{"pr_number": 381, "pr_title": "[563193] Capella Diagram Performance issues", "pr_createdAt": "2020-10-01T13:36:59Z", "pr_url": "https://github.com/eclipse/capella/pull/381", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTQ4OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498461488", "bodyText": "Collection directEvents = getElementToContainerCache(element);\nif (directEvents != null) {\n// if not present, compute it and put it in cache\ndirectEvents = getDirectEvents(element, instanceRole)\n}\nreturn directEvents.stream().filter(Execution)...", "author": "mPorhel", "createdAt": "2020-10-01T19:14:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1OTM5NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501059394", "bodyText": "Done", "author": "mPorhel", "createdAt": "2020-10-07T14:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTQ4OA=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nindex c0b9acc42..acce1cc73 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n\n@@ -12,20 +12,23 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.sirius.analysis;\n \n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n-\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Stack;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTYxOA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498461618", "bodyText": "Collection directEvents = getElementToContainerCache(element);\nif (directEvents != null) {\n// if not present, compute it and put it in cache\ndirectEvents = getDirectEvents(element, instanceRole)\n}\nreturn directEvents.stream().filter(State...)...", "author": "mPorhel", "createdAt": "2020-10-01T19:15:05Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1OTU3NQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501059575", "bodyText": "Done", "author": "mPorhel", "createdAt": "2020-10-07T14:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nindex c0b9acc42..acce1cc73 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n\n@@ -12,20 +12,23 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.sirius.analysis;\n \n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n-\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Stack;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjI2OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498466268", "bodyText": "You use the endToEventCache to retreive information that you did not put in the cache like ExecutionEnd -> Execution (finish of an eexcution when there is no return message : see timers and exchanges without return branch.", "author": "mPorhel", "createdAt": "2020-10-01T19:24:44Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Stack<EObject> ancestors = new Stack<EObject>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<EventContext>();\n+\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // cache StateFragment.start -> Execution and StateFragment.finish -> Execution\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, MessageEnd end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+      ancestors.push(container.get());\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, InteractionState end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, ExecutionEnd end) {\n+    Execution execution = end.getExecution();\n+    if (execution != null && end.getExecution().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), execution, true, ancestors.size() + 1));\n+      ancestors.push(execution);\n+    }\n+    if (execution != null && end.getExecution().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), execution, false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+        .filter(tl -> !(tl instanceof AbstractFragment));\n+    // scan timelapse only one time\n+    if (getEndToEventCache().isEmpty()) {\n+      timeLapses.forEach(e -> {\n+        if (e.getStart() instanceof MessageEnd) {\n+          putEndToEventCache(e.getStart(), e);", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2Mzc3OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501063778", "bodyText": "Done in further commit.\nendToEventCache renamed into interactionFragmentToTimeLapseCache and type changed from Map<InteractionFragment, CapellaElement> to Map<InteractionFragment, TimeLapse>.\nThis cache is now used only to store and retrieve the link from an InteractionFragment to a TimeLapse, this information exists with ExecutionEnd::execution but is missing between MEssageEnd and Execution and between InteractionState and StateFragment. The other way is defined in the M2 with TimeLapse::start and TimeLapse::finish references.", "author": "mPorhel", "createdAt": "2020-10-07T14:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NjI2OA=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nindex c0b9acc42..acce1cc73 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n\n@@ -12,20 +12,23 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.sirius.analysis;\n \n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n-\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Stack;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2Njg5Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498466897", "bodyText": "not sur that to understand how this  allows to retrieve the Excution/InstanceRole on which the Edge willbe connected", "author": "mPorhel", "createdAt": "2020-10-01T19:26:03Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NDMxNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501064317", "bodyText": "Replaced by computation of ReceivingEnd/SendingEnd based on the EventContext structure", "author": "mPorhel", "createdAt": "2020-10-07T14:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2Njg5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nindex c0b9acc42..acce1cc73 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n\n@@ -12,20 +12,23 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.sirius.analysis;\n \n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n-\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Stack;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NzQxNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498467414", "bodyText": "sending/receiving End ?\nif container isEmpty, this means that the messageEnd is not the start of the finish of an execution but the sendingEnd of the edge or the receiving end of the return branch.\nHere I see two solutions:\neither you use the endToEvent cache for this one to reference the \"getExecutionOfMessageEnd\", ie the Execution which will be the source of the edge (target of the return branch), but then your the mesage is not part of the structure.\nor you put  something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  putEndToEventCache(end, (CapellaElement) ancestors.peek());\n          \n          \n            \n                Message msg = end.getMessage();\n          \n          \n            \n                result.add(new EventContext(ancestors.peek(), msg, end.equals(msg.getStart()), ancestors.size() + 1));", "author": "mPorhel", "createdAt": "2020-10-01T19:27:13Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Stack<EObject> ancestors = new Stack<EObject>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<EventContext>();\n+\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // cache StateFragment.start -> Execution and StateFragment.finish -> Execution\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, MessageEnd end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+      ancestors.push(container.get());\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NTAxOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501065019", "bodyText": "Replaced with the creation of EventContext for every MessageEnd, see comments in code.", "author": "mPorhel", "createdAt": "2020-10-07T14:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NzQxNA=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nindex c0b9acc42..acce1cc73 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n\n@@ -12,20 +12,23 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.sirius.analysis;\n \n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n-\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Stack;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODcwNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498468704", "bodyText": "here I do not see how ancestor.peek()  would be the StateFragment of the InteractionState.\nStateFragment have no \"children\"\ncomputeTimeLapseStartAndEndCache is called before the calls to the visit method, so the cache is alreayd completed for InstractionState -> StateFragment\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  putEndToEventCache(end, (CapellaElement) ancestors.peek());", "author": "mPorhel", "createdAt": "2020-10-01T19:29:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,377 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Stack;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  /**\n+   * Return abstract end covered TimeLapse/InstanceRole.\n+   * \n+   * @param end\n+   *          AbstractEnd\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return TimeLapse\n+   */\n+  public static Optional<CapellaElement> getEvent(AbstractEnd end, InstanceRole instanceRole) {\n+    Optional<CapellaElement> timeLapse = getEndToEventCache(end);\n+    if (!timeLapse.isPresent()) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      // get TimeLapse from cache\n+      // if not present, compute it from EventContext structure\n+      Optional<EventContext> endEventContext = eventContexts.stream()\n+          .filter(eventContext -> end.equals(eventContext.getElement())).findFirst();\n+      if (endEventContext.isPresent() && endEventContext.get().getParent() instanceof CapellaElement) {\n+        putEndToEventCache(end, (CapellaElement) endEventContext.get().getParent());\n+      }\n+      timeLapse = getEndToEventCache(end);\n+    }\n+    return timeLapse;\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  private static List<EventContext> getEventContext(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      putInstanceRoleToEventContextCache(instanceRole, eventContexts);\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContext(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(eventContext -> eventContext.getElement()).filter(event -> event != element).distinct()\n+          .collect(Collectors.toList());\n+      putElementToContainerCache(element, directEvents);\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getElementToContainerCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Stack<EObject> ancestors = new Stack<EObject>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<EventContext>();\n+\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // cache StateFragment.start -> Execution and StateFragment.finish -> Execution\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, MessageEnd end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+      ancestors.push(container.get());\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof Execution\n+        && ((Execution) container.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Stack<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Stack<EObject> ancestors, List<EventContext> result, InteractionState end) {\n+    Optional<CapellaElement> container = getEndToEventCache(end);\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (container.isPresent() && container.get() instanceof StateFragment\n+        && ((StateFragment) container.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), container.get(), false, ancestors.size() + 1));\n+    }\n+    if (!container.isPresent()) {\n+      putEndToEventCache(end, (CapellaElement) ancestors.peek());", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NTQyMA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501065420", "bodyText": "LoC removed.", "author": "mPorhel", "createdAt": "2020-10-07T14:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2ODcwNA=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nindex c0b9acc42..acce1cc73 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n\n@@ -12,20 +12,23 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.sirius.analysis;\n \n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getEndToEventCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putElementToContainerCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putEndToEventCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextCache;\n-\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.Collections;\n+import java.util.Deque;\n import java.util.List;\n import java.util.Optional;\n-import java.util.Stack;\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODI1Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498478257", "bodyText": "I would have put:\nExecution exec = getEndToEvent(end);\n(by construction the start/finish is useless)\nif (exec != null)\nreturn  exec; (the execution/timer delimited by a message and its return branch)\nelse: need to find the exec which send/receive the edge : see eventContext message case.\nif no execution : instancerole must be returned.", "author": "mPorhel", "createdAt": "2020-10-01T19:50:25Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -141,69 +113,21 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     if (end == null) {\n       return message; // found message case\n     }\n-\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getFinish() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-\n-    return execution == null ? end.getCovered() : execution;\n+    return getExecutionOrCoveredOfMessageEnd(end);", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NTgzNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501065834", "bodyText": "Computation is now based on EventContext structure.", "author": "mPorhel", "createdAt": "2020-10-07T14:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODI1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\nindex 9b039eb54..f623a7c18 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n\n@@ -112,22 +111,28 @@ public class SequenceDiagramServices {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n+    } else {\n+      InstanceRole currentInstanceRole = currentInstanceRole(end);\n+      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n+\n+      Optional<EventContext> sendingEvent = eventContexts.stream()\n+          .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n+      return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n     }\n-    return getExecutionOrCoveredOfMessageEnd(end);\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n-    }\n-    return getExecutionOrCoveredOfMessageEnd(end);\n-  }\n+    } else {\n+      InstanceRole currentInstanceRole = currentInstanceRole(end);\n+      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n \n-  private static EObject getExecutionOrCoveredOfMessageEnd(MessageEnd end) {\n-    Optional<CapellaElement> execution = EventContextServices.getEvent(end, currentInstanceRole(end));\n-    // null never happen\n-    return execution.isPresent() ? execution.get() : null;\n+      Optional<EventContext> receivingEvent = eventContexts.stream()\n+          .filter(ec -> !ec.isStart() && ec.getElement().equals(message)).findFirst();\n+      return receivingEvent.isPresent() ? receivingEvent.get().getParent() : currentInstanceRole;\n+    }\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODQzNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498478435", "bodyText": "see previous comment, I am not sure that the getEvent is the food solution here.", "author": "mPorhel", "createdAt": "2020-10-01T19:50:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -141,69 +113,21 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     if (end == null) {\n       return message; // found message case\n     }\n-\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getFinish() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-\n-    return execution == null ? end.getCovered() : execution;\n+    return getExecutionOrCoveredOfMessageEnd(end);\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n     }\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getStart() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-    return execution == null ? end.getCovered() : execution;\n+    return getExecutionOrCoveredOfMessageEnd(end);\n   }\n \n-  /**\n-   * return the execution which start the messageEnd taken in parameter.\n-   * \n-   * @param end\n-   * @return\n-   */\n-  private static Execution getExecutionOfMessageEnd(MessageEnd end) {\n-    Scenario scenario = getScenario(end);\n-    InstanceRole currentIR = end.getCovered();\n-    List<Execution> executionStack = new ArrayList<Execution>();\n-    for (InteractionFragment ifgt : scenario.getOwnedInteractionFragments()) {\n-      if (ifgt instanceof AbstractEnd) {\n-        AbstractEnd ae = (AbstractEnd) ifgt;\n-        if (ae.getCovered() == currentIR) {\n-          // if ae starts an exception, the execution is stacked\n-          // if ae ends an exception, the execution is unstacked\n-          for (TimeLapse laptime : scenario.getOwnedTimeLapses()) {\n-            if (laptime instanceof Execution) {\n-              Execution execution = (Execution) laptime;\n-              if (execution.getCovered() == currentIR) {\n-                if (execution.getStart() == ae) {\n-                  executionStack.add(execution);\n-                }\n-                if (execution.getFinish() == ae) {\n-                  executionStack.remove(execution);\n-                }\n-              }\n-            }\n-          }\n-          if (ae == end) {\n-            return top(executionStack);\n-          }\n-        }\n-      }\n-    }\n-    return null;\n+  private static EObject getExecutionOrCoveredOfMessageEnd(MessageEnd end) {\n+    Optional<CapellaElement> execution = EventContextServices.getEvent(end, currentInstanceRole(end));\n+    // null never happen\n+    return execution.isPresent() ? execution.get() : null;", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NjA4Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501066086", "bodyText": "Computation is now based on EventContext structure.", "author": "mPorhel", "createdAt": "2020-10-07T14:37:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3ODQzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\nindex 9b039eb54..f623a7c18 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n\n@@ -112,22 +111,28 @@ public class SequenceDiagramServices {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n+    } else {\n+      InstanceRole currentInstanceRole = currentInstanceRole(end);\n+      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n+\n+      Optional<EventContext> sendingEvent = eventContexts.stream()\n+          .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n+      return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n     }\n-    return getExecutionOrCoveredOfMessageEnd(end);\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n-    }\n-    return getExecutionOrCoveredOfMessageEnd(end);\n-  }\n+    } else {\n+      InstanceRole currentInstanceRole = currentInstanceRole(end);\n+      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n \n-  private static EObject getExecutionOrCoveredOfMessageEnd(MessageEnd end) {\n-    Optional<CapellaElement> execution = EventContextServices.getEvent(end, currentInstanceRole(end));\n-    // null never happen\n-    return execution.isPresent() ? execution.get() : null;\n+      Optional<EventContext> receivingEvent = eventContexts.stream()\n+          .filter(ec -> !ec.isStart() && ec.getElement().equals(message)).findFirst();\n+      return receivingEvent.isPresent() ? receivingEvent.get().getParent() : currentInstanceRole;\n+    }\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ3OTg2Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498479867", "bodyText": "I would put this change in a releng commit to format the class before this commit", "author": "mPorhel", "createdAt": "2020-10-01T19:54:03Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -276,16 +200,16 @@ private static void reorderInteractionFragment(Scenario scenario, InteractionFra\n     int currentFragmentIndex = -1;\n     if (currentFragment != null) {\n       currentFragmentIndex = scenario.getOwnedInteractionFragments().indexOf(currentFragment);\n-    int currentIndexNewPredecessor = -1;\n-    if (newPredecessor != null) {\n-      currentIndexNewPredecessor = scenario.getOwnedInteractionFragments().indexOf(newPredecessor);\n-    }\n+      int currentIndexNewPredecessor = -1;\n+      if (newPredecessor != null) {\n+        currentIndexNewPredecessor = scenario.getOwnedInteractionFragments().indexOf(newPredecessor);\n+      }", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MDY1OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498480658", "bodyText": "It is a cache from InstanceRole/Execution to list fo children  (Execution/StateFragment)\neventToSubEventsCache ?", "author": "mPorhel", "createdAt": "2020-10-01T19:55:44Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, CapellaElement> endToEventCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> elementToContainerCache = new ConcurrentHashMap<>();\n+", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzA0Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501067043", "bodyText": "elementToContainerCache renamed into directEventsCache.\nIt could have been named directChildrenTimeLapseCache.", "author": "mPorhel", "createdAt": "2020-10-07T14:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MDY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\nindex 30bb24a86..53da9aac5 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n\n@@ -21,13 +21,14 @@ import java.util.function.Function;\n \n import org.eclipse.emf.ecore.EObject;\n import org.eclipse.sirius.diagram.DDiagram;\n-import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n import org.polarsys.capella.core.data.helpers.cache.Cache;\n import org.polarsys.capella.core.data.interaction.InstanceRole;\n import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n \n-public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+public class InteractionRefreshExtension implements IRefreshExtension {\n \n   /**\n    * Generic cache (basically for getCovered).\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTIwNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498481207", "bodyText": "Should not we activate the cache from here", "author": "mPorhel", "createdAt": "2020-10-01T19:56:57Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, CapellaElement> endToEventCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> elementToContainerCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextCache = new ConcurrentHashMap<InstanceRole, List<EventContext>>();\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+    super.beforeRefresh(diagram);", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MzUzNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498483537", "bodyText": "cacheGetter could return null is cache is not enabled and put method would do nothing (but current implementations which do put and then get would need to be reworked)", "author": "mPorhel", "createdAt": "2020-10-01T20:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzM5Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501067397", "bodyText": "Done", "author": "mPorhel", "createdAt": "2020-10-07T14:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\nindex 30bb24a86..53da9aac5 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n\n@@ -21,13 +21,14 @@ import java.util.function.Function;\n \n import org.eclipse.emf.ecore.EObject;\n import org.eclipse.sirius.diagram.DDiagram;\n-import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n import org.polarsys.capella.core.data.helpers.cache.Cache;\n import org.polarsys.capella.core.data.interaction.InstanceRole;\n import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n \n-public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+public class InteractionRefreshExtension implements IRefreshExtension {\n \n   /**\n    * Generic cache (basically for getCovered).\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTY4Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498481682", "bodyText": "clear + disable cache ?\nThe scope the cache would only be the refresh/\nWe would need to checkthe VSM to checkthat the tools do not use the services.\nThe cache is emptied for the lists but interactionCache remains active, it should be disabled to let tools properly work.", "author": "mPorhel", "createdAt": "2020-10-01T19:57:53Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, CapellaElement> endToEventCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> elementToContainerCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextCache = new ConcurrentHashMap<InstanceRole, List<EventContext>>();\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+    super.beforeRefresh(diagram);\n+  }\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void postRefresh(DDiagram diagram) {\n+    interactionCache.clearCache();", "originalCommit": "b1945eb20b44c4a0737c592de5007e69190fc235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzU5MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501067590", "bodyText": "done", "author": "mPorhel", "createdAt": "2020-10-07T14:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ4MTY4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\nindex 30bb24a86..53da9aac5 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n\n@@ -21,13 +21,14 @@ import java.util.function.Function;\n \n import org.eclipse.emf.ecore.EObject;\n import org.eclipse.sirius.diagram.DDiagram;\n-import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n import org.polarsys.capella.core.data.helpers.cache.Cache;\n import org.polarsys.capella.core.data.interaction.InstanceRole;\n import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n \n-public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtension {\n+public class InteractionRefreshExtension implements IRefreshExtension {\n \n   /**\n    * Generic cache (basically for getCovered).\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1Mjg3Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498952876", "bodyText": "diagram ?", "author": "mPorhel", "createdAt": "2020-10-02T17:25:24Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java", "diffHunk": "@@ -19,24 +19,24 @@\n \n public class InteractionRefreshExtensionProvider implements IRefreshExtensionProvider {\n \n-    private static final InteractionRefreshExtension REFRESH_EXTENSION = new InteractionRefreshExtension();\n+  private static final InteractionRefreshExtension REFRESH_EXTENSION = new InteractionRefreshExtension();\n \n-    public InteractionRefreshExtensionProvider() {\n-        // empty constructor\n-    }\n+  public InteractionRefreshExtensionProvider() {\n+    // empty constructor\n+  }\n \n-    /**\n-     * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#getRefreshExtension(org.eclipse.sirius.DDiagram)\n-     */\n-    public IRefreshExtension getRefreshExtension(DDiagram viewPoint_p) {\n-        return REFRESH_EXTENSION;\n-    }\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#getRefreshExtension(org.eclipse.sirius.DDiagram)\n+   */\n+  public IRefreshExtension getRefreshExtension(DDiagram viewPoint) {\n+    return REFRESH_EXTENSION;\n+  }\n \n-    /**\n-     * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#provides(org.eclipse.sirius.DDiagram)\n-     */\n-    public boolean provides(DDiagram viewPoint_p) {\n-        return viewPoint_p instanceof SequenceDDiagram;\n-    }\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#provides(org.eclipse.sirius.DDiagram)\n+   */\n+  public boolean provides(DDiagram viewPoint) {", "originalCommit": "a6cdaea6053b6df2111535c8961d12fb2b561c78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2ODc5Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501068796", "bodyText": "done", "author": "mPorhel", "createdAt": "2020-10-07T14:41:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1Mjg3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java\nindex 55ebb52b1..355296add 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java\n\n@@ -28,15 +28,15 @@ public class InteractionRefreshExtensionProvider implements IRefreshExtensionPro\n   /**\n    * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#getRefreshExtension(org.eclipse.sirius.DDiagram)\n    */\n-  public IRefreshExtension getRefreshExtension(DDiagram viewPoint) {\n+  public IRefreshExtension getRefreshExtension(DDiagram diagram) {\n     return REFRESH_EXTENSION;\n   }\n \n   /**\n    * @see org.eclipse.sirius.business.api.refresh.IRefreshExtensionProvider#provides(org.eclipse.sirius.DDiagram)\n    */\n-  public boolean provides(DDiagram viewPoint) {\n-    return viewPoint instanceof SequenceDDiagram;\n+  public boolean provides(DDiagram diagram) {\n+    return diagram instanceof SequenceDDiagram;\n   }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDIxNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498954215", "bodyText": "We could condition the putxxxCache method to have an effect only in this instead of check theisCacheEnabled value everywhere.\nTeh need to have the isCacheEnabledMethod would be less usefull.", "author": "mPorhel", "createdAt": "2020-10-02T17:28:06Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -65,7 +69,7 @@ public void beforeRefresh(DDiagram diagram) {\n   @Override\n   public void postRefresh(DDiagram diagram) {\n     clearCaches();\n-    super.postRefresh(diagram);\n+    isCacheEnabled = false;", "originalCommit": "a6cdaea6053b6df2111535c8961d12fb2b561c78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk2MTU2Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r498961562", "bodyText": "If we remove the super.beforeRefresh / afterRefresh method could you confirm that there is another extension which enable the ModelCache during the SequenceDDiagram refresh ?\nIf there is another extension doing this, we can remove the superbeforeR/afterR methods but in this case we should also remove the inheritance to the AbstractCacheAwareRefreshExtension.\nIt seems that the TitleBlockRefreshExtensionProvider is enabled for every diagram.", "author": "mPorhel", "createdAt": "2020-10-02T17:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA3MzAzNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r501073035", "bodyText": "done", "author": "mPorhel", "createdAt": "2020-10-07T14:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk1NDIxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d06008bf95006a89f25657e20ddc00404c421075", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\nindex 3ceb85ab4..53da9aac5 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n\n@@ -69,14 +70,14 @@ public class InteractionRefreshExtension extends AbstractCacheAwareRefreshExtens\n   @Override\n   public void postRefresh(DDiagram diagram) {\n     clearCaches();\n-    isCacheEnabled = false;\n+    disableRefreshCache();\n   }\n \n   private void clearCaches() {\n     interactionCache.clearCache();\n-    elementToContainerCache.clear();\n-    instanceRoleToEventContextCache.clear();\n-    endToEventCache.clear();\n+    directEventsCache.clear();\n+    instanceRoleToEventContextsCache.clear();\n+    interactionFragmentToTimeLapseCache.clear();\n   }\n \n   /**\n"}}, {"oid": "d06008bf95006a89f25657e20ddc00404c421075", "url": "https://github.com/eclipse/capella/commit/d06008bf95006a89f25657e20ddc00404c421075", "message": "[563193] Capella Diagram Performance issues\n\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-08T10:40:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwODg0MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505608840", "bodyText": "Maybe AbstractFragment could be taken into account in a future enhancement since it's absolutely suitable to use the same logic of EventContext to process elements such as CombinedFragment and InteractionUse.", "author": "minhtutonthat", "createdAt": "2020-10-15T14:53:55Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNDM3Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507714373", "bodyText": "Yes and no : all interactionUse and combinedFragments are direct DNodeContainder children of the SequenceDDiagram, there is no complexitiy to find and compute them. Then it is the SequenceLayout and the editParts which takes them and plays with the zOrder and layout constraints to place them.\nFor execution and states, we need all this logic in order to compute the DNode structure as each level of execution/state nodes are bordered nodes of the parent level. (The lifeline itself is a border node of the InstanceRole figure).", "author": "mPorhel", "createdAt": "2020-10-19T12:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwODg0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIzNDA5Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r509234092", "bodyText": "Ok i see", "author": "minhtutonthat", "createdAt": "2020-10-21T12:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwODg0MA=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwOTA4Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505609086", "bodyText": "For IR2?", "author": "minhtutonthat", "createdAt": "2020-10-15T14:54:15Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: ", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMTIxMA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507711210", "bodyText": "IR2", "author": "mPorhel", "createdAt": "2020-10-19T12:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYwOTA4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505610519", "bodyText": "Could you remove the unnecessary else clause?", "author": "minhtutonthat", "createdAt": "2020-10-15T14:55:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -140,70 +111,28 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n-    }\n+    } else {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNTU4Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507715587", "bodyText": "It is not unnecessary, it corresponds to all the logic ..\nSorry, ok, style issue, as you want.", "author": "mPorhel", "createdAt": "2020-10-19T12:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzc0NDE1Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507744156", "bodyText": "In our Dev environment, without the \"else\", we have a Checsktyle warning.", "author": "mPorhel", "createdAt": "2020-10-19T13:26:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIzNTAxNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r509235016", "bodyText": "In our dev environment Sonar checks this kind of rule :)", "author": "minhtutonthat", "createdAt": "2020-10-21T12:27:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMDUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\nindex f623a7c18..68db63bf4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n\n@@ -111,28 +111,28 @@ public class SequenceDiagramServices {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n-    } else {\n-      InstanceRole currentInstanceRole = currentInstanceRole(end);\n-      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n-\n-      Optional<EventContext> sendingEvent = eventContexts.stream()\n-          .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n-      return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n     }\n+    InstanceRole currentInstanceRole = currentInstanceRole(end);\n+    List<EventContext> eventContexts = ScenarioCache.getInstance().getEventContexts(currentInstanceRole);\n+\n+    Optional<EventContext> sendingEvent = eventContexts.stream()\n+        .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n+    return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n+\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n-    } else {\n-      InstanceRole currentInstanceRole = currentInstanceRole(end);\n-      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n-\n-      Optional<EventContext> receivingEvent = eventContexts.stream()\n-          .filter(ec -> !ec.isStart() && ec.getElement().equals(message)).findFirst();\n-      return receivingEvent.isPresent() ? receivingEvent.get().getParent() : currentInstanceRole;\n     }\n+    InstanceRole currentInstanceRole = currentInstanceRole(end);\n+    List<EventContext> eventContexts = ScenarioCache.getInstance().getEventContexts(currentInstanceRole);\n+\n+    Optional<EventContext> receivingEvent = eventContexts.stream()\n+        .filter(ec -> !ec.isStart() && ec.getElement().equals(message)).findFirst();\n+    return receivingEvent.isPresent() ? receivingEvent.get().getParent() : currentInstanceRole;\n+\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMTA1MQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r505611051", "bodyText": "Similary, could you remove the else clause plz?", "author": "minhtutonthat", "createdAt": "2020-10-15T14:56:25Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java", "diffHunk": "@@ -140,70 +111,28 @@ public static EObject getSendingEnd(SequenceMessage message) {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n-    }\n+    } else {\n+      InstanceRole currentInstanceRole = currentInstanceRole(end);\n+      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n \n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getFinish() == end) {\n-        return exec;\n-      }\n+      Optional<EventContext> sendingEvent = eventContexts.stream()\n+          .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n+      return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n     }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-\n-    return execution == null ? end.getCovered() : execution;\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n-    }\n-    Scenario sc = (Scenario) message.eContainer();\n-    for (TimeLapse exec : sc.getOwnedTimeLapses()) {\n-      if (exec.getStart() == end) {\n-        return exec;\n-      }\n-    }\n-    Execution execution = getExecutionOfMessageEnd(end);\n-    return execution == null ? end.getCovered() : execution;\n-  }\n+    } else {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxNTY0OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507715648", "bodyText": "ok", "author": "mPorhel", "createdAt": "2020-10-19T12:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYxMTA1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\nindex f623a7c18..68db63bf4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/SequenceDiagramServices.java\n\n@@ -111,28 +111,28 @@ public class SequenceDiagramServices {\n     MessageEnd end = message.getSendingEnd();\n     if (end == null) {\n       return message; // found message case\n-    } else {\n-      InstanceRole currentInstanceRole = currentInstanceRole(end);\n-      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n-\n-      Optional<EventContext> sendingEvent = eventContexts.stream()\n-          .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n-      return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n     }\n+    InstanceRole currentInstanceRole = currentInstanceRole(end);\n+    List<EventContext> eventContexts = ScenarioCache.getInstance().getEventContexts(currentInstanceRole);\n+\n+    Optional<EventContext> sendingEvent = eventContexts.stream()\n+        .filter(ec -> ec.isStart() && ec.getElement().equals(message)).findFirst();\n+    return sendingEvent.isPresent() ? sendingEvent.get().getParent() : currentInstanceRole;\n+\n   }\n \n   public static EObject getReceivingEnd(SequenceMessage message) {\n     MessageEnd end = message.getReceivingEnd();\n     if (end == null) {\n       return message; // lost message case\n-    } else {\n-      InstanceRole currentInstanceRole = currentInstanceRole(end);\n-      List<EventContext> eventContexts = EventContextServices.getEventContexts(currentInstanceRole);\n-\n-      Optional<EventContext> receivingEvent = eventContexts.stream()\n-          .filter(ec -> !ec.isStart() && ec.getElement().equals(message)).findFirst();\n-      return receivingEvent.isPresent() ? receivingEvent.get().getParent() : currentInstanceRole;\n     }\n+    InstanceRole currentInstanceRole = currentInstanceRole(end);\n+    List<EventContext> eventContexts = ScenarioCache.getInstance().getEventContexts(currentInstanceRole);\n+\n+    Optional<EventContext> receivingEvent = eventContexts.stream()\n+        .filter(ec -> !ec.isStart() && ec.getElement().equals(message)).findFirst();\n+    return receivingEvent.isPresent() ? receivingEvent.get().getParent() : currentInstanceRole;\n+\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ0NTMxNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506445316", "bodyText": "This class has a misleading name and location. This is not really a service (in the capella service sense), it is more a cache than a service.\n\nRename this class to ScenarioCache, make it a singleton and and move it to capella.core.sirius.analysis.cache.\nMove all of the caches (interactionCache, interactionFragmentToTimeLapseCache and all the others) and all the methods from the InteractionRefreshExtension to this ScenarioCache.\nThe InteractionRefreshExtension will only have an reference to the new ScenarioCache and activate/deactivate it.\nThe real services like ScenarioService will use the methods from the ScenarioCache.", "author": "sandupostaru", "createdAt": "2020-10-16T13:51:08Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ1OTAwNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506459006", "bodyText": "Preambule:\nThank you for the contribution. The new caching system seems cool and I can see the benefits from this change \ud83d\udc4d\nMy comments ones are mostly related to style, class location, variable naming conventions and are not all that functional except for a few. Don't hesitate to come back to me if you need more details.", "author": "sandupostaru", "createdAt": "2020-10-16T14:03:02Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sequencediag/ScenarioService.java", "diffHunk": "@@ -88,6 +86,7 @@\n import org.polarsys.capella.core.model.helpers.queries.QueryIdentifierConstants;\n import org.polarsys.capella.core.model.helpers.queries.filters.OnlySharedDataOrEventOrUnsetFilter;\n import org.polarsys.capella.core.sirius.analysis.CapellaServices;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices;", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sequencediag/ScenarioService.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sequencediag/ScenarioService.java\nindex d8ba5f49f..24d1c1f24 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sequencediag/ScenarioService.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sequencediag/ScenarioService.java\n\n@@ -86,10 +86,10 @@ import org.polarsys.capella.core.model.helpers.SequenceMessageExt;\n import org.polarsys.capella.core.model.helpers.queries.QueryIdentifierConstants;\n import org.polarsys.capella.core.model.helpers.queries.filters.OnlySharedDataOrEventOrUnsetFilter;\n import org.polarsys.capella.core.sirius.analysis.CapellaServices;\n-import org.polarsys.capella.core.sirius.analysis.EventContextServices;\n import org.polarsys.capella.core.sirius.analysis.IMappingNameConstants;\n import org.polarsys.capella.core.sirius.analysis.InformationServices;\n import org.polarsys.capella.core.sirius.analysis.SequenceDiagramServices;\n+import org.polarsys.capella.core.sirius.analysis.cache.ScenarioCache;\n \n import com.google.common.base.Predicate;\n import com.google.common.base.Predicates;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NDYyNw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506464627", "bodyText": "The name of this class is confusing. There is already an Event class in Capella that has different meaning.\nA more suitable name  would be Sibling because this class contains siblings of InstanceRoles (closely related elements).\nAn sibling contains a parent which can be used to filter the children.", "author": "sandupostaru", "createdAt": "2020-10-16T14:07:30Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));\n+      timeLapses.forEach(e -> {\n+        // Keep Interaction to TimeLapse info in cache\n+        // M2 allows to retrieve an Execution from an ExecutionEnd (execution.getFinish() when there is no\n+        // return branch : ASyncCall)\n+        // but not an Execution from a MessagEnd (SyncCall and ASyncCall) or a StateFragment from an\n+        // InteractionState.\n+        putTimeLapseInCache(e.getStart(), e);\n+        putTimeLapseInCache(e.getFinish(), e);\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Helper class to keep track of who \"contains\" who depending on the interleaving of the start/finish ends.\n+   * \n+   * @author pcdavid\n+   */\n+  public static final class EventContext {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwMDg3OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507700879", "bodyText": "Hi Sandu,\nWe kept Event,  EventContext and EventEnd as this is has a meaning in the Sirius Sequence diagram (used in layout, internal api ISequenceEvent), it was really helpfull in debug to have the same wording than in Sirius (refresh, layout) and not new vocabulary.\nIt was also a way to be sure to avoid to reuse TimeLapse, Fragments, ...", "author": "mPorhel", "createdAt": "2020-10-19T12:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NDYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM2ODMwOA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r508368308", "bodyText": "Hi Sandu.\nAfter discussion with Philippe, it is ok to rename the EventContext into something else, to avoid confusion with the \"event\" from the Capella M2 to help the maintainers of this code, but \"sibling\" does not look appropriate:\n\ndefinition of sibling: each of two or more children or offspring having one or both parents in common; a brother or sister.\n\nIMO, we should try to find another name, as the EventContext elements are not just siblings under the same parent, but their organization represents the hierarchical tree of Executions/States on the diagram and the structure is used from the VSM to build/find the semantic candidates for level/depth in evaluation of the mappings's expression during the SequenceDDiagram refresh.", "author": "mPorhel", "createdAt": "2020-10-20T09:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NDYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NjU3OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506466579", "bodyText": "change to child", "author": "sandupostaru", "createdAt": "2020-10-16T14:08:54Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));\n+      timeLapses.forEach(e -> {\n+        // Keep Interaction to TimeLapse info in cache\n+        // M2 allows to retrieve an Execution from an ExecutionEnd (execution.getFinish() when there is no\n+        // return branch : ASyncCall)\n+        // but not an Execution from a MessagEnd (SyncCall and ASyncCall) or a StateFragment from an\n+        // InteractionState.\n+        putTimeLapseInCache(e.getStart(), e);\n+        putTimeLapseInCache(e.getFinish(), e);\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Helper class to keep track of who \"contains\" who depending on the interleaving of the start/finish ends.\n+   * \n+   * @author pcdavid\n+   */\n+  public static final class EventContext {\n+    private final EObject parent;\n+\n+    private final boolean start;\n+\n+    private final EObject element;", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwMTMyNA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507701324", "bodyText": "I am not sure, this is really the current element for which we want the parent.\nChild would be used if we wanted to compute the children of element.", "author": "mPorhel", "createdAt": "2020-10-19T12:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2NjU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2Njg2OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506466868", "bodyText": "getChild", "author": "sandupostaru", "createdAt": "2020-10-16T14:09:07Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+    // Should not happen in current implementation of Capella Sequence diagrams\n+    if (timeLapse.isPresent() && timeLapse.get().getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Execution without return branch end / ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get().getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Return covered instance role.\n+   * \n+   * @param end\n+   *          InteractionFragment\n+   * @return covered instance role.\n+   */\n+  private static InstanceRole getCoveredInstanceRole(InteractionFragment end) {\n+    InstanceRole covered = null;\n+    if (end instanceof AbstractEnd) {\n+      covered = getInteractionCache(AbstractEnd::getCovered, (AbstractEnd) end);\n+    } else if (end instanceof InteractionState) {\n+      covered = getInteractionCache(InteractionState::getCovered, (InteractionState) end);\n+    }\n+    return covered;\n+  }\n+\n+  /**\n+   * Compute cache for TimeLapse start and finish ends.\n+   * \n+   * @param scenario\n+   *          Scenario\n+   */\n+  private static void computeTimeLapseStartAndEndCache(Scenario scenario) {\n+    // cache Execution.start -> Execution and Execution.finish -> Execution\n+    // scan timelapse only one time\n+    if (getInteractionFragmentToTimeLapseCache().isEmpty()) {\n+      Stream<TimeLapse> timeLapses = scenario.getOwnedTimeLapses().stream()\n+          .filter(tl -> !(tl instanceof AbstractFragment));\n+      timeLapses.forEach(e -> {\n+        // Keep Interaction to TimeLapse info in cache\n+        // M2 allows to retrieve an Execution from an ExecutionEnd (execution.getFinish() when there is no\n+        // return branch : ASyncCall)\n+        // but not an Execution from a MessagEnd (SyncCall and ASyncCall) or a StateFragment from an\n+        // InteractionState.\n+        putTimeLapseInCache(e.getStart(), e);\n+        putTimeLapseInCache(e.getFinish(), e);\n+      });\n+    }\n+  }\n+\n+  /**\n+   * Helper class to keep track of who \"contains\" who depending on the interleaving of the start/finish ends.\n+   * \n+   * @author pcdavid\n+   */\n+  public static final class EventContext {\n+    private final EObject parent;\n+\n+    private final boolean start;\n+\n+    private final EObject element;\n+\n+    private final int level;\n+\n+    public EventContext(EObject parent, EObject element, boolean start, int level) {\n+      this.parent = parent;\n+      this.element = element;\n+      this.level = level;\n+      this.start = start;\n+    }\n+\n+    public boolean isStart() {\n+      return start;\n+    }\n+\n+    public EObject getParent() {\n+      return parent;\n+    }\n+\n+    public EObject getElement() {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ2OTU2OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506469569", "bodyText": "rename to getSiblings (see my comment on the renaming of the EventContext class)", "author": "sandupostaru", "createdAt": "2020-10-16T14:11:22Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3MDQ2Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506470467", "bodyText": "make this method private and rename to getSiblingChildren", "author": "sandupostaru", "createdAt": "2020-10-16T14:12:11Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3MTEzMg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506471132", "bodyText": "Rename element to parent and change the order of the parameters, instanceRole comes first, parent second", "author": "sandupostaru", "createdAt": "2020-10-16T14:12:47Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTI2Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506479263", "bodyText": "This code block  does not serve any purpose, since the getDirectEvents() at line 122 already does verify if the information is available in the cache. This block should thus be removed.", "author": "sandupostaru", "createdAt": "2020-10-16T14:22:42Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwOTYxNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507709615", "bodyText": "this code filters the directEvents and return only the executions.", "author": "mPorhel", "createdAt": "2020-10-19T12:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTI2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTQ3Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506479472", "bodyText": "This code block  does not serve any purpose, since the getDirectEvents() at line 143 already does verify if the information is available in the cache. This block should thus be removed.", "author": "sandupostaru", "createdAt": "2020-10-16T14:22:57Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMDIwMw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507710203", "bodyText": "the code block filters direct events found in cache to return the state elements.", "author": "mPorhel", "createdAt": "2020-10-19T12:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTQ3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMDUzNQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507710535", "bodyText": "the line 143, compute the directs event, put them in cache and then we filter the result from here.", "author": "mPorhel", "createdAt": "2020-10-19T12:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ3OTQ3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MDUyMw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506480523", "bodyText": "rename to getSiblingExecutions, change parameter order and rename element to parent", "author": "sandupostaru", "createdAt": "2020-10-16T14:24:12Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MDc2NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506480764", "bodyText": "rename to getSiblingStateFragments, change parameter order and rename element to parent", "author": "sandupostaru", "createdAt": "2020-10-16T14:24:33Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MjA3MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506482070", "bodyText": "rename to computeSiblings", "author": "sandupostaru", "createdAt": "2020-10-16T14:26:03Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MjU0OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506482549", "bodyText": "rename to siblings", "author": "sandupostaru", "createdAt": "2020-10-16T14:26:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4Mjk4MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506482980", "bodyText": "rename to interactionFragments", "author": "sandupostaru", "createdAt": "2020-10-16T14:26:53Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MzM5Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506483392", "bodyText": "rename to interactionFragment", "author": "sandupostaru", "createdAt": "2020-10-16T14:27:19Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4MzgyMw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506483823", "bodyText": "coveredInstanceRole", "author": "sandupostaru", "createdAt": "2020-10-16T14:27:42Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NDk0Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506484942", "bodyText": "check right away if timelapse is null / present here and thus avoid checking it in each of the visitMethods", "author": "sandupostaru", "createdAt": "2020-10-16T14:28:40Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcxMTg3NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507711874", "bodyText": "the visit (Message) case will do something even if there is no attached timelapse.", "author": "mPorhel", "createdAt": "2020-10-19T12:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NDk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NTc5MQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506485791", "bodyText": "See the comments for each of the visit methods", "author": "sandupostaru", "createdAt": "2020-10-16T14:29:27Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4NzI3OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506487279", "bodyText": "rename to ComputeSiblings\nChange the order of the arguments and their name like so:\ncomputeSiblings(ancestors, timelapse->child , end -> executionEnd/state/messageEnd [depending on the method], result -> siblings)", "author": "sandupostaru", "createdAt": "2020-10-16T14:30:52Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4ODE1Mg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506488152", "bodyText": "same remark as above", "author": "sandupostaru", "createdAt": "2020-10-16T14:31:43Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ4ODMzOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506488339", "bodyText": "same remark as above", "author": "sandupostaru", "createdAt": "2020-10-16T14:31:51Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in\n+        //\n+        //     | IR1 |   | IR2 ]   | IR3 ] \n+        //        |         |         |\n+        //        |         |         |\n+        //        |-------> -         |   e1  m1\n+        //        |        | |------> -   e2  m2\n+        //        |        | |       | |\n+        //        |        | - <-----| |  e3  m3\n+        //        |        || |      | |\n+        //        |        || |      | |\n+        //        |        | - ----->| |      return_m3\n+        //        |        | |       | |\n+        //        |<------- -        | |      return_m1\n+        //        |         |         - \n+        //        |         |         | \n+        \n+        // would result the following structures:\n+        \n+        //  For IR1: \n+        //   EventContext(IR1, m1, true, 1)\n+        //   EventContext(IR1, return_m1, false, 1)\n+        //\n+        //  For IR1: \n+        //   EventContext(IR2, e1, true, 2)\n+        //   EventContext(e1, m1, false, 2)\n+        //   EventContext(e1, m2, true, 2)\n+        //   EventContext(e1, e3, true, 3)\n+        //   EventContext(e3, m3, false, 3)\n+        //   EventContext(e3, return_m3, true, 3)\n+        //   EventContext(e1, e3, false, 3)\n+        //   EventContext(e1, return_m1 true, 2)\n+        //   EventContext(IR2, e1, false, 2)\n+        //\n+        //  For IR3: \n+        //   EventContext(IR3, e3, true, 2)\n+        //   EventContext(e3, m2, false, 2)\n+        //   EventContext(IR3, e3, false, 2)\n+        // @formatter:on\n+  }\n+\n+  /**\n+   * Compute EventStructure for InteractionState.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          InteractionState\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, InteractionState end,\n+      Optional<TimeLapse> timeLapse) {\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+    }\n+\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof StateFragment\n+        && ((StateFragment) timeLapse.get()).getFinish() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+  }\n+\n+  /**\n+   * Compute EventStructure for ExecutionEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          ExecutionEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, ExecutionEnd end,", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5MzQxOQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506493419", "bodyText": "not needed since null check is moved in calling method", "author": "sandupostaru", "createdAt": "2020-10-16T14:36:53Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NDA1Mw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506494053", "bodyText": "Thanks for the explication, this is nice \ud83d\udc4d", "author": "sandupostaru", "createdAt": "2020-10-16T14:37:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java", "diffHunk": "@@ -0,0 +1,414 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis;\n+\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n+import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+\n+/**\n+ * Compute EventContext structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class EventContextServices {\n+\n+  private EventContextServices() {\n+    super();\n+  }\n+\n+  /**\n+   * Compute EventContext structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getEventContexts(InstanceRole instanceRole) {\n+    List<EventContext> eventContexts = getInstanceRoleToEventContextCache(instanceRole);\n+    if (eventContexts == null) {\n+      eventContexts = computeInstanceRoleEventContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToEventContextsCache(instanceRole, eventContexts);\n+      }\n+    }\n+    return eventContexts;\n+  }\n+\n+  /**\n+   * Get direct event on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution children +\n+   * StateFragment)\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEvents(EObject element, InstanceRole instanceRole) {\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents == null) {\n+      // compute result from EventContext structure\n+      List<EventContext> eventContexts = getEventContexts(instanceRole);\n+\n+      directEvents = eventContexts.stream().filter(eventContext -> element.equals(eventContext.getParent()))\n+          .map(EventContext::getElement).filter(event -> event != element).distinct().collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putDirectEventsInCache(element, directEvents);\n+      }\n+    }\n+    return directEvents;\n+  }\n+\n+  /**\n+   * Get Execution direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<Execution> getExecutionDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get executions from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(Execution.class::isInstance).map(Execution.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment direct events on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public static List<StateFragment> getStateFragmentDirectEvents(EObject element, InstanceRole instanceRole) {\n+    // get states from cache\n+    Collection<EObject> directEvents = getDirectEventsFromCache(element);\n+    if (directEvents != null) {\n+      return directEvents.stream().filter(StateFragment.class::isInstance).map(StateFragment.class::cast)\n+          .collect(Collectors.toList());\n+    }\n+    // if not present, compute it and put it in cache\n+    return getDirectEvents(element, instanceRole).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute EventContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> computeInstanceRoleEventContextStructure(InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<EventContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> ends = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    ends.forEachOrdered(end -> {\n+      InstanceRole covered = getCoveredInstanceRole(end);\n+      if (covered != null && covered.equals(instanceRole)) {\n+        Optional<TimeLapse> timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, result, (ExecutionEnd) end, timeLapse);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, result, (InteractionState) end, timeLapse);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, result, (MessageEnd) end, timeLapse);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute EventStructure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<EventContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private static void visit(Deque<CapellaElement> ancestors, List<EventContext> result, MessageEnd end,\n+      Optional<TimeLapse> timeLapse) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getStart() == end) {\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), true, ancestors.size() + 1));\n+      ancestors.push(timeLapse.get());\n+    }\n+\n+    // Message - EventContext to directly know which execution/instanceRole DNode must be source/target of the\n+    // message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in endToEventCache)\n+    // - receiving end of the main branch (start of execution found in endToEvent cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in endToEvent cache, not yet removed from the\n+    // ancestor cache)\n+    // - receiving end of the return branch (no execution found in endToEvent cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new EventContext(ancestors.peek(), message, end.equals(message.getSendingEnd()), ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse.isPresent() && timeLapse.get() instanceof Execution\n+        && ((Execution) timeLapse.get()).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new EventContext(ancestors.peek(), timeLapse.get(), false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+        //  The Following diagram would result in", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwMTg2NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507701864", "bodyText": "It was hard ten years after the main developments on Sequence to bring all memories together, it will be easier with this.", "author": "mPorhel", "createdAt": "2020-10-19T12:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NDA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nsimilarity index 52%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex acce1cc73..c38596bb4 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/EventContextServices.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -10,17 +10,7 @@\n  * Contributors:\n  *    Thales - initial API and implementation\n  *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis;\n-\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getDirectEventsFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInstanceRoleToEventContextCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getInteractionFragmentToTimeLapseCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.getTimeLapseFromCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.isRefreshCacheEnabled;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putDirectEventsInCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putInstanceRoleToEventContextsCache;\n-import static org.polarsys.capella.core.sirius.analysis.refresh.extension.InteractionRefreshExtension.putTimeLapseInCache;\n+package org.polarsys.capella.core.sirius.analysis.cache;\n \n import java.util.ArrayDeque;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NTc3Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506495776", "bodyText": "Why does this method return an optional? All of the other methods return null if the value is absent.\nLet's return a TimeLapse here ;)", "author": "sandupostaru", "createdAt": "2020-10-16T14:39:14Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension implements IRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Is InteractionRefreshExtension caches enabled ?\n+   */\n+  private static boolean isCacheEnabled;\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+      enableRefreshCache();\n+  }\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void postRefresh(DDiagram diagram) {\n+    clearCaches();\n+    disableRefreshCache();\n+  }\n+\n+  private void clearCaches() {\n+    interactionCache.clearCache();\n+    directEventsCache.clear();\n+    instanceRoleToEventContextsCache.clear();\n+    interactionFragmentToTimeLapseCache.clear();\n+  }\n+\n+  /**\n+   * \n+   * @param function\n+   * @param parameter\n+   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n+   *         result before returning it. //\n+   */\n+  public static <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n+    return interactionCache.get(function, parameter);\n+  }\n+\n+  /**\n+   * Get EventContext structure for instanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<EventContext>\n+   */\n+  public static List<EventContext> getInstanceRoleToEventContextCache(InstanceRole instanceRole) {\n+    return instanceRoleToEventContextsCache.get(instanceRole);\n+  }\n+\n+  /**\n+   * Put EventContext structure for instanceRole in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param structure\n+   *          List<EventContext>\n+   */\n+  public static void putInstanceRoleToEventContextsCache(InstanceRole instanceRole, List<EventContext> structure) {\n+    instanceRoleToEventContextsCache.put(instanceRole, structure);\n+  }\n+\n+  /**\n+   * Get element container.\n+   * \n+   * @param capellaElement\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  public static Collection<EObject> getDirectEventsFromCache(EObject capellaElement) {\n+    return directEventsCache.get(capellaElement);\n+  }\n+\n+  /**\n+   * Put element -> container in cache.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param container\n+   *          Collection<EObject>\n+   */\n+  public static void putDirectEventsInCache(EObject element, Collection<EObject> container) {\n+    directEventsCache.put(element, container);\n+  }\n+\n+  /**\n+   * @param key\n+   *          InteractionFragment\n+   * @return Event corresponding to key.\n+   */\n+  public static Optional<TimeLapse> getTimeLapseFromCache(InteractionFragment key) {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzcwNzY2NA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r507707664", "bodyText": "Because it is a special case :\nit is used  to simulate the \"MixEnd\" case : some MessageEnd are used as start/finish of an Execution additionnaly to being the start/finish of a message. But there is no end -> Execution/TimeLapse info in the M2.\nWe also use this cache to retrieve the InteractionState > StateFragment information.\nAnd to be consistent, we also store ExecutionEnd -> Execution.\nIf the cache returns null, IMO, this means that we put no entry in it. If the cache returns en empty Optional, this means that the TimeLapse in the model has no start or finish.\nBut looking at the implementation, it seems that putTimeLapseInCache should do nothing if the provided key is null and you are right getTimeLapseFromCache could return a TimeLapse, without Optional.", "author": "mPorhel", "createdAt": "2020-10-19T12:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5NTc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\ndeleted file mode 100644\nindex 53da9aac5..000000000\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * \n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- * \n- * SPDX-License-Identifier: EPL-2.0\n- * \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n-\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Function;\n-\n-import org.eclipse.emf.ecore.EObject;\n-import org.eclipse.sirius.diagram.DDiagram;\n-import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n-import org.polarsys.capella.core.data.helpers.cache.Cache;\n-import org.polarsys.capella.core.data.interaction.InstanceRole;\n-import org.polarsys.capella.core.data.interaction.InteractionFragment;\n-import org.polarsys.capella.core.data.interaction.TimeLapse;\n-import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n-\n-public class InteractionRefreshExtension implements IRefreshExtension {\n-\n-  /**\n-   * Generic cache (basically for getCovered).\n-   */\n-  private static Cache interactionCache = new Cache();\n-\n-  /**\n-   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n-   * way to get this information.)\n-   */\n-  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n-   */\n-  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Cache for InstanceRole -> EventContext structure.\n-   */\n-  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Is InteractionRefreshExtension caches enabled ?\n-   */\n-  private static boolean isCacheEnabled;\n-\n-  /**\n-   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n-   */\n-  @Override\n-  public void beforeRefresh(DDiagram diagram) {\n-      enableRefreshCache();\n-  }\n-\n-  /**\n-   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n-   */\n-  @Override\n-  public void postRefresh(DDiagram diagram) {\n-    clearCaches();\n-    disableRefreshCache();\n-  }\n-\n-  private void clearCaches() {\n-    interactionCache.clearCache();\n-    directEventsCache.clear();\n-    instanceRoleToEventContextsCache.clear();\n-    interactionFragmentToTimeLapseCache.clear();\n-  }\n-\n-  /**\n-   * \n-   * @param function\n-   * @param parameter\n-   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n-   *         result before returning it. //\n-   */\n-  public static <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n-    return interactionCache.get(function, parameter);\n-  }\n-\n-  /**\n-   * Get EventContext structure for instanceRole\n-   * \n-   * @param instanceRole\n-   *          InstanceRole\n-   * @return List<EventContext>\n-   */\n-  public static List<EventContext> getInstanceRoleToEventContextCache(InstanceRole instanceRole) {\n-    return instanceRoleToEventContextsCache.get(instanceRole);\n-  }\n-\n-  /**\n-   * Put EventContext structure for instanceRole in cache.\n-   * \n-   * @param instanceRole\n-   *          InstanceRole\n-   * @param structure\n-   *          List<EventContext>\n-   */\n-  public static void putInstanceRoleToEventContextsCache(InstanceRole instanceRole, List<EventContext> structure) {\n-    instanceRoleToEventContextsCache.put(instanceRole, structure);\n-  }\n-\n-  /**\n-   * Get element container.\n-   * \n-   * @param capellaElement\n-   *          EObject\n-   * @return Collection<EObject>\n-   */\n-  public static Collection<EObject> getDirectEventsFromCache(EObject capellaElement) {\n-    return directEventsCache.get(capellaElement);\n-  }\n-\n-  /**\n-   * Put element -> container in cache.\n-   * \n-   * @param element\n-   *          EObject\n-   * @param container\n-   *          Collection<EObject>\n-   */\n-  public static void putDirectEventsInCache(EObject element, Collection<EObject> container) {\n-    directEventsCache.put(element, container);\n-  }\n-\n-  /**\n-   * @param key\n-   *          InteractionFragment\n-   * @return Event corresponding to key.\n-   */\n-  public static Optional<TimeLapse> getTimeLapseFromCache(InteractionFragment key) {\n-    return Optional.ofNullable(interactionFragmentToTimeLapseCache.get(key));\n-  }\n-\n-  /**\n-   * Put end -> Event in cache.\n-   * \n-   * @param key\n-   *          InteractionFragment\n-   * @param value\n-   *          Event\n-   */\n-  public static void putTimeLapseInCache(InteractionFragment key, TimeLapse value) {\n-    interactionFragmentToTimeLapseCache.put(key, value);\n-  }\n-\n-  /**\n-   * @return endToEventCache\n-   */\n-  public static Map<InteractionFragment, TimeLapse> getInteractionFragmentToTimeLapseCache() {\n-    return interactionFragmentToTimeLapseCache;\n-  }\n-\n-  /**\n-   * @return if refresh cache is enabled\n-   */\n-  public static boolean isRefreshCacheEnabled() {\n-    return isCacheEnabled;\n-  }\n-\n-    /**\n-     * Enable refresh cache.\n-     */\n-    public static void enableRefreshCache() {\n-        isCacheEnabled = true;\n-    }\n-\n-    /**\n-     * Disable refresh cache.\n-     */\n-    public static void disableRefreshCache() {\n-        isCacheEnabled = false;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5Njc0Nw==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506496747", "bodyText": "Lets call this Class ScenarioRefreshExtensionProvider in order to be coherent.", "author": "sandupostaru", "createdAt": "2020-10-16T14:40:13Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtensionProvider;\n+import org.eclipse.sirius.diagram.sequence.SequenceDDiagram;\n+\n+public class InteractionRefreshExtensionProvider implements IRefreshExtensionProvider {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/ScenarioRefreshExtensionProvider.java\nsimilarity index 84%\nrename from core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java\nrename to core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/ScenarioRefreshExtensionProvider.java\nindex 355296add..3a65b3695 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtensionProvider.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/ScenarioRefreshExtensionProvider.java\n\n@@ -17,11 +17,11 @@ import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtensionProvider;\n import org.eclipse.sirius.diagram.sequence.SequenceDDiagram;\n \n-public class InteractionRefreshExtensionProvider implements IRefreshExtensionProvider {\n+public class ScenarioRefreshExtensionProvider implements IRefreshExtensionProvider {\n \n-  private static final InteractionRefreshExtension REFRESH_EXTENSION = new InteractionRefreshExtension();\n+  private static final ScenarioRefreshExtension REFRESH_EXTENSION = new ScenarioRefreshExtension();\n \n-  public InteractionRefreshExtensionProvider() {\n+  public ScenarioRefreshExtensionProvider() {\n     // empty constructor\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5Njk4OQ==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506496989", "bodyText": "Lets call this Class ScenarioRefreshExtension in order to be coherent.", "author": "sandupostaru", "createdAt": "2020-10-16T14:40:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension implements IRefreshExtension {", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\ndeleted file mode 100644\nindex 53da9aac5..000000000\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * \n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- * \n- * SPDX-License-Identifier: EPL-2.0\n- * \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n-\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Function;\n-\n-import org.eclipse.emf.ecore.EObject;\n-import org.eclipse.sirius.diagram.DDiagram;\n-import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n-import org.polarsys.capella.core.data.helpers.cache.Cache;\n-import org.polarsys.capella.core.data.interaction.InstanceRole;\n-import org.polarsys.capella.core.data.interaction.InteractionFragment;\n-import org.polarsys.capella.core.data.interaction.TimeLapse;\n-import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n-\n-public class InteractionRefreshExtension implements IRefreshExtension {\n-\n-  /**\n-   * Generic cache (basically for getCovered).\n-   */\n-  private static Cache interactionCache = new Cache();\n-\n-  /**\n-   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n-   * way to get this information.)\n-   */\n-  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n-   */\n-  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Cache for InstanceRole -> EventContext structure.\n-   */\n-  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Is InteractionRefreshExtension caches enabled ?\n-   */\n-  private static boolean isCacheEnabled;\n-\n-  /**\n-   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n-   */\n-  @Override\n-  public void beforeRefresh(DDiagram diagram) {\n-      enableRefreshCache();\n-  }\n-\n-  /**\n-   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n-   */\n-  @Override\n-  public void postRefresh(DDiagram diagram) {\n-    clearCaches();\n-    disableRefreshCache();\n-  }\n-\n-  private void clearCaches() {\n-    interactionCache.clearCache();\n-    directEventsCache.clear();\n-    instanceRoleToEventContextsCache.clear();\n-    interactionFragmentToTimeLapseCache.clear();\n-  }\n-\n-  /**\n-   * \n-   * @param function\n-   * @param parameter\n-   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n-   *         result before returning it. //\n-   */\n-  public static <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n-    return interactionCache.get(function, parameter);\n-  }\n-\n-  /**\n-   * Get EventContext structure for instanceRole\n-   * \n-   * @param instanceRole\n-   *          InstanceRole\n-   * @return List<EventContext>\n-   */\n-  public static List<EventContext> getInstanceRoleToEventContextCache(InstanceRole instanceRole) {\n-    return instanceRoleToEventContextsCache.get(instanceRole);\n-  }\n-\n-  /**\n-   * Put EventContext structure for instanceRole in cache.\n-   * \n-   * @param instanceRole\n-   *          InstanceRole\n-   * @param structure\n-   *          List<EventContext>\n-   */\n-  public static void putInstanceRoleToEventContextsCache(InstanceRole instanceRole, List<EventContext> structure) {\n-    instanceRoleToEventContextsCache.put(instanceRole, structure);\n-  }\n-\n-  /**\n-   * Get element container.\n-   * \n-   * @param capellaElement\n-   *          EObject\n-   * @return Collection<EObject>\n-   */\n-  public static Collection<EObject> getDirectEventsFromCache(EObject capellaElement) {\n-    return directEventsCache.get(capellaElement);\n-  }\n-\n-  /**\n-   * Put element -> container in cache.\n-   * \n-   * @param element\n-   *          EObject\n-   * @param container\n-   *          Collection<EObject>\n-   */\n-  public static void putDirectEventsInCache(EObject element, Collection<EObject> container) {\n-    directEventsCache.put(element, container);\n-  }\n-\n-  /**\n-   * @param key\n-   *          InteractionFragment\n-   * @return Event corresponding to key.\n-   */\n-  public static Optional<TimeLapse> getTimeLapseFromCache(InteractionFragment key) {\n-    return Optional.ofNullable(interactionFragmentToTimeLapseCache.get(key));\n-  }\n-\n-  /**\n-   * Put end -> Event in cache.\n-   * \n-   * @param key\n-   *          InteractionFragment\n-   * @param value\n-   *          Event\n-   */\n-  public static void putTimeLapseInCache(InteractionFragment key, TimeLapse value) {\n-    interactionFragmentToTimeLapseCache.put(key, value);\n-  }\n-\n-  /**\n-   * @return endToEventCache\n-   */\n-  public static Map<InteractionFragment, TimeLapse> getInteractionFragmentToTimeLapseCache() {\n-    return interactionFragmentToTimeLapseCache;\n-  }\n-\n-  /**\n-   * @return if refresh cache is enabled\n-   */\n-  public static boolean isRefreshCacheEnabled() {\n-    return isCacheEnabled;\n-  }\n-\n-    /**\n-     * Enable refresh cache.\n-     */\n-    public static void enableRefreshCache() {\n-        isCacheEnabled = true;\n-    }\n-\n-    /**\n-     * Disable refresh cache.\n-     */\n-    public static void disableRefreshCache() {\n-        isCacheEnabled = false;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjQ5ODQ5OA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r506498498", "bodyText": "We should also call clearCache() here, in case the root postRefresh Sirius method fails for whatever reason, and our postRefresh is not called.", "author": "sandupostaru", "createdAt": "2020-10-16T14:41:57Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.sirius.diagram.DDiagram;\n+import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n+\n+public class InteractionRefreshExtension implements IRefreshExtension {\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private static Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> EventContext structure.\n+   */\n+  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Is InteractionRefreshExtension caches enabled ?\n+   */\n+  private static boolean isCacheEnabled;\n+\n+  /**\n+   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n+   */\n+  @Override\n+  public void beforeRefresh(DDiagram diagram) {\n+      enableRefreshCache();", "originalCommit": "d06008bf95006a89f25657e20ddc00404c421075", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\ndeleted file mode 100644\nindex 53da9aac5..000000000\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/refresh/extension/InteractionRefreshExtension.java\n+++ /dev/null\n\n@@ -1,188 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * \n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- * \n- * SPDX-License-Identifier: EPL-2.0\n- * \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.sirius.analysis.refresh.extension;\n-\n-import java.util.Collection;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Function;\n-\n-import org.eclipse.emf.ecore.EObject;\n-import org.eclipse.sirius.diagram.DDiagram;\n-import org.eclipse.sirius.diagram.business.api.refresh.IRefreshExtension;\n-import org.polarsys.capella.core.data.helpers.cache.Cache;\n-import org.polarsys.capella.core.data.interaction.InstanceRole;\n-import org.polarsys.capella.core.data.interaction.InteractionFragment;\n-import org.polarsys.capella.core.data.interaction.TimeLapse;\n-import org.polarsys.capella.core.sirius.analysis.EventContextServices.EventContext;\n-\n-public class InteractionRefreshExtension implements IRefreshExtension {\n-\n-  /**\n-   * Generic cache (basically for getCovered).\n-   */\n-  private static Cache interactionCache = new Cache();\n-\n-  /**\n-   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n-   * way to get this information.)\n-   */\n-  private static Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n-   */\n-  private static Map<EObject, Collection<EObject>> directEventsCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Cache for InstanceRole -> EventContext structure.\n-   */\n-  private static Map<InstanceRole, List<EventContext>> instanceRoleToEventContextsCache = new ConcurrentHashMap<>();\n-\n-  /**\n-   * Is InteractionRefreshExtension caches enabled ?\n-   */\n-  private static boolean isCacheEnabled;\n-\n-  /**\n-   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#beforeRefresh(org.eclipse.sirius.DDiagram)\n-   */\n-  @Override\n-  public void beforeRefresh(DDiagram diagram) {\n-      enableRefreshCache();\n-  }\n-\n-  /**\n-   * @see org.eclipse.sirius.business.api.refresh.IRefreshExtension#postRefresh(org.eclipse.sirius.DDiagram)\n-   */\n-  @Override\n-  public void postRefresh(DDiagram diagram) {\n-    clearCaches();\n-    disableRefreshCache();\n-  }\n-\n-  private void clearCaches() {\n-    interactionCache.clearCache();\n-    directEventsCache.clear();\n-    instanceRoleToEventContextsCache.clear();\n-    interactionFragmentToTimeLapseCache.clear();\n-  }\n-\n-  /**\n-   * \n-   * @param function\n-   * @param parameter\n-   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n-   *         result before returning it. //\n-   */\n-  public static <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n-    return interactionCache.get(function, parameter);\n-  }\n-\n-  /**\n-   * Get EventContext structure for instanceRole\n-   * \n-   * @param instanceRole\n-   *          InstanceRole\n-   * @return List<EventContext>\n-   */\n-  public static List<EventContext> getInstanceRoleToEventContextCache(InstanceRole instanceRole) {\n-    return instanceRoleToEventContextsCache.get(instanceRole);\n-  }\n-\n-  /**\n-   * Put EventContext structure for instanceRole in cache.\n-   * \n-   * @param instanceRole\n-   *          InstanceRole\n-   * @param structure\n-   *          List<EventContext>\n-   */\n-  public static void putInstanceRoleToEventContextsCache(InstanceRole instanceRole, List<EventContext> structure) {\n-    instanceRoleToEventContextsCache.put(instanceRole, structure);\n-  }\n-\n-  /**\n-   * Get element container.\n-   * \n-   * @param capellaElement\n-   *          EObject\n-   * @return Collection<EObject>\n-   */\n-  public static Collection<EObject> getDirectEventsFromCache(EObject capellaElement) {\n-    return directEventsCache.get(capellaElement);\n-  }\n-\n-  /**\n-   * Put element -> container in cache.\n-   * \n-   * @param element\n-   *          EObject\n-   * @param container\n-   *          Collection<EObject>\n-   */\n-  public static void putDirectEventsInCache(EObject element, Collection<EObject> container) {\n-    directEventsCache.put(element, container);\n-  }\n-\n-  /**\n-   * @param key\n-   *          InteractionFragment\n-   * @return Event corresponding to key.\n-   */\n-  public static Optional<TimeLapse> getTimeLapseFromCache(InteractionFragment key) {\n-    return Optional.ofNullable(interactionFragmentToTimeLapseCache.get(key));\n-  }\n-\n-  /**\n-   * Put end -> Event in cache.\n-   * \n-   * @param key\n-   *          InteractionFragment\n-   * @param value\n-   *          Event\n-   */\n-  public static void putTimeLapseInCache(InteractionFragment key, TimeLapse value) {\n-    interactionFragmentToTimeLapseCache.put(key, value);\n-  }\n-\n-  /**\n-   * @return endToEventCache\n-   */\n-  public static Map<InteractionFragment, TimeLapse> getInteractionFragmentToTimeLapseCache() {\n-    return interactionFragmentToTimeLapseCache;\n-  }\n-\n-  /**\n-   * @return if refresh cache is enabled\n-   */\n-  public static boolean isRefreshCacheEnabled() {\n-    return isCacheEnabled;\n-  }\n-\n-    /**\n-     * Enable refresh cache.\n-     */\n-    public static void enableRefreshCache() {\n-        isCacheEnabled = true;\n-    }\n-\n-    /**\n-     * Disable refresh cache.\n-     */\n-    public static void disableRefreshCache() {\n-        isCacheEnabled = false;\n-    }\n-}\n"}}, {"oid": "b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "url": "https://github.com/eclipse/capella/commit/b9eaf0970d47fa8ddf52806233f5b1c1dfa999bf", "message": "[563193] Capella Diagram Performance issues\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-20T08:38:19Z", "type": "forcePushed"}, {"oid": "4ff155ae64a57c94a9a3369c0b3368e96b89e654", "url": "https://github.com/eclipse/capella/commit/4ff155ae64a57c94a9a3369c0b3368e96b89e654", "message": "[563193] Capella Diagram Performance issues\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-20T19:27:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNjQwNg==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r509216406", "bodyText": "The formatting of this section seems to be off. I think it was messed-up during the save + auto format.\nCan you restore it please?", "author": "sandupostaru", "createdAt": "2020-10-21T11:56:29Z", "path": "core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java", "diffHunk": "@@ -0,0 +1,554 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\n+ * \n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ * \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.sirius.analysis.cache;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.polarsys.capella.core.data.capellacore.CapellaElement;\n+import org.polarsys.capella.core.data.helpers.cache.Cache;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.AbstractFragment;\n+import org.polarsys.capella.core.data.interaction.Execution;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.InteractionState;\n+import org.polarsys.capella.core.data.interaction.MessageEnd;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.interaction.StateFragment;\n+import org.polarsys.capella.core.data.interaction.TimeLapse;\n+import org.polarsys.capella.core.sirius.analysis.SequenceDiagramServices;\n+\n+/**\n+ * Compute Scenario cache structure for sequence diagram.\n+ * \n+ * @author nlepine\n+ *\n+ */\n+public class ScenarioCache {\n+\n+  /**\n+   * Singleton.\n+   */\n+  private static ScenarioCache instance;\n+\n+  /**\n+   * Generic cache (basically for getCovered).\n+   */\n+  private Cache interactionCache = new Cache();\n+\n+  /**\n+   * Cache for MessageEnd -> Execution/InstanceRole and InteractionState -> StateFragment. (Cross referencer might be a\n+   * way to get this information.)\n+   */\n+  private Map<InteractionFragment, TimeLapse> interactionFragmentToTimeLapseCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for ChildExecution -> ParentExecution and StateFragment -> ParentExecution.\n+   */\n+  private Map<EObject, Collection<EObject>> semanticCandidatesCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Cache for InstanceRole -> semantic candidate structure.\n+   */\n+  private Map<InstanceRole, List<SemanticCandidateContext>> instanceRoleToSemanticCandidateContextsCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Is InteractionRefreshExtension caches enabled ?\n+   */\n+  private boolean isCacheEnabled;\n+\n+  /**\n+   * Constructor.\n+   */\n+  private ScenarioCache() {\n+  }\n+\n+  /**\n+   * @return ScenarioCache\n+   */\n+  public static ScenarioCache getInstance() {\n+    if (instance == null) {\n+      instance = new ScenarioCache();\n+    }\n+    return instance;\n+  }\n+\n+  /**\n+   * Clear all caches.\n+   */\n+  public void clearCaches() {\n+    interactionCache.clearCache();\n+    semanticCandidatesCache.clear();\n+    instanceRoleToSemanticCandidateContextsCache.clear();\n+    interactionFragmentToTimeLapseCache.clear();\n+  }\n+\n+  /**\n+   * \n+   * @param function\n+   * @param parameter\n+   * @return If enabled, return the cached result if any or apply the function to the given parameter and cache the\n+   *         result before returning it. //\n+   */\n+  public <P, R> R getInteractionCache(Function<P, R> function, P parameter) {\n+    return interactionCache.get(function, parameter);\n+  }\n+\n+  /**\n+   * Get SemanticCandidateContext structure for instanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<SemanticCandidateContext>\n+   */\n+  public List<SemanticCandidateContext> getInstanceRoleToSemanticCandidateContextCache(InstanceRole instanceRole) {\n+    return instanceRoleToSemanticCandidateContextsCache.get(instanceRole);\n+  }\n+\n+  /**\n+   * Put SemanticCandidateContext structure for instanceRole in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param structure\n+   *          List<SemanticCandidateContext>\n+   */\n+  public void putInstanceRoleToSemanticCandidateContextsCache(InstanceRole instanceRole,\n+      List<SemanticCandidateContext> structure) {\n+    instanceRoleToSemanticCandidateContextsCache.put(instanceRole, structure);\n+  }\n+\n+  /**\n+   * Get element container.\n+   * \n+   * @param capellaElement\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  public Collection<EObject> getSemanticCandidatesFromCache(EObject capellaElement) {\n+    return semanticCandidatesCache.get(capellaElement);\n+  }\n+\n+  /**\n+   * Put element -> container in cache.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param container\n+   *          Collection<EObject>\n+   */\n+  public void putSemanticCandidatesInCache(EObject element, Collection<EObject> container) {\n+    semanticCandidatesCache.put(element, container);\n+  }\n+\n+  /**\n+   * @param key\n+   *          InteractionFragment\n+   * @return TimeLapse corresponding to key.\n+   */\n+  public TimeLapse getTimeLapseFromCache(InteractionFragment key) {\n+    return interactionFragmentToTimeLapseCache.get(key);\n+  }\n+\n+  /**\n+   * Put end -> TimeLapse in cache.\n+   * \n+   * @param key\n+   *          InteractionFragment\n+   * @param value\n+   *          TimeLapse\n+   */\n+  public void putTimeLapseInCache(InteractionFragment key, TimeLapse value) {\n+    interactionFragmentToTimeLapseCache.put(key, value);\n+  }\n+\n+  /**\n+   * @return endToTimeLapseCache\n+   */\n+  public Map<InteractionFragment, TimeLapse> getInteractionFragmentToTimeLapseCache() {\n+    return interactionFragmentToTimeLapseCache;\n+  }\n+\n+  /**\n+   * @return if refresh cache is enabled\n+   */\n+  public boolean isRefreshCacheEnabled() {\n+    return isCacheEnabled;\n+  }\n+\n+  /**\n+   * Enable refresh cache.\n+   */\n+  public void enableRefreshCache() {\n+    isCacheEnabled = true;\n+  }\n+\n+  /**\n+   * Disable refresh cache.\n+   */\n+  public void disableRefreshCache() {\n+    isCacheEnabled = false;\n+  }\n+\n+  /**\n+   * Compute Scenario structure from InstanceRole if needed and put it in cache.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<SemanticCandidateContext>\n+   */\n+  public List<SemanticCandidateContext> getSemanticCandidateContexts(InstanceRole instanceRole) {\n+    List<SemanticCandidateContext> semanticCandidateContexts = getInstanceRoleToSemanticCandidateContextCache(\n+        instanceRole);\n+    if (semanticCandidateContexts == null) {\n+      semanticCandidateContexts = computeInstanceRoleSemanticCandidateContextStructure(instanceRole);\n+      if (isRefreshCacheEnabled()) {\n+        putInstanceRoleToSemanticCandidateContextsCache(instanceRole, semanticCandidateContexts);\n+      }\n+    }\n+    return semanticCandidateContexts;\n+  }\n+\n+  /**\n+   * Get semantic candidate on element. (InstanceRole -> Executions + StateFragment, Execution -> Execution\n+   * children + StateFragment)\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param element\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  private Collection<EObject> getSemanticCandidates(InstanceRole instanceRole, EObject element) {\n+    Collection<EObject> semanticCandidates = getSemanticCandidatesFromCache(element);\n+    if (semanticCandidates == null) {\n+      // compute result from SemanticCandidateContext structure\n+      List<SemanticCandidateContext> semanticCandidateContexts = getSemanticCandidateContexts(instanceRole);\n+\n+      semanticCandidates = semanticCandidateContexts.stream().filter(scc -> element.equals(scc.getParent()))\n+          .map(SemanticCandidateContext::getElement).filter(candidate -> candidate != element).distinct()\n+          .collect(Collectors.toList());\n+      if (isRefreshCacheEnabled()) {\n+        putSemanticCandidatesInCache(element, semanticCandidates);\n+      }\n+    }\n+    return semanticCandidates;\n+  }\n+\n+  /**\n+   * Get Execution semantic candidates on element.\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @param element\n+   *          EObject\n+   * @return Collection<EObject>\n+   */\n+  public Collection<Execution> getExecutionSemanticCandidates(InstanceRole instanceRole, EObject element) {\n+    return getSemanticCandidates(instanceRole, element).stream().filter(Execution.class::isInstance)\n+        .map(Execution.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Get StateFragment semantic candidates on element.\n+   * \n+   * @param element\n+   *          EObject\n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return Collection<EObject>\n+   */\n+  public List<StateFragment> getStateFragmentSemanticCandidates(InstanceRole instanceRole, EObject element) {\n+    return getSemanticCandidates(instanceRole, element).stream().filter(StateFragment.class::isInstance)\n+        .map(StateFragment.class::cast).collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Compute SemanticCandidateContext structure for InstanceRole\n+   * \n+   * @param instanceRole\n+   *          InstanceRole\n+   * @return List<SemanticCandidateContext>\n+   */\n+  private List<SemanticCandidateContext> computeInstanceRoleSemanticCandidateContextStructure(\n+      InstanceRole instanceRole) {\n+    if (instanceRole == null || !(instanceRole.eContainer() instanceof Scenario)) {\n+      return Collections.emptyList();\n+    }\n+    Scenario scenario = SequenceDiagramServices.getScenario(instanceRole);\n+\n+    // initialize ancestors\n+    Deque<CapellaElement> ancestors = new ArrayDeque<>();\n+    ancestors.push(instanceRole);\n+    List<SemanticCandidateContext> result = new ArrayList<>();\n+\n+    // Cache missing info from M2 :\n+    // - cache Execution.start -> Execution and Execution.finish -> Execution when the end is a MessageEnd\n+    // - cache StateFragment.start -> InteractionState and StateFragment.finish -> InteractionState\n+    // (ExecutionEnd has a getExecution() method)(ExecutionEnd has a getExecution() method)\n+    computeTimeLapseStartAndEndCache(scenario);\n+\n+    // compute Execution/StateFragment and InteractionFragment structure\n+    Stream<InteractionFragment> interactionFragments = scenario.getOwnedInteractionFragments().stream()\n+        .filter(frag -> frag instanceof AbstractEnd || frag instanceof InteractionState);\n+    interactionFragments.forEachOrdered(end -> {\n+      InstanceRole coveredInstanceRole = getCoveredInstanceRole(end);\n+      if (coveredInstanceRole != null && coveredInstanceRole.equals(instanceRole)) {\n+        TimeLapse timeLapse = getTimeLapseFromCache(end);\n+\n+        // Execution End case\n+        if (end instanceof ExecutionEnd) {\n+          visit(ancestors, timeLapse, (ExecutionEnd) end, result);\n+        }\n+\n+        // Interaction State case\n+        if (end instanceof InteractionState) {\n+          visit(ancestors, timeLapse, (InteractionState) end, result);\n+        }\n+\n+        // Message End case\n+        if (end instanceof MessageEnd) {\n+          visit(ancestors, timeLapse, (MessageEnd) end, result);\n+        }\n+\n+      }\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * Compute Semantic candidate Structure for MessageEnd.\n+   * \n+   * @param ancestors\n+   *          Deque<EObject>\n+   * @param result\n+   *          List<SemanticCandidateContext>\n+   * @param end\n+   *          MessageEnd\n+   */\n+  private void visit(Deque<CapellaElement> ancestors, TimeLapse timeLapse, MessageEnd end,\n+      List<SemanticCandidateContext> result) {\n+\n+    // Execution start / SyncCall and ASyncCall\n+    if (timeLapse instanceof Execution && ((Execution) timeLapse).getStart() == end) {\n+      result.add(new SemanticCandidateContext(ancestors.peek(), timeLapse, true, ancestors.size() + 1));\n+      ancestors.push(timeLapse);\n+    }\n+\n+    // Message - SemanticCandidateContext to directly know which execution/instanceRole DNode must be source/target of\n+    // the message's DEdge\n+    // Handle all cases :\n+    // - sending end of the main branch (no execution found in interactionFragmentToTimeLapseCache)\n+    // - receiving end of the main branch (start of execution found in interactionFragmentToTimeLapseCache cache and pushed on the ancestor\n+    // stack)\n+    // - sending end of the return branch (end of execution found in interactionFragmentToTimeLapseCache cache, not yet\n+    // removed from the ancestor cache)\n+    // - receiving end of the return branch (no execution found in interactionFragmentToTimeLapseCache cache).\n+    SequenceMessage message = end.getMessage();\n+    if (message != null) {\n+      result.add(new SemanticCandidateContext(ancestors.peek(), message, end.equals(message.getSendingEnd()),\n+          ancestors.size()));\n+    }\n+\n+    // Execution with return branch end / SyncCall\n+    if (timeLapse instanceof Execution && ((Execution) timeLapse).getFinish() == end) {\n+      ancestors.pop();\n+      result.add(new SemanticCandidateContext(ancestors.peek(), timeLapse, false, ancestors.size() + 1));\n+    }\n+\n+    // @formatter:off\n+    // The Following diagram would result in\n+    //\n+    // | IR1 | | IR2 ] | IR3 ]\n+    // | | |\n+    // | | |\n+    // |-------> - | e1 m1\n+    // | | |------> - e2 m2\n+    // | | | | |\n+    // | | - <-----| | e3 m3\n+    // | || | | |\n+    // | || | | |\n+    // | | - ----->| | return_m3\n+    // | | | | |\n+    // |<------- - | | return_m1\n+    // | | -\n+    // | | |\n+", "originalCommit": "4ff155ae64a57c94a9a3369c0b3368e96b89e654", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDEzMDA0MA==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r510130040", "bodyText": "Hi Sandu,\nNathalie is on holidays until Monday.\nShe will fix this on Monday.\nWe need to disable the Eclipse formatter  for this section as it is the only solution to have a understandable view of the computation here.", "author": "mPorhel", "createdAt": "2020-10-22T12:44:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNjQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg1NjI1Ng==", "url": "https://github.com/eclipse/capella/pull/381#discussion_r511856256", "bodyText": "Done!", "author": "nlepine", "createdAt": "2020-10-26T10:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTIxNjQwNg=="}], "type": "inlineReview", "revised_code": {"commit": "c0fe85dd3a57933440851cb057fce58bcf929455", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\nindex 5c11e3693..8abe741c7 100644\n--- a/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n+++ b/core/plugins/org.polarsys.capella.core.sirius.analysis/src/org/polarsys/capella/core/sirius/analysis/cache/ScenarioCache.java\n\n@@ -378,24 +378,24 @@ public class ScenarioCache {\n       ancestors.pop();\n       result.add(new SemanticCandidateContext(ancestors.peek(), timeLapse, false, ancestors.size() + 1));\n     }\n-\n+    \n     // @formatter:off\n-    // The Following diagram would result in\n+    //  The Following diagram would result in\n     //\n-    // | IR1 | | IR2 ] | IR3 ]\n-    // | | |\n-    // | | |\n-    // |-------> - | e1 m1\n-    // | | |------> - e2 m2\n-    // | | | | |\n-    // | | - <-----| | e3 m3\n-    // | || | | |\n-    // | || | | |\n-    // | | - ----->| | return_m3\n-    // | | | | |\n-    // |<------- - | | return_m1\n-    // | | -\n-    // | | |\n+    //     | IR1 |   | IR2 ]   | IR3 ] \n+    //        |         |         |\n+    //        |         |         |\n+    //        |-------> -         |   e1  m1\n+    //        |        | |------> -   e2  m2\n+    //        |        | |       | |\n+    //        |        | - <-----| |  e3  m3\n+    //        |        || |      | |\n+    //        |        || |      | |\n+    //        |        | - ----->| |      return_m3\n+    //        |        | |       | |\n+    //        |<------- -        | |      return_m1\n+    //        |         |         - \n+    //        |         |         | \n \n     // would result the following structures:\n \n"}}, {"oid": "c0fe85dd3a57933440851cb057fce58bcf929455", "url": "https://github.com/eclipse/capella/commit/c0fe85dd3a57933440851cb057fce58bcf929455", "message": "[563193] Capella Diagram Performance issues\n\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-26T09:28:50Z", "type": "commit"}, {"oid": "c0fe85dd3a57933440851cb057fce58bcf929455", "url": "https://github.com/eclipse/capella/commit/c0fe85dd3a57933440851cb057fce58bcf929455", "message": "[563193] Capella Diagram Performance issues\n\n\nSigned-off-by: Nathalie Lepine <nathalie.lepine@obeo.fr>", "committedDate": "2020-10-26T09:28:50Z", "type": "forcePushed"}]}