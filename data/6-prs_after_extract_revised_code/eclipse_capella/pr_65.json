{"pr_number": 65, "pr_title": "Search display Tree in Result view", "pr_createdAt": "2020-02-03T15:54:14Z", "pr_url": "https://github.com/eclipse/capella/pull/65", "timeline": [{"oid": "81b3d32b6584ecc68df78c5a853d557007847289", "url": "https://github.com/eclipse/capella/commit/81b3d32b6584ecc68df78c5a853d557007847289", "message": "Search display Tree in Result view\n\nChange-Id: I363b4e190d2b90ef4250bccd88346935b9773ee5\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-03T15:53:20Z", "type": "commit"}, {"oid": "bf86efed6a2ec561c2434bc20822224213871963", "url": "https://github.com/eclipse/capella/commit/bf86efed6a2ec561c2434bc20822224213871963", "message": "Search display Tree in Result view\n\nChange-Id: I9b6214cb7310f1c4513973f85264ecf2cdb8ad8c\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-05T10:31:45Z", "type": "commit"}, {"oid": "27b879aac89491ea8e12aa6d6fb119f42e04ae05", "url": "https://github.com/eclipse/capella/commit/27b879aac89491ea8e12aa6d6fb119f42e04ae05", "message": "Search display as tree/list and perform replace\n\nChange-Id: I8f7c838566ee3c5ac5456dbf0c255419aeb815d5\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-05T12:37:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwMDY2NA==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375400664", "bodyText": "Avoid using variables with underscore in their names (for Sonar)", "author": "minhtutonthat", "createdAt": "2020-02-05T17:30:09Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Stack;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.search.ui.text.Match;\r\n+\r\n+/**\r\n+ * Entity responsible of model result hierarchical organization.\r\n+ */\r\n+public abstract class AbstractCapellaSearchEntry extends Match {\r\n+  /** precedent AbstractCapellaSearchResultEntry in the hierarchical search query result thread */\r\n+  protected AbstractCapellaSearchEntry parent;\r\n+\r\n+  /** true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise */\r\n+  protected boolean matchedOnce;\r\n+\r\n+  /**\r\n+   * all AbstractCapellaSearchResultEntry children, potentially matches themselves or intermediary structural object(s)\r\n+   * for ordering purposes only)\r\n+   */\r\n+  private Collection<Object> children;\r\n+  \r\n+  private String text;\r\n+  \r\n+  private IProject project;\r\n+\r\n+  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source, boolean _matched, IProject _project) {\r", "originalCommit": "27b879aac89491ea8e12aa6d6fb119f42e04ae05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4MjkwOA==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375782908", "bodyText": "OK.", "author": "georgiana-ecobici", "createdAt": "2020-02-06T11:31:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwMDY2NA=="}], "type": "inlineReview", "revised_code": {"commit": "4e4e923c1ec49e16213486fc8cff9a8a96134db0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java\ndeleted file mode 100644\nindex 8a7ffb180..000000000\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *  \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.ui.search;\n-\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Stack;\n-\n-import org.eclipse.core.resources.IProject;\n-import org.eclipse.search.ui.text.Match;\n-\n-/**\n- * Entity responsible of model result hierarchical organization.\n- */\n-public abstract class AbstractCapellaSearchEntry extends Match {\n-  /** precedent AbstractCapellaSearchResultEntry in the hierarchical search query result thread */\n-  protected AbstractCapellaSearchEntry parent;\n-\n-  /** true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise */\n-  protected boolean matchedOnce;\n-\n-  /**\n-   * all AbstractCapellaSearchResultEntry children, potentially matches themselves or intermediary structural object(s)\n-   * for ordering purposes only)\n-   */\n-  private Collection<Object> children;\n-  \n-  private String text;\n-  \n-  private IProject project;\n-\n-  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source, boolean _matched, IProject _project) {\n-    super(_source, -1, -1);\n-    parent = _parent;\n-    children = new HashSet<Object>();\n-    project = _project;\n-    setMatchedOnce(_matched);\n-  }\n-\n-  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source,\n-      String _valuation, boolean _matched, IProject _project) {\n-    this(_parent, _source, _matched, _project);\n-    text = _valuation;\n-  }\n-  \n-  public String getText() {\n-    return text;\n-  }\n-  \n-  public void setText(String _text) {\n-    text = _text;\n-  }\n-  \n-  public Collection<Object> getChildren() {\n-    return children;\n-  }\n-\n-  public IProject getProject() {\n-    return project;\n-  }\n-  \n-  /**\n-   * Adds AbstractCapellaSearchResultEntry child, potentially match itself or intermediary structural object(s) for\n-   * ordering purposes only.\n-   */\n-  public void addChildren(AbstractCapellaSearchEntry e) {\n-    children.add(e);\n-  }\n-\n-  /**\n-   * Remove AbstractCapellaSearchResultEntry child, potentially match itself or intermediary structural object(s) for\n-   * ordering purposes only.\n-   */\n-  public void removeChildren(AbstractCapellaSearchEntry e) {\n-    children.remove(e);\n-  }\n-\n-  /////////////////////////\n-  // Getters / Setters\n-  /////////////////////////\n-\n-  /**\n-   * @return AbstractCapellaSearchResultEntry parent, potentially match itself or intermediary structural object(s) for\n-   *         ordering purposes only.\n-   */\n-  public AbstractCapellaSearchEntry getParent() {\n-    return parent;\n-  }\n-\n-  /**\n-   * Sets AbstractCapellaSearchResultEntry parent, potentially match itself or intermediary structural object(s) for\n-   * ordering purposes only.\n-   */\n-  public void setParent(AbstractCapellaSearchEntry p) {\n-    parent = p;\n-  }\n-\n-  /**\n-   * @return true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise\n-   */\n-  public boolean wasMatchedAtleastOnce() {\n-    return matchedOnce;\n-  }\n-\n-  /**\n-   * Set to true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise\n-   */\n-  public void setMatchedOnce(boolean matchedOnce) {\n-    this.matchedOnce = matchedOnce;\n-  }\n-\n-  /**\n-   * @return AbstractCapellaSearchResultEntry hierarchy in a root to leaf order (eg. tree like), void Stack otherwise.\n-   */\n-  public Stack<AbstractCapellaSearchEntry> getHierarchyFromRootToLeaf() {\n-    Stack<AbstractCapellaSearchEntry> hierarchy = new Stack<AbstractCapellaSearchEntry>();\n-    getHierarchyFromRootToLeaf(this, hierarchy);\n-    return hierarchy;\n-  }\n-\n-  /**\n-   * @return AbstractCapellaSearchResultEntry hierarchy in a root to leaf order (eg. tree like), void Stack otherwise.\n-   */\n-  private void getHierarchyFromRootToLeaf(AbstractCapellaSearchEntry e,\n-      Stack<AbstractCapellaSearchEntry> hierarchy) {\n-    if (e instanceof AbstractCapellaSearchEntry) {\n-      hierarchy.push(e);\n-      getHierarchyFromRootToLeaf(e.getParent(), hierarchy);\n-    }\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    final int prime = 31;\n-    int result = 1;\n-    result = prime * result + ((parent == null) ? 0 : parent.hashCode());\n-    result = prime * result + ((getElement() == null) ? 0 : getElement().hashCode());\n-    return result;\n-  }\n-\n-  /**\n-   * Overriding the equals method allows to apply a 1-1 comparison to all elements of a result hierarchy in a reverse\n-   * order.\n-   * \n-   * This is needed for result hierarchy sub tree insertion algorithms.\n-   * \n-   * A simple example:\n-   * \n-   * LEFT | RIGHT ========|======== A1 | A1 |-B1 | |-B1 |-C1 | |-C1 |-C2 | |-C3\n-   * \n-   * Trying to insert A1->(B1->(C3)) into existing A1->(B1->(C1, C2)) hierarchy implies being able to evaluate until\n-   * which point two elements of the same level are still equals or not.\n-   * \n-   * Here, each comparison A1 <> A1, B1 <> B1, C1 <> C3 implies their ancestor to be compared back on a 1-1 basis.\n-   * \n-   * This means that comparing left side A1.B1.C1 & right side A1.B1.C1 is something like: C1==C1 && B1==B1 && A1==A1\n-   * (eg: a back comparison to the root).\n-   * \n-   */\n-  @Override\n-  public boolean equals(Object obj) {\n-    if (this == obj)\n-      return true;\n-    if (obj == null)\n-      return false;\n-    if (getClass() != obj.getClass())\n-      return false;\n-    final AbstractCapellaSearchEntry other = (AbstractCapellaSearchEntry) obj;\n-    if (getElement() == null) {\n-      if (other.getElement() != null)\n-        return false;\n-    } else if (!getElement().equals(other.getElement()))\n-      return false;\n-    if (parent == null) {\n-      if (other.parent != null)\n-        return false;\n-    } else if (!parent.equals(other.parent))\n-      return false;\n-    return true;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTczNjIyMQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375736221", "bodyText": "Is this an assignement?", "author": "minhtutonthat", "createdAt": "2020-02-06T09:53:53Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.stream.Collectors;\r\n+import java.util.stream.Stream;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.emf.ecore.EAttribute;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.EStructuralFeature;\r\n+import org.eclipse.emf.ecore.ETypedElement;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.jface.resource.ImageDescriptor;\r\n+import org.eclipse.search.ui.text.AbstractTextSearchResult;\r\n+import org.eclipse.search.ui.text.IEditorMatchAdapter;\r\n+import org.eclipse.search.ui.text.IFileMatchAdapter;\r\n+import org.eclipse.search.ui.text.MatchFilter;\r\n+\r\n+public class CapellaSearchResult extends AbstractTextSearchResult {\r\n+\r\n+  private CapellaSearchQuery capellaSearchQuery;\r\n+\r\n+  /**\r\n+   * Current Search Entries\r\n+   */\r\n+  private Map<Object, Collection<Object>> searchEntries;\r\n+  private Map<Object, AbstractCapellaSearchEntry> elementToMatches = new HashMap();\r\n+  \r\n+  public CapellaSearchResult(CapellaSearchQuery capellaSearchQuery) {\r\n+    this.capellaSearchQuery = capellaSearchQuery;\r\n+    setActiveMatchFilters(new MatchFilter[] {}); // By default, no filter is activated\r\n+    searchEntries = new HashMap<Object, Collection<Object>>();\r\n+  }\r\n+  \r\n+  @Override\r\n+  public String getLabel() {\r\n+    int totalOccurrenceCount = getOccurrenceCount();\r\n+    int matchedElementsCount = getElements().length;\r\n+    int matchedProjectsCount = getProjects().size();\r\n+    String queryLabel = capellaSearchQuery.getLabel();\r\n+    int activeFilterCount = getActiveMatchFilters().length;\r\n+    if (activeFilterCount == 0) {\r\n+      return String.format(Messages.CapellaSearchResult_Label, queryLabel, totalOccurrenceCount, matchedElementsCount,\r\n+          matchedProjectsCount);\r\n+    }\r\n+    int displayedOccurrenceCount = 0; //getDisplayedOccurrenceCount();\r\n+    return String.format(Messages.CapellaSearchResult_Label_With_Active_Filters, queryLabel, totalOccurrenceCount,\r\n+        matchedElementsCount, matchedProjectsCount, totalOccurrenceCount - displayedOccurrenceCount, activeFilterCount);\r\n+  }\r\n+\r\n+  @Override\r\n+  public String getTooltip() {\r\n+    return getLabel();\r\n+  }\r\n+\r\n+  @Override\r\n+  public ImageDescriptor getImageDescriptor() {\r\n+    return Activator.getDefault().getImageDescriptor(\"search.gif\"); //$NON-NLS-1$\r\n+  }\r\n+\r\n+  @Override\r\n+  public CapellaSearchQuery getQuery() {\r\n+    return capellaSearchQuery;\r\n+  }\r\n+\r\n+  @Override\r\n+  public IEditorMatchAdapter getEditorMatchAdapter() {\r\n+    return null;\r\n+  }\r\n+\r\n+  @Override\r\n+  public IFileMatchAdapter getFileMatchAdapter() {\r\n+    return null;\r\n+  }\r\n+\r\n+  /**\r\n+   * Get all projects from matches\r\n+   * \r\n+   * @return\r\n+   */\r\n+  public Set<Object> getProjects() {\r\n+    return searchEntries.keySet();\r\n+  }\r\n+\r\n+  @Override\r\n+  public MatchFilter[] getAllMatchFilters() {\r\n+    return new MatchFilter[] { //\r\n+//        CapellaSearchMatchFilter.NOT_MODIFIABLE, //\r\n+//        CapellaSearchMatchFilter.CAPELLA_ELEMENT, //\r\n+//        CapellaSearchMatchFilter.REPRESENTATION //\r\n+    };\r\n+  }\r\n+\r\n+  /////////\r\n+  \r\n+  \r\n+  /**\r\n+   * {@inheritDoc}\r\n+   */\r\n+  public AbstractCapellaSearchEntry insert(Object file, AbstractCapellaSearchEntry entry, boolean notify) {\r\n+    if (searchEntries.get(file) == null) {\r\n+      searchEntries.put(file, new ArrayList<Object>());\r\n+    }\r\n+    insert2(searchEntries.get(file), entry, notify);\r\n+    return entry;\r\n+  }\r\n+\r\n+  /**\r\n+   * {@inheritDoc}\r\n+   */\r\n+  public AbstractCapellaSearchEntry insert(Object file, AbstractCapellaSearchEntry entry, Object eTypedElem, String valuation,\r\n+      boolean notify) {\r\n+    return insert5(entry, eTypedElem, valuation, notify, file);\r\n+  }\r\n+\r\n+  /**\r\n+   * Inserts & merges an entry sequence into an existing entry sequence hierarchy\r\n+   * \r\n+   * @param currentEntrySubHierarchyCollection\r\n+   * @param entryToInsert\r\n+   * @param notify\r\n+   */\r\n+  private void insert2(Collection<Object> currentEntrySubHierarchyCollection, AbstractCapellaSearchEntry entryToInsert,\r\n+      boolean notify) {\r\n+\r\n+      boolean alreadyExist = false;\r\n+      for (Object currentEntrySubHierarchy : currentEntrySubHierarchyCollection) {\r\n+        if (alreadyExist = currentEntrySubHierarchy.equals(entryToInsert)) {\r", "originalCommit": "27b879aac89491ea8e12aa6d6fb119f42e04ae05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4NDcxOQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375784719", "bodyText": "Will remove this.", "author": "georgiana-ecobici", "createdAt": "2020-02-06T11:35:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTczNjIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4e4e923c1ec49e16213486fc8cff9a8a96134db0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\nindex 0d8ce3273..5e198a5b1 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\n\n@@ -30,21 +30,17 @@ import org.eclipse.search.ui.text.AbstractTextSearchResult;\n import org.eclipse.search.ui.text.IEditorMatchAdapter;\n import org.eclipse.search.ui.text.IFileMatchAdapter;\n import org.eclipse.search.ui.text.MatchFilter;\n+import org.polarsys.capella.common.ui.toolkit.viewers.data.TreeData;\n \n public class CapellaSearchResult extends AbstractTextSearchResult {\n \n   private CapellaSearchQuery capellaSearchQuery;\n-\n-  /**\n-   * Current Search Entries\n-   */\n-  private Map<Object, Collection<Object>> searchEntries;\n-  private Map<Object, AbstractCapellaSearchEntry> elementToMatches = new HashMap();\n+  private TreeData treeData;\n   \n   public CapellaSearchResult(CapellaSearchQuery capellaSearchQuery) {\n     this.capellaSearchQuery = capellaSearchQuery;\n     setActiveMatchFilters(new MatchFilter[] {}); // By default, no filter is activated\n-    searchEntries = new HashMap<Object, Collection<Object>>();\n+    treeData = new TreeData(new ArrayList(), null);\n   }\n   \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1NTU4OQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375755589", "bodyText": "Deque, the unsynchronized version of Stack, should be used to be more performance efficient.", "author": "minhtutonthat", "createdAt": "2020-02-06T10:31:42Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashSet;\r\n+import java.util.Stack;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.search.ui.text.Match;\r\n+\r\n+/**\r\n+ * Entity responsible of model result hierarchical organization.\r\n+ */\r\n+public abstract class AbstractCapellaSearchEntry extends Match {\r\n+  /** precedent AbstractCapellaSearchResultEntry in the hierarchical search query result thread */\r\n+  protected AbstractCapellaSearchEntry parent;\r\n+\r\n+  /** true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise */\r\n+  protected boolean matchedOnce;\r\n+\r\n+  /**\r\n+   * all AbstractCapellaSearchResultEntry children, potentially matches themselves or intermediary structural object(s)\r\n+   * for ordering purposes only)\r\n+   */\r\n+  private Collection<Object> children;\r\n+  \r\n+  private String text;\r\n+  \r\n+  private IProject project;\r\n+\r\n+  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source, boolean _matched, IProject _project) {\r\n+    super(_source, -1, -1);\r\n+    parent = _parent;\r\n+    children = new HashSet<Object>();\r\n+    project = _project;\r\n+    setMatchedOnce(_matched);\r\n+  }\r\n+\r\n+  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source,\r\n+      String _valuation, boolean _matched, IProject _project) {\r\n+    this(_parent, _source, _matched, _project);\r\n+    text = _valuation;\r\n+  }\r\n+  \r\n+  public String getText() {\r\n+    return text;\r\n+  }\r\n+  \r\n+  public void setText(String _text) {\r\n+    text = _text;\r\n+  }\r\n+  \r\n+  public Collection<Object> getChildren() {\r\n+    return children;\r\n+  }\r\n+\r\n+  public IProject getProject() {\r\n+    return project;\r\n+  }\r\n+  \r\n+  /**\r\n+   * Adds AbstractCapellaSearchResultEntry child, potentially match itself or intermediary structural object(s) for\r\n+   * ordering purposes only.\r\n+   */\r\n+  public void addChildren(AbstractCapellaSearchEntry e) {\r\n+    children.add(e);\r\n+  }\r\n+\r\n+  /**\r\n+   * Remove AbstractCapellaSearchResultEntry child, potentially match itself or intermediary structural object(s) for\r\n+   * ordering purposes only.\r\n+   */\r\n+  public void removeChildren(AbstractCapellaSearchEntry e) {\r\n+    children.remove(e);\r\n+  }\r\n+\r\n+  /////////////////////////\r\n+  // Getters / Setters\r\n+  /////////////////////////\r\n+\r\n+  /**\r\n+   * @return AbstractCapellaSearchResultEntry parent, potentially match itself or intermediary structural object(s) for\r\n+   *         ordering purposes only.\r\n+   */\r\n+  public AbstractCapellaSearchEntry getParent() {\r\n+    return parent;\r\n+  }\r\n+\r\n+  /**\r\n+   * Sets AbstractCapellaSearchResultEntry parent, potentially match itself or intermediary structural object(s) for\r\n+   * ordering purposes only.\r\n+   */\r\n+  public void setParent(AbstractCapellaSearchEntry p) {\r\n+    parent = p;\r\n+  }\r\n+\r\n+  /**\r\n+   * @return true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise\r\n+   */\r\n+  public boolean wasMatchedAtleastOnce() {\r\n+    return matchedOnce;\r\n+  }\r\n+\r\n+  /**\r\n+   * Set to true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise\r\n+   */\r\n+  public void setMatchedOnce(boolean matchedOnce) {\r\n+    this.matchedOnce = matchedOnce;\r\n+  }\r\n+\r\n+  /**\r\n+   * @return AbstractCapellaSearchResultEntry hierarchy in a root to leaf order (eg. tree like), void Stack otherwise.\r\n+   */\r\n+  public Stack<AbstractCapellaSearchEntry> getHierarchyFromRootToLeaf() {\r", "originalCommit": "27b879aac89491ea8e12aa6d6fb119f42e04ae05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4MzExMA==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375783110", "bodyText": "OK.", "author": "georgiana-ecobici", "createdAt": "2020-02-06T11:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1NTU4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "4e4e923c1ec49e16213486fc8cff9a8a96134db0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java\ndeleted file mode 100644\nindex 8a7ffb180..000000000\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/AbstractCapellaSearchEntry.java\n+++ /dev/null\n\n@@ -1,189 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *  \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.ui.search;\n-\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Stack;\n-\n-import org.eclipse.core.resources.IProject;\n-import org.eclipse.search.ui.text.Match;\n-\n-/**\n- * Entity responsible of model result hierarchical organization.\n- */\n-public abstract class AbstractCapellaSearchEntry extends Match {\n-  /** precedent AbstractCapellaSearchResultEntry in the hierarchical search query result thread */\n-  protected AbstractCapellaSearchEntry parent;\n-\n-  /** true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise */\n-  protected boolean matchedOnce;\n-\n-  /**\n-   * all AbstractCapellaSearchResultEntry children, potentially matches themselves or intermediary structural object(s)\n-   * for ordering purposes only)\n-   */\n-  private Collection<Object> children;\n-  \n-  private String text;\n-  \n-  private IProject project;\n-\n-  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source, boolean _matched, IProject _project) {\n-    super(_source, -1, -1);\n-    parent = _parent;\n-    children = new HashSet<Object>();\n-    project = _project;\n-    setMatchedOnce(_matched);\n-  }\n-\n-  public AbstractCapellaSearchEntry(AbstractCapellaSearchEntry _parent, Object _source,\n-      String _valuation, boolean _matched, IProject _project) {\n-    this(_parent, _source, _matched, _project);\n-    text = _valuation;\n-  }\n-  \n-  public String getText() {\n-    return text;\n-  }\n-  \n-  public void setText(String _text) {\n-    text = _text;\n-  }\n-  \n-  public Collection<Object> getChildren() {\n-    return children;\n-  }\n-\n-  public IProject getProject() {\n-    return project;\n-  }\n-  \n-  /**\n-   * Adds AbstractCapellaSearchResultEntry child, potentially match itself or intermediary structural object(s) for\n-   * ordering purposes only.\n-   */\n-  public void addChildren(AbstractCapellaSearchEntry e) {\n-    children.add(e);\n-  }\n-\n-  /**\n-   * Remove AbstractCapellaSearchResultEntry child, potentially match itself or intermediary structural object(s) for\n-   * ordering purposes only.\n-   */\n-  public void removeChildren(AbstractCapellaSearchEntry e) {\n-    children.remove(e);\n-  }\n-\n-  /////////////////////////\n-  // Getters / Setters\n-  /////////////////////////\n-\n-  /**\n-   * @return AbstractCapellaSearchResultEntry parent, potentially match itself or intermediary structural object(s) for\n-   *         ordering purposes only.\n-   */\n-  public AbstractCapellaSearchEntry getParent() {\n-    return parent;\n-  }\n-\n-  /**\n-   * Sets AbstractCapellaSearchResultEntry parent, potentially match itself or intermediary structural object(s) for\n-   * ordering purposes only.\n-   */\n-  public void setParent(AbstractCapellaSearchEntry p) {\n-    parent = p;\n-  }\n-\n-  /**\n-   * @return true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise\n-   */\n-  public boolean wasMatchedAtleastOnce() {\n-    return matchedOnce;\n-  }\n-\n-  /**\n-   * Set to true if a real match (eg. not an intermediary structural object for ordering purpose only), false otherwise\n-   */\n-  public void setMatchedOnce(boolean matchedOnce) {\n-    this.matchedOnce = matchedOnce;\n-  }\n-\n-  /**\n-   * @return AbstractCapellaSearchResultEntry hierarchy in a root to leaf order (eg. tree like), void Stack otherwise.\n-   */\n-  public Stack<AbstractCapellaSearchEntry> getHierarchyFromRootToLeaf() {\n-    Stack<AbstractCapellaSearchEntry> hierarchy = new Stack<AbstractCapellaSearchEntry>();\n-    getHierarchyFromRootToLeaf(this, hierarchy);\n-    return hierarchy;\n-  }\n-\n-  /**\n-   * @return AbstractCapellaSearchResultEntry hierarchy in a root to leaf order (eg. tree like), void Stack otherwise.\n-   */\n-  private void getHierarchyFromRootToLeaf(AbstractCapellaSearchEntry e,\n-      Stack<AbstractCapellaSearchEntry> hierarchy) {\n-    if (e instanceof AbstractCapellaSearchEntry) {\n-      hierarchy.push(e);\n-      getHierarchyFromRootToLeaf(e.getParent(), hierarchy);\n-    }\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    final int prime = 31;\n-    int result = 1;\n-    result = prime * result + ((parent == null) ? 0 : parent.hashCode());\n-    result = prime * result + ((getElement() == null) ? 0 : getElement().hashCode());\n-    return result;\n-  }\n-\n-  /**\n-   * Overriding the equals method allows to apply a 1-1 comparison to all elements of a result hierarchy in a reverse\n-   * order.\n-   * \n-   * This is needed for result hierarchy sub tree insertion algorithms.\n-   * \n-   * A simple example:\n-   * \n-   * LEFT | RIGHT ========|======== A1 | A1 |-B1 | |-B1 |-C1 | |-C1 |-C2 | |-C3\n-   * \n-   * Trying to insert A1->(B1->(C3)) into existing A1->(B1->(C1, C2)) hierarchy implies being able to evaluate until\n-   * which point two elements of the same level are still equals or not.\n-   * \n-   * Here, each comparison A1 <> A1, B1 <> B1, C1 <> C3 implies their ancestor to be compared back on a 1-1 basis.\n-   * \n-   * This means that comparing left side A1.B1.C1 & right side A1.B1.C1 is something like: C1==C1 && B1==B1 && A1==A1\n-   * (eg: a back comparison to the root).\n-   * \n-   */\n-  @Override\n-  public boolean equals(Object obj) {\n-    if (this == obj)\n-      return true;\n-    if (obj == null)\n-      return false;\n-    if (getClass() != obj.getClass())\n-      return false;\n-    final AbstractCapellaSearchEntry other = (AbstractCapellaSearchEntry) obj;\n-    if (getElement() == null) {\n-      if (other.getElement() != null)\n-        return false;\n-    } else if (!getElement().equals(other.getElement()))\n-      return false;\n-    if (parent == null) {\n-      if (other.parent != null)\n-        return false;\n-    } else if (!parent.equals(other.parent))\n-      return false;\n-    return true;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1NjQzNg==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375756436", "bodyText": "This has not been finished, isn't it?", "author": "minhtutonthat", "createdAt": "2020-02-06T10:33:17Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.stream.Collectors;\r\n+import java.util.stream.Stream;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.emf.ecore.EAttribute;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.EStructuralFeature;\r\n+import org.eclipse.emf.ecore.ETypedElement;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.jface.resource.ImageDescriptor;\r\n+import org.eclipse.search.ui.text.AbstractTextSearchResult;\r\n+import org.eclipse.search.ui.text.IEditorMatchAdapter;\r\n+import org.eclipse.search.ui.text.IFileMatchAdapter;\r\n+import org.eclipse.search.ui.text.MatchFilter;\r\n+\r\n+public class CapellaSearchResult extends AbstractTextSearchResult {\r\n+\r\n+  private CapellaSearchQuery capellaSearchQuery;\r\n+\r\n+  /**\r\n+   * Current Search Entries\r\n+   */\r\n+  private Map<Object, Collection<Object>> searchEntries;\r\n+  private Map<Object, AbstractCapellaSearchEntry> elementToMatches = new HashMap();\r\n+  \r\n+  public CapellaSearchResult(CapellaSearchQuery capellaSearchQuery) {\r\n+    this.capellaSearchQuery = capellaSearchQuery;\r\n+    setActiveMatchFilters(new MatchFilter[] {}); // By default, no filter is activated\r\n+    searchEntries = new HashMap<Object, Collection<Object>>();\r\n+  }\r\n+  \r\n+  @Override\r\n+  public String getLabel() {\r\n+    int totalOccurrenceCount = getOccurrenceCount();\r\n+    int matchedElementsCount = getElements().length;\r\n+    int matchedProjectsCount = getProjects().size();\r\n+    String queryLabel = capellaSearchQuery.getLabel();\r\n+    int activeFilterCount = getActiveMatchFilters().length;\r\n+    if (activeFilterCount == 0) {\r\n+      return String.format(Messages.CapellaSearchResult_Label, queryLabel, totalOccurrenceCount, matchedElementsCount,\r\n+          matchedProjectsCount);\r\n+    }\r\n+    int displayedOccurrenceCount = 0; //getDisplayedOccurrenceCount();\r\n+    return String.format(Messages.CapellaSearchResult_Label_With_Active_Filters, queryLabel, totalOccurrenceCount,\r\n+        matchedElementsCount, matchedProjectsCount, totalOccurrenceCount - displayedOccurrenceCount, activeFilterCount);\r\n+  }\r\n+\r\n+  @Override\r\n+  public String getTooltip() {\r\n+    return getLabel();\r\n+  }\r\n+\r\n+  @Override\r\n+  public ImageDescriptor getImageDescriptor() {\r\n+    return Activator.getDefault().getImageDescriptor(\"search.gif\"); //$NON-NLS-1$\r\n+  }\r\n+\r\n+  @Override\r\n+  public CapellaSearchQuery getQuery() {\r\n+    return capellaSearchQuery;\r\n+  }\r\n+\r\n+  @Override\r\n+  public IEditorMatchAdapter getEditorMatchAdapter() {\r\n+    return null;\r\n+  }\r\n+\r\n+  @Override\r\n+  public IFileMatchAdapter getFileMatchAdapter() {\r\n+    return null;\r\n+  }\r\n+\r\n+  /**\r\n+   * Get all projects from matches\r\n+   * \r\n+   * @return\r\n+   */\r\n+  public Set<Object> getProjects() {\r\n+    return searchEntries.keySet();\r\n+  }\r\n+\r\n+  @Override\r\n+  public MatchFilter[] getAllMatchFilters() {\r\n+    return new MatchFilter[] { //\r\n+//        CapellaSearchMatchFilter.NOT_MODIFIABLE, //\r\n+//        CapellaSearchMatchFilter.CAPELLA_ELEMENT, //\r\n+//        CapellaSearchMatchFilter.REPRESENTATION //\r\n+    };\r\n+  }\r\n+\r\n+  /////////\r\n+  \r\n+  \r\n+  /**\r\n+   * {@inheritDoc}\r\n+   */\r\n+  public AbstractCapellaSearchEntry insert(Object file, AbstractCapellaSearchEntry entry, boolean notify) {\r\n+    if (searchEntries.get(file) == null) {\r\n+      searchEntries.put(file, new ArrayList<Object>());\r\n+    }\r\n+    insert2(searchEntries.get(file), entry, notify);\r\n+    return entry;\r\n+  }\r\n+\r\n+  /**\r\n+   * {@inheritDoc}\r\n+   */\r\n+  public AbstractCapellaSearchEntry insert(Object file, AbstractCapellaSearchEntry entry, Object eTypedElem, String valuation,\r\n+      boolean notify) {\r\n+    return insert5(entry, eTypedElem, valuation, notify, file);\r\n+  }\r\n+\r\n+  /**\r\n+   * Inserts & merges an entry sequence into an existing entry sequence hierarchy\r\n+   * \r\n+   * @param currentEntrySubHierarchyCollection\r\n+   * @param entryToInsert\r\n+   * @param notify\r\n+   */\r\n+  private void insert2(Collection<Object> currentEntrySubHierarchyCollection, AbstractCapellaSearchEntry entryToInsert,\r\n+      boolean notify) {\r\n+\r\n+      boolean alreadyExist = false;\r\n+      for (Object currentEntrySubHierarchy : currentEntrySubHierarchyCollection) {\r\n+        if (alreadyExist = currentEntrySubHierarchy.equals(entryToInsert)) {\r\n+          updateInsertionPoint((AbstractCapellaSearchEntry) currentEntrySubHierarchy, (AbstractCapellaSearchEntry) entryToInsert);\r\n+          insert3(currentEntrySubHierarchy, entryToInsert.getChildren(), notify);\r\n+          break;\r\n+        }\r\n+      }\r\n+      if (!alreadyExist) {\r\n+        currentEntrySubHierarchyCollection.add(entryToInsert);\r\n+        if (notify) {\r", "originalCommit": "27b879aac89491ea8e12aa6d6fb119f42e04ae05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4MzQxNg==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375783416", "bodyText": "I didn't use the notify, will be removed.", "author": "georgiana-ecobici", "createdAt": "2020-02-06T11:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1NjQzNg=="}], "type": "inlineReview", "revised_code": {"commit": "4e4e923c1ec49e16213486fc8cff9a8a96134db0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\nindex 0d8ce3273..5e198a5b1 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\n\n@@ -30,21 +30,17 @@ import org.eclipse.search.ui.text.AbstractTextSearchResult;\n import org.eclipse.search.ui.text.IEditorMatchAdapter;\n import org.eclipse.search.ui.text.IFileMatchAdapter;\n import org.eclipse.search.ui.text.MatchFilter;\n+import org.polarsys.capella.common.ui.toolkit.viewers.data.TreeData;\n \n public class CapellaSearchResult extends AbstractTextSearchResult {\n \n   private CapellaSearchQuery capellaSearchQuery;\n-\n-  /**\n-   * Current Search Entries\n-   */\n-  private Map<Object, Collection<Object>> searchEntries;\n-  private Map<Object, AbstractCapellaSearchEntry> elementToMatches = new HashMap();\n+  private TreeData treeData;\n   \n   public CapellaSearchResult(CapellaSearchQuery capellaSearchQuery) {\n     this.capellaSearchQuery = capellaSearchQuery;\n     setActiveMatchFilters(new MatchFilter[] {}); // By default, no filter is activated\n-    searchEntries = new HashMap<Object, Collection<Object>>();\n+    treeData = new TreeData(new ArrayList(), null);\n   }\n   \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc1NjYzNQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r375756635", "bodyText": "Same remark as above", "author": "minhtutonthat", "createdAt": "2020-02-06T10:33:40Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.Collections;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+import java.util.stream.Collectors;\r\n+import java.util.stream.Stream;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.emf.ecore.EAttribute;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.emf.ecore.EStructuralFeature;\r\n+import org.eclipse.emf.ecore.ETypedElement;\r\n+import org.eclipse.emf.ecore.util.EcoreUtil;\r\n+import org.eclipse.jface.resource.ImageDescriptor;\r\n+import org.eclipse.search.ui.text.AbstractTextSearchResult;\r\n+import org.eclipse.search.ui.text.IEditorMatchAdapter;\r\n+import org.eclipse.search.ui.text.IFileMatchAdapter;\r\n+import org.eclipse.search.ui.text.MatchFilter;\r\n+\r\n+public class CapellaSearchResult extends AbstractTextSearchResult {\r\n+\r\n+  private CapellaSearchQuery capellaSearchQuery;\r\n+\r\n+  /**\r\n+   * Current Search Entries\r\n+   */\r\n+  private Map<Object, Collection<Object>> searchEntries;\r\n+  private Map<Object, AbstractCapellaSearchEntry> elementToMatches = new HashMap();\r\n+  \r\n+  public CapellaSearchResult(CapellaSearchQuery capellaSearchQuery) {\r\n+    this.capellaSearchQuery = capellaSearchQuery;\r\n+    setActiveMatchFilters(new MatchFilter[] {}); // By default, no filter is activated\r\n+    searchEntries = new HashMap<Object, Collection<Object>>();\r\n+  }\r\n+  \r\n+  @Override\r\n+  public String getLabel() {\r\n+    int totalOccurrenceCount = getOccurrenceCount();\r\n+    int matchedElementsCount = getElements().length;\r\n+    int matchedProjectsCount = getProjects().size();\r\n+    String queryLabel = capellaSearchQuery.getLabel();\r\n+    int activeFilterCount = getActiveMatchFilters().length;\r\n+    if (activeFilterCount == 0) {\r\n+      return String.format(Messages.CapellaSearchResult_Label, queryLabel, totalOccurrenceCount, matchedElementsCount,\r\n+          matchedProjectsCount);\r\n+    }\r\n+    int displayedOccurrenceCount = 0; //getDisplayedOccurrenceCount();\r\n+    return String.format(Messages.CapellaSearchResult_Label_With_Active_Filters, queryLabel, totalOccurrenceCount,\r\n+        matchedElementsCount, matchedProjectsCount, totalOccurrenceCount - displayedOccurrenceCount, activeFilterCount);\r\n+  }\r\n+\r\n+  @Override\r\n+  public String getTooltip() {\r\n+    return getLabel();\r\n+  }\r\n+\r\n+  @Override\r\n+  public ImageDescriptor getImageDescriptor() {\r\n+    return Activator.getDefault().getImageDescriptor(\"search.gif\"); //$NON-NLS-1$\r\n+  }\r\n+\r\n+  @Override\r\n+  public CapellaSearchQuery getQuery() {\r\n+    return capellaSearchQuery;\r\n+  }\r\n+\r\n+  @Override\r\n+  public IEditorMatchAdapter getEditorMatchAdapter() {\r\n+    return null;\r\n+  }\r\n+\r\n+  @Override\r\n+  public IFileMatchAdapter getFileMatchAdapter() {\r\n+    return null;\r\n+  }\r\n+\r\n+  /**\r\n+   * Get all projects from matches\r\n+   * \r\n+   * @return\r\n+   */\r\n+  public Set<Object> getProjects() {\r\n+    return searchEntries.keySet();\r\n+  }\r\n+\r\n+  @Override\r\n+  public MatchFilter[] getAllMatchFilters() {\r\n+    return new MatchFilter[] { //\r\n+//        CapellaSearchMatchFilter.NOT_MODIFIABLE, //\r\n+//        CapellaSearchMatchFilter.CAPELLA_ELEMENT, //\r\n+//        CapellaSearchMatchFilter.REPRESENTATION //\r\n+    };\r\n+  }\r\n+\r\n+  /////////\r\n+  \r\n+  \r\n+  /**\r\n+   * {@inheritDoc}\r\n+   */\r\n+  public AbstractCapellaSearchEntry insert(Object file, AbstractCapellaSearchEntry entry, boolean notify) {\r\n+    if (searchEntries.get(file) == null) {\r\n+      searchEntries.put(file, new ArrayList<Object>());\r\n+    }\r\n+    insert2(searchEntries.get(file), entry, notify);\r\n+    return entry;\r\n+  }\r\n+\r\n+  /**\r\n+   * {@inheritDoc}\r\n+   */\r\n+  public AbstractCapellaSearchEntry insert(Object file, AbstractCapellaSearchEntry entry, Object eTypedElem, String valuation,\r\n+      boolean notify) {\r\n+    return insert5(entry, eTypedElem, valuation, notify, file);\r\n+  }\r\n+\r\n+  /**\r\n+   * Inserts & merges an entry sequence into an existing entry sequence hierarchy\r\n+   * \r\n+   * @param currentEntrySubHierarchyCollection\r\n+   * @param entryToInsert\r\n+   * @param notify\r\n+   */\r\n+  private void insert2(Collection<Object> currentEntrySubHierarchyCollection, AbstractCapellaSearchEntry entryToInsert,\r\n+      boolean notify) {\r\n+\r\n+      boolean alreadyExist = false;\r\n+      for (Object currentEntrySubHierarchy : currentEntrySubHierarchyCollection) {\r\n+        if (alreadyExist = currentEntrySubHierarchy.equals(entryToInsert)) {\r\n+          updateInsertionPoint((AbstractCapellaSearchEntry) currentEntrySubHierarchy, (AbstractCapellaSearchEntry) entryToInsert);\r\n+          insert3(currentEntrySubHierarchy, entryToInsert.getChildren(), notify);\r\n+          break;\r\n+        }\r\n+      }\r\n+      if (!alreadyExist) {\r\n+        currentEntrySubHierarchyCollection.add(entryToInsert);\r\n+        if (notify) {\r\n+          // fireItemAdded(entryToInsert);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Inserts & merges an entry into an existing entry sequence hierarchy\r\n+   * \r\n+   * @param currentEntrySubHierarchy\r\n+   * @param entrySubtreeToInsertCollection\r\n+   * @param notify\r\n+   */\r\n+  private void insert3(Object currentEntrySubHierarchy, Collection<Object> entrySubtreeToInsertCollection,\r\n+      boolean notify) {\r\n+    for (Object e2i : entrySubtreeToInsertCollection) {\r\n+      if (e2i instanceof AbstractCapellaSearchEntry && currentEntrySubHierarchy instanceof AbstractCapellaSearchEntry) {\r\n+        if (currentEntrySubHierarchy.equals(e2i)) {\r\n+          updateInsertionPoint((AbstractCapellaSearchEntry) currentEntrySubHierarchy, (AbstractCapellaSearchEntry) e2i);\r\n+        }\r\n+        insert2(((AbstractCapellaSearchEntry) currentEntrySubHierarchy).getChildren(), (AbstractCapellaSearchEntry) e2i, notify);\r\n+      }\r\n+    }\r\n+  }\r\n+\r\n+  /**\r\n+   * Inserts & merges an entry sequence into an existing entry\r\n+   * \r\n+   * @param compoundEntryToInsert\r\n+   * @param entryToInsert\r\n+   * @param notify\r\n+   * \r\n+   * @return newly inserted occurence entry\r\n+   */\r\n+  private AbstractCapellaSearchEntry insert5(AbstractCapellaSearchEntry entryHierarchyIntoWhichInsert, Object eTypedElem, String text,\r\n+      boolean notify, Object file) {\r\n+    CapellaSearchMatchOccurence occurence = null;\r\n+    for (Object result : entryHierarchyIntoWhichInsert.getChildren()) {\r\n+      if (result instanceof CapellaSearchMatchOccurence) {\r\n+        AbstractCapellaSearchEntry oc = (AbstractCapellaSearchEntry) result;\r\n+        if (isAnInvalidETypedElement(((EObject) oc.getElement()), (ETypedElement) eTypedElem)\r\n+            || isAnAlreadyExistingOccurenceValuation(text, (ETypedElement) eTypedElem, (CapellaSearchMatchOccurence) oc)) {\r\n+          return occurence;\r\n+        }\r\n+      }\r\n+    }\r\n+    occurence = new CapellaSearchMatchOccurence(entryHierarchyIntoWhichInsert, eTypedElem, text,\r\n+        true, (IProject)file);\r\n+    \r\n+    entryHierarchyIntoWhichInsert.addChildren(occurence);\r\n+\r\n+    if (notify) {\r", "originalCommit": "27b879aac89491ea8e12aa6d6fb119f42e04ae05", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4e4e923c1ec49e16213486fc8cff9a8a96134db0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\nindex 0d8ce3273..5e198a5b1 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchResult.java\n\n@@ -30,21 +30,17 @@ import org.eclipse.search.ui.text.AbstractTextSearchResult;\n import org.eclipse.search.ui.text.IEditorMatchAdapter;\n import org.eclipse.search.ui.text.IFileMatchAdapter;\n import org.eclipse.search.ui.text.MatchFilter;\n+import org.polarsys.capella.common.ui.toolkit.viewers.data.TreeData;\n \n public class CapellaSearchResult extends AbstractTextSearchResult {\n \n   private CapellaSearchQuery capellaSearchQuery;\n-\n-  /**\n-   * Current Search Entries\n-   */\n-  private Map<Object, Collection<Object>> searchEntries;\n-  private Map<Object, AbstractCapellaSearchEntry> elementToMatches = new HashMap();\n+  private TreeData treeData;\n   \n   public CapellaSearchResult(CapellaSearchQuery capellaSearchQuery) {\n     this.capellaSearchQuery = capellaSearchQuery;\n     setActiveMatchFilters(new MatchFilter[] {}); // By default, no filter is activated\n-    searchEntries = new HashMap<Object, Collection<Object>>();\n+    treeData = new TreeData(new ArrayList(), null);\n   }\n   \n   @Override\n"}}, {"oid": "4e4e923c1ec49e16213486fc8cff9a8a96134db0", "url": "https://github.com/eclipse/capella/commit/4e4e923c1ec49e16213486fc8cff9a8a96134db0", "message": "Navigator\n\nChange-Id: If511a14c484f9f8cca3e3f4a71ed1d630b43fe9c\n\nRefactored show result as tree\n\n\nChange-Id: Ib3ad3ff88d9cfd913898e8ca2764202e1351ce00\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-07T13:57:58Z", "type": "commit"}, {"oid": "4f5f90aeb7978ad40f7ccd1ace53b6f577246100", "url": "https://github.com/eclipse/capella/commit/4f5f90aeb7978ad40f7ccd1ace53b6f577246100", "message": "Show result as tree/list\n\nChange-Id: I895b7dcbe37f7eff678001259749a533812d9ccd\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-07T16:01:44Z", "type": "commit"}, {"oid": "dec2aefa54026ef28899ada71bc4e032ea904c8b", "url": "https://github.com/eclipse/capella/commit/dec2aefa54026ef28899ada71bc4e032ea904c8b", "message": "Search result tree/table + replace in result\n\nChange-Id: I2c64bbd28544c9774aa73dabdd9bb7bbb3d9bf7d", "committedDate": "2020-02-10T10:02:40Z", "type": "commit"}, {"oid": "3e8b169585d150fd4f890457c969472e2ef950de", "url": "https://github.com/eclipse/capella/commit/3e8b169585d150fd4f890457c969472e2ef950de", "message": "Search result tree/table + replace in result\n\nChange-Id: I21d72f408776da64ceef36c0379dfdbee510b89d\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-10T10:10:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY1MjQ3Ng==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r377652476", "bodyText": "Will this commented code be used in the future ?", "author": "Cosmin-Visan", "createdAt": "2020-02-11T14:03:37Z", "path": "core/plugins/org.polarsys.capella.core.ui.search_cdb/src/org/polarsys/capella/core/ui/search_cdb/CapellaSearchResultTreeContentProvider.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search_cdb;\r\n+\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.emf.ecore.EObject;\r\n+import org.eclipse.jface.viewers.ITreeContentProvider;\r\n+import org.eclipse.jface.viewers.Viewer;\r\n+import org.polarsys.capella.core.platform.sirius.ui.navigator.viewer.CapellaNavigatorContentProvider;\r\n+\r\n+public class CapellaSearchResultTreeContentProvider extends CapellaNavigatorContentProvider {\r\n+  private CapellaSearchResult_CDB searchResult;\r\n+\r\n+  public CapellaSearchResultTreeContentProvider(CapellaSearchResultPage_CDB capellaSearchResultPage) {\r\n+    super();\r\n+    searchResult = capellaSearchResultPage.getInput();\r\n+  }\r\n+  \r\n+  public Object[] getChildren(Object parentElement) {\r\n+    if (parentElement instanceof CapellaSearchMatch_CDB) {\r\n+      return ((CapellaSearchMatch_CDB)parentElement).getMatchOccurrences().toArray();\r\n+    }\r\n+    return super.getChildren(parentElement);\r\n+  }\r\n+  \r\n+  public Object getParent(Object element) {\r\n+    if (element instanceof CapellaSearchMatch_CDB) {\r\n+      return super.getParent(((CapellaSearchMatch_CDB)element).getElement());\r\n+    }\r\n+    return super.getParent(element);\r\n+  }\r\n+  \r\n+  @Override\r\n+  public Object[] getElements(Object inputElement) {\r\n+    if (inputElement instanceof CapellaSearchResult_CDB) {\r\n+      CapellaSearchResult_CDB input = (CapellaSearchResult_CDB) inputElement;\r\n+      Set<IProject> files = input.getProjects();\r\n+      return files.toArray();\r\n+    }\r\n+    return super.getElements(inputElement);\r\n+  }\r\n+  \r\n+  @Override\r\n+  public boolean hasChildren(Object element) {\r\n+    if (element instanceof IProject) {\r\n+      return true;\r\n+    } else if (element instanceof CapellaSearchMatch_CDB) {\r\n+      return !((CapellaSearchMatch_CDB) element).getMatchOccurrences().isEmpty();\r\n+    }\r\n+    return super.hasChildren(element);\r\n+  }\r\n+  \r\n+  /*public Object[] getSources(Object[] input) {\r", "originalCommit": "3e8b169585d150fd4f890457c969472e2ef950de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY2MDY2NQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r377660665", "bodyText": "No, I accidentally commited this file. I will remove it.", "author": "georgiana-ecobici", "createdAt": "2020-02-11T14:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY1MjQ3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search_cdb/src/org/polarsys/capella/core/ui/search_cdb/CapellaSearchResultTreeContentProvider.java b/core/plugins/org.polarsys.capella.core.ui.search_cdb/src/org/polarsys/capella/core/ui/search_cdb/CapellaSearchResultTreeContentProvider.java\ndeleted file mode 100644\nindex e71431c00..000000000\n--- a/core/plugins/org.polarsys.capella.core.ui.search_cdb/src/org/polarsys/capella/core/ui/search_cdb/CapellaSearchResultTreeContentProvider.java\n+++ /dev/null\n\n@@ -1,134 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *  \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.ui.search_cdb;\n-\n-import java.util.Set;\n-\n-import org.eclipse.core.resources.IProject;\n-import org.eclipse.emf.ecore.EObject;\n-import org.eclipse.jface.viewers.ITreeContentProvider;\n-import org.eclipse.jface.viewers.Viewer;\n-import org.polarsys.capella.core.platform.sirius.ui.navigator.viewer.CapellaNavigatorContentProvider;\n-\n-public class CapellaSearchResultTreeContentProvider extends CapellaNavigatorContentProvider {\n-  private CapellaSearchResult_CDB searchResult;\n-\n-  public CapellaSearchResultTreeContentProvider(CapellaSearchResultPage_CDB capellaSearchResultPage) {\n-    super();\n-    searchResult = capellaSearchResultPage.getInput();\n-  }\n-  \n-  public Object[] getChildren(Object parentElement) {\n-    if (parentElement instanceof CapellaSearchMatch_CDB) {\n-      return ((CapellaSearchMatch_CDB)parentElement).getMatchOccurrences().toArray();\n-    }\n-    return super.getChildren(parentElement);\n-  }\n-  \n-  public Object getParent(Object element) {\n-    if (element instanceof CapellaSearchMatch_CDB) {\n-      return super.getParent(((CapellaSearchMatch_CDB)element).getElement());\n-    }\n-    return super.getParent(element);\n-  }\n-  \n-  @Override\n-  public Object[] getElements(Object inputElement) {\n-    if (inputElement instanceof CapellaSearchResult_CDB) {\n-      CapellaSearchResult_CDB input = (CapellaSearchResult_CDB) inputElement;\n-      Set<IProject> files = input.getProjects();\n-      return files.toArray();\n-    }\n-    return super.getElements(inputElement);\n-  }\n-  \n-  @Override\n-  public boolean hasChildren(Object element) {\n-    if (element instanceof IProject) {\n-      return true;\n-    } else if (element instanceof CapellaSearchMatch_CDB) {\n-      return !((CapellaSearchMatch_CDB) element).getMatchOccurrences().isEmpty();\n-    }\n-    return super.hasChildren(element);\n-  }\n-  \n-  /*public Object[] getSources(Object[] input) {\n-    Object[] res = new Object[input.length];\n-    for(int i = 0; i < input.length; i++) {\n-      if(input[i] instanceof CapellaSearchMatchEntry) {\n-        CapellaSearchMatchEntry entry = (CapellaSearchMatchEntry)input[i];\n-        res[i] = entry.getElement();\n-      }\n-      else {\n-        res[i] = input[i];\n-      }\n-    }\n-    return res;\n-  }\n-  public Object[] getChildren(Object parentElement) {\n-    if (parentElement instanceof IProject) {\n-      return getSources(searchResult.getRootResultHierarchies().get((IProject) parentElement).toArray());\n-    } else if (parentElement instanceof CapellaSearchMatch_CDB) {\n-      return getSources(((CapellaSearchMatch_CDB) parentElement).getChildren().toArray());\n-    }\n-    else if(parentElement instanceof EObject) {\n-      CapellaSearchMatch_CDB a = searchResult.getElementToMatches().get(parentElement);\n-      if(a != null)\n-        return getSources(((CapellaSearchMatch_CDB) a).getChildren().toArray());\n-    }\n-    return new Object[0];\n-  }\n-\n-  public Object getParent(Object element) {\n-    if (element instanceof Resource) {\n-      return searchResult;\n-    } else if (element instanceof CapellaSearchMatch_CDB) {\n-      return ((CapellaSearchMatch_CDB) element).getParent();\n-    }\n-    else if(element instanceof EObject) {\n-      CapellaSearchMatch_CDB a = searchResult.getElementToMatches().get(element);\n-      if(a != null && a.getParent() != null)\n-        return a.getParent().getElement();\n-    }\n-    return null;\n-  }\n-\n-  public boolean hasChildren(Object element) {\n-    if (element instanceof IProject) {\n-      return true;\n-    } else if (element instanceof CapellaSearchMatch_CDB) {\n-      return !((CapellaSearchMatch_CDB) element).getChildren().isEmpty();\n-    } else if(element instanceof EObject) {\n-      CapellaSearchMatch_CDB a = searchResult.getElementToMatches().get(element);\n-      if(a != null)\n-        return !((CapellaSearchMatch_CDB) a).getChildren().isEmpty();\n-    }\n-    return false;\n-  }\n-\n-  public Object[] getElements(Object inputElement) {\n-    if (inputElement instanceof CapellaSearchResult) {\n-      CapellaSearchResult input = (CapellaSearchResult) inputElement;\n-      Set<Object> files = input.getRootResultHierarchies().keySet();\n-      return getSources(files.toArray());\n-    } else if (inputElement instanceof Collection) {\n-      return ((Collection<?>) inputElement).toArray();\n-    }\n-    return new Object[0];\n-  }\n-  */\n-\n-  public void inputChanged(Viewer viewer, Object oldInput, Object newInput) {\n-    if (newInput instanceof CapellaSearchResult_CDB) {\n-      searchResult = (CapellaSearchResult_CDB) newInput;\n-    }\n-  }\n-}\n"}}, {"oid": "63f433e930f1bef11bb4735f446147bf1cca4e48", "url": "https://github.com/eclipse/capella/commit/63f433e930f1bef11bb4735f446147bf1cca4e48", "message": "Added Search For Section\n - Model Elements\n - Attributes\n\n Incomplete:\n - Diagram Elements\n - Filter attributes based on the Meta Classes in left panel\n\nChange-Id: I643f4c8229321070d32298a695c606d2ca775467\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-11T16:03:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxMzE1MQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378213151", "bodyText": "Remove this import", "author": "minhtutonthat", "createdAt": "2020-02-12T12:12:08Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.Collection;\r\n+import java.util.EnumMap;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Map.Entry;\r\n+import java.util.Set;\r\n+import java.util.function.Predicate;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import javax.swing.JTable;\r\n+import org.eclipse.core.internal.resources.File;\r\n+import org.eclipse.core.resources.IFile;\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.core.resources.IWorkspaceRoot;\r\n+import org.eclipse.core.resources.ResourcesPlugin;\r\n+import org.eclipse.core.runtime.IStatus;\r\n+import org.eclipse.core.runtime.Path;\r\n+import org.eclipse.emf.common.util.EList;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EReference;\r\n+import org.eclipse.jface.dialogs.Dialog;\r\n+import org.eclipse.jface.dialogs.DialogPage;\r\n+import org.eclipse.jface.dialogs.MessageDialog;\r\n+import org.eclipse.jface.fieldassist.ComboContentAdapter;\r\n+import org.eclipse.jface.layout.GridDataFactory;\r\n+import org.eclipse.jface.layout.GridLayoutFactory;\r\n+import org.eclipse.jface.resource.JFaceColors;\r\n+import org.eclipse.jface.text.FindReplaceDocumentAdapterContentProposalProvider;\r\n+import org.eclipse.jface.viewers.CheckboxTableViewer;\r\n+import org.eclipse.jface.viewers.Viewer;\r\n+import org.eclipse.search.ui.IReplacePage;\r\n+import org.eclipse.search.ui.ISearchPage;\r\n+import org.eclipse.search.ui.ISearchPageContainer;\r\n+import org.eclipse.search.ui.NewSearchUI;\r\n+import org.eclipse.sirius.business.api.dialect.DialectManager;\r\n+import org.eclipse.sirius.business.api.session.Session;\r\n+import org.eclipse.sirius.business.api.session.SessionManager;\r\n+import org.eclipse.sirius.viewpoint.DRepresentationDescriptor;\r\n+import org.eclipse.sirius.viewpoint.DRepresentationElement;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.custom.CLabel;\r\n+import org.eclipse.swt.events.SelectionAdapter;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Combo;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Group;\r\n+import org.eclipse.swt.widgets.Label;\r\n+import org.eclipse.swt.widgets.Table;\r\n+import org.eclipse.ui.dialogs.PatternFilter;\r\n+import org.eclipse.ui.fieldassist.ContentAssistCommandAdapter;\r\n+import org.eclipse.ui.texteditor.ITextEditorActionDefinitionIds;\r\n+import org.polarsys.capella.core.model.handler.command.CapellaResourceHelper;\r\n+import org.polarsys.capella.core.sirius.ui.helper.SessionHelper;\r\n+import org.polarsys.capella.core.ui.search.searchfor.CapellaLeftSearchForContainerArea;\r\n+import org.polarsys.capella.core.ui.search.searchfor.CapellaRightSearchForContainerArea;\r\n+import org.polarsys.capella.test.framework.helpers.TestHelper;\r", "originalCommit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzc5OQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378317799", "bodyText": "Ok", "author": "georgiana-ecobici", "createdAt": "2020-02-12T15:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxMzE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA5MzcyOA==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r380093728", "bodyText": "Done.", "author": "georgiana-ecobici", "createdAt": "2020-02-17T10:16:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxMzE1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "987ecfbc82508d7c68ba767833cc2aa3dbe9bad1", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java\nindex 000e8e21f..63e938256 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java\n\n@@ -266,6 +266,7 @@ public class CapellaSearchPage extends DialogPage implements ISearchPage, IRepla\n     qGrp.setText(Messages.SearchFor_Label);\n     CapellaLeftSearchForContainerArea leftCont = new CapellaLeftSearchForContainerArea(qGrp);\n     CapellaRightSearchForContainerArea rightCont = new CapellaRightSearchForContainerArea(qGrp, leftCont);\n+    leftCont.setOtherSideArea(rightCont);\n     createFiltercontainer(qGrp);\n   }\n   \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxNDAwMQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378214001", "bodyText": "Add org.eclipse.sirius.diagram to MANIFEST.MF", "author": "minhtutonthat", "createdAt": "2020-02-12T12:14:06Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/MetaClassesParticipantsItemProvider.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search.searchfor;\r\n+\r\n+import java.util.Collection;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.resources.IProject;\r\n+import org.eclipse.core.resources.ResourcesPlugin;\r\n+import org.eclipse.emf.common.util.EList;\r\n+import org.eclipse.emf.ecore.EAttribute;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.EClassifier;\r\n+import org.eclipse.emf.ecore.EPackage;\r\n+import org.eclipse.sirius.business.api.dialect.DialectManager;\r\n+import org.eclipse.sirius.business.api.session.Session;\r\n+import org.eclipse.sirius.diagram.DiagramPackage;\r", "originalCommit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA5NDY5Ng==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r380094696", "bodyText": "I have: org.eclipse.sirius.common.ui.", "author": "georgiana-ecobici", "createdAt": "2020-02-17T10:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxNDAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "bbae0fdb01314c0ef9bb61db83b81a62c0a8c0e0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/MetaClassesParticipantsItemProvider.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/MetaClassesParticipantsItemProvider.java\nindex faef46707..577b03feb 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/MetaClassesParticipantsItemProvider.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/MetaClassesParticipantsItemProvider.java\n\n@@ -29,7 +29,7 @@ import org.eclipse.sirius.diagram.DiagramPackage;\n import org.eclipse.sirius.viewpoint.DRepresentationDescriptor;\n import org.eclipse.sirius.viewpoint.DRepresentationElement;\n import org.polarsys.capella.core.sirius.ui.helper.SessionHelper;\n-import org.polarsys.capella.core.ui.search.Messages;\n+import org.polarsys.capella.core.ui.search.CapellaSearchConstants;\n \n public class MetaClassesParticipantsItemProvider extends AbstractMetaModelParticipantsItemProvider {\n   private AbstractCapellaSearchForContainerArea area = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxNDY1Nw==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378214657", "bodyText": "Remove unused imports. There are many of them.", "author": "minhtutonthat", "createdAt": "2020-02-12T12:15:31Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java", "diffHunk": "@@ -0,0 +1,389 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.ArrayList;\r", "originalCommit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNzkxMA==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378317910", "bodyText": "OK", "author": "georgiana-ecobici", "createdAt": "2020-02-12T15:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxNDY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA5NDczMQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r380094731", "bodyText": "Done.", "author": "georgiana-ecobici", "createdAt": "2020-02-17T10:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxNDY1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "987ecfbc82508d7c68ba767833cc2aa3dbe9bad1", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java\nindex 000e8e21f..63e938256 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchPage.java\n\n@@ -266,6 +266,7 @@ public class CapellaSearchPage extends DialogPage implements ISearchPage, IRepla\n     qGrp.setText(Messages.SearchFor_Label);\n     CapellaLeftSearchForContainerArea leftCont = new CapellaLeftSearchForContainerArea(qGrp);\n     CapellaRightSearchForContainerArea rightCont = new CapellaRightSearchForContainerArea(qGrp, leftCont);\n+    leftCont.setOtherSideArea(rightCont);\n     createFiltercontainer(qGrp);\n   }\n   \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyNzg3NQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378227875", "bodyText": "Could you try to abstract this class and CapellaReplaceHistory to have a common class since they have a lot in common?", "author": "minhtutonthat", "createdAt": "2020-02-12T12:45:25Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchSettingsHistory.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search;\r\n+\r\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+\r\n+import org.eclipse.jface.dialogs.IDialogSettings;\r\n+\r\n+public class CapellaSearchSettingsHistory {\r", "originalCommit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxODAyMQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378318021", "bodyText": "Ok", "author": "georgiana-ecobici", "createdAt": "2020-02-12T15:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyNzg3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bbae0fdb01314c0ef9bb61db83b81a62c0a8c0e0", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchSettingsHistory.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchSettingsHistory.java\nindex 0cc9df4b5..edefaf35c 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchSettingsHistory.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/CapellaSearchSettingsHistory.java\n\n@@ -10,155 +10,25 @@\n  *******************************************************************************/\n package org.polarsys.capella.core.ui.search;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-\n import org.eclipse.jface.dialogs.IDialogSettings;\n \n-public class CapellaSearchSettingsHistory {\n-\n-  private static final int HISTORY_SIZE = 5;\n-\n-  private static final String SECTION_SEARCH = \"org.polarsys.capella.core.ui.search.page\";\n-  private static final String SECTION_HISTORY_PREFIX = \"history\";\n-  private static final String SECTION_HISTORY_COUNT = \"history.count\";\n+public class CapellaSearchSettingsHistory extends AbstractCapellaHistory {\n \n   private static final String SECTION_SEARCH_PATTERN = \"pattern\";\n   private static final String SECTION_SEARCH_REGEX = \"regex\";\n   private static final String SECTION_SEARCH_CASE_SENSITIVE = \"case.sensitive\";\n \n-  private static final String SECTION_SEARCH_FIELD_PREFIX = \"field\";\n-  private static final String SECTION_SEARCH_FIELD_COUNT = \"field.count\";\n-\n-  private static final String SECTION_SEARCH_PROJECT_PREFIX = \"project\";\n-  private static final String SECTION_SEARCH_PROJECT_COUNT = \"project.count\";\n-\n-  private CapellaSearchSettingsHistory() {\n-    //\n-  }\n-\n-  public static List<CapellaSearchSettings> getAllSearchSettings() {\n-    List<CapellaSearchSettings> capellaSearchSettingsInHistory = new ArrayList<>();\n-\n-    IDialogSettings capellaSearchSection = getDialogSettingsForCapellaSearch();\n-\n-    try {\n-      int currentHistoryCount = capellaSearchSection.getInt(SECTION_HISTORY_COUNT);\n-      for (int i = currentHistoryCount - 1; i >= 0; i--) {\n-        capellaSearchSettingsInHistory.add(createSearchSettingsFromHistoryIndex(i));\n-      }\n-    } catch (NumberFormatException e) {\n-      // nothing\n-    }\n-    return capellaSearchSettingsInHistory;\n-  }\n-\n-  private static CapellaSearchSettings createSearchSettingsFromHistoryIndex(int historyIndex) {\n-    IDialogSettings searchHistorySection = getDialogSettingsForHistoryIndex(historyIndex);\n-    CapellaSearchSettings searchSettings = new CapellaSearchSettings();\n-    if (searchHistorySection != null) {\n-      searchSettings.setTextPattern(searchHistorySection.get(SECTION_SEARCH_PATTERN));\n-      searchSettings.setRegExSearch(searchHistorySection.getBoolean(SECTION_SEARCH_REGEX));\n-      searchSettings.setCaseSensitive(searchHistorySection.getBoolean(SECTION_SEARCH_CASE_SENSITIVE));\n-\n-      try {\n-        int projectsCount = searchHistorySection.getInt(SECTION_SEARCH_PROJECT_COUNT);\n-        for (int i = 0; i < projectsCount; i++) {\n-          searchSettings.addProject(searchHistorySection.get(SECTION_SEARCH_PROJECT_PREFIX + i));\n-        }\n-        int fieldsCount = searchHistorySection.getInt(SECTION_SEARCH_FIELD_COUNT);\n-        for (int i = 0; i < fieldsCount; i++) {\n-          String searchFieldText = searchHistorySection.get(SECTION_SEARCH_FIELD_PREFIX + i);\n-          searchSettings.addSearchField(CapellaSearchField.valueOf(searchFieldText));\n-        }\n-      } catch (NumberFormatException e) {\n-        // Nothing\n-      }\n-    }\n-    return searchSettings;\n-  }\n-\n-  public static void appendSearchSettings(CapellaSearchSettings capellaSearchSettings) {\n-    IDialogSettings capellaSearchSection = getDialogSettingsForCapellaSearch();\n-    int historyIndex = getHistoryIndex(capellaSearchSettings);\n-    if (historyIndex == -1) { // not yet in history\n-      int historyPointToAppend = 0;\n-      try {\n-        int currentHistoryCount = capellaSearchSection.getInt(SECTION_HISTORY_COUNT);\n-        if (currentHistoryCount == HISTORY_SIZE) {\n-          for (int i = 0; i < currentHistoryCount - 1; i++) {\n-            saveSearchSettingsToHistoryPoint(createSearchSettingsFromHistoryIndex(i + 1), i);\n-          }\n-          historyPointToAppend = HISTORY_SIZE - 1;\n-        } else {\n-          // Otherwise save to the last index\n-          historyPointToAppend = currentHistoryCount;\n-        }\n-      } catch (NumberFormatException e) {\n-      }\n-\n-      saveSearchSettingsToHistoryPoint(capellaSearchSettings, historyPointToAppend);\n-      capellaSearchSection.put(SECTION_HISTORY_COUNT, historyPointToAppend + 1);\n-    }\n-  }\n-\n-  private static IDialogSettings getDialogSettingsForCapellaSearch() {\n-    IDialogSettings dialogSettings = Activator.getDefault().getDialogSettings();\n-    IDialogSettings section = dialogSettings.getSection(SECTION_SEARCH);\n-    if (section == null) {\n-      section = dialogSettings.addNewSection(SECTION_SEARCH);\n-    }\n-    return section;\n-  }\n-\n-  private static IDialogSettings getDialogSettingsForHistoryIndex(int historyIndex) {\n-    IDialogSettings capellaSearch = getDialogSettingsForCapellaSearch();\n-\n-    IDialogSettings searchSectionAtHistoryPoint = capellaSearch.getSection(SECTION_HISTORY_PREFIX + historyIndex);\n-    if (searchSectionAtHistoryPoint == null) {\n-      searchSectionAtHistoryPoint = capellaSearch.addNewSection(SECTION_HISTORY_PREFIX + historyIndex);\n-    }\n+  protected CapellaSearchSettingsHistory() {}\n \n-    return searchSectionAtHistoryPoint;\n+  protected static void setSearchSettings(CapellaSearchSettings searchSettings, IDialogSettings searchHistorySection) {\n+    searchSettings.setTextPattern(searchHistorySection.get(SECTION_SEARCH_PATTERN));\n+    searchSettings.setRegExSearch(searchHistorySection.getBoolean(SECTION_SEARCH_REGEX));\n+    searchSettings.setCaseSensitive(searchHistorySection.getBoolean(SECTION_SEARCH_CASE_SENSITIVE));\n   }\n-\n-  private static void saveSearchSettingsToHistoryPoint(CapellaSearchSettings capellaSearchSettings, int historyIndex) {\n-    IDialogSettings searchHistorySection = getDialogSettingsForHistoryIndex(historyIndex);\n-    if (searchHistorySection != null) {\n-\n-      searchHistorySection.put(SECTION_SEARCH_PATTERN, capellaSearchSettings.getTextPattern());\n-      searchHistorySection.put(SECTION_SEARCH_REGEX, capellaSearchSettings.isRegExSearch());\n-      searchHistorySection.put(SECTION_SEARCH_CASE_SENSITIVE, capellaSearchSettings.isCaseSensitive());\n-\n-      int projectsCount = 0;\n-      for (String project : capellaSearchSettings.getProjects()) {\n-        searchHistorySection.put(SECTION_SEARCH_PROJECT_PREFIX + projectsCount, project);\n-        projectsCount++;\n-      }\n-      searchHistorySection.put(SECTION_SEARCH_PROJECT_COUNT, projectsCount);\n-\n-      int fieldsCount = 0;\n-      for (CapellaSearchField searchField : capellaSearchSettings.getSearchFields()) {\n-        searchHistorySection.put(SECTION_SEARCH_FIELD_PREFIX + fieldsCount, searchField.toString());\n-        fieldsCount++;\n-      }\n-      searchHistorySection.put(SECTION_SEARCH_FIELD_COUNT, fieldsCount);\n-    }\n-  }\n-\n-  private static int getHistoryIndex(CapellaSearchSettings capellaSearchSettings) {\n-    IDialogSettings capellaSearchSection = getDialogSettingsForCapellaSearch();\n-    try {\n-      int currentHistoryCount = capellaSearchSection.getInt(SECTION_HISTORY_COUNT);\n-      for (int i = 0; i < currentHistoryCount; i++) {\n-        CapellaSearchSettings searchSettingsInHistory = createSearchSettingsFromHistoryIndex(i);\n-        if (searchSettingsInHistory.equals(capellaSearchSettings)) {\n-          return i;\n-        }\n-      }\n-    } catch (NumberFormatException e) {\n-      // Nothing\n-    }\n-    return -1;\n+  \n+  protected static void setSearchHistorySettings(CapellaSearchSettings capellaSearchSettings, IDialogSettings searchHistorySection) {\n+    searchHistorySection.put(SECTION_SEARCH_PATTERN, capellaSearchSettings.getTextPattern());\n+    searchHistorySection.put(SECTION_SEARCH_REGEX, capellaSearchSettings.isRegExSearch());\n+    searchHistorySection.put(SECTION_SEARCH_CASE_SENSITIVE, capellaSearchSettings.isCaseSensitive());\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyODkwNA==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378228904", "bodyText": "Could you avoid using deprecated methods if possible in this class (e.g. setSorter)?", "author": "minhtutonthat", "createdAt": "2020-02-12T12:47:37Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/AbstractCapellaSearchForContainerArea.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search.searchfor;\r\n+\r\n+import java.lang.reflect.InvocationTargetException;\r\n+import java.net.URL;\r\n+import java.util.ArrayList;\r\n+import java.util.HashMap;\r\n+import java.util.HashSet;\r\n+import java.util.List;\r\n+import java.util.Map;\r\n+import java.util.Set;\r\n+\r\n+import org.eclipse.core.runtime.FileLocator;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.core.runtime.Path;\r\n+import org.eclipse.core.runtime.Status;\r\n+import org.eclipse.emf.common.notify.AdapterFactory;\r\n+import org.eclipse.emf.ecore.EAttribute;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.emf.ecore.ENamedElement;\r\n+import org.eclipse.emf.edit.provider.ComposeableAdapterFactory;\r\n+import org.eclipse.emf.edit.provider.ComposedAdapterFactory;\r\n+import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;\r\n+import org.eclipse.jface.operation.IRunnableWithProgress;\r\n+import org.eclipse.jface.viewers.CheckboxTreeViewer;\r\n+import org.eclipse.jface.viewers.IStructuredContentProvider;\r\n+import org.eclipse.jface.viewers.TreePath;\r\n+import org.eclipse.jface.viewers.Viewer;\r\n+import org.eclipse.sirius.viewpoint.DRepresentationDescriptor;\r\n+import org.eclipse.sirius.viewpoint.DRepresentationElement;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.graphics.Image;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Group;\r\n+import org.eclipse.ui.IWorkbench;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.dialogs.PatternFilter;\r\n+import org.eclipse.ui.progress.IProgressService;\r\n+import org.polarsys.capella.core.ui.search.Activator;\r\n+import org.polarsys.capella.core.ui.search.Messages;\r\n+import org.polarsys.capella.core.data.capellamodeller.provider.CapellaModellerEditPlugin;\r\n+\r\n+public abstract class AbstractCapellaSearchForContainerArea {\r", "originalCommit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA5NTM4Mw==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r380095383", "bodyText": "II removed deprecated except two more which I noted it: PatternConstructor.createPattern, viewer.setAllChecked.", "author": "georgiana-ecobici", "createdAt": "2020-02-17T10:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyODkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "987ecfbc82508d7c68ba767833cc2aa3dbe9bad1", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/AbstractCapellaSearchForContainerArea.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/AbstractCapellaSearchForContainerArea.java\nindex 595034e09..8d1e4cab2 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/AbstractCapellaSearchForContainerArea.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/AbstractCapellaSearchForContainerArea.java\n\n@@ -27,11 +27,14 @@ import org.eclipse.emf.common.notify.AdapterFactory;\n import org.eclipse.emf.ecore.EAttribute;\n import org.eclipse.emf.ecore.EClass;\n import org.eclipse.emf.ecore.ENamedElement;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n import org.eclipse.emf.edit.provider.ComposeableAdapterFactory;\n import org.eclipse.emf.edit.provider.ComposedAdapterFactory;\n import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider;\n import org.eclipse.jface.operation.IRunnableWithProgress;\n+import org.eclipse.jface.viewers.CheckStateChangedEvent;\n import org.eclipse.jface.viewers.CheckboxTreeViewer;\n+import org.eclipse.jface.viewers.ICheckStateListener;\n import org.eclipse.jface.viewers.IStructuredContentProvider;\n import org.eclipse.jface.viewers.TreePath;\n import org.eclipse.jface.viewers.Viewer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMwNTAzOQ==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r378305039", "bodyText": "There are some problems with this class. It not only recreates images but also maintains a map of ImageDescriptor which is already done with the ExtendedImageRegistry. This causes performance issue and code redundancy. Moreover, it's not generic. Capella's elements are treated separately than diagram elements, viewpoint elements, etc.\nIMO, there are 2 solutions: 1) Create dummy objects of eClasses just to get their label and image (using EObjectLabelProviderHelper). We've already done this in Capella in org.polarsys.capella.core.ui.metric.actions.MetricAction.\n2) More complicated but I think feasible. Contribute a new class (e.g. EClassLabelProviderHelper) to get label and image from EClass. From an EClass we can get the Package URI and then get the ItemProviderAdapterFactory (contributed via org.eclipse.emf.edit.itemProviderAdapterFactories extension point). From the ItemProviderAdapterFactory we can determine the .edit bundle (e.g. org.polarsys.capella.core.data.gen.edit in Capella). With the bundle we can get the image (like what you've done) with ExtendedImageRegistry.INSTANCE.getImageDescriptor. For the label, we can inspire from the method org.eclipse.emf.common.EMFPlugin.InternalHelper.getString(String, boolean).", "author": "minhtutonthat", "createdAt": "2020-02-12T14:59:51Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/ModelSearchImagesUtil.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search.searchfor;\r\n+\r\n+import java.net.URL;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+\r\n+import org.eclipse.core.runtime.FileLocator;\r\n+import org.eclipse.core.runtime.Path;\r\n+import org.eclipse.jface.resource.ImageDescriptor;\r\n+import org.eclipse.swt.graphics.Image;\r\n+import org.osgi.framework.Bundle;\r\n+\r\n+/**\r\n+ * Utility class for images\r\n+ */\r\n+public final class ModelSearchImagesUtil {\r", "originalCommit": "63f433e930f1bef11bb4735f446147bf1cca4e48", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6d0763856bfe1c84ebe2c18245dc027a50daf68a", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/ModelSearchImagesUtil.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/ModelSearchImagesUtil.java\ndeleted file mode 100644\nindex 647e5174f..000000000\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/ModelSearchImagesUtil.java\n+++ /dev/null\n\n@@ -1,138 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 THALES GLOBAL SERVICES.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *  \n- * Contributors:\n- *    Thales - initial API and implementation\n- *******************************************************************************/\n-package org.polarsys.capella.core.ui.search.searchfor;\n-\n-import java.net.URL;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import org.eclipse.core.runtime.FileLocator;\n-import org.eclipse.core.runtime.Path;\n-import org.eclipse.jface.resource.ImageDescriptor;\n-import org.eclipse.swt.graphics.Image;\n-import org.osgi.framework.Bundle;\n-\n-/**\n- * Utility class for images\n- */\n-public final class ModelSearchImagesUtil {\n-\t/**\n-\t * A 'registry' {@link Map} of all image descriptors identified by their URL \n-\t */\n-\tprivate static Map<URL, ImageDescriptor> imageDescriptorMap;\n-\t\n-\t/**\n-\t * A 'registry' {@link Map} of all images identified by their URL \n-\t */\n-\tprivate static Map<URL, Image> imageMap;\n-\t\n-\t/**\n-\t * Missing image {@link ImageDescriptor}\n-\t */\n-\tpublic static ImageDescriptor MISSING_IMG_DESC;\n-\t\n-\t/**\n-\t * Static initialization\n-\t */\n-\tstatic {\n-\t\timageDescriptorMap = new HashMap<URL, ImageDescriptor>();\n-\t\timageMap = new HashMap<URL, Image>();\n-\t\tMISSING_IMG_DESC = ImageDescriptor.getMissingImageDescriptor();\n-\t\tMISSING_IMG_DESC.getImageData().scaledTo(16, 16);\n-\t}\n-\t\n-    /**\n-     * Get an Image from a bundle ID and image relative path to the given bundle location\n-     * \n-     * @param url Relative URL to the wanted image\n-     * \n-     * @return ImageDescriptor built from the image file, Empty non null ImageDescriptor otherwise\n-     * \n-     * @see ImageDescriptor\n-     */\n-    public static Image getImage(URL url) {\n-    \tif (imageMap.containsKey(url)) {\n-    \t\treturn imageMap.get(url);\n-    \t}\n-      Image image = getImageDescriptor(url).createImage();\n-      imageMap.put(url, image);\n-      return image;\n-    }\n-    \n-    /**\n-     * Get an Image from a bundle ID and image relative path to the given bundle location\n-     * \n-     * @param bundle Given bundle ID which location will be resolve as root to search images into\n-     * @param imagePath Relative path to the wanted image\n-     * \n-     * @return ImageDescriptor built from the image file, Empty non null ImageDescriptor otherwise\n-     * \n-     * @see ImageDescriptor\n-     */\n-    public static Image getImage(Bundle bundle, String imagePath) {\n-\t    URL url = null;\n-\t    if (bundle != null){\n-\t        url = FileLocator.find(bundle, new Path(imagePath), null);\n-\t    \tif (imageMap.containsKey(url)) {\n-\t    \t\treturn imageMap.get(url);\n-\t    \t}\n-        Image image = getImageDescriptor(bundle, imagePath).createImage();\n-        imageMap.put(url, image);\n-        return image;\n-\t    }\n-\t    return MISSING_IMG_DESC.createImage();\n-    }\n-    \n-    /**\n-     * Get an ImageDescriptor from a bundle ID and image relative path to the given bundle location\n-     * \n-     * @param bundle Given bundle ID which location will be resolve as root to search images into\n-     * @param imagePath Relative path to the wanted image\n-     * \n-     * @return ImageDescriptor built from the image file, Empty non null ImageDescriptor otherwise\n-     * \n-     * @see ImageDescriptor\n-     */\n-    public static ImageDescriptor getImageDescriptor(Bundle bundle, String imagePath) {\n-\t    ImageDescriptor desc = MISSING_IMG_DESC;\n-\t    URL url = null;\n-\t    if (bundle != null){\n-\t        url = FileLocator.find(bundle, new Path(imagePath), null);\n-\t        if (imageDescriptorMap.containsKey(url)) {\n-\t        \tdesc = imageDescriptorMap.get(url);\n-\t        } else {\n-\t        \tdesc = ImageDescriptor.createFromURL(url);\n-\t        \timageDescriptorMap.put(url, desc);\n-\t        }\n-\t    }\n-\t    return desc;\n-    }\n-    \n-    /**\n-     * Get an ImageDescriptor from a bundle ID and image relative path to the given bundle location\n-     * \n-     * @param url Relative URL to the wanted image\n-     * \n-     * @return ImageDescriptor built from the image file, Empty non null ImageDescriptor otherwise\n-     * \n-     * @see ImageDescriptor\n-     */\n-    public static ImageDescriptor getImageDescriptor(URL url) {\n-\t    ImageDescriptor desc = ImageDescriptor.getMissingImageDescriptor();\n-\t    if (imageDescriptorMap.containsKey(url)) {\n-\t        desc = imageDescriptorMap.get(url);\n-\t    } else {\n-\t        desc = ImageDescriptor.createFromURL(url);\n-\t        imageDescriptorMap.put(url, desc);\n-\t    }\n-\t    return desc;\n-    }\n-}\n"}}, {"oid": "987ecfbc82508d7c68ba767833cc2aa3dbe9bad1", "url": "https://github.com/eclipse/capella/commit/987ecfbc82508d7c68ba767833cc2aa3dbe9bad1", "message": "Added Search For Section\n - Model Elements\n - Attributes\n\n Incomplete:\n - Diagram Elements\n - Filter attributes based on the Meta Classes in left panel\n\nChange-Id: Id08b997f123a574920e6c1ddd6a01fa4f19b27c8\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-13T07:34:15Z", "type": "commit"}, {"oid": "bbae0fdb01314c0ef9bb61db83b81a62c0a8c0e0", "url": "https://github.com/eclipse/capella/commit/bbae0fdb01314c0ef9bb61db83b81a62c0a8c0e0", "message": "Added Search For Section\n - Model Elements\n - Attributes\n\n Incomplete:\n - Diagram Elements\n - Filter attributes based on the Meta Classes in left panel\n\nChange-Id: Id5f7a40a8d17ce641fefaa7d6055db12500f6920\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-13T08:21:00Z", "type": "commit"}, {"oid": "cb6a4ae422748cae7d91571c2d25d6caa2722f24", "url": "https://github.com/eclipse/capella/commit/cb6a4ae422748cae7d91571c2d25d6caa2722f24", "message": "Added Search For Section\n - Model Elements\n - Attributes\n\n Incomplete:\n - Diagram Elements\n - Filter attributes based on the Meta Classes in left panel\n\nChange-Id: I941fb859732dc7ad325029738ec51cfc23b1f9bc\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-13T14:00:00Z", "type": "commit"}, {"oid": "88178d7db3316f3eb0ed2f2501b931abd0c66f72", "url": "https://github.com/eclipse/capella/commit/88178d7db3316f3eb0ed2f2501b931abd0c66f72", "message": "Search and Replace:\n\n- search\n- search result\n- replace all\n- search for (only display Eclasses and Attributes)\n\nChange-Id: I53b394ed8c8e074a1fc30d4980afe74b6e307a54\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-17T09:57:02Z", "type": "commit"}, {"oid": "6d0763856bfe1c84ebe2c18245dc027a50daf68a", "url": "https://github.com/eclipse/capella/commit/6d0763856bfe1c84ebe2c18245dc027a50daf68a", "message": "Get Images for EClass\n\nChange-Id: I0000000000000000000000000000000000000000\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-18T12:18:30Z", "type": "commit"}, {"oid": "79b6eb0f4f4c4e302fe0475d892f48242f02e24d", "url": "https://github.com/eclipse/capella/commit/79b6eb0f4f4c4e302fe0475d892f48242f02e24d", "message": "Search by attributes + metaclasses\n\nChange-Id: Iae10cae8a709ee773542660b9c89b9fca9ca270c\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-25T15:11:08Z", "type": "commit"}, {"oid": "26f44ccfc0b8d9a6454b5501d48d5b402c11e76d", "url": "https://github.com/eclipse/capella/commit/26f44ccfc0b8d9a6454b5501d48d5b402c11e76d", "message": "Cache the provided data for Search For (attributes / meta-classes)\n\nChange-Id: Iec8a9d3a78dcee36ec575c813317b5b1e3aff5df\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-26T09:30:45Z", "type": "commit"}, {"oid": "5d9afa6cf8e85aaba270e9d99fa58d6e0fe5375c", "url": "https://github.com/eclipse/capella/commit/5d9afa6cf8e85aaba270e9d99fa58d6e0fe5375c", "message": "Position Capella Search first\n\nChange-Id: I729153338869427132ca001d6e6cc8ac45d62eee\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-26T10:46:35Z", "type": "commit"}, {"oid": "8c88088efd5a8463809fc1b93209f2ed9dee78c6", "url": "https://github.com/eclipse/capella/commit/8c88088efd5a8463809fc1b93209f2ed9dee78c6", "message": "Search and Replace\n\nChange-Id: I1dadc007d0eaac1043ea1739fe0fd7cf75f0158f\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-02-28T15:14:07Z", "type": "commit"}, {"oid": "92b994bb865c874368514db470598ae2e786da42", "url": "https://github.com/eclipse/capella/commit/92b994bb865c874368514db470598ae2e786da42", "message": "Search and Replace\n\nChange-Id: I9b5f5740977b8425d2059734d32714fbde9ada03\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-03T13:53:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NjcxMw==", "url": "https://github.com/eclipse/capella/pull/65#discussion_r387046713", "bodyText": "I will delete this function in next commit.", "author": "georgiana-ecobici", "createdAt": "2020-03-03T14:16:13Z", "path": "core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/CapellaLeftSearchForContainerArea.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*******************************************************************************\r\n+ * Copyright (c) 2020 THALES GLOBAL SERVICES.\r\n+ * All rights reserved. This program and the accompanying materials\r\n+ * are made available under the terms of the Eclipse Public License v1.0\r\n+ * which accompanies this distribution, and is available at\r\n+ * http://www.eclipse.org/legal/epl-v10.html\r\n+ *  \r\n+ * Contributors:\r\n+ *    Thales - initial API and implementation\r\n+ *******************************************************************************/\r\n+package org.polarsys.capella.core.ui.search.searchfor;\r\n+\r\n+import java.lang.reflect.InvocationTargetException;\r\n+\r\n+import org.eclipse.core.resources.IProjectDescription;\r\n+import org.eclipse.core.runtime.CoreException;\r\n+import org.eclipse.core.runtime.IProgressMonitor;\r\n+import org.eclipse.emf.ecore.EClass;\r\n+import org.eclipse.jface.layout.GridDataFactory;\r\n+import org.eclipse.jface.layout.GridLayoutFactory;\r\n+import org.eclipse.jface.operation.IRunnableWithProgress;\r\n+import org.eclipse.jface.viewers.CheckStateChangedEvent;\r\n+import org.eclipse.jface.viewers.CheckboxTreeViewer;\r\n+import org.eclipse.jface.viewers.ICheckStateListener;\r\n+import org.eclipse.jface.viewers.Viewer;\r\n+import org.eclipse.swt.SWT;\r\n+import org.eclipse.swt.events.SelectionAdapter;\r\n+import org.eclipse.swt.events.SelectionEvent;\r\n+import org.eclipse.swt.events.SelectionListener;\r\n+import org.eclipse.swt.layout.GridData;\r\n+import org.eclipse.swt.layout.GridLayout;\r\n+import org.eclipse.swt.widgets.Button;\r\n+import org.eclipse.swt.widgets.Composite;\r\n+import org.eclipse.swt.widgets.Group;\r\n+import org.eclipse.swt.widgets.Text;\r\n+import org.eclipse.ui.IWorkbench;\r\n+import org.eclipse.ui.PlatformUI;\r\n+import org.eclipse.ui.dialogs.PatternFilter;\r\n+import org.eclipse.ui.progress.IProgressService;\r\n+import org.polarsys.capella.core.ui.search.CapellaSearchConstants;\r\n+import org.polarsys.capella.core.ui.search.CapellaSearchPage;\r\n+\r\n+public class CapellaLeftSearchForContainerArea extends AbstractCapellaSearchForContainerArea {\r\n+  protected AbstractMetaModelParticipantsItemProvider partictipantsItemProvider;\r\n+  Button checkboxFilterAbstract;\r\n+  Button checkboxFilterSemantic;\r\n+\r\n+  public CapellaLeftSearchForContainerArea(Group parent, CapellaSearchPage searchPage) {\r\n+    super(parent, null, searchPage);\r\n+  }\r\n+\r\n+  @Override\r\n+  protected AbstractMetaModelParticipantsItemProvider getPartictipantsItemProvider() {\r\n+    if (partictipantsItemProvider == null) {\r\n+      partictipantsItemProvider = new MetaClassesParticipantsItemProvider(this);\r\n+    }\r\n+    return partictipantsItemProvider;\r\n+  }\r\n+\r\n+  protected PatternFilter createPatternFilter() {\r\n+    return new PatternFilter() {\r\n+      @Override\r\n+      public Object[] filter(Viewer viewer, Object parent, Object[] elements) {\r\n+        Object[] result = super.filter(viewer, parent, elements);\r\n+        if (parent != null) {\r\n+          if (parent.equals(\"\")) {\r\n+            displayedElements.clear();\r\n+            for (Object element : result) {\r\n+              updateDisplayedElements(filter(viewer, element, partictipantsItemProvider.getChildren(element)));\r\n+            }\r\n+          }\r\n+        }\r\n+        return result;\r\n+      }\r\n+\r\n+      private void updateDisplayedElements(Object[] elements) {\r\n+        for (Object displayedElement : elements) {\r\n+          if (displayedElement instanceof EClass) {\r\n+            displayedElements.add(displayedElement);\r\n+          }\r\n+        }\r\n+      }\r\n+    };\r\n+  }\r\n+\r\n+  @Override\r\n+  protected void setCheckSubtree() {\r\n+    ((CheckboxTreeViewer) filteredTree.getViewer()).addCheckStateListener(getCheckStateListener());\r\n+  }\r\n+\r\n+  private ICheckStateListener getCheckStateListener() {\r\n+    return new ICheckStateListener() {\r\n+      public void checkStateChanged(final CheckStateChangedEvent event) {\r\n+        CheckboxTreeViewer viewer = (CheckboxTreeViewer) filteredTree.getViewer();\r\n+        boolean state = event.getChecked();\r\n+        Object parent = event.getElement();\r\n+        if (state == true)\r\n+          checkedElements.add(parent);\r\n+        else\r\n+          checkedElements.remove(parent);\r\n+\r\n+        // handle the inheritance check propagation\r\n+        Object[] changedObjects = partictipantsItemProvider.getChildren(parent);\r\n+\r\n+        for (Object obj : changedObjects) {\r\n+          viewer.setChecked(obj, state);\r\n+          if (state == true) {\r\n+            checkedElements.add(obj);\r\n+          } else {\r\n+            checkedElements.remove(obj);\r\n+          }\r\n+        }\r\n+\r\n+        searchPage.updateValidationStatus(searchPage.getCapellaSearchSettings().validate());\r\n+        // setSearchMetaClasses, beside the metaclass it contains also the category (Diagram Elements or Model Elements)\r\n+        searchPage.getCapellaSearchSettings().setSearchMetaClasses(checkedElements);\r\n+        // refresh the attributes in right panel\r\n+        if (otherSideArea != null) {\r\n+          otherSideArea.filteredTree.getViewer().refresh();\r\n+        }\r\n+      }\r\n+    };\r\n+  }\r\n+\r\n+  public void createFiltercontainer(Group parentGroup) {\r\n+    Group searchForSelectionGroup = new Group(parentGroup, SWT.NONE);\r\n+    GridLayoutFactory.swtDefaults().numColumns(2).applyTo(searchForSelectionGroup);\r\n+\r\n+    GridData gdGrp = new GridData(GridData.FILL_BOTH);\r\n+    gdGrp.widthHint = 50;\r\n+    searchForSelectionGroup.setLayoutData(gdGrp);\r\n+\r\n+    searchForSelectionGroup.setText(CapellaSearchConstants.Filters_Label);\r\n+    checkboxFilterAbstract = createCheckboxFilters(searchForSelectionGroup, CapellaSearchConstants.Abstract_Label,\r\n+        false);\r\n+    checkboxFilterSemantic = createCheckboxFilters(searchForSelectionGroup, CapellaSearchConstants.Semantic_Label,\r\n+        true);\r\n+  }\r\n+\r\n+  private Button createCheckboxFilters(Composite group, String label, boolean selected) {\r\n+    Button checkboxFilters = new Button(group, SWT.CHECK);\r\n+    checkboxFilters.setText(label);\r\n+    GridDataFactory.swtDefaults().align(SWT.FILL, SWT.CENTER).applyTo(checkboxFilters);\r\n+    checkboxFilters.setFont(group.getFont());\r\n+    checkboxFilters.setSelection(selected);\r\n+\r\n+    checkboxFilters.addSelectionListener(new SelectionAdapter() {\r\n+      @Override\r\n+      public void widgetSelected(SelectionEvent e) {\r\n+        applyFilter();\r\n+      }\r\n+    });\r\n+    return checkboxFilters;\r\n+  }\r\n+\r\n+  protected void applyFilter() {\r\n+    IRunnableWithProgress runnable = new IRunnableWithProgress() {\r\n+      @Override\r\n+      public void run(IProgressMonitor monitor) throws InvocationTargetException {\r\n+        CheckboxTreeViewer checkboxTreeViewer = (CheckboxTreeViewer) filteredTree.getViewer();\r\n+        MetaClassesParticipantsItemProvider provider = (MetaClassesParticipantsItemProvider) getPartictipantsItemProvider();\r\n+        provider.setShowAbstract(checkboxFilterAbstract.getSelection());\r\n+        provider.setShowSemantics(checkboxFilterSemantic.getSelection());\r\n+        checkboxTreeViewer.refresh();\r\n+        checkboxTreeViewer.expandAll();\r\n+      }\r\n+    };\r\n+    IProgressService service = PlatformUI.getWorkbench().getProgressService();\r\n+    try {\r\n+      service.run(false, false, runnable);\r\n+    } catch (InterruptedException e) {\r\n+      e.printStackTrace();\r\n+    } catch (InvocationTargetException e) {\r\n+      e.printStackTrace();\r\n+    }\r\n+  }\r\n+\r\n+  public void addFilters() {\r", "originalCommit": "92b994bb865c874368514db470598ae2e786da42", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0861e1d1ab40d2225aa2009a9b936f064a1c6523", "chunk": "diff --git a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/CapellaLeftSearchForContainerArea.java b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/CapellaLeftSearchForContainerArea.java\nindex 72a6ff944..d9cc34da5 100644\n--- a/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/CapellaLeftSearchForContainerArea.java\n+++ b/core/plugins/org.polarsys.capella.core.ui.search/src/org/polarsys/capella/core/ui/search/searchfor/CapellaLeftSearchForContainerArea.java\n\n@@ -174,100 +174,4 @@ public class CapellaLeftSearchForContainerArea extends AbstractCapellaSearchForC\n       e.printStackTrace();\n     }\n   }\n-\n-  public void addFilters() {\n-    Composite treeViewerParent = parentGroup;\n-\n-    // treeViewerParent.setData(gridData);\n-    Group filterGrp = new Group(treeViewerParent, SWT.FILL);\n-    GridLayout filterGrpLayout = new GridLayout(SWT.NONE, true);\n-    GridData gdData = new GridData(GridData.FILL_BOTH);\n-    filterGrpLayout.numColumns = 2;\n-    gdData.grabExcessHorizontalSpace = true;\n-    gdData.grabExcessVerticalSpace = true;\n-    gdData.heightHint = 200;\n-    filterGrp.setLayoutData(gdData);\n-    filterGrpLayout.marginHeight = 0;\n-    filterGrpLayout.marginWidth = 0;\n-    filterGrp.setLayout(filterGrpLayout);\n-\n-    Group toBefilteredGrp = new Group(filterGrp, SWT.NONE);\n-    toBefilteredGrp.setText(\"Filters :\");\n-    GridData toBefilteredGrpGdData = new GridData(GridData.FILL_BOTH);\n-    toBefilteredGrpGdData.grabExcessHorizontalSpace = true;\n-    toBefilteredGrpGdData.grabExcessVerticalSpace = true;\n-    toBefilteredGrpGdData.widthHint = 100;\n-    toBefilteredGrp.setLayoutData(toBefilteredGrpGdData);\n-\n-    GridLayout toBeFilteredGrpGridLayout = new GridLayout(SWT.FILL, false);\n-    toBeFilteredGrpGridLayout.numColumns = 2;\n-    toBefilteredGrp.setLayout(toBeFilteredGrpGridLayout);\n-\n-    // GridData abstractFilterGrpGridData = new GridData(SWT.NONE);\n-    // abstractFilterGrpGridData.grabExcessHorizontalSpace = true;\n-    // abstractFilterGrp.setData(abstractFilterGrpGridData);\n-\n-    GridData abstractFilterButtonGdData = new GridData();\n-    Button abstractFilterButton = new Button(toBefilteredGrp, SWT.CHECK);\n-    abstractFilterButton.setLayoutData(abstractFilterButtonGdData);\n-    ;\n-\n-    GridData abstractFilterTxtGdData = new GridData();\n-    Text abstractFilterTxt = new Text(toBefilteredGrp, SWT.NONE);\n-    abstractFilterTxt.setLayoutData(abstractFilterTxtGdData);\n-    abstractFilterTxt.setText(\"Abstract\");\n-\n-    abstractFilterButton.addSelectionListener(new SelectionListener() {\n-\n-      @Override\n-      public void widgetSelected(SelectionEvent e) {\n-        // filtersAbstract();\n-      }\n-\n-      @Override\n-      public void widgetDefaultSelected(SelectionEvent e) {\n-        // TODO Auto-generated method stub\n-\n-      }\n-    });\n-\n-    Group toBeFocusedGrp = new Group(filterGrp, SWT.FILL);\n-    toBeFocusedGrp.setText(\"Show Only :\");\n-\n-    GridData toBeFocusedGrpGdData = new GridData(GridData.FILL_BOTH);\n-    toBeFocusedGrpGdData.grabExcessHorizontalSpace = true;\n-    toBeFocusedGrpGdData.grabExcessVerticalSpace = true;\n-    toBeFocusedGrpGdData.widthHint = 100;\n-    toBeFocusedGrp.setLayoutData(toBeFocusedGrpGdData);\n-\n-    GridLayout toBeFocusedGrpLayout = new GridLayout(SWT.FILL, false);\n-    toBeFocusedGrpLayout.numColumns = 2;\n-    toBeFocusedGrp.setLayout(toBeFocusedGrpLayout);\n-\n-    GridData semanticFilterButtonGdData = new GridData();\n-    Button semanticFilterButton = new Button(toBeFocusedGrp, SWT.CHECK);\n-    semanticFilterButton.setLayoutData(semanticFilterButtonGdData);\n-\n-    GridData semanticFilterTxtGdData = new GridData();\n-    Text semanticFilterTxt = new Text(toBeFocusedGrp, SWT.NONE);\n-    semanticFilterTxt.setText(\"Semantics\");\n-    semanticFilterTxt.setLayoutData(semanticFilterTxtGdData);\n-\n-    semanticFilterButton.addSelectionListener(new SelectionListener() {\n-\n-      @Override\n-      public void widgetSelected(SelectionEvent e) {\n-        // showOnlySemantics();\n-\n-      }\n-\n-      @Override\n-      public void widgetDefaultSelected(SelectionEvent e) {\n-        // TODO Auto-generated method stub\n-\n-      }\n-    });\n-\n-  }\n-\n }\n"}}, {"oid": "0861e1d1ab40d2225aa2009a9b936f064a1c6523", "url": "https://github.com/eclipse/capella/commit/0861e1d1ab40d2225aa2009a9b936f064a1c6523", "message": "Search and Replace\n\nChange-Id: Ic343cf92f7fd90d70f094dd72bedc8b5455050e3\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-03T14:20:31Z", "type": "commit"}, {"oid": "332ba18dcf5bac76366ff79adb2f94c55cd72e5e", "url": "https://github.com/eclipse/capella/commit/332ba18dcf5bac76366ff79adb2f94c55cd72e5e", "message": "Search and replace\n\nChange-Id: I86ba54b532cd920557034994a0306c089bc7609e\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-03T15:26:33Z", "type": "commit"}, {"oid": "dd2b99fb6736225a401d43904a136177be379fed", "url": "https://github.com/eclipse/capella/commit/dd2b99fb6736225a401d43904a136177be379fed", "message": "Search and replace\n\nChange-Id: I2fe7daf8a2c88add1724a1d167d34953b74f5c78\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-03T17:20:41Z", "type": "commit"}, {"oid": "b5e5592f5296d3e9150697596832efc77e07a79a", "url": "https://github.com/eclipse/capella/commit/b5e5592f5296d3e9150697596832efc77e07a79a", "message": "Search and replace\n\n- validate, check if filters are selected\n\nChange-Id: I3cf19aa273b154117d5b7d73fb4c0e3bc17231d8\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-04T07:48:27Z", "type": "commit"}, {"oid": "9acb3fd59018d24f7ef39204ba871c8ac91956b1", "url": "https://github.com/eclipse/capella/commit/9acb3fd59018d24f7ef39204ba871c8ac91956b1", "message": "Search and replace\n- note\n\nChange-Id: Id92fdc073e457dafe8dd3d492bad26b427a2af20\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-04T08:30:49Z", "type": "commit"}, {"oid": "abced2f2f90889f41d46ebb34b905435d5485d50", "url": "https://github.com/eclipse/capella/commit/abced2f2f90889f41d46ebb34b905435d5485d50", "message": "Search and replace improvements\n\nChange-Id: I9b1a070ac434513a1c3bf6f9785d7439557a8d88\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-05T13:37:31Z", "type": "commit"}, {"oid": "f26e91d940e216da64ff679d71b4df4afb935e59", "url": "https://github.com/eclipse/capella/commit/f26e91d940e216da64ff679d71b4df4afb935e59", "message": "Search and replace bug fixing\n\nChange-Id: Ib2a6b804ca51f5ab46c67c5fcb0cc52600fd4691\nSigned-off-by: Georgiana Ecobici <georgiana-elena.ecobici@thalesgroup.com>", "committedDate": "2020-03-06T09:55:41Z", "type": "commit"}]}