{"pr_number": 1489, "pr_title": "HDDS-4308. Fix issue with quota update", "pr_createdAt": "2020-10-13T07:45:47Z", "pr_url": "https://github.com/apache/ozone/pull/1489", "timeline": [{"oid": "e6a0ecdacca868c781969b259be02ed6d0ee30c7", "url": "https://github.com/apache/ozone/commit/e6a0ecdacca868c781969b259be02ed6d0ee30c7", "message": "Fix acquire VOLUME_LOCK issue", "committedDate": "2020-10-13T12:52:00Z", "type": "forcePushed"}, {"oid": "f3744e77d31652cdbf237f073c1af17d27e74b18", "url": "https://github.com/apache/ozone/commit/f3744e77d31652cdbf237f073c1af17d27e74b18", "message": "Fix acquire VOLUME_LOCK issue", "committedDate": "2020-10-14T02:02:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r512749950", "bodyText": "I don't prefer to add new methods here, this makes current PR not clear to understand.\n@captainzmc , can you make the minor adjustment for getVolumeInfo as I suggested in JIRA HDDS-4308. After this, we can make few lines change I think.", "author": "linyiqun", "createdAt": "2020-10-27T14:40:15Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java", "diffHunk": "@@ -597,27 +596,40 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info for the specified volume. If the volume does not\n-   * exist, returns {@code null}.\n+   * Return volume info that updated usageBytes for the specified volume.\n    * @param omMetadataManager\n    * @param volume\n+   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n-      String volume) {\n-\n-    OmVolumeArgs volumeArgs = null;\n-\n-    CacheValue<OmVolumeArgs> value =\n-        omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n-\n-    if (value != null) {\n-      volumeArgs = value.getCacheValue();\n-    }\n+  protected static synchronized OmVolumeArgs syncUpdateUsage(\n+      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n+    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n+        .getCacheValue();\n+    volumeArgs.getUsedBytes().add(updateUsage);\n+    return volumeArgs.copyObject();\n+  }\n \n-    return volumeArgs;\n+  /**\n+   * Return volume info that updated usageBytes for the specified volume. And\n+   * check Volume usageBytes quota.\n+   * @param omMetadataManager\n+   * @param volume\n+   * @param updateUsage\n+   * @return OmVolumeArgs\n+   * @throws IOException\n+   */\n+  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(", "originalCommit": "2614eeb893dc9c406764824aba73faafd56d4ded", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0MDYyOA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513140628", "bodyText": "Thanks for @linyiqun's review.\nModifying getVolumeInfo to synchronized and get copyObject would not suffice. There is only one instance of volumeArgs in memory, and we need to update volumeArgs atomic after getVolumeInfo. Then get the value of the copyObject.\nSo, I made a modification based on your suggestion, added update volumeArgs's usedBytes to the getVolumeInfo method.", "author": "captainzmc", "createdAt": "2020-10-28T02:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2OTIyOQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513169229", "bodyText": "I have not understood one part, how without volume lock this will help here.\nBecause other threads can be updating volumeArgs when this update is happening/ other threads read omVolumeArgs.", "author": "bharatviswa504", "createdAt": "2020-10-28T04:10:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2OTc5Mw==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513169793", "bodyText": "Do we need LongAdder still?", "author": "bharatviswa504", "createdAt": "2020-10-28T04:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxNjU4NQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513216585", "bodyText": "I have not understood one part, how without volume lock this will help here.\nBecause other threads can be updating volumeArgs when this update is happening/ other threads read omVolumeArgs.\n\nThank for @bharatviswa504's  feedback. This is a possible case. Can lead to update usageBytes inaccurate.\nSuppose that ThreadA update VolumeArgs using OMVolumeSetOwnerRequest, it gets VolumeArgs from DB if usageBytes is 1000 at this point. When ThreadB writes the new key using OMKeyCreateRequest, he changes usageBytes to 1100.\nThere is no Volume lock at this point, so ThreadB may finish executing first and ThreadA last. The Final usageBytes for VolumeArgs would be 1000. This should be a problem.\nMaybe we still can't avoid using Volume lock. hi @linyiqun Any suggestions here?", "author": "captainzmc", "createdAt": "2020-10-28T06:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxOTM1OA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513219358", "bodyText": "Do we need LongAdder still?\n\nLongAdder will no longer be necessary if there are no concurrent updates to usedBytes.", "author": "captainzmc", "createdAt": "2020-10-28T07:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzMzQzNQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r513333435", "bodyText": "Thank for @bharatviswa504's feedback. This is a possible case. Can lead to update usageBytes inaccurate.\nSuppose that ThreadA update VolumeArgs using OMVolumeSetOwnerRequest, it gets VolumeArgs from DB if usageBytes is 1000 at this point. When ThreadB writes the new key using OMKeyCreateRequest, he changes usageBytes to 1100.\n\nGood catch, @captainzmc . Seems we still need to use volume lock to help us do the volume quota update control. We should acquire volume lock before get volume info (copy volume info) and release volume lock after add the OMClientResponse into double buffer cache.", "author": "linyiqun", "createdAt": "2020-10-28T10:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc0OTk1MA=="}], "type": "inlineReview", "revised_code": {"commit": "dcfdb763ba9d72fa6d36d3221d40f5cfe60c08b4", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java\nindex 196306706..36e332c2d 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRequest.java\n\n@@ -596,40 +597,27 @@ protected boolean checkDirectoryAlreadyExists(String volumeName,\n   }\n \n   /**\n-   * Return volume info that updated usageBytes for the specified volume.\n+   * Return volume info for the specified volume. If the volume does not\n+   * exist, returns {@code null}.\n    * @param omMetadataManager\n    * @param volume\n-   * @param updateUsage\n    * @return OmVolumeArgs\n    * @throws IOException\n    */\n-  protected static synchronized OmVolumeArgs syncUpdateUsage(\n-      OMMetadataManager omMetadataManager, String volume, long updateUsage) {\n-    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n-        .getCacheValue();\n-    volumeArgs.getUsedBytes().add(updateUsage);\n-    return volumeArgs.copyObject();\n-  }\n+  protected OmVolumeArgs getVolumeInfo(OMMetadataManager omMetadataManager,\n+      String volume) {\n \n-  /**\n-   * Return volume info that updated usageBytes for the specified volume. And\n-   * check Volume usageBytes quota.\n-   * @param omMetadataManager\n-   * @param volume\n-   * @param updateUsage\n-   * @return OmVolumeArgs\n-   * @throws IOException\n-   */\n-  protected static synchronized OmVolumeArgs syncCheckAndUpdateUsage(\n-      OMMetadataManager omMetadataManager, String volume, long updateUsage)\n-      throws IOException {\n-    OmVolumeArgs volumeArgs = omMetadataManager.getVolumeTable().getCacheValue(\n-        new CacheKey<>(omMetadataManager.getVolumeKey(volume)))\n-        .getCacheValue();\n-    checkVolumeQuotaInBytes(volumeArgs, updateUsage);\n-    volumeArgs.getUsedBytes().add(updateUsage);\n-    return volumeArgs.copyObject();\n+    OmVolumeArgs volumeArgs = null;\n+\n+    CacheValue<OmVolumeArgs> value =\n+        omMetadataManager.getVolumeTable().getCacheValue(\n+        new CacheKey<>(omMetadataManager.getVolumeKey(volume)));\n+\n+    if (value != null) {\n+      volumeArgs = value.getCacheValue();\n+    }\n+\n+    return volumeArgs;\n   }\n \n   /**\n"}}, {"oid": "f3744e77d31652cdbf237f073c1af17d27e74b18", "url": "https://github.com/apache/ozone/commit/f3744e77d31652cdbf237f073c1af17d27e74b18", "message": "Fix acquire VOLUME_LOCK issue", "committedDate": "2020-10-14T02:02:18Z", "type": "forcePushed"}, {"oid": "dcfdb763ba9d72fa6d36d3221d40f5cfe60c08b4", "url": "https://github.com/apache/ozone/commit/dcfdb763ba9d72fa6d36d3221d40f5cfe60c08b4", "message": "LongAdder in OmVolumeArgs is unnecessary", "committedDate": "2020-10-29T12:31:51Z", "type": "forcePushed"}, {"oid": "dfc8e50f63315ce8e915e1861309ab6766fe8004", "url": "https://github.com/apache/ozone/commit/dfc8e50f63315ce8e915e1861309ab6766fe8004", "message": "LongAdder in OmVolumeArgs is unnecessary", "committedDate": "2020-10-29T13:15:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MDM0MQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515140341", "bodyText": "Method name setUsedBytes seems confused, can we rename to incrUsedBytes(long bytes)", "author": "linyiqun", "createdAt": "2020-10-30T14:31:44Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java", "diffHunk": "@@ -177,10 +176,14 @@ public OmOzoneAclMap getAclMap() {\n     return aclMap;\n   }\n \n-  public LongAdder getUsedBytes() {\n+  public long getUsedBytes() {\n     return usedBytes;\n   }\n \n+  public void setUsedBytes(long usedBytes) {\n+    this.usedBytes = this.usedBytes + usedBytes;", "originalCommit": "dfc8e50f63315ce8e915e1861309ab6766fe8004", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a3c5ba2e990603f66d3c737dcead759e8d5952a8", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java\nindex 80fd485c2..0aec7f634 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java\n+++ b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmVolumeArgs.java\n\n@@ -180,8 +180,8 @@ public long getUsedBytes() {\n     return usedBytes;\n   }\n \n-  public void setUsedBytes(long usedBytes) {\n-    this.usedBytes = this.usedBytes + usedBytes;\n+  public void incrUsedBytes(long bytes) {\n+    this.usedBytes = this.usedBytes + bytes;\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0MzYzOA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515143638", "bodyText": "We should not release volume lock until add omClientResponse into double buffer. So that we can make sure stale OmVolumeArgs in other OM request won't be earlier processed than this request. Here we should ensure that the OmVolumeArgs is updated in order.\nI prefer to add volume lock for the whole method. The same comment for other OM Request classes.", "author": "linyiqun", "createdAt": "2020-10-30T14:36:52Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -300,8 +302,26 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           trxnLogIndex);\n \n       // update usedBytes atomically.\n-      omVolumeArgs.getUsedBytes().add(preAllocatedSpace);\n       omBucketInfo.getUsedBytes().add(preAllocatedSpace);\n+      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n+      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n+      // release BUCKET_LOCK first.\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+        acquiredLock = false;\n+      }\n+\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n+      omVolumeArgs.setUsedBytes(preAllocatedSpace);\n+      OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n+      if (acquireVolumeLock) {\n+        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n+        acquireVolumeLock = false;\n+      }", "originalCommit": "dfc8e50f63315ce8e915e1861309ab6766fe8004", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a3c5ba2e990603f66d3c737dcead759e8d5952a8", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\nindex 2353e6b38..587f9fcc0 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n\n@@ -301,27 +299,11 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           bucketName, Optional.absent(), Optional.of(missingParentInfos),\n           trxnLogIndex);\n \n-      // update usedBytes atomically.\n-      omBucketInfo.getUsedBytes().add(preAllocatedSpace);\n+      // update usedBytes.\n+      omBucketInfo.incrUsedBytes(preAllocatedSpace);\n       OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n-      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n-      // release BUCKET_LOCK first.\n-      if (acquiredLock) {\n-        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n-            bucketName);\n-        acquiredLock = false;\n-      }\n-\n-      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n-          VOLUME_LOCK, volumeName);\n-      omVolumeArgs.setUsedBytes(preAllocatedSpace);\n+      omVolumeArgs.incrUsedBytes(preAllocatedSpace);\n       OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n-      if (acquireVolumeLock) {\n-        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n-        acquireVolumeLock = false;\n-      }\n-      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n \n       // Prepare response\n       omResponse.setCreateFileResponse(CreateFileResponse.newBuilder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1MTU3OA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515151578", "bodyText": "The similar concurrent update issue for bucket usedBytes will happens if we release bucket lock here and then try to acquire bucket lock again.\nAs mentioned above, we should both lock the volume and bucket lock for the whole method.", "author": "linyiqun", "createdAt": "2020-10-30T14:48:40Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -300,8 +302,26 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           trxnLogIndex);\n \n       // update usedBytes atomically.\n-      omVolumeArgs.getUsedBytes().add(preAllocatedSpace);\n       omBucketInfo.getUsedBytes().add(preAllocatedSpace);\n+      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n+      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n+      // release BUCKET_LOCK first.\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+        acquiredLock = false;\n+      }", "originalCommit": "dfc8e50f63315ce8e915e1861309ab6766fe8004", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a3c5ba2e990603f66d3c737dcead759e8d5952a8", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\nindex 2353e6b38..587f9fcc0 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n\n@@ -301,27 +299,11 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           bucketName, Optional.absent(), Optional.of(missingParentInfos),\n           trxnLogIndex);\n \n-      // update usedBytes atomically.\n-      omBucketInfo.getUsedBytes().add(preAllocatedSpace);\n+      // update usedBytes.\n+      omBucketInfo.incrUsedBytes(preAllocatedSpace);\n       OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n-      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n-      // release BUCKET_LOCK first.\n-      if (acquiredLock) {\n-        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n-            bucketName);\n-        acquiredLock = false;\n-      }\n-\n-      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n-          VOLUME_LOCK, volumeName);\n-      omVolumeArgs.setUsedBytes(preAllocatedSpace);\n+      omVolumeArgs.incrUsedBytes(preAllocatedSpace);\n       OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n-      if (acquireVolumeLock) {\n-        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n-        acquireVolumeLock = false;\n-      }\n-      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n \n       // Prepare response\n       omResponse.setCreateFileResponse(CreateFileResponse.newBuilder()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE1NzczOQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515157739", "bodyText": "We should also update below lines to use copyVolumeArgs,  copyBucketInfo.\n    } catch (IOException ex) {\n      result = Result.FAILURE;\n      exception = ex;\n      omClientResponse = new S3MultipartUploadCommitPartResponse(\n          createErrorOMResponse(omResponse, exception), multipartKey, openKey,\n          multipartKeyInfo, oldPartKeyInfo, omKeyInfo,\n          ozoneManager.isRatisEnabled(), omVolumeArgs, omBucketInfo);\n    } finally {\n    ...\n    }", "author": "linyiqun", "createdAt": "2020-10-30T14:53:57Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java", "diffHunk": "@@ -222,16 +218,34 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       // be subtracted.\n       long correctedSpace = omKeyInfo.getDataSize() * factor -\n           keyArgs.getKeyLocationsList().size() * scmBlockSize * factor;\n-      omVolumeArgs.getUsedBytes().add(correctedSpace);\n       omBucketInfo.getUsedBytes().add(correctedSpace);\n+      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n+      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n+      // release BUCKET_LOCK first.\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+        acquiredLock = false;\n+      }\n+\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n+      omVolumeArgs.setUsedBytes(correctedSpace);\n+      OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n+      if (acquireVolumeLock) {\n+        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n+        acquireVolumeLock = false;\n+      }\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n \n       omResponse.setCommitMultiPartUploadResponse(\n           MultipartCommitUploadPartResponse.newBuilder()\n               .setPartName(partName));\n       omClientResponse = new S3MultipartUploadCommitPartResponse(\n           omResponse.build(), multipartKey, openKey,\n           multipartKeyInfo, oldPartKeyInfo, omKeyInfo,\n-          ozoneManager.isRatisEnabled(), omVolumeArgs, omBucketInfo);\n+          ozoneManager.isRatisEnabled(), copyVolumeArgs, copyBucketInfo);", "originalCommit": "dfc8e50f63315ce8e915e1861309ab6766fe8004", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a3c5ba2e990603f66d3c737dcead759e8d5952a8", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java\nindex a25429bd4..520c53912 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/s3/multipart/S3MultipartUploadCommitPartRequest.java\n\n@@ -218,26 +218,11 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       // be subtracted.\n       long correctedSpace = omKeyInfo.getDataSize() * factor -\n           keyArgs.getKeyLocationsList().size() * scmBlockSize * factor;\n-      omBucketInfo.getUsedBytes().add(correctedSpace);\n-      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n-      // We cannot acquire VOLUME_LOCK while holding BUCKET_LOCK. So\n-      // release BUCKET_LOCK first.\n-      if (acquiredLock) {\n-        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n-            bucketName);\n-        acquiredLock = false;\n-      }\n-\n-      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n-          VOLUME_LOCK, volumeName);\n-      omVolumeArgs.setUsedBytes(correctedSpace);\n-      OmVolumeArgs copyVolumeArgs = omVolumeArgs.copyObject();\n-      if (acquireVolumeLock) {\n-        omMetadataManager.getLock().releaseWriteLock(VOLUME_LOCK, volumeName);\n-        acquireVolumeLock = false;\n-      }\n-      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n+      // update usedBytes.\n+      omBucketInfo.incrUsedBytes(correctedSpace);\n+      copyBucketInfo = omBucketInfo.copyObject();\n+      omVolumeArgs.incrUsedBytes(correctedSpace);\n+      copyVolumeArgs = omVolumeArgs.copyObject();\n \n       omResponse.setCommitMultiPartUploadResponse(\n           MultipartCommitUploadPartResponse.newBuilder()\n"}}, {"oid": "a3c5ba2e990603f66d3c737dcead759e8d5952a8", "url": "https://github.com/apache/ozone/commit/a3c5ba2e990603f66d3c737dcead759e8d5952a8", "message": "fix review issues", "committedDate": "2020-11-02T12:04:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODYyMA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515938620", "bodyText": "The similar concurrent update issue for bucket usedBytes will happens if we release bucket lock here and then try to acquire bucket lock again.\nAs mentioned above, we should both lock the volume and bucket lock for the whole method.\n\n@captainzmc , can you address above comment, bucket lock is also needed since we also do the bucket used bytes update. Can you update this in all below places?\nOther change looks good to me.", "author": "linyiqun", "createdAt": "2020-11-02T12:30:28Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -206,8 +206,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n-      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n ", "originalCommit": "a3c5ba2e990603f66d3c737dcead759e8d5952a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk3NTY3OQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r515975679", "bodyText": "Thanks  for @linyiqun's feedback. A new commit has been committed to fix this.", "author": "captainzmc", "createdAt": "2020-11-02T13:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTkzODYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "d9d17aa72f7c5f459b55e87774699e9ca5757308", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\nindex 587f9fcc0..88d6745bd 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n\n@@ -206,8 +206,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n-      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n-          VOLUME_LOCK, volumeName);\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n \n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MjA1Mg==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r516082052", "bodyText": "Nit: Can we rename all variable name of acquiredLock to acquireBucketLock in current PR change?", "author": "linyiqun", "createdAt": "2020-11-02T16:10:59Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java", "diffHunk": "@@ -206,6 +208,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n+      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n+          VOLUME_LOCK, volumeName);\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "originalCommit": "325930137c02a41064a5d1f561477a8aa0052017", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0NTE1MQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r516445151", "bodyText": "Thanks @linyiqun.  Changed this with new commit.", "author": "captainzmc", "createdAt": "2020-11-03T06:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4MjA1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d9d17aa72f7c5f459b55e87774699e9ca5757308", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\nindex 1a6d8a7a1..88d6745bd 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileCreateRequest.java\n\n@@ -208,8 +206,6 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n           IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n \n       // acquire lock\n-      acquireVolumeLock = omMetadataManager.getLock().acquireWriteLock(\n-          VOLUME_LOCK, volumeName);\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n           volumeName, bucketName);\n \n"}}, {"oid": "d9d17aa72f7c5f459b55e87774699e9ca5757308", "url": "https://github.com/apache/ozone/commit/d9d17aa72f7c5f459b55e87774699e9ca5757308", "message": "Fix issue with quota update", "committedDate": "2020-11-05T14:42:58Z", "type": "commit"}, {"oid": "d9d17aa72f7c5f459b55e87774699e9ca5757308", "url": "https://github.com/apache/ozone/commit/d9d17aa72f7c5f459b55e87774699e9ca5757308", "message": "Fix issue with quota update", "committedDate": "2020-11-05T14:42:58Z", "type": "forcePushed"}, {"oid": "357d513680f1d3b46660fd092e134f7a898e5586", "url": "https://github.com/apache/ozone/commit/357d513680f1d3b46660fd092e134f7a898e5586", "message": "trigger new CI check", "committedDate": "2020-11-05T16:10:36Z", "type": "commit"}, {"oid": "f4428bfc07d20e351a23b936d48042201f1ea31c", "url": "https://github.com/apache/ozone/commit/f4428bfc07d20e351a23b936d48042201f1ea31c", "message": "fix review issues.", "committedDate": "2020-11-19T13:40:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MDQ2NQ==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529170465", "bodyText": "we do not need this comment any more.", "author": "runzhiwang", "createdAt": "2020-11-24T03:02:39Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "diffHunk": "@@ -171,15 +171,15 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n         quotaReleased += sumBlockLengths(omKeyInfo);\n       }\n       // update usedBytes atomically.", "originalCommit": "f4428bfc07d20e351a23b936d48042201f1ea31c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f9831c4ff632ec192cc30d7050076eabfcbddace", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java\nindex c56d666f3..3dc22e8fa 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java\n\n@@ -170,16 +170,15 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n         omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n         quotaReleased += sumBlockLengths(omKeyInfo);\n       }\n-      // update usedBytes atomically.\n       omBucketInfo.incrUsedBytes(-quotaReleased);\n-      OmBucketInfo copyBucketInfo = omBucketInfo.copyObject();\n \n       omClientResponse = new OMKeysDeleteResponse(omResponse\n           .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n               .setStatus(deleteStatus).setUnDeletedKeys(unDeletedKeys))\n           .setStatus(deleteStatus ? OK : PARTIAL_DELETE)\n           .setSuccess(deleteStatus).build(), omKeyInfoList,\n-          ozoneManager.isRatisEnabled(), omVolumeArgs, copyBucketInfo);\n+          ozoneManager.isRatisEnabled(), omVolumeArgs,\n+          omBucketInfo.copyObject());\n \n       result = Result.SUCCESS;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MTAxNA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529171014", "bodyText": "this.usedBytes += bytes;", "author": "runzhiwang", "createdAt": "2020-11-24T03:04:29Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java", "diffHunk": "@@ -241,9 +240,14 @@ public String getSourceBucket() {\n   }\n \n \n-  public LongAdder getUsedBytes() {\n+  public long getUsedBytes() {\n     return usedBytes;\n   }\n+\n+  public void incrUsedBytes(long bytes) {\n+    this.usedBytes = this.usedBytes + bytes;", "originalCommit": "f4428bfc07d20e351a23b936d48042201f1ea31c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f9831c4ff632ec192cc30d7050076eabfcbddace", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java\nindex 28c7a1ce2..a23bbfc1d 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java\n+++ b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmBucketInfo.java\n\n@@ -245,7 +245,7 @@ public long getUsedBytes() {\n   }\n \n   public void incrUsedBytes(long bytes) {\n-    this.usedBytes = this.usedBytes + bytes;\n+    this.usedBytes += bytes;\n   }\n \n   public long getQuotaInBytes() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MjI5Nw==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529172297", "bodyText": "revert this line", "author": "runzhiwang", "createdAt": "2020-11-24T03:08:43Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyCommitRequest.java", "diffHunk": "@@ -167,7 +167,6 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n         }\n       }\n \n-", "originalCommit": "f4428bfc07d20e351a23b936d48042201f1ea31c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MjYyMA==", "url": "https://github.com/apache/ozone/pull/1489#discussion_r529172620", "bodyText": "copyBucketInfo -> omBucketInfo.copyObject()", "author": "runzhiwang", "createdAt": "2020-11-24T03:09:40Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -158,7 +158,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n \n       omClientResponse = new OMKeyDeleteResponse(omResponse\n           .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n-          omKeyInfo, ozoneManager.isRatisEnabled(), omVolumeArgs, omBucketInfo);\n+          omKeyInfo, ozoneManager.isRatisEnabled(), omVolumeArgs,\n+          copyBucketInfo);", "originalCommit": "f4428bfc07d20e351a23b936d48042201f1ea31c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f9831c4ff632ec192cc30d7050076eabfcbddace", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex da72ee27b..a99c02bc0 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -159,7 +157,7 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       omClientResponse = new OMKeyDeleteResponse(omResponse\n           .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n           omKeyInfo, ozoneManager.isRatisEnabled(), omVolumeArgs,\n-          copyBucketInfo);\n+          omBucketInfo.copyObject());\n \n       result = Result.SUCCESS;\n     } catch (IOException ex) {\n"}}, {"oid": "f9831c4ff632ec192cc30d7050076eabfcbddace", "url": "https://github.com/apache/ozone/commit/f9831c4ff632ec192cc30d7050076eabfcbddace", "message": "fix review issues.", "committedDate": "2020-11-24T12:19:10Z", "type": "commit"}]}