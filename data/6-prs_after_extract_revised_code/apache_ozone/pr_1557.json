{"pr_number": 1557, "pr_title": "HDDS-4357: Rename : make rename an atomic ops by updating key path entry in dir/file table", "pr_createdAt": "2020-11-06T11:16:56Z", "pr_url": "https://github.com/apache/ozone/pull/1557", "timeline": [{"oid": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "url": "https://github.com/apache/ozone/commit/87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "message": "HDDS-4357: Rename : make rename an atomic ops by updating key path entry in dir/file table", "committedDate": "2020-11-06T11:10:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NjkwMQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r519096901", "bodyText": "Can we add additional test cases that can fully cover current rename logic:\n\n\nRename to a existed file, failed.\n\n\nRename to a existed folder:\nRename from /a, to /b, final key will be /b/a\n\n\nRename to a parent folder:\ncase1: parent folder does't exist, and then failed\ncase2: parent folder existed, then succeed", "author": "linyiqun", "createdAt": "2020-11-07T04:14:04Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java", "diffHunk": "@@ -260,6 +260,44 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+\n+  protected void testRenameDir() throws Exception {\n+    final String root = \"/root_dir\";\n+    final String dir = root + \"/dir1\";\n+    final Path source = new Path(fs.getUri().toString() + dir);\n+    final Path dest = new Path(source.toString() + \".renamed\");\n+    // Add a sub-dir to the directory to be moved.\n+    final Path subdir = new Path(source, \"sub_dir1\");\n+    fs.mkdirs(subdir);\n+    LOG.info(\"Created dir {}\", subdir);\n+\n+    // case-1) source is a sub-dir to destin\n+    final Path sourceRoot = new Path(fs.getUri().toString() + root);\n+    LOG.info(\"Rename op-> source:/root_dir to destin:/root_dir/dir1/sub_dir1\");\n+    try {\n+      fs.rename(sourceRoot, subdir);\n+      Assert.fail(\"Should throw exception : Cannot rename a directory to\" +\n+              \" its own subdirectory\");\n+    } catch (OMException e) {\n+      // expected\n+    }\n+\n+    LOG.info(\"Will move {} to {}\", source, dest);\n+    fs.rename(source, dest);\n+\n+    assertTrue(\"Directory rename failed\", fs.exists(dest));\n+    // Verify that the subdir is also renamed i.e. keys corresponding to the\n+    // sub-directories of the renamed directory have also been renamed.\n+    assertTrue(\"Keys under the renamed directory not renamed\",\n+            fs.exists(new Path(dest, \"sub_dir1\")));\n+\n+    // Test if one path belongs to other FileSystem.\n+    Path fakeDir = new Path(fs.getUri().toString() + \"fake\" + dir);\n+    LambdaTestUtils.intercept(IllegalArgumentException.class, \"Wrong FS\",\n+            () -> fs.rename(fakeDir, dest));", "originalCommit": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDczMzA3OA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520733078", "bodyText": "@linyiqun  Thanks a lot for the review comments.\nSure, I will add tests. Can you please help me to understand about case1 with some example.\n\ncase1: parent folder does't exist, and then failed\n\nRename from /a/b/c/d to /a. Are you talking about this? How would I simulate non-existent \"/a\", which is already a valid root of the source path, right?\n\ncase2: parent folder existed, then succeed\n\nI think you are saying that, Rename from \"/a/b/c\" to \"/a\". It will succeed and result will be \"/a/c\"", "author": "rakeshadr", "createdAt": "2020-11-10T17:16:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NjkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA2MDAwNg==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r521060006", "bodyText": "Rename from /a/b/c/d to /a. Are you talking about this? How would I simulate non-existent \"/a\", which is already a valid root of the source path, right?\n\nYes, you are right. Can we transform this to the case below:\ndir: /a/b/c/d\nfile: /a/d,\nRename from /a/b/c/d to /a, should be failed since /a/d is a existed file.\n\nI think you are saying that, Rename from \"/a/b/c\" to \"/a\". It will succeed and result will be \"/a/c\"\n\nYes, this is what I want to say.\nHope makes sense to you.", "author": "linyiqun", "createdAt": "2020-11-11T02:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NjkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA2NTcwMA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r521065700", "bodyText": "Thanks for the clear explanation. Will prepare the changes!", "author": "rakeshadr", "createdAt": "2020-11-11T03:05:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NjkwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "86647aab902ab199236e7cea22a553eae6e26998", "chunk": "diff --git a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\nindex ffa0d7347e..c4849ce813 100644\n--- a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\n+++ b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\n\n@@ -260,43 +260,159 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+  /**\n+   * Case-1) fromKeyName should exist, otw throws exception.\n+   */\n+  protected void testRenameWithNonExistentSource() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final String dir2 = root + \"/dir2\";\n+    final Path source = new Path(fs.getUri().toString() + dir1);\n+    final Path destin = new Path(fs.getUri().toString() + dir2);\n+\n+    // creates destin\n+    fs.mkdirs(destin);\n+    LOG.info(\"Created destin dir: {}\", destin);\n+\n+    LOG.info(\"Rename op-> source:{} to destin:{}}\", source, destin);\n+    try {\n+      fs.rename(source, destin);\n+      Assert.fail(\"Should throw exception : Source doesn't exist!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_NOT_FOUND);\n+    }\n+  }\n+\n+  /**\n+   * Case-2) Cannot rename a directory to its own subdirectory.\n+   */\n+  protected void testRenameDirToItsOwnSubDir() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final Path dir1Path = new Path(fs.getUri().toString() + dir1);\n+    // Add a sub-dir1 to the directory to be moved.\n+    final Path subDir1 = new Path(dir1Path, \"sub_dir1\");\n+    fs.mkdirs(subDir1);\n+    LOG.info(\"Created dir1 {}\", subDir1);\n \n-  protected void testRenameDir() throws Exception {\n-    final String root = \"/root_dir\";\n-    final String dir = root + \"/dir1\";\n-    final Path source = new Path(fs.getUri().toString() + dir);\n-    final Path dest = new Path(source.toString() + \".renamed\");\n-    // Add a sub-dir to the directory to be moved.\n-    final Path subdir = new Path(source, \"sub_dir1\");\n-    fs.mkdirs(subdir);\n-    LOG.info(\"Created dir {}\", subdir);\n-\n-    // case-1) source is a sub-dir to destin\n     final Path sourceRoot = new Path(fs.getUri().toString() + root);\n-    LOG.info(\"Rename op-> source:/root_dir to destin:/root_dir/dir1/sub_dir1\");\n+    LOG.info(\"Rename op-> source:{} to destin:{}\", sourceRoot, subDir1);\n     try {\n-      fs.rename(sourceRoot, subdir);\n+      fs.rename(sourceRoot, subDir1);\n       Assert.fail(\"Should throw exception : Cannot rename a directory to\" +\n               \" its own subdirectory\");\n-    } catch (OMException e) {\n+    } catch (OMException ome) {\n       // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Case-5) If new destin '/dst/source' exists then throws exception.\n+   * If destination is a directory then rename source as sub-path of it.\n+   * <p>\n+   * For example: rename /a to /b will lead to /b/a. This new path should\n+   * not exist.\n+   */\n+  protected void testRenameToNewSubDirShouldNotExist() throws Exception {\n+    // Case-5.a) Rename directory from /a to /b.\n+    // created /a\n+    final Path aSourcePath = new Path(fs.getUri().toString() + \"/a\");\n+    fs.mkdirs(aSourcePath);\n+\n+    // created /b\n+    final Path bDestinPath = new Path(fs.getUri().toString() + \"/b\");\n+    fs.mkdirs(bDestinPath);\n+\n+    // Add a sub-directory '/a/c' to '/a'. This is to verify that after\n+    // rename sub-directory also be moved.\n+    final Path baPath = new Path(fs.getUri().toString() + \"/b/a\");\n+    fs.mkdirs(baPath);\n+\n+    try {\n+      fs.rename(aSourcePath, bDestinPath);\n+      Assert.fail(\"Should fail as new destination dir exists!\");\n+    } catch (OMException ome) {\n+      // expected as new sub-path /b/a already exists.\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_ALREADY_EXISTS);\n     }\n \n-    LOG.info(\"Will move {} to {}\", source, dest);\n-    fs.rename(source, dest);\n+    // Case-5.b) Rename file from /a/b/c/file1 to /a.\n+    // Should be failed since /a/file1 exists.\n+    final Path abcPath = new Path(fs.getUri().toString() + \"/a/b/c\");\n+    fs.mkdirs(abcPath);\n+    Path abcFile1 = new Path(abcPath, \"/file1\");\n+    ContractTestUtils.touch(fs, abcFile1);\n+\n+    final Path aFile1 = new Path(fs.getUri().toString() + \"/a/file1\");\n+    ContractTestUtils.touch(fs, aFile1);\n \n-    assertTrue(\"Directory rename failed\", fs.exists(dest));\n-    // Verify that the subdir is also renamed i.e. keys corresponding to the\n-    // sub-directories of the renamed directory have also been renamed.\n-    assertTrue(\"Keys under the renamed directory not renamed\",\n-            fs.exists(new Path(dest, \"sub_dir1\")));\n+    final Path aDestinPath = new Path(fs.getUri().toString() + \"/a\");\n \n-    // Test if one path belongs to other FileSystem.\n-    Path fakeDir = new Path(fs.getUri().toString() + \"fake\" + dir);\n-    LambdaTestUtils.intercept(IllegalArgumentException.class, \"Wrong FS\",\n-            () -> fs.rename(fakeDir, dest));\n+    try {\n+      fs.rename(abcFile1, aDestinPath);\n+      Assert.fail(\"Should fail as new destination file exists!\");\n+    } catch (OMException ome) {\n+      // expected as new sub-path /b/a already exists.\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+    }\n   }\n \n+  /**\n+   * Case-6) Rename directory to an existed file, should be failed.\n+   */\n+  protected void testRenameDirToFile() throws Exception {\n+    final String root = \"/root\";\n+    Path rootPath = new Path(fs.getUri().toString() + root);\n+    fs.mkdirs(rootPath);\n+\n+    Path file1Destin = new Path(fs.getUri().toString() + root + \"/file1\");\n+    ContractTestUtils.touch(fs, file1Destin);\n+    Path abcRootPath = new Path(fs.getUri().toString() + \"/a/b/c\");\n+    fs.mkdirs(abcRootPath);\n+    try {\n+      fs.rename(abcRootPath, file1Destin);\n+      Assert.fail(\"key already exists /root_dir/file1\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+    }\n+  }\n+\n+  /**\n+   * Fails if the (a) parent of dst does not exist or (b) parent is a file.\n+   */\n+  protected void testRenameDestinationParentDoesntExist() throws Exception {\n+    final String root = \"/root_dir\";\n+    final String dir1 = root + \"/dir1\";\n+    final String dir2 = dir1 + \"/dir2\";\n+    final Path dir2SourcePath = new Path(fs.getUri().toString() + dir2);\n+    fs.mkdirs(dir2SourcePath);\n+\n+    // (a) parent of dst does not exist.  /root_dir/b/c\n+    final Path destinPath = new Path(fs.getUri().toString() + root + \"/b/c\");\n+    try {\n+      fs.rename(dir2SourcePath, destinPath);\n+      Assert.fail(\"Should fail as parent of dst does not exist!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+\n+    // (b) parent of dst is a file. /root_dir/file1/c\n+    Path filePath = new Path(fs.getUri().toString() + root + \"/file1\");\n+    ContractTestUtils.touch(fs, filePath);\n+\n+    Path newDestinPath = new Path(filePath, \"c\");\n+    try {\n+      fs.rename(dir2SourcePath, newDestinPath);\n+      Assert.fail(\"Should fail as parent of dst is a file!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+  }\n \n   @Test(timeout = 300_000)\n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5Njk3MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r519096971", "bodyText": "Comment is not right, here source is parent dir,", "author": "linyiqun", "createdAt": "2020-11-07T04:14:41Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java", "diffHunk": "@@ -260,6 +260,44 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+\n+  protected void testRenameDir() throws Exception {\n+    final String root = \"/root_dir\";\n+    final String dir = root + \"/dir1\";\n+    final Path source = new Path(fs.getUri().toString() + dir);\n+    final Path dest = new Path(source.toString() + \".renamed\");\n+    // Add a sub-dir to the directory to be moved.\n+    final Path subdir = new Path(source, \"sub_dir1\");\n+    fs.mkdirs(subdir);\n+    LOG.info(\"Created dir {}\", subdir);\n+\n+    // case-1) source is a sub-dir to destin", "originalCommit": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIzNDE1MA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r521234150", "bodyText": "Done in latest commit", "author": "rakeshadr", "createdAt": "2020-11-11T09:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5Njk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "86647aab902ab199236e7cea22a553eae6e26998", "chunk": "diff --git a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\nindex ffa0d7347e..c4849ce813 100644\n--- a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\n+++ b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\n\n@@ -260,43 +260,159 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+  /**\n+   * Case-1) fromKeyName should exist, otw throws exception.\n+   */\n+  protected void testRenameWithNonExistentSource() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final String dir2 = root + \"/dir2\";\n+    final Path source = new Path(fs.getUri().toString() + dir1);\n+    final Path destin = new Path(fs.getUri().toString() + dir2);\n+\n+    // creates destin\n+    fs.mkdirs(destin);\n+    LOG.info(\"Created destin dir: {}\", destin);\n+\n+    LOG.info(\"Rename op-> source:{} to destin:{}}\", source, destin);\n+    try {\n+      fs.rename(source, destin);\n+      Assert.fail(\"Should throw exception : Source doesn't exist!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_NOT_FOUND);\n+    }\n+  }\n+\n+  /**\n+   * Case-2) Cannot rename a directory to its own subdirectory.\n+   */\n+  protected void testRenameDirToItsOwnSubDir() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final Path dir1Path = new Path(fs.getUri().toString() + dir1);\n+    // Add a sub-dir1 to the directory to be moved.\n+    final Path subDir1 = new Path(dir1Path, \"sub_dir1\");\n+    fs.mkdirs(subDir1);\n+    LOG.info(\"Created dir1 {}\", subDir1);\n \n-  protected void testRenameDir() throws Exception {\n-    final String root = \"/root_dir\";\n-    final String dir = root + \"/dir1\";\n-    final Path source = new Path(fs.getUri().toString() + dir);\n-    final Path dest = new Path(source.toString() + \".renamed\");\n-    // Add a sub-dir to the directory to be moved.\n-    final Path subdir = new Path(source, \"sub_dir1\");\n-    fs.mkdirs(subdir);\n-    LOG.info(\"Created dir {}\", subdir);\n-\n-    // case-1) source is a sub-dir to destin\n     final Path sourceRoot = new Path(fs.getUri().toString() + root);\n-    LOG.info(\"Rename op-> source:/root_dir to destin:/root_dir/dir1/sub_dir1\");\n+    LOG.info(\"Rename op-> source:{} to destin:{}\", sourceRoot, subDir1);\n     try {\n-      fs.rename(sourceRoot, subdir);\n+      fs.rename(sourceRoot, subDir1);\n       Assert.fail(\"Should throw exception : Cannot rename a directory to\" +\n               \" its own subdirectory\");\n-    } catch (OMException e) {\n+    } catch (OMException ome) {\n       // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Case-5) If new destin '/dst/source' exists then throws exception.\n+   * If destination is a directory then rename source as sub-path of it.\n+   * <p>\n+   * For example: rename /a to /b will lead to /b/a. This new path should\n+   * not exist.\n+   */\n+  protected void testRenameToNewSubDirShouldNotExist() throws Exception {\n+    // Case-5.a) Rename directory from /a to /b.\n+    // created /a\n+    final Path aSourcePath = new Path(fs.getUri().toString() + \"/a\");\n+    fs.mkdirs(aSourcePath);\n+\n+    // created /b\n+    final Path bDestinPath = new Path(fs.getUri().toString() + \"/b\");\n+    fs.mkdirs(bDestinPath);\n+\n+    // Add a sub-directory '/a/c' to '/a'. This is to verify that after\n+    // rename sub-directory also be moved.\n+    final Path baPath = new Path(fs.getUri().toString() + \"/b/a\");\n+    fs.mkdirs(baPath);\n+\n+    try {\n+      fs.rename(aSourcePath, bDestinPath);\n+      Assert.fail(\"Should fail as new destination dir exists!\");\n+    } catch (OMException ome) {\n+      // expected as new sub-path /b/a already exists.\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_ALREADY_EXISTS);\n     }\n \n-    LOG.info(\"Will move {} to {}\", source, dest);\n-    fs.rename(source, dest);\n+    // Case-5.b) Rename file from /a/b/c/file1 to /a.\n+    // Should be failed since /a/file1 exists.\n+    final Path abcPath = new Path(fs.getUri().toString() + \"/a/b/c\");\n+    fs.mkdirs(abcPath);\n+    Path abcFile1 = new Path(abcPath, \"/file1\");\n+    ContractTestUtils.touch(fs, abcFile1);\n+\n+    final Path aFile1 = new Path(fs.getUri().toString() + \"/a/file1\");\n+    ContractTestUtils.touch(fs, aFile1);\n \n-    assertTrue(\"Directory rename failed\", fs.exists(dest));\n-    // Verify that the subdir is also renamed i.e. keys corresponding to the\n-    // sub-directories of the renamed directory have also been renamed.\n-    assertTrue(\"Keys under the renamed directory not renamed\",\n-            fs.exists(new Path(dest, \"sub_dir1\")));\n+    final Path aDestinPath = new Path(fs.getUri().toString() + \"/a\");\n \n-    // Test if one path belongs to other FileSystem.\n-    Path fakeDir = new Path(fs.getUri().toString() + \"fake\" + dir);\n-    LambdaTestUtils.intercept(IllegalArgumentException.class, \"Wrong FS\",\n-            () -> fs.rename(fakeDir, dest));\n+    try {\n+      fs.rename(abcFile1, aDestinPath);\n+      Assert.fail(\"Should fail as new destination file exists!\");\n+    } catch (OMException ome) {\n+      // expected as new sub-path /b/a already exists.\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+    }\n   }\n \n+  /**\n+   * Case-6) Rename directory to an existed file, should be failed.\n+   */\n+  protected void testRenameDirToFile() throws Exception {\n+    final String root = \"/root\";\n+    Path rootPath = new Path(fs.getUri().toString() + root);\n+    fs.mkdirs(rootPath);\n+\n+    Path file1Destin = new Path(fs.getUri().toString() + root + \"/file1\");\n+    ContractTestUtils.touch(fs, file1Destin);\n+    Path abcRootPath = new Path(fs.getUri().toString() + \"/a/b/c\");\n+    fs.mkdirs(abcRootPath);\n+    try {\n+      fs.rename(abcRootPath, file1Destin);\n+      Assert.fail(\"key already exists /root_dir/file1\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+    }\n+  }\n+\n+  /**\n+   * Fails if the (a) parent of dst does not exist or (b) parent is a file.\n+   */\n+  protected void testRenameDestinationParentDoesntExist() throws Exception {\n+    final String root = \"/root_dir\";\n+    final String dir1 = root + \"/dir1\";\n+    final String dir2 = dir1 + \"/dir2\";\n+    final Path dir2SourcePath = new Path(fs.getUri().toString() + dir2);\n+    fs.mkdirs(dir2SourcePath);\n+\n+    // (a) parent of dst does not exist.  /root_dir/b/c\n+    final Path destinPath = new Path(fs.getUri().toString() + root + \"/b/c\");\n+    try {\n+      fs.rename(dir2SourcePath, destinPath);\n+      Assert.fail(\"Should fail as parent of dst does not exist!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+\n+    // (b) parent of dst is a file. /root_dir/file1/c\n+    Path filePath = new Path(fs.getUri().toString() + root + \"/file1\");\n+    ContractTestUtils.touch(fs, filePath);\n+\n+    Path newDestinPath = new Path(filePath, \"c\");\n+    try {\n+      fs.rename(dir2SourcePath, newDestinPath);\n+      Assert.fail(\"Should fail as parent of dst is a file!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+  }\n \n   @Test(timeout = 300_000)\n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTk2MA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520961960", "bodyText": "Minor:\nCheck if fromKey exists", "author": "bharatviswa504", "createdAt": "2020-11-11T00:33:14Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists", "originalCommit": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4MjkwMw==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r521082903", "bodyText": "Yes, I am doing it. It seems, I need to improve the commenting section. I will try improve it :-)", "author": "rakeshadr", "createdAt": "2020-11-11T03:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2MTk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "86647aab902ab199236e7cea22a553eae6e26998", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\nindex 44091c9a7f..74e53fe314 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\n\n@@ -115,45 +115,46 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n-      // Check if toKey exists\n+      // Check if fromKey exists\n       OzoneFileStatus fromKeyFileStatus =\n               OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n                       bucketName, fromKeyName, 0);\n-      // fromKeyName should exist\n+      // case-1) fromKeyName should exist, otw throws exception\n       if (fromKeyFileStatus == null) {\n         // TODO: Add support for renaming open key\n         throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n       }\n \n-      // source exists\n+      // source existed\n       fromKeyValue = fromKeyFileStatus.getKeyInfo();\n       boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n \n-      // Cannot rename a directory to its own subdirectory\n+      // case-2) Cannot rename a directory to its own subdirectory\n       OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n               toKeyName, fromKeyFileStatus.isDirectory());\n \n       OzoneFileStatus toKeyFileStatus =\n               OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n                       volumeName, bucketName, toKeyName, 0);\n-      OmKeyInfo toKeyValue;\n \n-      // Destination exists cases:\n+      // Check if toKey exists.\n       if(toKeyFileStatus != null) {\n-\n-        toKeyValue = toKeyFileStatus.getKeyInfo();\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n \n         if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n-          // case-1) src == destin then check source and destin of same type\n-          // If dst is a file then return true. Otherwise fail the operation.\n-          if (!toKeyFileStatus.isDirectory()) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n             result = Result.SUCCESS;\n           } else {\n             throw new OMException(\"Key already exists \" + toKeyName,\n                     OMException.ResultCodes.KEY_ALREADY_EXISTS);\n           }\n         } else if (toKeyFileStatus.isDirectory()) {\n-          // case-2) If dst is a directory, rename source as sub-path of it.\n+          // case-4) If dst is a directory then rename source as sub-path of it\n           // For example: rename /source to /dst will lead to /dst/source\n           String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n           String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520962991", "bodyText": "How this works for Object Store API when used from shell.\nIn Object Store scenario how you will distinguish between file and dir.", "author": "bharatviswa504", "createdAt": "2020-11-11T00:36:16Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // fromKeyName should exist\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source exists\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();", "originalCommit": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIzNjkxOA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r521236918", "bodyText": "Thanks @bharatviswa504 for the review help. Hope we have unit test to verify this behavior. Could you please point me to that.\nAdding a fair guess, will FS semantics flag help us to cover this case ?", "author": "rakeshadr", "createdAt": "2020-11-11T09:46:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzNzQyNg==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522537426", "bodyText": "FS Semantics flag do you mean ozone.filesystem.paths.enable.\nmy question was when key is created via ObjectStore API like KeyCreate and rename is called what happens. (When above flag is false)\nBecause previously from Object Store API rename on directories is not possible. But with this approach how this will work, and how the rename will work?", "author": "bharatviswa504", "createdAt": "2020-11-13T00:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE3NTI0OQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523175249", "bodyText": "Because previously from Object Store API rename on directories is not possible\n\n\"previously\" - you meant before HDDS-2939 ? or are we allowing rename when ozone.filesystem.paths.enable=true or false ?\nSorry for multiple questions. Appreciate if you could add an example case that would help me to think better:-). Thanks!", "author": "rakeshadr", "createdAt": "2020-11-13T19:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkwNTU1Ng==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523905556", "bodyText": "ozone.filesystem.paths.enable=false\nwhen key is created like /a/b/c/d(Using key create API) i think we don't create intermediate directories right?\nSo, in that case, how rename works is my question.\nBecause we check key exists or not by checking dirTable for parents and for leaf FileTable.", "author": "bharatviswa504", "createdAt": "2020-11-16T05:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzkxODA4Mg==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523918082", "bodyText": "Thanks @bharatviswa504 for the clear explanation.\nYes, it won't create intermediate dirs if ozone.filesystem.paths.enable=false.\nAdding one more point to consider.\nReference earlier discussion\nV1 feature version : Following ops shouldn't depend on enableFSPaths flag\n   File/DirDelete -> Look into fileTable and dirTable for the keys.\n   File/DirRename-> Look into fileTable and dirTable for the keys.\n\nV1 feature version & enableFSPaths=true\n   KeyDelete ---> Look into fileTable and dirTable for the keys.\n   KeyRename -> supported only in ozone shell. It should look into fileTable and dirTable for the keys.\n\nNow the challenge is to support rename for keys as the rename implementation at OM side don't have any clue about whether operation coming from shell objectstore rename or FSRename, right?\nTo unblock current rename PR and proceed to finish OFS implementation - As we planned earlier, at this initial stage how about target only FS apis and incrementally we can provide supporting ObjectStore KeyCreate, list, delete and rename ops ? I will raise a specific jira issues to handle the Key cases.\nDoes that make sense to you?", "author": "rakeshadr", "createdAt": "2020-11-16T06:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2Mjk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "86647aab902ab199236e7cea22a553eae6e26998", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\nindex 44091c9a7f..74e53fe314 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\n\n@@ -115,45 +115,46 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n-      // Check if toKey exists\n+      // Check if fromKey exists\n       OzoneFileStatus fromKeyFileStatus =\n               OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n                       bucketName, fromKeyName, 0);\n-      // fromKeyName should exist\n+      // case-1) fromKeyName should exist, otw throws exception\n       if (fromKeyFileStatus == null) {\n         // TODO: Add support for renaming open key\n         throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n       }\n \n-      // source exists\n+      // source existed\n       fromKeyValue = fromKeyFileStatus.getKeyInfo();\n       boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n \n-      // Cannot rename a directory to its own subdirectory\n+      // case-2) Cannot rename a directory to its own subdirectory\n       OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n               toKeyName, fromKeyFileStatus.isDirectory());\n \n       OzoneFileStatus toKeyFileStatus =\n               OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n                       volumeName, bucketName, toKeyName, 0);\n-      OmKeyInfo toKeyValue;\n \n-      // Destination exists cases:\n+      // Check if toKey exists.\n       if(toKeyFileStatus != null) {\n-\n-        toKeyValue = toKeyFileStatus.getKeyInfo();\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n \n         if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n-          // case-1) src == destin then check source and destin of same type\n-          // If dst is a file then return true. Otherwise fail the operation.\n-          if (!toKeyFileStatus.isDirectory()) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n             result = Result.SUCCESS;\n           } else {\n             throw new OMException(\"Key already exists \" + toKeyName,\n                     OMException.ResultCodes.KEY_ALREADY_EXISTS);\n           }\n         } else if (toKeyFileStatus.isDirectory()) {\n-          // case-2) If dst is a directory, rename source as sub-path of it.\n+          // case-4) If dst is a directory then rename source as sub-path of it\n           // For example: rename /source to /dst will lead to /dst/source\n           String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n           String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MzUzMA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r520973530", "bodyText": "Question: What is meant here by should not exist?", "author": "bharatviswa504", "createdAt": "2020-11-11T00:58:17Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // fromKeyName should exist\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source exists\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+      OmKeyInfo toKeyValue;\n+\n+      // Destination exists cases:\n+      if(toKeyFileStatus != null) {\n+\n+        toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-1) src == destin then check source and destin of same type\n+          // If dst is a file then return true. Otherwise fail the operation.\n+          if (!toKeyFileStatus.isDirectory()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-2) If dst is a directory, rename source as sub-path of it.\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // If new destination '/dst/source' exists.\n+            throw new OMException(String.format(\n+                    \"Failed to rename %s to %s, file already exists or not \" +\n+                            \"empty!\", fromKeyName, newToKeyName),\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+\n+          omClientResponse = renameKey(toKeyValue.getObjectID(), trxnLogIndex,\n+                  fromKeyValue, isRenameDirectory, newToKeyName,\n+                  keyArgs.getModificationTime(), omResponse, ozoneManager);\n+          result = Result.SUCCESS;\n+        } else {\n+          // case-3) destination is a file and should not exist", "originalCommit": "87090cdc567b2f7fe7c0e836aa55438ea51a39ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5MDIyOA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r521090228", "bodyText": "For example,\nsource: /x/y/file1 and destin: /root_dir/file1.renamed, which exits.\nRename checks whether the destin is a file type and if exists then throws KEY_ALREADY_EXISTS exception.\nI have checked existing code and followed same behavior.\nDoes this make sense to you?", "author": "rakeshadr", "createdAt": "2020-11-11T03:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MzUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "86647aab902ab199236e7cea22a553eae6e26998", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\nindex 44091c9a7f..74e53fe314 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java\n\n@@ -115,45 +115,46 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n-      // Check if toKey exists\n+      // Check if fromKey exists\n       OzoneFileStatus fromKeyFileStatus =\n               OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n                       bucketName, fromKeyName, 0);\n-      // fromKeyName should exist\n+      // case-1) fromKeyName should exist, otw throws exception\n       if (fromKeyFileStatus == null) {\n         // TODO: Add support for renaming open key\n         throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n       }\n \n-      // source exists\n+      // source existed\n       fromKeyValue = fromKeyFileStatus.getKeyInfo();\n       boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n \n-      // Cannot rename a directory to its own subdirectory\n+      // case-2) Cannot rename a directory to its own subdirectory\n       OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n               toKeyName, fromKeyFileStatus.isDirectory());\n \n       OzoneFileStatus toKeyFileStatus =\n               OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n                       volumeName, bucketName, toKeyName, 0);\n-      OmKeyInfo toKeyValue;\n \n-      // Destination exists cases:\n+      // Check if toKey exists.\n       if(toKeyFileStatus != null) {\n-\n-        toKeyValue = toKeyFileStatus.getKeyInfo();\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n \n         if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n-          // case-1) src == destin then check source and destin of same type\n-          // If dst is a file then return true. Otherwise fail the operation.\n-          if (!toKeyFileStatus.isDirectory()) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n             result = Result.SUCCESS;\n           } else {\n             throw new OMException(\"Key already exists \" + toKeyName,\n                     OMException.ResultCodes.KEY_ALREADY_EXISTS);\n           }\n         } else if (toKeyFileStatus.isDirectory()) {\n-          // case-2) If dst is a directory, rename source as sub-path of it.\n+          // case-4) If dst is a directory then rename source as sub-path of it\n           // For example: rename /source to /dst will lead to /dst/source\n           String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n           String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n"}}, {"oid": "86647aab902ab199236e7cea22a553eae6e26998", "url": "https://github.com/apache/ozone/commit/86647aab902ab199236e7cea22a553eae6e26998", "message": "Fixed review comments - added bunch of unit test cases", "committedDate": "2020-11-11T09:40:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NjM3Ng==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522496376", "bodyText": "Not got when parent is null, why we need to return keyName", "author": "bharatviswa504", "createdAt": "2020-11-12T23:18:22Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OzoneFSUtils.java", "diffHunk": "@@ -162,4 +162,46 @@ public static boolean isImmediateChild(String parentKey, String childKey) {\n \n     return parentPath.equals(childParent);\n   }\n+\n+  /**\n+   * The function returns parent directory from the given absolute path. For\n+   * example, the given key path '/a/b/c/d/e/file1' then it returns parent\n+   * directory name as 'e'.\n+   *\n+   * @param keyName key name\n+   */\n+  public static String getParentDir(@Nonnull String keyName) {\n+    java.nio.file.Path fileName = Paths.get(keyName).getParent();\n+    if (fileName != null) {\n+      return fileName.toString();\n+    }\n+    // failed to converts a path key\n+    return keyName;", "originalCommit": "86647aab902ab199236e7cea22a553eae6e26998", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA3OTk1OQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523079959", "bodyText": "This is done to avoid any NPE and I thought below logic will throw exception. Does that make sense to you?\nOzoneFileStatus toKeyParentDirStatus = getOMKeyInfoIfExists(metaMgr,\n          volumeName, bucketName, toKeyParentDir, 0);\n  // check if the immediate parent exists\n  if (toKeyParentDirStatus == null || toKeyParentDirStatus.isFile()) {\n    throw new OMException(String.format(\n            \"Failed to rename %s to %s, %s is a file\", fromKeyName, toKeyName,\n            toKeyParentDir), OMException.ResultCodes.KEY_RENAME_ERROR);\n  }", "author": "rakeshadr", "createdAt": "2020-11-13T16:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MDQxNA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r525580414", "bodyText": "You mean to say here because we use Paths.get will cause issue here?", "author": "bharatviswa504", "createdAt": "2020-11-17T22:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc0NjQxNA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r526746414", "bodyText": "Yes, it won't occur in general, just return keyname it for the safer side.", "author": "rakeshadr", "createdAt": "2020-11-19T10:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NjM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "6cbffbae9349c7481e8e9aeeebff0d147be61819", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OzoneFSUtils.java b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OzoneFSUtils.java\nindex 80cb5487a7..e9d4cf98fa 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OzoneFSUtils.java\n+++ b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OzoneFSUtils.java\n\n@@ -169,13 +169,14 @@ public static boolean isImmediateChild(String parentKey, String childKey) {\n    * directory name as 'e'.\n    *\n    * @param keyName key name\n+   * @return parent directory. If not found then return keyName itself.\n    */\n   public static String getParentDir(@Nonnull String keyName) {\n     java.nio.file.Path fileName = Paths.get(keyName).getParent();\n     if (fileName != null) {\n       return fileName.toString();\n     }\n-    // failed to converts a path key\n+    // failed to find a parent directory.\n     return keyName;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNzk3MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522507971", "bodyText": "Minor: When toKeyParentDirStatus null means intermediate directories does not exist. So, should we change the exception when it is file and null.", "author": "bharatviswa504", "createdAt": "2020-11-12T23:41:25Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -696,4 +697,91 @@ public static String getAbsolutePath(String prefixName, String fileName) {\n     }\n     return prefixName.concat(OzoneConsts.OZONE_URI_DELIMITER).concat(fileName);\n   }\n+\n+  /**\n+   * Build DirectoryInfo from OmKeyInfo.\n+   *\n+   * @param keyInfo omKeyInfo\n+   * @return omDirectoryInfo object\n+   */\n+  public static OmDirectoryInfo getDirectoryInfo(OmKeyInfo keyInfo){\n+    OmDirectoryInfo.Builder builder = new OmDirectoryInfo.Builder();\n+    builder.setParentObjectID(keyInfo.getParentObjectID());\n+    builder.setAcls(keyInfo.getAcls());\n+    builder.addAllMetadata(keyInfo.getMetadata());\n+    builder.setCreationTime(keyInfo.getCreationTime());\n+    builder.setModificationTime(keyInfo.getModificationTime());\n+    builder.setObjectID(keyInfo.getObjectID());\n+    builder.setUpdateID(keyInfo.getUpdateID());\n+    builder.setName(OzoneFSUtils.getFileName(keyInfo.getKeyName()));\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Verify that the given toKey directory is a sub directory of fromKey\n+   * directory.\n+   * <p>\n+   * For example, special case of renaming a directory to its own\n+   * sub-directory is not allowed.\n+   *\n+   * @param fromKeyName source path\n+   * @param toKeyName   destination path\n+   * @throws OMException if the dest dir is a sub-dir of source dir.\n+   */\n+  public static void verifyToDirIsASubDirOfFromDirectory(String fromKeyName,\n+      String toKeyName, boolean isDir) throws OMException {\n+    if (!isDir) {\n+      return;\n+    }\n+    Path dstParent = Paths.get(toKeyName).getParent();\n+    while (dstParent != null) {\n+      if (Paths.get(fromKeyName).equals(dstParent)) {\n+        throw new OMException(\"Cannot rename a directory to its own \" +\n+                \"subdirectory\", OMException.ResultCodes.KEY_RENAME_ERROR);\n+        // TODO: Existing rename throws java.lang.IllegalArgumentException.\n+        //       Should we throw same exception ?\n+      }\n+      dstParent = dstParent.getParent();\n+    }\n+  }\n+\n+  /**\n+   * Verify parent exists for the destination path and return destination\n+   * path parent Id.\n+   * <p>\n+   * Check whether dst parent dir exists or not. If the parent exists, then the\n+   * source can be renamed to dst path.\n+   *\n+   * @param volumeName  volume name\n+   * @param bucketName  bucket name\n+   * @param toKeyName   destination path\n+   * @param fromKeyName source path\n+   * @param metaMgr     metadata manager\n+   * @throws IOException if the destination parent dir doesn't exists.\n+   */\n+  public static long getToKeyNameParentId(String volumeName,\n+      String bucketName, String toKeyName, String fromKeyName,\n+      OMMetadataManager metaMgr) throws IOException {\n+\n+    int totalDirsCount = OzoneFSUtils.getFileCount(toKeyName);\n+    // skip parent is root '/'\n+    if (totalDirsCount <= 1) {\n+      String bucketKey = metaMgr.getBucketKey(volumeName, bucketName);\n+      OmBucketInfo omBucketInfo =\n+              metaMgr.getBucketTable().get(bucketKey);\n+      return omBucketInfo.getObjectID();\n+    }\n+\n+    String toKeyParentDir = OzoneFSUtils.getParentDir(toKeyName);\n+\n+    OzoneFileStatus toKeyParentDirStatus = getOMKeyInfoIfExists(metaMgr,\n+            volumeName, bucketName, toKeyParentDir, 0);\n+    // check if the immediate parent exists\n+    if (toKeyParentDirStatus == null || toKeyParentDirStatus.isFile()) {\n+      throw new OMException(String.format(", "originalCommit": "86647aab902ab199236e7cea22a553eae6e26998", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwNzU2Ng==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523107566", "bodyText": "Sure, I will check and make proper error message to differentiate both cases.", "author": "rakeshadr", "createdAt": "2020-11-13T17:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNzk3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6cbffbae9349c7481e8e9aeeebff0d147be61819", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java\nindex f13d1260e4..9ef924e6d3 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java\n\n@@ -726,6 +726,7 @@ public static OmDirectoryInfo getDirectoryInfo(OmKeyInfo keyInfo){\n    *\n    * @param fromKeyName source path\n    * @param toKeyName   destination path\n+   * @param isDir       true represents a directory type otw a file type\n    * @throws OMException if the dest dir is a sub-dir of source dir.\n    */\n   public static void verifyToDirIsASubDirOfFromDirectory(String fromKeyName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODg4OQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522508889", "bodyText": "Minor: isDir is missing in javaDoc", "author": "bharatviswa504", "createdAt": "2020-11-12T23:43:08Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -696,4 +697,91 @@ public static String getAbsolutePath(String prefixName, String fileName) {\n     }\n     return prefixName.concat(OzoneConsts.OZONE_URI_DELIMITER).concat(fileName);\n   }\n+\n+  /**\n+   * Build DirectoryInfo from OmKeyInfo.\n+   *\n+   * @param keyInfo omKeyInfo\n+   * @return omDirectoryInfo object\n+   */\n+  public static OmDirectoryInfo getDirectoryInfo(OmKeyInfo keyInfo){\n+    OmDirectoryInfo.Builder builder = new OmDirectoryInfo.Builder();\n+    builder.setParentObjectID(keyInfo.getParentObjectID());\n+    builder.setAcls(keyInfo.getAcls());\n+    builder.addAllMetadata(keyInfo.getMetadata());\n+    builder.setCreationTime(keyInfo.getCreationTime());\n+    builder.setModificationTime(keyInfo.getModificationTime());\n+    builder.setObjectID(keyInfo.getObjectID());\n+    builder.setUpdateID(keyInfo.getUpdateID());\n+    builder.setName(OzoneFSUtils.getFileName(keyInfo.getKeyName()));\n+    return builder.build();\n+  }\n+\n+  /**\n+   * Verify that the given toKey directory is a sub directory of fromKey\n+   * directory.\n+   * <p>\n+   * For example, special case of renaming a directory to its own\n+   * sub-directory is not allowed.\n+   *\n+   * @param fromKeyName source path\n+   * @param toKeyName   destination path\n+   * @throws OMException if the dest dir is a sub-dir of source dir.", "originalCommit": "86647aab902ab199236e7cea22a553eae6e26998", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEwODk3MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523108971", "bodyText": "Yes, will add it", "author": "rakeshadr", "createdAt": "2020-11-13T17:28:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwODg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6cbffbae9349c7481e8e9aeeebff0d147be61819", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java\nindex f13d1260e4..9ef924e6d3 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java\n\n@@ -726,6 +726,7 @@ public static OmDirectoryInfo getDirectoryInfo(OmKeyInfo keyInfo){\n    *\n    * @param fromKeyName source path\n    * @param toKeyName   destination path\n+   * @param isDir       true represents a directory type otw a file type\n    * @throws OMException if the dest dir is a sub-dir of source dir.\n    */\n   public static void verifyToDirIsASubDirOfFromDirectory(String fromKeyName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNTMyOA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522515328", "bodyText": "General mv supports it,\n$ mv /tmp/f1 /Users/bviswanadham/f1\nIs this semantics of rename API in Fs?", "author": "bharatviswa504", "createdAt": "2020-11-12T23:54:22Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if fromKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // case-1) fromKeyName should exist, otw throws exception\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source existed\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // case-2) Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+\n+      // Check if toKey exists.\n+      if(toKeyFileStatus != null) {\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-4) If dst is a directory then rename source as sub-path of it\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // case-5) If new destin '/dst/source' exists then throws exception\n+            throw new OMException(String.format(\n+                    \"Failed to rename %s to %s, file already exists or not \" +\n+                            \"empty!\", fromKeyName, newToKeyName),\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+\n+          omClientResponse = renameKey(toKeyValue.getObjectID(), trxnLogIndex,\n+                  fromKeyValue, isRenameDirectory, newToKeyName,\n+                  keyArgs.getModificationTime(), omResponse, ozoneManager);\n+          result = Result.SUCCESS;\n+        } else {\n+          // case-6) If destination is a file type and if exists then throws", "originalCommit": "86647aab902ab199236e7cea22a553eae6e26998", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUyMTg1MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522521851", "bodyText": "Okay reading more I see FS As RenameOptions only when OverWrite then it will do.\nWith out any rename options, we fail if dest exists.\nCorrect me if I am missing something here.", "author": "bharatviswa504", "createdAt": "2020-11-13T00:14:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNTMyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExODkzNA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523118934", "bodyText": "Yes, if the destin is a file and exists then it will throw error.", "author": "rakeshadr", "createdAt": "2020-11-13T17:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxNTMyOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxOTk3MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522519971", "bodyText": "Same for directory also.", "author": "bharatviswa504", "createdAt": "2020-11-13T00:08:58Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequestV1.java", "diffHunk": "@@ -0,0 +1,292 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.file.OMFileRequest;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyRenameResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles rename key request layout version V1.\n+ */\n+public class OMKeyRenameRequestV1 extends OMKeyRenameRequest {\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(OMKeyRenameRequestV1.class);\n+\n+  public OMKeyRenameRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    RenameKeyRequest renameKeyRequest = getOmRequest().getRenameKeyRequest();\n+    KeyArgs keyArgs = renameKeyRequest.getKeyArgs();\n+    Map<String, String> auditMap = buildAuditMap(keyArgs, renameKeyRequest);\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String fromKeyName = keyArgs.getKeyName();\n+    String toKeyName = renameKeyRequest.getToKeyName();\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyRenames();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+            getOmRequest());\n+\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    IOException exception = null;\n+    OmKeyInfo fromKeyValue;\n+    String fromKey = null;\n+    Result result;\n+    try {\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+                OMException.ResultCodes.INVALID_KEY_NAME);\n+      }\n+\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+              IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+              volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if fromKey exists\n+      OzoneFileStatus fromKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager, volumeName,\n+                      bucketName, fromKeyName, 0);\n+      // case-1) fromKeyName should exist, otw throws exception\n+      if (fromKeyFileStatus == null) {\n+        // TODO: Add support for renaming open key\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      }\n+\n+      // source existed\n+      fromKeyValue = fromKeyFileStatus.getKeyInfo();\n+      boolean isRenameDirectory = fromKeyFileStatus.isDirectory();\n+\n+      // case-2) Cannot rename a directory to its own subdirectory\n+      OMFileRequest.verifyToDirIsASubDirOfFromDirectory(fromKeyName,\n+              toKeyName, fromKeyFileStatus.isDirectory());\n+\n+      OzoneFileStatus toKeyFileStatus =\n+              OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                      volumeName, bucketName, toKeyName, 0);\n+\n+      // Check if toKey exists.\n+      if(toKeyFileStatus != null) {\n+        // Destination exists and following are different cases:\n+        OmKeyInfo toKeyValue = toKeyFileStatus.getKeyInfo();\n+\n+        if (fromKeyValue.getKeyName().equals(toKeyValue.getKeyName())) {\n+          // case-3) If src == destin then check source and destin of same type\n+          // (a) If dst is a file then return true.\n+          // (b) Otherwise throws exception.\n+          // TODO: Discuss do we need to throw exception for file as well.\n+          if (toKeyFileStatus.isFile()) {\n+            result = Result.SUCCESS;\n+          } else {\n+            throw new OMException(\"Key already exists \" + toKeyName,\n+                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          }\n+        } else if (toKeyFileStatus.isDirectory()) {\n+          // case-4) If dst is a directory then rename source as sub-path of it\n+          // For example: rename /source to /dst will lead to /dst/source\n+          String fromFileName = OzoneFSUtils.getFileName(fromKeyName);\n+          String newToKeyName = OzoneFSUtils.appendFileNameToKeyPath(toKeyName,\n+                  fromFileName);\n+          OzoneFileStatus newToOzoneFileStatus =\n+                  OMFileRequest.getOMKeyInfoIfExists(omMetadataManager,\n+                          volumeName, bucketName, newToKeyName, 0);\n+\n+          if (newToOzoneFileStatus != null) {\n+            // case-5) If new destin '/dst/source' exists then throws exception", "originalCommit": "86647aab902ab199236e7cea22a553eae6e26998", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExOTI4Nw==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523119287", "bodyText": "yes. If new destin '/dst/source' exists then throws exception.", "author": "rakeshadr", "createdAt": "2020-11-13T17:42:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUxOTk3MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzMDg1NA==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r522530854", "bodyText": "Minor: Test is doing different, comment says different", "author": "bharatviswa504", "createdAt": "2020-11-13T00:42:42Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java", "diffHunk": "@@ -260,6 +260,160 @@ private void testListFilesRecursive() throws Exception {\n             expectedFilesCount, actualCount);\n   }\n \n+  /**\n+   * Case-1) fromKeyName should exist, otw throws exception.\n+   */\n+  protected void testRenameWithNonExistentSource() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final String dir2 = root + \"/dir2\";\n+    final Path source = new Path(fs.getUri().toString() + dir1);\n+    final Path destin = new Path(fs.getUri().toString() + dir2);\n+\n+    // creates destin\n+    fs.mkdirs(destin);\n+    LOG.info(\"Created destin dir: {}\", destin);\n+\n+    LOG.info(\"Rename op-> source:{} to destin:{}}\", source, destin);\n+    try {\n+      fs.rename(source, destin);\n+      Assert.fail(\"Should throw exception : Source doesn't exist!\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_NOT_FOUND);\n+    }\n+  }\n+\n+  /**\n+   * Case-2) Cannot rename a directory to its own subdirectory.\n+   */\n+  protected void testRenameDirToItsOwnSubDir() throws Exception {\n+    final String root = \"/root\";\n+    final String dir1 = root + \"/dir1\";\n+    final Path dir1Path = new Path(fs.getUri().toString() + dir1);\n+    // Add a sub-dir1 to the directory to be moved.\n+    final Path subDir1 = new Path(dir1Path, \"sub_dir1\");\n+    fs.mkdirs(subDir1);\n+    LOG.info(\"Created dir1 {}\", subDir1);\n+\n+    final Path sourceRoot = new Path(fs.getUri().toString() + root);\n+    LOG.info(\"Rename op-> source:{} to destin:{}\", sourceRoot, subDir1);\n+    try {\n+      fs.rename(sourceRoot, subDir1);\n+      Assert.fail(\"Should throw exception : Cannot rename a directory to\" +\n+              \" its own subdirectory\");\n+    } catch (OMException ome) {\n+      // expected\n+      assertEquals(ome.getResult(), OMException.ResultCodes.KEY_RENAME_ERROR);\n+    }\n+  }\n+\n+  /**\n+   * Case-5) If new destin '/dst/source' exists then throws exception.\n+   * If destination is a directory then rename source as sub-path of it.\n+   * <p>\n+   * For example: rename /a to /b will lead to /b/a. This new path should\n+   * not exist.\n+   */\n+  protected void testRenameToNewSubDirShouldNotExist() throws Exception {\n+    // Case-5.a) Rename directory from /a to /b.\n+    // created /a\n+    final Path aSourcePath = new Path(fs.getUri().toString() + \"/a\");\n+    fs.mkdirs(aSourcePath);\n+\n+    // created /b\n+    final Path bDestinPath = new Path(fs.getUri().toString() + \"/b\");\n+    fs.mkdirs(bDestinPath);\n+\n+    // Add a sub-directory '/a/c' to '/a'. This is to verify that after", "originalCommit": "86647aab902ab199236e7cea22a553eae6e26998", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0Mzc0MQ==", "url": "https://github.com/apache/ozone/pull/1557#discussion_r523143741", "bodyText": "oops, its copy paste issue. Will correct it.", "author": "rakeshadr", "createdAt": "2020-11-13T18:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUzMDg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "6cbffbae9349c7481e8e9aeeebff0d147be61819", "chunk": "diff --git a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\nindex c4849ce813..a31ef502b8 100644\n--- a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\n+++ b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystemV1.java\n\n@@ -325,8 +325,8 @@ protected void testRenameToNewSubDirShouldNotExist() throws Exception {\n     final Path bDestinPath = new Path(fs.getUri().toString() + \"/b\");\n     fs.mkdirs(bDestinPath);\n \n-    // Add a sub-directory '/a/c' to '/a'. This is to verify that after\n-    // rename sub-directory also be moved.\n+    // Add a sub-directory '/b/a' to '/b'. This is to verify that rename\n+    // throws exception as new destin /b/a already exists.\n     final Path baPath = new Path(fs.getUri().toString() + \"/b/a\");\n     fs.mkdirs(baPath);\n \n"}}, {"oid": "6cbffbae9349c7481e8e9aeeebff0d147be61819", "url": "https://github.com/apache/ozone/commit/6cbffbae9349c7481e8e9aeeebff0d147be61819", "message": "Fixed review comments", "committedDate": "2020-11-13T18:51:17Z", "type": "commit"}, {"oid": "e0dee8edda7c57113eba4b15f31afe1814dcd7a5", "url": "https://github.com/apache/ozone/commit/e0dee8edda7c57113eba4b15f31afe1814dcd7a5", "message": "Fixed NPE and removed duplciate entries in TableCache during listStatus", "committedDate": "2020-11-19T07:46:26Z", "type": "commit"}, {"oid": "3b78899f274d2a5a7e1708d5cf44912e6d556581", "url": "https://github.com/apache/ozone/commit/3b78899f274d2a5a7e1708d5cf44912e6d556581", "message": "trigger new CI check", "committedDate": "2020-11-19T08:49:11Z", "type": "commit"}, {"oid": "d6283887ba48329a903961e67a9f875532b220c2", "url": "https://github.com/apache/ozone/commit/d6283887ba48329a903961e67a9f875532b220c2", "message": "trigger new CI check", "committedDate": "2020-11-19T10:19:46Z", "type": "commit"}, {"oid": "045e3a0d0176bc008836230fbc4aa06d028f7ca9", "url": "https://github.com/apache/ozone/commit/045e3a0d0176bc008836230fbc4aa06d028f7ca9", "message": "trigger new CI check", "committedDate": "2020-11-19T13:11:55Z", "type": "commit"}]}