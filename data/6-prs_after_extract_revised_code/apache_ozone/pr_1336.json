{"pr_number": 1336, "pr_title": "HDDS-4119. Improve performance of the BufferPool management of Ozone client", "pr_createdAt": "2020-08-17T20:05:05Z", "pr_url": "https://github.com/apache/ozone/pull/1336", "timeline": [{"oid": "16347b78c41de982d81a0876fb12ae730f19bdda", "url": "https://github.com/apache/ozone/commit/16347b78c41de982d81a0876fb12ae730f19bdda", "message": "teragenfix", "committedDate": "2020-08-13T08:36:45Z", "type": "commit"}, {"oid": "61a8e6a48f4d04d0c23bf1b28a93ece33e9e9929", "url": "https://github.com/apache/ozone/commit/61a8e6a48f4d04d0c23bf1b28a93ece33e9e9929", "message": "revert genesis changes", "committedDate": "2020-08-13T08:38:54Z", "type": "commit"}, {"oid": "2e32191450c90f533e2d96b98f326f4d70bbafcd", "url": "https://github.com/apache/ozone/commit/2e32191450c90f533e2d96b98f326f4d70bbafcd", "message": "cleanup patch", "committedDate": "2020-08-13T09:50:02Z", "type": "commit"}, {"oid": "962cfd52c79f418d5fdf0ab92c2d8305fce5fe19", "url": "https://github.com/apache/ozone/commit/962cfd52c79f418d5fdf0ab92c2d8305fce5fe19", "message": "Cleanup tests and block output stream", "committedDate": "2020-08-13T10:26:25Z", "type": "commit"}, {"oid": "d4456c00dc085284a80341d298a41496179af3e7", "url": "https://github.com/apache/ozone/commit/d4456c00dc085284a80341d298a41496179af3e7", "message": "fix buffer pool allocation", "committedDate": "2020-08-13T12:17:35Z", "type": "commit"}, {"oid": "1c4f272e9e68a77aab4a60e44231af5e4ca184a3", "url": "https://github.com/apache/ozone/commit/1c4f272e9e68a77aab4a60e44231af5e4ca184a3", "message": "unit test fix", "committedDate": "2020-08-13T13:58:21Z", "type": "commit"}, {"oid": "65a542ffef1a78e64bf19a50a8dcc99f9a4eaf16", "url": "https://github.com/apache/ozone/commit/65a542ffef1a78e64bf19a50a8dcc99f9a4eaf16", "message": "additional debug log", "committedDate": "2020-08-13T15:29:32Z", "type": "commit"}, {"oid": "256db2a7426f6d5c3e08ef7b1c4358cdca30efa5", "url": "https://github.com/apache/ozone/commit/256db2a7426f6d5c3e08ef7b1c4358cdca30efa5", "message": "fix write(byte) with the help of Lokesh", "committedDate": "2020-08-14T07:40:51Z", "type": "commit"}, {"oid": "118d8ce41e65ed9947108abce7ba3d2a77bd4a5a", "url": "https://github.com/apache/ozone/commit/118d8ce41e65ed9947108abce7ba3d2a77bd4a5a", "message": "Additional fixes from Lokesh", "committedDate": "2020-08-15T05:56:25Z", "type": "commit"}, {"oid": "514f7110c09defd3cb482b6cba99665acc0a1ccd", "url": "https://github.com/apache/ozone/commit/514f7110c09defd3cb482b6cba99665acc0a1ccd", "message": "rat and checkstyle fixes", "committedDate": "2020-08-17T10:08:50Z", "type": "commit"}, {"oid": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "url": "https://github.com/apache/ozone/commit/dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "message": "checkstyle fixes", "committedDate": "2020-08-17T10:18:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzMTI4OQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475431289", "bodyText": "Can you please extract these 2 lines to a separate method (and replace other 2 duplicate fragments, too)?", "author": "adoroszlai", "createdAt": "2020-08-24T08:39:45Z", "path": "hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java", "diffHunk": "@@ -154,6 +159,16 @@ public BlockOutputStream(BlockID blockID,\n     this.bufferPool = bufferPool;\n     this.bytesPerChecksum = bytesPerChecksum;\n \n+    //number of buffers used before doing a flush\n+    currentBuffer = bufferPool.getCurrentBuffer();\n+    currentBufferRemaining =\n+        currentBuffer != null ? currentBuffer.remaining() : 0;", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "chunk": "diff --git a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\nindex a0efa75b5..a3548c5d2 100644\n--- a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n+++ b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n\n@@ -160,9 +160,7 @@ public BlockOutputStream(BlockID blockID,\n     this.bytesPerChecksum = bytesPerChecksum;\n \n     //number of buffers used before doing a flush\n-    currentBuffer = bufferPool.getCurrentBuffer();\n-    currentBufferRemaining =\n-        currentBuffer != null ? currentBuffer.remaining() : 0;\n+    refreshCurrentBuffer(bufferPool);\n     flushPeriod = (int) (streamBufferFlushSize / streamBufferSize);\n \n     Preconditions\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQzOTQzMg==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475439432", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return put(buf, 0, 1);  }\n          \n          \n            \n                return put(buf, 0, 1);\n          \n          \n            \n              }", "author": "adoroszlai", "createdAt": "2020-08-24T08:53:37Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java", "diffHunk": "@@ -88,6 +86,12 @@ default ChunkBuffer put(byte[] b) {\n     return put(ByteBuffer.wrap(b));\n   }\n \n+  /** Similar to {@link ByteBuffer#put(byte[])}. */\n+  default ChunkBuffer put(byte b) {\n+    byte[] buf = new byte[1];\n+    buf[0] = (byte) b;\n+    return put(buf, 0, 1);  }", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "chunk": "diff --git a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java\nindex 9f7a01383..937ba5915 100644\n--- a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java\n+++ b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java\n\n@@ -90,7 +90,8 @@ default ChunkBuffer put(byte[] b) {\n   default ChunkBuffer put(byte b) {\n     byte[] buf = new byte[1];\n     buf[0] = (byte) b;\n-    return put(buf, 0, 1);  }\n+    return put(buf, 0, 1);\n+  }\n \n   /** Similar to {@link ByteBuffer#put(byte[], int, int)}. */\n   default ChunkBuffer put(byte[] b, int offset, int length) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MDUzNw==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475440537", "bodyText": "\ud83c\udded\ud83c\uddfa", "author": "adoroszlai", "createdAt": "2020-08-24T08:55:31Z", "path": "hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.storage;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.hadoop.hdds.client.BlockID;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ChecksumType;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerCommandRequestProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerCommandResponseProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.GetCommittedBlockLengthResponseProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.PutBlockResponseProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.Result;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.Type;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationFactor;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationType;\n+import org.apache.hadoop.hdds.scm.XceiverClientManager;\n+import org.apache.hadoop.hdds.scm.XceiverClientReply;\n+import org.apache.hadoop.hdds.scm.XceiverClientSpi;\n+import org.apache.hadoop.hdds.scm.pipeline.Pipeline;\n+import org.apache.hadoop.hdds.scm.pipeline.Pipeline.Builder;\n+import org.apache.hadoop.hdds.scm.pipeline.Pipeline.PipelineState;\n+import org.apache.hadoop.hdds.scm.pipeline.PipelineID;\n+\n+import org.apache.ratis.thirdparty.com.google.protobuf.ByteString;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+/**\n+ * UNIT test for BlockOutputStream.\n+ * <p>\n+ * Compares bytes written to the stream and received in the ChunkWriteRequests.\n+ */\n+public class TestBlockOutputStreamCorrectness {\n+\n+  private static final long SEED = 18480315L;", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "chunk": "diff --git a/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java b/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java\nindex 3af380054..4919cdf2d 100644\n--- a/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java\n+++ b/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java\n\n@@ -19,8 +19,6 @@\n package org.apache.hadoop.hdds.scm.storage;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.Random;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0MzEyMg==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475443122", "bodyText": "Can we move this logic to MockPipeline for reuse?", "author": "adoroszlai", "createdAt": "2020-08-24T08:59:57Z", "path": "hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hdds.scm.storage;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.apache.hadoop.hdds.client.BlockID;\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ChecksumType;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerCommandRequestProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.ContainerCommandResponseProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.GetCommittedBlockLengthResponseProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.PutBlockResponseProto;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.Result;\n+import org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos.Type;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationFactor;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos.ReplicationType;\n+import org.apache.hadoop.hdds.scm.XceiverClientManager;\n+import org.apache.hadoop.hdds.scm.XceiverClientReply;\n+import org.apache.hadoop.hdds.scm.XceiverClientSpi;\n+import org.apache.hadoop.hdds.scm.pipeline.Pipeline;\n+import org.apache.hadoop.hdds.scm.pipeline.Pipeline.Builder;\n+import org.apache.hadoop.hdds.scm.pipeline.Pipeline.PipelineState;\n+import org.apache.hadoop.hdds.scm.pipeline.PipelineID;\n+\n+import org.apache.ratis.thirdparty.com.google.protobuf.ByteString;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+/**\n+ * UNIT test for BlockOutputStream.\n+ * <p>\n+ * Compares bytes written to the stream and received in the ChunkWriteRequests.\n+ */\n+public class TestBlockOutputStreamCorrectness {\n+\n+  private static final long SEED = 18480315L;\n+\n+  private int writeUnitSize = 1;\n+\n+  @Test\n+  public void test() throws IOException {\n+\n+    final BufferPool bufferPool = new BufferPool(4 * 1024 * 1024, 32 / 4);\n+\n+    for (int block = 0; block < 10; block++) {\n+      BlockOutputStream outputStream =\n+          createBlockOutputStream(bufferPool);\n+\n+      Random random = new Random(SEED);\n+\n+      int max = 256 * 1024 * 1024 / writeUnitSize;\n+\n+      byte[] writeBuffer = new byte[writeUnitSize];\n+      for (int t = 0; t < max; t++) {\n+        if (writeUnitSize > 1) {\n+          for (int i = 0; i < writeBuffer.length; i++) {\n+            writeBuffer[i] = (byte) random.nextInt();\n+          }\n+          outputStream.write(writeBuffer, 0, writeBuffer.length);\n+        } else {\n+          outputStream.write((byte) random.nextInt());\n+        }\n+      }\n+      outputStream.close();\n+    }\n+  }\n+\n+  @NotNull\n+  private BlockOutputStream createBlockOutputStream(BufferPool bufferPool)\n+      throws IOException {\n+    List<DatanodeDetails> nodes = new ArrayList<>();\n+    nodes.add(MockDatanodeDetails.randomDatanodeDetails());\n+    nodes.add(MockDatanodeDetails.randomDatanodeDetails());\n+    nodes.add(MockDatanodeDetails.randomDatanodeDetails());\n+\n+    final Pipeline pipeline = new Builder()\n+        .setFactor(ReplicationFactor.THREE)\n+        .setType(ReplicationType.RATIS)\n+        .setState(PipelineState.OPEN)\n+        .setId(PipelineID.randomId())\n+        .setNodes(nodes)\n+        .build();", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "chunk": "diff --git a/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java b/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java\nindex 3af380054..4919cdf2d 100644\n--- a/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java\n+++ b/hadoop-hdds/client/src/test/java/org/apache/hadoop/hdds/scm/storage/TestBlockOutputStreamCorrectness.java\n\n@@ -19,8 +19,6 @@\n package org.apache.hadoop.hdds.scm.storage;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.List;\n import java.util.Random;\n import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ExecutionException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475447115", "bodyText": "Can you please also change TestChunkBuffer#runTestIncrementalChunkBuffer to explicitly create IncrementalChunkBuffer?  Currently it uses this factory method, and so with this patch it really tests ChunkBufferImplWithByteBuffer.", "author": "adoroszlai", "createdAt": "2020-08-24T09:05:25Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java", "diffHunk": "@@ -44,9 +45,6 @@ static ChunkBuffer allocate(int capacity) {\n    *   When increment <= 0, entire buffer is allocated in the beginning.\n    */\n   static ChunkBuffer allocate(int capacity, int increment) {\n-    if (increment > 0 && increment < capacity) {\n-      return new IncrementalChunkBuffer(capacity, increment, false);", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIyMjgwMQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r477222801", "bodyText": "Wow, nice catch.", "author": "elek", "createdAt": "2020-08-26T11:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIyNjc0MQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r477226741", "bodyText": "IncrementalChunkBuffer was added to address cases where ozone client were running into OOM with keys less than chunk size , as without this, the smallest buffer which will be allocated will always be equal to the chunk size(4MB by default).\nPlease see https://issues.apache.org/jira/browse/HDDS-2331 for more details.\nI would prefer to not remove this logic of incremental chunk buffer and may be hide it within an internal config.\n@elek , how much of perf gain we will have of we still do incremental buffer allocation?", "author": "bshashikant", "createdAt": "2020-08-26T11:23:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1MzQyOQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r478353429", "bodyText": "@elek , how much of perf gain we will have of we still do incremental buffer allocation?\n\nI can repeat the test to get exact numbers, but I couldn't get good performance without removing the incremental buffer. You can easily test it with the new unit test, if you write a lot of data with byte=1, it's still low.\n\nIncrementalChunkBuffer was added to address cases where ozone client were running into OOM with keys less than chunk size , as without this, the smallest buffer which will be allocated will always be equal to the chunk size(4MB by default).\n\nI think it's a valid (and important question), but as far as I see it's safe to remove the IncrementalByteBuffer. As far as I see the situation is slightly different since HDDS-2331. I tried to test this patch with the commands from the HDDS-2331:\nozone freon rk --numOfThreads 1 --numOfVolumes 1 --numOfBuckets 1 --replicationType RATIS --factor ONE --keySize 1048576 --numOfKeys 5120 --bufferSize 65536\n\nI couldn't reproduce the OOM.\nBased on my understanding:\n\nWe already have an increment by the ByteBuffer but size of the increment is 4MB (adding one more buffer when required)\n4MB seems to be acceptable even with many clients in the same JVM, especially if we can have acceptable performance.\n\nLet's say I have 100 Ozone clients (in the same JVM!!!) which write 1kb keys. I will have (4MB-1kb)  *100 overhead without the IncrementalChunkBuffer (as far as I understood). It's still <400MB in exchange for 30-100% performance gain. Sounds like a good deal.\nBut let me know if you see any problems here.\n\nLet's say the 400MB overhead is unacceptable (or my calculation was wrong and the overhead is higher ;-) )\n\nAs far as I see the BufferPool is created per key. I think it would be possible to set the buffer size to min(keySize, bufferSize). With this approach the first and only buffer of the BufferPool can have exactly the required size (which covers all the where the key size is < 4MB)", "author": "elek", "createdAt": "2020-08-27T11:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MjU3OQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r478372579", "bodyText": "the situation is slightly different since HDDS-2331\n\nNote that default chunk size was 16MB at the time when HDDS-2331 was reported.  The benefit from IncrementalChunkBuffer is less now with 4MB default size.", "author": "adoroszlai", "createdAt": "2020-08-27T12:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4NTYzOQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r480085639", "bodyText": "I would suggest separating the two parts of the PR:\n\nreorganize the position calculation and allocation\nremove the usage of the Incremental buffer\n\nWhile we can continue to searching for the safest method to do 2 (or do something instead of the removal), we can merge the first part where we already have an agreement.", "author": "elek", "createdAt": "2020-08-31T12:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE3OTcyNA==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r481179724", "bodyText": "See #1374 about the 2nd.", "author": "elek", "createdAt": "2020-09-01T14:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NzExNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7bf5b29acf7e65239749dcf6cf965f6f0e7e0028", "chunk": "diff --git a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java\nindex 9f7a01383..65f8a895a 100644\n--- a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java\n+++ b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/common/ChunkBuffer.java\n\n@@ -45,6 +45,9 @@ static ChunkBuffer allocate(int capacity) {\n    *   When increment <= 0, entire buffer is allocated in the beginning.\n    */\n   static ChunkBuffer allocate(int capacity, int increment) {\n+    if (increment > 0 && increment < capacity) {\n+      return new IncrementalChunkBuffer(capacity, increment, false);\n+    }\n     return new ChunkBufferImplWithByteBuffer(ByteBuffer.allocate(capacity));\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTIyMQ==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475455221", "bodyText": "For consistency, I think we should move the condition to allocateNewBuffer and rename it to allocateNewBufferIfNeeded.", "author": "adoroszlai", "createdAt": "2020-08-24T09:19:52Z", "path": "hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java", "diffHunk": "@@ -209,9 +224,16 @@ public IOException getIoException() {\n   @Override\n   public void write(int b) throws IOException {\n     checkOpen();\n-    byte[] buf = new byte[1];\n-    buf[0] = (byte) b;\n-    write(buf, 0, 1);\n+    if (currentBufferRemaining == 0) {\n+      allocateNewBuffer();\n+    }", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9ab01a7753b75009997cc33a338bbef282230687", "chunk": "diff --git a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\nindex a0efa75b5..0fa8f0cbd 100644\n--- a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n+++ b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n\n@@ -224,16 +227,18 @@ public IOException getIoException() {\n   @Override\n   public void write(int b) throws IOException {\n     checkOpen();\n-    if (currentBufferRemaining == 0) {\n-      allocateNewBuffer();\n-    }\n+    allocateNewBufferIfNeeded();\n     currentBuffer.put((byte) b);\n     currentBufferRemaining--;\n+    writeChunkIfNeeded();\n+    writtenDataLength++;\n+    doFlushOrWatchIfNeeded();\n+  }\n+\n+  private void writeChunkIfNeeded() throws IOException {\n     if (currentBufferRemaining == 0) {\n       writeChunk(currentBuffer);\n     }\n-    writtenDataLength++;\n-    doFlushOrWatchIfNeeded();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTUzMg==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475455532", "bodyText": "For consistency, I think we should move the condition to a new method writeChunkIfNeeded.", "author": "adoroszlai", "createdAt": "2020-08-24T09:20:20Z", "path": "hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java", "diffHunk": "@@ -209,9 +224,16 @@ public IOException getIoException() {\n   @Override\n   public void write(int b) throws IOException {\n     checkOpen();\n-    byte[] buf = new byte[1];\n-    buf[0] = (byte) b;\n-    write(buf, 0, 1);\n+    if (currentBufferRemaining == 0) {\n+      allocateNewBuffer();\n+    }\n+    currentBuffer.put((byte) b);\n+    currentBufferRemaining--;\n+    if (currentBufferRemaining == 0) {\n+      writeChunk(currentBuffer);\n+    }", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIyMzk0MA==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r477223940", "bodyText": "Not sure if I understood. Why is it more consistent to move this 3 lines to a separated method?", "author": "elek", "createdAt": "2020-08-26T11:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI1MzM5NA==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r477253394", "bodyText": "checkOpen() and doFlushOrWatchIfNeeded() calls are both concise.  I think moving the conditions for these two other calls would help make the level of abstraction in write() more similar.  But it's optional.", "author": "adoroszlai", "createdAt": "2020-08-26T12:15:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1ODk2Mw==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r478358963", "bodyText": "Ok, I think I got the idea, but please double-check my commit as I am not sure ;-)\n9ab01a7", "author": "elek", "createdAt": "2020-08-27T11:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3NTA1NA==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r478375054", "bodyText": "Thanks for the update.", "author": "adoroszlai", "createdAt": "2020-08-27T12:19:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTUzMg=="}], "type": "inlineReview", "revised_code": {"commit": "9ab01a7753b75009997cc33a338bbef282230687", "chunk": "diff --git a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\nindex a0efa75b5..0fa8f0cbd 100644\n--- a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n+++ b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n\n@@ -224,16 +227,18 @@ public IOException getIoException() {\n   @Override\n   public void write(int b) throws IOException {\n     checkOpen();\n-    if (currentBufferRemaining == 0) {\n-      allocateNewBuffer();\n-    }\n+    allocateNewBufferIfNeeded();\n     currentBuffer.put((byte) b);\n     currentBufferRemaining--;\n+    writeChunkIfNeeded();\n+    writtenDataLength++;\n+    doFlushOrWatchIfNeeded();\n+  }\n+\n+  private void writeChunkIfNeeded() throws IOException {\n     if (currentBufferRemaining == 0) {\n       writeChunk(currentBuffer);\n     }\n-    writtenDataLength++;\n-    doFlushOrWatchIfNeeded();\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ2NjUyNg==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r475466526", "bodyText": "Should we also update currentBufferRemaining?", "author": "adoroszlai", "createdAt": "2020-08-24T09:31:27Z", "path": "hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java", "diffHunk": "@@ -481,7 +516,7 @@ private void handleFlush(boolean close)\n     checkOpen();\n     // flush the last chunk data residing on the currentBuffer\n     if (totalDataFlushedLength < writtenDataLength) {\n-      final ChunkBuffer currentBuffer = bufferPool.getCurrentBuffer();\n+      currentBuffer = bufferPool.getCurrentBuffer();", "originalCommit": "dd99deb1ae7b7a8bb5eed17681c473bdfb410f30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIyNDU5Ng==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r477224596", "bodyText": "Yeah, I started to use the newly introduced method which is suggested by the first comment... (update current buffer + remaining)", "author": "elek", "createdAt": "2020-08-26T11:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ2NjUyNg=="}], "type": "inlineReview", "revised_code": {"commit": "a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "chunk": "diff --git a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\nindex a0efa75b5..a3548c5d2 100644\n--- a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n+++ b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n\n@@ -516,7 +516,7 @@ private void handleFlush(boolean close)\n     checkOpen();\n     // flush the last chunk data residing on the currentBuffer\n     if (totalDataFlushedLength < writtenDataLength) {\n-      currentBuffer = bufferPool.getCurrentBuffer();\n+      refreshCurrentBuffer(bufferPool);\n       Preconditions.checkArgument(currentBuffer.position() > 0);\n       if (currentBuffer.hasRemaining()) {\n         writeChunk(currentBuffer);\n"}}, {"oid": "a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "url": "https://github.com/apache/ozone/commit/a2d8fc5dbfebd9b906a756d074ad6795fb5c6d40", "message": "Address review comments", "committedDate": "2020-08-26T11:21:21Z", "type": "commit"}, {"oid": "ad9c07c94ed9ea7139255770125379a65195c933", "url": "https://github.com/apache/ozone/commit/ad9c07c94ed9ea7139255770125379a65195c933", "message": "checkstyle fixes", "committedDate": "2020-08-26T11:31:58Z", "type": "commit"}, {"oid": "9ab01a7753b75009997cc33a338bbef282230687", "url": "https://github.com/apache/ozone/commit/9ab01a7753b75009997cc33a338bbef282230687", "message": "move conditions to the helper methods", "committedDate": "2020-08-27T11:52:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3NDk0NA==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r478374944", "bodyText": "Note the condition is different here, might not be safe to replace with writeChunkIfNeeded().", "author": "adoroszlai", "createdAt": "2020-08-27T12:18:53Z", "path": "hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java", "diffHunk": "@@ -481,11 +514,9 @@ private void handleFlush(boolean close)\n     checkOpen();\n     // flush the last chunk data residing on the currentBuffer\n     if (totalDataFlushedLength < writtenDataLength) {\n-      final ChunkBuffer currentBuffer = bufferPool.getCurrentBuffer();\n+      refreshCurrentBuffer(bufferPool);\n       Preconditions.checkArgument(currentBuffer.position() > 0);\n-      if (currentBuffer.hasRemaining()) {\n-        writeChunk(currentBuffer);", "originalCommit": "9ab01a7753b75009997cc33a338bbef282230687", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg1MDkxMw==", "url": "https://github.com/apache/ozone/pull/1336#discussion_r482850913", "bodyText": "Thanks the help. I fully reverted these lines in #23ba2d1 and build is green again.", "author": "elek", "createdAt": "2020-09-03T09:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3NDk0NA=="}], "type": "inlineReview", "revised_code": {"commit": "40721a1613a70ac41feb8349e6cf46534ff2a7ac", "chunk": "diff --git a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\nindex 0fa8f0cbd..6b6b5e932 100644\n--- a/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n+++ b/hadoop-hdds/client/src/main/java/org/apache/hadoop/hdds/scm/storage/BlockOutputStream.java\n\n@@ -516,7 +516,9 @@ private void handleFlush(boolean close)\n     if (totalDataFlushedLength < writtenDataLength) {\n       refreshCurrentBuffer(bufferPool);\n       Preconditions.checkArgument(currentBuffer.position() > 0);\n-      writeChunkIfNeeded();\n+      if (currentBuffer.hasRemaining()) {\n+        writeChunk(currentBuffer);\n+      }\n       // This can be a partially filled chunk. Since we are flushing the buffer\n       // here, we just limit this buffer to the current position. So that next\n       // write will happen in new buffer\n"}}, {"oid": "40721a1613a70ac41feb8349e6cf46534ff2a7ac", "url": "https://github.com/apache/ozone/commit/40721a1613a70ac41feb8349e6cf46534ff2a7ac", "message": "Revert single writeChunk() call with different condition", "committedDate": "2020-08-27T14:47:19Z", "type": "commit"}, {"oid": "8969b42ab8a2864c3029a01f9847568434c81714", "url": "https://github.com/apache/ozone/commit/8969b42ab8a2864c3029a01f9847568434c81714", "message": "restore orginal writeChunk logic in handleFlush", "committedDate": "2020-08-27T15:03:08Z", "type": "commit"}, {"oid": "7bf5b29acf7e65239749dcf6cf965f6f0e7e0028", "url": "https://github.com/apache/ozone/commit/7bf5b29acf7e65239749dcf6cf965f6f0e7e0028", "message": "Use incremental chunk buffer for time being", "committedDate": "2020-08-31T13:04:32Z", "type": "commit"}, {"oid": "bc5b38b04c52c3369262651d1df3bfc512cdc80e", "url": "https://github.com/apache/ozone/commit/bc5b38b04c52c3369262651d1df3bfc512cdc80e", "message": "Merge remote-tracking branch 'elek/HDDS-4119' into HDDS-4119", "committedDate": "2020-08-31T13:08:12Z", "type": "commit"}, {"oid": "0bce14d3a033b2e4a91980d9a04ab6a1f50615be", "url": "https://github.com/apache/ozone/commit/0bce14d3a033b2e4a91980d9a04ab6a1f50615be", "message": "Merge remote-tracking branch 'origin/master' into HDDS-4119", "committedDate": "2020-09-01T08:39:25Z", "type": "commit"}, {"oid": "c4144cc9bbfe952cd9a86dd980fdeade05e40229", "url": "https://github.com/apache/ozone/commit/c4144cc9bbfe952cd9a86dd980fdeade05e40229", "message": "fix merge problem", "committedDate": "2020-09-01T12:11:41Z", "type": "commit"}, {"oid": "23ba2d1d071942a6adaa92f4ca30b0edfbb1d5b0", "url": "https://github.com/apache/ozone/commit/23ba2d1d071942a6adaa92f4ca30b0edfbb1d5b0", "message": "revert change in retry", "committedDate": "2020-09-02T13:34:09Z", "type": "commit"}]}