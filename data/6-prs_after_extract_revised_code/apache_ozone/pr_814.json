{"pr_number": 814, "pr_title": "HDDS-3286. BasicOzoneFileSystem  support batchDelete.", "pr_createdAt": "2020-04-13T10:07:37Z", "pr_url": "https://github.com/apache/ozone/pull/814", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODE0OA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407558148", "bodyText": "Can you please rephrase java comment conveying the list of keys. How about something like below,\n\"Deletes the given list of keys from the bucket\"", "author": "rakeshadr", "createdAt": "2020-04-13T16:04:45Z", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java", "diffHunk": "@@ -382,11 +382,25 @@ public void deleteKey(String key) throws IOException {\n     proxy.deleteKey(volumeName, name, key);\n   }\n \n+  /**\n+   * Deletes key from the bucket.", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\nindex 2fab87b75f..c3ef2d13dd 100644\n--- a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\n+++ b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\n\n@@ -383,12 +383,12 @@ public void deleteKey(String key) throws IOException {\n   }\n \n   /**\n-   * Deletes key from the bucket.\n+   * Deletes keys from the bucket.\n    * @param keyList List of the key name to be deleted.\n    * @throws IOException\n    */\n-  public void deleteKeyList(List<String> keyList) throws IOException {\n-    proxy.deleteKeyList(volumeName, name, keyList);\n+  public void deleteKeys(List<String> keyList) throws IOException {\n+    proxy.deleteKeys(volumeName, name, keyList);\n   }\n \n   public void renameKey(String fromKeyName, String toKeyName)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU1ODUwMA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407558500", "bodyText": "Please add javadoc.", "author": "rakeshadr", "createdAt": "2020-04-13T16:05:24Z", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java", "diffHunk": "@@ -382,11 +382,25 @@ public void deleteKey(String key) throws IOException {\n     proxy.deleteKey(volumeName, name, key);\n   }\n \n+  /**\n+   * Deletes key from the bucket.\n+   * @param keyList List of the key name to be deleted.\n+   * @throws IOException\n+   */\n+  public void deleteKeyList(List<String> keyList) throws IOException {\n+    proxy.deleteKeyList(volumeName, name, keyList);\n+  }\n+\n   public void renameKey(String fromKeyName, String toKeyName)", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\nindex 2fab87b75f..c3ef2d13dd 100644\n--- a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\n+++ b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\n\n@@ -383,12 +383,12 @@ public void deleteKey(String key) throws IOException {\n   }\n \n   /**\n-   * Deletes key from the bucket.\n+   * Deletes keys from the bucket.\n    * @param keyList List of the key name to be deleted.\n    * @throws IOException\n    */\n-  public void deleteKeyList(List<String> keyList) throws IOException {\n-    proxy.deleteKeyList(volumeName, name, keyList);\n+  public void deleteKeys(List<String> keyList) throws IOException {\n+    proxy.deleteKeys(volumeName, name, keyList);\n   }\n \n   public void renameKey(String fromKeyName, String toKeyName)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MTE2Mg==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407561162", "bodyText": "Can we follow naming convention for the collection APIs?\nHow about something like below. The same comment applicable to delete list api as well.\n#renameKeys\n#deleteKeys", "author": "rakeshadr", "createdAt": "2020-04-13T16:10:23Z", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java", "diffHunk": "@@ -382,11 +382,25 @@ public void deleteKey(String key) throws IOException {\n     proxy.deleteKey(volumeName, name, key);\n   }\n \n+  /**\n+   * Deletes key from the bucket.\n+   * @param keyList List of the key name to be deleted.\n+   * @throws IOException\n+   */\n+  public void deleteKeyList(List<String> keyList) throws IOException {\n+    proxy.deleteKeyList(volumeName, name, keyList);\n+  }\n+\n   public void renameKey(String fromKeyName, String toKeyName)\n       throws IOException {\n     proxy.renameKey(volumeName, name, fromKeyName, toKeyName);\n   }\n \n+  public void renameKey(Map<String, String> keyMap)", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\nindex 2fab87b75f..c3ef2d13dd 100644\n--- a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\n+++ b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java\n\n@@ -383,12 +383,12 @@ public void deleteKey(String key) throws IOException {\n   }\n \n   /**\n-   * Deletes key from the bucket.\n+   * Deletes keys from the bucket.\n    * @param keyList List of the key name to be deleted.\n    * @throws IOException\n    */\n-  public void deleteKeyList(List<String> keyList) throws IOException {\n-    proxy.deleteKeyList(volumeName, name, keyList);\n+  public void deleteKeys(List<String> keyList) throws IOException {\n+    proxy.deleteKeys(volumeName, name, keyList);\n   }\n \n   public void renameKey(String fromKeyName, String toKeyName)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2MzE0MQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407563141", "bodyText": "The above comment naming convention exists here as well. Please take care the same in all applicable places. Thanks!", "author": "rakeshadr", "createdAt": "2020-04-13T16:13:56Z", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java", "diffHunk": "@@ -288,6 +288,17 @@ OzoneInputStream getKey(String volumeName, String bucketName, String keyName)\n   void deleteKey(String volumeName, String bucketName, String keyName)\n       throws IOException;\n \n+  /**\n+   * Deletes key List.\n+   * @param volumeName Name of the Volume\n+   * @param bucketName Name of the Bucket\n+   * @param keyNameList List of the Key\n+   * @throws IOException\n+   */\n+  void deleteKeyList(String volumeName, String bucketName,", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java\nindex d0147e9e2a..872d1f419e 100644\n--- a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java\n+++ b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java\n\n@@ -289,13 +291,13 @@ void deleteKey(String volumeName, String bucketName, String keyName)\n       throws IOException;\n \n   /**\n-   * Deletes key List.\n+   * Deletes keys through the list.\n    * @param volumeName Name of the Volume\n    * @param bucketName Name of the Bucket\n    * @param keyNameList List of the Key\n    * @throws IOException\n    */\n-  void deleteKeyList(String volumeName, String bucketName,\n+  void deleteKeys(String volumeName, String bucketName,\n                      List<String> keyNameList)\n           throws IOException;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2ODk1Mw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407568953", "bodyText": "Do we need String keyName argument ? Can you please incorporate String keyName argument into the keyNameList argument, something similar you have very well refactored for keyNameList.add(keyName); in deleteKey api.", "author": "rakeshadr", "createdAt": "2020-04-13T16:24:50Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java", "diffHunk": "@@ -70,6 +72,8 @@ private OmKeyArgs(String volumeName, String bucketName, String keyName,\n     this.refreshPipeline = refreshPipeline;\n     this.acls = acls;\n     this.sortDatanodesInPipeline = sortDatanode;\n+    this.keyNameList = keyNameList;", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0NzgzOA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r427247838", "bodyText": "Do we need String keyName argument ? Can you please incorporate String keyName argument into the keyNameList argument, something similar you have very well refactored for keyNameList.add(keyName); in deleteKey api.\n\nThe keyName in OmKeyArgs is Shared with other interfaces. Operations like create and list still need to use it.", "author": "captainzmc", "createdAt": "2020-05-19T12:03:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU2ODk1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java\nindex acb67126c2..38bb61f8a4 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java\n+++ b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java\n\n@@ -73,7 +72,6 @@ private OmKeyArgs(String volumeName, String bucketName, String keyName,\n     this.acls = acls;\n     this.sortDatanodesInPipeline = sortDatanode;\n     this.keyNameList = keyNameList;\n-    this.renameKeyMap = renameKeyMap;\n   }\n \n   public boolean getIsMultipartKey() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU3MzQwNA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407573404", "bodyText": "Please correct indentation after == symbol.  if (keyNameList.size() == 0) {", "author": "rakeshadr", "createdAt": "2020-04-13T16:32:43Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -116,51 +119,53 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     boolean acquiredLock = false;\n     OMClientResponse omClientResponse = null;\n     Result result = null;\n+    List<OmKeyInfo> omKeyInfoList= new ArrayList<>();\n     try {\n-      // check Acl\n-      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-\n-      String objectKey = omMetadataManager.getOzoneKey(\n-          volumeName, bucketName, keyName);\n-\n+      if (keyNameList.size() ==0) {", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c927d2b98b663d7c052683b9fd5ea2c416e04933", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex b340e5f911..480e317751 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -110,10 +107,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n \n     Map<String, String> auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n \n-    OMResponse.Builder omResponse = OMResponse.newBuilder()\n-        .setCmdType(Type.DeleteKey)\n-        .setStatus(Status.OK)\n-        .setSuccess(true);\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n     OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n     IOException exception = null;\n     boolean acquiredLock = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MTM3MQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407581371", "bodyText": "What if one of the key not found in the list of keys and assume there are 10keys and the 5th key not found. What is the contract batch api provides executes all or executes till first failure or none of them ?\nPlease consider Check if this transaction is a replay of ratis logs. this validation check also or any other exception. As there is no strict recommendations, I'm keeping this open for discussions:-).", "author": "rakeshadr", "createdAt": "2020-04-13T16:47:36Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -116,51 +119,53 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     boolean acquiredLock = false;\n     OMClientResponse omClientResponse = null;\n     Result result = null;\n+    List<OmKeyInfo> omKeyInfoList= new ArrayList<>();\n     try {\n-      // check Acl\n-      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-\n-      String objectKey = omMetadataManager.getOzoneKey(\n-          volumeName, bucketName, keyName);\n-\n+      if (keyNameList.size() ==0) {\n+        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+      }\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n-\n+              volumeName, bucketName);\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n-\n-      OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n-      if (omKeyInfo == null) {\n-        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+      Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n+      for (String keyName : keyNameList) {\n+        // check Acl\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+                IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+        String objectKey = omMetadataManager.getOzoneKey(\n+                volumeName, bucketName, keyName);\n+        OmKeyInfo omKeyInfo = keyTable.get(objectKey);\n+        if (omKeyInfo == null) {", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIzODI4Mw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r427238283", "bodyText": "What if one of the key not found in the list of keys and assume there are 10keys and the 5th key not found. What is the contract batch api provides executes all or executes till first failure or none of them ?\nPlease consider Check if this transaction is a replay of ratis logs. this validation check also or any other exception. As there is no strict recommendations, I'm keeping this open for discussions:-).\n\nWhen delete multiple keys, such as a directory, FS will get all the keys in this directory first, so at this time the key exists. But if there are two people delete a directory at the same time, this can cause problems, which can also occur when a single key is deleted before.\nSo here we're executing till first failure. Also  If any other error occurs, it will break and throw the exception to the user.", "author": "captainzmc", "createdAt": "2020-05-19T11:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4MTM3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "c927d2b98b663d7c052683b9fd5ea2c416e04933", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex b340e5f911..480e317751 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -110,10 +107,8 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n \n     Map<String, String> auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n \n-    OMResponse.Builder omResponse = OMResponse.newBuilder()\n-        .setCmdType(Type.DeleteKey)\n-        .setStatus(Status.OK)\n-        .setSuccess(true);\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n     OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n     IOException exception = null;\n     boolean acquiredLock = false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU4ODE5OA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407588198", "bodyText": "Above comment is applicable renamekeys as well.\nWhat if one of the key not found in the list of keys and assume there are 10keys and the 5th key not found. What is the contract batch api provides executes all or executes till first failure or none of them ?", "author": "rakeshadr", "createdAt": "2020-04-13T16:59:39Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java", "diffHunk": "@@ -127,112 +131,124 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     OmKeyInfo fromKeyValue = null;\n     String toKey = null, fromKey = null;\n     Result result = null;\n+    List<RenameInfo> renameInfoList = new ArrayList<>();\n     try {\n-      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n-        throw new OMException(\"Key name is empty\",\n-            OMException.ResultCodes.INVALID_KEY_NAME);\n+      if (renameKeyMap.size() == 0) {\n+        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n       }\n-      // check Acls to see if user has access to perform delete operation on\n-      // old key and create operation on new key\n-      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n-          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n-          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n-\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n-\n-      // Validate bucket and volume exists or not.\n-      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n-\n-      // Check if toKey exists\n-      fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-          fromKeyName);\n-      toKey = omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n-      OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n-\n-      if (toKeyValue != null) {\n-\n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n-\n-          // Check if fromKey is still in the DB and created before this\n-          // replay.\n-          // For example, lets say we have the following sequence of\n-          // transactions.\n-          //     Trxn 1 : Create Key1\n-          //     Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n-          // Now if these transactions are replayed:\n-          //     Replay Trxn 1 : Creates Key1 again as Key1 does not exist in DB\n-          //     Replay Trxn 2 : Key2 is not created as it exists in DB and the\n-          //                     request would be deemed a replay. But Key1\n-          //                     is still in the DB and needs to be deleted.\n-          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n-          if (fromKeyValue != null) {\n-            // Check if this replay transaction was after the fromKey was\n-            // created. If so, we have to delete the fromKey.\n-            if (ozoneManager.isRatisEnabled() &&\n-                trxnLogIndex > fromKeyValue.getUpdateID()) {\n-              // Add to cache. Only fromKey should be deleted. ToKey already\n-              // exists in DB as this transaction is a replay.\n-              result = Result.DELETE_FROM_KEY_ONLY;\n-              Table<String, OmKeyInfo> keyTable = omMetadataManager\n-                  .getKeyTable();\n-              keyTable.addCacheEntry(new CacheKey<>(fromKey),\n-                  new CacheValue<>(Optional.absent(), trxnLogIndex));\n+              volumeName, bucketName);\n+      for (Map.Entry<String, String> renameKeyEntry : renameKeyMap.entrySet()) {\n+        String fromKeyName = renameKeyEntry.getKey();", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java\nindex 58b99404f5..d6fd884713 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyRenameRequest.java\n\n@@ -131,124 +127,112 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     OmKeyInfo fromKeyValue = null;\n     String toKey = null, fromKey = null;\n     Result result = null;\n-    List<RenameInfo> renameInfoList = new ArrayList<>();\n     try {\n-      if (renameKeyMap.size() == 0) {\n-        throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+      if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n+        throw new OMException(\"Key name is empty\",\n+            OMException.ResultCodes.INVALID_KEY_NAME);\n       }\n+      // check Acls to see if user has access to perform delete operation on\n+      // old key and create operation on new key\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n+          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-              volumeName, bucketName);\n-      for (Map.Entry<String, String> renameKeyEntry : renameKeyMap.entrySet()) {\n-        String fromKeyName = renameKeyEntry.getKey();\n-        String toKeyName = renameKeyEntry.getValue();\n-\n-        if (toKeyName.length() == 0 || fromKeyName.length() == 0) {\n-          throw new OMException(\"Key name is empty\",\n-                  OMException.ResultCodes.INVALID_KEY_NAME);\n-        }\n+          volumeName, bucketName);\n+\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      // Check if toKey exists\n+      fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+          fromKeyName);\n+      toKey = omMetadataManager.getOzoneKey(volumeName, bucketName, toKeyName);\n+      OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n+\n+      if (toKeyValue != null) {\n+\n+        // Check if this transaction is a replay of ratis logs.\n+        if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n+\n+          // Check if fromKey is still in the DB and created before this\n+          // replay.\n+          // For example, lets say we have the following sequence of\n+          // transactions.\n+          //     Trxn 1 : Create Key1\n+          //     Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n+          // Now if these transactions are replayed:\n+          //     Replay Trxn 1 : Creates Key1 again as Key1 does not exist in DB\n+          //     Replay Trxn 2 : Key2 is not created as it exists in DB and the\n+          //                     request would be deemed a replay. But Key1\n+          //                     is still in the DB and needs to be deleted.\n+          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+          if (fromKeyValue != null) {\n+            // Check if this replay transaction was after the fromKey was\n+            // created. If so, we have to delete the fromKey.\n+            if (ozoneManager.isRatisEnabled() &&\n+                trxnLogIndex > fromKeyValue.getUpdateID()) {\n+              // Add to cache. Only fromKey should be deleted. ToKey already\n+              // exists in DB as this transaction is a replay.\n+              result = Result.DELETE_FROM_KEY_ONLY;\n+              Table<String, OmKeyInfo> keyTable = omMetadataManager\n+                  .getKeyTable();\n+              keyTable.addCacheEntry(new CacheKey<>(fromKey),\n+                  new CacheValue<>(Optional.absent(), trxnLogIndex));\n \n-        // check Acls to see if user has access to perform delete operation on\n-        // old key and create operation on new key\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, fromKeyName,\n-                IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, toKeyName,\n-                IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n-\n-        // Validate bucket and volume exists or not.\n-        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n-\n-        // Check if toKey exists\n-        fromKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-                fromKeyName);\n-        toKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-                toKeyName);\n-        OmKeyInfo toKeyValue = omMetadataManager.getKeyTable().get(toKey);\n-\n-        if (toKeyValue != null) {\n-          // Check if this transaction is a replay of ratis logs.\n-          if (isReplay(ozoneManager, toKeyValue, trxnLogIndex)) {\n-\n-            // Check if fromKey is still in the DB and created before this\n-            // replay.\n-            // For example, lets say we have the following sequence of\n-            // transactions.\n-            //     Trxn 1 : Create Key1\n-            //     Trnx 2 : Rename Key1 to Key2 -> Deletes Key1 and Creates Key2\n-            // Now if these transactions are replayed:\n-            //     Replay Trxn 1 :\n-            // Creates Key1 again as Key1 does not exist in DB\n-            //     Replay Trxn 2 :\n-            // Key2 is not created as it exists in DB and the\n-            //                     request would be deemed a replay. But Key1\n-            //                     is still in the DB and needs to be deleted.\n-            fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n-            if (fromKeyValue != null) {\n-              // Check if this replay transaction was after the fromKey was\n-              // created. If so, we have to delete the fromKey.\n-              if (ozoneManager.isRatisEnabled() &&\n-                      trxnLogIndex > fromKeyValue.getUpdateID()) {\n-                // Add to cache. Only fromKey should be deleted. ToKey already\n-                // exists in DB as this transaction is a replay.\n-                result = Result.DELETE_FROM_KEY_ONLY;\n-                Table<String, OmKeyInfo> keyTable = omMetadataManager\n-                        .getKeyTable();\n-                keyTable.addCacheEntry(new CacheKey<>(fromKey),\n-                        new CacheValue<>(Optional.absent(), trxnLogIndex));\n-                RenameInfo renameInfo = new  RenameInfo(\n-                        fromKeyName, fromKeyValue, null);\n-                renameInfoList.add(renameInfo);\n-              }\n+              omClientResponse = new OMKeyRenameResponse(omResponse\n+                  .setRenameKeyResponse(RenameKeyResponse.newBuilder()).build(),\n+                  fromKeyName, fromKeyValue);\n             }\n+          }\n \n-            if (result == null) {\n-              result = Result.REPLAY;\n-              // If toKey exists and fromKey does not, then no further action is\n-              // required. Return a dummy OMClientResponse.\n-              omClientResponse = new OMKeyRenameResponse(createReplayOMResponse(\n-                      omResponse));\n-            }\n-          } else {\n-            // This transaction is not a replay. toKeyName should not exist\n-            throw new OMException(\"Key already exists \" + toKeyName,\n-                    OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+          if (result == null) {\n+            result = Result.REPLAY;\n+            // If toKey exists and fromKey does not, then no further action is\n+            // required. Return a dummy OMClientResponse.\n+            omClientResponse = new OMKeyRenameResponse(createReplayOMResponse(\n+                omResponse));\n           }\n         } else {\n+          // This transaction is not a replay. toKeyName should not exist\n+          throw new OMException(\"Key already exists \" + toKeyName,\n+              OMException.ResultCodes.KEY_ALREADY_EXISTS);\n+        }\n+      } else {\n \n-          // This transaction is not a replay.\n+        // This transaction is not a replay.\n \n-          // fromKeyName should exist\n-          fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n-          if (fromKeyValue == null) {\n-            // TODO: Add support for renaming open key\n-            throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n-          }\n+        // fromKeyName should exist\n+        fromKeyValue = omMetadataManager.getKeyTable().get(fromKey);\n+        if (fromKeyValue == null) {\n+          // TODO: Add support for renaming open key\n+          throw new OMException(\"Key not found \" + fromKey, KEY_NOT_FOUND);\n+        }\n \n-          fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+        fromKeyValue.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n \n-          fromKeyValue.setKeyName(toKeyName);\n-          //Set modification time\n-          fromKeyValue.setModificationTime(renameKeyArgs.getModificationTime());\n+        fromKeyValue.setKeyName(toKeyName);\n+        //Set modification time\n+        fromKeyValue.setModificationTime(renameKeyArgs.getModificationTime());\n \n-          // Add to cache.\n-          // fromKey should be deleted,\n-          // toKey should be added with newly updated omKeyInfo.\n-          Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n+        // Add to cache.\n+        // fromKey should be deleted, toKey should be added with newly updated\n+        // omKeyInfo.\n+        Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n \n-          keyTable.addCacheEntry(new CacheKey<>(fromKey),\n-                  new CacheValue<>(Optional.absent(), trxnLogIndex));\n+        keyTable.addCacheEntry(new CacheKey<>(fromKey),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n \n-          keyTable.addCacheEntry(new CacheKey<>(toKey),\n-                  new CacheValue<>(Optional.of(fromKeyValue), trxnLogIndex));\n-          RenameInfo renameInfo = new  RenameInfo(fromKeyName,\n-              fromKeyValue, toKeyName);\n-          renameInfoList.add(renameInfo);\n-        }\n+        keyTable.addCacheEntry(new CacheKey<>(toKey),\n+            new CacheValue<>(Optional.of(fromKeyValue), trxnLogIndex));\n+\n+        omClientResponse = new OMKeyRenameResponse(omResponse\n+            .setRenameKeyResponse(RenameKeyResponse.newBuilder()).build(),\n+            fromKeyName, toKeyName, fromKeyValue);\n \n+        result = Result.SUCCESS;\n       }\n-      omClientResponse = new OMKeyRenameResponse(omResponse\n-              .setRenameKeyResponse(RenameKeyResponse.newBuilder()).build(),\n-              renameInfoList);\n-      result = Result.SUCCESS;\n     } catch (IOException ex) {\n       result = Result.FAILURE;\n       exception = ex;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MDg4MQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407590881", "bodyText": "Should we need fromKey member variable? Is this duplicate info and we can get it from fromKeyValue.getKeyName(); , right?", "author": "rakeshadr", "createdAt": "2020-04-13T17:04:52Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+/**\n+ * The data interface needed to the rename operation.\n+ */\n+public class RenameInfo {\n+  private String  fromKey;", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java b/hadoop-ozone/tools/src/main/java/org/apache/hadoop/ozone/debug/ChunkDataNodeDetails.java\nsimilarity index 61%\nrename from hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java\nrename to hadoop-ozone/tools/src/main/java/org/apache/hadoop/ozone/debug/ChunkDataNodeDetails.java\nindex 5783bff698..6019e5806d 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java\n+++ b/hadoop-ozone/tools/src/main/java/org/apache/hadoop/ozone/debug/ChunkDataNodeDetails.java\n\n@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5MTQzNA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407591434", "bodyText": "Can we dofromKeyValue.getKeyName();?", "author": "rakeshadr", "createdAt": "2020-04-13T17:05:56Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+/**\n+ * The data interface needed to the rename operation.\n+ */\n+public class RenameInfo {\n+  private String  fromKey;\n+  private  OmKeyInfo fromKeyValue;\n+  private String toKey;\n+\n+  public RenameInfo(String fromKey, OmKeyInfo fromKeyValue, String toKey) {\n+    this.fromKey = fromKey;\n+    this.fromKeyValue = fromKeyValue;\n+    this.toKey = toKey;\n+  }\n+\n+  public String getFromKey() {\n+    return fromKey;\n+  }\n+\n+  public OmKeyInfo getFromKeyValue() {\n+    return fromKeyValue;", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java b/hadoop-ozone/tools/src/main/java/org/apache/hadoop/ozone/debug/ChunkDataNodeDetails.java\nsimilarity index 61%\nrename from hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java\nrename to hadoop-ozone/tools/src/main/java/org/apache/hadoop/ozone/debug/ChunkDataNodeDetails.java\nindex 5783bff698..6019e5806d 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/RenameInfo.java\n+++ b/hadoop-ozone/tools/src/main/java/org/apache/hadoop/ozone/debug/ChunkDataNodeDetails.java\n\n@@ -1,4 +1,4 @@\n-/**\n+/*\n  * Licensed to the Apache Software Foundation (ASF) under one\n  * or more contributor license agreements.  See the NOTICE file\n  * distributed with this work for additional information\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5Njg5Nw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407596897", "bodyText": "Instead of hard coding, can you do OzoneConfigKeys.OZONE_FS_ITERATE_BATCH_SIZE ?", "author": "rakeshadr", "createdAt": "2020-04-13T17:15:59Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneFileSystem.java", "diffHunk": "@@ -748,19 +751,34 @@ public String toString() {\n      */\n     boolean iterate() throws IOException {\n       LOG.trace(\"Iterating path {}\", path);\n+      List<String> keyList = new ArrayList<>();\n       if (status.isDirectory()) {\n         LOG.trace(\"Iterating directory:{}\", pathKey);\n         while (keyIterator.hasNext()) {\n           BasicKeyInfo key = keyIterator.next();\n           LOG.trace(\"iterating key:{}\", key.getName());\n-          if (!processKey(key.getName())) {\n+          if (!key.getName().equals(\"\")) {\n+            keyList.add(key.getName());\n+          }\n+          int batchSize = getConf().getInt(\"ozone.fs.iterate.batch-size\", 1);", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneFileSystem.java b/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneFileSystem.java\nindex f02d14387b..05def178bf 100644\n--- a/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneFileSystem.java\n+++ b/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneFileSystem.java\n\n@@ -760,7 +769,8 @@ boolean iterate() throws IOException {\n           if (!key.getName().equals(\"\")) {\n             keyList.add(key.getName());\n           }\n-          int batchSize = getConf().getInt(\"ozone.fs.iterate.batch-size\", 1);\n+          int batchSize = getConf().getInt(OZONE_FS_ITERATE_BATCH_SIZE,\n+              OZONE_FS_ITERATE_BATCH_SIZE_DEFAULT);\n           if (keyList.size() >= batchSize) {\n             if (!processKey(keyList)) {\n               return false;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU5ODUwNg==", "url": "https://github.com/apache/ozone/pull/814#discussion_r407598506", "bodyText": "General comment for both delete and rename batch apis.\nPlease add some test cases with all, partial, no success behaviors. Thanks!", "author": "rakeshadr", "createdAt": "2020-04-13T17:19:00Z", "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/key/TestOMKeyRenameRequest.java", "diffHunk": "@@ -327,11 +331,13 @@ private OMRequest doPreExecute(OMRequest originalOmRequest) throws Exception {\n    * @return OMRequest\n    */\n   private OMRequest createRenameKeyRequest(String toKeyName) {\n-    KeyArgs keyArgs = KeyArgs.newBuilder().setKeyName(keyName)\n+    Map<String, String> renameKeyMap = new HashMap<>();", "originalCommit": "e66bfea7fe596682d386b78d37af2d67c1cb6900", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6208606e7e1a81663889901b98f13335d392c101", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/key/TestOMKeyRenameRequest.java b/hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/key/TestOMKeyRenameRequest.java\nindex 2add0c2793..eb79d7a634 100644\n--- a/hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/key/TestOMKeyRenameRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/key/TestOMKeyRenameRequest.java\n\n@@ -331,13 +327,11 @@ private OMRequest doPreExecute(OMRequest originalOmRequest) throws Exception {\n    * @return OMRequest\n    */\n   private OMRequest createRenameKeyRequest(String toKeyName) {\n-    Map<String, String> renameKeyMap = new HashMap<>();\n-    renameKeyMap.put(keyName, toKeyName);\n-    KeyArgs keyArgs = KeyArgs.newBuilder().addAllRenameKeyMap(\n-        KeyValueUtil.toProtobuf(renameKeyMap))\n+    KeyArgs keyArgs = KeyArgs.newBuilder().setKeyName(keyName)\n         .setVolumeName(volumeName).setBucketName(bucketName).build();\n+\n     RenameKeyRequest renameKeyRequest = RenameKeyRequest.newBuilder()\n-            .setKeyArgs(keyArgs).build();\n+            .setKeyArgs(keyArgs).setToKeyName(toKeyName).build();\n \n     return OMRequest.newBuilder()\n         .setClientId(UUID.randomUUID().toString())\n"}}, {"oid": "c927d2b98b663d7c052683b9fd5ea2c416e04933", "url": "https://github.com/apache/ozone/commit/c927d2b98b663d7c052683b9fd5ea2c416e04933", "message": "BasicOzoneFileSystem support batchDelete and batchRename", "committedDate": "2020-05-18T13:14:15Z", "type": "forcePushed"}, {"oid": "6208606e7e1a81663889901b98f13335d392c101", "url": "https://github.com/apache/ozone/commit/6208606e7e1a81663889901b98f13335d392c101", "message": "BasicOzoneFileSystem support batchDelete", "committedDate": "2020-05-19T06:38:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NzU5MQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429087591", "bodyText": "We need to iterate all omKeyInfo in the list as well here", "author": "timmylicheng", "createdAt": "2020-05-22T07:30:33Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -111,51 +114,53 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     boolean acquiredLock = false;\n     OMClientResponse omClientResponse = null;\n     Result result = null;\n+    List<OmKeyInfo> omKeyInfoList= new ArrayList<>();\n     try {\n-      // check Acl\n-      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-\n-      String objectKey = omMetadataManager.getOzoneKey(\n-          volumeName, bucketName, keyName);\n-\n+      if (keyNameList.size() == 0) {\n+        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+      }\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-          volumeName, bucketName);\n-\n+              volumeName, bucketName);\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n-\n-      OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n-      if (omKeyInfo == null) {\n-        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+      Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n+      for (String keyName : keyNameList) {\n+        // check Acl\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+                IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+        String objectKey = omMetadataManager.getOzoneKey(\n+                volumeName, bucketName, keyName);\n+        OmKeyInfo omKeyInfo = keyTable.get(objectKey);\n+        if (omKeyInfo == null) {\n+          throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+        }\n+\n+        // Check if this transaction is a replay of ratis logs.\n+        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex b75dd474b8..1f1b0fb053 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -114,53 +111,51 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     boolean acquiredLock = false;\n     OMClientResponse omClientResponse = null;\n     Result result = null;\n-    List<OmKeyInfo> omKeyInfoList= new ArrayList<>();\n     try {\n-      if (keyNameList.size() == 0) {\n-        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n-      }\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+\n+      String objectKey = omMetadataManager.getOzoneKey(\n+          volumeName, bucketName, keyName);\n+\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-              volumeName, bucketName);\n+          volumeName, bucketName);\n+\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n-      Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n-      for (String keyName : keyNameList) {\n-        // check Acl\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-                IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-        String objectKey = omMetadataManager.getOzoneKey(\n-                volumeName, bucketName, keyName);\n-        OmKeyInfo omKeyInfo = keyTable.get(objectKey);\n-        if (omKeyInfo == null) {\n-          throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n-        }\n-\n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n-          // Replay implies the response has already been returned to\n-          // the client. So take no further action and return a dummy\n-          // OMClientResponse.\n-          throw new OMReplayException();\n-        }\n-\n-        // Set the UpdateID to current transactionLogIndex\n-        omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n-\n-        // Update table cache.\n-        keyTable.addCacheEntry(\n-                new CacheKey<>(omMetadataManager.getOzoneKey(\n-                        volumeName, bucketName, keyName)),\n-                new CacheValue<>(Optional.absent(), trxnLogIndex));\n-\n-        // No need to add cache entries to delete table. As delete table will\n-        // be used by DeleteKeyService only, not used for any client response\n-        // validation, so we don't need to add to cache.\n-        // TODO: Revisit if we need it later.\n-        omKeyInfoList.add(omKeyInfo);\n+\n+      OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+      if (omKeyInfo == null) {\n+        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n       }\n+\n+      // Check if this transaction is a replay of ratis logs.\n+      if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n+        // Replay implies the response has already been returned to\n+        // the client. So take no further action and return a dummy\n+        // OMClientResponse.\n+        throw new OMReplayException();\n+      }\n+\n+      // Set the UpdateID to current transactionLogIndex\n+      omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+      // Update table cache.\n+      omMetadataManager.getKeyTable().addCacheEntry(\n+          new CacheKey<>(omMetadataManager.getOzoneKey(volumeName, bucketName,\n+              keyName)),\n+          new CacheValue<>(Optional.absent(), trxnLogIndex));\n+\n+      // No need to add cache entries to delete table. As delete table will\n+      // be used by DeleteKeyService only, not used for any client response\n+      // validation, so we don't need to add to cache.\n+      // TODO: Revisit if we need it later.\n+\n       omClientResponse = new OMKeyDeleteResponse(omResponse\n-              .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n-              omKeyInfoList, ozoneManager.isRatisEnabled());\n+          .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n+          omKeyInfo, ozoneManager.isRatisEnabled());\n+\n       result = Result.SUCCESS;\n     } catch (IOException ex) {\n       if (ex instanceof OMReplayException) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4ODg3MQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429088871", "bodyText": "Not related to this class. But you wanna visit TestOzoneManagerHAWithData and see if HA needs a test case for deleting a list of keys.", "author": "timmylicheng", "createdAt": "2020-05-22T07:33:42Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java", "diffHunk": "@@ -157,6 +159,7 @@ public void testFileSystem() throws Exception {\n ", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3f720f10c256c604b57db2cd6e12bc6cccc9b0ad", "chunk": "diff --git a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java\nindex fe9bf4d4b1..ba3d643e3d 100644\n--- a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java\n+++ b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java\n\n@@ -159,7 +172,7 @@ public void testFileSystem() throws Exception {\n \n     testCreateDoesNotAddParentDirKeys();\n     testDeleteCreatesFakeParentDir();\n-    testBatchDelete();\n+    testFileDelete();\n     testNonExplicitlyCreatedPathExistsAfterItsLeafsWereRemoved();\n \n     testRenameDir();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4OTE0MQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429089141", "bodyText": "Why do we keep keyName and keyNameList at the same time?", "author": "timmylicheng", "createdAt": "2020-05-22T07:34:24Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java", "diffHunk": "@@ -256,11 +263,16 @@ public Builder setSortDatanodesInPipeline(boolean sort) {\n       return this;\n     }\n \n+    public Builder setKeyNameList(List<String> keyList) {\n+      this.keyNameList = keyList;\n+      return this;\n+    }\n+\n     public OmKeyArgs build() {\n       return new OmKeyArgs(volumeName, bucketName, keyName, dataSize, type,", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzOTYzOQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429339639", "bodyText": "I think other operations such as createKey still assume a single KeyName.", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4OTE0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTcxMjMwMw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429712303", "bodyText": "I will delete keyNameList in KeyArgs, by use list of KeyArgs. To avoid changes to KeyArgs.", "author": "captainzmc", "createdAt": "2020-05-25T02:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4OTE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java\nindex 38bb61f8a4..2a882a43a9 100644\n--- a/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java\n+++ b/hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmKeyArgs.java\n\n@@ -263,16 +256,11 @@ public Builder setSortDatanodesInPipeline(boolean sort) {\n       return this;\n     }\n \n-    public Builder setKeyNameList(List<String> keyList) {\n-      this.keyNameList = keyList;\n-      return this;\n-    }\n-\n     public OmKeyArgs build() {\n       return new OmKeyArgs(volumeName, bucketName, keyName, dataSize, type,\n           factor, locationInfoList, isMultipartKey, multipartUploadID,\n           multipartUploadPartNumber, metadata, refreshPipeline, acls,\n-          sortDatanodesInPipeline, keyNameList);\n+          sortDatanodesInPipeline);\n     }\n \n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA5NTU1Mw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429095553", "bodyText": "It would be great if we add a failure case here like there is an unknown key in a list of known keys. We would like to also test exceptions.", "author": "timmylicheng", "createdAt": "2020-05-22T07:49:15Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java", "diffHunk": "@@ -248,6 +253,34 @@ private void testDeleteCreatesFakeParentDir() throws Exception {\n     assertEquals(parentKey, parentKeyInfo.getName());\n   }\n ", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8604295876cef7c62e51720ba34d90d783c00534", "chunk": "diff --git a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java\nindex fe9bf4d4b1..f51f6a3dad 100644\n--- a/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java\n+++ b/hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneFileSystem.java\n\n@@ -266,19 +273,11 @@ private void testBatchDelete() throws Exception {\n       ContractTestUtils.touch(fs, childFile);\n       ContractTestUtils.touch(fs, childFolderFile);\n     }\n-\n+    assertTrue(fs.listStatus(grandparent).length == 1);\n+    assertTrue(fs.listStatus(parent).length == 9);\n+    assertTrue(fs.listStatus(childFolder).length == 8);\n     fs.delete(grandparent, true);\n-    assertTrue(!o3fs.exists(grandparent));\n-    for (int i = 0; i < 8; i++) {\n-      Path childFile = new Path(parent, \"child\" + i);\n-      // Make sure all keys under testBatchDelete/parent should be deleted\n-      assertTrue(!o3fs.exists(childFile));\n-\n-      // Test to recursively delete child folder, make sure all keys under\n-      // testBatchDelete/parent/childFolder should be deleted.\n-      Path childFolderFile = new Path(childFolder, \"child\" + i);\n-      assertTrue(!o3fs.exists(childFolderFile));\n-    }\n+    assertTrue(fs.listStatus(grandparent).length == 0);\n   }\n \n   private void testListStatus() throws Exception {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MjgyOQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429342829", "bodyText": "When we delete a list of keys, upon failure in the middle, can we return a list of deleted keys and undeleted keys? This may not be an issue when you delete a single key but when batch deleting, it is hard to recover from the failures without that information.", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:30:10Z", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/OzoneBucket.java", "diffHunk": "@@ -382,6 +382,21 @@ public void deleteKey(String key) throws IOException {\n     proxy.deleteKey(volumeName, name, key);\n   }\n \n+  /**\n+   * Deletes the given list of keys from the bucket.\n+   * @param keyList List of the key name to be deleted.\n+   * @throws IOException\n+   */\n+  public void deleteKeys(List<String> keyList) throws IOException {", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExOTczOA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437119738", "bodyText": "Agree with Xiaoyu, we should return a list of deleted key result on failure.", "author": "ChenSammi", "createdAt": "2020-06-09T03:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MjgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwOTcwNw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437509707", "bodyText": "I will add unDeletedKeys and deletedKeys in exception when an exception occurs when delete keys.", "author": "captainzmc", "createdAt": "2020-06-09T15:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0MjgyOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NDgzNw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429344837", "bodyText": "This is OK with o3fs as we will mount a single bucket. In the context of ofs where you can have multiple volume buckets under the root. This lock can't guarantee atomic across all the delete keyname list.", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:34:36Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -111,51 +114,53 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     boolean acquiredLock = false;\n     OMClientResponse omClientResponse = null;\n     Result result = null;\n+    List<OmKeyInfo> omKeyInfoList= new ArrayList<>();\n     try {\n-      // check Acl\n-      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-\n-      String objectKey = omMetadataManager.getOzoneKey(\n-          volumeName, bucketName, keyName);\n-\n+      if (keyNameList.size() == 0) {\n+        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+      }\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NjE4MA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r431896180", "bodyText": "Here I will make sure that all buckets I used are locked to ensure compatibility with ofs.", "author": "captainzmc", "createdAt": "2020-05-28T14:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NDgzNw=="}], "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex b75dd474b8..1f1b0fb053 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -114,53 +111,51 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     boolean acquiredLock = false;\n     OMClientResponse omClientResponse = null;\n     Result result = null;\n-    List<OmKeyInfo> omKeyInfoList= new ArrayList<>();\n     try {\n-      if (keyNameList.size() == 0) {\n-        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n-      }\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+\n+      String objectKey = omMetadataManager.getOzoneKey(\n+          volumeName, bucketName, keyName);\n+\n       acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n-              volumeName, bucketName);\n+          volumeName, bucketName);\n+\n       // Validate bucket and volume exists or not.\n       validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n-      Table<String, OmKeyInfo> keyTable = omMetadataManager.getKeyTable();\n-      for (String keyName : keyNameList) {\n-        // check Acl\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-                IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n-        String objectKey = omMetadataManager.getOzoneKey(\n-                volumeName, bucketName, keyName);\n-        OmKeyInfo omKeyInfo = keyTable.get(objectKey);\n-        if (omKeyInfo == null) {\n-          throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n-        }\n-\n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n-          // Replay implies the response has already been returned to\n-          // the client. So take no further action and return a dummy\n-          // OMClientResponse.\n-          throw new OMReplayException();\n-        }\n-\n-        // Set the UpdateID to current transactionLogIndex\n-        omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n-\n-        // Update table cache.\n-        keyTable.addCacheEntry(\n-                new CacheKey<>(omMetadataManager.getOzoneKey(\n-                        volumeName, bucketName, keyName)),\n-                new CacheValue<>(Optional.absent(), trxnLogIndex));\n-\n-        // No need to add cache entries to delete table. As delete table will\n-        // be used by DeleteKeyService only, not used for any client response\n-        // validation, so we don't need to add to cache.\n-        // TODO: Revisit if we need it later.\n-        omKeyInfoList.add(omKeyInfo);\n+\n+      OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+      if (omKeyInfo == null) {\n+        throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n       }\n+\n+      // Check if this transaction is a replay of ratis logs.\n+      if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n+        // Replay implies the response has already been returned to\n+        // the client. So take no further action and return a dummy\n+        // OMClientResponse.\n+        throw new OMReplayException();\n+      }\n+\n+      // Set the UpdateID to current transactionLogIndex\n+      omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+      // Update table cache.\n+      omMetadataManager.getKeyTable().addCacheEntry(\n+          new CacheKey<>(omMetadataManager.getOzoneKey(volumeName, bucketName,\n+              keyName)),\n+          new CacheValue<>(Optional.absent(), trxnLogIndex));\n+\n+      // No need to add cache entries to delete table. As delete table will\n+      // be used by DeleteKeyService only, not used for any client response\n+      // validation, so we don't need to add to cache.\n+      // TODO: Revisit if we need it later.\n+\n       omClientResponse = new OMKeyDeleteResponse(omResponse\n-              .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n-              omKeyInfoList, ozoneManager.isRatisEnabled());\n+          .setDeleteKeyResponse(DeleteKeyResponse.newBuilder()).build(),\n+          omKeyInfo, ozoneManager.isRatisEnabled());\n+\n       result = Result.SUCCESS;\n     } catch (IOException ex) {\n       if (ex instanceof OMReplayException) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NjE1NQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429346155", "bodyText": "This will only print the address of the keNameList. You may want to expand the list and also protect the LOG.debug with a if LOG.isDebugEnabled().", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:37:41Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -187,7 +192,7 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     case SUCCESS:\n       omMetrics.decNumKeys();\n       LOG.debug(\"Key deleted. Volume:{}, Bucket:{}, Key:{}\", volumeName,\n-          bucketName, keyName);\n+          bucketName, keyNameList);", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex b75dd474b8..1f1b0fb053 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -192,7 +187,7 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     case SUCCESS:\n       omMetrics.decNumKeys();\n       LOG.debug(\"Key deleted. Volume:{}, Bucket:{}, Key:{}\", volumeName,\n-          bucketName, keyNameList);\n+          bucketName, keyName);\n       break;\n     case REPLAY:\n       LOG.debug(\"Replayed Transaction {} ignored. Request: {}\", trxnLogIndex,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0NjU3NQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429346575", "bodyText": "same as above. we might only want to print the key that failed in the deletion instead of the whole list upon failures. print the whole list can be a debug or trace level log.", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:38:34Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java", "diffHunk": "@@ -196,7 +201,7 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     case FAILURE:\n       omMetrics.incNumKeyDeleteFails();\n       LOG.error(\"Key delete failed. Volume:{}, Bucket:{}, Key{}. Exception:{}\",\n-          volumeName, bucketName, keyName, exception);\n+          volumeName, bucketName, keyNameList, exception);", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\nindex b75dd474b8..1f1b0fb053 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyDeleteRequest.java\n\n@@ -201,7 +196,7 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     case FAILURE:\n       omMetrics.incNumKeyDeleteFails();\n       LOG.error(\"Key delete failed. Volume:{}, Bucket:{}, Key{}. Exception:{}\",\n-          volumeName, bucketName, keyNameList, exception);\n+          volumeName, bucketName, keyName, exception);\n       break;\n     default:\n       LOG.error(\"Unrecognized Result for OMKeyDeleteRequest: {}\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0ODUxNQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429348515", "bodyText": "Should we define a new method called deleteObjects to be backward compatible?", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:42:55Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneClientAdapterImpl.java", "diffHunk": "@@ -272,15 +272,15 @@ public boolean createDirectory(String keyName) throws IOException {\n   /**\n    * Helper method to delete an object specified by key name in bucket.\n    *\n-   * @param keyName key name to be deleted\n+   * @param keyNameList key name list to be deleted\n    * @return true if the key is deleted, false otherwise\n    */\n   @Override\n-  public boolean deleteObject(String keyName) {\n-    LOG.trace(\"issuing delete for key {}\", keyName);\n+  public boolean deleteObject(List<String> keyNameList) {", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneClientAdapterImpl.java b/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneClientAdapterImpl.java\nindex 35269a6ab9..5678754f1f 100644\n--- a/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneClientAdapterImpl.java\n+++ b/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicOzoneClientAdapterImpl.java\n\n@@ -269,6 +269,25 @@ public boolean createDirectory(String keyName) throws IOException {\n     return true;\n   }\n \n+  /**\n+   * Helper method to delete an object specified by key name in bucket.\n+   *\n+   * @param keyName key name to be deleted\n+   * @return true if the key is deleted, false otherwise\n+   */\n+  @Override\n+  public boolean deleteObject(String keyName) {\n+    LOG.trace(\"issuing delete for key {}\", keyName);\n+    try {\n+      incrementCounter(Statistic.OBJECTS_DELETED);\n+      bucket.deleteKey(keyName);\n+      return true;\n+    } catch (IOException ioe) {\n+      LOG.error(\"delete key failed {}\", ioe.getMessage());\n+      return false;\n+    }\n+  }\n+\n   /**\n    * Helper method to delete an object specified by key name in bucket.\n    *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM0OTAyMA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r429349020", "bodyText": "Should we define a new method called deleteObjects to be backward compatible?", "author": "xiaoyuyao", "createdAt": "2020-05-22T16:43:49Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OzoneClientAdapter.java", "diffHunk": "@@ -48,7 +48,7 @@ OzoneFSOutputStream createFile(String key, short replication,\n \n   boolean createDirectory(String keyName) throws IOException;\n \n-  boolean deleteObject(String keyName);", "originalCommit": "66af6cbb7ebedaefc9c99874c9c207e71d62ea21", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e89201e399af3ae6cbb114ebb3643eb713174981", "chunk": "diff --git a/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OzoneClientAdapter.java b/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OzoneClientAdapter.java\nindex 2a497566eb..98e128131b 100644\n--- a/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OzoneClientAdapter.java\n+++ b/hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OzoneClientAdapter.java\n\n@@ -48,7 +48,9 @@ OzoneFSOutputStream createFile(String key, short replication,\n \n   boolean createDirectory(String keyName) throws IOException;\n \n-  boolean deleteObject(List<String> keyName);\n+  boolean deleteObject(String keyName);\n+\n+  boolean deleteObjects(List<String> keyName);\n \n   Iterator<BasicKeyInfo> listKeys(String pathKey);\n \n"}}, {"oid": "e89201e399af3ae6cbb114ebb3643eb713174981", "url": "https://github.com/apache/ozone/commit/e89201e399af3ae6cbb114ebb3643eb713174981", "message": "support batch delete and fix review issues.", "committedDate": "2020-05-28T11:44:40Z", "type": "forcePushed"}, {"oid": "c4950d93738e1a683d544da6f696818cb9df2af6", "url": "https://github.com/apache/ozone/commit/c4950d93738e1a683d544da6f696818cb9df2af6", "message": "support batch delete and fix review issues.", "committedDate": "2020-05-28T12:03:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxOTAyNQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r433519025", "bodyText": "Note when the batch size is large, this could hold the lock for a longer period of time compare with the individual lock and release.", "author": "xiaoyuyao", "createdAt": "2020-06-01T22:16:13Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.exceptions.OMReplayException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMBatchKeyDeleteResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles DeleteKey request.\n+ */\n+public class OMBatchKeyDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMBatchKeyDeleteRequest.class);\n+\n+  public OMBatchKeyDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+    DeleteBatchKeyRequest deleteKeyRequest =\n+        getOmRequest().getDeleteBatchKeyRequest();\n+    Preconditions.checkNotNull(deleteKeyRequest);\n+    List<KeyArgs> newKeyArgsList = new ArrayList<>();\n+    for (KeyArgs keyArgs : deleteKeyRequest.getKeyArgsList()) {\n+      newKeyArgsList.add(\n+          keyArgs.toBuilder().setModificationTime(Time.now()).build());\n+    }\n+    DeleteBatchKeyRequest newDeleteKeyRequest = DeleteBatchKeyRequest\n+        .newBuilder().addAllKeyArgs(newKeyArgsList).build();\n+\n+    return getOmRequest().toBuilder()\n+        .setDeleteBatchKeyRequest(newDeleteKeyRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+    DeleteBatchKeyRequest deleteKeyRequest =\n+        getOmRequest().getDeleteBatchKeyRequest();\n+\n+    List<KeyArgs> deleteKeyArgsList = deleteKeyRequest.getKeyArgsList();\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyDeletes();\n+    List<OmKeyInfo> omKeyInfoList = new ArrayList<>();\n+    Set<String> acquiredLockSet = new HashSet<>();\n+    Map<String, String> auditMap = null;\n+    String volumeName = \"\";\n+    String bucketName = \"\";\n+    String keyName = \"\";\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo =\n+        getOmRequest().getUserInfo();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    try {\n+      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n+        acquiredLockSet.add(deleteKeyArgs.getVolumeName() + \"_\" +\n+            deleteKeyArgs.getBucketName());\n+      }\n+\n+      for (String volumeAndVolume : acquiredLockSet) {\n+        omMetadataManager.getLock().acquireWriteLock(", "originalCommit": "109a6ba9bdb6b21244b51cc2818d8ddbce8bafd1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5NDA2Mg==", "url": "https://github.com/apache/ozone/pull/814#discussion_r433894062", "bodyText": "Had fixed this part by getting the lock separately when the key is deleting.", "author": "captainzmc", "createdAt": "2020-06-02T13:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzUxOTAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "1149c66f48b445d13d82bf3a8aa6f4e34a11b3b7", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java\nindex 0020f439e6..94edb69aab 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java\n\n@@ -36,7 +36,16 @@\n import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n import org.apache.hadoop.ozone.om.response.key.OMBatchKeyDeleteResponse;\n import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n-import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.*;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .DeleteBatchKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .DeleteBatchKeyResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .KeyArgs;\n import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n import org.apache.hadoop.ozone.security.acl.OzoneObj;\n import org.apache.hadoop.util.Time;\n"}}, {"oid": "1149c66f48b445d13d82bf3a8aa6f4e34a11b3b7", "url": "https://github.com/apache/ozone/commit/1149c66f48b445d13d82bf3a8aa6f4e34a11b3b7", "message": "fix checkstyle.", "committedDate": "2020-06-02T13:42:33Z", "type": "forcePushed"}, {"oid": "fd75e9216288652eac0f9429105abd68a8fcb8ec", "url": "https://github.com/apache/ozone/commit/fd75e9216288652eac0f9429105abd68a8fcb8ec", "message": "fix checkstyle.", "committedDate": "2020-06-05T09:10:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExODQzMA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437118430", "bodyText": "Suggest a bigger default size, say 100?", "author": "ChenSammi", "createdAt": "2020-06-09T03:32:18Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java", "diffHunk": "@@ -401,6 +401,10 @@\n       \"ozone.s3.token.max.lifetime\";\n   public static final String OZONE_S3_AUTHINFO_MAX_LIFETIME_KEY_DEFAULT = \"3m\";\n \n+  public static final String OZONE_FS_ITERATE_BATCH_SIZE =\n+          \"ozone.fs.iterate.batch-size\";\n+  public static final int OZONE_FS_ITERATE_BATCH_SIZE_DEFAULT = 1;", "originalCommit": "2158a796f08f35f5498943085f053570b26b7ac5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8604295876cef7c62e51720ba34d90d783c00534", "chunk": "diff --git a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java\nindex 6e40c6cfde..fcd3ff4d9b 100644\n--- a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java\n+++ b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java\n\n@@ -402,8 +402,8 @@\n   public static final String OZONE_S3_AUTHINFO_MAX_LIFETIME_KEY_DEFAULT = \"3m\";\n \n   public static final String OZONE_FS_ITERATE_BATCH_SIZE =\n-          \"ozone.fs.iterate.batch-size\";\n-  public static final int OZONE_FS_ITERATE_BATCH_SIZE_DEFAULT = 1;\n+      \"ozone.fs.iterate.batch-size\";\n+  public static final int OZONE_FS_ITERATE_BATCH_SIZE_DEFAULT = 100;\n \n   // Ozone Client Retry and Failover configurations\n   public static final String OZONE_CLIENT_FAILOVER_MAX_ATTEMPTS_KEY =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExODUxOA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437118518", "bodyText": "Will this property be used for batch rename too?", "author": "ChenSammi", "createdAt": "2020-06-09T03:32:40Z", "path": "hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java", "diffHunk": "@@ -401,6 +401,10 @@\n       \"ozone.s3.token.max.lifetime\";\n   public static final String OZONE_S3_AUTHINFO_MAX_LIFETIME_KEY_DEFAULT = \"3m\";\n \n+  public static final String OZONE_FS_ITERATE_BATCH_SIZE =", "originalCommit": "2158a796f08f35f5498943085f053570b26b7ac5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIzNDU2NA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437234564", "bodyText": "Yes, batch Rename will also use this property.", "author": "captainzmc", "createdAt": "2020-06-09T08:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExODUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "8604295876cef7c62e51720ba34d90d783c00534", "chunk": "diff --git a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java\nindex 6e40c6cfde..fcd3ff4d9b 100644\n--- a/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java\n+++ b/hadoop-hdds/common/src/main/java/org/apache/hadoop/ozone/OzoneConfigKeys.java\n\n@@ -402,8 +402,8 @@\n   public static final String OZONE_S3_AUTHINFO_MAX_LIFETIME_KEY_DEFAULT = \"3m\";\n \n   public static final String OZONE_FS_ITERATE_BATCH_SIZE =\n-          \"ozone.fs.iterate.batch-size\";\n-  public static final int OZONE_FS_ITERATE_BATCH_SIZE_DEFAULT = 1;\n+      \"ozone.fs.iterate.batch-size\";\n+  public static final int OZONE_FS_ITERATE_BATCH_SIZE_DEFAULT = 100;\n \n   // Ozone Client Retry and Failover configurations\n   public static final String OZONE_CLIENT_FAILOVER_MAX_ATTEMPTS_KEY =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExODgzMQ==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437118831", "bodyText": "Indent is incorrect.", "author": "ChenSammi", "createdAt": "2020-06-09T03:34:10Z", "path": "hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java", "diffHunk": "@@ -294,6 +294,17 @@ OzoneInputStream getKey(String volumeName, String bucketName, String keyName)\n   void deleteKey(String volumeName, String bucketName, String keyName)\n       throws IOException;\n \n+  /**\n+   * Deletes keys through the list.\n+   * @param volumeName Name of the Volume\n+   * @param bucketName Name of the Bucket\n+   * @param keyNameList List of the Key\n+   * @throws IOException\n+   */\n+  void deleteKeys(String volumeName, String bucketName,\n+                     List<String> keyNameList)", "originalCommit": "2158a796f08f35f5498943085f053570b26b7ac5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8604295876cef7c62e51720ba34d90d783c00534", "chunk": "diff --git a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java\nindex 4c34262d24..9c662efbf0 100644\n--- a/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java\n+++ b/hadoop-ozone/client/src/main/java/org/apache/hadoop/ozone/client/protocol/ClientProtocol.java\n\n@@ -302,8 +302,8 @@ void deleteKey(String volumeName, String bucketName, String keyName)\n    * @throws IOException\n    */\n   void deleteKeys(String volumeName, String bucketName,\n-                     List<String> keyNameList)\n-          throws IOException;\n+                  List<String> keyNameList)\n+      throws IOException;\n \n   /**\n    * Renames an existing key within a bucket.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzIyOTg1MA==", "url": "https://github.com/apache/ozone/pull/814#discussion_r437229850", "bodyText": "Can we return the list of deleted keys together with the exception to client so that client knows which keyes are deleted and which key trigger the exception?", "author": "ChenSammi", "createdAt": "2020-06-09T08:30:55Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.key;\n+\n+import com.google.common.base.Optional;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.exceptions.OMReplayException;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMKeyDeleteResponse;\n+import org.apache.hadoop.ozone.om.response.key.OMBatchKeyDeleteResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .DeleteBatchKeyRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .DeleteBatchKeyResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+    .KeyArgs;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.KEY_NOT_FOUND;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+\n+/**\n+ * Handles DeleteKey request.\n+ */\n+public class OMBatchKeyDeleteRequest extends OMKeyRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMBatchKeyDeleteRequest.class);\n+\n+  public OMBatchKeyDeleteRequest(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n+    DeleteBatchKeyRequest deleteKeyRequest =\n+        getOmRequest().getDeleteBatchKeyRequest();\n+    Preconditions.checkNotNull(deleteKeyRequest);\n+    List<KeyArgs> newKeyArgsList = new ArrayList<>();\n+    for (KeyArgs keyArgs : deleteKeyRequest.getKeyArgsList()) {\n+      newKeyArgsList.add(\n+          keyArgs.toBuilder().setModificationTime(Time.now()).build());\n+    }\n+    DeleteBatchKeyRequest newDeleteKeyRequest = DeleteBatchKeyRequest\n+        .newBuilder().addAllKeyArgs(newKeyArgsList).build();\n+\n+    return getOmRequest().toBuilder()\n+        .setDeleteBatchKeyRequest(newDeleteKeyRequest)\n+        .setUserInfo(getUserInfo()).build();\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"methodlength\")\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+    DeleteBatchKeyRequest deleteKeyRequest =\n+        getOmRequest().getDeleteBatchKeyRequest();\n+\n+    List<KeyArgs> deleteKeyArgsList = deleteKeyRequest.getKeyArgsList();\n+    IOException exception = null;\n+    boolean acquiredLock = false;\n+    OMClientResponse omClientResponse = null;\n+    Result result = null;\n+\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumKeyDeletes();\n+    List<OmKeyInfo> omKeyInfoList = new ArrayList<>();\n+    Map<String, String> auditMap = null;\n+    String volumeName = \"\";\n+    String bucketName = \"\";\n+    String keyName = \"\";\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo =\n+        getOmRequest().getUserInfo();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    try {\n+      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n+        volumeName = deleteKeyArgs.getVolumeName();\n+        bucketName = deleteKeyArgs.getBucketName();\n+        keyName = deleteKeyArgs.getKeyName();\n+        auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n+\n+        // check Acl\n+        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+\n+        String objectKey = omMetadataManager.getOzoneKey(\n+            volumeName, bucketName, keyName);\n+\n+        acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+            volumeName, bucketName);\n+        // Validate bucket and volume exists or not.\n+        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n+        if (omKeyInfo == null) {\n+          throw new OMException(\"Key not found\", KEY_NOT_FOUND);\n+        }\n+\n+        // Check if this transaction is a replay of ratis logs.\n+        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n+          // Replay implies the response has already been returned to\n+          // the client. So take no further action and return a dummy\n+          // OMClientResponse.\n+          throw new OMReplayException();\n+        }\n+\n+        // Set the UpdateID to current transactionLogIndex\n+        omKeyInfo.setUpdateID(trxnLogIndex, ozoneManager.isRatisEnabled());\n+\n+        // Update table cache.\n+        omMetadataManager.getKeyTable().addCacheEntry(\n+            new CacheKey<>(omMetadataManager.getOzoneKey(\n+                volumeName, bucketName, keyName)),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+\n+        // No need to add cache entries to delete table. As delete table will\n+        // be used by DeleteKeyService only, not used for any client response\n+        // validation, so we don't need to add to cache.\n+        // TODO: Revisit if we need it later.\n+\n+        if (acquiredLock) {\n+          omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+              bucketName);\n+          acquiredLock = false;\n+        }\n+        omKeyInfoList.add(omKeyInfo);\n+      }\n+      omClientResponse = new OMBatchKeyDeleteResponse(omResponse\n+          .setDeleteBatchKeyResponse(DeleteBatchKeyResponse.newBuilder())\n+          .build(),\n+          omKeyInfoList, ozoneManager.isRatisEnabled());\n+      result = Result.SUCCESS;\n+    } catch (IOException ex) {\n+      if (ex instanceof OMReplayException) {\n+        result = Result.REPLAY;\n+        omClientResponse = new OMKeyDeleteResponse(createReplayOMResponse(", "originalCommit": "2158a796f08f35f5498943085f053570b26b7ac5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8604295876cef7c62e51720ba34d90d783c00534", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java\nsimilarity index 82%\nrename from hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java\nrename to hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java\nindex 94edb69aab..8f6fbdd4c1 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMBatchKeyDeleteRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java\n\n@@ -20,6 +20,7 @@\n \n import com.google.common.base.Optional;\n import com.google.common.base.Preconditions;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n import org.apache.hadoop.ozone.audit.AuditLogger;\n"}}, {"oid": "8604295876cef7c62e51720ba34d90d783c00534", "url": "https://github.com/apache/ozone/commit/8604295876cef7c62e51720ba34d90d783c00534", "message": "add unDeletedKeys and deletedKeys in exception and fix review issues.", "committedDate": "2020-06-12T02:00:16Z", "type": "forcePushed"}, {"oid": "3f720f10c256c604b57db2cd6e12bc6cccc9b0ad", "url": "https://github.com/apache/ozone/commit/3f720f10c256c604b57db2cd6e12bc6cccc9b0ad", "message": "fix review issues and bugs.", "committedDate": "2020-06-18T06:40:18Z", "type": "forcePushed"}, {"oid": "257a8d4c91d9b922d3aa3589a5165bb071cef822", "url": "https://github.com/apache/ozone/commit/257a8d4c91d9b922d3aa3589a5165bb071cef822", "message": "fix review issues and bugs and rebase master.", "committedDate": "2020-06-18T08:07:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3MzQ5Mw==", "url": "https://github.com/apache/ozone/pull/814#discussion_r443073493", "bodyText": "I think put the undeleted keys in OMResponse is good enough. Not sure if we want to append all the key names into the string message, which can hurt the performance when the list is huge.", "author": "xiaoyuyao", "createdAt": "2020-06-19T23:06:49Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/OMClientRequest.java", "diffHunk": "@@ -220,6 +224,39 @@ protected OMResponse createErrorOMResponse(\n     return omResponse.build();\n   }\n \n+  /**\n+   * Set parameters needed for return error response to client.\n+   *\n+   * @param omResponse\n+   * @param ex         - IOException\n+   * @param unDeletedKeys    - Set<OmKeyInfo>\n+   * @return error response need to be returned to client - OMResponse.\n+   */\n+  protected OMResponse createOperationKeysErrorOMResponse(\n+      @Nonnull OMResponse.Builder omResponse,\n+      @Nonnull IOException ex, @Nonnull Set<OmKeyInfo> unDeletedKeys) {\n+    omResponse.setSuccess(false);\n+    StringBuffer errorMsg = new StringBuffer();\n+    errorMsg.append(exceptionErrorMessage(ex) + \"\\n The Keys not deleted: \");\n+    UnDeletedKeysResponse.Builder resp =\n+        UnDeletedKeysResponse.newBuilder();\n+    for (OmKeyInfo key : unDeletedKeys) {\n+      if(key != null) {\n+        resp.addKeyInfo(key.getProtobuf());\n+        errorMsg.append(key.getObjectInfo() + \"\\n\");\n+      }\n+    }\n+    if (errorMsg != null) {\n+      omResponse.setMessage(errorMsg.toString());\n+    }\n+    // TODO: Currently all delete operations in OzoneBucket.java are void. Here\n+    //  we put the List of unDeletedKeys into Response. These KeyInfo can be\n+    //  used to continue deletion if client support delete retry.\n+    omResponse.setUnDeletedKeysResponse(resp.build());", "originalCommit": "257a8d4c91d9b922d3aa3589a5165bb071cef822", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "078c9d4e621dee0d4cc9a6c8d50cb636470519bc", "chunk": "diff --git a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/OMClientRequest.java b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/OMClientRequest.java\nindex 8a7fbbfb3c..03531440e5 100644\n--- a/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/OMClientRequest.java\n+++ b/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/OMClientRequest.java\n\n@@ -237,13 +237,10 @@ protected OMResponse createOperationKeysErrorOMResponse(\n       @Nonnull IOException ex, @Nonnull Set<OmKeyInfo> unDeletedKeys) {\n     omResponse.setSuccess(false);\n     StringBuffer errorMsg = new StringBuffer();\n-    errorMsg.append(exceptionErrorMessage(ex) + \"\\n The Keys not deleted: \");\n-    UnDeletedKeysResponse.Builder resp =\n-        UnDeletedKeysResponse.newBuilder();\n+    DeleteKeysResponse.Builder resp = DeleteKeysResponse.newBuilder();\n     for (OmKeyInfo key : unDeletedKeys) {\n       if(key != null) {\n-        resp.addKeyInfo(key.getProtobuf());\n-        errorMsg.append(key.getObjectInfo() + \"\\n\");\n+        resp.addUnDeletedKeys(key.getProtobuf());\n       }\n     }\n     if (errorMsg != null) {\n"}}, {"oid": "078c9d4e621dee0d4cc9a6c8d50cb636470519bc", "url": "https://github.com/apache/ozone/commit/078c9d4e621dee0d4cc9a6c8d50cb636470519bc", "message": "fix review issues.", "committedDate": "2020-06-23T07:46:03Z", "type": "forcePushed"}, {"oid": "b377791437f65804e96561b07b20bf6f66672f0c", "url": "https://github.com/apache/ozone/commit/b377791437f65804e96561b07b20bf6f66672f0c", "message": "support batch delete and fix review issues.", "committedDate": "2020-06-23T08:29:28Z", "type": "commit"}, {"oid": "44c578871806ed0b2412d5341093aced907f4e71", "url": "https://github.com/apache/ozone/commit/44c578871806ed0b2412d5341093aced907f4e71", "message": "fix review issues and resolve the conflict.", "committedDate": "2020-06-23T09:02:02Z", "type": "commit"}, {"oid": "44c578871806ed0b2412d5341093aced907f4e71", "url": "https://github.com/apache/ozone/commit/44c578871806ed0b2412d5341093aced907f4e71", "message": "fix review issues and resolve the conflict.", "committedDate": "2020-06-23T09:02:02Z", "type": "forcePushed"}]}