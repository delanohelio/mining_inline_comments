{"pr_number": 12643, "pr_title": "Prevent removeBlock from waiting indefinitly", "pr_createdAt": "2020-12-15T06:18:47Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/12643", "timeline": [{"oid": "26286c8ad0d517f6881590ec8582cdd1eb242162", "url": "https://github.com/Alluxio/alluxio/commit/26286c8ad0d517f6881590ec8582cdd1eb242162", "message": "Prevent removeBlock from waiting indefinitly", "committedDate": "2020-12-15T18:12:55Z", "type": "commit"}, {"oid": "26286c8ad0d517f6881590ec8582cdd1eb242162", "url": "https://github.com/Alluxio/alluxio/commit/26286c8ad0d517f6881590ec8582cdd1eb242162", "message": "Prevent removeBlock from waiting indefinitly", "committedDate": "2020-12-15T18:12:55Z", "type": "forcePushed"}, {"oid": "b48d65307514b4c927c755657805d6b8255ac5d7", "url": "https://github.com/Alluxio/alluxio/commit/b48d65307514b4c927c755657805d6b8255ac5d7", "message": "Add more unit tests", "committedDate": "2020-12-15T18:59:00Z", "type": "commit"}, {"oid": "01c5c9d7b58be011a4db8612a78fa166b3053b05", "url": "https://github.com/Alluxio/alluxio/commit/01c5c9d7b58be011a4db8612a78fa166b3053b05", "message": "More unit tests on AsyncBlockRemover", "committedDate": "2020-12-15T21:17:43Z", "type": "commit"}, {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab", "url": "https://github.com/Alluxio/alluxio/commit/a53db7ccdc54861105d338fcc08150c1fa51a5ab", "message": "Cleanup", "committedDate": "2020-12-15T23:05:10Z", "type": "commit"}, {"oid": "a53db7ccdc54861105d338fcc08150c1fa51a5ab", "url": "https://github.com/Alluxio/alluxio/commit/a53db7ccdc54861105d338fcc08150c1fa51a5ab", "message": "Cleanup", "committedDate": "2020-12-15T23:05:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNTE0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544025149", "bodyText": "Maybe it would be better if you could abstract a private method lockBlock(long, long, BlockLockType, boolean useTryLock, long, unit), and add the following logic into this method\nif (useTryLock) {\n    try {\n     if (!lock.tryLock(time, unit)) {\n        LOG.warn(\"Failed to acquire lock for block {} after {} {}.  \"\n                + \"session: {}, blockLockType: {}, lock reference count = {}\",\n            blockId, time, unit, sessionId, blockLockType, blockLock.getReferenceCount());\n        return INVALID_LOCK_ID;\n      }\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();\n    }\n} else {\n  lock.lock()\n}\nIt can reduce redundancy code.", "author": "maobaolong", "createdAt": "2020-12-16T06:31:14Z", "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java", "diffHunk": "@@ -99,31 +99,60 @@ public BlockLockManager() {}\n    */\n   public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n     ClientRWLock blockLock = getBlockLock(blockId);\n-    Lock lock;\n-    if (blockLockType == BlockLockType.READ) {\n-      lock = blockLock.readLock();\n-    } else {\n-      // Make sure the session isn't already holding the block lock.\n-      if (sessionHoldsLock(sessionId, blockId)) {\n-        throw new IllegalStateException(String\n-            .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n-                + \" holds a lock on the block\", sessionId, blockId));\n-      }\n-      lock = blockLock.writeLock();\n+    Lock lock = blockLockType == BlockLockType.READ ? blockLock.readLock() : blockLock.writeLock();\n+    // Make sure the session isn't already holding the block lock.\n+    if (blockLockType == BlockLockType.WRITE && sessionHoldsLock(sessionId, blockId)) {\n+      throw new IllegalStateException(String\n+          .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n+              + \" holds a lock on the block\", sessionId, blockId));\n     }\n     lock.lock();\n     try {\n-      long lockId = LOCK_ID_GEN.getAndIncrement();\n-      try (LockResource r = new LockResource(mSharedMapsLock.writeLock())) {\n-        mLockIdToRecordMap.put(lockId, new LockRecord(sessionId, blockId, lock));\n-        Set<Long> sessionLockIds = mSessionIdToLockIdsMap.get(sessionId);\n-        if (sessionLockIds == null) {\n-          mSessionIdToLockIdsMap.put(sessionId, Sets.newHashSet(lockId));\n-        } else {\n-          sessionLockIds.add(lockId);\n-        }\n+      return allocateLockId(sessionId, blockId, lock);\n+    } catch (Throwable e) {\n+      // If an unexpected exception occurs, we should release the lock to be conservative.\n+      unlock(lock, blockId);\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Tries to lock a block within the given time.\n+   * Note that even if this block does not exist, a lock id is still returned.\n+   *\n+   * If all {@link PropertyKey#WORKER_TIERED_STORE_BLOCK_LOCKS} are already in use and no lock has\n+   * been allocated for the specified block, this method will need to wait until a lock can be\n+   * acquired from the lock pool.\n+   *\n+   * @param sessionId the session id\n+   * @param blockId the block id\n+   * @param blockLockType {@link BlockLockType#READ} or {@link BlockLockType#WRITE}\n+   * @param time the maximum time to wait for the lock\n+   * @param unit the time unit of the {@code time} argument\n+   * @return lock id or INVALID_LOCK_ID if not able to lock within the given time\n+   */\n+  public long tryLockBlock(long sessionId, long blockId, BlockLockType blockLockType,\n+      long time, TimeUnit unit) {\n+    ClientRWLock blockLock = getBlockLock(blockId);\n+    Lock lock = blockLockType == BlockLockType.READ ? blockLock.readLock() : blockLock.writeLock();\n+    // Make sure the session isn't already holding the block lock.\n+    if (blockLockType == BlockLockType.WRITE && sessionHoldsLock(sessionId, blockId)) {\n+      throw new IllegalStateException(String\n+          .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n+              + \" holds a lock on the block\", sessionId, blockId));\n+    }\n+    try {", "originalCommit": "a53db7ccdc54861105d338fcc08150c1fa51a5ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2OTI0OA==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544069248", "bodyText": "in case useTryLock=false, lockBlock(long, long, BlockLockType, boolean useTryLock, long, unit)  requires some used time unit value. This is not a good way for an API. I would avoid convoluting two methods", "author": "apc999", "createdAt": "2020-12-16T07:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNTE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4OTA5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544089097", "bodyText": "@apc999 Sorry for not clarify the detail, I mean create a private method private void lockBlock(long, long, BlockLockType, boolean useTryLock, long, unit), so it's not an API, you can keep the two method lockBlock and tryLockBlock as the public method to be API for outer callee.", "author": "maobaolong", "createdAt": "2020-12-16T08:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNTE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5NDA1Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544094057", "bodyText": "The full changes I suggested is\n  public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n    return internalLockBlock(sessionId, blockId, blockLockType, false, -1, null);\n  }\n\n  public long tryLockBlock(long sessionId, long blockId, BlockLockType blockLockType,\n      long time, TimeUnit unit) {\n    return internalLockBlock(sessionId, blockId, blockLockType, true, time, unit);\n  }\n\n  private long internalLockBlock(long sessionId, long blockId, BlockLockType blockLockType,\n      boolean useTryLock, long time, TimeUnit unit) {\n    ClientRWLock blockLock = getBlockLock(blockId);\n    Lock lock = blockLockType == BlockLockType.READ ? blockLock.readLock() : blockLock.writeLock();\n    // Make sure the session isn't already holding the block lock.\n    if (blockLockType == BlockLockType.WRITE && sessionHoldsLock(sessionId, blockId)) {\n      throw new IllegalStateException(String\n          .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n              + \" holds a lock on the block\", sessionId, blockId));\n    }\n    if (useTryLock) {\n      try {\n        if (!lock.tryLock(time, unit)) {\n          LOG.warn(\"Failed to acquire lock for block {} after {} {}.  \"\n                  + \"session: {}, blockLockType: {}, lock reference count = {}\",\n              blockId, time, unit, sessionId, blockLockType,\n              blockLock.getReferenceCount());\n          return INVALID_LOCK_ID;\n        }\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    } else {\n      lock.lock();\n    }\n    try {\n      return allocateLockId(sessionId, blockId, lock);\n    } catch (Throwable e) {\n      // If an unexpected exception occurs, we should release the lock to be conservative.\n      unlock(lock, blockId);\n      throw e;\n    }\n  }", "author": "maobaolong", "createdAt": "2020-12-16T08:13:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNTE0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDU2ODI0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544568249", "bodyText": "good call. I adopted what you suggested here. Thanks ! @maobaolong", "author": "apc999", "createdAt": "2020-12-16T19:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAyNTE0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "chunk": "diff --git a/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java b/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java\nindex fa9345e7dc..bdf59e35dd 100644\n--- a/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java\n+++ b/core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java\n\n@@ -98,22 +100,7 @@ public final class BlockLockManager {\n    * @return lock id\n    */\n   public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n-    ClientRWLock blockLock = getBlockLock(blockId);\n-    Lock lock = blockLockType == BlockLockType.READ ? blockLock.readLock() : blockLock.writeLock();\n-    // Make sure the session isn't already holding the block lock.\n-    if (blockLockType == BlockLockType.WRITE && sessionHoldsLock(sessionId, blockId)) {\n-      throw new IllegalStateException(String\n-          .format(\"Session %s attempted to take a write lock on block %s, but the session already\"\n-              + \" holds a lock on the block\", sessionId, blockId));\n-    }\n-    lock.lock();\n-    try {\n-      return allocateLockId(sessionId, blockId, lock);\n-    } catch (Throwable e) {\n-      // If an unexpected exception occurs, we should release the lock to be conservative.\n-      unlock(lock, blockId);\n-      throw e;\n-    }\n+    return lockBlockInternal(sessionId, blockId, blockLockType, true, null, null);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzODQ5Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544038492", "bodyText": "Just a question:\nWhen we meet this exception, we need more information to know what has happened, something like who(sessionId) hold this block write lock, how long has been held by this session? If user has already know there are something wrong with the session client, is there a way to let user/admin to clear the specific session's locks? So that, we don't have to wait the session timeout.", "author": "maobaolong", "createdAt": "2020-12-16T06:46:59Z", "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -378,8 +379,11 @@ public void removeBlock(long sessionId, long blockId)\n   public void removeBlock(long sessionId, long blockId, BlockStoreLocation location)\n       throws InvalidWorkerStateException, BlockDoesNotExistException, IOException {\n     LOG.debug(\"removeBlock: sessionId={}, blockId={}, location={}\", sessionId, blockId, location);\n-    long lockId = mLockManager.lockBlock(sessionId, blockId, BlockLockType.WRITE);\n-\n+    long lockId = mLockManager.tryLockBlock(sessionId, blockId, BlockLockType.WRITE,\n+        REMOVE_BLOCK_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n+    if (lockId == BlockLockManager.INVALID_LOCK_ID) {\n+      throw new IOException(String.format(\"Can not acquire lock for block %d\", blockId));", "originalCommit": "a53db7ccdc54861105d338fcc08150c1fa51a5ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA4Mzc2MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544083761", "bodyText": "good call. I added more info.\nCurrently we don't have info like how long the lock is hold and whichelse sessions hold locks. That's why I mentioned today the LockInfo design might benefit Worker better than Master.\nWe also don't have ways to clean the session by admin. Might be a good thing to have.", "author": "apc999", "createdAt": "2020-12-16T07:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzODQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5MDQxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544090419", "bodyText": "@apc999 OK, @runzhiwang It seems your design can be useful.", "author": "maobaolong", "createdAt": "2020-12-16T08:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzODQ5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA5NTcyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544095729", "bodyText": "Currently we don't have info like how long the lock is hold and whichelse sessions hold locks. That's why I mentioned today the LockInfo design might benefit Worker better than Master.\n\n@apc999 @maobaolong Okay, I add the support for worker in my design.", "author": "runzhiwang", "createdAt": "2020-12-16T08:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDAzODQ5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "96ffe7b570ee4510e174956210bae93e707b2360", "chunk": "diff --git a/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java b/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java\nindex d00afd666c..f14d191b1f 100644\n--- a/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java\n+++ b/core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java\n\n@@ -382,7 +382,9 @@ public class TieredBlockStore implements BlockStore {\n     long lockId = mLockManager.tryLockBlock(sessionId, blockId, BlockLockType.WRITE,\n         REMOVE_BLOCK_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n     if (lockId == BlockLockManager.INVALID_LOCK_ID) {\n-      throw new IOException(String.format(\"Can not acquire lock for block %d\", blockId));\n+      throw new IOException(\n+          String.format(\"Can not acquire lock to remove block %d for session %d after %d ms\",\n+              blockId, sessionId, REMOVE_BLOCK_TIMEOUT_MS));\n     }\n     BlockMeta blockMeta;\n     try (LockResource r = new LockResource(mMetadataReadLock)) {\n"}}, {"oid": "96ffe7b570ee4510e174956210bae93e707b2360", "url": "https://github.com/Alluxio/alluxio/commit/96ffe7b570ee4510e174956210bae93e707b2360", "message": "Address comments", "committedDate": "2020-12-16T07:50:54Z", "type": "commit"}, {"oid": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "url": "https://github.com/Alluxio/alluxio/commit/f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "message": "Address comments", "committedDate": "2020-12-16T19:34:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNDQxNw==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544624417", "bodyText": "will this still log the stack of the Exception?", "author": "gpang", "createdAt": "2020-12-16T21:09:01Z", "path": "core/server/worker/src/main/java/alluxio/worker/block/AsyncBlockRemover.java", "diffHunk": "@@ -110,41 +122,31 @@ public void shutDown() {\n   }\n \n   private class BlockRemover implements Runnable {\n-    private String mThreadName;\n-\n     @Override\n     public void run() {\n-      mThreadName = Thread.currentThread().getName();\n-      long blockToBeRemoved;\n+      String threadName = Thread.currentThread().getName();\n       while (true) {\n-        blockToBeRemoved = INVALID_BLOCK_ID;\n+        Long blockToBeRemoved = null;\n         try {\n           blockToBeRemoved = mBlocksToRemove.take();\n           mTakeCount.inc();\n           mBlockWorker.removeBlock(Sessions.MASTER_COMMAND_SESSION_ID, blockToBeRemoved);\n           mRemovedSuccessCount.inc();\n-          LOG.debug(\"Block {} is removed in thread {}.\", blockToBeRemoved, mThreadName);\n+          LOG.debug(\"Block {} is removed in thread {}.\", blockToBeRemoved, threadName);\n         } catch (InterruptedException e) {\n           Thread.currentThread().interrupt();\n           // Only log warning if interrupted not due to a shutdown.\n           if (!mShutdown) {\n-            LOG.warn(\"{} got interrupted while it was cleaning block {}.\", mThreadName,\n+            LOG.warn(\"{} got interrupted while it was cleaning block {}.\", threadName,\n                 blockToBeRemoved);\n           }\n           break;\n-        } catch (IOException e) {\n-          LOG.warn(\"IOException occurred while {} was cleaning block {}, exception is {}.\",\n-              mThreadName, blockToBeRemoved, e.getMessage());\n-        } catch (BlockDoesNotExistException e) {\n-          LOG.warn(\"{}: block {} may be deleted already. exception is {}.\",\n-              mThreadName, blockToBeRemoved, e.getMessage());\n-        } catch (InvalidWorkerStateException e) {\n-          LOG.warn(\"{}: invalid block state for block {}, exception is {}.\",\n-              mThreadName, blockToBeRemoved, e.getMessage());\n         } catch (Exception e) {\n-          LOG.warn(\"Unexpected exception: {}.\", e);\n+          LOG.warn(\"Failed to remove block {} instructed by master. This is best-effort and \"\n+              + \"will be tried later. threadName {}, error {}\", blockToBeRemoved,\n+              threadName, e.getMessage());", "originalCommit": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY4MzcyMA==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544683720", "bodyText": "no, neither log message before this PR (which prints e.toString())", "author": "apc999", "createdAt": "2020-12-16T22:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyNDQxNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYyOTYwOA==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544629608", "bodyText": "This will either wait for a free lock, or timeout (if the timeout is set), right?", "author": "gpang", "createdAt": "2020-12-16T21:18:02Z", "path": "core/server/worker/src/main/java/alluxio/worker/block/BlockLockManager.java", "diffHunk": "@@ -98,20 +100,57 @@ public BlockLockManager() {}\n    * @return lock id\n    */\n   public long lockBlock(long sessionId, long blockId, BlockLockType blockLockType) {\n+    return lockBlockInternal(sessionId, blockId, blockLockType, true, null, null);\n+  }\n+\n+  /**\n+   * Tries to lock a block within the given time.\n+   * Note that even if this block does not exist, a lock id is still returned.\n+   *\n+   * If all {@link PropertyKey#WORKER_TIERED_STORE_BLOCK_LOCKS} are already in use and no lock has\n+   * been allocated for the specified block, this method will need to wait until a lock can be\n+   * acquired from the lock pool.", "originalCommit": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYzNzYxMw==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544637613", "bodyText": "Is this only called by the async block remover? Are there any other callers which may be affected by the new locking behavior?", "author": "gpang", "createdAt": "2020-12-16T21:31:52Z", "path": "core/server/worker/src/main/java/alluxio/worker/block/TieredBlockStore.java", "diffHunk": "@@ -378,8 +379,13 @@ public void removeBlock(long sessionId, long blockId)\n   public void removeBlock(long sessionId, long blockId, BlockStoreLocation location)", "originalCommit": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MDEyMA==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r544640120", "bodyText": "If all the removes failed, why is this list still empty?", "author": "gpang", "createdAt": "2020-12-16T21:36:24Z", "path": "core/server/worker/src/test/java/alluxio/worker/block/AsyncBlockRemoverTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.worker.block;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.Mockito.doAnswer;\n+\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+/**\n+ * Tests for AsyncBlockRemover.\n+ */\n+public class AsyncBlockRemoverTest {\n+  private AsyncBlockRemover mRemover;\n+  private final BlockingQueue<Long> mBlocksToRemove = new LinkedBlockingQueue<>();\n+  private final Set<Long> mBlocksTriedToRemoved =\n+      Collections.newSetFromMap(new ConcurrentHashMap<>());\n+  private final BlockWorker mMockWorker = Mockito.mock(BlockWorker.class);\n+\n+  @Test\n+  public void blockRemove() throws Exception {\n+    doAnswer(args -> {\n+      // keeps track the blocks to remove\n+      mBlocksTriedToRemoved.add(args.getArgument(1));\n+      return null;\n+    }).when(mMockWorker).removeBlock(anyLong(), anyLong());\n+    mRemover = new AsyncBlockRemover(mMockWorker, 10, mBlocksToRemove,\n+        Collections.newSetFromMap(new ConcurrentHashMap<>()));\n+    List<Long> blocks = new ArrayList<>();\n+    for (long i = 0; i < 100; i++) {\n+      blocks.add(i);\n+    }\n+    mRemover.addBlocksToDelete(blocks);\n+    CommonUtils.waitFor(\"async block removal completed\",\n+        () -> mBlocksTriedToRemoved.size() == blocks.size(),\n+        WaitForOptions.defaults().setTimeoutMs(10000));\n+    assertEquals(0, mBlocksToRemove.size());\n+  }\n+\n+  @Test\n+  public void failedBlockRemove() throws Exception {\n+    doAnswer(args -> {\n+      // keeps track the blocks to remove\n+      mBlocksTriedToRemoved.add(args.getArgument(1));\n+      // throw exception\n+      throw new IOException(\"Failed to remove block\");\n+    }).when(mMockWorker).removeBlock(anyLong(), anyLong());\n+    mRemover = new AsyncBlockRemover(mMockWorker, 10, mBlocksToRemove,\n+        Collections.newSetFromMap(new ConcurrentHashMap<>()));\n+    List<Long> blocks = new ArrayList<>();\n+    for (long i = 0; i < 100; i++) {\n+      blocks.add(i);\n+    }\n+    mRemover.addBlocksToDelete(blocks);\n+    CommonUtils.waitFor(\"async block removal completed\",\n+        () -> mBlocksTriedToRemoved.size() == blocks.size(),\n+        WaitForOptions.defaults().setTimeoutMs(10000));\n+    assertEquals(0, mBlocksToRemove.size());", "originalCommit": "f0dc49a2d266a0be2b14eda8277feaf646f8e6fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ5MTEyNg==", "url": "https://github.com/Alluxio/alluxio/pull/12643#discussion_r545491126", "bodyText": "@gpang I think because of IOException has been caught by BlockRemover#run, and continue the loop, so it can drain out the mBlocksToRemove.", "author": "maobaolong", "createdAt": "2020-12-18T00:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDY0MDEyMA=="}], "type": "inlineReview", "revised_code": null}]}