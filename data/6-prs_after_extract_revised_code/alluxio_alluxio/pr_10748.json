{"pr_number": 10748, "pr_title": "Implement a User-Side Alluxio Local Cache", "pr_createdAt": "2020-01-14T23:12:06Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/10748", "timeline": [{"oid": "63bfd68e85e74151d73cc4bce8c20e95023a137d", "url": "https://github.com/Alluxio/alluxio/commit/63bfd68e85e74151d73cc4bce8c20e95023a137d", "message": "Refactor FileSystem Interface\n\nMotivation\n- Simplify the logic to implement a new FileSystem class. E.g.,\nseparating the logic to handle file system instance cache as well as\nreducing the set of methods to implement.\n\nDetails:\n- Move some convenience methods from `BaseFileSystem` to `FileSystem`\nInterface as default implementation. So in the future, other\nimplementing class only needs to implement the non-default methods to\navoid code duplication.\n- Move `FileSystem.Cache` outside the interface as `FileSystemCache` to\nprevent future confusion and also to make the interface thinner\n- Rename `CachingFileSystem` to `MetadataCachingBaseFileSystem` to avoid\nconfusion\n- Consolidate the logic of Caching `FileSystem` Instances inside\n`FileSystemCache` and `InstanceCachingFileSystem`, rather than leaving\ncache insertion in `FileSystem` and cache removal in implementing\nclasses like `BaseFileSystem`\n\npr-link: Alluxio/alluxio#10679\nchange-id: cid-57acfc3f6a00a1bc06b326bd76c493340271442c", "committedDate": "2020-01-02T21:19:52Z", "type": "commit"}, {"oid": "03964d6d061432139949769566d68d7dc9c4ec98", "url": "https://github.com/Alluxio/alluxio/commit/03964d6d061432139949769566d68d7dc9c4ec98", "message": "Add skeleton implementation\n\nIntroduce local cache on client side\n\npr-link: Alluxio/alluxio#10694\nchange-id: cid-71def4efc5b7a8241c097954fd1fb4e4a1bc273f", "committedDate": "2020-01-03T23:08:02Z", "type": "commit"}, {"oid": "53985c66f4a091d275dfa2f79808fbcabc65ada1", "url": "https://github.com/Alluxio/alluxio/commit/53985c66f4a091d275dfa2f79808fbcabc65ada1", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-03T23:45:12Z", "type": "commit"}, {"oid": "2c27b93fd8f9f042dcebd2893e5364225a8a53cb", "url": "https://github.com/Alluxio/alluxio/commit/2c27b93fd8f9f042dcebd2893e5364225a8a53cb", "message": "Update PageStore interface to use fileId and PageIndex\n\n\n\npr-link: Alluxio/alluxio#10697\nchange-id: cid-a79cf1518acac210b9bb19537995a75f57d88228", "committedDate": "2020-01-04T06:19:48Z", "type": "commit"}, {"oid": "b9d36a9f4f3f9aa545408af6816a0651807c76ad", "url": "https://github.com/Alluxio/alluxio/commit/b9d36a9f4f3f9aa545408af6816a0651807c76ad", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-06T07:06:28Z", "type": "commit"}, {"oid": "8313614ec502003c3960200e0d1d61158f4d24ba", "url": "https://github.com/Alluxio/alluxio/commit/8313614ec502003c3960200e0d1d61158f4d24ba", "message": "Merge branch 'lite' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-06T07:06:46Z", "type": "commit"}, {"oid": "7a14c6b75bca2a5aeb632b77bc4b70d9c1b196c7", "url": "https://github.com/Alluxio/alluxio/commit/7a14c6b75bca2a5aeb632b77bc4b70d9c1b196c7", "message": "Implement page stores\n\n\n\npr-link: Alluxio/alluxio#10703\nchange-id: cid-58f8774ccfc18b72324fa61fac366472bc066c95", "committedDate": "2020-01-10T18:32:35Z", "type": "commit"}, {"oid": "a249ce14ec9d13ff304b8723540b0beb6910e667", "url": "https://github.com/Alluxio/alluxio/commit/a249ce14ec9d13ff304b8723540b0beb6910e667", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-10T18:54:20Z", "type": "commit"}, {"oid": "b489b807d3f245cd409253fe703042f8f780ea00", "url": "https://github.com/Alluxio/alluxio/commit/b489b807d3f245cd409253fe703042f8f780ea00", "message": "[WIP] Implement read/posread for local cache fileinstream\n\nPositioned read and read have similar implementations, we could make a\nread internal and reuse some code if we introduce an object to hold the\nposition, but we have separate implementations in the\nAlluxioFileInStream.\n\npr-link: Alluxio/alluxio#10711\nchange-id: cid-8a7325545761b47ce183c4377770bfca591fac35", "committedDate": "2020-01-10T21:52:56Z", "type": "commit"}, {"oid": "82f257abde9f2bd6995323bc239dc56c9d645272", "url": "https://github.com/Alluxio/alluxio/commit/82f257abde9f2bd6995323bc239dc56c9d645272", "message": "Implement LocalCacheManager\n\n\n\npr-link: Alluxio/alluxio#10707\nchange-id: cid-ed5bbae85961daf918a4946e3a6207a61d0b9f87", "committedDate": "2020-01-12T06:39:25Z", "type": "commit"}, {"oid": "2c2541c497e825fdc2fc81cf087b17eb266a7093", "url": "https://github.com/Alluxio/alluxio/commit/2c2541c497e825fdc2fc81cf087b17eb266a7093", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-12T06:39:59Z", "type": "commit"}, {"oid": "a81878ad77b729d93723b062f12c4cbccb460eb8", "url": "https://github.com/Alluxio/alluxio/commit/a81878ad77b729d93723b062f12c4cbccb460eb8", "message": "Cleanup LocalCacheManager  Unit Test\n\nImprove unit test of `LocalCacheManager` by\n- removing PowerMock\n- instead of asserting on internal implementation (counting func calls),\nassert on cache state before and after.\n\npr-link: Alluxio/alluxio#10732\nchange-id: cid-cf31c4a45afb79af2f07b7677b1e89b979939996", "committedDate": "2020-01-13T21:29:11Z", "type": "commit"}, {"oid": "86285ac80436a3adee7eff06de64b250deef5506", "url": "https://github.com/Alluxio/alluxio/commit/86285ac80436a3adee7eff06de64b250deef5506", "message": "Add more tests for LocalCacheFileInStream\n\nSome of these won't pass until we adopt the new APIs.\n\npr-link: Alluxio/alluxio#10729\nchange-id: cid-acc3254291c4d17fbd4f9bf6413361337e4fcf66", "committedDate": "2020-01-13T23:04:59Z", "type": "commit"}, {"oid": "60d00234e259db7c5f3409f7fa90cafa051794f1", "url": "https://github.com/Alluxio/alluxio/commit/60d00234e259db7c5f3409f7fa90cafa051794f1", "message": "Implement positioned read\n\nThis PR also uses the newer API to do partial page reads correctly.\n\npr-link: Alluxio/alluxio#10737\nchange-id: cid-26b8b2b0c53d65aaa74b6b8c22cec2a2699f5cd5", "committedDate": "2020-01-14T08:04:03Z", "type": "commit"}, {"oid": "523d9b175dfe50c7818fb641c245fd8b795754ca", "url": "https://github.com/Alluxio/alluxio/commit/523d9b175dfe50c7818fb641c245fd8b795754ca", "message": "Implement client side cache evictor and metastore\n\nImplement a basic metastore and LRU evictor for client side cache.\n\npr-link: Alluxio/alluxio#10733\nchange-id: cid-995fa10d3181f4053d638f91ce7fd4af8897b72e", "committedDate": "2020-01-14T08:05:33Z", "type": "commit"}, {"oid": "6259ae4d788b0ff58e5a326324eb9332194dbb1a", "url": "https://github.com/Alluxio/alluxio/commit/6259ae4d788b0ff58e5a326324eb9332194dbb1a", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-14T08:07:06Z", "type": "commit"}, {"oid": "25154b45e5a85f2cc1c664edceec5df47373139c", "url": "https://github.com/Alluxio/alluxio/commit/25154b45e5a85f2cc1c664edceec5df47373139c", "message": "Fix PageStore FindBugs issues\n\nFixed following issues reported by findbugs:\n\n```\n[ERROR] Possible null pointer dereference in\nalluxio.client.file.cache.store.LocalPageStore.delete(PageId) due to\nreturn value of called method\n[alluxio.client.file.cache.store.LocalPageStore,\nalluxio.client.file.cache.store.LocalPageStore] Method invoked at\nLocalPageStore.java:[line 89]Known null at LocalPageStore.java:[line 89]\nNP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n[ERROR] Possible null pointer dereference in\nalluxio.client.file.cache.store.LocalPageStore.delete(PageId) due to\nreturn value of called method\n[alluxio.client.file.cache.store.LocalPageStore,\nalluxio.client.file.cache.store.LocalPageStore] Method invoked at\nLocalPageStore.java:[line 90]Known null at LocalPageStore.java:[line 90]\nNP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n[ERROR] Possible null pointer dereference in\nalluxio.client.file.cache.store.LocalPageStore.put(PageId, byte[]) due\nto return value of called method\n[alluxio.client.file.cache.store.LocalPageStore,\nalluxio.client.file.cache.store.LocalPageStore] Method invoked at\nLocalPageStore.java:[line 59]Known null at LocalPageStore.java:[line 59]\nNP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n[ERROR] alluxio.client.file.cache.store.LocalPageStore.delete(PageId)\nmay fail to close stream\n[alluxio.client.file.cache.store.LocalPageStore] At\nLocalPageStore.java:[line 89] OS_OPEN_STREAM\n[ERROR] Unused field:\nalluxio.client.file.cache.store.LocalPageStoreOptions.mRootDir\n[alluxio.client.file.cache.store.LocalPageStoreOptions] In\nLocalPageStoreOptions.java UUF_UNUSED_FIELD\n```\n\npr-link: Alluxio/alluxio#10743\nchange-id: cid-a54f0342af545a4f2f5eae32b9105bd3fe38c632", "committedDate": "2020-01-14T19:36:38Z", "type": "commit"}, {"oid": "3bf45304e5196b3b0cf04ac96c50209a65966b7f", "url": "https://github.com/Alluxio/alluxio/commit/3bf45304e5196b3b0cf04ac96c50209a65966b7f", "message": "Fix checkstyle for local cache fileinstream related classes\n\n\n\npr-link: Alluxio/alluxio#10744\nchange-id: cid-7fd019fb5a6470fb829aea0260898d4f36c144c0", "committedDate": "2020-01-14T19:38:25Z", "type": "commit"}, {"oid": "74932edcb60ca7b63130e42438849da125af761d", "url": "https://github.com/Alluxio/alluxio/commit/74932edcb60ca7b63130e42438849da125af761d", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-01-14T22:47:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNTkzNw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366635937", "bodyText": "@apc999 This needs to be public or reflection will not work", "author": "calvinjia", "createdAt": "2020-01-15T00:01:34Z", "path": "core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java", "diffHunk": "@@ -101,7 +101,7 @@\n    *\n    * @param fsContext file system context\n    */\n-  public BaseFileSystem(FileSystemContext fsContext) {\n+  protected BaseFileSystem(FileSystemContext fsContext) {", "originalCommit": "74932edcb60ca7b63130e42438849da125af761d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ab11cf76344cc898a9c677648f35f828c95fa627", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java b/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java\nindex 64315b9802..0ee9d15d1d 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java\n\n@@ -101,7 +101,7 @@ public class BaseFileSystem implements FileSystem {\n    *\n    * @param fsContext file system context\n    */\n-  protected BaseFileSystem(FileSystemContext fsContext) {\n+  public BaseFileSystem(FileSystemContext fsContext) {\n     mFsContext = fsContext;\n     mBlockStore = AlluxioBlockStore.create(fsContext);\n     mCloser.register(mFsContext);\n"}}, {"oid": "ab11cf76344cc898a9c677648f35f828c95fa627", "url": "https://github.com/Alluxio/alluxio/commit/ab11cf76344cc898a9c677648f35f828c95fa627", "message": "Revert a merge conflict resolution\n\n\n\npr-link: Alluxio/alluxio#10751\nchange-id: cid-26e83df64146a48abd82f9788ab5d4f466a4f8ce", "committedDate": "2020-01-15T00:08:19Z", "type": "commit"}, {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "url": "https://github.com/Alluxio/alluxio/commit/0f6a556bb73f02a026e4602381d62bf1855ca8f7", "message": "Fix some bugs and add new properties for client-side cache\n\nFixed index out of bound exception for cache manager locking.\nFixed exception when reading from stream with oversized buffer.\nAdded properties to configure page store directory and type.\n\npr-link: Alluxio/alluxio#10749\nchange-id: cid-84da2e962f967c990d25c1ff89f21639c6168227", "committedDate": "2020-01-15T01:57:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzE0NA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753144", "bodyText": "is this already a lazy init or just a TODO, @calvinjia ?", "author": "apc999", "createdAt": "2020-01-15T08:49:43Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object", "originalCommit": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex cf1e73b854..5a18b2c1ed 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -18,8 +18,11 @@ import alluxio.client.file.URIStatus;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.ClientMetrics;\n+import alluxio.metrics.MetricsSystem;\n import alluxio.util.io.BufferUtils;\n \n+import com.codahale.metrics.Counter;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Suppliers;\n import com.google.common.io.Closer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzY3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753672", "bodyText": "how shall we handle IOException here when reading cache? Assume we shall fallback to external stream? Currently the IOE will be escalated.", "author": "apc999", "createdAt": "2020-01-15T08:51:08Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {", "originalCommit": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex cf1e73b854..5a18b2c1ed 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -18,8 +18,11 @@ import alluxio.client.file.URIStatus;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.ClientMetrics;\n+import alluxio.metrics.MetricsSystem;\n import alluxio.util.io.BufferUtils;\n \n+import com.codahale.metrics.Counter;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Suppliers;\n import com.google.common.io.Closer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzkxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753919", "bodyText": "how shall we handle IOException here when reading cache? Assume we shall fallback to external stream? Currently the IOE will be escalated. Are we supposed to make the failure transparent for the application?", "author": "apc999", "createdAt": "2020-01-15T08:51:45Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {", "originalCommit": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex cf1e73b854..5a18b2c1ed 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -18,8 +18,11 @@ import alluxio.client.file.URIStatus;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.ClientMetrics;\n+import alluxio.metrics.MetricsSystem;\n import alluxio.util.io.BufferUtils;\n \n+import com.codahale.metrics.Counter;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Suppliers;\n import com.google.common.io.Closer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NDI4Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366754287", "bodyText": "how shall we handle failed put with IOE? shall we silently swallow the exception (w/ warning)?", "author": "apc999", "createdAt": "2020-01-15T08:52:37Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);", "originalCommit": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex cf1e73b854..5a18b2c1ed 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -18,8 +18,11 @@ import alluxio.client.file.URIStatus;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.ClientMetrics;\n+import alluxio.metrics.MetricsSystem;\n import alluxio.util.io.BufferUtils;\n \n+import com.codahale.metrics.Counter;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Suppliers;\n import com.google.common.io.Closer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NDUzNA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366754534", "bodyText": "handle IOException?", "author": "apc999", "createdAt": "2020-01-15T08:53:16Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);", "originalCommit": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex cf1e73b854..5a18b2c1ed 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -18,8 +18,11 @@ import alluxio.client.file.URIStatus;\n import alluxio.conf.PropertyKey;\n import alluxio.exception.AlluxioException;\n import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.ClientMetrics;\n+import alluxio.metrics.MetricsSystem;\n import alluxio.util.io.BufferUtils;\n \n+import com.codahale.metrics.Counter;\n import com.google.common.base.Preconditions;\n import com.google.common.base.Suppliers;\n import com.google.common.io.Closer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NTE4Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366755186", "bodyText": "what's the invariant when access evictor in terms of locking?", "author": "apc999", "createdAt": "2020-01-15T08:54:49Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;", "originalCommit": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2e4d8a0dcf415d803aa7295f2be78d63e6d0c4d0", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex f34a66a3a0..b772a79b45 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -34,12 +34,13 @@ import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class coordinates different components to respond for\n- * thread-safety and operate cache replacement policies.\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n  *\n  * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n  * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n- * performance benefits for various read workloads.\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n  *\n  * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n  * <ul>\n"}}, {"oid": "2e4d8a0dcf415d803aa7295f2be78d63e6d0c4d0", "url": "https://github.com/Alluxio/alluxio/commit/2e4d8a0dcf415d803aa7295f2be78d63e6d0c4d0", "message": "Update LocalCacheManager.java", "committedDate": "2020-01-15T16:59:19Z", "type": "commit"}, {"oid": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "url": "https://github.com/Alluxio/alluxio/commit/9a57d76c5c4d18c7d1f4404788633a0f48637502", "message": "Add metrics for cache hit/miss\n\nAdds 3 metrics\nnumber of bytes read from local cache\nnumber of bytes read from external store\nnumber of bytes requested from external store (may be less than bytes\nread because we read full pages)\n\npr-link: Alluxio/alluxio#10758\nchange-id: cid-e3bd3715f58f3018681db716b256a73a3d2b9e58", "committedDate": "2020-01-17T19:39:02Z", "type": "commit"}, {"oid": "fff850b07488f32a4035d027156d059f2ad9210f", "url": "https://github.com/Alluxio/alluxio/commit/fff850b07488f32a4035d027156d059f2ad9210f", "message": "Make further cleanup in Alluxio library\n\n\n\npr-link: Alluxio/alluxio#10753\nchange-id: cid-cb214012ac161c38fc6bec9da7e3b070bee14e0e", "committedDate": "2020-01-17T21:37:11Z", "type": "commit"}, {"oid": "3579609ffa007a59b775fe7f937ddef4408e50d0", "url": "https://github.com/Alluxio/alluxio/commit/3579609ffa007a59b775fe7f937ddef4408e50d0", "message": "Simplify page store creation\n\ncombine the factory methods of `PageStore` and `PageStoreOptions`.\n\npr-link: Alluxio/alluxio#10759\nchange-id: cid-404e7afd7b36ab93370676a4fe11d812181f9d74", "committedDate": "2020-01-18T02:06:36Z", "type": "commit"}, {"oid": "f14d640f9fd2c4f2be9a068d1838052a826107b5", "url": "https://github.com/Alluxio/alluxio/commit/f14d640f9fd2c4f2be9a068d1838052a826107b5", "message": "Merge remote-tracking branch 'upstream' into lite", "committedDate": "2020-01-18T06:31:10Z", "type": "commit"}, {"oid": "c4174cd381da82abdbc79f0a63429a8899efc6e5", "url": "https://github.com/Alluxio/alluxio/commit/c4174cd381da82abdbc79f0a63429a8899efc6e5", "message": "Optimize offset read from page store\n\nAdd a new offset read API on page store to eliminate buffer copy in\n`LocalCacheManager`.\n\npr-link: Alluxio/alluxio#10760\nchange-id: cid-5e932cecd9532f711fd9ace280fa8637e2a558c0", "committedDate": "2020-01-20T18:39:03Z", "type": "commit"}, {"oid": "100016fd134e9b4d3c165e306270d579db3cccc1", "url": "https://github.com/Alluxio/alluxio/commit/100016fd134e9b4d3c165e306270d579db3cccc1", "message": "Merge branch 'master' into lite", "committedDate": "2020-01-20T23:39:20Z", "type": "commit"}, {"oid": "5a938b66f35f28f4e0b3143c0eb2446e3399e34a", "url": "https://github.com/Alluxio/alluxio/commit/5a938b66f35f28f4e0b3143c0eb2446e3399e34a", "message": "Merge branch 'master' into lite", "committedDate": "2020-01-21T08:01:28Z", "type": "commit"}, {"oid": "5dfe0f9d35f17bc566d12e74af248f34fb6da045", "url": "https://github.com/Alluxio/alluxio/commit/5dfe0f9d35f17bc566d12e74af248f34fb6da045", "message": "Add integration tests for client side cache\n\n\n\npr-link: Alluxio/alluxio#10757\nchange-id: cid-fa2217a1f9409a63098a9ae37ab53fbf2b137468", "committedDate": "2020-01-21T21:39:47Z", "type": "commit"}, {"oid": "f559ac8bfbe6a042691d41682e85be70e77daac8", "url": "https://github.com/Alluxio/alluxio/commit/f559ac8bfbe6a042691d41682e85be70e77daac8", "message": "Merge branch 'master' into lite", "committedDate": "2020-01-24T00:31:37Z", "type": "commit"}, {"oid": "4925157df795b2cf22b458f97d1ab46b3ba8cb4c", "url": "https://github.com/Alluxio/alluxio/commit/4925157df795b2cf22b458f97d1ab46b3ba8cb4c", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite", "committedDate": "2020-02-03T21:51:48Z", "type": "commit"}, {"oid": "2c0cdc7134422c823deeb9fd50f785816c8d8c3a", "url": "https://github.com/Alluxio/alluxio/commit/2c0cdc7134422c823deeb9fd50f785816c8d8c3a", "message": "Refactor for local cache\n\nBetter division for the file system configuration and constructors.\n\npr-link: Alluxio/alluxio#10835\nchange-id: cid-4aaad495699af37db33b2fe1d666b74fb7fff442", "committedDate": "2020-02-04T22:26:25Z", "type": "commit"}, {"oid": "af6abe657b19ad8c769248513c0ad19aae94a5b1", "url": "https://github.com/Alluxio/alluxio/commit/af6abe657b19ad8c769248513c0ad19aae94a5b1", "message": "Add thread-safe annotation to evictor interface\n\n\n\npr-link: Alluxio/alluxio#10816\nchange-id: cid-c73647a651734fe14c9a499d7c014715f1f3c3bc", "committedDate": "2020-02-07T21:54:55Z", "type": "commit"}, {"oid": "723bd4613566253c4b02c4500450cec3ea618261", "url": "https://github.com/Alluxio/alluxio/commit/723bd4613566253c4b02c4500450cec3ea618261", "message": "Allow local cache to recover from existing files\n\nAdd functionality to detect previously cached data on local storage and\nreuse them if the data is compatible.\n\npr-link: Alluxio/alluxio#10776\nchange-id: cid-58ec9cb4ecd08cda92a3d84055232f5ce9245428", "committedDate": "2020-02-09T04:32:57Z", "type": "commit"}, {"oid": "c0c0e8feedbf7e0b0d4b6e669abc81cf42b2ce86", "url": "https://github.com/Alluxio/alluxio/commit/c0c0e8feedbf7e0b0d4b6e669abc81cf42b2ce86", "message": "Make page calculation in bytes on eviction\n\n\n\npr-link: Alluxio/alluxio#10847\nchange-id: cid-6af8945461f4a9aa8927177eaadc6fdf1d4eda95", "committedDate": "2020-02-10T22:49:42Z", "type": "commit"}, {"oid": "da5a7e29ecb873c58dbc1deff94e4ddbc829251f", "url": "https://github.com/Alluxio/alluxio/commit/da5a7e29ecb873c58dbc1deff94e4ddbc829251f", "message": "Merge with conflicts.", "committedDate": "2020-02-10T22:56:03Z", "type": "commit"}, {"oid": "144e6c2252ddedf5d8ba03970fa971bd6eab07b5", "url": "https://github.com/Alluxio/alluxio/commit/144e6c2252ddedf5d8ba03970fa971bd6eab07b5", "message": "Resolve conflicts.", "committedDate": "2020-02-10T23:13:36Z", "type": "commit"}, {"oid": "ab262c94a5291e8b95910e2d7facd619d8488654", "url": "https://github.com/Alluxio/alluxio/commit/ab262c94a5291e8b95910e2d7facd619d8488654", "message": "Merge openFile(URIStatus, ...).", "committedDate": "2020-02-10T23:18:48Z", "type": "commit"}, {"oid": "1a4f76250ad0542c3162a7b4ff196ec68cbcbbff", "url": "https://github.com/Alluxio/alluxio/commit/1a4f76250ad0542c3162a7b4ff196ec68cbcbbff", "message": "Address comments.", "committedDate": "2020-02-10T23:29:06Z", "type": "commit"}, {"oid": "c079aaa5a5c3b45bc4c77a4f7ecaebc8a417d922", "url": "https://github.com/Alluxio/alluxio/commit/c079aaa5a5c3b45bc4c77a4f7ecaebc8a417d922", "message": "Support external stores which do not read in full\n\nThis is consistent with InputStream's API.\n\npr-link: Alluxio/alluxio#10891\nchange-id: cid-e9bfdb6d79fe69b5926d040c2a382e07db305efa", "committedDate": "2020-02-12T01:05:33Z", "type": "commit"}, {"oid": "5230d8eb81507fac665476eca0e0c75e39de0680", "url": "https://github.com/Alluxio/alluxio/commit/5230d8eb81507fac665476eca0e0c75e39de0680", "message": "Refactor the client cache to use string file id\n\nThis allows certain client filesystem to use UUID as file id without\nworrying about collision.\n\npr-link: Alluxio/alluxio#10868\nchange-id: cid-5b17a25a9dec59f3a64907ae27a9d129bb15f975", "committedDate": "2020-02-12T07:24:14Z", "type": "commit"}, {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "url": "https://github.com/Alluxio/alluxio/commit/19b84fabf379640970e4af6f4e3d72cb433fe89d", "message": "Remove library property for local cache\n\n\n\npr-link: Alluxio/alluxio#10898\nchange-id: cid-4ef3917a0e367f83f72b8c92e45dc93f06d5d701", "committedDate": "2020-02-12T22:26:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDgyNg==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378560826", "bodyText": "should this be done through getClusterConf()?", "author": "ZacBlanco", "createdAt": "2020-02-12T22:55:31Z", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3NzY4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379077689", "bodyText": "We previously were trying to decouple filesystem creation from the file system context, but I don't think that is necessary anymore, I've reverted the changes. See: #10907", "author": "calvinjia", "createdAt": "2020-02-13T19:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDgyNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDkwNw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378560907", "bodyText": "same question", "author": "ZacBlanco", "createdAt": "2020-02-12T22:55:42Z", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n       Class[] ctorArgClasses = new Class[] {FileSystemContext.class};\n       Object[] ctorArgs = new Object[] {context};\n       FileSystem fs =\n           (FileSystem) CommonUtils.createNewClassInstance(fsClass, ctorArgClasses, ctorArgs);\n-      if (context.getClusterConf().getBoolean(PropertyKey.USER_LOCAL_CACHE_ENABLED)) {\n-        return new LocalCacheFileSystem(fs);\n+      if (conf.getBoolean(PropertyKey.USER_LOCAL_CACHE_ENABLED)) {", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTAzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378999031", "bodyText": "how is this different from the fileId? Can we add some info in the javadoc?", "author": "gpang", "createdAt": "2020-02-13T17:09:59Z", "path": "core/common/src/main/java/alluxio/wire/FileInfo.java", "diffHunk": "@@ -89,6 +90,13 @@ public long getFileId() {\n     return mFileId;\n   }\n \n+  /**\n+   * @return the file identifier", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTA3Nzc0NA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379077744", "bodyText": "Added: #10907", "author": "calvinjia", "createdAt": "2020-02-13T19:40:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTAzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "chunk": "diff --git a/core/common/src/main/java/alluxio/wire/FileInfo.java b/core/common/src/main/java/alluxio/wire/FileInfo.java\nindex 6444a43890..46806fb842 100644\n--- a/core/common/src/main/java/alluxio/wire/FileInfo.java\n+++ b/core/common/src/main/java/alluxio/wire/FileInfo.java\n\n@@ -91,7 +91,10 @@ public final class FileInfo implements Serializable {\n   }\n \n   /**\n-   * @return the file identifier\n+   *  Similar to {@link #getFileId()}, but returns in a string form, allowing for the use of\n+   *  non-long based ids.\n+   *\n+   *  @return the file identifier\n    */\n   public String getFileIdentifier() {\n     return mFileIdentifier != null ? mFileIdentifier : Long.toString(mFileId);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMjQyNw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379102427", "bodyText": "we can get rid of lots of powermock usages throughout the codebase with this :)", "author": "ZacBlanco", "createdAt": "2020-02-13T20:31:33Z", "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "diffHunk": "@@ -85,7 +85,7 @@\n  * so, because thread A holds the lock on {@link FileSystemContext}.\n  */\n @ThreadSafe\n-public final class FileSystemContext implements Closeable {\n+public class FileSystemContext implements Closeable {", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODcxOA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379118718", "bodyText": "is it simpler to just make this method synchronized?", "author": "ZacBlanco", "createdAt": "2020-02-13T21:07:29Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/evictor/LRUCacheEvictor.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.evictor;\n+\n+import alluxio.client.file.cache.CacheEvictor;\n+import alluxio.client.file.cache.PageId;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * LRU client-side cache eviction policy.\n+ */\n+@ThreadSafe\n+public class LRUCacheEvictor implements CacheEvictor {\n+  private static final int LINKED_HASH_MAP_INIT_CAPACITY = 200;\n+  private static final float LINKED_HASH_MAP_INIT_LOAD_FACTOR = 0.75f;\n+  private static final boolean LINKED_HASH_MAP_ACCESS_ORDERED = true;\n+  private static final boolean UNUSED_MAP_VALUE = true;\n+\n+  // TODO(feng): unify with worker side evictor\n+  private final Map<PageId, Boolean> mLRUCache =\n+      Collections.synchronizedMap(new LinkedHashMap<>(LINKED_HASH_MAP_INIT_CAPACITY,\n+          LINKED_HASH_MAP_INIT_LOAD_FACTOR, LINKED_HASH_MAP_ACCESS_ORDERED));\n+\n+  @Override\n+  public void updateOnGet(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnPut(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnDelete(PageId pageId) {\n+    mLRUCache.remove(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public PageId evict() {\n+    synchronized (mLRUCache) {", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTI5NA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379165294", "bodyText": "IMO finer grained synchronization is cleaner", "author": "calvinjia", "createdAt": "2020-02-13T22:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODcxOA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNTE1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379125156", "bodyText": "RocksDB is better-optimized for smaller values. Since pages are on the order of MB, there is probably some tuning in the default values for RocksPageStoreOptions that we can do to improve performance OOTB for many users. I am fine saving the work for a later PR\nReference discussion: https://github.com/facebook/rocksdb/issues/513", "author": "ZacBlanco", "createdAt": "2020-02-13T21:21:14Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;\n+  private static final byte[] CONF_KEY = \"CONF\".getBytes();\n+\n+  private final String mRoot;\n+  private final RocksDB mDb;\n+  private final AtomicLong mSize = new AtomicLong(0);\n+  private final AtomicLong mBytes = new AtomicLong(0);\n+  private final double mOverheadRatio;\n+\n+  /**\n+   * Creates a new instance of {@link PageStore} backed by RocksDB.\n+   *\n+   * @param options options for the rocks page store\n+   * @throws IOException when fails to create a {@link RocksPageStore}\n+   */\n+  public RocksPageStore(RocksPageStoreOptions options) throws IOException {\n+    Preconditions.checkArgument(options.getMaxPageSize() > 0);\n+    mRoot = options.getRootDir();\n+    // TODO(feng): consider making the overhead ratio configurable\n+    mOverheadRatio = (double) KEY_LEN / options.getMaxPageSize();\n+    Cache.PRocksPageStoreOptions pOptions = options.toProto();\n+    RocksDB.loadLibrary();\n+    RocksDB db = null;\n+    Options rocksOptions = new Options();\n+    rocksOptions.setCreateIfMissing(true);\n+    rocksOptions.setWriteBufferSize(options.getWriteBufferSize());\n+    rocksOptions.setCompressionType(options.getCompressionType());", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java b/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java\nindex bce3671c4f..2dc38072dc 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java\n\n@@ -44,7 +44,8 @@ import javax.annotation.Nullable;\n import javax.annotation.concurrent.NotThreadSafe;\n \n /**\n- * A page store implementation which utilizes rocksDB to persist the data.\n+ * A page store implementation which utilizes rocksDB to persist the data. This implementation\n+ * will not be included to client jar by default to reduce client jar size.\n  */\n @NotThreadSafe\n public class RocksPageStore implements PageStore {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTU2MA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379145560", "bodyText": "nit: should Local Cache be capitalized?", "author": "ZacBlanco", "createdAt": "2020-02-13T22:05:23Z", "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NTU4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379165585", "bodyText": "Updated: #10907", "author": "calvinjia", "createdAt": "2020-02-13T22:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "74af6bcb2bb3eae4af11132119ebd81d98b607b2", "chunk": "diff --git a/core/common/src/main/java/alluxio/metrics/MetricKey.java b/core/common/src/main/java/alluxio/metrics/MetricKey.java\nindex b67b93c007..92e1370f32 100644\n--- a/core/common/src/main/java/alluxio/metrics/MetricKey.java\n+++ b/core/common/src/main/java/alluxio/metrics/MetricKey.java\n\n@@ -765,7 +765,7 @@ public final class MetricKey implements Comparable<MetricKey> {\n       new Builder(Name.CLIENT_BYTES_WRITTEN_LOCAL_THROUGHPUT)\n           .setDescription(\"Bytes throughput short-circuit written to local storage by this client\")\n           .setMetricType(MetricType.METER)\n-          .setIsClusterAggregated(true)\n+          .setIsClusterAggregated(false)\n           .build();\n   public static final MetricKey CLIENT_BYTES_WRITTEN_UFS =\n       new Builder(Name.CLIENT_BYTES_WRITTEN_UFS)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTgyMA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379145820", "bodyText": "what is CacheBytesReadExternal? Should we reference the variable instead?", "author": "ZacBlanco", "createdAt": "2020-02-13T22:05:54Z", "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_EXTERNAL)\n+          .setDescription(\"Total number of bytes read from external storage due to a cache miss \"\n+              + \"on the local cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL)\n+          .setDescription(\"Total number of bytes the user requested to read which resulted in a \"\n+              + \"cache miss. This number may be smaller than CacheBytesReadExternal due to chunk \"", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NjAxMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379166011", "bodyText": "Updated: #10907", "author": "calvinjia", "createdAt": "2020-02-13T22:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "74af6bcb2bb3eae4af11132119ebd81d98b607b2", "chunk": "diff --git a/core/common/src/main/java/alluxio/metrics/MetricKey.java b/core/common/src/main/java/alluxio/metrics/MetricKey.java\nindex b67b93c007..92e1370f32 100644\n--- a/core/common/src/main/java/alluxio/metrics/MetricKey.java\n+++ b/core/common/src/main/java/alluxio/metrics/MetricKey.java\n\n@@ -765,7 +765,7 @@ public final class MetricKey implements Comparable<MetricKey> {\n       new Builder(Name.CLIENT_BYTES_WRITTEN_LOCAL_THROUGHPUT)\n           .setDescription(\"Bytes throughput short-circuit written to local storage by this client\")\n           .setMetricType(MetricType.METER)\n-          .setIsClusterAggregated(true)\n+          .setIsClusterAggregated(false)\n           .build();\n   public static final MetricKey CLIENT_BYTES_WRITTEN_UFS =\n       new Builder(Name.CLIENT_BYTES_WRITTEN_UFS)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379137806", "bodyText": "HashMap is not thread-safe. Is that ok?", "author": "gpang", "createdAt": "2020-02-13T21:48:57Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/DefaultMetaStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The default implementation of a metadata store for pages stored in cache.\n+ */\n+public class DefaultMetaStore implements MetaStore {\n+  /** A map from PageId to page info. */\n+  private final Map<PageId, PageInfo> mPageMap = new HashMap<>();", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NjQwOA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379166408", "bodyText": "I think we are handling locking in LocalCacheManager, @bf8086", "author": "calvinjia", "createdAt": "2020-02-13T22:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3MjA4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379172083", "bodyText": "Yeah the LocalCacheManager manages the locks for metadata operations.", "author": "bf8086", "createdAt": "2020-02-13T23:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDU5OA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379144598", "bodyText": "This looks like it shares a lot of code with read(). Can it be refactored/reused?", "author": "gpang", "createdAt": "2020-02-13T22:03:02Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2NzQ4NA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379167484", "bodyText": "We weren't able to refactor much of it, it comes down to updating the instance variable mPosition vs a local variable. Do you have any suggestions? FWIW the other implementations of read/positionedread are also duplicated.", "author": "calvinjia", "createdAt": "2020-02-13T23:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDU5OA=="}], "type": "inlineReview", "revised_code": {"commit": "13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex 00b0cd668e..33741e63f8 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -242,9 +242,9 @@ public class LocalCacheFileInStream extends FileInStream {\n     }\n     Preconditions.checkState(\n         bytesRead == len || (bytesRead < len && currentPosition == mStatus.getLength()),\n-        \"Invalid number of bytes read - \"\n+        \"Invalid number of bytes positionread - read from position = %d, \"\n             + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n-        len, bytesRead, mStatus.getLength() - currentPosition);\n+        pos, len, bytesRead, mStatus.getLength() - currentPosition);\n     return bytesRead;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDkwMA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379144900", "bodyText": "this looks like the same exact error message as read(). Can we make them distinct?", "author": "gpang", "createdAt": "2020-02-13T22:03:43Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);\n+          System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+        }\n+      }\n+    }\n+    Preconditions.checkState(\n+        bytesRead == len || (bytesRead < len && currentPosition == mStatus.getLength()),\n+        \"Invalid number of bytes read - \"", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2Nzk4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379167983", "bodyText": "Updated: #10907", "author": "calvinjia", "createdAt": "2020-02-13T23:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDkwMA=="}], "type": "inlineReview", "revised_code": {"commit": "13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex 00b0cd668e..33741e63f8 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -242,9 +242,9 @@ public class LocalCacheFileInStream extends FileInStream {\n     }\n     Preconditions.checkState(\n         bytesRead == len || (bytesRead < len && currentPosition == mStatus.getLength()),\n-        \"Invalid number of bytes read - \"\n+        \"Invalid number of bytes positionread - read from position = %d, \"\n             + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n-        len, bytesRead, mStatus.getLength() - currentPosition);\n+        pos, len, bytesRead, mStatus.getLength() - currentPosition);\n     return bytesRead;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzkwMw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379147903", "bodyText": "Would this be easier if using something like AtomicReference?", "author": "gpang", "createdAt": "2020-02-13T22:10:48Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.DelegatingFileSystem;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * A FileSystem implementation with a local cache.\n+ */\n+public class LocalCacheFileSystem extends DelegatingFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheFileSystem.class);\n+  private static Optional<CacheManager> sCacheManager;\n+\n+  private final AlluxioConfiguration mConf;\n+\n+  /**\n+   * @param fs a FileSystem instance to query on local cache miss\n+   * @param conf the configuration, only respected for the first call\n+   */\n+  @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+      value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\",\n+      justification = \"write to static is made threadsafe\")\n+  public LocalCacheFileSystem(FileSystem fs, AlluxioConfiguration conf) {\n+    super(fs);\n+    // TODO(feng): support multiple cache managers\n+    if (sCacheManager == null) {\n+      synchronized (LocalCacheFileSystem.class) {", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2OTcxNA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379169714", "bodyText": "Are you suggesting to use getAndSet, that requires creating a new instance of cachemanager each time?", "author": "calvinjia", "createdAt": "2020-02-13T23:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzkwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0ODk5MQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379148991", "bodyText": "Could this use com.google.common.util.concurrent.Striped?", "author": "gpang", "createdAt": "2020-02-13T22:13:22Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTY2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379149662", "bodyText": "what are the locking rules for locking both a meta lock and a page lock?", "author": "gpang", "createdAt": "2020-02-13T22:14:56Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTc0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379149749", "bodyText": "Is anything allowed to lock more than 1 page lock?", "author": "gpang", "createdAt": "2020-02-13T22:15:07Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDM2MA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379150360", "bodyText": "Can you make this a more descriptive debug message?", "author": "gpang", "createdAt": "2020-02-13T22:16:35Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDQ1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379150451", "bodyText": "Can you improve this message?", "author": "gpang", "createdAt": "2020-02-13T22:16:47Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;\n+        if (enoughSpace) {\n+          mMetaStore.addPage(pageId, new PageInfo(pageId, page.length));\n+        } else {\n+          victim = mEvictor.evict();\n+          victimPageInfo = mMetaStore.getPageInfo(victim);\n+        }\n+      } catch (PageNotFoundException e) {\n+        throw new IllegalStateException(\"we shall not reach here\");", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1Mjc1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379152759", "bodyText": "what is a file id, and why is it a string?", "author": "gpang", "createdAt": "2020-02-13T22:22:34Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageId.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class identifies a single cached page.\n+ */\n+@ThreadSafe\n+public class PageId {\n+  private final String mFileId;", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE2ODc1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379168756", "bodyText": "fileID will be used to key the pages, any unique identifier will be ok", "author": "calvinjia", "createdAt": "2020-02-13T23:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1Mjc1OQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NjI3MA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379156270", "bodyText": "What is the format of the key?", "author": "gpang", "createdAt": "2020-02-13T22:30:49Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;", "originalCommit": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE3Mjg4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379172883", "bodyText": "It is PageIndex(long) + FileIdentifier(String). This constant here is only used for estimation of the overhead.", "author": "bf8086", "createdAt": "2020-02-13T23:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NjI3MA=="}], "type": "inlineReview", "revised_code": {"commit": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java b/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java\nindex bce3671c4f..2dc38072dc 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java\n\n@@ -44,7 +44,8 @@ import javax.annotation.Nullable;\n import javax.annotation.concurrent.NotThreadSafe;\n \n /**\n- * A page store implementation which utilizes rocksDB to persist the data.\n+ * A page store implementation which utilizes rocksDB to persist the data. This implementation\n+ * will not be included to client jar by default to reduce client jar size.\n  */\n @NotThreadSafe\n public class RocksPageStore implements PageStore {\n"}}, {"oid": "74af6bcb2bb3eae4af11132119ebd81d98b607b2", "url": "https://github.com/Alluxio/alluxio/commit/74af6bcb2bb3eae4af11132119ebd81d98b607b2", "message": "Merge branch 'master' into lite", "committedDate": "2020-02-14T00:44:36Z", "type": "commit"}, {"oid": "13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "url": "https://github.com/Alluxio/alluxio/commit/13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "message": "Improve local cache\n\nAddresses comments for #10748\n\npr-link: Alluxio/alluxio#10907\nchange-id: cid-c1a61a201f0c8705e9934da18d0d2609569ee14a", "committedDate": "2020-02-14T02:48:06Z", "type": "commit"}, {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "url": "https://github.com/Alluxio/alluxio/commit/baef1ebe66f7398b680b2e697510a3fc563c4b83", "message": "Exclude dependency on rocksdb from client jar\n\nTested with my local build, client jar size reduced from 40MB to 26MB\n\npr-link: Alluxio/alluxio#10916\nchange-id: cid-bfb804d70ea61104fa3704c07fa54a3456e51556", "committedDate": "2020-02-14T04:16:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTc3MA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379639770", "bodyText": "@bf8086 From what I understand, mPageStore.bytes() is not protected by mMetaLock, so if enoughSpace is true here, there is no guarantee that it will continue to hold true.", "author": "calvinjia", "createdAt": "2020-02-14T20:53:40Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;", "originalCommit": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MDE5NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379640195", "bodyText": "Instead of mPageStore.bytes() I think we need to use something like mMetastore.bytes()? Since we can guarantee that is not changing and we will reserve the required space while still holding the metalock", "author": "calvinjia", "createdAt": "2020-02-14T20:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTc3MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MjYwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379642601", "bodyText": "Since this is best effort, could make this API not throw exception, even on write failure?", "author": "calvinjia", "createdAt": "2020-02-14T21:01:36Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager extends AutoCloseable  {\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(AlluxioConfiguration conf) throws IOException {\n+    // TODO(feng): make cache manager type configurable when we introduce more implementations.\n+    return LocalCacheManager.create(conf);\n+  }\n+\n+  /**\n+   * Writes a new page from a source channel with best effort. It is possible that this put\n+   * operation returns without page written due to transient behavior not due to failures writing\n+   * to disks.\n+   *\n+   * @param pageId page identifier\n+   * @param page page data\n+   * @throws IOException if error happens when writing the page to disk\n+   * @return true on a successful put or false due to transient\n+   */\n+  boolean put(PageId pageId, byte[] page) throws IOException;", "originalCommit": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MjgzMA==", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379642830", "bodyText": "Could we default to returning null from this API instead of throwing an exception, since cache hit is best effort?", "author": "calvinjia", "createdAt": "2020-02-14T21:02:14Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager extends AutoCloseable  {\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(AlluxioConfiguration conf) throws IOException {\n+    // TODO(feng): make cache manager type configurable when we introduce more implementations.\n+    return LocalCacheManager.create(conf);\n+  }\n+\n+  /**\n+   * Writes a new page from a source channel with best effort. It is possible that this put\n+   * operation returns without page written due to transient behavior not due to failures writing\n+   * to disks.\n+   *\n+   * @param pageId page identifier\n+   * @param page page data\n+   * @throws IOException if error happens when writing the page to disk\n+   * @return true on a successful put or false due to transient\n+   */\n+  boolean put(PageId pageId, byte[] page) throws IOException;\n+\n+  /**\n+   * Wraps the page in a channel or null if the queried page is not found in the cache.\n+   *\n+   * @param pageId page identifier\n+   * @return a channel to read the page\n+   * @throws IOException if error happens when reading the page\n+   */\n+  @Nullable\n+  ReadableByteChannel get(PageId pageId) throws IOException;", "originalCommit": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}