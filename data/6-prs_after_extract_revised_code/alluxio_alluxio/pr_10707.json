{"pr_number": 10707, "pr_title": "Implement LocalCacheManager", "pr_createdAt": "2020-01-07T21:20:06Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/10707", "timeline": [{"oid": "685ebe7a66030e81b56d88237fc7434668c306b1", "url": "https://github.com/Alluxio/alluxio/commit/685ebe7a66030e81b56d88237fc7434668c306b1", "message": "Implement LocalCacheManager", "committedDate": "2020-01-07T21:18:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1ODMyMA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r363958320", "bodyText": "I don't feel very good about this constructor. It seems counter-intuitive to have the fsContext as an argument here.\nThere is already an fsContext embededed within the fs object. Is there a better way to access it?", "author": "ZacBlanco", "createdAt": "2020-01-07T21:25:55Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -23,14 +24,16 @@\n public class LocalCacheFileSystem extends DelegatingFileSystem {\n \n   private final LocalCacheManager mLocalCacheManager;\n+  private final FileSystemContext mFsContext;\n \n   /**\n    * @param fs a FileSystem instance to query on local cache miss\n    */\n-  public LocalCacheFileSystem(FileSystem fs) {\n+  public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {", "originalCommit": "685ebe7a66030e81b56d88237fc7434668c306b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM3NjM3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364376375", "bodyText": "I don't see a way to access it unless we expose it from the FileSystem interface.", "author": "bf8086", "createdAt": "2020-01-08T18:26:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk1ODMyMA=="}], "type": "inlineReview", "revised_code": {"commit": "4e49242b68194fb815cfc138fac24b64d895f313", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java\nindex a78fb051c5..ddfe205552 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java\n\n@@ -28,6 +28,7 @@ public class LocalCacheFileSystem extends DelegatingFileSystem {\n \n   /**\n    * @param fs a FileSystem instance to query on local cache miss\n+   * @param fsContext file system context\n    */\n   public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {\n     super(fs);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTU2MA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r363969560", "bodyText": "do we ever need to make this configurable?", "author": "ZacBlanco", "createdAt": "2020-01-07T21:53:44Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,74 +11,251 @@\n \n package alluxio.client.file.cache;\n \n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n import java.nio.channels.WritableByteChannel;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+  /** Number of page locks to strip. */\n+  private static int PAGE_LOCK_SIZE = 256;", "originalCommit": "685ebe7a66030e81b56d88237fc7434668c306b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM3NTk1Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364375957", "bodyText": "Doesn't hurt to add a property.", "author": "bf8086", "createdAt": "2020-01-08T18:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyNzg0NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364527845", "bodyText": "this is a very internal config and I don't expect the users to tune this value.\nGiven we have already too many configuration keys, I would leave this a constant large enough, e.g., a few thousands.", "author": "apc999", "createdAt": "2020-01-09T01:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzk2OTU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "4e49242b68194fb815cfc138fac24b64d895f313", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex 6cb9c0853e..a492764116 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -51,7 +51,7 @@ import javax.annotation.concurrent.ThreadSafe;\n public class LocalCacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n   /** Number of page locks to strip. */\n-  private static int PAGE_LOCK_SIZE = 256;\n+  private static final int PAGE_LOCK_SIZE = 256;\n \n   private final int mPageSize;\n   private final int mCacheSize;\n"}}, {"oid": "4e49242b68194fb815cfc138fac24b64d895f313", "url": "https://github.com/Alluxio/alluxio/commit/4e49242b68194fb815cfc138fac24b64d895f313", "message": "Fix checkstyles", "committedDate": "2020-01-07T22:04:09Z", "type": "commit"}, {"oid": "3d77abf0fa9d247dcc8a8f6d10035a34907486e5", "url": "https://github.com/Alluxio/alluxio/commit/3d77abf0fa9d247dcc8a8f6d10035a34907486e5", "message": "add unit tests and minor fixes", "committedDate": "2020-01-08T01:52:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA4MzExNg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364083116", "bodyText": "shouldn't it be mPageStore.size() based on my convo with @ZacBlanco", "author": "apc999", "createdAt": "2020-01-08T06:45:18Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,74 +11,253 @@\n \n package alluxio.client.file.cache;\n \n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n import java.nio.channels.WritableByteChannel;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final int mLockSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks;\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n+\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n+  }\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE);\n+    mLockSize = mFsContext.getClusterConf().getInt(PropertyKey.USER_CLIENT_CACHE_LOCK_SIZE);\n+    mPageLocks = new ReentrantReadWriteLock[mLockSize];\n+    for (int i = 0; i < mLockSize; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(long fileId, long pageIndex) {\n+    return mPageLocks[(int) (fileId + pageIndex) % mLockSize];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param fileId2 file identifier\n+   * @param pageIndex2 index of the page within the file\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(long fileId, long pageIndex,\n+      long fileId2, long pageIndex2) {\n+    if (fileId + pageIndex < fileId2 + pageIndex2) {\n+      return new Pair<>(getPageLock(fileId, pageIndex), getPageLock(fileId2, pageIndex2));\n+    } else {\n+      return new Pair<>(getPageLock(fileId2, pageIndex2), getPageLock(fileId, pageIndex));\n+    }\n   }\n \n   /**\n-   * Writes a new page from a source channel to the store.\n+   * Writes a new page from a source channel with best effort.\n    *\n-   * @param pageId page ID\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n    * @param src source channel to read this new page\n    * @throws IOException\n    * @return the number of bytes written\n    */\n-  int put(long pageId, ReadableByteChannel src) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(pageId, src);\n-    return 0;\n+  public int put(long fileId, long pageIndex, ReadableByteChannel src) throws IOException {\n+    long victimFileId = 0;\n+    long victimPageIndex = 0;\n+\n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      boolean alreadyCached;\n+      boolean needEvict = false;\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n+        if (!alreadyCached) {\n+          needEvict = (mPageSize + mMetaStore.size()) > mCacheSize;", "originalCommit": "3d77abf0fa9d247dcc8a8f6d10035a34907486e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDM4MzczOA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364383738", "bodyText": "I don't see it on the PageStore interface yet. Should I go ahead and add it?", "author": "bf8086", "createdAt": "2020-01-08T18:43:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA4MzExNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDQzODkzOA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364438938", "bodyText": "Refactored the method to PageStore.", "author": "bf8086", "createdAt": "2020-01-08T20:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDA4MzExNg=="}], "type": "inlineReview", "revised_code": {"commit": "f381481a9ca629d19fc8ada534c13a7c8089d000", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex 13502cf52b..d0baa26d57 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -141,7 +141,7 @@ public class LocalCacheManager {\n       try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n         alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n         if (!alreadyCached) {\n-          needEvict = (mPageSize + mMetaStore.size()) > mCacheSize;\n+          needEvict = (mPageSize + mPageStore.size()) > mCacheSize;\n           if (needEvict) {\n             Pair<Long, Long> victim = mEvictor.evict();\n             victimFileId = victim.getFirst();\n"}}, {"oid": "f381481a9ca629d19fc8ada534c13a7c8089d000", "url": "https://github.com/Alluxio/alluxio/commit/f381481a9ca629d19fc8ada534c13a7c8089d000", "message": "move the size method", "committedDate": "2020-01-08T20:44:54Z", "type": "commit"}, {"oid": "e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "url": "https://github.com/Alluxio/alluxio/commit/e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "message": "clean up test", "committedDate": "2020-01-08T21:27:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyODc4Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364528786", "bodyText": "this local cache manager should be shared across multiple different LocalCacheFileSystem instances (e.g., different thread may init their own instances). in other words, we don't want to have multiple instances of this manager or they will race on reading/writing files. As a result, we may want to introduce the instance ofLocalCacheManager as a singleton in the context.", "author": "apc999", "createdAt": "2020-01-09T01:56:53Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -23,14 +24,17 @@\n public class LocalCacheFileSystem extends DelegatingFileSystem {\n \n   private final LocalCacheManager mLocalCacheManager;\n+  private final FileSystemContext mFsContext;\n \n   /**\n    * @param fs a FileSystem instance to query on local cache miss\n+   * @param fsContext file system context\n    */\n-  public LocalCacheFileSystem(FileSystem fs) {\n+  public LocalCacheFileSystem(FileSystem fs, FileSystemContext fsContext) {\n     super(fs);\n+    mFsContext = fsContext;\n     // needs to be moved outside FileSystem constructor\n-    mLocalCacheManager = new LocalCacheManager();\n+    mLocalCacheManager = new LocalCacheManager(mFsContext);", "originalCommit": "e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDk1MzI3OA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364953278", "bodyText": "Done. For initial implementation the local cache manager is global to all file system clients.", "author": "bf8086", "createdAt": "2020-01-09T20:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUyODc4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f7c4ef3873f82bf5ed979b7dbcb33172934339e1", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java\nindex ddfe205552..105e462750 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java\n\n@@ -22,8 +22,6 @@ import alluxio.grpc.OpenFilePOptions;\n  * A FileSystem implementation with a local cache.\n  */\n public class LocalCacheFileSystem extends DelegatingFileSystem {\n-\n-  private final LocalCacheManager mLocalCacheManager;\n   private final FileSystemContext mFsContext;\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDUzMDg2MA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r364530860", "bodyText": "why throwing IOException here?", "author": "apc999", "createdAt": "2020-01-09T02:07:50Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageStore.java", "diffHunk": "@@ -56,9 +56,14 @@ static PageStore create() {\n    * Deletes a page from the store.\n    *\n    * @param fileId file identifier\n-   * @param pageIndex index of page within the file.\n+   * @param pageIndex index of page within the file\n    * @return if the page was deleted\n    * @throws IOException\n    */\n   boolean delete(long fileId, long pageIndex) throws IOException;\n+\n+  /**\n+   * @return size of the data in store\n+   */\n+  long size() throws IOException;", "originalCommit": "e68d1f47d06d274afd6b1d1bd40ae94f87244df6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b44aaa0a9edcc3411a7ba5372fbf1eec492fe96", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/PageStore.java b/core/client/fs/src/main/java/alluxio/client/file/cache/PageStore.java\nindex 62bebe6985..f5833fd4b8 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/PageStore.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/PageStore.java\n\n@@ -46,24 +69,28 @@ public interface PageStore {\n    *\n    * @param fileId file indentifier\n    * @param pageIndex index of page within the file\n-   * @param dst destination channel to read this new page\n    * @return the number of bytes read\n    * @throws IOException\n+   * @throws PageNotFoundException when the page isn't found in the store\n    */\n-  int get(long fileId, long pageIndex, WritableByteChannel dst) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex) throws IOException,\n+      PageNotFoundException;\n \n   /**\n    * Deletes a page from the store.\n    *\n    * @param fileId file identifier\n    * @param pageIndex index of page within the file\n-   * @return if the page was deleted\n    * @throws IOException\n+   * @throws PageNotFoundException when the page isn't found in the store\n    */\n-  boolean delete(long fileId, long pageIndex) throws IOException;\n+  void delete(long fileId, long pageIndex) throws IOException, PageNotFoundException;\n+\n+  @Override\n+  void close();\n \n   /**\n-   * @return size of the data in store\n+   * @return the number of pages stored\n    */\n-  long size() throws IOException;\n+  int size();\n }\n"}}, {"oid": "f7c4ef3873f82bf5ed979b7dbcb33172934339e1", "url": "https://github.com/Alluxio/alluxio/commit/f7c4ef3873f82bf5ed979b7dbcb33172934339e1", "message": "Make local cache manager a singleton", "committedDate": "2020-01-09T20:45:50Z", "type": "commit"}, {"oid": "7a2e1971af22d7d0744851c7bbcffcf0b1e425fb", "url": "https://github.com/Alluxio/alluxio/commit/7a2e1971af22d7d0744851c7bbcffcf0b1e425fb", "message": "Add cache manager interface", "committedDate": "2020-01-09T22:23:17Z", "type": "commit"}, {"oid": "3b44aaa0a9edcc3411a7ba5372fbf1eec492fe96", "url": "https://github.com/Alluxio/alluxio/commit/3b44aaa0a9edcc3411a7ba5372fbf1eec492fe96", "message": "Merge remote-tracking branch 'upstream/lite' into lite_cachemgr", "committedDate": "2020-01-10T19:32:47Z", "type": "commit"}, {"oid": "8969909b743039fe0cdd72d7e519f6afc6b72033", "url": "https://github.com/Alluxio/alluxio/commit/8969909b743039fe0cdd72d7e519f6afc6b72033", "message": "Merge remote-tracking branch 'upstream/lite' into lite_cachemgr", "committedDate": "2020-01-10T22:02:26Z", "type": "commit"}, {"oid": "3b97e8c3d844fc868cff9ae0378baad5ed4aca35", "url": "https://github.com/Alluxio/alluxio/commit/3b97e8c3d844fc868cff9ae0378baad5ed4aca35", "message": "update API signatures", "committedDate": "2020-01-10T23:02:20Z", "type": "commit"}, {"oid": "af9a3a5b10e1b90c390d9737b9d22e07c4b1ec18", "url": "https://github.com/Alluxio/alluxio/commit/af9a3a5b10e1b90c390d9737b9d22e07c4b1ec18", "message": "update meta store API", "committedDate": "2020-01-10T23:11:33Z", "type": "commit"}, {"oid": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "url": "https://github.com/Alluxio/alluxio/commit/cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "message": "fix checkstyles", "committedDate": "2020-01-10T23:22:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTMwMw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365471303", "bodyText": "Given how often we use the fileId, pageIndex pair, it might be worth creating an explicit object.", "author": "calvinjia", "createdAt": "2020-01-10T23:35:31Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheEvictor.java", "diffHunk": "@@ -24,10 +27,34 @@ static CacheEvictor create() {\n     return null;\n   }\n \n-  void updateOnGet(long pageId);\n+  /**\n+   * Updates evictor after a get operation.\n+   *\n+   * @param fileId ID of the file\n+   * @param pageIndex index of the page within the file\n+   */\n+  void updateOnGet(long fileId, long pageIndex);\n \n-  void updateOnPut(long pageId);\n+  /**\n+   * Updates evictor after a put operation.\n+   *\n+   * @param fileId ID of the file\n+   * @param pageIndex index of the page within the file\n+   */\n+  void updateOnPut(long fileId, long pageIndex);\n \n-  List<Long> getPagesToEvict(int pages);\n+  /**\n+   * Updates evictor after a delete operation.\n+   *\n+   * @param fileId ID of the file\n+   * @param pageIndex index of the page within the file\n+   */\n+  void updateOnDelete(long fileId, long pageIndex);\n \n+  /**\n+   * Find a page to evict.\n+   *\n+   * @return a pair of long values representing (fileId, pageIndex)\n+   */\n+  Pair<Long, Long> evict();", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTUwMTUzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365501539", "bodyText": "Refactored.", "author": "bf8086", "createdAt": "2020-01-11T05:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3MTMwMw=="}], "type": "inlineReview", "revised_code": {"commit": "820d2d285ea7718f32b0d84939babe55efbf7706", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/CacheEvictor.java b/core/client/fs/src/main/java/alluxio/client/file/cache/CacheEvictor.java\nindex eb73b4f61d..a2d9185900 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/CacheEvictor.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/CacheEvictor.java\n\n@@ -30,31 +27,28 @@ public interface CacheEvictor {\n   /**\n    * Updates evictor after a get operation.\n    *\n-   * @param fileId ID of the file\n-   * @param pageIndex index of the page within the file\n+   * @param pageId page identifier\n    */\n-  void updateOnGet(long fileId, long pageIndex);\n+  void updateOnGet(PageId pageId);\n \n   /**\n    * Updates evictor after a put operation.\n    *\n-   * @param fileId ID of the file\n-   * @param pageIndex index of the page within the file\n+   * @param pageId page identifier\n    */\n-  void updateOnPut(long fileId, long pageIndex);\n+  void updateOnPut(PageId pageId);\n \n   /**\n    * Updates evictor after a delete operation.\n    *\n-   * @param fileId ID of the file\n-   * @param pageIndex index of the page within the file\n+   * @param pageId page identifier\n    */\n-  void updateOnDelete(long fileId, long pageIndex);\n+  void updateOnDelete(PageId pageId);\n \n   /**\n    * Find a page to evict.\n    *\n-   * @return a pair of long values representing (fileId, pageIndex)\n+   * @return identifier of the page to evict\n    */\n-  Pair<Long, Long> evict();\n+  PageId evict();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3Nzc0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365477747", "bodyText": "@Nullable\nReadableByteChannel get(long fileId, long pageIndex) throws IOException;", "author": "apc999", "createdAt": "2020-01-11T00:11:26Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -1,37 +1,73 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n \n import java.io.IOException;\n import java.nio.channels.ReadableByteChannel;\n \n-interface CacheManager {\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager {\n+  /**\n+   * @param fsContext filesystem context\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(FileSystemContext fsContext) {\n+    return new LocalCacheManager(fsContext);\n+  }\n \n   /**\n-   * Writes a new page from a source channel to the store.\n+   * Writes a new page from a source channel with best effort.\n    *\n-   * @param fileId file ID\n-   * @param pageId page ID\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n    * @param page page data\n-   * @return the number of bytes written\n+   * @throws IOException\n+   */\n+  void put(long fileId, long pageIndex, byte[] page) throws IOException;\n+\n+  /**\n+   * Reads a page to the destination channel.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @throws PageNotFoundException if page is not found in the store\n+   * @return the number of bytes read\n    */\n-  int put(long fileId, long pageId, byte[] page) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex) throws IOException,", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTk4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485985", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-01-11T01:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3Nzc0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java\nindex dd0499c87e..4e0f730fc6 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java\n\n@@ -12,10 +12,13 @@\n package alluxio.client.file.cache;\n \n import alluxio.client.file.FileSystemContext;\n+import alluxio.exception.PageNotFoundException;\n \n import java.io.IOException;\n import java.nio.channels.ReadableByteChannel;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Interface for managing cached pages.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478023", "bodyText": "Does the length parameter help underlying implementations? For the caller, length is not important since they have control over how many bytes are being read.", "author": "calvinjia", "createdAt": "2020-01-11T00:13:29Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -1,37 +1,73 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n \n import java.io.IOException;\n import java.nio.channels.ReadableByteChannel;\n \n-interface CacheManager {\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager {\n+  /**\n+   * @param fsContext filesystem context\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(FileSystemContext fsContext) {\n+    return new LocalCacheManager(fsContext);\n+  }\n \n   /**\n-   * Writes a new page from a source channel to the store.\n+   * Writes a new page from a source channel with best effort.\n    *\n-   * @param fileId file ID\n-   * @param pageId page ID\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n    * @param page page data\n-   * @return the number of bytes written\n+   * @throws IOException\n+   */\n+  void put(long fileId, long pageIndex, byte[] page) throws IOException;\n+\n+  /**\n+   * Reads a page to the destination channel.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @throws PageNotFoundException if page is not found in the store\n+   * @return the number of bytes read\n    */\n-  int put(long fileId, long pageId, byte[] page) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex) throws IOException,\n+      PageNotFoundException;\n \n   /**\n-   * Gets a page from the store to the destination channel.\n+   * Reads a part of a page to the destination channel.\n    *\n-   * @param fileId file ID\n-   * @param pageId page ID\n-   * @return a channel to read the page\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param pageOffset offset into the page\n+   * @param length length to read\n+   * @throws PageNotFoundException if page is not found in the store\n+   * @return the number of bytes read\n    */\n-  ReadableByteChannel get(long fileId, long pageId) throws IOException;\n+  ReadableByteChannel get(long fileId, long pageIndex, int pageOffset, int length)", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDAwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365480001", "bodyText": "Shouldn't be much difference in the underlying implementation.", "author": "bf8086", "createdAt": "2020-01-11T00:26:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4MDQ0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365480446", "bodyText": "In that case I don't think we need to specify length?", "author": "calvinjia", "createdAt": "2020-01-11T00:29:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NzIyNg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365487226", "bodyText": "Removed.", "author": "bf8086", "createdAt": "2020-01-11T01:22:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java\nindex dd0499c87e..4e0f730fc6 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java\n\n@@ -12,10 +12,13 @@\n package alluxio.client.file.cache;\n \n import alluxio.client.file.FileSystemContext;\n+import alluxio.exception.PageNotFoundException;\n \n import java.io.IOException;\n import java.nio.channels.ReadableByteChannel;\n \n+import javax.annotation.Nullable;\n+\n /**\n  * Interface for managing cached pages.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODE5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478197", "bodyText": "Use try-with-catch?", "author": "apc999", "createdAt": "2020-01-11T00:14:42Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -106,21 +106,30 @@ public int read(byte[] b, int off, int len) throws IOException {\n       int currentPageOffset = (int) (mPosition % PAGE_SIZE);\n       int bytesLeftInPage = (int) Math.min(PAGE_SIZE - currentPageOffset, len - bytesRead);\n       // TODO(calvin): Update this to take page offset when API is updated\n-      ReadableByteChannel cachedData = mCacheManager.get(mStatus.getFileId(), currentPage);\n+      ReadableByteChannel cachedData = null;\n+      try {\n+        cachedData = mCacheManager.get(mStatus.getFileId(), currentPage);\n+      } catch (PageNotFoundException e) {\n+        // ignore exception and continue to read remote data\n+      }\n       if (cachedData != null) { // cache hit\n         // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n-        ByteBuffer buf = ByteBuffer.wrap(b);\n-        buf.position(off + bytesRead);\n-        buf.limit(off + bytesRead + bytesLeftInPage);\n-        // read data from cache\n-        while (buf.position() != buf.limit()) {\n-          if (cachedData.read(buf) == -1) {\n-            break;\n+        try {", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTg4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485882", "bodyText": "Done.", "author": "bf8086", "createdAt": "2020-01-11T01:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODE5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\nindex f702b36ece..e46ec370b0 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java\n\n@@ -102,19 +103,13 @@ public class LocalCacheFileInStream extends FileInStream {\n     int bytesRead = 0;\n     // for each page, check if it is available in the cache\n     while (bytesRead < len) {\n-      long currentPage = mPosition / PAGE_SIZE;\n-      int currentPageOffset = (int) (mPosition % PAGE_SIZE);\n-      int bytesLeftInPage = (int) Math.min(PAGE_SIZE - currentPageOffset, len - bytesRead);\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n       // TODO(calvin): Update this to take page offset when API is updated\n-      ReadableByteChannel cachedData = null;\n-      try {\n-        cachedData = mCacheManager.get(mStatus.getFileId(), currentPage);\n-      } catch (PageNotFoundException e) {\n-        // ignore exception and continue to read remote data\n-      }\n-      if (cachedData != null) { // cache hit\n-        // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n-        try {\n+      try (ReadableByteChannel cachedData = mCacheManager.get(mStatus.getFileId(), currentPage)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n           ByteBuffer buf = ByteBuffer.wrap(b);\n           buf.position(off + bytesRead);\n           buf.limit(off + bytesRead + bytesLeftInPage);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODIwNQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478205", "bodyText": "Should we do something in this error case, it doesn't seem safe to proceed?", "author": "calvinjia", "createdAt": "2020-01-11T00:14:45Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / mPageSize;\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(long fileId, long pageIndex) {\n+    return mPageLocks[(int) (fileId + pageIndex) % LOCK_SIZE];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param fileId2 file identifier\n+   * @param pageIndex2 index of the page within the file\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(long fileId, long pageIndex,\n+      long fileId2, long pageIndex2) {\n+    if (fileId + pageIndex < fileId2 + pageIndex2) {\n+      return new Pair<>(getPageLock(fileId, pageIndex), getPageLock(fileId2, pageIndex2));\n+    } else {\n+      return new Pair<>(getPageLock(fileId2, pageIndex2), getPageLock(fileId, pageIndex));\n+    }\n   }\n \n   @Override\n-  public ReadableByteChannel get(long fileId, long pageId) throws IOException {\n-    if (!mMetaStore.hasPage(pageId)) {\n+  public void put(long fileId, long pageIndex, byte[] page) throws IOException {\n+    long victimFileId = 0;\n+    long victimPageIndex = 0;\n \n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      boolean alreadyCached;\n+      boolean needEvict = false;\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n+        if (!alreadyCached) {\n+          needEvict = mPageStore.size() + 1 > mCacheSize;\n+          if (needEvict) {\n+            Pair<Long, Long> victim = mEvictor.evict();\n+            victimFileId = victim.getFirst();\n+            victimPageIndex = victim.getSecond();\n+          } else {\n+            mMetaStore.addPage(fileId, pageIndex);\n+          }\n+        }\n+      }\n+      if (alreadyCached) {\n+        try {\n+          mPageStore.delete(fileId, pageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to delete page {} {} from page store\", fileId, pageIndex, e);\n+        }\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      } else if (!needEvict) {\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      }\n     }\n-    mEvictor.updateOnGet(pageId);\n-    return null;\n+\n+    Pair<ReadWriteLock, ReadWriteLock> pageLockPair =\n+        getPageLockPair(fileId, pageIndex, victimFileId, victimPageIndex);\n+    try (LockResource r1 = new LockResource(pageLockPair.getFirst().writeLock());\n+        LockResource r2 = new LockResource(pageLockPair.getSecond().writeLock())) {\n+      try (LockResource r3 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(fileId, pageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already inserted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        if (!mMetaStore.hasPage(victimFileId, victimPageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already evicted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        try {\n+          mMetaStore.removePage(victimFileId, victimPageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to remove page {} {} from meta store\",\n+              victimFileId, victimPageIndex, e);\n+        }", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODcwNA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478704", "bodyText": "Yeah we can throw IllegalStateException instead.", "author": "bf8086", "createdAt": "2020-01-11T00:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODIwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex 3446049bd0..c4bf97efcc 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -14,6 +14,7 @@ package alluxio.client.file.cache;\n import alluxio.client.file.FileSystemContext;\n import alluxio.collections.Pair;\n import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n import alluxio.resource.LockResource;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODk5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478996", "bodyText": "Could you update the page size constant used in LocalCacheFileInStream?", "author": "calvinjia", "createdAt": "2020-01-11T00:19:55Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTE0MA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485140", "bodyText": "Updated.", "author": "bf8086", "createdAt": "2020-01-11T01:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODk5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex 3446049bd0..c4bf97efcc 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -14,6 +14,7 @@ package alluxio.client.file.cache;\n import alluxio.client.file.FileSystemContext;\n import alluxio.collections.Pair;\n import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n import alluxio.resource.LockResource;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODQ4NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365478485", "bodyText": "incorrect javadoc with missing params", "author": "apc999", "createdAt": "2020-01-11T00:16:27Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NTAxNg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365485016", "bodyText": "Fixed.", "author": "bf8086", "createdAt": "2020-01-11T01:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3ODQ4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex 3446049bd0..c4bf97efcc 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -14,6 +14,7 @@ package alluxio.client.file.cache;\n import alluxio.client.file.FileSystemContext;\n import alluxio.collections.Pair;\n import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n import alluxio.resource.LockResource;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTAxNA==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365479014", "bodyText": "return null. using Exceptions for control flow is undesired.", "author": "apc999", "createdAt": "2020-01-11T00:20:03Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -11,53 +11,240 @@\n \n package alluxio.client.file.cache;\n \n-import alluxio.client.file.cache.store.PageNotFoundException;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.ThreadSafe;\n \n /**\n- * A class to manage cached pages. This class will\n- * 1. Ensure thread-safety\n- * 2. Bookkeep Cache Replacement Alg\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n  *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n  */\n @ThreadSafe\n public class LocalCacheManager implements CacheManager {\n   private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n \n-  private final CacheEvictor mEvictor = CacheEvictor.create();\n-  private final PageStore mPageStore = PageStore.create();\n-  private final MetaStore mMetaStore = new MetaStore();\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+  private final FileSystemContext mFsContext;\n \n-  public LocalCacheManager() {\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  public LocalCacheManager(FileSystemContext fsContext) {\n+    this(fsContext, new MetaStore(), PageStore.create(), CacheEvictor.create());\n   }\n \n-  @Override\n-  public int put(long fileId, long pageId, byte[] page) throws IOException {\n-    mMetaStore.addPage(pageId);\n-    mPageStore.put(fileId, pageId, page);\n-    return 0;\n+  /**\n+   * @param fsContext filesystem context\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(FileSystemContext fsContext, MetaStore metaStore,\n+                    PageStore pageStore, CacheEvictor evictor) {\n+    mFsContext = fsContext;\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = (int) mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = mFsContext.getClusterConf().getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / mPageSize;\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(long fileId, long pageIndex) {\n+    return mPageLocks[(int) (fileId + pageIndex) % LOCK_SIZE];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param fileId file identifier\n+   * @param pageIndex index of the page within the file\n+   * @param fileId2 file identifier\n+   * @param pageIndex2 index of the page within the file\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(long fileId, long pageIndex,\n+      long fileId2, long pageIndex2) {\n+    if (fileId + pageIndex < fileId2 + pageIndex2) {\n+      return new Pair<>(getPageLock(fileId, pageIndex), getPageLock(fileId2, pageIndex2));\n+    } else {\n+      return new Pair<>(getPageLock(fileId2, pageIndex2), getPageLock(fileId, pageIndex));\n+    }\n   }\n \n   @Override\n-  public ReadableByteChannel get(long fileId, long pageId) throws IOException {\n-    if (!mMetaStore.hasPage(pageId)) {\n+  public void put(long fileId, long pageIndex, byte[] page) throws IOException {\n+    long victimFileId = 0;\n+    long victimPageIndex = 0;\n \n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      boolean alreadyCached;\n+      boolean needEvict = false;\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        alreadyCached = mMetaStore.hasPage(fileId, pageIndex);\n+        if (!alreadyCached) {\n+          needEvict = mPageStore.size() + 1 > mCacheSize;\n+          if (needEvict) {\n+            Pair<Long, Long> victim = mEvictor.evict();\n+            victimFileId = victim.getFirst();\n+            victimPageIndex = victim.getSecond();\n+          } else {\n+            mMetaStore.addPage(fileId, pageIndex);\n+          }\n+        }\n+      }\n+      if (alreadyCached) {\n+        try {\n+          mPageStore.delete(fileId, pageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to delete page {} {} from page store\", fileId, pageIndex, e);\n+        }\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      } else if (!needEvict) {\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+        mPageStore.put(fileId, pageIndex, page);\n+      }\n     }\n-    mEvictor.updateOnGet(pageId);\n-    return null;\n+\n+    Pair<ReadWriteLock, ReadWriteLock> pageLockPair =\n+        getPageLockPair(fileId, pageIndex, victimFileId, victimPageIndex);\n+    try (LockResource r1 = new LockResource(pageLockPair.getFirst().writeLock());\n+        LockResource r2 = new LockResource(pageLockPair.getSecond().writeLock())) {\n+      try (LockResource r3 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(fileId, pageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already inserted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        if (!mMetaStore.hasPage(victimFileId, victimPageIndex)) {\n+          LOG.warn(\"fileId {} pageIndex {} is already evicted by a racing thread\",\n+              fileId, pageIndex);\n+          return;\n+        }\n+        try {\n+          mMetaStore.removePage(victimFileId, victimPageIndex);\n+        } catch (PageNotFoundException e) {\n+          // this should never happen with proper locking\n+          LOG.error(\"failed to remove page {} {} from meta store\",\n+              victimFileId, victimPageIndex, e);\n+        }\n+        mEvictor.updateOnDelete(victimFileId, victimPageIndex);\n+        mMetaStore.addPage(fileId, pageIndex);\n+        mEvictor.updateOnPut(fileId, pageIndex);\n+      }\n+      try {\n+        mPageStore.delete(victimFileId, victimPageIndex);\n+      } catch (PageNotFoundException e) {\n+        // this should never happen with proper locking\n+        LOG.error(\"failed to delete page {} {} from page store\", victimFileId, victimPageIndex, e);\n+      }\n+      mPageStore.put(fileId, pageIndex, page);\n+    }\n+  }\n+\n+  @Override\n+  public ReadableByteChannel get(long fileId, long pageIndex) throws IOException,\n+      PageNotFoundException {\n+    return get(fileId, pageIndex, 0, mPageSize);\n   }\n \n   @Override\n-  public boolean delete(long fileId, long pageId) throws IOException, PageNotFoundException {\n-    mMetaStore.removePage(pageId);\n-    mPageStore.delete(fileId, pageId);\n-    return false;\n+  public ReadableByteChannel get(long fileId, long pageIndex, int pageOffset, int length)\n+      throws IOException, PageNotFoundException {\n+    Preconditions.checkArgument(pageOffset + length <= mPageSize,\n+        \"Read exceeds page boundary: offset=%s length=%s, size=%s\", pageOffset, length, mPageSize);\n+    ReadableByteChannel ret;\n+    boolean hasPage;\n+    ReadWriteLock pageLock = getPageLock(fileId, pageIndex);\n+    try (LockResource r = new LockResource(pageLock.readLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.readLock())) {\n+        hasPage = mMetaStore.hasPage(fileId, pageIndex);\n+      }\n+      if (!hasPage) {\n+        throw new PageNotFoundException(", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NDk5Mg==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365484992", "bodyText": "Refactored.", "author": "bf8086", "createdAt": "2020-01-11T01:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTAxNA=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\nindex 3446049bd0..c4bf97efcc 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n+++ b/core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java\n\n@@ -14,6 +14,7 @@ package alluxio.client.file.cache;\n import alluxio.client.file.FileSystemContext;\n import alluxio.collections.Pair;\n import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n import alluxio.resource.LockResource;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTE3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365479175", "bodyText": "we typically put all Alluxio exceptions together rather than leaving them  in different packages.", "author": "apc999", "createdAt": "2020-01-11T00:21:07Z", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageNotFoundException.java", "diffHunk": "@@ -10,7 +10,7 @@\n  *\n  */\n \n-package alluxio.client.file.cache.store;\n+package alluxio.client.file.cache;", "originalCommit": "cadc31fb47fcdbcd1a3b401bcbd8a82c3049d60c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ4NDg0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/10707#discussion_r365484846", "bodyText": "Moved.", "author": "bf8086", "createdAt": "2020-01-11T00:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ3OTE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "2520b69d6575df495504ac068ce8fc1fde9689aa", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/file/cache/PageNotFoundException.java b/core/base/src/main/java/alluxio/exception/PageNotFoundException.java\nsimilarity index 77%\nrename from core/client/fs/src/main/java/alluxio/client/file/cache/PageNotFoundException.java\nrename to core/base/src/main/java/alluxio/exception/PageNotFoundException.java\nindex 1e8627a6b1..30b4af70f3 100644\n--- a/core/client/fs/src/main/java/alluxio/client/file/cache/PageNotFoundException.java\n+++ b/core/base/src/main/java/alluxio/exception/PageNotFoundException.java\n\n@@ -7,17 +7,12 @@\n  * either express or implied, as more fully set forth in the License.\n  *\n  * See the NOTICE file distributed with this work for information regarding copyright ownership.\n- *\n  */\n \n-package alluxio.client.file.cache;\n-\n-import alluxio.exception.AlluxioException;\n+package alluxio.exception;\n \n /**\n- * An exception that should be thrown when a page store implementation cannot find a page using\n- * {@link alluxio.client.file.cache.PageStore#get(long, long)} or\n- * {@link alluxio.client.file.cache.PageStore#delete(long, long)}.\n+ * An exception that should be thrown when a page is not found in store.\n  */\n public class PageNotFoundException extends AlluxioException {\n   /**\n"}}, {"oid": "2520b69d6575df495504ac068ce8fc1fde9689aa", "url": "https://github.com/Alluxio/alluxio/commit/2520b69d6575df495504ac068ce8fc1fde9689aa", "message": "address comments", "committedDate": "2020-01-11T00:57:01Z", "type": "commit"}, {"oid": "e2c449d63423d31d86a74385f171d47657c5bb35", "url": "https://github.com/Alluxio/alluxio/commit/e2c449d63423d31d86a74385f171d47657c5bb35", "message": "throw exception on missing page", "committedDate": "2020-01-11T01:06:11Z", "type": "commit"}, {"oid": "c0342b0759cf83f54f03a9a262646b11555ce923", "url": "https://github.com/Alluxio/alluxio/commit/c0342b0759cf83f54f03a9a262646b11555ce923", "message": "remove length from get parameter", "committedDate": "2020-01-11T01:22:20Z", "type": "commit"}, {"oid": "820d2d285ea7718f32b0d84939babe55efbf7706", "url": "https://github.com/Alluxio/alluxio/commit/820d2d285ea7718f32b0d84939babe55efbf7706", "message": "create page id object", "committedDate": "2020-01-11T05:34:02Z", "type": "commit"}, {"oid": "5c6f08423f98d85cb4ede4fe74f560c39a38a3f2", "url": "https://github.com/Alluxio/alluxio/commit/5c6f08423f98d85cb4ede4fe74f560c39a38a3f2", "message": "More cleanup", "committedDate": "2020-01-12T06:23:35Z", "type": "commit"}]}