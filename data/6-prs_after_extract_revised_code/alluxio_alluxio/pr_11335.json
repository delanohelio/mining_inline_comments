{"pr_number": 11335, "pr_title": "Optimize gRPC managed resource handling", "pr_createdAt": "2020-04-23T19:45:50Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11335", "timeline": [{"oid": "7c1dcc69aad902ec0f6ae0bd19fe44e7715d8320", "url": "https://github.com/Alluxio/alluxio/commit/7c1dcc69aad902ec0f6ae0bd19fe44e7715d8320", "message": "Optimize gRPC managed resource handling\n\nFixes https://github.com/Alluxio/alluxio/issues/11307\n\npr-link: Alluxio/alluxio#11304\nchange-id: cid-945a8bfe010792c1c0ab8b3c4a26346b4d0a5a58", "committedDate": "2020-04-23T19:44:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA4MDE0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11335#discussion_r414080147", "bodyText": "Needed to remove a lambda here as it's not available in 2.2", "author": "ggezer", "createdAt": "2020-04-23T19:52:36Z", "path": "core/common/src/main/java/alluxio/grpc/GrpcConnectionPool.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.grpc;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.network.ChannelType;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.WaitForOptions;\n+import alluxio.util.network.NettyUtils;\n+\n+import com.google.common.base.Preconditions;\n+import io.grpc.ConnectivityState;\n+import io.grpc.ManagedChannel;\n+import io.grpc.netty.NettyChannelBuilder;\n+import io.netty.channel.Channel;\n+import io.netty.channel.EventLoopGroup;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Used to provide gRPC level connection management and pooling facilities.\n+ *\n+ * This class is used internally by {@link GrpcChannelBuilder} and {@link GrpcChannel}.\n+ */\n+@ThreadSafe\n+public class GrpcConnectionPool {\n+  private static final Logger LOG = LoggerFactory.getLogger(GrpcConnectionPool.class);\n+\n+  // Singleton instance.\n+  public static final GrpcConnectionPool INSTANCE = new GrpcConnectionPool();\n+\n+  /** gRPC Managed channels/connections. */\n+  private ConcurrentMap<GrpcConnectionKey, CountingReference<ManagedChannel>> mChannels;\n+\n+  /** Event loops. */\n+  private ConcurrentMap<GrpcChannelKey, CountingReference<EventLoopGroup>> mEventLoops;\n+\n+  /** Used to assign order within a network group. */\n+  private ConcurrentMap<GrpcChannelKey.NetworkGroup, AtomicLong> mNetworkGroupCounters;\n+\n+  /**\n+   * Creates a new {@link GrpcConnectionPool}.\n+   */\n+  public GrpcConnectionPool() {\n+    mChannels = new ConcurrentHashMap<>();\n+    mEventLoops = new ConcurrentHashMap<>();\n+    // Initialize counters for known network-groups.\n+    mNetworkGroupCounters = new ConcurrentHashMap<>();\n+    for (GrpcChannelKey.NetworkGroup group : GrpcChannelKey.NetworkGroup.values()) {\n+      mNetworkGroupCounters.put(group, new AtomicLong());\n+    }\n+  }\n+\n+  /**\n+   * Acquires and increases the ref-count for the {@link ManagedChannel}.\n+   *\n+   * @param channelKey the channel key\n+   * @param conf the Alluxio configuration\n+   * @return a {@link GrpcConnection}\n+   */\n+  public GrpcConnection acquireConnection(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Get a connection key.\n+    GrpcConnectionKey connectionKey = getConnectionKey(channelKey, conf);\n+    // Acquire connection.\n+    CountingReference<ManagedChannel> connectionRef =\n+        mChannels.compute(connectionKey, (key, ref) -> {\n+          boolean shutdownExistingConnection = false;\n+          int existingRefCount = 0;\n+          if (ref != null) {\n+            // Connection exists, wait for health check.\n+            if (waitForConnectionReady(ref.get(), conf)) {\n+              LOG.debug(\"Acquiring an existing connection. ConnectionKey: {}. Ref-count: {}\", key,\n+                  ref.getRefCount());\n+\n+              return ref.reference();\n+            } else {\n+              // Health check failed.\n+              shutdownExistingConnection = true;\n+            }\n+          }\n+          // Existing connection should shut-down.\n+          if (shutdownExistingConnection) {\n+            // TODO(ggezer): Implement GrpcConnectionListener for receiving notification.\n+            existingRefCount = ref.getRefCount();\n+            LOG.debug(\"Shutting down an existing unhealthy connection. \"\n+                + \"ConnectionKey: {}. Ref-count: {}\", key, existingRefCount);\n+            // Shutdown the channel forcefully as it's already unhealthy.\n+            shutdownManagedChannel(ref.get(), conf);\n+          }\n+\n+          // Create a new managed channel.\n+          LOG.debug(\"Creating a new managed channel. ConnectionKey: {}. Ref-count:{}\", key,\n+              existingRefCount);\n+          ManagedChannel managedChannel = createManagedChannel(channelKey, conf);\n+          // Set map reference.\n+          return new CountingReference(managedChannel, existingRefCount).reference();\n+        });\n+\n+    // Wrap connection reference and the connection.\n+    return new GrpcConnection(connectionKey, connectionRef.get(), conf);\n+  }\n+\n+  /**\n+   * Decreases the ref-count of the {@link ManagedChannel} for the given address. It shuts down the\n+   * underlying channel if reference count reaches zero.\n+   *\n+   * @param connectionKey the connection key\n+   * @param conf the Alluxio configuration\n+   */\n+  public void releaseConnection(GrpcConnectionKey connectionKey, AlluxioConfiguration conf) {\n+    mChannels.compute(connectionKey, (key, ref) -> {\n+      Preconditions.checkNotNull(ref, \"Cannot release nonexistent connection\");\n+      LOG.debug(\"Releasing connection for: {}. Ref-count: {}\", key, ref.getRefCount());\n+      // Shutdown managed channel.\n+      if (ref.dereference() == 0) {\n+        LOG.debug(\"Shutting down connection after: {}\", connectionKey);\n+        shutdownManagedChannel(ref.get(), conf);\n+        // Release the event-loop for the connection.\n+        releaseNetworkEventLoop(connectionKey.getChannelKey());\n+        return null;\n+      }\n+      return ref;\n+    });\n+  }\n+\n+  private GrpcConnectionKey getConnectionKey(GrpcChannelKey channelKey, AlluxioConfiguration conf) {\n+    // Assign index within the network group.\n+    long groupIndex = mNetworkGroupCounters.get(channelKey.getNetworkGroup()).incrementAndGet();\n+    switch (channelKey.getNetworkGroup()) {\n+      case RPC:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_RPC_MAX_CONNECTIONS);\n+        break;\n+      case STREAMING:\n+        groupIndex %= conf.getLong(PropertyKey.USER_NETWORK_STREAMING_MAX_CONNECTIONS);\n+        break;\n+      default:\n+        throw new IllegalStateException(\n+            String.format(\"Unrecognized network group: %s\", channelKey.getNetworkGroup()));\n+    }\n+\n+    return new GrpcConnectionKey(channelKey, (int) groupIndex);\n+  }\n+\n+  /**\n+   * Creates a {@link ManagedChannel} by given pool key.\n+   */\n+  private ManagedChannel createManagedChannel(GrpcChannelKey channelKey,\n+      AlluxioConfiguration conf) {\n+    // Create netty channel builder with the address from channel key.\n+    NettyChannelBuilder channelBuilder;\n+    SocketAddress address = channelKey.getServerAddress().getSocketAddress();\n+    if (address instanceof InetSocketAddress) {\n+      InetSocketAddress inetServerAddress = (InetSocketAddress) address;\n+      // This constructor delays DNS lookup to detect changes\n+      channelBuilder = NettyChannelBuilder.forAddress(inetServerAddress.getHostName(),\n+          inetServerAddress.getPort());\n+    } else {\n+      channelBuilder = NettyChannelBuilder.forAddress(address);\n+    }\n+    // Apply default channel options for the multiplex group.\n+    channelBuilder = applyGroupDefaults(channelKey, channelBuilder, conf);\n+    // Build netty managed channel.\n+    return channelBuilder.build();\n+  }\n+\n+  /**\n+   * It updates and returns the given {@link NettyChannelBuilder} based on network group settings.\n+   */\n+  private NettyChannelBuilder applyGroupDefaults(GrpcChannelKey key,\n+      NettyChannelBuilder channelBuilder, AlluxioConfiguration conf) {\n+    long keepAliveTimeMs = conf.getMs(PropertyKey.Template.USER_NETWORK_KEEPALIVE_TIME_MS\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    long keepAliveTimeoutMs = conf.getMs(PropertyKey.Template.USER_NETWORK_KEEPALIVE_TIMEOUT_MS\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    long inboundMessageSizeBytes =\n+        conf.getBytes(PropertyKey.Template.USER_NETWORK_MAX_INBOUND_MESSAGE_SIZE\n+            .format(key.getNetworkGroup().getPropertyCode()));\n+    long flowControlWindow = conf.getBytes(PropertyKey.Template.USER_NETWORK_FLOWCONTROL_WINDOW\n+        .format(key.getNetworkGroup().getPropertyCode()));\n+    Class<? extends Channel> channelType = NettyUtils.getChannelClass(\n+        !(key.getServerAddress().getSocketAddress() instanceof InetSocketAddress),\n+        PropertyKey.Template.USER_NETWORK_NETTY_CHANNEL\n+            .format(key.getNetworkGroup().getPropertyCode()),\n+        conf);\n+    EventLoopGroup eventLoopGroup = acquireNetworkEventLoop(key, conf);\n+\n+    // Update the builder.\n+    channelBuilder.keepAliveTime(keepAliveTimeMs, TimeUnit.MILLISECONDS);\n+    channelBuilder.keepAliveTimeout(keepAliveTimeoutMs, TimeUnit.MILLISECONDS);\n+    channelBuilder.maxInboundMetadataSize((int) inboundMessageSizeBytes);\n+    channelBuilder.flowControlWindow((int) flowControlWindow);\n+    channelBuilder.channelType(channelType);\n+    channelBuilder.eventLoopGroup(eventLoopGroup);\n+    // Use plaintext\n+    channelBuilder.usePlaintext();\n+\n+    return channelBuilder;\n+  }\n+\n+  /**\n+   * Returns {@code true} if given managed channel is ready.\n+   */\n+  private boolean waitForConnectionReady(ManagedChannel managedChannel, AlluxioConfiguration conf) {\n+    long healthCheckTimeoutMs = conf.getMs(PropertyKey.NETWORK_CONNECTION_HEALTH_CHECK_TIMEOUT);\n+    try {\n+      Boolean res = CommonUtils.waitForResult(\"channel to be ready\", () -> {\n+        ConnectivityState currentState = managedChannel.getState(true);\n+        switch (currentState) {\n+          case READY:\n+            return true;\n+          case TRANSIENT_FAILURE:\n+          case SHUTDOWN:\n+            return false;\n+          case IDLE:\n+          case CONNECTING:\n+            return null;\n+          default:\n+            return null;\n+        }\n+      }, WaitForOptions.defaults().setTimeoutMs((int) healthCheckTimeoutMs));", "originalCommit": "7c1dcc69aad902ec0f6ae0bd19fe44e7715d8320", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}