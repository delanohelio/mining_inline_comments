{"pr_number": 11480, "pr_title": "Add an HDFS validation tool", "pr_createdAt": "2020-05-27T15:35:16Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11480", "timeline": [{"oid": "787730a5f680c44da066e6f5f6de3a1cf558fdc0", "url": "https://github.com/Alluxio/alluxio/commit/787730a5f680c44da066e6f5f6de3a1cf558fdc0", "message": "testing", "committedDate": "2020-05-18T15:00:32Z", "type": "commit"}, {"oid": "8aa0986241bcc1b4e8b259aab045398513d15c72", "url": "https://github.com/Alluxio/alluxio/commit/8aa0986241bcc1b4e8b259aab045398513d15c72", "message": "add driver command", "committedDate": "2020-05-19T07:02:24Z", "type": "commit"}, {"oid": "64f17091ac173f98a2d7c55c12146c6d8a662415", "url": "https://github.com/Alluxio/alluxio/commit/64f17091ac173f98a2d7c55c12146c6d8a662415", "message": "core logic, doesn't compile", "committedDate": "2020-05-27T15:32:38Z", "type": "commit"}, {"oid": "53b595426200dfdc63002a8cf3ac9695f80f9450", "url": "https://github.com/Alluxio/alluxio/commit/53b595426200dfdc63002a8cf3ac9695f80f9450", "message": "refactor ValidationTask to use TaskResult", "committedDate": "2020-05-28T08:04:49Z", "type": "commit"}, {"oid": "025995aaf9aab07b3d72cb5f014ec26970e9a015", "url": "https://github.com/Alluxio/alluxio/commit/025995aaf9aab07b3d72cb5f014ec26970e9a015", "message": "restructure hdfs val tasks", "committedDate": "2020-05-28T13:06:17Z", "type": "commit"}, {"oid": "32fcb8b4c7e00e454ba35aaa3879d7898bf68a9d", "url": "https://github.com/Alluxio/alluxio/commit/32fcb8b4c7e00e454ba35aaa3879d7898bf68a9d", "message": "add dependency to ufs-hdfs", "committedDate": "2020-05-28T13:08:44Z", "type": "commit"}, {"oid": "b1749eaf2873328273c90a984475667d97d00c30", "url": "https://github.com/Alluxio/alluxio/commit/b1749eaf2873328273c90a984475667d97d00c30", "message": "compiles", "committedDate": "2020-06-01T11:01:10Z", "type": "commit"}, {"oid": "2d651568c62e65187fad953abc55046260af4fb4", "url": "https://github.com/Alluxio/alluxio/commit/2d651568c62e65187fad953abc55046260af4fb4", "message": "adding unit tests", "committedDate": "2020-06-02T02:25:54Z", "type": "commit"}, {"oid": "2da4e2867fa11e9a776733e09e76b04e5ec782f2", "url": "https://github.com/Alluxio/alluxio/commit/2da4e2867fa11e9a776733e09e76b04e5ec782f2", "message": "added some more unit tests", "committedDate": "2020-06-02T13:48:56Z", "type": "commit"}, {"oid": "dcbbcffaac1fb2d2d5c3e9faa43022d9e1bd8561", "url": "https://github.com/Alluxio/alluxio/commit/dcbbcffaac1fb2d2d5c3e9faa43022d9e1bd8561", "message": "add unit tests", "committedDate": "2020-06-02T13:49:54Z", "type": "commit"}, {"oid": "cef53099ad91c584eeac77e07072362d6784aa75", "url": "https://github.com/Alluxio/alluxio/commit/cef53099ad91c584eeac77e07072362d6784aa75", "message": "Merge remote-tracking branch 'upstream/master' into hdfs-validation", "committedDate": "2020-06-04T14:17:40Z", "type": "commit"}, {"oid": "6c4b1d4045bd9fef87c80fe69e6d9a5e41a8681f", "url": "https://github.com/Alluxio/alluxio/commit/6c4b1d4045bd9fef87c80fe69e6d9a5e41a8681f", "message": "rebase and use new TaskResult", "committedDate": "2020-06-04T15:01:21Z", "type": "commit"}, {"oid": "fe04aba03fc54a82a83cf6fa19f0c8fac9bead4f", "url": "https://github.com/Alluxio/alluxio/commit/fe04aba03fc54a82a83cf6fa19f0c8fac9bead4f", "message": "cluster mode collect results", "committedDate": "2020-06-04T15:46:50Z", "type": "commit"}, {"oid": "c28018ea95f6933c45efc225a199233858725f46", "url": "https://github.com/Alluxio/alluxio/commit/c28018ea95f6933c45efc225a199233858725f46", "message": "use annotation to tag ufs tests", "committedDate": "2020-06-05T16:03:48Z", "type": "commit"}, {"oid": "2c760c29d86a603574d96c5486b5ae1db3ccb640", "url": "https://github.com/Alluxio/alluxio/commit/2c760c29d86a603574d96c5486b5ae1db3ccb640", "message": "runUfsTests return TaskResult", "committedDate": "2020-06-06T05:53:58Z", "type": "commit"}, {"oid": "d93f2a1730c55b626344707fe9f6711fd76818c8", "url": "https://github.com/Alluxio/alluxio/commit/d93f2a1730c55b626344707fe9f6711fd76818c8", "message": "fixed on tests", "committedDate": "2020-06-07T07:22:45Z", "type": "commit"}, {"oid": "f6a2818d4d71c313a6b01514506cb181eff35c78", "url": "https://github.com/Alluxio/alluxio/commit/f6a2818d4d71c313a6b01514506cb181eff35c78", "message": "move the tool to another path", "committedDate": "2020-06-07T07:52:54Z", "type": "commit"}, {"oid": "a98d3e8a712ba7ee41ab0cc00e3a07255e4dd862", "url": "https://github.com/Alluxio/alluxio/commit/a98d3e8a712ba7ee41ab0cc00e3a07255e4dd862", "message": "resolve checkstyle", "committedDate": "2020-06-07T10:54:28Z", "type": "commit"}, {"oid": "f988a9410d08d25197d7e54b478398f5cc0bc4c7", "url": "https://github.com/Alluxio/alluxio/commit/f988a9410d08d25197d7e54b478398f5cc0bc4c7", "message": "ser/de from remote hosts", "committedDate": "2020-06-07T13:48:06Z", "type": "commit"}, {"oid": "1137a7ca2d78354e16d760d4ce61eb00676813a3", "url": "https://github.com/Alluxio/alluxio/commit/1137a7ca2d78354e16d760d4ce61eb00676813a3", "message": "print command return", "committedDate": "2020-06-07T13:57:00Z", "type": "commit"}, {"oid": "e8b619001845e62dc02e117ec9730f84dae2c6ac", "url": "https://github.com/Alluxio/alluxio/commit/e8b619001845e62dc02e117ec9730f84dae2c6ac", "message": "use a marker for json", "committedDate": "2020-06-07T14:07:44Z", "type": "commit"}, {"oid": "2eb97e3ad18c8beae94baf481b18120f55e4aa7b", "url": "https://github.com/Alluxio/alluxio/commit/2eb97e3ad18c8beae94baf481b18120f55e4aa7b", "message": "debug printouts", "committedDate": "2020-06-07T14:12:34Z", "type": "commit"}, {"oid": "3cd097302eb6f76a7955a070573fd50441f304c2", "url": "https://github.com/Alluxio/alluxio/commit/3cd097302eb6f76a7955a070573fd50441f304c2", "message": "replace marker", "committedDate": "2020-06-08T05:57:05Z", "type": "commit"}, {"oid": "860c044d90de2bd3ca4734669b91fbf9054afa7f", "url": "https://github.com/Alluxio/alluxio/commit/860c044d90de2bd3ca4734669b91fbf9054afa7f", "message": "handle unknown host", "committedDate": "2020-06-08T06:05:33Z", "type": "commit"}, {"oid": "142db925bc9d2ec39fc536ef2f0172a78127b836", "url": "https://github.com/Alluxio/alluxio/commit/142db925bc9d2ec39fc536ef2f0172a78127b836", "message": "fix unit tests", "committedDate": "2020-06-08T06:26:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NDM5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436674394", "bodyText": "Moved to a more generalized path", "author": "jiacheliu3", "createdAt": "2020-06-08T12:59:45Z", "path": "core/common/src/main/java/alluxio/cli/JsonSerializable.java", "diffHunk": "@@ -9,14 +9,16 @@\n  * See the NOTICE file distributed with this work for information regarding copyright ownership.\n  */\n \n-package alluxio.stress;\n+package alluxio.cli;", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMDE3Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437020176", "bodyText": "this class is also used by job_server, may be moved to alluxio.utils?", "author": "LuQQiu", "createdAt": "2020-06-08T21:47:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NDM5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2OTYxMA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438269610", "bodyText": "SGTM", "author": "jiacheliu3", "createdAt": "2020-06-10T16:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NDM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "99680346c71c20366e5a2065290e915e0e15ea84", "chunk": "diff --git a/core/common/src/main/java/alluxio/cli/JsonSerializable.java b/core/common/src/main/java/alluxio/util/JsonSerializable.java\nsimilarity index 97%\nrename from core/common/src/main/java/alluxio/cli/JsonSerializable.java\nrename to core/common/src/main/java/alluxio/util/JsonSerializable.java\nindex 5ed266e144..0860aaf1dd 100644\n--- a/core/common/src/main/java/alluxio/cli/JsonSerializable.java\n+++ b/core/common/src/main/java/alluxio/util/JsonSerializable.java\n\n@@ -9,10 +9,9 @@\n  * See the NOTICE file distributed with this work for information regarding copyright ownership.\n  */\n \n-package alluxio.cli;\n+package alluxio.util;\n \n import com.fasterxml.jackson.core.JsonProcessingException;\n-import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n import com.fasterxml.jackson.databind.type.MapType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NjIzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436676234", "bodyText": "Is there a better way for this kind of wrapper methods?", "author": "jiacheliu3", "createdAt": "2020-06-08T13:01:38Z", "path": "core/common/src/main/java/alluxio/cli/JsonSerializable.java", "diffHunk": "@@ -51,6 +53,12 @@ default String toJson() throws JsonProcessingException {\n     return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(this);\n   }\n \n+  static <T extends JsonSerializable> String listToJson(List<T> list) throws JsonProcessingException {\n+    ObjectMapper objectMapper = new ObjectMapper();\n+    objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n+    return objectMapper.writeValueAsString(list);\n+  }", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "chunk": "diff --git a/core/common/src/main/java/alluxio/cli/JsonSerializable.java b/core/common/src/main/java/alluxio/util/JsonSerializable.java\nsimilarity index 95%\nrename from core/common/src/main/java/alluxio/cli/JsonSerializable.java\nrename to core/common/src/main/java/alluxio/util/JsonSerializable.java\nindex 5ed266e144..d7b391c03d 100644\n--- a/core/common/src/main/java/alluxio/cli/JsonSerializable.java\n+++ b/core/common/src/main/java/alluxio/util/JsonSerializable.java\n\n@@ -56,7 +55,7 @@ public interface JsonSerializable {\n   static <T extends JsonSerializable> String listToJson(List<T> list) throws JsonProcessingException {\n     ObjectMapper objectMapper = new ObjectMapper();\n     objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false);\n-    return objectMapper.writeValueAsString(list);\n+    return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(list);\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3Njg1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436676859", "bodyText": "Setting these two to public and using this class to parse Alluxio impersonation properties", "author": "jiacheliu3", "createdAt": "2020-06-08T13:02:23Z", "path": "core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java", "diffHunk": "@@ -146,4 +148,12 @@ public void authenticate(String connectionUser, String impersonationUser)\n         connectionUser, impersonationUser, connectionUser, impersonationUser,\n         RuntimeConstants.ALLUXIO_SECURITY_DOCS_URL));\n   }\n+\n+  public Map<String, Set<String>> getImpersonationUsers() {\n+    return Collections.unmodifiableMap(mImpersonationUsers);\n+  }\n+\n+  public Map<String, Set<String>> getmImpersonationGroups() {\n+    return Collections.unmodifiableMap(mImpersonationGroups);\n+  }", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "379f56fea0eae80186e74a782e7f40cd123dd20a", "chunk": "diff --git a/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java b/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java\nindex 7dbbb62613..08a533a288 100644\n--- a/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java\n+++ b/core/common/src/main/java/alluxio/security/authentication/ImpersonationAuthenticator.java\n\n@@ -148,12 +146,4 @@ public final class ImpersonationAuthenticator {\n         connectionUser, impersonationUser, connectionUser, impersonationUser,\n         RuntimeConstants.ALLUXIO_SECURITY_DOCS_URL));\n   }\n-\n-  public Map<String, Set<String>> getImpersonationUsers() {\n-    return Collections.unmodifiableMap(mImpersonationUsers);\n-  }\n-\n-  public Map<String, Set<String>> getmImpersonationGroups() {\n-    return Collections.unmodifiableMap(mImpersonationGroups);\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NzIwNg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436677206", "bodyText": "Moved to a util class", "author": "jiacheliu3", "createdAt": "2020-06-08T13:02:47Z", "path": "integration/tools/src/main/java/alluxio/cli/ValidateHms.java", "diffHunk": "@@ -154,7 +154,7 @@ private boolean checkHmsUri(String uriAddress) throws Exception {\n       uri = new URI(uriAddress);\n     } catch (Throwable t) {\n       mResults.computeIfAbsent(State.FAILED, k -> new ArrayList<>()).add(\n-          new TaskResult(State.FAILED, \"HmsUrisSyntaxCheck\", getErrorInfo(t),\n+          new TaskResult(State.FAILED, \"HmsUrisSyntaxCheck\", ValidateUtils.getErrorInfo(t),", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "chunk": "diff --git a/integration/tools/src/main/java/alluxio/cli/ValidateHms.java b/integration/tools/hms/src/main/java/alluxio/cli/HmsValidationTool.java\nsimilarity index 86%\nrename from integration/tools/src/main/java/alluxio/cli/ValidateHms.java\nrename to integration/tools/hms/src/main/java/alluxio/cli/HmsValidationTool.java\nindex 421215ebf7..c75542c305 100644\n--- a/integration/tools/src/main/java/alluxio/cli/ValidateHms.java\n+++ b/integration/tools/hms/src/main/java/alluxio/cli/HmsValidationTool.java\n\n@@ -154,7 +162,7 @@ public class ValidateHms {\n       uri = new URI(uriAddress);\n     } catch (Throwable t) {\n       mResults.computeIfAbsent(State.FAILED, k -> new ArrayList<>()).add(\n-          new TaskResult(State.FAILED, \"HmsUrisSyntaxCheck\", ValidateUtils.getErrorInfo(t),\n+          new TaskResult(State.FAILED, \"HmsUrisSyntaxCheck\", ValidationUtils.getErrorInfo(t),\n               \"Please make sure the given hive metastore uri(s) is valid\"));\n       throw t;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3NzY0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436677646", "bodyText": "Using JsonSerializable to do serialization.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:03:16Z", "path": "integration/tools/src/main/java/alluxio/cli/ValidateUtils.java", "diffHunk": "@@ -37,7 +41,7 @@ private ValidateUtils() {} // prevent instantiation\n   /**\n    * Represents the result of a given task.\n    */\n-  public static class TaskResult implements Serializable {\n+  public static class TaskResult implements JsonSerializable {", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6cc3601cdb607fc574c650a6caf4131e72e88ed1", "chunk": "diff --git a/integration/tools/src/main/java/alluxio/cli/ValidateUtils.java b/core/common/src/main/java/alluxio/cli/ValidationUtils.java\nsimilarity index 82%\nrename from integration/tools/src/main/java/alluxio/cli/ValidateUtils.java\nrename to core/common/src/main/java/alluxio/cli/ValidationUtils.java\nindex 4934da4009..3f25810aed 100644\n--- a/integration/tools/src/main/java/alluxio/cli/ValidateUtils.java\n+++ b/core/common/src/main/java/alluxio/cli/ValidationUtils.java\n\n@@ -41,7 +35,7 @@ public final class ValidateUtils {\n   /**\n    * Represents the result of a given task.\n    */\n-  public static class TaskResult implements JsonSerializable {\n+  public static class TaskResult implements Serializable {\n     private static final long serialVersionUID = -2746652850515278409L;\n \n     State mState = State.OK;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3ODM5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436678390", "bodyText": "Updated this test to be able to validate a nested mount path", "author": "jiacheliu3", "createdAt": "2020-06-08T13:04:06Z", "path": "shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java", "diffHunk": "@@ -52,14 +60,31 @@\n   @Parameter(names = {\"--help\"}, help = true)\n   private boolean mHelp = false;\n \n-  private InstancedConfiguration mConf\n-      = new InstancedConfiguration(ConfigurationUtils.defaults());\n-\n+  private InstancedConfiguration mConf;\n   private UnderFileSystem mUfs;\n \n-  private UnderFileSystemContractTest() {}\n+  /**\n+   * A constructor from default.\n+   * */\n+  public UnderFileSystemContractTest() {\n+    mConf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+  }\n \n-  private void run() throws Exception {\n+  /**\n+   * Initiate the tests for a specific UFS path and UFS configs.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFs configurations\n+   * */\n+  public UnderFileSystemContractTest(String path, InstancedConfiguration conf) {\n+    mUfsPath = path;\n+    mConf = conf;\n+  }", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY3OTY3NQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436679675", "bodyText": "Use a constructor now instead of static block, as the validation can be against a nested mount.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:05:31Z", "path": "shell/src/main/java/alluxio/cli/ValidateEnv.java", "diffHunk": "@@ -87,80 +93,108 @@\n   private static final List<ValidationTask> MASTER_TASKS = new ArrayList<>();\n   private static final List<ValidationTask> WORKER_TASKS = new ArrayList<>();\n \n-  private static final AlluxioConfiguration CONF;\n+  private final AlluxioConfiguration mConf;\n+  private final String mPath;\n \n-  static {\n-    CONF = InstancedConfiguration.defaults();", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "55b44bfc643ceb4b0dbac02bc4bd6d67b7808116", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/ValidateEnv.java b/shell/src/main/java/alluxio/cli/ValidateEnv.java\nindex 491ecaf0b7..1621dcff23 100644\n--- a/shell/src/main/java/alluxio/cli/ValidateEnv.java\n+++ b/shell/src/main/java/alluxio/cli/ValidateEnv.java\n\n@@ -167,9 +167,9 @@ public final class ValidateEnv {\n     registerTask(\"ufs.path.accessible\",\n         \"validate the under file system location is accessible\",\n         new UfsDirectoryValidationTask(mPath, mConf), COMMON_TASKS);\n-    registerTask(\"ufs.root.superuser\",\n-        \"validate Alluxio has super user privilege on root under file system\",\n-        new UfsSuperUserValidationTask(mConf), COMMON_TASKS);\n+    registerTask(\"ufs.path.superuser\",\n+        \"validate Alluxio has super user privilege on the under file system\",\n+        new UfsSuperUserValidationTask(mPath, mConf), COMMON_TASKS);\n \n     // RAM disk validations\n     registerTask(\"worker.ramdisk.mount.privilege\",\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MDU1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436680552", "bodyText": "After some tests I find JCommand to be better. Will refactor this to use JCommand.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:06:29Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package alluxio.cli;\n+\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.Source;\n+import alluxio.shell.CommandReturn;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.ShellUtils;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A tool to validate an HDFS mount, before the paths is mounted to Alluxio.\n+ * */\n+public class ValidateHdfsMount {\n+  private static final Logger LOG = LoggerFactory.getLogger(ValidateHdfsMount.class);\n+  private static final String JSON_START_POS_MARKER = \"ValidateHdfsMount task results: \\n\";\n+\n+  private static final Option READONLY_OPTION =\n+          Option.builder()\n+                  .longOpt(\"readonly\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is readonly in Alluxio\")\n+                  .build();\n+  private static final Option SHARED_OPTION =\n+          Option.builder()\n+                  .longOpt(\"shared\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is shared\")\n+                  .build();\n+  private static final Option OPTION_OPTION =\n+          Option.builder()\n+                  .longOpt(\"option\")\n+                  .required(false)\n+                  .hasArg(true)\n+                  .numberOfArgs(2)\n+                  .argName(\"key=value\")\n+                  .valueSeparator('=')\n+                  .desc(\"options associated with this mount point\")\n+                  .build();\n+  private static final Option LOCAL_OPTION =\n+          Option.builder().required(false).longOpt(\"local\").hasArg(false)\n+                  .desc(\"running only on localhost\").build();\n+  private static final Options OPTIONS =\n+          new Options().addOption(READONLY_OPTION).addOption(SHARED_OPTION)\n+                  .addOption(OPTION_OPTION).addOption(LOCAL_OPTION);\n+\n+  /**\n+   * Invokes {@link UnderFileSystemContractTest} to validate UFS operations.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS conf\n+   * @return a {@link alluxio.cli.ValidateUtils.TaskResult} containing the validation result\n+   *        of the UFS operations\n+   * */\n+  public static ValidateUtils.TaskResult runUfsTests(String path, InstancedConfiguration conf) {\n+    try {\n+      UnderFileSystemContractTest test = new UnderFileSystemContractTest(path, conf);\n+      return test.runValidationTask();\n+    } catch (IOException e) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.FAILED, \"ufsTests\",\n+              ValidateUtils.getErrorInfo(e), \"\");\n+    }\n+  }\n+\n+  /**\n+   * The entrance.\n+   *\n+   * @param args command line arguments\n+   * */\n+  public static void main(String[] args) throws Exception {\n+    // TODO(jiacheng): use jccommand?", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MDY0OA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438280648", "bodyText": "do you still plan on addressing this?", "author": "madanadit", "createdAt": "2020-06-10T17:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MDU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc2MTgzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438761831", "bodyText": "Not really, i'll remove this TODO. I found the existing cmdline works just fine. JCommand is not a better option anymore.", "author": "jiacheliu3", "createdAt": "2020-06-11T12:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MDU1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\nindex 16a1cc4026..ad8594c314 100644\n--- a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n+++ b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n\n@@ -189,8 +189,10 @@ public class ValidateHdfsMount {\n     for (Map.Entry<String, CompletableFuture<CommandReturn>> entry : resultFuture.entrySet()) {\n       String host = entry.getKey();\n       CommandReturn cr = entry.getValue().get();\n-      System.out.format(\"Host %s%nStatus: %s%n\", host, cr.getExitCode());\n-      System.out.println(cr.getFormattedOutput());\n+      if (cr.getExitCode() != 0) {\n+        System.err.format(\"Failed to run validateHdfsMount on host %s.%n%s%n\", host, cr.getFormattedOutput());\n+        continue;\n+      }\n \n       // Deserialize from JSON\n       List<ValidateUtils.TaskResult> taskResults = parseTaskResults(cr.getOutput());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MTExMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436681111", "bodyText": "This will be resolved", "author": "jiacheliu3", "createdAt": "2020-06-08T13:07:04Z", "path": "shell/src/main/java/alluxio/cli/validation/HadoopConfigurationFileParser.java", "diffHunk": "@@ -87,4 +87,32 @@ public HadoopConfigurationFileParser() {}\n     }\n     return ret;\n   }\n+\n+  // TODO(jiacheng): keep only one", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4ad06f2a3bafa66919b0a18f2ed142c30e1e9337", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/HadoopConfigurationFileParser.java b/shell/src/main/java/alluxio/cli/validation/hdfs/HadoopConfigurationFileParser.java\nsimilarity index 59%\nrename from shell/src/main/java/alluxio/cli/validation/HadoopConfigurationFileParser.java\nrename to shell/src/main/java/alluxio/cli/validation/hdfs/HadoopConfigurationFileParser.java\nindex 663ac6c023..8f69dc4d16 100644\n--- a/shell/src/main/java/alluxio/cli/validation/HadoopConfigurationFileParser.java\n+++ b/shell/src/main/java/alluxio/cli/validation/hdfs/HadoopConfigurationFileParser.java\n\n@@ -45,51 +45,7 @@ public class HadoopConfigurationFileParser {\n    * @param path path to the xml file\n    * @return Map from property names to values\n    */\n-  @Nullable\n-  public Map<String, String> parseXmlConfiguration(final String path) {\n-    File xmlFile;\n-    xmlFile = new File(path);\n-    if (!xmlFile.exists()) {\n-      System.err.format(\"File %s does not exist.\", path);\n-      return null;\n-    }\n-    DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();\n-    DocumentBuilder docBuilder;\n-    try {\n-      docBuilder = docBuilderFactory.newDocumentBuilder();\n-    } catch (ParserConfigurationException e) {\n-      System.err.format(\"Failed to create instance of DocumentBuilder for file: %s. %s. %n\",\n-          path, e.getMessage());\n-      return null;\n-    }\n-    Document doc;\n-    try {\n-      doc = docBuilder.parse(xmlFile);\n-    } catch (IOException e) {\n-      System.err.format(\"An I/O error occured reading file %s. %s.%n\", path, e.getMessage());\n-      return null;\n-    } catch (SAXException e) {\n-      System.err.format(\"A parsing error occured parsing file %s. %s.%n\", path, e.getMessage());\n-      return null;\n-    }\n-    // Optional, but recommended.\n-    // Refer to http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work\n-    doc.getDocumentElement().normalize();\n-    Map<String, String> ret = new HashMap<>();\n-    NodeList propNodeList = doc.getElementsByTagName(\"property\");\n-    for (int i = 0; i < propNodeList.getLength(); i++) {\n-      Node propNode = propNodeList.item(i);\n-      if (propNode.getNodeType() == Node.ELEMENT_NODE) {\n-        Element element = (Element) propNode;\n-        ret.put(element.getElementsByTagName(\"name\").item(0).getTextContent(),\n-            element.getElementsByTagName(\"value\").item(0).getTextContent());\n-      }\n-    }\n-    return ret;\n-  }\n-\n-  // TODO(jiacheng): keep only one\n-  public Map<String, String> parseXmlConfNonNull(final String path)\n+  public Map<String, String> parseXmlConfiguration(final String path)\n           throws IOException, SAXException, ParserConfigurationException {\n     File xmlFile;\n     xmlFile = new File(path);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4MjY2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436682668", "bodyText": "This is the previous alluxio.cli.validation.HdfsValidationTask where the hdfs configs defined in Alluxio property are compared against the hadoop config defined in hadoop env variables.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:08:44Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsConfParityValidationTask.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.util.io.PathUtils;\n+\n+import org.apache.commons.cli.Option;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Compares HDFS configuration in Alluxio and in HDFS environment variables.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsConfParityValidationTask extends HdfsConfValidationTask {", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "94e6c76210f158292c8e7e6d293422fead2fb400", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/HdfsConfParityValidationTask.java b/shell/src/main/java/alluxio/cli/validation/hdfs/HdfsConfParityValidationTask.java\nsimilarity index 98%\nrename from shell/src/main/java/alluxio/cli/validation/HdfsConfParityValidationTask.java\nrename to shell/src/main/java/alluxio/cli/validation/hdfs/HdfsConfParityValidationTask.java\nindex 069aad403e..48c4f79468 100644\n--- a/shell/src/main/java/alluxio/cli/validation/HdfsConfParityValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/hdfs/HdfsConfParityValidationTask.java\n\n@@ -1,6 +1,7 @@\n-package alluxio.cli.validation;\n+package alluxio.cli.validation.hdfs;\n \n import alluxio.cli.ValidateUtils;\n+import alluxio.cli.validation.ApplicableUfsType;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.util.io.PathUtils;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NTIzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436685234", "bodyText": "Do we want to assume the current running user needs impersonation? I don't think so.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:11:26Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.security.authentication.ImpersonationAuthenticator;\n+import alluxio.util.network.NetworkAddressUtils;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the impersonation configurations in alluxio and hdfs.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsImpersonationValidationTask extends HdfsConfValidationTask {\n+  private final Map<String, Set<String>> mImpersonationUsers;\n+  private final Map<String, Set<String>> mImpersonationGroups;\n+  private final Mode mMode;\n+\n+  /**\n+   * Creates a new instance of {@link HdfsImpersonationValidationTask}\n+   * for validating impersonation configuration.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n+   * @param mode the mode for validation\n+   */\n+  public HdfsImpersonationValidationTask(String path, AlluxioConfiguration conf, Mode mode) {\n+    super(path, conf);\n+    mMode = mode;\n+    ImpersonationAuthenticator ia = new ImpersonationAuthenticator(mConf);\n+    mImpersonationUsers = ia.getImpersonationUsers();\n+    mImpersonationGroups = ia.getmImpersonationGroups();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return String.format(\"ValidateImpersonationConf%s\", mMode);\n+  }\n+\n+  private boolean shouldSkip() {\n+    // If no impersonation setting in Alluxio, skip the check\n+    if (mImpersonationUsers.entrySet().size() == 0\n+            && mImpersonationGroups.size() == 0) {\n+      mMsg.append(\"No impersonation setting found in Alluxio. \"\n+              + \"Skip the impersonation validation step.\\n\");\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private ValidateUtils.TaskResult validateImpersonationUsers() {\n+    String taskName = \"Validate alluxio impersonation users\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationUsers.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impUsers = entry.getValue();\n+      PropertyKey alluxioKey =\n+              PropertyKey.Template.MASTER_IMPERSONATION_USERS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. %n\",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation user is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser.%n\",\n+                hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s.%n\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpUsers = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impUsers.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any user in Alluxio and HDFS.%n\",\n+                  userName));\n+        } else {\n+          state = ValidateUtils.State.FAILED;\n+          msg.append(String.format(\"User %s can impersonate any user in \"\n+                  + \"Alluxio but only %s in HDFS.%n\", userName, hdfsImpUsers));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any user in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // Not using wildcard, compare the exact usernames\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpUsers.split(\",\")));\n+      System.out.format(\"Impersonable users: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more users than defined in Alluxio\n+      Set<String> missedUsers = Sets.difference(impUsers, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed users %s%n\", missedUsers);\n+      if (missedUsers.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as users %s in Alluxio but \"\n+                + \"not in HDFS.%n\", userName, missedUsers));\n+        advice.append(String.format(\"Please add the missing users to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(\"All impersonable users in Alluxio are found in HDFS. \\n\");\n+    }\n+\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // TODO(jiacheng): refactor with users logic\n+  private ValidateUtils.TaskResult validateImpersonationGroups() {\n+    String taskName = \"Validate alluxio impersonation groups\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationGroups.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impGroups = entry.getValue();\n+      PropertyKey alluxioKey = PropertyKey.Template\n+              .MASTER_IMPERSONATION_GROUPS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. \",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation group is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser. \", hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpGroups = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impGroups.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any group in \"\n+                  + \"Alluxio and HDFS. \", userName));\n+        } else {\n+          msg.append(String.format(\"User %s can impersonate any group \"\n+                  + \"in Alluxio but not in HDFS. \", userName));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any group in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // The impersonation group has different configuration in core-site.xml\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpGroups.split(\",\")));\n+      System.out.format(\"Impersonable groups: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more groups than defined in Alluxio\n+      Set<String> missedGroups = Sets.difference(impGroups, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed groups %s%n\", missedGroups);\n+      if (missedGroups.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as groups %s \"\n+                + \"in Alluxio but not in HDFS.\", userName, missedGroups));\n+        advice.append(String.format(\"Please add the missing groups to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(String.format(\"Found matching configuration in %s and %s. \",\n+              alluxioKey.toString(), hdfsKey));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // At least the current host should be in hadoop.proxy.<username>.hosts\n+  private ValidateUtils.TaskResult validateImpersonationHosts() {\n+    String taskName = \"Validate proxyuser hosts\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+\n+    // current host\n+    String localhost = NetworkAddressUtils.getLocalHostName(1000);\n+\n+    // All the possible users Alluxio needs\n+    Set<String> allUsers = Sets.union(mImpersonationUsers.keySet(), mImpersonationGroups.keySet());\n+    for (String userName : allUsers) {\n+      msg.append(String.format(\"User %s is configured to allow impersonation is Alluxio. \",\n+              userName));\n+\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.hosts\", userName);\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(\"But the user is not allowed to use impersonation on this host.\");\n+        advice.append(String.format(\"Please configure %s to contain %s. \", hdfsKey, localhost));\n+        continue;\n+      }\n+\n+      String proxyHosts = mCoreConf.get(hdfsKey);\n+      // Consider wildcard separately\n+      if (proxyHosts.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"The user is enabled for impersonation from all hosts. \"));\n+        continue;\n+      }\n+      // If wildcard is not used and the localhost is not in the permitted list\n+      if (!proxyHosts.contains(localhost)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s does not contain host %s. \", hdfsKey, localhost));\n+        advice.append(String.format(\"Please enable host %s in %s. \", localhost, hdfsKey));\n+        continue;\n+      }\n+\n+      // Passed all checks\n+      msg.append(String.format(\"Host %s is enabled to use impersonation in HDFS. \", localhost));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  @Override\n+  public ValidateUtils.TaskResult validate(Map<String, String> optionMap) {\n+    if (shouldSkip()) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED, getName(),\n+              mMsg.toString(), mAdvice.toString());\n+    }\n+\n+    ValidateUtils.TaskResult loadConfig = loadHdfsConfig();\n+    if (loadConfig.getState() != ValidateUtils.State.OK) {\n+      return loadConfig;\n+    }\n+\n+    // TODO(jiacheng): do we want to check the current user even if", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "94e6c76210f158292c8e7e6d293422fead2fb400", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java b/shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java\ndeleted file mode 100644\nindex c5f752fbed..0000000000\n--- a/shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java\n+++ /dev/null\n\n@@ -1,264 +0,0 @@\n-package alluxio.cli.validation;\n-\n-import alluxio.cli.ValidateUtils;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.PropertyKey;\n-import alluxio.security.authentication.ImpersonationAuthenticator;\n-import alluxio.util.network.NetworkAddressUtils;\n-\n-import com.google.common.collect.Sets;\n-\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Validates the impersonation configurations in alluxio and hdfs.\n- * */\n-@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n-public class HdfsImpersonationValidationTask extends HdfsConfValidationTask {\n-  private final Map<String, Set<String>> mImpersonationUsers;\n-  private final Map<String, Set<String>> mImpersonationGroups;\n-  private final Mode mMode;\n-\n-  /**\n-   * Creates a new instance of {@link HdfsImpersonationValidationTask}\n-   * for validating impersonation configuration.\n-   *\n-   * @param path the UFS path\n-   * @param conf the UFS configuration\n-   * @param mode the mode for validation\n-   */\n-  public HdfsImpersonationValidationTask(String path, AlluxioConfiguration conf, Mode mode) {\n-    super(path, conf);\n-    mMode = mode;\n-    ImpersonationAuthenticator ia = new ImpersonationAuthenticator(mConf);\n-    mImpersonationUsers = ia.getImpersonationUsers();\n-    mImpersonationGroups = ia.getmImpersonationGroups();\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return String.format(\"ValidateImpersonationConf%s\", mMode);\n-  }\n-\n-  private boolean shouldSkip() {\n-    // If no impersonation setting in Alluxio, skip the check\n-    if (mImpersonationUsers.entrySet().size() == 0\n-            && mImpersonationGroups.size() == 0) {\n-      mMsg.append(\"No impersonation setting found in Alluxio. \"\n-              + \"Skip the impersonation validation step.\\n\");\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  private ValidateUtils.TaskResult validateImpersonationUsers() {\n-    String taskName = \"Validate alluxio impersonation users\";\n-    ValidateUtils.State state = ValidateUtils.State.OK;\n-    StringBuilder msg = new StringBuilder();\n-    StringBuilder advice = new StringBuilder();\n-    for (Map.Entry<String, Set<String>> entry : mImpersonationUsers.entrySet()) {\n-      String userName = entry.getKey();\n-      Set<String> impUsers = entry.getValue();\n-      PropertyKey alluxioKey =\n-              PropertyKey.Template.MASTER_IMPERSONATION_USERS_OPTION.format(userName);\n-      String hdfsKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n-      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. %n\",\n-              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n-\n-      // The impersonation user is not configured in core-site.xml\n-      if (!mCoreConf.containsKey(hdfsKey)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"But %s is not configured in hadoop proxyuser.%n\",\n-                hdfsKey));\n-        advice.append(String.format(\"Please configure %s to match %s.%n\",\n-                hdfsKey, alluxioKey.toString()));\n-        continue;\n-      }\n-      String hdfsImpUsers = mCoreConf.get(hdfsKey);\n-\n-      // Consider wildcard separately\n-      if (impUsers.contains(ImpersonationAuthenticator.WILDCARD)) {\n-        if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n-          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n-          msg.append(String.format(\"User %s can impersonate any user in Alluxio and HDFS.%n\",\n-                  userName));\n-        } else {\n-          state = ValidateUtils.State.FAILED;\n-          msg.append(String.format(\"User %s can impersonate any user in \"\n-                  + \"Alluxio but only %s in HDFS.%n\", userName, hdfsImpUsers));\n-          advice.append(String.format(\"Please set %s to %s. \",\n-                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n-        }\n-        continue;\n-      } else if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n-        msg.append(String.format(\"User %s can impersonate any user in HDFS.%n\", userName));\n-        continue;\n-      }\n-\n-      // Not using wildcard, compare the exact usernames\n-      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpUsers.split(\",\")));\n-      System.out.format(\"Impersonable users: %s%n\", nameSet);\n-      // The proxyuser can be enabled to impersonate more users than defined in Alluxio\n-      Set<String> missedUsers = Sets.difference(impUsers, nameSet); // in alluxio not in hdfs\n-      System.out.format(\"Found missed users %s%n\", missedUsers);\n-      if (missedUsers.size() > 0) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"User %s can impersonate as users %s in Alluxio but \"\n-                + \"not in HDFS.%n\", userName, missedUsers));\n-        advice.append(String.format(\"Please add the missing users to %s. \", hdfsKey));\n-        continue;\n-      }\n-\n-      // All checks passed\n-      msg.append(\"All impersonable users in Alluxio are found in HDFS. \\n\");\n-    }\n-\n-    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n-  }\n-\n-  // TODO(jiacheng): refactor with users logic\n-  private ValidateUtils.TaskResult validateImpersonationGroups() {\n-    String taskName = \"Validate alluxio impersonation groups\";\n-    ValidateUtils.State state = ValidateUtils.State.OK;\n-    StringBuilder msg = new StringBuilder();\n-    StringBuilder advice = new StringBuilder();\n-    for (Map.Entry<String, Set<String>> entry : mImpersonationGroups.entrySet()) {\n-      String userName = entry.getKey();\n-      Set<String> impGroups = entry.getValue();\n-      PropertyKey alluxioKey = PropertyKey.Template\n-              .MASTER_IMPERSONATION_GROUPS_OPTION.format(userName);\n-      String hdfsKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n-      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. \",\n-              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n-\n-      // The impersonation group is not configured in core-site.xml\n-      if (!mCoreConf.containsKey(hdfsKey)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"But %s is not configured in hadoop proxyuser. \", hdfsKey));\n-        advice.append(String.format(\"Please configure %s to match %s\",\n-                hdfsKey, alluxioKey.toString()));\n-        continue;\n-      }\n-      String hdfsImpGroups = mCoreConf.get(hdfsKey);\n-\n-      // Consider wildcard separately\n-      if (impGroups.contains(ImpersonationAuthenticator.WILDCARD)) {\n-        if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n-          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n-          msg.append(String.format(\"User %s can impersonate any group in \"\n-                  + \"Alluxio and HDFS. \", userName));\n-        } else {\n-          msg.append(String.format(\"User %s can impersonate any group \"\n-                  + \"in Alluxio but not in HDFS. \", userName));\n-          advice.append(String.format(\"Please set %s to %s. \",\n-                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n-        }\n-        continue;\n-      } else if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n-        msg.append(String.format(\"User %s can impersonate any group in HDFS.%n\", userName));\n-        continue;\n-      }\n-\n-      // The impersonation group has different configuration in core-site.xml\n-      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpGroups.split(\",\")));\n-      System.out.format(\"Impersonable groups: %s%n\", nameSet);\n-      // The proxyuser can be enabled to impersonate more groups than defined in Alluxio\n-      Set<String> missedGroups = Sets.difference(impGroups, nameSet); // in alluxio not in hdfs\n-      System.out.format(\"Found missed groups %s%n\", missedGroups);\n-      if (missedGroups.size() > 0) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"User %s can impersonate as groups %s \"\n-                + \"in Alluxio but not in HDFS.\", userName, missedGroups));\n-        advice.append(String.format(\"Please add the missing groups to %s. \", hdfsKey));\n-        continue;\n-      }\n-\n-      // All checks passed\n-      msg.append(String.format(\"Found matching configuration in %s and %s. \",\n-              alluxioKey.toString(), hdfsKey));\n-    }\n-    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n-  }\n-\n-  // At least the current host should be in hadoop.proxy.<username>.hosts\n-  private ValidateUtils.TaskResult validateImpersonationHosts() {\n-    String taskName = \"Validate proxyuser hosts\";\n-    ValidateUtils.State state = ValidateUtils.State.OK;\n-    StringBuilder msg = new StringBuilder();\n-    StringBuilder advice = new StringBuilder();\n-\n-    // current host\n-    String localhost = NetworkAddressUtils.getLocalHostName(1000);\n-\n-    // All the possible users Alluxio needs\n-    Set<String> allUsers = Sets.union(mImpersonationUsers.keySet(), mImpersonationGroups.keySet());\n-    for (String userName : allUsers) {\n-      msg.append(String.format(\"User %s is configured to allow impersonation is Alluxio. \",\n-              userName));\n-\n-      String hdfsKey = String.format(\"hadoop.proxyuser.%s.hosts\", userName);\n-      if (!mCoreConf.containsKey(hdfsKey)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(\"But the user is not allowed to use impersonation on this host.\");\n-        advice.append(String.format(\"Please configure %s to contain %s. \", hdfsKey, localhost));\n-        continue;\n-      }\n-\n-      String proxyHosts = mCoreConf.get(hdfsKey);\n-      // Consider wildcard separately\n-      if (proxyHosts.equals(ImpersonationAuthenticator.WILDCARD)) {\n-        msg.append(String.format(\"The user is enabled for impersonation from all hosts. \"));\n-        continue;\n-      }\n-      // If wildcard is not used and the localhost is not in the permitted list\n-      if (!proxyHosts.contains(localhost)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"But %s does not contain host %s. \", hdfsKey, localhost));\n-        advice.append(String.format(\"Please enable host %s in %s. \", localhost, hdfsKey));\n-        continue;\n-      }\n-\n-      // Passed all checks\n-      msg.append(String.format(\"Host %s is enabled to use impersonation in HDFS. \", localhost));\n-    }\n-    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n-  }\n-\n-  @Override\n-  public ValidateUtils.TaskResult validate(Map<String, String> optionMap) {\n-    if (shouldSkip()) {\n-      return new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED, getName(),\n-              mMsg.toString(), mAdvice.toString());\n-    }\n-\n-    ValidateUtils.TaskResult loadConfig = loadHdfsConfig();\n-    if (loadConfig.getState() != ValidateUtils.State.OK) {\n-      return loadConfig;\n-    }\n-\n-    // TODO(jiacheng): do we want to check the current user even if\n-    //  there's no impersonation setting?\n-    switch (mMode) {\n-      case USERS:\n-        return validateImpersonationUsers();\n-      case GROUPS:\n-        return validateImpersonationGroups();\n-      case HOSTS:\n-        return validateImpersonationHosts();\n-      default:\n-        throw new RuntimeException(String.format(\"Unknown validation mode %s\", mMode));\n-    }\n-  }\n-\n-  /**\n-   * The mode for impersonation check.\n-   * */\n-  public enum Mode {\n-    USERS,\n-    GROUPS,\n-    HOSTS\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NjcxMw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436686713", "bodyText": "One limitation of the current check is, we can only know which users need impersonation based on the Alluxio properties. If the user does not define alluxio.security.impersonation.bob.users field, there's no way to know if bob needs to be validated.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:13:02Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.security.authentication.ImpersonationAuthenticator;\n+import alluxio.util.network.NetworkAddressUtils;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Validates the impersonation configurations in alluxio and hdfs.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsImpersonationValidationTask extends HdfsConfValidationTask {\n+  private final Map<String, Set<String>> mImpersonationUsers;\n+  private final Map<String, Set<String>> mImpersonationGroups;\n+  private final Mode mMode;\n+\n+  /**\n+   * Creates a new instance of {@link HdfsImpersonationValidationTask}\n+   * for validating impersonation configuration.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n+   * @param mode the mode for validation\n+   */\n+  public HdfsImpersonationValidationTask(String path, AlluxioConfiguration conf, Mode mode) {\n+    super(path, conf);\n+    mMode = mode;\n+    ImpersonationAuthenticator ia = new ImpersonationAuthenticator(mConf);\n+    mImpersonationUsers = ia.getImpersonationUsers();\n+    mImpersonationGroups = ia.getmImpersonationGroups();\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return String.format(\"ValidateImpersonationConf%s\", mMode);\n+  }\n+\n+  private boolean shouldSkip() {\n+    // If no impersonation setting in Alluxio, skip the check\n+    if (mImpersonationUsers.entrySet().size() == 0\n+            && mImpersonationGroups.size() == 0) {\n+      mMsg.append(\"No impersonation setting found in Alluxio. \"\n+              + \"Skip the impersonation validation step.\\n\");\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private ValidateUtils.TaskResult validateImpersonationUsers() {\n+    String taskName = \"Validate alluxio impersonation users\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationUsers.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impUsers = entry.getValue();\n+      PropertyKey alluxioKey =\n+              PropertyKey.Template.MASTER_IMPERSONATION_USERS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. %n\",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation user is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser.%n\",\n+                hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s.%n\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpUsers = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impUsers.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any user in Alluxio and HDFS.%n\",\n+                  userName));\n+        } else {\n+          state = ValidateUtils.State.FAILED;\n+          msg.append(String.format(\"User %s can impersonate any user in \"\n+                  + \"Alluxio but only %s in HDFS.%n\", userName, hdfsImpUsers));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any user in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // Not using wildcard, compare the exact usernames\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpUsers.split(\",\")));\n+      System.out.format(\"Impersonable users: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more users than defined in Alluxio\n+      Set<String> missedUsers = Sets.difference(impUsers, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed users %s%n\", missedUsers);\n+      if (missedUsers.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as users %s in Alluxio but \"\n+                + \"not in HDFS.%n\", userName, missedUsers));\n+        advice.append(String.format(\"Please add the missing users to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(\"All impersonable users in Alluxio are found in HDFS. \\n\");\n+    }\n+\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // TODO(jiacheng): refactor with users logic\n+  private ValidateUtils.TaskResult validateImpersonationGroups() {\n+    String taskName = \"Validate alluxio impersonation groups\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+    for (Map.Entry<String, Set<String>> entry : mImpersonationGroups.entrySet()) {\n+      String userName = entry.getKey();\n+      Set<String> impGroups = entry.getValue();\n+      PropertyKey alluxioKey = PropertyKey.Template\n+              .MASTER_IMPERSONATION_GROUPS_OPTION.format(userName);\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n+      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. \",\n+              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n+\n+      // The impersonation group is not configured in core-site.xml\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s is not configured in hadoop proxyuser. \", hdfsKey));\n+        advice.append(String.format(\"Please configure %s to match %s\",\n+                hdfsKey, alluxioKey.toString()));\n+        continue;\n+      }\n+      String hdfsImpGroups = mCoreConf.get(hdfsKey);\n+\n+      // Consider wildcard separately\n+      if (impGroups.contains(ImpersonationAuthenticator.WILDCARD)) {\n+        if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n+          msg.append(String.format(\"User %s can impersonate any group in \"\n+                  + \"Alluxio and HDFS. \", userName));\n+        } else {\n+          msg.append(String.format(\"User %s can impersonate any group \"\n+                  + \"in Alluxio but not in HDFS. \", userName));\n+          advice.append(String.format(\"Please set %s to %s. \",\n+                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n+        }\n+        continue;\n+      } else if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"User %s can impersonate any group in HDFS.%n\", userName));\n+        continue;\n+      }\n+\n+      // The impersonation group has different configuration in core-site.xml\n+      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpGroups.split(\",\")));\n+      System.out.format(\"Impersonable groups: %s%n\", nameSet);\n+      // The proxyuser can be enabled to impersonate more groups than defined in Alluxio\n+      Set<String> missedGroups = Sets.difference(impGroups, nameSet); // in alluxio not in hdfs\n+      System.out.format(\"Found missed groups %s%n\", missedGroups);\n+      if (missedGroups.size() > 0) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"User %s can impersonate as groups %s \"\n+                + \"in Alluxio but not in HDFS.\", userName, missedGroups));\n+        advice.append(String.format(\"Please add the missing groups to %s. \", hdfsKey));\n+        continue;\n+      }\n+\n+      // All checks passed\n+      msg.append(String.format(\"Found matching configuration in %s and %s. \",\n+              alluxioKey.toString(), hdfsKey));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  // At least the current host should be in hadoop.proxy.<username>.hosts\n+  private ValidateUtils.TaskResult validateImpersonationHosts() {\n+    String taskName = \"Validate proxyuser hosts\";\n+    ValidateUtils.State state = ValidateUtils.State.OK;\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n+\n+    // current host\n+    String localhost = NetworkAddressUtils.getLocalHostName(1000);\n+\n+    // All the possible users Alluxio needs\n+    Set<String> allUsers = Sets.union(mImpersonationUsers.keySet(), mImpersonationGroups.keySet());\n+    for (String userName : allUsers) {\n+      msg.append(String.format(\"User %s is configured to allow impersonation is Alluxio. \",\n+              userName));\n+\n+      String hdfsKey = String.format(\"hadoop.proxyuser.%s.hosts\", userName);\n+      if (!mCoreConf.containsKey(hdfsKey)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(\"But the user is not allowed to use impersonation on this host.\");\n+        advice.append(String.format(\"Please configure %s to contain %s. \", hdfsKey, localhost));\n+        continue;\n+      }\n+\n+      String proxyHosts = mCoreConf.get(hdfsKey);\n+      // Consider wildcard separately\n+      if (proxyHosts.equals(ImpersonationAuthenticator.WILDCARD)) {\n+        msg.append(String.format(\"The user is enabled for impersonation from all hosts. \"));\n+        continue;\n+      }\n+      // If wildcard is not used and the localhost is not in the permitted list\n+      if (!proxyHosts.contains(localhost)) {\n+        state = ValidateUtils.State.FAILED;\n+        msg.append(String.format(\"But %s does not contain host %s. \", hdfsKey, localhost));\n+        advice.append(String.format(\"Please enable host %s in %s. \", localhost, hdfsKey));\n+        continue;\n+      }\n+\n+      // Passed all checks\n+      msg.append(String.format(\"Host %s is enabled to use impersonation in HDFS. \", localhost));\n+    }\n+    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n+  }\n+\n+  @Override\n+  public ValidateUtils.TaskResult validate(Map<String, String> optionMap) {\n+    if (shouldSkip()) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED, getName(),\n+              mMsg.toString(), mAdvice.toString());\n+    }\n+\n+    ValidateUtils.TaskResult loadConfig = loadHdfsConfig();\n+    if (loadConfig.getState() != ValidateUtils.State.OK) {\n+      return loadConfig;\n+    }\n+\n+    // TODO(jiacheng): do we want to check the current user even if\n+    //  there's no impersonation setting?\n+    switch (mMode) {\n+      case USERS:\n+        return validateImpersonationUsers();\n+      case GROUPS:\n+        return validateImpersonationGroups();\n+      case HOSTS:\n+        return validateImpersonationHosts();", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4OTMwNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436689304", "bodyText": "@LuQQiu One slightly better way is to define a list of users that we \"think\" should have impersonation, like \"presto, yarn, spark\", and give a warning if they are not configured. But then the drawback is, we will subsequently complain if those users are not configured in hadoop core-site.xml, which may be confusing to those who don't need these users.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4NjcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "94e6c76210f158292c8e7e6d293422fead2fb400", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java b/shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java\ndeleted file mode 100644\nindex c5f752fbed..0000000000\n--- a/shell/src/main/java/alluxio/cli/validation/HdfsImpersonationValidationTask.java\n+++ /dev/null\n\n@@ -1,264 +0,0 @@\n-package alluxio.cli.validation;\n-\n-import alluxio.cli.ValidateUtils;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.PropertyKey;\n-import alluxio.security.authentication.ImpersonationAuthenticator;\n-import alluxio.util.network.NetworkAddressUtils;\n-\n-import com.google.common.collect.Sets;\n-\n-import java.util.Arrays;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-/**\n- * Validates the impersonation configurations in alluxio and hdfs.\n- * */\n-@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n-public class HdfsImpersonationValidationTask extends HdfsConfValidationTask {\n-  private final Map<String, Set<String>> mImpersonationUsers;\n-  private final Map<String, Set<String>> mImpersonationGroups;\n-  private final Mode mMode;\n-\n-  /**\n-   * Creates a new instance of {@link HdfsImpersonationValidationTask}\n-   * for validating impersonation configuration.\n-   *\n-   * @param path the UFS path\n-   * @param conf the UFS configuration\n-   * @param mode the mode for validation\n-   */\n-  public HdfsImpersonationValidationTask(String path, AlluxioConfiguration conf, Mode mode) {\n-    super(path, conf);\n-    mMode = mode;\n-    ImpersonationAuthenticator ia = new ImpersonationAuthenticator(mConf);\n-    mImpersonationUsers = ia.getImpersonationUsers();\n-    mImpersonationGroups = ia.getmImpersonationGroups();\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return String.format(\"ValidateImpersonationConf%s\", mMode);\n-  }\n-\n-  private boolean shouldSkip() {\n-    // If no impersonation setting in Alluxio, skip the check\n-    if (mImpersonationUsers.entrySet().size() == 0\n-            && mImpersonationGroups.size() == 0) {\n-      mMsg.append(\"No impersonation setting found in Alluxio. \"\n-              + \"Skip the impersonation validation step.\\n\");\n-      return true;\n-    }\n-    return false;\n-  }\n-\n-  private ValidateUtils.TaskResult validateImpersonationUsers() {\n-    String taskName = \"Validate alluxio impersonation users\";\n-    ValidateUtils.State state = ValidateUtils.State.OK;\n-    StringBuilder msg = new StringBuilder();\n-    StringBuilder advice = new StringBuilder();\n-    for (Map.Entry<String, Set<String>> entry : mImpersonationUsers.entrySet()) {\n-      String userName = entry.getKey();\n-      Set<String> impUsers = entry.getValue();\n-      PropertyKey alluxioKey =\n-              PropertyKey.Template.MASTER_IMPERSONATION_USERS_OPTION.format(userName);\n-      String hdfsKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n-      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. %n\",\n-              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n-\n-      // The impersonation user is not configured in core-site.xml\n-      if (!mCoreConf.containsKey(hdfsKey)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"But %s is not configured in hadoop proxyuser.%n\",\n-                hdfsKey));\n-        advice.append(String.format(\"Please configure %s to match %s.%n\",\n-                hdfsKey, alluxioKey.toString()));\n-        continue;\n-      }\n-      String hdfsImpUsers = mCoreConf.get(hdfsKey);\n-\n-      // Consider wildcard separately\n-      if (impUsers.contains(ImpersonationAuthenticator.WILDCARD)) {\n-        if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n-          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n-          msg.append(String.format(\"User %s can impersonate any user in Alluxio and HDFS.%n\",\n-                  userName));\n-        } else {\n-          state = ValidateUtils.State.FAILED;\n-          msg.append(String.format(\"User %s can impersonate any user in \"\n-                  + \"Alluxio but only %s in HDFS.%n\", userName, hdfsImpUsers));\n-          advice.append(String.format(\"Please set %s to %s. \",\n-                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n-        }\n-        continue;\n-      } else if (hdfsImpUsers.equals(ImpersonationAuthenticator.WILDCARD)) {\n-        msg.append(String.format(\"User %s can impersonate any user in HDFS.%n\", userName));\n-        continue;\n-      }\n-\n-      // Not using wildcard, compare the exact usernames\n-      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpUsers.split(\",\")));\n-      System.out.format(\"Impersonable users: %s%n\", nameSet);\n-      // The proxyuser can be enabled to impersonate more users than defined in Alluxio\n-      Set<String> missedUsers = Sets.difference(impUsers, nameSet); // in alluxio not in hdfs\n-      System.out.format(\"Found missed users %s%n\", missedUsers);\n-      if (missedUsers.size() > 0) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"User %s can impersonate as users %s in Alluxio but \"\n-                + \"not in HDFS.%n\", userName, missedUsers));\n-        advice.append(String.format(\"Please add the missing users to %s. \", hdfsKey));\n-        continue;\n-      }\n-\n-      // All checks passed\n-      msg.append(\"All impersonable users in Alluxio are found in HDFS. \\n\");\n-    }\n-\n-    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n-  }\n-\n-  // TODO(jiacheng): refactor with users logic\n-  private ValidateUtils.TaskResult validateImpersonationGroups() {\n-    String taskName = \"Validate alluxio impersonation groups\";\n-    ValidateUtils.State state = ValidateUtils.State.OK;\n-    StringBuilder msg = new StringBuilder();\n-    StringBuilder advice = new StringBuilder();\n-    for (Map.Entry<String, Set<String>> entry : mImpersonationGroups.entrySet()) {\n-      String userName = entry.getKey();\n-      Set<String> impGroups = entry.getValue();\n-      PropertyKey alluxioKey = PropertyKey.Template\n-              .MASTER_IMPERSONATION_GROUPS_OPTION.format(userName);\n-      String hdfsKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n-      msg.append(String.format(\"User %s has impersonation configured in Alluxio property %s=%s. \",\n-              userName, alluxioKey.toString(), mConf.get(alluxioKey)));\n-\n-      // The impersonation group is not configured in core-site.xml\n-      if (!mCoreConf.containsKey(hdfsKey)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"But %s is not configured in hadoop proxyuser. \", hdfsKey));\n-        advice.append(String.format(\"Please configure %s to match %s\",\n-                hdfsKey, alluxioKey.toString()));\n-        continue;\n-      }\n-      String hdfsImpGroups = mCoreConf.get(hdfsKey);\n-\n-      // Consider wildcard separately\n-      if (impGroups.contains(ImpersonationAuthenticator.WILDCARD)) {\n-        if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n-          // If impersonation is enabled for all users in Alluxio and HDFS, succeed\n-          msg.append(String.format(\"User %s can impersonate any group in \"\n-                  + \"Alluxio and HDFS. \", userName));\n-        } else {\n-          msg.append(String.format(\"User %s can impersonate any group \"\n-                  + \"in Alluxio but not in HDFS. \", userName));\n-          advice.append(String.format(\"Please set %s to %s. \",\n-                  hdfsKey, ImpersonationAuthenticator.WILDCARD));\n-        }\n-        continue;\n-      } else if (hdfsImpGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n-        msg.append(String.format(\"User %s can impersonate any group in HDFS.%n\", userName));\n-        continue;\n-      }\n-\n-      // The impersonation group has different configuration in core-site.xml\n-      Set<String> nameSet = new HashSet<>(Arrays.asList(hdfsImpGroups.split(\",\")));\n-      System.out.format(\"Impersonable groups: %s%n\", nameSet);\n-      // The proxyuser can be enabled to impersonate more groups than defined in Alluxio\n-      Set<String> missedGroups = Sets.difference(impGroups, nameSet); // in alluxio not in hdfs\n-      System.out.format(\"Found missed groups %s%n\", missedGroups);\n-      if (missedGroups.size() > 0) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"User %s can impersonate as groups %s \"\n-                + \"in Alluxio but not in HDFS.\", userName, missedGroups));\n-        advice.append(String.format(\"Please add the missing groups to %s. \", hdfsKey));\n-        continue;\n-      }\n-\n-      // All checks passed\n-      msg.append(String.format(\"Found matching configuration in %s and %s. \",\n-              alluxioKey.toString(), hdfsKey));\n-    }\n-    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n-  }\n-\n-  // At least the current host should be in hadoop.proxy.<username>.hosts\n-  private ValidateUtils.TaskResult validateImpersonationHosts() {\n-    String taskName = \"Validate proxyuser hosts\";\n-    ValidateUtils.State state = ValidateUtils.State.OK;\n-    StringBuilder msg = new StringBuilder();\n-    StringBuilder advice = new StringBuilder();\n-\n-    // current host\n-    String localhost = NetworkAddressUtils.getLocalHostName(1000);\n-\n-    // All the possible users Alluxio needs\n-    Set<String> allUsers = Sets.union(mImpersonationUsers.keySet(), mImpersonationGroups.keySet());\n-    for (String userName : allUsers) {\n-      msg.append(String.format(\"User %s is configured to allow impersonation is Alluxio. \",\n-              userName));\n-\n-      String hdfsKey = String.format(\"hadoop.proxyuser.%s.hosts\", userName);\n-      if (!mCoreConf.containsKey(hdfsKey)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(\"But the user is not allowed to use impersonation on this host.\");\n-        advice.append(String.format(\"Please configure %s to contain %s. \", hdfsKey, localhost));\n-        continue;\n-      }\n-\n-      String proxyHosts = mCoreConf.get(hdfsKey);\n-      // Consider wildcard separately\n-      if (proxyHosts.equals(ImpersonationAuthenticator.WILDCARD)) {\n-        msg.append(String.format(\"The user is enabled for impersonation from all hosts. \"));\n-        continue;\n-      }\n-      // If wildcard is not used and the localhost is not in the permitted list\n-      if (!proxyHosts.contains(localhost)) {\n-        state = ValidateUtils.State.FAILED;\n-        msg.append(String.format(\"But %s does not contain host %s. \", hdfsKey, localhost));\n-        advice.append(String.format(\"Please enable host %s in %s. \", localhost, hdfsKey));\n-        continue;\n-      }\n-\n-      // Passed all checks\n-      msg.append(String.format(\"Host %s is enabled to use impersonation in HDFS. \", localhost));\n-    }\n-    return new ValidateUtils.TaskResult(state, taskName, msg.toString(), advice.toString());\n-  }\n-\n-  @Override\n-  public ValidateUtils.TaskResult validate(Map<String, String> optionMap) {\n-    if (shouldSkip()) {\n-      return new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED, getName(),\n-              mMsg.toString(), mAdvice.toString());\n-    }\n-\n-    ValidateUtils.TaskResult loadConfig = loadHdfsConfig();\n-    if (loadConfig.getState() != ValidateUtils.State.OK) {\n-      return loadConfig;\n-    }\n-\n-    // TODO(jiacheng): do we want to check the current user even if\n-    //  there's no impersonation setting?\n-    switch (mMode) {\n-      case USERS:\n-        return validateImpersonationUsers();\n-      case GROUPS:\n-        return validateImpersonationGroups();\n-      case HOSTS:\n-        return validateImpersonationHosts();\n-      default:\n-        throw new RuntimeException(String.format(\"Unknown validation mode %s\", mMode));\n-    }\n-  }\n-\n-  /**\n-   * The mode for impersonation check.\n-   * */\n-  public enum Mode {\n-    USERS,\n-    GROUPS,\n-    HOSTS\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY4OTc2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436689763", "bodyText": "Need to double check if the same format holds true in CDH.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:16:21Z", "path": "shell/src/main/java/alluxio/cli/validation/HdfsVersionValidationTask.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.util.ShellUtils;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Validates if the HDFS version works with the UFS version specified in\n+ * alluxio configuration.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsVersionValidationTask extends AbstractValidationTask {\n+  private final AlluxioConfiguration mConf;\n+\n+  /**\n+   * Creates a new instance of {@link HdfsVersionValidationTask}\n+   * for validating HDFS version.\n+   * @param conf configuration\n+   */\n+  public HdfsVersionValidationTask(AlluxioConfiguration conf) {\n+    mConf = conf;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return \"ValidateHdfsVersion\";\n+  }\n+\n+  protected String parseVersion(String output) {\n+    // An example output from \"hadoop version\" command:\n+    //    Hadoop 2.7.2", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/HdfsVersionValidationTask.java b/shell/src/main/java/alluxio/cli/validation/HdfsVersionValidationTask.java\nindex 08ea87ddb9..b00765e3a1 100644\n--- a/shell/src/main/java/alluxio/cli/validation/HdfsVersionValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/HdfsVersionValidationTask.java\n\n@@ -54,7 +54,6 @@ public class HdfsVersionValidationTask extends AbstractValidationTask {\n   @Override\n   public ValidateUtils.TaskResult validate(Map<String, String> optionMap)\n           throws InterruptedException {\n-    // get hadoop version\n     String hadoopVersion;\n     try {\n       hadoopVersion = getHadoopVersion();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MTMzMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436691331", "bodyText": "Hadoop native lib may be defined here.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:18:04Z", "path": "shell/src/main/java/alluxio/cli/validation/NativeLibValidationTask.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package alluxio.cli.validation;\n+\n+import alluxio.cli.ValidateUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+\n+import java.io.File;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+/**\n+ * Validates the Java native libs defined in the system property.", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MjAzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436692036", "bodyText": "But then the drawback is for the default value for your JVM, there's a good chance you don't have them all in your env and you always see this warning.......", "author": "jiacheliu3", "createdAt": "2020-06-08T13:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MTMzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/NativeLibValidationTask.java b/shell/src/main/java/alluxio/cli/validation/NativeLibValidationTask.java\nindex a0c7b13da9..b8824e4922 100644\n--- a/shell/src/main/java/alluxio/cli/validation/NativeLibValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/NativeLibValidationTask.java\n\n@@ -1,6 +1,6 @@\n package alluxio.cli.validation;\n \n-import alluxio.cli.ValidateUtils;\n+import alluxio.cli.ValidationUtils;\n import alluxio.conf.AlluxioConfiguration;\n \n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5MjkyOA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436692928", "bodyText": "Partially updated classes like this are from validateEnv. They are not all run in this validateHdfsMount tool.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:19:48Z", "path": "shell/src/main/java/alluxio/cli/validation/SecureHdfsValidationTask.java", "diffHunk": "@@ -27,7 +27,8 @@\n /**\n  * Task for validating security configurations.\n  */\n-public final class SecureHdfsValidationTask extends HdfsValidationTask {\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public final class SecureHdfsValidationTask extends AbstractValidationTask {", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY5NjYwNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r436696604", "bodyText": "Now if the namenode / nameservice is not accessible there will be an exception here. I'm trying to add another test using hadoopClient.isHealthy() in hadoop client, which should be more verbose and specific.", "author": "jiacheliu3", "createdAt": "2020-06-08T13:23:43Z", "path": "shell/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java", "diffHunk": "@@ -30,27 +31,41 @@\n    * Creates a new instance of {@link UfsDirectoryValidationTask}\n    * for validating root under file system.\n    *\n-   * @param conf configuration\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n    */\n-  public UfsDirectoryValidationTask(AlluxioConfiguration conf) {\n-    mUfs = UnderFileSystem.Factory.createForRoot(conf);\n-    mPath = conf.get(PropertyKey.MASTER_MOUNT_TABLE_ROOT_UFS);\n+  public UfsDirectoryValidationTask(String path, AlluxioConfiguration conf) {\n+    mPath = path;\n+    mUfs = UnderFileSystem.Factory.create(mPath, conf);\n   }\n \n   @Override\n-  public TaskResult validate(Map<String, String> optionsMap) {\n+  public String getName() {\n+    return \"ValidateUfsDir\";\n+  }\n+\n+  @Override\n+  public ValidateUtils.TaskResult validate(Map<String, String> optionsMap) {\n+    StringBuilder msg = new StringBuilder();\n+    StringBuilder advice = new StringBuilder();\n     try {\n       UfsStatus[] listStatus = mUfs.listStatus(mPath);\n       if (listStatus == null) {\n-        System.err.format(\"Unable to list under file system path %s.%n\", mPath);\n-        return TaskResult.FAILED;\n+        msg.append(String.format(\"Unable to list under file system path %s. \", mPath));", "originalCommit": "142db925bc9d2ec39fc536ef2f0172a78127b836", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java b/shell/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java\nindex 9fead14b69..8a25d83431 100644\n--- a/shell/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/UfsDirectoryValidationTask.java\n\n@@ -45,7 +44,7 @@ public final class UfsDirectoryValidationTask extends AbstractValidationTask {\n   }\n \n   @Override\n-  public ValidateUtils.TaskResult validate(Map<String, String> optionsMap) {\n+  public ValidationUtils.TaskResult validate(Map<String, String> optionsMap) {\n     StringBuilder msg = new StringBuilder();\n     StringBuilder advice = new StringBuilder();\n     try {\n"}}, {"oid": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "url": "https://github.com/Alluxio/alluxio/commit/3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "message": "improvements", "committedDate": "2020-06-08T13:26:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mjk2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437052967", "bodyText": "what does errStream use for ?", "author": "LuQQiu", "createdAt": "2020-06-08T23:20:06Z", "path": "shell/src/main/java/alluxio/cli/RunTestUtils.java", "diffHunk": "@@ -27,18 +28,29 @@\n   private RunTestUtils() {} // prevent instantiation\n \n   /**\n-   * Prints information of the test result.\n+   * Prints information of the test result to redirected streams.\n    *\n    * @param pass the test result\n+   * @param outStream stream for stdout\n+   * @param errStream stream for stderr\n    */\n-  public static void printPassInfo(boolean pass) {\n+  public static void printPassInfo(boolean pass, PrintStream outStream, PrintStream errStream) {", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MzU1NA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438263554", "bodyText": "Nothing, for now. I think it's better to hijack stdout and stderr together?", "author": "jiacheliu3", "createdAt": "2020-06-10T16:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mjk2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "99680346c71c20366e5a2065290e915e0e15ea84", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/RunTestUtils.java b/shell/src/main/java/alluxio/cli/RunTestUtils.java\nindex dee5e205d8..076b7187a5 100644\n--- a/shell/src/main/java/alluxio/cli/RunTestUtils.java\n+++ b/shell/src/main/java/alluxio/cli/RunTestUtils.java\n\n@@ -34,7 +34,7 @@ public final class RunTestUtils {\n    * @param outStream stream for stdout\n    * @param errStream stream for stderr\n    */\n-  public static void printPassInfo(boolean pass, PrintStream outStream, PrintStream errStream) {\n+  public static void printTestStatus(boolean pass, PrintStream outStream, PrintStream errStream) {\n     if (pass) {\n       outStream.println(Constants.ANSI_GREEN + \"Passed the test!\" + Constants.ANSI_RESET);\n     } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437053167", "bodyText": "this function only prints the succeed (== pass) information?", "author": "LuQQiu", "createdAt": "2020-06-08T23:20:39Z", "path": "shell/src/main/java/alluxio/cli/RunTestUtils.java", "diffHunk": "@@ -27,18 +28,29 @@\n   private RunTestUtils() {} // prevent instantiation\n \n   /**\n-   * Prints information of the test result.\n+   * Prints information of the test result to redirected streams.\n    *\n    * @param pass the test result\n+   * @param outStream stream for stdout\n+   * @param errStream stream for stderr\n    */\n-  public static void printPassInfo(boolean pass) {\n+  public static void printPassInfo(boolean pass, PrintStream outStream, PrintStream errStream) {\n     if (pass) {\n-      System.out.println(Constants.ANSI_GREEN + \"Passed the test!\" + Constants.ANSI_RESET);\n+      outStream.println(Constants.ANSI_GREEN + \"Passed the test!\" + Constants.ANSI_RESET);\n     } else {\n-      System.out.println(Constants.ANSI_RED + \"Failed the test!\" + Constants.ANSI_RESET);\n+      outStream.println(Constants.ANSI_RED + \"Failed the test!\" + Constants.ANSI_RESET);\n     }\n   }\n \n+  /**\n+   * Prints information of the test result.\n+   *\n+   * @param pass the test result\n+   */\n+  public static void printPassInfo(boolean pass) {", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2NTE5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438265190", "bodyText": "You mean the name is not very helpful? How about printTestStatus?", "author": "jiacheliu3", "createdAt": "2020-06-10T16:42:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "99680346c71c20366e5a2065290e915e0e15ea84", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/RunTestUtils.java b/shell/src/main/java/alluxio/cli/RunTestUtils.java\nindex dee5e205d8..076b7187a5 100644\n--- a/shell/src/main/java/alluxio/cli/RunTestUtils.java\n+++ b/shell/src/main/java/alluxio/cli/RunTestUtils.java\n\n@@ -34,7 +34,7 @@ public final class RunTestUtils {\n    * @param outStream stream for stdout\n    * @param errStream stream for stderr\n    */\n-  public static void printPassInfo(boolean pass, PrintStream outStream, PrintStream errStream) {\n+  public static void printTestStatus(boolean pass, PrintStream outStream, PrintStream errStream) {\n     if (pass) {\n       outStream.println(Constants.ANSI_GREEN + \"Passed the test!\" + Constants.ANSI_RESET);\n     } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1OTUzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437059539", "bodyText": "license header", "author": "LuQQiu", "createdAt": "2020-06-08T23:42:34Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package alluxio.cli;", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "99680346c71c20366e5a2065290e915e0e15ea84", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\nindex ad8594c314..512ffe2e5f 100644\n--- a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n+++ b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n\n@@ -1,3 +1,14 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.cli;\n \n import alluxio.cli.validation.ApplicableUfsType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1OTY5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437059694", "bodyText": "The path", "author": "LuQQiu", "createdAt": "2020-06-08T23:43:02Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package alluxio.cli;\n+\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.Source;\n+import alluxio.shell.CommandReturn;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.ShellUtils;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A tool to validate an HDFS mount, before the paths is mounted to Alluxio.", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "99680346c71c20366e5a2065290e915e0e15ea84", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\nindex ad8594c314..512ffe2e5f 100644\n--- a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n+++ b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n\n@@ -1,3 +1,14 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.cli;\n \n import alluxio.cli.validation.ApplicableUfsType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437068090", "bodyText": "@madanadit Is the ValidateHdfs required to run on all nodes? @jiacheliu3 I saw the local option and validate hdfs will run by default on local and remote nodes. The problem is this requires SSH and file permissions which is hard to fulfill in real env. I would suggest either remove the remote check (or at least make it optional) or expose validateHdfs rpcs in master/worker. Then we can ask for the server check through rpc channel.", "author": "LuQQiu", "createdAt": "2020-06-09T00:14:06Z", "path": "shell/src/main/java/alluxio/cli/ValidateHdfsMount.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package alluxio.cli;\n+\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.Source;\n+import alluxio.shell.CommandReturn;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.ShellUtils;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import org.apache.commons.cli.CommandLine;\n+import org.apache.commons.cli.CommandLineParser;\n+import org.apache.commons.cli.DefaultParser;\n+import org.apache.commons.cli.Option;\n+import org.apache.commons.cli.Options;\n+import org.apache.commons.cli.ParseException;\n+import org.apache.commons.lang.ArrayUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n+/**\n+ * A tool to validate an HDFS mount, before the paths is mounted to Alluxio.\n+ * */\n+public class ValidateHdfsMount {\n+  private static final Logger LOG = LoggerFactory.getLogger(ValidateHdfsMount.class);\n+  private static final String JSON_START_POS_MARKER = \"ValidateHdfsMount task results: \\n\";\n+\n+  private static final Option READONLY_OPTION =\n+          Option.builder()\n+                  .longOpt(\"readonly\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is readonly in Alluxio\")\n+                  .build();\n+  private static final Option SHARED_OPTION =\n+          Option.builder()\n+                  .longOpt(\"shared\")\n+                  .required(false)\n+                  .hasArg(false)\n+                  .desc(\"mount point is shared\")\n+                  .build();\n+  private static final Option OPTION_OPTION =\n+          Option.builder()\n+                  .longOpt(\"option\")\n+                  .required(false)\n+                  .hasArg(true)\n+                  .numberOfArgs(2)\n+                  .argName(\"key=value\")\n+                  .valueSeparator('=')\n+                  .desc(\"options associated with this mount point\")\n+                  .build();\n+  private static final Option LOCAL_OPTION =\n+          Option.builder().required(false).longOpt(\"local\").hasArg(false)\n+                  .desc(\"running only on localhost\").build();\n+  private static final Options OPTIONS =\n+          new Options().addOption(READONLY_OPTION).addOption(SHARED_OPTION)\n+                  .addOption(OPTION_OPTION).addOption(LOCAL_OPTION);\n+\n+  /**\n+   * Invokes {@link UnderFileSystemContractTest} to validate UFS operations.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS conf\n+   * @return a {@link alluxio.cli.ValidateUtils.TaskResult} containing the validation result\n+   *        of the UFS operations\n+   * */\n+  public static ValidateUtils.TaskResult runUfsTests(String path, InstancedConfiguration conf) {\n+    try {\n+      UnderFileSystemContractTest test = new UnderFileSystemContractTest(path, conf);\n+      return test.runValidationTask();\n+    } catch (IOException e) {\n+      return new ValidateUtils.TaskResult(ValidateUtils.State.FAILED, \"ufsTests\",\n+              ValidateUtils.getErrorInfo(e), \"\");\n+    }\n+  }\n+\n+  /**\n+   * The entrance.\n+   *\n+   * @param args command line arguments\n+   * */\n+  public static void main(String[] args) throws Exception {\n+    // TODO(jiacheng): use jccommand?\n+    CommandLineParser parser = new DefaultParser();\n+    CommandLine cmd = null;\n+    try {\n+      cmd = parser.parse(OPTIONS, args, true /* stopAtNonOption */);\n+    } catch (ParseException e) {\n+      System.exit(1);\n+    }\n+    args = cmd.getArgs();\n+    String ufsPath = args[0];\n+\n+    InstancedConfiguration conf = InstancedConfiguration.defaults();\n+    if (cmd.hasOption(LOCAL_OPTION.getLongOpt())) {\n+      // Merge options from the command line option\n+      UnderFileSystemConfiguration ufsConf = UnderFileSystemConfiguration.defaults(conf);\n+      if (cmd.hasOption(READONLY_OPTION.getLongOpt())) {\n+        ufsConf.setReadOnly(true);\n+      }\n+      if (cmd.hasOption(SHARED_OPTION.getLongOpt())) {\n+        ufsConf.setShared(true);\n+      }\n+      if (cmd.hasOption(OPTION_OPTION.getLongOpt())) {\n+        Properties properties = cmd.getOptionProperties(OPTION_OPTION.getLongOpt());\n+        ufsConf.merge(properties, Source.MOUNT_OPTION);\n+        LOG.debug(\"Options from cmdline: {}\", properties);\n+      }\n+\n+      // Run validateEnv\n+      Map<String, String> validateOpts = ImmutableMap.of();\n+      ValidateEnv validate = new ValidateEnv(ufsPath, ufsConf);\n+      List<ValidateUtils.TaskResult> results = validate.validateUfs(\n+              ApplicableUfsType.Type.HDFS, validateOpts);\n+\n+      // Run runUfsTests\n+      if (ufsConf.isReadOnly()) {\n+        LOG.debug(\"Ufs operations are skipped because the path is readonly.\");\n+        results.add(new ValidateUtils.TaskResult(ValidateUtils.State.SKIPPED,\n+                UnderFileSystemContractTest.TASK_NAME,\n+                String.format(\"UFS path %s is readonly, skipped UFS operation tests.\", ufsPath),\n+                \"\"));\n+      } else {\n+        results.add(runUfsTests(ufsPath, new InstancedConfiguration(ufsConf)));\n+      }\n+\n+      // Serialize the results back to the calling node\n+      printResults(results);\n+\n+      System.exit(0);\n+    }\n+\n+    // Cluster mode\n+    LOG.info(\"Invoking the command remotely on the Alluxio cluster.\");\n+\n+    // how many nodes in the cluster\n+    Set<String> hosts = ConfigurationUtils.getServerHostnames(conf);\n+    ExecutorService executor = Executors.newFixedThreadPool(hosts.size());\n+\n+    // Invoke validateHdfsMount locally on each host\n+    Map<String, CompletableFuture<CommandReturn>> resultFuture = new HashMap<>();\n+    for (String host : hosts) {\n+      LOG.info(\"validate hdfs mount on host {}\", host);\n+\n+      // We make the assumption that the Alluxio WORK_DIR is the same\n+      String workDir = conf.get(PropertyKey.WORK_DIR);\n+      String alluxioBinPath = Paths.get(workDir, \"bin/alluxio\")", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDEzNA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437080134", "bodyText": "In this release (2.3) we target single node (local) validation with no ssh requirement. I agree, remove the remote check.", "author": "madanadit", "createdAt": "2020-06-09T01:01:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NTA5MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438245091", "bodyText": "Makes sense to me", "author": "jiacheliu3", "createdAt": "2020-06-10T16:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcyODk3Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438728972", "bodyText": "Removed remote check", "author": "jiacheliu3", "createdAt": "2020-06-11T11:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODA5MA=="}], "type": "inlineReview", "revised_code": {"commit": "99680346c71c20366e5a2065290e915e0e15ea84", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\nindex ad8594c314..512ffe2e5f 100644\n--- a/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n+++ b/shell/src/main/java/alluxio/cli/ValidateHdfsMount.java\n\n@@ -1,3 +1,14 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.cli;\n \n import alluxio.cli.validation.ApplicableUfsType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r437068639", "bodyText": "Why we choose to put the validateHdfs logic inside validateEnv?\npersonally i will prefer to have a separate class for the hdfs<>ValidationTask. and ValidateEnv can call the hdfs<>ValidationTasks if it's root ufs is hdfs. This is because many of the ValidateEnv tasks are not related to hdfs.", "author": "LuQQiu", "createdAt": "2020-06-09T00:16:11Z", "path": "shell/src/main/java/alluxio/cli/ValidateEnv.java", "diffHunk": "@@ -87,80 +93,108 @@\n   private static final List<ValidationTask> MASTER_TASKS = new ArrayList<>();\n   private static final List<ValidationTask> WORKER_TASKS = new ArrayList<>();\n \n-  private static final AlluxioConfiguration CONF;\n+  private final AlluxioConfiguration mConf;\n+  private final String mPath;\n \n-  static {\n-    CONF = InstancedConfiguration.defaults();\n+  /**\n+   * Initializes from the target UFS path and configurations.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configurtions\n+   * */\n+  public ValidateEnv(String path, AlluxioConfiguration conf) {", "originalCommit": "3b3f1f26f81c40a8da58a62e0e942c226c3047c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NDkyMg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438244922", "bodyText": "Good call. I'm thinking about that too. Will extract them into a better place and we can discuss.", "author": "jiacheliu3", "createdAt": "2020-06-10T16:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MzgzNg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438283836", "bodyText": "i had a similar question about the method runValidationTask defined in UfsContractTest instead of ValidateHdfsMount where it is actually used", "author": "madanadit", "createdAt": "2020-06-10T17:14:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyNzY4Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438827683", "bodyText": "Actually I tried to move that into ValidateHdfsMount but turned out to be very hard. It's hard because the UfsContractTest is not providing a \"functional\" interface where you just feed it parameters and get results. It has much internal logic and using its embedded fields. Another reason for adding a method to UfsContractTest is, actually most of its tests are run.\nLeft a TODO tho. I will have to refactor much of that class to achieve this.", "author": "jiacheliu3", "createdAt": "2020-06-11T14:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2ODYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "55b44bfc643ceb4b0dbac02bc4bd6d67b7808116", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/ValidateEnv.java b/shell/src/main/java/alluxio/cli/ValidateEnv.java\nindex 491ecaf0b7..1621dcff23 100644\n--- a/shell/src/main/java/alluxio/cli/ValidateEnv.java\n+++ b/shell/src/main/java/alluxio/cli/ValidateEnv.java\n\n@@ -167,9 +167,9 @@ public final class ValidateEnv {\n     registerTask(\"ufs.path.accessible\",\n         \"validate the under file system location is accessible\",\n         new UfsDirectoryValidationTask(mPath, mConf), COMMON_TASKS);\n-    registerTask(\"ufs.root.superuser\",\n-        \"validate Alluxio has super user privilege on root under file system\",\n-        new UfsSuperUserValidationTask(mConf), COMMON_TASKS);\n+    registerTask(\"ufs.path.superuser\",\n+        \"validate Alluxio has super user privilege on the under file system\",\n+        new UfsSuperUserValidationTask(mPath, mConf), COMMON_TASKS);\n \n     // RAM disk validations\n     registerTask(\"worker.ramdisk.mount.privilege\",\n"}}, {"oid": "cf3fc88f206e946eea54a89741a459b9402f3647", "url": "https://github.com/Alluxio/alluxio/commit/cf3fc88f206e946eea54a89741a459b9402f3647", "message": "update pom", "committedDate": "2020-06-10T16:35:22Z", "type": "commit"}, {"oid": "99680346c71c20366e5a2065290e915e0e15ea84", "url": "https://github.com/Alluxio/alluxio/commit/99680346c71c20366e5a2065290e915e0e15ea84", "message": "resolve some comments", "committedDate": "2020-06-10T16:51:55Z", "type": "commit"}, {"oid": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "url": "https://github.com/Alluxio/alluxio/commit/09347fc6566bc4e860da132e206cd9d4d895e0cf", "message": "remove cluster mode", "committedDate": "2020-06-10T17:00:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MTkxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438281919", "bodyText": "why do you need to set these properties?", "author": "madanadit", "createdAt": "2020-06-10T17:10:57Z", "path": "shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java", "diffHunk": "@@ -84,6 +109,63 @@ private void run() throws Exception {\n     System.out.printf(\"Tests completed with %d failed.%n\", failedCnt);\n   }\n \n+  /**\n+   * Runs the tests and return a {@link alluxio.cli.ValidateUtils.TaskResult}.\n+   *\n+   * @return a task result for all UFS tests\n+   * */\n+  public ValidateUtils.TaskResult runValidationTask() throws IOException {\n+    Closer closer = Closer.create();\n+    final ByteArrayOutputStream msgBuf = new ByteArrayOutputStream();\n+    final ByteArrayOutputStream adviceBuf = new ByteArrayOutputStream();\n+    PrintStream msgStream = new PrintStream(msgBuf, true);\n+    PrintStream adviceStream = new PrintStream(adviceBuf, true);\n+    closer.register(msgStream);\n+    closer.register(adviceStream);\n+    closer.register(msgBuf);\n+    closer.register(adviceBuf);\n+    try {\n+      UnderFileSystemConfiguration ufsConf = getUfsConf();\n+      UnderFileSystemFactory factory = UnderFileSystemFactoryRegistry.find(mUfsPath, ufsConf);\n+      // Check if the ufs path is valid\n+      if (factory == null || !factory.supportsPath(mUfsPath)) {\n+        msgStream.append(String.format(\"%s is not a valid path%n\", mUfsPath));\n+        adviceStream.append(String.format(\"Please validate if %s is a correct path\\n\", mUfsPath));\n+        return new ValidateUtils.TaskResult(ValidateUtils.State.FAILED, TASK_NAME,\n+                msgBuf.toString(), adviceBuf.toString());\n+      }\n+\n+      // Set common properties\n+      mConf.set(PropertyKey.UNDERFS_LISTING_LENGTH, \"50\");", "originalCommit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MjY2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438292662", "bodyText": "This actually is inherited from the existing UFSContractTest#run. @LuQQiu Do you think I should keep these properties for the test?", "author": "jiacheliu3", "createdAt": "2020-06-10T17:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MTkxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA4MjgyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r439082825", "bodyText": "Those properties are inherited from original UfsContrctTests and are added to for testing purposes. Like listing less files , using small blocks and speed up tests. I think it will be better to keep these properties", "author": "LuQQiu", "createdAt": "2020-06-11T21:34:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4MTkxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java b/shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java\nindex b587652306..8771a8a091 100644\n--- a/shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java\n+++ b/shell/src/main/java/alluxio/cli/UnderFileSystemContractTest.java\n\n@@ -110,11 +110,11 @@ public final class UnderFileSystemContractTest {\n   }\n \n   /**\n-   * Runs the tests and return a {@link alluxio.cli.ValidateUtils.TaskResult}.\n+   * Runs the tests and return a {@link alluxio.cli.ValidationUtils.TaskResult}.\n    *\n    * @return a task result for all UFS tests\n    * */\n-  public ValidateUtils.TaskResult runValidationTask() throws IOException {\n+  public ValidationUtils.TaskResult runValidationTask() throws IOException {\n     Closer closer = Closer.create();\n     final ByteArrayOutputStream msgBuf = new ByteArrayOutputStream();\n     final ByteArrayOutputStream adviceBuf = new ByteArrayOutputStream();\n"}}, {"oid": "4738033507dee7df99436a0921b27e321116c937", "url": "https://github.com/Alluxio/alluxio/commit/4738033507dee7df99436a0921b27e321116c937", "message": "add cmdline", "committedDate": "2020-06-10T17:15:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NTE2OA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438285168", "bodyText": "is this better suited part of the interface definition?", "author": "madanadit", "createdAt": "2020-06-10T17:16:36Z", "path": "shell/src/main/java/alluxio/cli/validation/AbstractValidationTask.java", "diffHunk": "@@ -20,6 +20,13 @@\n  * Abstract class for validation environment.\n  */\n public abstract class AbstractValidationTask implements ValidationTask {\n+  /**\n+   * Gets the name of the task.\n+   *\n+   * @return the task name\n+   * */\n+  public abstract String getName();", "originalCommit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d726454116a9919602e40b6bff0f60e36df25aae", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/AbstractValidationTask.java b/shell/src/main/java/alluxio/cli/validation/AbstractValidationTask.java\nindex 6db492ffb0..334e60d38b 100644\n--- a/shell/src/main/java/alluxio/cli/validation/AbstractValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/AbstractValidationTask.java\n\n@@ -20,13 +20,6 @@ import java.util.List;\n  * Abstract class for validation environment.\n  */\n public abstract class AbstractValidationTask implements ValidationTask {\n-  /**\n-   * Gets the name of the task.\n-   *\n-   * @return the task name\n-   * */\n-  public abstract String getName();\n-\n   @Override\n   public List<Option> getOptionList() {\n     return new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzA3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438287070", "bodyText": "we agreed to validate local conf only w/o ssh?", "author": "madanadit", "createdAt": "2020-06-10T17:19:53Z", "path": "shell/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java", "diffHunk": "@@ -122,37 +147,34 @@ public TaskResult validate(Map<String, String> optionMap) throws InterruptedExce\n         }\n         String remoteValue = allProperties.get(remoteNode).getProperty(propertyName);\n         if (!StringUtils.equals(remoteValue, baseValue)) {\n-          System.err.format(\"%s: Property \\\"%s\\\" is inconsistent between node %s and %s.%n\",\n-              errLabel, propertyName, baseNode, remoteNode);\n-          System.err.format(\" %s: %s%n %s: %s%n\", baseNode, Objects.toString(baseValue, \"not set\"),\n-              remoteNode,  Objects.toString(remoteValue, \"not set\"));\n+          msg.append(String.format(\"%s: Property \\\"%s\\\" is inconsistent between node %s and %s.%n\",\n+              errLabel, propertyName, baseNode, remoteNode));\n+          msg.append(String.format(\" %s: %s%n %s: %s%n\", baseNode,\n+                  Objects.toString(baseValue, \"not set\"),\n+              remoteNode,  Objects.toString(remoteValue, \"not set\")));\n+          advice.append(String.format(\"Please check your settings for property %s on %s and %s.%n\",\n+                  propertyName, baseNode, remoteNode));\n           isConsistent = false;\n         }\n       }\n       if (!isConsistent) {\n-        result = result == TaskResult.FAILED ? TaskResult.FAILED : errLevel;\n+        state = state == ValidateUtils.State.FAILED ? ValidateUtils.State.FAILED : errLevel;\n       }\n     }\n-    return result;\n+    return new ValidateUtils.TaskResult(state, getName(), msg.toString(), advice.toString());\n   }\n \n-  @Nullable\n-  private Properties getNodeConf(String node) {\n-    try {\n-      String homeDir = mConf.get(PropertyKey.HOME);\n-      String remoteCommand = String.format(\n-          \"%s/bin/alluxio getConf\", homeDir);\n-      String localCommand = String.format(\n-          \"ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no -tt %s \\\"bash %s\\\"\",\n-          node, remoteCommand);\n-      String[] command = {\"bash\", \"-c\", localCommand};\n-      Properties properties = new Properties();\n-      Process process = Runtime.getRuntime().exec(command);\n-      properties.load(process.getInputStream());\n-      return properties;\n-    } catch (IOException e) {\n-      System.err.format(\"Unable to retrieve configuration for %s: %s.\", node, e.getMessage());\n-      return null;\n-    }\n+  private Properties getNodeConf(String node) throws IOException {\n+    String homeDir = mConf.get(PropertyKey.HOME);\n+    String remoteCommand = String.format(\n+        \"%s/bin/alluxio getConf\", homeDir);\n+    String localCommand = String.format(", "originalCommit": "09347fc6566bc4e860da132e206cd9d4d895e0cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI5MTY2MA==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438291660", "bodyText": "Yes remote has just been removed", "author": "jiacheliu3", "createdAt": "2020-06-10T17:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NzA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java b/shell/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java\nindex 670f4d4027..949370380b 100644\n--- a/shell/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/ClusterConfConsistencyValidationTask.java\n\n@@ -158,10 +158,10 @@ public final class ClusterConfConsistencyValidationTask extends AbstractValidati\n         }\n       }\n       if (!isConsistent) {\n-        state = state == ValidateUtils.State.FAILED ? ValidateUtils.State.FAILED : errLevel;\n+        state = state == ValidationUtils.State.FAILED ? ValidationUtils.State.FAILED : errLevel;\n       }\n     }\n-    return new ValidateUtils.TaskResult(state, getName(), msg.toString(), advice.toString());\n+    return new ValidationUtils.TaskResult(state, getName(), msg.toString(), advice.toString());\n   }\n \n   private Properties getNodeConf(String node) throws IOException {\n"}}, {"oid": "f2d5fc1a2c2c06679df5e1da5c7d99971faf58f4", "url": "https://github.com/Alluxio/alluxio/commit/f2d5fc1a2c2c06679df5e1da5c7d99971faf58f4", "message": "group results in the end", "committedDate": "2020-06-10T17:33:48Z", "type": "commit"}, {"oid": "55b44bfc643ceb4b0dbac02bc4bd6d67b7808116", "url": "https://github.com/Alluxio/alluxio/commit/55b44bfc643ceb4b0dbac02bc4bd6d67b7808116", "message": "correct super user check", "committedDate": "2020-06-10T18:01:19Z", "type": "commit"}, {"oid": "94e6c76210f158292c8e7e6d293422fead2fb400", "url": "https://github.com/Alluxio/alluxio/commit/94e6c76210f158292c8e7e6d293422fead2fb400", "message": "move hdfs validation tasks and rewrite impersonation check logic", "committedDate": "2020-06-11T11:42:54Z", "type": "commit"}, {"oid": "6cc3601cdb607fc574c650a6caf4131e72e88ed1", "url": "https://github.com/Alluxio/alluxio/commit/6cc3601cdb607fc574c650a6caf4131e72e88ed1", "message": "merge updated master", "committedDate": "2020-06-11T11:50:51Z", "type": "commit"}, {"oid": "7b4a15412c8dd3ac4f21c801262473d63cf3218f", "url": "https://github.com/Alluxio/alluxio/commit/7b4a15412c8dd3ac4f21c801262473d63cf3218f", "message": "master is too fast i gotta catch up", "committedDate": "2020-06-11T12:15:05Z", "type": "commit"}, {"oid": "d726454116a9919602e40b6bff0f60e36df25aae", "url": "https://github.com/Alluxio/alluxio/commit/d726454116a9919602e40b6bff0f60e36df25aae", "message": "resolve comment", "committedDate": "2020-06-11T12:49:00Z", "type": "commit"}, {"oid": "4ad06f2a3bafa66919b0a18f2ed142c30e1e9337", "url": "https://github.com/Alluxio/alluxio/commit/4ad06f2a3bafa66919b0a18f2ed142c30e1e9337", "message": "resolve TODOs", "committedDate": "2020-06-11T13:17:00Z", "type": "commit"}, {"oid": "379f56fea0eae80186e74a782e7f40cd123dd20a", "url": "https://github.com/Alluxio/alluxio/commit/379f56fea0eae80186e74a782e7f40cd123dd20a", "message": "checkstyle", "committedDate": "2020-06-11T13:24:27Z", "type": "commit"}, {"oid": "508bdc5cd3f003bc56273d954f03bae43b0a0a26", "url": "https://github.com/Alluxio/alluxio/commit/508bdc5cd3f003bc56273d954f03bae43b0a0a26", "message": "resolve comments", "committedDate": "2020-06-11T14:29:05Z", "type": "commit"}, {"oid": "f0ac42fa46e20e8a955e169fbe6b33dc5bfe6933", "url": "https://github.com/Alluxio/alluxio/commit/f0ac42fa46e20e8a955e169fbe6b33dc5bfe6933", "message": "pom update and checkstyle", "committedDate": "2020-06-11T14:38:28Z", "type": "commit"}, {"oid": "4e7aa61de5cc376548823bd786450149c4fc8cd1", "url": "https://github.com/Alluxio/alluxio/commit/4e7aa61de5cc376548823bd786450149c4fc8cd1", "message": "pom update", "committedDate": "2020-06-11T14:40:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NTg0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/11480#discussion_r438845849", "bodyText": "@madanadit PTAL at the impersonation check now, updated per our discussion today. Now the logic goes as follows:\n// Skipped if authType is NOSASL\nvalidateProxyUsers(String alluxioUser) {\n// if neither hadoop.proxyuser.alluxioUser.users and hadoop.proxyuser.alluxioUser.groups are configured -> ERROR\n// If either is *, OK\n// Otherwise  -> WARN and let the user check. \n}\n\nWhat do you think about the final WARN scenario? Maybe hadoop.proxyuser.alluxioUser.users or hadoop.proxyuser.alluxioUser.groups has some config but we don't really know if that's what we want. I left a TODO in case we want to add a little more to this part.", "author": "jiacheliu3", "createdAt": "2020-06-11T14:53:28Z", "path": "shell/src/main/java/alluxio/cli/validation/hdfs/HdfsProxyUserValidationTask.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package alluxio.cli.validation.hdfs;\n+\n+import alluxio.cli.ValidationUtils;\n+import alluxio.cli.validation.ApplicableUfsType;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.status.UnauthenticatedException;\n+import alluxio.security.authentication.AuthType;\n+import alluxio.security.authentication.ImpersonationAuthenticator;\n+import alluxio.security.user.UserState;\n+\n+import java.util.Map;\n+\n+/**\n+ * Validates the proxyuser configurations for alluxio in hdfs.\n+ * */\n+@ApplicableUfsType(ApplicableUfsType.Type.HDFS)\n+public class HdfsProxyUserValidationTask extends HdfsConfValidationTask {\n+  /**\n+   * Creates a new instance of {@link HdfsProxyUserValidationTask}\n+   * for validating proxyuser configuration.\n+   *\n+   * @param path the UFS path\n+   * @param conf the UFS configuration\n+   */\n+  public HdfsProxyUserValidationTask(String path, AlluxioConfiguration conf) {\n+    super(path, conf);\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return \"ValidateProxyUserConf\";\n+  }\n+\n+  private String getCurrentUser() throws UnauthenticatedException {\n+    UserState s = UserState.Factory.create(mConf);\n+    return s.getUser().getName();\n+  }\n+\n+  private ValidationUtils.TaskResult validateProxyUsers(String userName) {\n+    String proxyUserKey = String.format(\"hadoop.proxyuser.%s.users\", userName);\n+    String proxyGroupKey = String.format(\"hadoop.proxyuser.%s.groups\", userName);\n+    String proxyUsers = mCoreConf.getOrDefault(proxyUserKey, \"\");\n+    String proxyGroups = mCoreConf.getOrDefault(proxyGroupKey, \"\");\n+\n+    // Neither proxy users or groups is configured in core-site.xml\n+    if (proxyUsers.equals(\"\") && proxyGroups.equals(\"\")) {\n+      mMsg.append(String.format(\"Alluxio is running as user %s. But neither %s or %s is \"\n+              + \"configured in hadoop configuration. Alluxio is not able to perform \"\n+              + \"impersonation.%n\", userName, proxyUserKey, proxyGroupKey));\n+      mAdvice.append(String.format(\"Please enable Alluxio user %s to impersonate.%n\", userName));\n+\n+      return new ValidationUtils.TaskResult(ValidationUtils.State.FAILED, getName(), mMsg.toString(),\n+              mAdvice.toString());\n+    }\n+\n+    // If proxy users/groups is *, alluxio can impersonate anyone\n+    if (proxyUsers.equals(ImpersonationAuthenticator.WILDCARD)\n+            || proxyGroups.equals(ImpersonationAuthenticator.WILDCARD)) {\n+      mMsg.append(String.format(\"Alluxio user %s can impersonate as any user/group in HDFS.%n\",\n+              userName));\n+      return new ValidationUtils.TaskResult(ValidationUtils.State.OK, getName(),\n+              mMsg.toString(), mAdvice.toString());\n+    }\n+\n+    // There are proxyable users and groups for the Alluxio user in HDFS,\n+    // but we cannot know if that is a full set.\n+    // Leave a warning for the user to double check.\n+    // TODO(jiacheng): can we do better check than this?", "originalCommit": "4e7aa61de5cc376548823bd786450149c4fc8cd1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d842b19e37c3fd60cea8504e72ea7958ea1f15b2", "chunk": "diff --git a/shell/src/main/java/alluxio/cli/validation/hdfs/HdfsProxyUserValidationTask.java b/shell/src/main/java/alluxio/cli/validation/hdfs/HdfsProxyUserValidationTask.java\nindex 55b8d21afb..0f1929a390 100644\n--- a/shell/src/main/java/alluxio/cli/validation/hdfs/HdfsProxyUserValidationTask.java\n+++ b/shell/src/main/java/alluxio/cli/validation/hdfs/HdfsProxyUserValidationTask.java\n\n@@ -1,3 +1,14 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n package alluxio.cli.validation.hdfs;\n \n import alluxio.cli.ValidationUtils;\n"}}, {"oid": "d842b19e37c3fd60cea8504e72ea7958ea1f15b2", "url": "https://github.com/Alluxio/alluxio/commit/d842b19e37c3fd60cea8504e72ea7958ea1f15b2", "message": "checkstyle", "committedDate": "2020-06-11T15:02:26Z", "type": "commit"}, {"oid": "c4b7f78c344d71cb1493617c67c6105f1279229b", "url": "https://github.com/Alluxio/alluxio/commit/c4b7f78c344d71cb1493617c67c6105f1279229b", "message": "spotbugs", "committedDate": "2020-06-11T15:34:54Z", "type": "commit"}, {"oid": "015c5b853daab3900487b6b116fb71ed987d7028", "url": "https://github.com/Alluxio/alluxio/commit/015c5b853daab3900487b6b116fb71ed987d7028", "message": "checkcheckstyle", "committedDate": "2020-06-12T01:05:07Z", "type": "commit"}]}