{"pr_number": 11400, "pr_title": "Improve HdfsPositionedReadUnderFileInputStream with a heuristic", "pr_createdAt": "2020-05-08T04:50:57Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/11400", "timeline": [{"oid": "145bcd1a847b78213bc8cb0bb04e1134f14479d9", "url": "https://github.com/Alluxio/alluxio/commit/145bcd1a847b78213bc8cb0bb04e1134f14479d9", "message": "fix NPE related to blocklocations", "committedDate": "2020-05-06T22:09:16Z", "type": "commit"}, {"oid": "c423fc54921ef5d40db511fa9660bcd1cb77f67f", "url": "https://github.com/Alluxio/alluxio/commit/c423fc54921ef5d40db511fa9660bcd1cb77f67f", "message": "add logging", "committedDate": "2020-05-07T01:42:38Z", "type": "commit"}, {"oid": "dc81f1679a654505e98e120f073ae2d6e2eafd23", "url": "https://github.com/Alluxio/alluxio/commit/dc81f1679a654505e98e120f073ae2d6e2eafd23", "message": "fix logic error", "committedDate": "2020-05-07T02:50:22Z", "type": "commit"}, {"oid": "1dd690d2c52dbf4b4209a3696aab4ec3ac0f720d", "url": "https://github.com/Alluxio/alluxio/commit/1dd690d2c52dbf4b4209a3696aab4ec3ac0f720d", "message": "better heurstics", "committedDate": "2020-05-08T00:53:25Z", "type": "commit"}, {"oid": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "url": "https://github.com/Alluxio/alluxio/commit/8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "message": "more comments and less logging", "committedDate": "2020-05-08T04:41:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTc3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422259771", "bodyText": "If we seek backward should sequential count always be set to 0?", "author": "calvinjia", "createdAt": "2020-05-08T17:06:07Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {", "originalCommit": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzQ1OA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422307458", "bodyText": "yeah i was undecided about this one, but probably rare to see someone jump forward and then jump back in the stream?", "author": "yuzhu", "createdAt": "2020-05-08T18:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "e334b0533d4903c77a479f31b967019518442096", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex d80df4eec2..eed82c7745 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -90,32 +90,29 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n     }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n-    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n-    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n       mSequentialReadCount = 0;\n-    } else {\n-      ((FSDataInputStream) in).seek(position);\n     }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n     if (n > MOVEMENT_LIMIT) {\n       mSequentialReadCount = 0;\n-      mPos += n;\n-      return n;\n-    } else {\n-      long skipped = ((FSDataInputStream) in).skip(n);\n-      mPos += skipped;\n-      return skipped;\n     }\n+    mPos += n;\n+    return n;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDgyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422260825", "bodyText": "Should this only be incremented if bytesRead > 0?", "author": "calvinjia", "createdAt": "2020-05-08T17:08:25Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;", "originalCommit": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNzQ5NA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422307494", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-08T18:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MDgyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "e334b0533d4903c77a479f31b967019518442096", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex d80df4eec2..eed82c7745 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -90,32 +90,29 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n     }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n-    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n-    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n       mSequentialReadCount = 0;\n-    } else {\n-      ((FSDataInputStream) in).seek(position);\n     }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n     if (n > MOVEMENT_LIMIT) {\n       mSequentialReadCount = 0;\n-      mPos += n;\n-      return n;\n-    } else {\n-      long skipped = ((FSDataInputStream) in).skip(n);\n-      mPos += skipped;\n-      return skipped;\n     }\n+    mPos += n;\n+    return n;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MTUxOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422261519", "bodyText": "Is it guaranteed that in is positioned correctly?", "author": "calvinjia", "createdAt": "2020-05-08T17:09:46Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,24 +71,51 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n     }\n+    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((FSDataInputStream) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n-    mPos += n;\n-    return n;\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+      mPos += n;\n+      return n;\n+    } else {\n+      long skipped = ((FSDataInputStream) in).skip(n);", "originalCommit": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwNjczMQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422306731", "bodyText": "good catch, fixed", "author": "yuzhu", "createdAt": "2020-05-08T18:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MTUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e334b0533d4903c77a479f31b967019518442096", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex d80df4eec2..eed82c7745 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -90,32 +90,29 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n     }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n-    mSequentialReadCount++;\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n-    if (Math.abs(position - mPos) > MOVEMENT_LIMIT) {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n       mSequentialReadCount = 0;\n-    } else {\n-      ((FSDataInputStream) in).seek(position);\n     }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n     if (n > MOVEMENT_LIMIT) {\n       mSequentialReadCount = 0;\n-      mPos += n;\n-      return n;\n-    } else {\n-      long skipped = ((FSDataInputStream) in).skip(n);\n-      mPos += skipped;\n-      return skipped;\n     }\n+    mPos += n;\n+    return n;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422262140", "bodyText": "Do these numbers require tuning or is the heuristic good enough?", "author": "calvinjia", "createdAt": "2020-05-08T17:11:04Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -24,11 +24,21 @@\n  * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  private static final int MOVEMENT_LIMIT = 512;", "originalCommit": "8f10c3a6ad830cdf8530fd8240b6d3498a25e86b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjMwODE3Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422308177", "bodyText": "We could further tune these, but experimentally journal replays are as fast as before, will verify remote spark tpcds behavior soon.", "author": "yuzhu", "createdAt": "2020-05-08T18:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM1ODU4MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422358581", "bodyText": "nit: add a comment describing these as counts and not a bytes limit", "author": "madanadit", "createdAt": "2020-05-08T20:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MzYzMg==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422363632", "bodyText": "if they require tuning, i prefer and property. we can choose to make it hidden in case we don't want to add to the user's confusion.", "author": "madanadit", "createdAt": "2020-05-08T20:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NzkwNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422457905", "bodyText": "So I am actually leaning towards making these not tunable for now. A tunable parameter is only useful if there is some metric / log message that suggests these parameters need to be tuned. Right now we don't have any of that. These default values should work well out of the box.\nHow about we add a TODO here to make another PR with the appropriate diagnostic metrics and make it tunable in that PR?", "author": "yuzhu", "createdAt": "2020-05-09T06:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI2MjE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "c3645fb20761ad43d527345790697991c1fc6dd3", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex d80df4eec2..1f6de17b3d 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -16,15 +16,23 @@ import alluxio.util.io.BufferUtils;\n \n import com.google.common.base.Preconditions;\n import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.PositionedReadable;\n+import org.apache.hadoop.fs.Seekable;\n \n import java.io.IOException;\n \n /**\n- * The input stream of HDFS as under filesystem. This input stream supports seeking but internally\n- * uses the positionedRead {@link FSDataInputStream} API. This stream can be cached for reuse.\n+ * The input stream of HDFS as under filesystem. This input stream has two mode of operations.\n+ * Under sequential mode, it uses the read api and can take advantage of underlying stream's\n+ * buffering. Under random read mode, it uses the positionedRead {@link FSDataInputStream} API.\n+ * This stream can be cached for reuse.\n  */\n public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputStream {\n+  // After this many number of sequential reads (reads without large skips), it\n+  // will switch to sequential read mode.\n   private static final int SEQUENTIAL_READ_LIMIT = 3;\n+  // This describes the number of bytes that we can move forward in a stream without\n+  // switching to random read mode.\n   private static final int MOVEMENT_LIMIT = 512;\n \n   private long mPos;\n"}}, {"oid": "e334b0533d4903c77a479f31b967019518442096", "url": "https://github.com/Alluxio/alluxio/commit/e334b0533d4903c77a479f31b967019518442096", "message": "address comments", "committedDate": "2020-05-08T20:22:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422393756", "bodyText": "We still need to skip in the stream if we are in the sequential read mode and n is less than the movement limit?", "author": "calvinjia", "createdAt": "2020-05-08T21:54:34Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +71,46 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((FSDataInputStream) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((FSDataInputStream) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    }", "originalCommit": "e334b0533d4903c77a479f31b967019518442096", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwMDA5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422400096", "bodyText": "it is not necessary, because our mPos is the ground truth. As long as we maintain mPos, we can delay any seek or skip until when we actually read.", "author": "yuzhu", "createdAt": "2020-05-08T22:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQwNTExMA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422405110", "bodyText": "In that case, a read pattern like read, read, read, skip(1), read, skip(1), read will cause us to lose the sequential read mode at the last read. Is this intended?", "author": "calvinjia", "createdAt": "2020-05-08T22:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1NzI0NA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422457244", "bodyText": "yes, fixed. it became obvious once i started writing the test.", "author": "yuzhu", "createdAt": "2020-05-09T06:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzc1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "84259b50133bb5c4cfe815ed12e60fd8f264f5dc", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex eed82c7745..c85af1bdea 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -79,14 +81,14 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n     int bytesRead;\n     if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n-      ((FSDataInputStream) in).seek(mPos);\n+      ((Seekable) in).seek(mPos);\n       mSequentialReadCount = 0;\n     }\n-    if (mPos == ((FSDataInputStream) in).getPos()) {\n+    if (mPos == ((Seekable) in).getPos()) {\n       // same position, use buffered reads as default\n       bytesRead = in.read(buffer, offset, length);\n     } else {\n-      bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n     }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n"}}, {"oid": "84259b50133bb5c4cfe815ed12e60fd8f264f5dc", "url": "https://github.com/Alluxio/alluxio/commit/84259b50133bb5c4cfe815ed12e60fd8f264f5dc", "message": "add test and address comments", "committedDate": "2020-05-09T02:54:17Z", "type": "commit"}, {"oid": "c3645fb20761ad43d527345790697991c1fc6dd3", "url": "https://github.com/Alluxio/alluxio/commit/c3645fb20761ad43d527345790697991c1fc6dd3", "message": "update comments", "committedDate": "2020-05-09T06:17:13Z", "type": "commit"}, {"oid": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "url": "https://github.com/Alluxio/alluxio/commit/b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "message": "add TODO", "committedDate": "2020-05-09T06:20:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MDg3MA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422670870", "bodyText": "nit: this seems to be a clone of FilterInputStream javadoc. I don't think we need a copy here.", "author": "madanadit", "createdAt": "2020-05-10T16:57:44Z", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjExNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702115", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MDg3MA=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\nindex 3985ab58c8..0a82264017 100644\n--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n\n@@ -88,83 +85,65 @@ public final class HdfsUnderFileSystemTest {\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n \n-  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n-\n-    /**\n-     * Creates a <code>FilterInputStream</code>\n-     * by assigning the  argument <code>in</code>\n-     * to the field <code>this.in</code> so as\n-     * to remember it for later use.\n-     *\n-     * @param in the underlying input stream, or <code>null</code> if\n-     *           this instance is to be created without an underlying stream.\n-     */\n-    protected PreadSeekableStream(InputStream in) {\n-      super(in);\n-    }\n-\n-    @Override\n-    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n-      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes);\n-    }\n-\n-    @Override\n-    public void seek(long l) throws IOException {\n-      ((FSDataInputStream) in).seek(l);\n-    }\n-\n-    @Override\n-    public long getPos() throws IOException {\n-      return ((FSDataInputStream) in).getPos();\n-    }\n-\n-    @Override\n-    public boolean seekToNewSource(long l) throws IOException {\n-      return ((FSDataInputStream) in).seekToNewSource(l);\n-    }\n+  private void checkDataValid(int data, int index) {\n+    // index is larger than Byte.MAX_VALUE, convert to byte to compare\n+    Assert.assertEquals((byte) index, (byte) data);\n   }\n+\n   /**\n    * Tests the dynamic switching between pread and read calls to underlying stream.\n    */\n   @Test\n   public void verifyPread() throws Exception {\n     File file = mTemporaryFolder.newFile(\"test.txt\");\n-    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n-    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n-        OpenOptions.defaults().setPositionShort(true));\n+    byte[] data = new byte[4 * MOVEMENT_LIMIT];\n+    for (int i = 0; i < 4 * MOVEMENT_LIMIT; i++) {\n+      data[i] = (byte) i;\n+    }\n+    FileUtils.writeByteArrayToFile(file, data);\n+    SeekableUnderFileInputStream in = (SeekableUnderFileInputStream) mHdfsUnderFileSystem.open(\n+        file.getAbsolutePath(), OpenOptions.defaults().setPositionShort(true));\n     FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n     PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n     PreadSeekableStream spyStream = spy(stream);\n     Whitebox.setInternalState(in, \"in\", spyStream);\n-    in.read();\n-    in.read();\n-    in.read();\n-    in.read();\n+    int readPos = 0;\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n     in.skip(2);\n-    in.read();\n+    readPos += 4;\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n-    in.read();\n+    readPos += 2;\n+    checkDataValid(in.read(), readPos++);\n+    // we are in sequential read mode, therefore all reads are normal reads and never preads\n     verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.skip(1000);\n-    in.read();\n-    in.read();\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    in.skip(MOVEMENT_LIMIT + 1);\n+    readPos += MOVEMENT_LIMIT + 1;\n+    for (int i = 0; i < SEQUENTIAL_READ_LIMIT; i++) {\n+      checkDataValid(in.read(), readPos++);\n+    }\n+    // because we skipped over more than MOVEMENT_LIMIT, we switched to pread mode, the next\n+    // three reads are preads\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    // we performed more than SEQUENTIAL_READ_LIMIT reads without seeking beyond movement limit,\n+    // thus we switch back to sequential read mode\n+    checkDataValid(in.read(), readPos++);\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n+    in.seek(MOVEMENT_LIMIT * 3);\n+    readPos = MOVEMENT_LIMIT * 3;\n+    checkDataValid(in.read(), readPos++);\n+    // we performed seek to a far location, we should switch back to pread mode\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT + 1)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n     in.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MTQ2NA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422671464", "bodyText": "nit: this doesn't need to be a nested class? separate file for readability", "author": "madanadit", "createdAt": "2020-05-10T17:02:33Z", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEwNg==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702106", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MTQ2NA=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\nindex 3985ab58c8..0a82264017 100644\n--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n\n@@ -88,83 +85,65 @@ public final class HdfsUnderFileSystemTest {\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n \n-  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n-\n-    /**\n-     * Creates a <code>FilterInputStream</code>\n-     * by assigning the  argument <code>in</code>\n-     * to the field <code>this.in</code> so as\n-     * to remember it for later use.\n-     *\n-     * @param in the underlying input stream, or <code>null</code> if\n-     *           this instance is to be created without an underlying stream.\n-     */\n-    protected PreadSeekableStream(InputStream in) {\n-      super(in);\n-    }\n-\n-    @Override\n-    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n-      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes);\n-    }\n-\n-    @Override\n-    public void seek(long l) throws IOException {\n-      ((FSDataInputStream) in).seek(l);\n-    }\n-\n-    @Override\n-    public long getPos() throws IOException {\n-      return ((FSDataInputStream) in).getPos();\n-    }\n-\n-    @Override\n-    public boolean seekToNewSource(long l) throws IOException {\n-      return ((FSDataInputStream) in).seekToNewSource(l);\n-    }\n+  private void checkDataValid(int data, int index) {\n+    // index is larger than Byte.MAX_VALUE, convert to byte to compare\n+    Assert.assertEquals((byte) index, (byte) data);\n   }\n+\n   /**\n    * Tests the dynamic switching between pread and read calls to underlying stream.\n    */\n   @Test\n   public void verifyPread() throws Exception {\n     File file = mTemporaryFolder.newFile(\"test.txt\");\n-    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n-    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n-        OpenOptions.defaults().setPositionShort(true));\n+    byte[] data = new byte[4 * MOVEMENT_LIMIT];\n+    for (int i = 0; i < 4 * MOVEMENT_LIMIT; i++) {\n+      data[i] = (byte) i;\n+    }\n+    FileUtils.writeByteArrayToFile(file, data);\n+    SeekableUnderFileInputStream in = (SeekableUnderFileInputStream) mHdfsUnderFileSystem.open(\n+        file.getAbsolutePath(), OpenOptions.defaults().setPositionShort(true));\n     FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n     PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n     PreadSeekableStream spyStream = spy(stream);\n     Whitebox.setInternalState(in, \"in\", spyStream);\n-    in.read();\n-    in.read();\n-    in.read();\n-    in.read();\n+    int readPos = 0;\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n     in.skip(2);\n-    in.read();\n+    readPos += 4;\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n-    in.read();\n+    readPos += 2;\n+    checkDataValid(in.read(), readPos++);\n+    // we are in sequential read mode, therefore all reads are normal reads and never preads\n     verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.skip(1000);\n-    in.read();\n-    in.read();\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    in.skip(MOVEMENT_LIMIT + 1);\n+    readPos += MOVEMENT_LIMIT + 1;\n+    for (int i = 0; i < SEQUENTIAL_READ_LIMIT; i++) {\n+      checkDataValid(in.read(), readPos++);\n+    }\n+    // because we skipped over more than MOVEMENT_LIMIT, we switched to pread mode, the next\n+    // three reads are preads\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    // we performed more than SEQUENTIAL_READ_LIMIT reads without seeking beyond movement limit,\n+    // thus we switch back to sequential read mode\n+    checkDataValid(in.read(), readPos++);\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n+    in.seek(MOVEMENT_LIMIT * 3);\n+    readPos = MOVEMENT_LIMIT * 3;\n+    checkDataValid(in.read(), readPos++);\n+    // we performed seek to a far location, we should switch back to pread mode\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT + 1)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n     in.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Mjk4MA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422672980", "bodyText": "nit: comment why pread is never called", "author": "madanadit", "createdAt": "2020-05-10T17:15:31Z", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEzNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702135", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Mjk4MA=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\nindex 3985ab58c8..0a82264017 100644\n--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n\n@@ -88,83 +85,65 @@ public final class HdfsUnderFileSystemTest {\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n \n-  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n-\n-    /**\n-     * Creates a <code>FilterInputStream</code>\n-     * by assigning the  argument <code>in</code>\n-     * to the field <code>this.in</code> so as\n-     * to remember it for later use.\n-     *\n-     * @param in the underlying input stream, or <code>null</code> if\n-     *           this instance is to be created without an underlying stream.\n-     */\n-    protected PreadSeekableStream(InputStream in) {\n-      super(in);\n-    }\n-\n-    @Override\n-    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n-      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes);\n-    }\n-\n-    @Override\n-    public void seek(long l) throws IOException {\n-      ((FSDataInputStream) in).seek(l);\n-    }\n-\n-    @Override\n-    public long getPos() throws IOException {\n-      return ((FSDataInputStream) in).getPos();\n-    }\n-\n-    @Override\n-    public boolean seekToNewSource(long l) throws IOException {\n-      return ((FSDataInputStream) in).seekToNewSource(l);\n-    }\n+  private void checkDataValid(int data, int index) {\n+    // index is larger than Byte.MAX_VALUE, convert to byte to compare\n+    Assert.assertEquals((byte) index, (byte) data);\n   }\n+\n   /**\n    * Tests the dynamic switching between pread and read calls to underlying stream.\n    */\n   @Test\n   public void verifyPread() throws Exception {\n     File file = mTemporaryFolder.newFile(\"test.txt\");\n-    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n-    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n-        OpenOptions.defaults().setPositionShort(true));\n+    byte[] data = new byte[4 * MOVEMENT_LIMIT];\n+    for (int i = 0; i < 4 * MOVEMENT_LIMIT; i++) {\n+      data[i] = (byte) i;\n+    }\n+    FileUtils.writeByteArrayToFile(file, data);\n+    SeekableUnderFileInputStream in = (SeekableUnderFileInputStream) mHdfsUnderFileSystem.open(\n+        file.getAbsolutePath(), OpenOptions.defaults().setPositionShort(true));\n     FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n     PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n     PreadSeekableStream spyStream = spy(stream);\n     Whitebox.setInternalState(in, \"in\", spyStream);\n-    in.read();\n-    in.read();\n-    in.read();\n-    in.read();\n+    int readPos = 0;\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n     in.skip(2);\n-    in.read();\n+    readPos += 4;\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n-    in.read();\n+    readPos += 2;\n+    checkDataValid(in.read(), readPos++);\n+    // we are in sequential read mode, therefore all reads are normal reads and never preads\n     verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.skip(1000);\n-    in.read();\n-    in.read();\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    in.skip(MOVEMENT_LIMIT + 1);\n+    readPos += MOVEMENT_LIMIT + 1;\n+    for (int i = 0; i < SEQUENTIAL_READ_LIMIT; i++) {\n+      checkDataValid(in.read(), readPos++);\n+    }\n+    // because we skipped over more than MOVEMENT_LIMIT, we switched to pread mode, the next\n+    // three reads are preads\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    // we performed more than SEQUENTIAL_READ_LIMIT reads without seeking beyond movement limit,\n+    // thus we switch back to sequential read mode\n+    checkDataValid(in.read(), readPos++);\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n+    in.seek(MOVEMENT_LIMIT * 3);\n+    readPos = MOVEMENT_LIMIT * 3;\n+    checkDataValid(in.read(), readPos++);\n+    // we performed seek to a far location, we should switch back to pread mode\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT + 1)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n     in.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzAzOQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422673039", "bodyText": "nit: comment that skip > MOVEMENT_LIMIT causes pread. maybe even mark MOVEMENT_LIMIT @VisibleForTesting and re-use 2*MOVEMENT_LIMIT to avoid changing the test if we tune the parameter.", "author": "madanadit", "createdAt": "2020-05-10T17:15:57Z", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702146", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzAzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\nindex 3985ab58c8..0a82264017 100644\n--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n\n@@ -88,83 +85,65 @@ public final class HdfsUnderFileSystemTest {\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n \n-  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n-\n-    /**\n-     * Creates a <code>FilterInputStream</code>\n-     * by assigning the  argument <code>in</code>\n-     * to the field <code>this.in</code> so as\n-     * to remember it for later use.\n-     *\n-     * @param in the underlying input stream, or <code>null</code> if\n-     *           this instance is to be created without an underlying stream.\n-     */\n-    protected PreadSeekableStream(InputStream in) {\n-      super(in);\n-    }\n-\n-    @Override\n-    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n-      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes);\n-    }\n-\n-    @Override\n-    public void seek(long l) throws IOException {\n-      ((FSDataInputStream) in).seek(l);\n-    }\n-\n-    @Override\n-    public long getPos() throws IOException {\n-      return ((FSDataInputStream) in).getPos();\n-    }\n-\n-    @Override\n-    public boolean seekToNewSource(long l) throws IOException {\n-      return ((FSDataInputStream) in).seekToNewSource(l);\n-    }\n+  private void checkDataValid(int data, int index) {\n+    // index is larger than Byte.MAX_VALUE, convert to byte to compare\n+    Assert.assertEquals((byte) index, (byte) data);\n   }\n+\n   /**\n    * Tests the dynamic switching between pread and read calls to underlying stream.\n    */\n   @Test\n   public void verifyPread() throws Exception {\n     File file = mTemporaryFolder.newFile(\"test.txt\");\n-    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n-    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n-        OpenOptions.defaults().setPositionShort(true));\n+    byte[] data = new byte[4 * MOVEMENT_LIMIT];\n+    for (int i = 0; i < 4 * MOVEMENT_LIMIT; i++) {\n+      data[i] = (byte) i;\n+    }\n+    FileUtils.writeByteArrayToFile(file, data);\n+    SeekableUnderFileInputStream in = (SeekableUnderFileInputStream) mHdfsUnderFileSystem.open(\n+        file.getAbsolutePath(), OpenOptions.defaults().setPositionShort(true));\n     FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n     PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n     PreadSeekableStream spyStream = spy(stream);\n     Whitebox.setInternalState(in, \"in\", spyStream);\n-    in.read();\n-    in.read();\n-    in.read();\n-    in.read();\n+    int readPos = 0;\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n     in.skip(2);\n-    in.read();\n+    readPos += 4;\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n-    in.read();\n+    readPos += 2;\n+    checkDataValid(in.read(), readPos++);\n+    // we are in sequential read mode, therefore all reads are normal reads and never preads\n     verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.skip(1000);\n-    in.read();\n-    in.read();\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    in.skip(MOVEMENT_LIMIT + 1);\n+    readPos += MOVEMENT_LIMIT + 1;\n+    for (int i = 0; i < SEQUENTIAL_READ_LIMIT; i++) {\n+      checkDataValid(in.read(), readPos++);\n+    }\n+    // because we skipped over more than MOVEMENT_LIMIT, we switched to pread mode, the next\n+    // three reads are preads\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    // we performed more than SEQUENTIAL_READ_LIMIT reads without seeking beyond movement limit,\n+    // thus we switch back to sequential read mode\n+    checkDataValid(in.read(), readPos++);\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n+    in.seek(MOVEMENT_LIMIT * 3);\n+    readPos = MOVEMENT_LIMIT * 3;\n+    checkDataValid(in.read(), readPos++);\n+    // we performed seek to a far location, we should switch back to pread mode\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT + 1)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n     in.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzY0Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422673647", "bodyText": "nit: comment that read > SEQUENTIAL_READ_LIMIT causes . similar to above consider exposing SEQUENTIAL_READ_LIMIT for testing and using a for loop here to avoid changing the test after possible tuning", "author": "madanadit", "createdAt": "2020-05-10T17:21:09Z", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n+    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n+        OpenOptions.defaults().setPositionShort(true));\n+    FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n+    PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n+    PreadSeekableStream spyStream = spy(stream);\n+    Whitebox.setInternalState(in, \"in\", spyStream);\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.read();\n+    in.skip(2);\n+    in.skip(2);\n+    in.read();\n+    in.skip(2);\n+    in.read();\n+    verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.skip(1000);\n+    in.read();\n+    in.read();\n+    in.read();\n+    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n+    in.read();", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjE1Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702153", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3MzY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\nindex 3985ab58c8..0a82264017 100644\n--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n\n@@ -88,83 +85,65 @@ public final class HdfsUnderFileSystemTest {\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n \n-  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n-\n-    /**\n-     * Creates a <code>FilterInputStream</code>\n-     * by assigning the  argument <code>in</code>\n-     * to the field <code>this.in</code> so as\n-     * to remember it for later use.\n-     *\n-     * @param in the underlying input stream, or <code>null</code> if\n-     *           this instance is to be created without an underlying stream.\n-     */\n-    protected PreadSeekableStream(InputStream in) {\n-      super(in);\n-    }\n-\n-    @Override\n-    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n-      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes);\n-    }\n-\n-    @Override\n-    public void seek(long l) throws IOException {\n-      ((FSDataInputStream) in).seek(l);\n-    }\n-\n-    @Override\n-    public long getPos() throws IOException {\n-      return ((FSDataInputStream) in).getPos();\n-    }\n-\n-    @Override\n-    public boolean seekToNewSource(long l) throws IOException {\n-      return ((FSDataInputStream) in).seekToNewSource(l);\n-    }\n+  private void checkDataValid(int data, int index) {\n+    // index is larger than Byte.MAX_VALUE, convert to byte to compare\n+    Assert.assertEquals((byte) index, (byte) data);\n   }\n+\n   /**\n    * Tests the dynamic switching between pread and read calls to underlying stream.\n    */\n   @Test\n   public void verifyPread() throws Exception {\n     File file = mTemporaryFolder.newFile(\"test.txt\");\n-    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n-    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n-        OpenOptions.defaults().setPositionShort(true));\n+    byte[] data = new byte[4 * MOVEMENT_LIMIT];\n+    for (int i = 0; i < 4 * MOVEMENT_LIMIT; i++) {\n+      data[i] = (byte) i;\n+    }\n+    FileUtils.writeByteArrayToFile(file, data);\n+    SeekableUnderFileInputStream in = (SeekableUnderFileInputStream) mHdfsUnderFileSystem.open(\n+        file.getAbsolutePath(), OpenOptions.defaults().setPositionShort(true));\n     FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n     PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n     PreadSeekableStream spyStream = spy(stream);\n     Whitebox.setInternalState(in, \"in\", spyStream);\n-    in.read();\n-    in.read();\n-    in.read();\n-    in.read();\n+    int readPos = 0;\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n     in.skip(2);\n-    in.read();\n+    readPos += 4;\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n-    in.read();\n+    readPos += 2;\n+    checkDataValid(in.read(), readPos++);\n+    // we are in sequential read mode, therefore all reads are normal reads and never preads\n     verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.skip(1000);\n-    in.read();\n-    in.read();\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    in.skip(MOVEMENT_LIMIT + 1);\n+    readPos += MOVEMENT_LIMIT + 1;\n+    for (int i = 0; i < SEQUENTIAL_READ_LIMIT; i++) {\n+      checkDataValid(in.read(), readPos++);\n+    }\n+    // because we skipped over more than MOVEMENT_LIMIT, we switched to pread mode, the next\n+    // three reads are preads\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    // we performed more than SEQUENTIAL_READ_LIMIT reads without seeking beyond movement limit,\n+    // thus we switch back to sequential read mode\n+    checkDataValid(in.read(), readPos++);\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n+    in.seek(MOVEMENT_LIMIT * 3);\n+    readPos = MOVEMENT_LIMIT * 3;\n+    checkDataValid(in.read(), readPos++);\n+    // we performed seek to a far location, we should switch back to pread mode\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT + 1)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n     in.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDAyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422674025", "bodyText": "nit: the comment above is mis-placed?", "author": "madanadit", "createdAt": "2020-05-10T17:24:06Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java\nindex be5c2f4e15..30f82bc1f5 100755\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java\n\n@@ -556,8 +556,6 @@ public class HdfsUnderFileSystem extends ConsistentUnderFileSystem\n   private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n-    // Heuristic to determine whether to use positionedRead on hdfs ufs\n-    // If any block is not found on the same host, we use pread api\n     BlockLocation[] blockLocations;\n     try {\n       blockLocations = fs.getFileBlockLocations(filePath,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDA5Mg==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422674092", "bodyText": "nit: also this comment seems mis-placed as this method makes no decision about pread api", "author": "madanadit", "createdAt": "2020-05-10T17:24:44Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java", "diffHunk": "@@ -553,19 +553,28 @@ public boolean mkdirs(String path, MkdirsOptions options) throws IOException {\n     throw te;\n   }\n \n-  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options)\n-      throws IOException {\n+  private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n     // Heuristic to determine whether to use positionedRead on hdfs ufs\n     // If any block is not found on the same host, we use pread api\n-    BlockLocation[] blockLocations = fs.getFileBlockLocations(filePath,\n-        options.getOffset(), options.getLength());\n-    for (BlockLocation loc : blockLocations) {\n-      if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n-        // Some blocks are remote only, use pread api to HDFS\n-        return false;\n+    BlockLocation[] blockLocations;\n+    try {\n+      blockLocations = fs.getFileBlockLocations(filePath,\n+          options.getOffset(), options.getLength());\n+      if (blockLocations == null) {\n+        // no blocks exist\n+        return true;\n       }\n+\n+      for (BlockLocation loc : blockLocations) {\n+        if (Arrays.stream(loc.getHosts()).noneMatch(localHost::equals)) {\n+          // Some blocks are remote only, use pread api to HDFS", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA5Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702096", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NDA5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java\nindex be5c2f4e15..30f82bc1f5 100755\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsUnderFileSystem.java\n\n@@ -556,8 +556,6 @@ public class HdfsUnderFileSystem extends ConsistentUnderFileSystem\n   private boolean isReadLocal(FileSystem fs, Path filePath, OpenOptions options) {\n     String localHost = NetworkAddressUtils.getLocalHostName((int) mUfsConf\n         .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS));\n-    // Heuristic to determine whether to use positionedRead on hdfs ufs\n-    // If any block is not found on the same host, we use pread api\n     BlockLocation[] blockLocations;\n     try {\n       blockLocations = fs.getFileBlockLocations(filePath,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTA1Nw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422675057", "bodyText": "nit: in this test can we also check if the data read back is what we expect, in addition to the API used to read?", "author": "madanadit", "createdAt": "2020-05-10T17:32:43Z", "path": "underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java", "diffHunk": "@@ -63,4 +87,85 @@ public void prepareConfiguration() throws Exception {\n     Assert.assertEquals(ufsConf.get(PropertyKey.UNDERFS_HDFS_IMPL), conf.get(\"fs.hdfs.impl\"));\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n+\n+  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n+\n+    /**\n+     * Creates a <code>FilterInputStream</code>\n+     * by assigning the  argument <code>in</code>\n+     * to the field <code>this.in</code> so as\n+     * to remember it for later use.\n+     *\n+     * @param in the underlying input stream, or <code>null</code> if\n+     *           this instance is to be created without an underlying stream.\n+     */\n+    protected PreadSeekableStream(InputStream in) {\n+      super(in);\n+    }\n+\n+    @Override\n+    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n+      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n+    }\n+\n+    @Override\n+    public void readFully(long l, byte[] bytes) throws IOException {\n+      ((FSDataInputStream) in).readFully(l, bytes);\n+    }\n+\n+    @Override\n+    public void seek(long l) throws IOException {\n+      ((FSDataInputStream) in).seek(l);\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return ((FSDataInputStream) in).getPos();\n+    }\n+\n+    @Override\n+    public boolean seekToNewSource(long l) throws IOException {\n+      return ((FSDataInputStream) in).seekToNewSource(l);\n+    }\n+  }\n+  /**\n+   * Tests the dynamic switching between pread and read calls to underlying stream.\n+   */\n+  @Test\n+  public void verifyPread() throws Exception {\n+    File file = mTemporaryFolder.newFile(\"test.txt\");\n+    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjEyMw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702123", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTA1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\nindex 3985ab58c8..0a82264017 100644\n--- a/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n+++ b/underfs/hdfs/src/test/java/alluxio/underfs/hdfs/HdfsUnderFileSystemTest.java\n\n@@ -88,83 +85,65 @@ public final class HdfsUnderFileSystemTest {\n     Assert.assertTrue(conf.getBoolean(\"fs.hdfs.impl.disable.cache\", false));\n   }\n \n-  class PreadSeekableStream extends FilterInputStream implements Seekable, PositionedReadable {\n-\n-    /**\n-     * Creates a <code>FilterInputStream</code>\n-     * by assigning the  argument <code>in</code>\n-     * to the field <code>this.in</code> so as\n-     * to remember it for later use.\n-     *\n-     * @param in the underlying input stream, or <code>null</code> if\n-     *           this instance is to be created without an underlying stream.\n-     */\n-    protected PreadSeekableStream(InputStream in) {\n-      super(in);\n-    }\n-\n-    @Override\n-    public int read(long l, byte[] bytes, int i, int i1) throws IOException {\n-      return ((FSDataInputStream) in).read(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes, int i, int i1) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes, i, i1);\n-    }\n-\n-    @Override\n-    public void readFully(long l, byte[] bytes) throws IOException {\n-      ((FSDataInputStream) in).readFully(l, bytes);\n-    }\n-\n-    @Override\n-    public void seek(long l) throws IOException {\n-      ((FSDataInputStream) in).seek(l);\n-    }\n-\n-    @Override\n-    public long getPos() throws IOException {\n-      return ((FSDataInputStream) in).getPos();\n-    }\n-\n-    @Override\n-    public boolean seekToNewSource(long l) throws IOException {\n-      return ((FSDataInputStream) in).seekToNewSource(l);\n-    }\n+  private void checkDataValid(int data, int index) {\n+    // index is larger than Byte.MAX_VALUE, convert to byte to compare\n+    Assert.assertEquals((byte) index, (byte) data);\n   }\n+\n   /**\n    * Tests the dynamic switching between pread and read calls to underlying stream.\n    */\n   @Test\n   public void verifyPread() throws Exception {\n     File file = mTemporaryFolder.newFile(\"test.txt\");\n-    FileUtils.writeByteArrayToFile(file, CommonUtils.randomBytes(4096));\n-    FilterInputStream in = (FilterInputStream) mHdfsUnderFileSystem.open(file.getAbsolutePath(),\n-        OpenOptions.defaults().setPositionShort(true));\n+    byte[] data = new byte[4 * MOVEMENT_LIMIT];\n+    for (int i = 0; i < 4 * MOVEMENT_LIMIT; i++) {\n+      data[i] = (byte) i;\n+    }\n+    FileUtils.writeByteArrayToFile(file, data);\n+    SeekableUnderFileInputStream in = (SeekableUnderFileInputStream) mHdfsUnderFileSystem.open(\n+        file.getAbsolutePath(), OpenOptions.defaults().setPositionShort(true));\n     FSDataInputStream dataInput = Whitebox.getInternalState(in, \"in\");\n     PreadSeekableStream stream = new PreadSeekableStream(dataInput);\n     PreadSeekableStream spyStream = spy(stream);\n     Whitebox.setInternalState(in, \"in\", spyStream);\n-    in.read();\n-    in.read();\n-    in.read();\n-    in.read();\n+    int readPos = 0;\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n     in.skip(2);\n-    in.read();\n+    readPos += 4;\n+    checkDataValid(in.read(), readPos++);\n     in.skip(2);\n-    in.read();\n+    readPos += 2;\n+    checkDataValid(in.read(), readPos++);\n+    // we are in sequential read mode, therefore all reads are normal reads and never preads\n     verify(spyStream, never()).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.skip(1000);\n-    in.read();\n-    in.read();\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    in.skip(MOVEMENT_LIMIT + 1);\n+    readPos += MOVEMENT_LIMIT + 1;\n+    for (int i = 0; i < SEQUENTIAL_READ_LIMIT; i++) {\n+      checkDataValid(in.read(), readPos++);\n+    }\n+    // because we skipped over more than MOVEMENT_LIMIT, we switched to pread mode, the next\n+    // three reads are preads\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(6)).read(any(byte[].class), anyInt(), anyInt());\n-    in.read();\n-    verify(spyStream, times(3)).read(anyInt(), any(byte[].class), anyInt(), anyInt());\n+    // we performed more than SEQUENTIAL_READ_LIMIT reads without seeking beyond movement limit,\n+    // thus we switch back to sequential read mode\n+    checkDataValid(in.read(), readPos++);\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n+    verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n+    in.seek(MOVEMENT_LIMIT * 3);\n+    readPos = MOVEMENT_LIMIT * 3;\n+    checkDataValid(in.read(), readPos++);\n+    // we performed seek to a far location, we should switch back to pread mode\n+    verify(spyStream, times(SEQUENTIAL_READ_LIMIT + 1)).read(\n+        anyInt(), any(byte[].class), anyInt(), anyInt());\n     verify(spyStream, times(7)).read(any(byte[].class), anyInt(), anyInt());\n     in.close();\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTYxMw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422675613", "bodyText": "is this seek necessary or guaranteed to be a no-op if say I have 10 continuous reads as we reset mSequentialReadCount and seek after every 3 reads?", "author": "madanadit", "createdAt": "2020-05-10T17:36:50Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMTgzOA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422701838", "bodyText": "I changed this part a bit so we don't do the noop seek. Basically we do the seek lazily if we are in sequential mode, and don't reset the counter until we seek or skip a large step.", "author": "yuzhu", "createdAt": "2020-05-10T21:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NTYxMw=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex cd14811f81..0d4a365f8b 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -87,9 +90,8 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n     int bytesRead;\n-    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+    if (isSequentialReadMode() && mPos != ((Seekable) in).getPos()) {\n       ((Seekable) in).seek(mPos);\n-      mSequentialReadCount = 0;\n     }\n     if (mPos == ((Seekable) in).getPos()) {\n       // same position, use buffered reads as default\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NzU3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422677571", "bodyText": "what if\n\nstream is in random read mode and mPos=0\nHdfsPositionedUnderFileInputeStream.seek(MOVEMENT_LIMIT-1)\nwe end up calling seek on FSDataInputStream and that is undesired?\n\ninstead can we refactor this by creating an auxiliary method isSequentialReadMode=mSequentialReadCount> SEQUENTIAL_READ_LIMIT\n   if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n      mSequentialReadCount = 0;\n    }\n\n    if (isSequentialReadMode()) {\n      ((Seekable) in).seek(position);", "author": "madanadit", "createdAt": "2020-05-10T17:53:03Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702056", "bodyText": "see above, i now avoid this seek entirely by doing it lazily in the read.", "author": "yuzhu", "createdAt": "2020-05-10T21:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3NzU3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex cd14811f81..0d4a365f8b 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -87,9 +90,8 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n     int bytesRead;\n-    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+    if (isSequentialReadMode() && mPos != ((Seekable) in).getPos()) {\n       ((Seekable) in).seek(mPos);\n-      mSequentialReadCount = 0;\n     }\n     if (mPos == ((Seekable) in).getPos()) {\n       // same position, use buffered reads as default\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Nzg1Mw==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422677853", "bodyText": "nit: for readability i prefer a method called  isSequentialReadMode to determine whether to seek or not", "author": "madanadit", "createdAt": "2020-05-10T17:54:48Z", "path": "underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java", "diffHunk": "@@ -61,22 +80,50 @@ public int read(byte[] b) throws IOException {\n     return read(b, 0, b.length);\n   }\n \n+  /**\n+   * If there has been a number of sequential reads in a row,\n+   * we move to regular buffered reads.\n+   */\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n-    int bytesRead = ((FSDataInputStream) in).read(mPos, buffer, offset, length);\n+    int bytesRead;\n+    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+      ((Seekable) in).seek(mPos);\n+      mSequentialReadCount = 0;\n+    }\n+    if (mPos == ((Seekable) in).getPos()) {\n+      // same position, use buffered reads as default\n+      bytesRead = in.read(buffer, offset, length);\n+    } else {\n+      bytesRead = ((PositionedReadable) in).read(mPos, buffer, offset, length);\n+    }\n     if (bytesRead > 0) {\n       mPos += bytesRead;\n+      mSequentialReadCount++;\n     }\n     return bytesRead;\n   }\n \n   @Override\n   public void seek(long position) throws IOException {\n+    if (position < mPos || position - mPos > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(position);\n+    }\n     mPos = position;\n   }\n \n   @Override\n   public long skip(long n) throws IOException {\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    if (n > MOVEMENT_LIMIT) {\n+      mSequentialReadCount = 0;\n+    } else {\n+      ((Seekable) in).seek(mPos + n);", "originalCommit": "b95d021e15f49ed0d6bbcf58f73970f9fcebdbfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwMjA4MA==", "url": "https://github.com/Alluxio/alluxio/pull/11400#discussion_r422702080", "bodyText": "done", "author": "yuzhu", "createdAt": "2020-05-10T21:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY3Nzg1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "657e7024429bee539dde55656432563ba3f24d0b", "chunk": "diff --git a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\nindex cd14811f81..0d4a365f8b 100644\n--- a/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n+++ b/underfs/hdfs/src/main/java/alluxio/underfs/hdfs/HdfsPositionedUnderFileInputStream.java\n\n@@ -87,9 +90,8 @@ public class HdfsPositionedUnderFileInputStream extends SeekableUnderFileInputSt\n   @Override\n   public int read(byte[] buffer, int offset, int length) throws IOException {\n     int bytesRead;\n-    if (mSequentialReadCount >= SEQUENTIAL_READ_LIMIT) {\n+    if (isSequentialReadMode() && mPos != ((Seekable) in).getPos()) {\n       ((Seekable) in).seek(mPos);\n-      mSequentialReadCount = 0;\n     }\n     if (mPos == ((Seekable) in).getPos()) {\n       // same position, use buffered reads as default\n"}}, {"oid": "657e7024429bee539dde55656432563ba3f24d0b", "url": "https://github.com/Alluxio/alluxio/commit/657e7024429bee539dde55656432563ba3f24d0b", "message": "address comments", "committedDate": "2020-05-10T21:16:34Z", "type": "commit"}, {"oid": "77c420d9fa09c244d029a47c1532521e73716eef", "url": "https://github.com/Alluxio/alluxio/commit/77c420d9fa09c244d029a47c1532521e73716eef", "message": "add header", "committedDate": "2020-05-11T00:38:32Z", "type": "commit"}, {"oid": "1a72ecb94a17715b683feed89f8a05eef0f1cbcb", "url": "https://github.com/Alluxio/alluxio/commit/1a72ecb94a17715b683feed89f8a05eef0f1cbcb", "message": "fix license header", "committedDate": "2020-05-11T01:23:54Z", "type": "commit"}]}