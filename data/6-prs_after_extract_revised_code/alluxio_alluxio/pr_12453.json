{"pr_number": 12453, "pr_title": "Improve concurrent read performance through RPC", "pr_createdAt": "2020-11-03T05:55:19Z", "pr_url": "https://github.com/Alluxio/alluxio/pull/12453", "timeline": [{"oid": "74b484b67727b55357893f2e51dd02ffda5ee38a", "url": "https://github.com/Alluxio/alluxio/commit/74b484b67727b55357893f2e51dd02ffda5ee38a", "message": "fix multi-process read perf issue\n\nCo-authored-by: bastrik <rzhang56@illinois.edu>", "committedDate": "2020-11-03T05:52:06Z", "type": "commit"}, {"oid": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "url": "https://github.com/Alluxio/alluxio/commit/990e3df845d5dfaf8b750a899e2dfb825096cf79", "message": "fix multiple process read perf issue, by creating shared grpc data reader\n\nCo-authored-by: bastrik <rzhang56@illinois.edu>", "committedDate": "2020-11-03T05:53:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4Mjg1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517082850", "bodyText": "What's the performance difference (rough numbers are enough) in the following scenario compared to original impl\n\nsingle process Fuse read with NaiveSharedGrpcDataReader\nSingle process Fuse read without NaiveSharedGrpcDataReader\nMultiple (four) processes Fuse read with NaiveSharedGrpcDataReader\nMultiple (four) processes Fuse read without NaiveSharedGrpcDataReader", "author": "LuQQiu", "createdAt": "2020-11-04T03:49:52Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +341,42 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else if (pos < mLength) {\n+      // Try to read data already in queue\n+      long curPos = mPos;\n+      while (mCurrentChunk != null && curPos < pos) {\n+        long nextPos = curPos + mCurrentChunk.readableBytes();\n+        if (nextPos <= pos) {\n+          curPos = nextPos; \n+          mCurrentChunk.release();\n+          mCurrentChunk = mDataReader.readChunkNoWait();\n+        } else {\n+          // TODO introduce seek in DataBuffer\n+          int toRead = (int)(pos - curPos);\n+          final byte[] b = new byte[toRead];\n+          mCurrentChunk.readBytes(b, 0, toRead);\n+          curPos = pos;\n+        }\n+      }\n+\n+      if (curPos < pos) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI2OTIwNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518269204", "bodyText": "Just have some rough number:\n\nSingle process fuse read\nNaivceDataReader -> 11s\nGrpcDataReader -> 18 ~ 20 s\n4 processes\nNaiveDataReader -> 20s\nGrpcDataReader -> 500 ~ 600 s, 1600s in worst case\n\nBy the way, if with code change in BlockInStream.seek + GrpcDataReader, single process perf is 20s, and 4 process read perf is 140 ~ 150s", "author": "chaowangnk1", "createdAt": "2020-11-05T18:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4Mjg1MA=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\nindex 2e652109a4..0f82a9f79d 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n\n@@ -342,7 +344,7 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl\n     if (pos < mPos) {\n       mEOF = false;\n       if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n-        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader) mDataReader;\n         reader.seek(pos);\n         if (mCurrentChunk != null) {\n           mCurrentChunk.release();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4MzgyNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517083824", "bodyText": "Change to NaiveCachedGrpcDataReader then will be easier to debug", "author": "LuQQiu", "createdAt": "2020-11-04T03:54:30Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nindex 1cb4b07375..4fc53eecfd 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n\n@@ -14,7 +14,6 @@ package alluxio.client.block.stream;\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n import alluxio.grpc.ReadResponse;\n import alluxio.grpc.ReadResponseMarshaller;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjczMA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517086730", "bodyText": "Why remove the part for GrpcDataMessagingBlockingStream?", "author": "LuQQiu", "createdAt": "2020-11-04T04:07:59Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";\n+      if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+        desc = MoreObjects.toStringHelper(this)\n+          .add(\"request\", mReadRequest)\n+          .add(\"address\", address)\n+          .toString();\n+      }\n+      mStream = new GrpcBlockingStream<>(mClient.get()::readBlock, mReaderBufferSizeMessages,\n+          desc);\n+      mStream.send(mReadRequest, mDataTimeoutMs);\n+    } catch (Exception e) {\n+      mClient.close();\n+      throw e;\n+    }\n+  }\n+\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+    \n+    try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+      while (index >= mBufferCount) {\n+        DataBuffer buffer = readChunk();\n+        mDataBuffers[mBufferCount] = buffer;\n+        ++mBufferCount;\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  private DataBuffer readChunk() throws IOException {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcwMjM0OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517702348", "bodyText": "GrpcDataMessagingBlockingStream can't be used here.\nDataBuffer.getReadOnlyByteBuffer is used to clone a copy in SharedDataReader.readChunk. getReadOnlyByteBuffer is not implemented in DataBuffer returned from GrpcDataMessagingBlockingStream.", "author": "chaowangnk1", "createdAt": "2020-11-05T00:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA4NjczMA=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nindex 1cb4b07375..4fc53eecfd 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n\n@@ -14,7 +14,6 @@ package alluxio.client.block.stream;\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n import alluxio.grpc.ReadResponse;\n import alluxio.grpc.ReadResponseMarshaller;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU0NjU2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517546567", "bodyText": "if the client's buffer is full?", "author": "LuQQiu", "createdAt": "2020-11-04T18:27:13Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU0NzYyMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517547623", "bodyText": "Will we add a mechanism to limit the available buffer used for the NaiveReader and make the available buffer configurable? Can be done in future PRs.\nKind of worry about the data reader introduces the client-side OOM issue.", "author": "LuQQiu", "createdAt": "2020-11-04T18:29:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU0NjU2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nindex 1cb4b07375..4fc53eecfd 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n\n@@ -14,7 +14,6 @@ package alluxio.client.block.stream;\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n import alluxio.grpc.ReadResponse;\n import alluxio.grpc.ReadResponseMarshaller;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjA4MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517562080", "bodyText": "if index < mBufferCount, no need to lock?", "author": "LuQQiu", "createdAt": "2020-11-04T18:54:32Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";\n+      if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+        desc = MoreObjects.toStringHelper(this)\n+          .add(\"request\", mReadRequest)\n+          .add(\"address\", address)\n+          .toString();\n+      }\n+      mStream = new GrpcBlockingStream<>(mClient.get()::readBlock, mReaderBufferSizeMessages,\n+          desc);\n+      mStream.send(mReadRequest, mDataTimeoutMs);\n+    } catch (Exception e) {\n+      mClient.close();\n+      throw e;\n+    }\n+  }\n+\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+    \n+    try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3MDc0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518270743", "bodyText": "Good point, that could save some runtime", "author": "chaowangnk1", "createdAt": "2020-11-05T18:27:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjA4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nindex 1cb4b07375..4fc53eecfd 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n\n@@ -14,7 +14,6 @@ package alluxio.client.block.stream;\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n import alluxio.grpc.ReadResponse;\n import alluxio.grpc.ReadResponseMarshaller;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3Njg0Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517676842", "bodyText": "isn't this case (pos < mLength) given? since we asserted pos <= mLength and return on pos == mLength", "author": "apc999", "createdAt": "2020-11-04T22:48:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +341,42 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else if (pos < mLength) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI2NTI2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518265266", "bodyText": "'else' part is for (pos == mLength).  CloseDataReader() is mandatory in this case.\nAnd 'return' is on pos == mPos but not pos == mLength.", "author": "chaowangnk1", "createdAt": "2020-11-05T18:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3Njg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNjk2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518306960", "bodyText": "Make sense, changed to else{} directly and remove the original else{} block.", "author": "LuQQiu", "createdAt": "2020-11-05T19:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3Njg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\nindex 2e652109a4..0f82a9f79d 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n\n@@ -342,7 +344,7 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl\n     if (pos < mPos) {\n       mEOF = false;\n       if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n-        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader) mDataReader;\n         reader.seek(pos);\n         if (mCurrentChunk != null) {\n           mCurrentChunk.release();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3NzYwOA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517677608", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              DataBuffer readChunkNoWait() throws IOException;\n          \n          \n            \n              @Nullable\n          \n          \n            \n              DataBuffer readChunkNoWait() throws IOException;", "author": "apc999", "createdAt": "2020-11-04T22:50:14Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java", "diffHunk": "@@ -28,6 +28,13 @@\n    */\n   DataBuffer readChunk() throws IOException;\n \n+  /**\n+   * Try to read a chunk without waiting for data ready. \n+   *\n+   * @return the data buffer or null if EOF is reached or data is not ready.\n+   */\n+  DataBuffer readChunkNoWait() throws IOException;", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzA3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307071", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3NzYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\nindex 4c12b8ec50..ae7d67f8b0 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\n\n@@ -29,11 +31,12 @@ public interface DataReader extends Closeable {\n   DataBuffer readChunk() throws IOException;\n \n   /**\n-   * Try to read a chunk without waiting for data ready. \n+   * Try to read a chunk if the data is ready.\n    *\n-   * @return the data buffer or null if EOF is reached or data is not ready.\n+   * @return the data buffer or null if EOF is reached or data is not ready\n    */\n-  DataBuffer readChunkNoWait() throws IOException;\n+  @Nullable\n+  DataBuffer readChunkIfReady() throws IOException;\n \n   /**\n    * @return the current stream position\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTA4Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517679082", "bodyText": "please complete the javadoc", "author": "apc999", "createdAt": "2020-11-04T22:53:46Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -172,6 +172,15 @@ public ResT receive(long timeoutMs) throws IOException {\n     }\n   }\n \n+  /**\n+   * Check if there are responses in the queue\n+   * @return ", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzE4Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307187", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTA4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java\nindex c6844bfcb2..17b4b8f77f 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java\n\n@@ -173,12 +173,10 @@ public class GrpcBlockingStream<ReqT, ResT> {\n   }\n \n   /**\n-   * Check if there are responses in the queue\n-   * @return \n-   * @throws IOException if any error occurs\n+   * @return true if the current stream has responses received but hasn't processed\n    */\n   public boolean hasResponseInCache() {\n-    return mResponses.size() != 0;\n+    return mResponses.size() > 0;\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTUwMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517679503", "bodyText": "mResponses.size() > 0 ?", "author": "apc999", "createdAt": "2020-11-04T22:54:51Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java", "diffHunk": "@@ -172,6 +172,15 @@ public ResT receive(long timeoutMs) throws IOException {\n     }\n   }\n \n+  /**\n+   * Check if there are responses in the queue\n+   * @return \n+   * @throws IOException if any error occurs\n+   */\n+  public boolean hasResponseInCache() {\n+    return mResponses.size() != 0;", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzMyOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307329", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzY3OTUwMw=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java\nindex c6844bfcb2..17b4b8f77f 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcBlockingStream.java\n\n@@ -173,12 +173,10 @@ public class GrpcBlockingStream<ReqT, ResT> {\n   }\n \n   /**\n-   * Check if there are responses in the queue\n-   * @return \n-   * @throws IOException if any error occurs\n+   * @return true if the current stream has responses received but hasn't processed\n    */\n   public boolean hasResponseInCache() {\n-    return mResponses.size() != 0;\n+    return mResponses.size() > 0;\n   }\n \n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjIxNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517712214", "bodyText": "@Nullable", "author": "apc999", "createdAt": "2020-11-05T00:33:05Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java", "diffHunk": "@@ -161,6 +161,16 @@ public DataBuffer readChunk() throws IOException {\n     return buffer;\n   }\n \n+  @Override\n+  public DataBuffer readChunkNoWait() throws IOException {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwNzYyNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518307624", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:25:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java\nindex f6c2027b39..fbf684ac6c 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/GrpcDataReader.java\n\n@@ -162,7 +162,7 @@ public final class GrpcDataReader implements DataReader {\n   }\n \n   @Override\n-  public DataBuffer readChunkNoWait() throws IOException {\n+  public DataBuffer readChunkIfReady() throws IOException {\n     Preconditions.checkState(!mClient.get().isShutdown(),\n         \"Data reader is closed while reading data chunks.\");\n     if (!mStream.hasResponseInCache()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzAwMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517713003", "bodyText": "let's avoid throwing exceptions in a constructor. If this is required, create a static factory method to create an instance which may throw exceptions rather than having it in constructor. Constructor should be lightweight and no requirement to cover its failure case", "author": "apc999", "createdAt": "2020-11-05T00:35:53Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwODAzMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518308032", "bodyText": "Move the logics to Factory, please take a look", "author": "LuQQiu", "createdAt": "2020-11-05T19:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzAwMw=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nindex 1cb4b07375..4fc53eecfd 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n\n@@ -14,7 +14,6 @@ package alluxio.client.block.stream;\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n import alluxio.grpc.ReadResponse;\n import alluxio.grpc.ReadResponseMarshaller;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzUyNQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517713525", "bodyText": "same comments on constructor vs factory method as NaiveCachedGrpcDataReader.\nSince this is private and only invoked by Factory.create, we should avoid throwing Exceptions here, and you can move the part of code that may throw exception to the factory method", "author": "apc999", "createdAt": "2020-11-05T00:37:37Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwODI0Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518308243", "bodyText": "Moved the logics to Factory, please take a look", "author": "LuQQiu", "createdAt": "2020-11-05T19:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMzUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nindex 94196903b4..36f9d8153a 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n\n@@ -12,85 +12,57 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n-import alluxio.grpc.ReadResponse;\n-import alluxio.grpc.ReadResponseMarshaller;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n-import alluxio.resource.CloseableResource;\n import alluxio.resource.LockResource;\n import alluxio.wire.WorkerNetAddress;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.NotThreadSafe;\n \n /**\n- * A gRPC data reader that streams a region from gRPC data server.\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n  *\n- * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n- * It follows GrpcDataReader protocol.\n- * It takes strong assumption:\n- *    Parallel read to the same file happens on the same time, so that read request is \n- *    serialized by kernel\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n  */\n @NotThreadSafe\n public final class NaiveSharedGrpcDataReader implements DataReader {\n   private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n \n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  // A map from block id to the block's cached data reader\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n   private final NaiveCachedGrpcDataReader mCachedDataReader;\n   private final long mBlockId;\n-\n   private long mChunkSize;\n-  private long mBlockSize;\n-\n   /** The next pos to read. */\n   private long mPosToRead;\n \n-  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n-  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n-\n   /**\n    * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n    *\n-   * @param context the file system context\n-   * @param address the data server address\n    * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n    */\n-  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n-      ReadRequest readRequest) throws IOException {\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n     mChunkSize = readRequest.getChunkSize();\n     mPosToRead = readRequest.getOffset();\n-    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n-    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {\n-      mBlockId = readRequest.getBlockId();\n-      NaiveCachedGrpcDataReader reader = mBlockReaders.get(mBlockId);\n-      if (reader == null) {\n-        // I'm naive, I always read from 0 and read the whole block\n-        ReadRequest cacheRequest = readRequest.toBuilder().setOffset(0).setLength(readRequest.getOffset()+ readRequest.getLength()).build();\n-        reader = new NaiveCachedGrpcDataReader(context, address, cacheRequest);\n-        mBlockReaders.put(mBlockId, reader);\n-      }\n-\n-      reader.ref();\n-      mCachedDataReader = reader;\n-    }\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDAxMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517714011", "bodyText": "@GuardedBy(\"mBlockLocks\")\nis mBlockReaders the only data structure to protect by this lock?", "author": "apc999", "createdAt": "2020-11-05T00:39:22Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3MTI1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518271250", "bodyText": "to q2, yes, it's the only resource protected by this lock", "author": "chaowangnk1", "createdAt": "2020-11-05T18:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwODkzNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518308937", "bodyText": "Added\nYeah, it mainly use for BlockReaders, didn't find other data structures fully protected by this lock", "author": "LuQQiu", "createdAt": "2020-11-05T19:27:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDAxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nindex 94196903b4..36f9d8153a 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n\n@@ -12,85 +12,57 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n-import alluxio.grpc.ReadResponse;\n-import alluxio.grpc.ReadResponseMarshaller;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n-import alluxio.resource.CloseableResource;\n import alluxio.resource.LockResource;\n import alluxio.wire.WorkerNetAddress;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.NotThreadSafe;\n \n /**\n- * A gRPC data reader that streams a region from gRPC data server.\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n  *\n- * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n- * It follows GrpcDataReader protocol.\n- * It takes strong assumption:\n- *    Parallel read to the same file happens on the same time, so that read request is \n- *    serialized by kernel\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n  */\n @NotThreadSafe\n public final class NaiveSharedGrpcDataReader implements DataReader {\n   private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n \n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  // A map from block id to the block's cached data reader\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n   private final NaiveCachedGrpcDataReader mCachedDataReader;\n   private final long mBlockId;\n-\n   private long mChunkSize;\n-  private long mBlockSize;\n-\n   /** The next pos to read. */\n   private long mPosToRead;\n \n-  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n-  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n-\n   /**\n    * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n    *\n-   * @param context the file system context\n-   * @param address the data server address\n    * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n    */\n-  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n-      ReadRequest readRequest) throws IOException {\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n     mChunkSize = readRequest.getChunkSize();\n     mPosToRead = readRequest.getOffset();\n-    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n-    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {\n-      mBlockId = readRequest.getBlockId();\n-      NaiveCachedGrpcDataReader reader = mBlockReaders.get(mBlockId);\n-      if (reader == null) {\n-        // I'm naive, I always read from 0 and read the whole block\n-        ReadRequest cacheRequest = readRequest.toBuilder().setOffset(0).setLength(readRequest.getOffset()+ readRequest.getLength()).build();\n-        reader = new NaiveCachedGrpcDataReader(context, address, cacheRequest);\n-        mBlockReaders.put(mBlockId, reader);\n-      }\n-\n-      reader.ref();\n-      mCachedDataReader = reader;\n-    }\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzI1Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517723256", "bodyText": "can we move this outside of critical session?", "author": "apc999", "createdAt": "2020-11-05T01:10:24Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n+    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {\n+      mBlockId = readRequest.getBlockId();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMwOTAwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518309001", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-05T19:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzI1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nindex 94196903b4..36f9d8153a 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n\n@@ -12,85 +12,57 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n-import alluxio.grpc.ReadResponse;\n-import alluxio.grpc.ReadResponseMarshaller;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n-import alluxio.resource.CloseableResource;\n import alluxio.resource.LockResource;\n import alluxio.wire.WorkerNetAddress;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.NotThreadSafe;\n \n /**\n- * A gRPC data reader that streams a region from gRPC data server.\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n  *\n- * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n- * It follows GrpcDataReader protocol.\n- * It takes strong assumption:\n- *    Parallel read to the same file happens on the same time, so that read request is \n- *    serialized by kernel\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n  */\n @NotThreadSafe\n public final class NaiveSharedGrpcDataReader implements DataReader {\n   private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n \n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  // A map from block id to the block's cached data reader\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n   private final NaiveCachedGrpcDataReader mCachedDataReader;\n   private final long mBlockId;\n-\n   private long mChunkSize;\n-  private long mBlockSize;\n-\n   /** The next pos to read. */\n   private long mPosToRead;\n \n-  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n-  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n-\n   /**\n    * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n    *\n-   * @param context the file system context\n-   * @param address the data server address\n    * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n    */\n-  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n-      ReadRequest readRequest) throws IOException {\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n     mChunkSize = readRequest.getChunkSize();\n     mPosToRead = readRequest.getOffset();\n-    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n-    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {\n-      mBlockId = readRequest.getBlockId();\n-      NaiveCachedGrpcDataReader reader = mBlockReaders.get(mBlockId);\n-      if (reader == null) {\n-        // I'm naive, I always read from 0 and read the whole block\n-        ReadRequest cacheRequest = readRequest.toBuilder().setOffset(0).setLength(readRequest.getOffset()+ readRequest.getLength()).build();\n-        reader = new NaiveCachedGrpcDataReader(context, address, cacheRequest);\n-        mBlockReaders.put(mBlockId, reader);\n-      }\n-\n-      reader.ref();\n-      mCachedDataReader = reader;\n-    }\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzY2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517723666", "bodyText": "I actually think this part of looking up and returning cached reader should go to factory rather than constructor here", "author": "apc999", "createdAt": "2020-11-05T01:11:51Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n+ * It follows GrpcDataReader protocol.\n+ * It takes strong assumption:\n+ *    Parallel read to the same file happens on the same time, so that read request is \n+ *    serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mBlockId;\n+\n+  private long mChunkSize;\n+  private long mBlockSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n+  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n+    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI3NDM2Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518274366", "bodyText": "That's a better option.", "author": "chaowangnk1", "createdAt": "2020-11-05T18:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxMDI0NQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518310245", "bodyText": "Moved", "author": "LuQQiu", "createdAt": "2020-11-05T19:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMzY2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nindex 94196903b4..36f9d8153a 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n\n@@ -12,85 +12,57 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n-import alluxio.grpc.ReadResponse;\n-import alluxio.grpc.ReadResponseMarshaller;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n-import alluxio.resource.CloseableResource;\n import alluxio.resource.LockResource;\n import alluxio.wire.WorkerNetAddress;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.Lock;\n-import java.util.concurrent.locks.ReentrantReadWriteLock;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Preconditions;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n+import javax.annotation.concurrent.GuardedBy;\n import javax.annotation.concurrent.NotThreadSafe;\n \n /**\n- * A gRPC data reader that streams a region from gRPC data server.\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n  *\n- * NaiveSharedGrpcDataReader is a POC to solve multi-process-read perf issue.\n- * It follows GrpcDataReader protocol.\n- * It takes strong assumption:\n- *    Parallel read to the same file happens on the same time, so that read request is \n- *    serialized by kernel\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n  */\n @NotThreadSafe\n public final class NaiveSharedGrpcDataReader implements DataReader {\n   private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n \n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  // A map from block id to the block's cached data reader\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n   private final NaiveCachedGrpcDataReader mCachedDataReader;\n   private final long mBlockId;\n-\n   private long mChunkSize;\n-  private long mBlockSize;\n-\n   /** The next pos to read. */\n   private long mPosToRead;\n \n-  private final static ReentrantReadWriteLock mBlockLocks = new ReentrantReadWriteLock();\n-  private final static Map<Long, NaiveCachedGrpcDataReader> mBlockReaders = new HashMap<>();\n-\n   /**\n    * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n    *\n-   * @param context the file system context\n-   * @param address the data server address\n    * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n    */\n-  private NaiveSharedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n-      ReadRequest readRequest) throws IOException {\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n     mChunkSize = readRequest.getChunkSize();\n     mPosToRead = readRequest.getOffset();\n-    mBlockSize = readRequest.getLength() + readRequest.getOffset();\n-    try (LockResource r1 = new LockResource(mBlockLocks.writeLock())) {\n-      mBlockId = readRequest.getBlockId();\n-      NaiveCachedGrpcDataReader reader = mBlockReaders.get(mBlockId);\n-      if (reader == null) {\n-        // I'm naive, I always read from 0 and read the whole block\n-        ReadRequest cacheRequest = readRequest.toBuilder().setOffset(0).setLength(readRequest.getOffset()+ readRequest.getLength()).build();\n-        reader = new NaiveCachedGrpcDataReader(context, address, cacheRequest);\n-        mBlockReaders.put(mBlockId, reader);\n-      }\n-\n-      reader.ref();\n-      mCachedDataReader = reader;\n-    }\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNDE3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517724171", "bodyText": "Considering Closer?", "author": "apc999", "createdAt": "2020-11-05T01:13:44Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.DataMessage;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import alluxio.resource.LockResource;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that streams a region from gRPC data server.\n+ *\n+ * Protocol:\n+ * 1. The client sends a read request (id, offset, length).\n+ * 2. Once the server receives the request, it streams chunks to the client. The streaming pauses\n+ *    if the server's buffer is full and resumes if the buffer is not full.\n+ * 3. The client reads chunks from the stream using an iterator.\n+ * 4. The client can cancel the read request at anytime. The cancel request is ignored by the\n+ *    server if everything has been sent to channel.\n+ * 5. To make it simple to handle errors, the channel is closed if any error occurs.\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final int mReaderBufferSizeMessages;\n+  private final long mDataTimeoutMs;\n+  private final FileSystemContext mContext;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final ReadRequest mReadRequest;\n+  private final WorkerNetAddress mAddress;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+\n+  private final DataBuffer[] mDataBuffers; \n+  private int mBufferCount = 0;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param context the file system context\n+   * @param address the data server address\n+   * @param readRequest the read request\n+   */\n+  public NaiveCachedGrpcDataReader(FileSystemContext context, WorkerNetAddress address,\n+      ReadRequest readRequest) throws IOException {\n+    mContext = context;\n+    mAddress = address;\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    AlluxioConfiguration alluxioConf = context.getClusterConf();\n+    mReaderBufferSizeMessages = alluxioConf\n+        .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+    mDataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+    mMarshaller = new ReadResponseMarshaller();\n+    mClient = mContext.acquireBlockWorkerClient(address);\n+    long blockSize = readRequest.getLength() + readRequest.getOffset();\n+    long chunkSize = readRequest.getChunkSize();\n+    int buffCount = (int)(blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+\n+    try {\n+      String desc = \"GrpcDataReader\";\n+      if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+        desc = MoreObjects.toStringHelper(this)\n+          .add(\"request\", mReadRequest)\n+          .add(\"address\", address)\n+          .toString();\n+      }\n+      mStream = new GrpcBlockingStream<>(mClient.get()::readBlock, mReaderBufferSizeMessages,\n+          desc);\n+      mStream.send(mReadRequest, mDataTimeoutMs);\n+    } catch (Exception e) {\n+      mClient.close();\n+      throw e;\n+    }\n+  }\n+\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+    \n+    try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+      while (index >= mBufferCount) {\n+        DataBuffer buffer = readChunk();\n+        mDataBuffers[mBufferCount] = buffer;\n+        ++mBufferCount;\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  public void close() throws IOException {\n+    try {\n+      if (mClient.get().isShutdown()) {\n+        return;\n+      }\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    } finally {\n+      mMarshaller.close();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nindex 1cb4b07375..4fc53eecfd 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n\n@@ -14,7 +14,6 @@ package alluxio.client.block.stream;\n import alluxio.client.file.FileSystemContext;\n import alluxio.conf.AlluxioConfiguration;\n import alluxio.conf.PropertyKey;\n-import alluxio.grpc.DataMessage;\n import alluxio.grpc.ReadRequest;\n import alluxio.grpc.ReadResponse;\n import alluxio.grpc.ReadResponseMarshaller;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjQ4MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517726480", "bodyText": "I think this is a redundant case. please check", "author": "apc999", "createdAt": "2020-11-05T01:21:50Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +341,42 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else if (pos < mLength) {\n+      // Try to read data already in queue\n+      long curPos = mPos;\n+      while (mCurrentChunk != null && curPos < pos) {\n+        long nextPos = curPos + mCurrentChunk.readableBytes();\n+        if (nextPos <= pos) {\n+          curPos = nextPos; \n+          mCurrentChunk.release();\n+          mCurrentChunk = mDataReader.readChunkNoWait();\n+        } else {\n+          // TODO introduce seek in DataBuffer\n+          int toRead = (int)(pos - curPos);\n+          final byte[] b = new byte[toRead];\n+          mCurrentChunk.readBytes(b, 0, toRead);\n+          curPos = pos;\n+        }\n+      }\n+\n+      if (curPos < pos) {\n+        // Not enough data in queue, close the data reader\n+        closeDataReader();\n+      }\n+    } else {\n+      closeDataReader();", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNTgyMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518315823", "bodyText": "Removed this block, think it's abundant as well", "author": "LuQQiu", "createdAt": "2020-11-05T19:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\nindex 2e652109a4..0f82a9f79d 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n\n@@ -342,7 +344,7 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl\n     if (pos < mPos) {\n       mEOF = false;\n       if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n-        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader)mDataReader;\n+        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader) mDataReader;\n         reader.seek(pos);\n         if (mCurrentChunk != null) {\n           mCurrentChunk.release();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjY3MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r517726671", "bodyText": "how about naming this method : readChunkIfReady", "author": "apc999", "createdAt": "2020-11-05T01:22:35Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java", "diffHunk": "@@ -28,6 +28,13 @@\n    */\n   DataBuffer readChunk() throws IOException;\n \n+  /**\n+   * Try to read a chunk without waiting for data ready. \n+   *\n+   * @return the data buffer or null if EOF is reached or data is not ready.\n+   */\n+  DataBuffer readChunkNoWait() throws IOException;", "originalCommit": "990e3df845d5dfaf8b750a899e2dfb825096cf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODMxNTk2MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518315961", "bodyText": "Renamed", "author": "LuQQiu", "createdAt": "2020-11-05T19:35:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyNjY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\nindex 4c12b8ec50..ae7d67f8b0 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\n\n@@ -29,11 +31,12 @@ public interface DataReader extends Closeable {\n   DataBuffer readChunk() throws IOException;\n \n   /**\n-   * Try to read a chunk without waiting for data ready. \n+   * Try to read a chunk if the data is ready.\n    *\n-   * @return the data buffer or null if EOF is reached or data is not ready.\n+   * @return the data buffer or null if EOF is reached or data is not ready\n    */\n-  DataBuffer readChunkNoWait() throws IOException;\n+  @Nullable\n+  DataBuffer readChunkIfReady() throws IOException;\n \n   /**\n    * @return the current stream position\n"}}, {"oid": "ccfecf3af7bb034800ea4e112ea598ef886776dc", "url": "https://github.com/Alluxio/alluxio/commit/ccfecf3af7bb034800ea4e112ea598ef886776dc", "message": "Fix the blockSize bug, move logics from constructor to factory and fix codestyle", "committedDate": "2020-11-05T19:13:44Z", "type": "commit"}, {"oid": "ef197c31a6e860e03f7971b0e3a4a6c4968d8e1d", "url": "https://github.com/Alluxio/alluxio/commit/ef197c31a6e860e03f7971b0e3a4a6c4968d8e1d", "message": "Change to closer", "committedDate": "2020-11-05T19:36:15Z", "type": "commit"}, {"oid": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "url": "https://github.com/Alluxio/alluxio/commit/b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "message": "Small fix", "committedDate": "2020-11-05T22:08:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNDExNg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518514116", "bodyText": "Tries to read a chunk if there is data ready. If chunk is not null, the caller needs to release it", "author": "apc999", "createdAt": "2020-11-06T04:16:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java", "diffHunk": "@@ -28,6 +30,14 @@\n    */\n   DataBuffer readChunk() throws IOException;\n \n+  /**\n+   * Try to read a chunk if the data is ready.", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNjIzNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519006237", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-06T21:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNDExNg=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\nindex ae7d67f8b0..fa122d202b 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/DataReader.java\n\n@@ -31,7 +31,8 @@ public interface DataReader extends Closeable {\n   DataBuffer readChunk() throws IOException;\n \n   /**\n-   * Try to read a chunk if the data is ready.\n+   * Tries to read a chunk if there is data ready.\n+   * If the chunk is not null, the caller needs to release it.\n    *\n    * @return the data buffer or null if EOF is reached or data is not ready\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTM3OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518515379", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final DataBuffer[] mDataBuffers;\n          \n          \n            \n              @GuardedBy(\"mBlockLocks\")\n          \n          \n            \n              private final DataBuffer[] mDataBuffers;", "author": "apc999", "createdAt": "2020-11-06T04:22:06Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;\n+  private final DataBuffer[] mDataBuffers;", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODg3NjE4NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518876184", "bodyText": "For mDataBuffers, only the update (write buff) is guarded by the mBufferLocks, all other read operations are not protected.", "author": "LuQQiu", "createdAt": "2020-11-06T16:50:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTM3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nsimilarity index 78%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex f5d4bd6543..712f370f85 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -41,20 +41,15 @@ import javax.annotation.concurrent.NotThreadSafe;\n  *\n  * The current implementation cached the block data from the beginning to\n  * the largest index being read.\n- *\n- * It follows GrpcDataReader protocol and takes strong assumption:\n- * Parallel read to the same file happens on the same time, so that read request is\n- * serialized by kernel\n  */\n @NotThreadSafe\n-public final class NaiveCachedGrpcDataReader {\n-  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n \n   private final WorkerNetAddress mAddress;\n   private final CloseableResource<BlockWorkerClient> mClient;\n   private final long mDataTimeoutMs;\n   private final ReadRequest mReadRequest;\n-\n   private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n   private final ReadResponseMarshaller mMarshaller;\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTY2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518515663", "bodyText": "any reason to use volatile int rather than AtomicInteger?", "author": "apc999", "createdAt": "2020-11-06T04:23:26Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkwMjgyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518902821", "bodyText": "Volatile and AtomicInteger don't make a difference here.  AtomicInteger internally uses volatile for the integer value. AtomicInteger mainly improved for setting values. in our case, we only increase the value under a write lock.", "author": "LuQQiu", "createdAt": "2020-11-06T17:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNjA5OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519006098", "bodyText": "Changed the volatile to AtomicInteger", "author": "LuQQiu", "createdAt": "2020-11-06T21:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNTY2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nsimilarity index 78%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex f5d4bd6543..712f370f85 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -41,20 +41,15 @@ import javax.annotation.concurrent.NotThreadSafe;\n  *\n  * The current implementation cached the block data from the beginning to\n  * the largest index being read.\n- *\n- * It follows GrpcDataReader protocol and takes strong assumption:\n- * Parallel read to the same file happens on the same time, so that read request is\n- * serialized by kernel\n  */\n @NotThreadSafe\n-public final class NaiveCachedGrpcDataReader {\n-  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n \n   private final WorkerNetAddress mAddress;\n   private final CloseableResource<BlockWorkerClient> mClient;\n   private final long mDataTimeoutMs;\n   private final ReadRequest mReadRequest;\n-\n   private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n   private final ReadResponseMarshaller mMarshaller;\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNjM2OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518516368", "bodyText": "any reason to have this registration here rather than in constructor or factory method?", "author": "apc999", "createdAt": "2020-11-06T04:26:20Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param closer the closer\n+   * @param dataBuffers the data buffers to cache block data in chunk\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private NaiveCachedGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, Closer closer, DataBuffer[] dataBuffers,\n+      long dataTimeoutMs, ReadRequest readRequest,\n+      GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mCloser = closer;\n+    mDataBuffers = dataBuffers;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount] = buffer;\n+          ++mBufferCount;\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link NaiveCachedGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNTc5Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519005797", "bodyText": "Moved to the constructor, thanks!", "author": "LuQQiu", "createdAt": "2020-11-06T21:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxNjM2OA=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nsimilarity index 78%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex f5d4bd6543..712f370f85 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -41,20 +41,15 @@ import javax.annotation.concurrent.NotThreadSafe;\n  *\n  * The current implementation cached the block data from the beginning to\n  * the largest index being read.\n- *\n- * It follows GrpcDataReader protocol and takes strong assumption:\n- * Parallel read to the same file happens on the same time, so that read request is\n- * serialized by kernel\n  */\n @NotThreadSafe\n-public final class NaiveCachedGrpcDataReader {\n-  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n \n   private final WorkerNetAddress mAddress;\n   private final CloseableResource<BlockWorkerClient> mClient;\n   private final long mDataTimeoutMs;\n   private final ReadRequest mReadRequest;\n-\n   private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n   private final ReadResponseMarshaller mMarshaller;\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxOTE0Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518519142", "bodyText": "Nit: I would prefer to put the creation of closer and dataBuffers inside the constructor rather than in factory method here. It is easier to reason the ownership of these data structures in that way. In contrast, the creation of stream , client is not guaranteed to succeed with exception possibly thrown, thus why we should leave it in factory method and pass them to constructor as param on successful creation.\nAs long as the constructor is ensured to complete, we should be good.", "author": "apc999", "createdAt": "2020-11-06T04:38:12Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private volatile int mBufferCount = 0;\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveCachedGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param closer the closer\n+   * @param dataBuffers the data buffers to cache block data in chunk\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private NaiveCachedGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, Closer closer, DataBuffer[] dataBuffers,\n+      long dataTimeoutMs, ReadRequest readRequest,\n+      GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mCloser = closer;\n+    mDataBuffers = dataBuffers;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount] = buffer;\n+          ++mBufferCount;\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link NaiveCachedGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+    mCloser.close();\n+  }\n+\n+  /**\n+   * Increases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int ref() {\n+    return mRefCount.incrementAndGet();\n+  }\n+\n+  /**\n+   * Decreases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int deRef() {\n+    return mRefCount.decrementAndGet();\n+  }\n+\n+  /**\n+   * @return the current count\n+   */\n+  public int getRefCount() {\n+    return mRefCount.get();\n+  }\n+\n+  /**\n+   * Factory class to create {@link NaiveCachedGrpcDataReader}s.\n+   */\n+  public static class Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequest;\n+\n+    /**\n+     * Creates an instance of {@link NaiveCachedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequest the read request\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequest) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequest = readRequest;\n+    }\n+\n+    /**\n+     * @return a new {@link NaiveCachedGrpcDataReader}\n+     */\n+    public NaiveCachedGrpcDataReader create() throws IOException {\n+      AlluxioConfiguration alluxioConf = mContext.getClusterConf();\n+      int readerBufferSizeMessages = alluxioConf\n+          .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+      long dataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+\n+      Closer closer = Closer.create();\n+      CloseableResource<BlockWorkerClient> client = mContext.acquireBlockWorkerClient(mAddress);\n+      closer.register(client);\n+\n+      long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+      long chunkSize = mReadRequest.getChunkSize();\n+      int buffCount = (int) (blockSize / chunkSize);\n+      if ((blockSize % chunkSize) != 0) {\n+        buffCount += 1;\n+      }\n+      DataBuffer[] dataBuffers = new DataBuffer[buffCount];", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNTYzNQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519005635", "bodyText": "Make sense. Moved the closer and DataBuffer[] related logics back to the constructor. The Closer in the constructor is better to show the ownership.", "author": "LuQQiu", "createdAt": "2020-11-06T21:07:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUxOTE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nsimilarity index 78%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex f5d4bd6543..712f370f85 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -41,20 +41,15 @@ import javax.annotation.concurrent.NotThreadSafe;\n  *\n  * The current implementation cached the block data from the beginning to\n  * the largest index being read.\n- *\n- * It follows GrpcDataReader protocol and takes strong assumption:\n- * Parallel read to the same file happens on the same time, so that read request is\n- * serialized by kernel\n  */\n @NotThreadSafe\n-public final class NaiveCachedGrpcDataReader {\n-  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n \n   private final WorkerNetAddress mAddress;\n   private final CloseableResource<BlockWorkerClient> mClient;\n   private final long mDataTimeoutMs;\n   private final ReadRequest mReadRequest;\n-\n   private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n   private final ReadResponseMarshaller mMarshaller;\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDA4NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518520084", "bodyText": "I would call this BufferCachingGrpcDataReader\nmy personal preference: do not to use final when defining a class  unless you are very sure no one should extend it\nBetter to extend DataReader unless there is particular reason", "author": "apc999", "createdAt": "2020-11-06T04:42:21Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk1NDg2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518954860", "bodyText": "Because the methods are different.\nDataReader's methods\n  DataBuffer readChunk() throws IOException;\n  DataBuffer readChunkIfReady() throws IOException;\n  long pos();\n\nare not related to bufferCachingGrpcDataReader. bufferCachingGrpcDataReader doesn't have pos concept and it's readChunk() is private. The main publicly available method is readChunk(index) to read a specific chunk from this block.", "author": "LuQQiu", "createdAt": "2020-11-06T19:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDA4NA=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nsimilarity index 78%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex f5d4bd6543..712f370f85 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -41,20 +41,15 @@ import javax.annotation.concurrent.NotThreadSafe;\n  *\n  * The current implementation cached the block data from the beginning to\n  * the largest index being read.\n- *\n- * It follows GrpcDataReader protocol and takes strong assumption:\n- * Parallel read to the same file happens on the same time, so that read request is\n- * serialized by kernel\n  */\n @NotThreadSafe\n-public final class NaiveCachedGrpcDataReader {\n-  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n \n   private final WorkerNetAddress mAddress;\n   private final CloseableResource<BlockWorkerClient> mClient;\n   private final long mDataTimeoutMs;\n   private final ReadRequest mReadRequest;\n-\n   private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n   private final ReadResponseMarshaller mMarshaller;\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDQxNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518520417", "bodyText": "nit: unnecessary empty line", "author": "apc999", "createdAt": "2020-11-06T04:44:05Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveCachedGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNTA2OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519005069", "bodyText": "Removed", "author": "LuQQiu", "createdAt": "2020-11-06T21:06:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMDQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nsimilarity index 78%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex f5d4bd6543..712f370f85 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveCachedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -41,20 +41,15 @@ import javax.annotation.concurrent.NotThreadSafe;\n  *\n  * The current implementation cached the block data from the beginning to\n  * the largest index being read.\n- *\n- * It follows GrpcDataReader protocol and takes strong assumption:\n- * Parallel read to the same file happens on the same time, so that read request is\n- * serialized by kernel\n  */\n @NotThreadSafe\n-public final class NaiveCachedGrpcDataReader {\n-  private static final Logger LOG = LoggerFactory.getLogger(NaiveCachedGrpcDataReader.class);\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n \n   private final WorkerNetAddress mAddress;\n   private final CloseableResource<BlockWorkerClient> mClient;\n   private final long mDataTimeoutMs;\n   private final ReadRequest mReadRequest;\n-\n   private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n   private final ReadResponseMarshaller mMarshaller;\n   /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMTY1NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518521654", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change", "author": "apc999", "createdAt": "2020-11-06T04:49:22Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNDg2NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519004864", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-06T21:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyMTY1NA=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nsimilarity index 71%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex c5b3aff137..f381af660b 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,18 +12,21 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyOTczMA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518529730", "bodyText": "new NaiveCachedGrpcDataReader.Factory(mContext, mAddress, cacheRequest).create(); has RPCs inside and thus can take a long time. It is not a good idea to have a global lock here around a RPC. In case network connection is not working properly and there is some timing out triggered, this global lock will pause all new block reads for entire client across user processes.\nhow about instead of single global lock, create an array of locks, and lock the one in lock array based on block Id:\ntry (LockResource lockResource = \n    new LockResource(BLOCK_LOCKS[blockId % BLOCK_LOCKS.length].writeLock())) {\n  reader = BLOCK_READERS.computeIfAbsent(blockId, \n      blockId -> new NaiveCachedGrpcDataReader(...));\n  reader.ref();\n}", "author": "apc999", "createdAt": "2020-11-06T05:23:12Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n+  private final long mBlockId;\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {\n+      try (LockResource lockResource = new LockResource(BLOCK_LOCK.writeLock())) {\n+        if (mCachedDataReader.getRefCount() == 0) {\n+          mCachedDataReader.close();\n+          BLOCK_READERS.remove(mBlockId);\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Factory class to create {@link NaiveSharedGrpcDataReader}s.\n+   */\n+  public static class Factory implements DataReader.Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequestPartial;\n+    private final long mBlockSize;\n+\n+    /**\n+     * Creates an instance of {@link NaiveSharedGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequestPartial the partial read request\n+     * @param blockSize the block size\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequestPartial, long blockSize) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequestPartial = readRequestPartial;\n+      mBlockSize = blockSize;\n+    }\n+\n+    @Override\n+    public DataReader create(long offset, long len) throws IOException {\n+      long blockId = mReadRequestPartial.getBlockId();\n+      NaiveCachedGrpcDataReader reader;\n+      try (LockResource lockResource = new LockResource(BLOCK_LOCK.writeLock())) {\n+        reader = BLOCK_READERS.get(blockId);\n+        if (reader == null) {\n+          // I'm naive, I always read from 0 and read the whole block\n+          ReadRequest cacheRequest = mReadRequestPartial\n+              .toBuilder().setOffset(0).setLength(mBlockSize).build();\n+          reader = new NaiveCachedGrpcDataReader\n+              .Factory(mContext, mAddress, cacheRequest).create();\n+          BLOCK_READERS.put(blockId, reader);\n+        }\n+\n+        reader.ref();\n+      }", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwNDcwMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519004702", "bodyText": "Changed to use an array of locks\ntry (LockResource lockResource = new LockResource(\n          BLOCK_LOCKS[(int) (mBlockId % BLOCK_LOCKS.length)].writeLock())) {\n\nand changed the readers hashmap to ConcurrentHashMap.\ni didn't change to use computeIfAbsent because the BufferCachingGrpcDataReader creation will throw IOException which the compute function cannot process well.", "author": "LuQQiu", "createdAt": "2020-11-06T21:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyOTczMA=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nsimilarity index 71%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex c5b3aff137..f381af660b 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,18 +12,21 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzMzg3NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518533874", "bodyText": "Regarding lock , Check my next comment on lock striping first.  AgainmCachedDataReader.close() may take a long time, we should not put this inside a critical session by a global lock.\nAfter lock striping, we can remove reader from the BLOCK_READERS map if its refcount reaches 0, but calling  mCachedDataReader.close() outside the lock to further make sure operations inside the lock is minimal.", "author": "apc999", "createdAt": "2020-11-06T05:39:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(NaiveSharedGrpcDataReader.class);\n+\n+  private static final ReentrantReadWriteLock BLOCK_LOCK = new ReentrantReadWriteLock();\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"mBlockLocks\")\n+  private static final Map<Long, NaiveCachedGrpcDataReader> BLOCK_READERS = new HashMap<>();\n+\n+  private final long mBlockId;\n+  private final NaiveCachedGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link NaiveSharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private NaiveSharedGrpcDataReader(ReadRequest readRequest, NaiveCachedGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {\n+      try (LockResource lockResource = new LockResource(BLOCK_LOCK.writeLock())) {\n+        if (mCachedDataReader.getRefCount() == 0) {\n+          mCachedDataReader.close();\n+          BLOCK_READERS.remove(mBlockId);\n+        }\n+      }", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk2MzU2Nw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518963567", "bodyText": "Changed to\n      try (LockResource lockResource = new LockResource(\n          BLOCK_LOCKS[(int) (mBlockId % BLOCK_LOCKS.length)].writeLock())) {\n        if (mCachedDataReader.getRefCount() == 0) {\n          BLOCK_READERS.remove(mBlockId);\n        }\n      }\n      if (mCachedDataReader.getRefCount() == 0) {\n        mCachedDataReader.close();\n      }\n\nI think it should be thread-safe,\n\nThread B deRef() == 0\nThread A ref++\nThread B get the write lock and doesn't remove blockId from readers map\nThread A deRef() == 0\nThread B close the dataReader\nThread A remove blockId from readers map and close the dataReader again.\n\n\n\nThread B deRef() == 0\nThread A ref++\nThread B get the write lock and doesn't remove blockId from readers map\nThread B doesn't close the dataReader\nThread A remove blockId from readers map and close the dataReader.\n\nboth scenarios are safe", "author": "LuQQiu", "createdAt": "2020-11-06T19:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzMzg3NA=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nsimilarity index 71%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex c5b3aff137..f381af660b 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,18 +12,21 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDY0MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518534641", "bodyText": "currently this is not specific to fuse. we can either make it only works on fuse (e.g., check process type), or rename the flag to make it usable in general.\nFUSE_SHARED_GRPC_DATA_READER_ENABLED", "author": "apc999", "createdAt": "2020-11-06T05:42:23Z", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -5551,6 +5560,8 @@ private static String javadocLink(String fullyQualifiedClassname) {\n     public static final String FUSE_DEBUG_ENABLED = \"alluxio.fuse.debug.enabled\";\n     public static final String FUSE_FS_NAME = \"alluxio.fuse.fs.name\";\n     public static final String FUSE_JNIFUSE_ENABLED = \"alluxio.fuse.jnifuse.enabled\";\n+    public static final String FUSE_SHARED_GRPC_DATA_READER", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk1MDE5OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518950198", "bodyText": "I think it's specific to FUSE use case, not sure if it's able to work on other cases.\nThe bufferCachingDataReader is more general, but the SharedDataReader can be only used for fuse since it is based on the assumption\n * It follows GrpcDataReader protocol and takes strong assumption:\n * Parallel read to the same file happens on the same time, so that read request is\n * serialized by kernel\n\nit relies on one thread do seek() and then readChunk()  and then the other thread do seek() -> readChunk()s.", "author": "LuQQiu", "createdAt": "2020-11-06T19:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMzI2MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519003260", "bodyText": "Maybe we can change the current name SharedDataReader to FuseSharedDataReader to be more clear?", "author": "LuQQiu", "createdAt": "2020-11-06T21:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/common/src/main/java/alluxio/conf/PropertyKey.java b/core/common/src/main/java/alluxio/conf/PropertyKey.java\nindex c02bcbd484..dd620dbba7 100755\n--- a/core/common/src/main/java/alluxio/conf/PropertyKey.java\n+++ b/core/common/src/main/java/alluxio/conf/PropertyKey.java\n\n@@ -5560,8 +5571,10 @@ public final class PropertyKey implements Comparable<PropertyKey> {\n     public static final String FUSE_DEBUG_ENABLED = \"alluxio.fuse.debug.enabled\";\n     public static final String FUSE_FS_NAME = \"alluxio.fuse.fs.name\";\n     public static final String FUSE_JNIFUSE_ENABLED = \"alluxio.fuse.jnifuse.enabled\";\n-    public static final String FUSE_SHARED_GRPC_DATA_READER\n-        = \"alluxio.fuse.shared.grpcdatareader.enabled\";\n+    public static final String FUSE_SHARED_CACHING_READER_ENABLED\n+        = \"alluxio.fuse.shared.caching.reader.enabled\";\n+    public static final String FUSE_SHARED_CACHING_READER_LOCKS\n+        = \"alluxio.fuse.shared.caching.reader.locks\";\n     public static final String FUSE_LOGGING_THRESHOLD = \"alluxio.fuse.logging.threshold\";\n     public static final String FUSE_MAXWRITE_BYTES = \"alluxio.fuse.maxwrite.bytes\";\n     public static final String FUSE_MAXCACHE_BYTES = \"alluxio.fuse.maxcache.bytes\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDk2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518534963", "bodyText": "I would simply call this class SharedGrpcDataReader", "author": "apc999", "createdAt": "2020-11-06T05:43:42Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public final class NaiveSharedGrpcDataReader implements DataReader {", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjc5NQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519002795", "bodyText": "Changed to SharedGrpcDataReader", "author": "LuQQiu", "createdAt": "2020-11-06T21:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNDk2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nsimilarity index 71%\nrename from core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\nrename to core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex c5b3aff137..f381af660b 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/NaiveSharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,18 +12,21 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n-import java.util.HashMap;\n-import java.util.Map;\n import java.io.IOException;\n import java.nio.ByteBuffer;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNTg0NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518535844", "bodyText": "can we also guard the newly added logic under flag FUSE_SHARED_GRPC_DATA_READER ?\nif (flag is off) {\n  if (pos < mPos) {\n    mEOF = false;\n  }\n  closeDataReader();\n  mPos = pos;\n  return;\n}\n// here starts the new logic", "author": "apc999", "createdAt": "2020-11-06T05:47:00Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +343,39 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mDataReader instanceof NaiveSharedGrpcDataReader) {", "originalCommit": "b913c5eaf7f3f9e4f3cb2248654a42abcae15968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODk0ODIxMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r518948212", "bodyText": "The try to read data already received but haven't processed logic works for both flag is off and on.  Will change the instanceof to a flag check.", "author": "LuQQiu", "createdAt": "2020-11-06T19:05:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNTg0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAwMjU4Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519002586", "bodyText": "Changed to if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {", "author": "LuQQiu", "createdAt": "2020-11-06T21:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNTg0NA=="}], "type": "inlineReview", "revised_code": {"commit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\nindex 0f82a9f79d..b1f225cf11 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n\n@@ -343,8 +343,8 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl\n     }\n     if (pos < mPos) {\n       mEOF = false;\n-      if (mDataReader instanceof NaiveSharedGrpcDataReader) {\n-        NaiveSharedGrpcDataReader reader = (NaiveSharedGrpcDataReader) mDataReader;\n+      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {\n+        SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n         reader.seek(pos);\n         if (mCurrentChunk != null) {\n           mCurrentChunk.release();\n"}}, {"oid": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "url": "https://github.com/Alluxio/alluxio/commit/fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "message": "Change to multi locks and remove close out of lock", "committedDate": "2020-11-06T19:56:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMjM0Ng==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519032346", "bodyText": "@LuQQiu this else branch is still not guarded and will still be accessible even the flag is off, right?", "author": "apc999", "createdAt": "2020-11-06T22:15:40Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +343,39 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {\n+        SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n+        reader.seek(pos);\n+        if (mCurrentChunk != null) {\n+          mCurrentChunk.release();\n+          mCurrentChunk = null;\n+        }\n+      } else {\n+        closeDataReader();\n+      }\n+    } else {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NzMwOQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519057309", "bodyText": "Yeah, the change can be applied to all cases, not only related to sharedDataReader.\nDo we want to be safe and put it under the flag for now and maybe add a TODO(lu) to move it not guarded in the future?", "author": "LuQQiu", "createdAt": "2020-11-06T23:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMjM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA5NzYwNg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519097606", "bodyText": "yes let's put all the new logic in BlockInStream protected by the flag and leave a TODO.\nThanks", "author": "apc999", "createdAt": "2020-11-07T04:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzMjM0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "3da28c4213483a46fc2ea22644156f9ebedaff02", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\nindex b1f225cf11..05afb32b06 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n\n@@ -343,7 +343,7 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl\n     }\n     if (pos < mPos) {\n       mEOF = false;\n-      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {\n+      if (mDataReader instanceof SharedGrpcDataReader) {\n         SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n         reader.seek(pos);\n         if (mCurrentChunk != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNDM1MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519034350", "bodyText": "nit: unnecessary empty lines at line 88 and 95. The code base should be compact for readability in general.", "author": "apc999", "createdAt": "2020-11-06T22:21:45Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MzUzNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073534", "bodyText": "Removed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNDM1MA=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNTYyMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519035622", "bodyText": "@Nullable", "author": "apc999", "createdAt": "2020-11-06T22:25:25Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MzkwNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073907", "bodyText": "Done", "author": "LuQQiu", "createdAt": "2020-11-07T01:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzNTYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODE5MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519038190", "bodyText": "a few questions on reclaiming resources:\n\nif mClient is closed, do we still need to close mStream, and vise versa\nwhat should be the order to close mStream and mClient?", "author": "apc999", "createdAt": "2020-11-06T22:33:19Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MzU3MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519063570", "bodyText": "I guess the original way\n  @Override\n  public void close() throws IOException {\n    try {\n      if (mClient.get().isShutdown()) {\n        return;\n      }\n      mStream.close();\n      mStream.waitForComplete(mDataTimeoutMs);\n    } finally {\n      mMarshaller.close();\n      mClient.close();\n    }\n  }\n\nis used instead of the closer to guarantee the close sequence. The mStream is always close before mClient. So if mClient is shutdown, we know that stream is closed as well.\nin that case, may be better to keep the original way of closing items.", "author": "LuQQiu", "createdAt": "2020-11-07T00:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3MzMyOA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073328", "bodyText": "Changed back to the original close way to guarantee the order", "author": "LuQQiu", "createdAt": "2020-11-07T01:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODE5MA=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODk1MQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519038951", "bodyText": "marking @Nullablewhenever it is possible. IDE will help a lot to warn null check in invokers.", "author": "apc999", "createdAt": "2020-11-06T22:35:31Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3Mzk1OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519073959", "bodyText": "Added, thanks! Will remember adding Nullable", "author": "LuQQiu", "createdAt": "2020-11-07T01:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzODk1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzOTUxNw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519039517", "bodyText": "The following code equivalent but slightly more readable.\nTypically return on failure/error cases earlier is easier to read and reason the control flow\nif (response == null) {\n  return null;\n}\nPreconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n      \"response should always contain chunk\");\nByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\nbuffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());", "author": "apc999", "createdAt": "2020-11-06T22:37:10Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDAyMA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074020", "bodyText": "Changed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTAzOTUxNw=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MDc1NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519040754", "bodyText": "return refcount incremented? kinda confusing to say the current count.", "author": "apc999", "createdAt": "2020-11-06T22:40:53Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link BufferCachingGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.close();\n+  }\n+\n+  /**\n+   * Increases the reference count and return the current count.\n+   *\n+   * @return the current count", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDAzMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074033", "bodyText": "Changed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MDc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MTEzNA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519041134", "bodyText": "final.\nmark member variables final whenever possible.", "author": "apc999", "createdAt": "2020-11-06T22:41:58Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDE1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074152", "bodyText": "Marked, thanks!", "author": "LuQQiu", "createdAt": "2020-11-07T01:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA0MTEzNA=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDMyMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519050321", "bodyText": "do we need to close stream here too?", "author": "apc999", "createdAt": "2020-11-06T23:13:55Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();\n+    mPosToRead = readRequest.getOffset();\n+    mReadRequest = readRequest;\n+    mStream = stream;\n+\n+    mCloser = Closer.create();\n+    mCloser.register(mClient);\n+    mCloser.register(() -> {\n+      mStream.close();\n+      mStream.waitForComplete(mDataTimeoutMs);\n+    });\n+\n+    long blockSize = mReadRequest.getLength() + mReadRequest.getOffset();\n+    long chunkSize = mReadRequest.getChunkSize();\n+    int buffCount = (int) (blockSize / chunkSize);\n+    if ((blockSize % chunkSize) != 0) {\n+      buffCount += 1;\n+    }\n+    mDataBuffers = new DataBuffer[buffCount];\n+  }\n+\n+  /**\n+   * Reads a specific chunk from the block.\n+   *\n+   * @param index the chunk index\n+   * @return the chunk data if exists\n+   */\n+  public DataBuffer readChunk(int index) throws IOException {\n+    if (index >= mDataBuffers.length) {\n+      return null;\n+    }\n+\n+    if (index >= mBufferCount.get()) {\n+      try (LockResource r1 = new LockResource(mBufferLocks.writeLock())) {\n+        while (index >= mBufferCount.get()) {\n+          DataBuffer buffer = readChunk();\n+          mDataBuffers[mBufferCount.get()] = buffer;\n+          mBufferCount.incrementAndGet();\n+        }\n+      }\n+    }\n+\n+    return mDataBuffers[index];\n+  }\n+\n+  /**\n+   * Reads a chunk of data.\n+   *\n+   * @return a chunk of data\n+   */\n+  private DataBuffer readChunk() throws IOException {\n+    Preconditions.checkState(!mClient.get().isShutdown(),\n+        \"Data reader is closed while reading data chunks.\");\n+    DataBuffer buffer = null;\n+    ReadResponse response = null;\n+    response = mStream.receive(mDataTimeoutMs);\n+    if (response != null) {\n+      Preconditions.checkState(response.hasChunk() && response.getChunk().hasData(),\n+          \"response should always contain chunk\");\n+\n+      ByteBuffer byteBuffer = response.getChunk().getData().asReadOnlyByteBuffer();\n+      buffer = new NioDataBuffer(byteBuffer, byteBuffer.remaining());\n+    } else {\n+      return null;\n+    }\n+    mPosToRead += buffer.readableBytes();\n+    try {\n+      mStream.send(mReadRequest.toBuilder().setOffsetReceived(mPosToRead).build());\n+    } catch (Exception e) {\n+      // nothing is done as the receipt is sent at best effort\n+      LOG.debug(\"Failed to send receipt of data to worker {} for request {}: {}.\", mAddress,\n+          mReadRequest, e.getMessage());\n+    }\n+    Preconditions.checkState(mPosToRead - mReadRequest.getOffset() <= mReadRequest.getLength());\n+    return buffer;\n+  }\n+\n+  /**\n+   * Closes the {@link BufferCachingGrpcDataReader}.\n+   */\n+  public void close() throws IOException {\n+    if (mClient.get().isShutdown()) {\n+      return;\n+    }\n+    mCloser.close();\n+  }\n+\n+  /**\n+   * Increases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int ref() {\n+    return mRefCount.incrementAndGet();\n+  }\n+\n+  /**\n+   * Decreases the reference count and return the current count.\n+   *\n+   * @return the current count\n+   */\n+  public int deRef() {\n+    return mRefCount.decrementAndGet();\n+  }\n+\n+  /**\n+   * @return the current count\n+   */\n+  public int getRefCount() {\n+    return mRefCount.get();\n+  }\n+\n+  /**\n+   * Factory class to create {@link BufferCachingGrpcDataReader}s.\n+   */\n+  public static class Factory {\n+    private final FileSystemContext mContext;\n+    private final WorkerNetAddress mAddress;\n+    private final ReadRequest mReadRequest;\n+\n+    /**\n+     * Creates an instance of {@link BufferCachingGrpcDataReader.Factory} for block reads.\n+     *\n+     * @param context the file system context\n+     * @param address the worker address\n+     * @param readRequest the read request\n+     */\n+    public Factory(FileSystemContext context, WorkerNetAddress address,\n+        ReadRequest readRequest) {\n+      mContext = context;\n+      mAddress = address;\n+      mReadRequest = readRequest;\n+    }\n+\n+    /**\n+     * @return a new {@link BufferCachingGrpcDataReader}\n+     */\n+    public BufferCachingGrpcDataReader create() throws IOException {\n+      AlluxioConfiguration alluxioConf = mContext.getClusterConf();\n+      int readerBufferSizeMessages = alluxioConf\n+          .getInt(PropertyKey.USER_STREAMING_READER_BUFFER_SIZE_MESSAGES);\n+      long dataTimeoutMs = alluxioConf.getMs(PropertyKey.USER_STREAMING_DATA_TIMEOUT);\n+\n+      CloseableResource<BlockWorkerClient> client = mContext.acquireBlockWorkerClient(mAddress);\n+\n+      GrpcBlockingStream<ReadRequest, ReadResponse> stream;\n+      try {\n+        String desc = \"BufferCachingGrpcDataReader\";\n+        if (LOG.isDebugEnabled()) { // More detailed description when debug logging is enabled\n+          desc = MoreObjects.toStringHelper(this)\n+              .add(\"request\", mReadRequest)\n+              .add(\"address\", mAddress)\n+              .toString();\n+        }\n+        // Stream here cannot be GrpcDataMessagingBlockingStream\n+        // DataBuffer.getReadOnlyByteBuffer is used to clone a copy in SharedDataReader.readChunk.\n+        // getReadOnlyByteBuffer is not implemented in DataBuffer\n+        // returned from GrpcDataMessagingBlockingStream.\n+        stream = new GrpcBlockingStream<>(client.get()::readBlock, readerBufferSizeMessages,\n+            desc);\n+        stream.send(mReadRequest, dataTimeoutMs);\n+      } catch (Exception e) {\n+        client.close();", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDIxMg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074212", "bodyText": "Add the stream close here,\nI am little worry about when creating the stream, errors thrown, but i guess can still do the close() since it checks isOpen first.", "author": "LuQQiu", "createdAt": "2020-11-07T01:08:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MDMyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MTM5OA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519051398", "bodyText": "I don't think we need another flag FUSE_SHARED_CACHING_READER_LOCKS on this.\nPicking a constant number like 32 is good enough to ensure ~32 concurrent readers.\nIn general, we should be very conservative in adding new configuration flags.\nUnless we're very sure users will tune it.", "author": "apc999", "createdAt": "2020-11-06T23:18:00Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    int lockNum = conf.getInt(PropertyKey.FUSE_SHARED_CACHING_READER_LOCKS);", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDUwMQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074501", "bodyText": "Yeah, it may not be helpful and necessary to add it as a property, removed", "author": "LuQQiu", "createdAt": "2020-11-07T01:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MTM5OA=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex f381af660b..75ec47a683 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,14 +12,10 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.InstancedConfiguration;\n-import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n-import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjI2NA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519052264", "bodyText": "let's make a static util method to return the corresponding lock in the lock array based on block Id.\ne.g.,\nprivate static ReentrantReadWriteLock getBlockLock(long blockId) {\n  return BLOCK_LOCKS[(int) (blockId % BLOCK_LOCKS.length)]\n}\n\nThen in both close and create, let's all use the util method rather than hardcode the same logic twice.\nIn case we change the logic in the future, we only need to go one place", "author": "apc999", "createdAt": "2020-11-06T23:21:31Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    int lockNum = conf.getInt(PropertyKey.FUSE_SHARED_CACHING_READER_LOCKS);\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[lockNum];\n+    for (int i = 0; i < lockNum; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {\n+      try (LockResource lockResource = new LockResource(\n+          BLOCK_LOCKS[(int) (mBlockId % BLOCK_LOCKS.length)].writeLock())) {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDc4OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074789", "bodyText": "Changed, thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:11:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1MjI2NA=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex f381af660b..75ec47a683 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,14 +12,10 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.InstancedConfiguration;\n-import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n-import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NTY1Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519055652", "bodyText": "readability suggestion:\nif (mCachedDataReader.deRef() > 0) {\n  return;\n}\n...", "author": "apc999", "createdAt": "2020-11-06T23:34:50Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.wire.WorkerNetAddress;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A shared gRPC data reader that cache blocks data for multi-thread accessing.\n+ *\n+ * It follows GrpcDataReader protocol and takes strong assumption:\n+ * Parallel read to the same file happens on the same time, so that read request is\n+ * serialized by kernel\n+ */\n+@NotThreadSafe\n+public class SharedGrpcDataReader implements DataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(SharedGrpcDataReader.class);\n+  private static final ReentrantReadWriteLock[] BLOCK_LOCKS;\n+  /** A map from block id to the block's cached data reader. */\n+  @GuardedBy(\"BLOCK_LOCKS\")\n+  private static final ConcurrentHashMap<Long, BufferCachingGrpcDataReader> BLOCK_READERS\n+      = new ConcurrentHashMap<>();\n+\n+  static {\n+    AlluxioConfiguration conf = new InstancedConfiguration(ConfigurationUtils.defaults());\n+    int lockNum = conf.getInt(PropertyKey.FUSE_SHARED_CACHING_READER_LOCKS);\n+    BLOCK_LOCKS = new ReentrantReadWriteLock[lockNum];\n+    for (int i = 0; i < lockNum; i++) {\n+      BLOCK_LOCKS[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  private final long mBlockId;\n+  private final BufferCachingGrpcDataReader mCachedDataReader;\n+  private final long mChunkSize;\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link SharedGrpcDataReader}.\n+   *\n+   * @param readRequest the read request\n+   * @param reader the cached Grpc data reader for the given block\n+   */\n+  private SharedGrpcDataReader(ReadRequest readRequest, BufferCachingGrpcDataReader reader) {\n+    mChunkSize = readRequest.getChunkSize();\n+    mPosToRead = readRequest.getOffset();\n+    mBlockId = readRequest.getBlockId();\n+    mCachedDataReader = reader;\n+  }\n+\n+  @Override\n+  public long pos() {\n+    return mPosToRead;\n+  }\n+\n+  /**\n+   * Seeks to a specific position.\n+   *\n+   * @param pos the position to seek to\n+   */\n+  public void seek(long pos) {\n+    mPosToRead = pos;\n+  }\n+\n+  @Override\n+  public DataBuffer readChunk() throws IOException {\n+    int index = (int) (mPosToRead / mChunkSize);\n+    DataBuffer chunk = mCachedDataReader.readChunk(index);\n+    if (chunk == null) {\n+      return null;\n+    }\n+    ByteBuffer bb = chunk.getReadOnlyByteBuffer();\n+    // Force to align to chunk size\n+    bb.position((int) (mPosToRead % mChunkSize));\n+    mPosToRead += mChunkSize - mPosToRead % mChunkSize;\n+\n+    return new NioDataBuffer(bb, bb.remaining());\n+  }\n+\n+  @Override\n+  public DataBuffer readChunkIfReady() throws IOException {\n+    // I'm naive, I'm reading chunks anyway\n+    return readChunk();\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    if (mCachedDataReader.deRef() == 0) {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NDgxMw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519074813", "bodyText": "Done thanks", "author": "LuQQiu", "createdAt": "2020-11-07T01:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1NTY1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\nindex f381af660b..75ec47a683 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/SharedGrpcDataReader.java\n\n@@ -12,14 +12,10 @@\n package alluxio.client.block.stream;\n \n import alluxio.client.file.FileSystemContext;\n-import alluxio.conf.AlluxioConfiguration;\n-import alluxio.conf.InstancedConfiguration;\n-import alluxio.conf.PropertyKey;\n import alluxio.grpc.ReadRequest;\n import alluxio.network.protocol.databuffer.DataBuffer;\n import alluxio.network.protocol.databuffer.NioDataBuffer;\n import alluxio.resource.LockResource;\n-import alluxio.util.ConfigurationUtils;\n import alluxio.wire.WorkerNetAddress;\n \n import org.slf4j.Logger;\n"}}, {"oid": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "url": "https://github.com/Alluxio/alluxio/commit/1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "message": "Better close", "committedDate": "2020-11-07T00:43:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1OTc3MA==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519059770", "bodyText": "This check is not complete. Even the config is true, usual GrpcDataReader will still be used if block size is <= 4 * chunksize.\nWould recommend to keep the logic of checking class of the instance. The logic inner if block is only applicable to cached data reader.", "author": "chaowangnk1", "createdAt": "2020-11-06T23:52:29Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java", "diffHunk": "@@ -337,8 +343,39 @@ public void seek(long pos) throws IOException {\n     }\n     if (pos < mPos) {\n       mEOF = false;\n+      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NjM0OQ==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519076349", "bodyText": "Oh good catch!! Will change back to instanceof", "author": "LuQQiu", "createdAt": "2020-11-07T01:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA1OTc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "3da28c4213483a46fc2ea22644156f9ebedaff02", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\nindex b1f225cf11..05afb32b06 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BlockInStream.java\n\n@@ -343,7 +343,7 @@ public class BlockInStream extends InputStream implements BoundedStream, Seekabl\n     }\n     if (pos < mPos) {\n       mEOF = false;\n-      if (mContext.getClusterConf().getBoolean(PropertyKey.FUSE_SHARED_CACHING_READER_ENABLED)) {\n+      if (mDataReader instanceof SharedGrpcDataReader) {\n         SharedGrpcDataReader reader = (SharedGrpcDataReader) mDataReader;\n         reader.seek(pos);\n         if (mCurrentChunk != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjM2Mg==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519062362", "bodyText": "mMarshaller could be removed since it's not used in this class.", "author": "chaowangnk1", "createdAt": "2020-11-07T00:03:31Z", "path": "core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.block.stream;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.grpc.ReadRequest;\n+import alluxio.grpc.ReadResponse;\n+import alluxio.grpc.ReadResponseMarshaller;\n+import alluxio.network.protocol.databuffer.DataBuffer;\n+import alluxio.network.protocol.databuffer.NioDataBuffer;\n+import alluxio.resource.CloseableResource;\n+import alluxio.wire.WorkerNetAddress;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Preconditions;\n+import com.google.common.io.Closer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A gRPC data reader that responsible for reading from a specific block.\n+ *\n+ * The current implementation cached the block data from the beginning to\n+ * the largest index being read.\n+ */\n+@NotThreadSafe\n+public class BufferCachingGrpcDataReader {\n+  private static final Logger LOG = LoggerFactory.getLogger(BufferCachingGrpcDataReader.class);\n+\n+  private final WorkerNetAddress mAddress;\n+  private final CloseableResource<BlockWorkerClient> mClient;\n+  private final long mDataTimeoutMs;\n+  private final ReadRequest mReadRequest;\n+  private final GrpcBlockingStream<ReadRequest, ReadResponse> mStream;\n+  private final ReadResponseMarshaller mMarshaller;\n+  /**\n+   * Count the number of threads that are accessing the same block together.\n+   * When no thread is accessing this block, the cached data will be GCed.\n+   */\n+  private final AtomicInteger mRefCount = new AtomicInteger(0);\n+  private final Closer mCloser;\n+\n+  private AtomicInteger mBufferCount = new AtomicInteger(0);\n+  private final DataBuffer[] mDataBuffers;\n+  private final ReentrantReadWriteLock mBufferLocks = new ReentrantReadWriteLock();\n+\n+  /** The next pos to read. */\n+  private long mPosToRead;\n+\n+  /**\n+   * Creates an instance of {@link BufferCachingGrpcDataReader}.\n+   *\n+   * @param address the data server address\n+   * @param client the block worker client to read data from\n+   * @param dataTimeoutMs the maximum time to wait for a data response\n+   * @param readRequest the read request\n+   * @param stream the underlying gRPC stream to read data\n+   */\n+  private BufferCachingGrpcDataReader(WorkerNetAddress address,\n+      CloseableResource<BlockWorkerClient> client, long dataTimeoutMs,\n+      ReadRequest readRequest, GrpcBlockingStream<ReadRequest, ReadResponse> stream) {\n+    mAddress = address;\n+    mClient = client;\n+    mDataTimeoutMs = dataTimeoutMs;\n+    mMarshaller = new ReadResponseMarshaller();", "originalCommit": "fd4eb6d7ee37e0df48c67ecfdfc5b0eda2476852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA3NjQ2Mw==", "url": "https://github.com/Alluxio/alluxio/pull/12453#discussion_r519076463", "bodyText": "Changed, thanks!", "author": "LuQQiu", "createdAt": "2020-11-07T01:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTA2MjM2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1dbdd5cbac7591a08106e9a012a9fd26ac104ec6", "chunk": "diff --git a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\nindex 712f370f85..9da7761368 100644\n--- a/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n+++ b/core/client/fs/src/main/java/alluxio/client/block/stream/BufferCachingGrpcDataReader.java\n\n@@ -25,7 +25,6 @@ import alluxio.resource.LockResource;\n \n import com.google.common.base.MoreObjects;\n import com.google.common.base.Preconditions;\n-import com.google.common.io.Closer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"oid": "3da28c4213483a46fc2ea22644156f9ebedaff02", "url": "https://github.com/Alluxio/alluxio/commit/3da28c4213483a46fc2ea22644156f9ebedaff02", "message": "Fix BlockInStream.seek and remove mMarshaller", "committedDate": "2020-11-07T01:23:54Z", "type": "commit"}, {"oid": "eced1440c8c6cd0d3ae19952e80460c02930b953", "url": "https://github.com/Alluxio/alluxio/commit/eced1440c8c6cd0d3ae19952e80460c02930b953", "message": "Isolate BlockInStream seek fuse logic", "committedDate": "2020-11-08T00:18:04Z", "type": "commit"}]}