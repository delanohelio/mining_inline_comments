{"pr_number": 1830, "pr_title": "Feature: Task resiliency from QueueDAO failures", "pr_createdAt": "2020-08-17T11:04:02Z", "pr_url": "https://github.com/Netflix/conductor/pull/1830", "timeline": [{"oid": "38bd48c5a60f8f30899ec72dba1b6a7968f6b598", "url": "https://github.com/Netflix/conductor/commit/38bd48c5a60f8f30899ec72dba1b6a7968f6b598", "message": "[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\n[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\n[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\n[WIP] Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nClean up.\n\nClean up.", "committedDate": "2020-08-17T11:15:48Z", "type": "forcePushed"}, {"oid": "6410e9167f9e1ed7e7af757bf0215bc10afc1b77", "url": "https://github.com/Netflix/conductor/commit/6410e9167f9e1ed7e7af757bf0215bc10afc1b77", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.", "committedDate": "2020-09-11T01:54:34Z", "type": "forcePushed"}, {"oid": "114a91d6d1608693e7011275f987a29c4b08a33f", "url": "https://github.com/Netflix/conductor/commit/114a91d6d1608693e7011275f987a29c4b08a33f", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.", "committedDate": "2020-09-11T07:41:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzMjU0Mg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r487232542", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (task.getStatus().equals(Task.Status.SCHEDULED)) {\n          \n          \n            \n                    if (task.getStatus() == Task.Status.SCHEDULED)) {\n          \n      \n    \n    \n  \n\nEnums can be compared using the operator and it also helps avoiding a NullPointerException", "author": "aravindanr", "createdAt": "2020-09-11T19:00:26Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.common.run.Workflow;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.tasks.WorkflowSystemTask;\n+import com.netflix.conductor.dao.ExecutionDAO;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A helper service that tries to keep ExecutionDAO and QueueDAO in sync, based on the\n+ * task or workflow state.\n+ *\n+ * This service expects that the underlying Queueing layer implements QueueDAO.containsMessage method. This can be controlled\n+ * with Configuration.isWorkflowRepairServiceEnabled() property.\n+ */\n+public class WorkflowRepairService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(WorkflowRepairService.class);\n+\n+    private final ExecutionDAO executionDAO;\n+    private final QueueDAO queueDAO;\n+    private final Configuration configuration;\n+\n+    private final Predicate<Task> isSystemTask = task -> WorkflowSystemTask.is(task.getTaskType());\n+\n+    @Inject\n+    public WorkflowRepairService(\n+            ExecutionDAO executionDAO,\n+            QueueDAO queueDAO,\n+            Configuration configuration\n+    ) {\n+        this.executionDAO = executionDAO;\n+        this.queueDAO = queueDAO;\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Verify and repair if the workflowId exists in deciderQueue, and then if each scheduled task has relevant message\n+     * in the queue.\n+     * @param workflowId\n+     * @param includeTasks\n+     * @return\n+     */\n+    public boolean verifyAndRepairWorkflow(String workflowId, boolean includeTasks) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, includeTasks);\n+        AtomicBoolean repaired = new AtomicBoolean(false);\n+        repaired.set(verifyAndRepairDeciderQueue(workflow));\n+        if (includeTasks) {\n+            workflow.getTasks().forEach(task -> {\n+                repaired.set(verifyAndRepairTask(task));\n+            });\n+        }\n+        return repaired.get();\n+    }\n+\n+    /**\n+     * Verify and repair tasks in a workflow\n+     * @param workflowId\n+     */\n+    public void verifyAndRepairWorkflowTasks(String workflowId) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, true);\n+        workflow.getTasks().forEach(task -> verifyAndRepairTask(task));\n+    }\n+\n+    /**\n+     * Verify and fix if Workflow decider queue contains this workflowId.\n+     * @param workflow\n+     * @return\n+     */\n+    private boolean verifyAndRepairDeciderQueue(Workflow workflow) {\n+        if (!workflow.getStatus().isTerminal()) {\n+            String queueName = WorkflowExecutor.DECIDER_QUEUE;\n+            if (!queueDAO.containsMessage(queueName, workflow.getWorkflowId())) {\n+                queueDAO.push(queueName, workflow.getWorkflowId(), configuration.getSweepFrequency());\n+                Monitors.recordQueueMessageRepushFromRepairService(queueName);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Verify if ExecutionDAO and QueueDAO agree for the provided task.\n+     * @param task\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean verifyAndRepairTask(Task task) {\n+        WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n+        if (task.getStatus().equals(Task.Status.SCHEDULED)) {", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\nindex 8c292cc2..96b4dff0 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n\n@@ -1,3 +1,15 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n package com.netflix.conductor.core.execution;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyMzQ0MA==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488323440", "bodyText": "Please add license header.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:13:15Z", "path": "common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.netflix.conductor.common.constraints;", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java b/common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java\ndeleted file mode 100644\nindex 48f9ec3c..00000000\n--- a/common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java\n+++ /dev/null\n\n@@ -1,14 +0,0 @@\n-package com.netflix.conductor.common.constraints;\n-\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-/**\n- * Interceptor intended for failure injection during unit / integration testing.\n- */\n-@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD)\n-public @interface FaultInjectionInterceptor {\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNDMwNg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488324306", "bodyText": "This should probably be added to the core module.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:16:27Z", "path": "common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package com.netflix.conductor.common.constraints;\n+\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Interceptor intended for failure injection during unit / integration testing.\n+ */\n+@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD)\n+public @interface FaultInjectionInterceptor {", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java b/common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java\ndeleted file mode 100644\nindex 48f9ec3c..00000000\n--- a/common/src/main/java/com/netflix/conductor/common/constraints/FaultInjectionInterceptor.java\n+++ /dev/null\n\n@@ -1,14 +0,0 @@\n-package com.netflix.conductor.common.constraints;\n-\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-/**\n- * Interceptor intended for failure injection during unit / integration testing.\n- */\n-@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD)\n-public @interface FaultInjectionInterceptor {\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTAxMg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488325012", "bodyText": "tasks should be removed from queue before status is updated, else tasks to be CANCELED will be polled and processed by the workers.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:19:06Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -785,6 +782,11 @@ public void terminateWorkflow(Workflow workflow, String reason, String failureWo\n             if (workflow.getWorkflowDefinition().isWorkflowStatusListenerEnabled()) {\n                 workflowStatusListener.onWorkflowTerminated(workflow);\n             }\n+\n+            //remove from the sweep queue", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b9a18d1fb6da47188af6a2d5449c01e6565bbf28", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 47399c51..950dff72 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n\n@@ -782,11 +791,6 @@ public class WorkflowExecutor {\n             if (workflow.getWorkflowDefinition().isWorkflowStatusListenerEnabled()) {\n                 workflowStatusListener.onWorkflowTerminated(workflow);\n             }\n-\n-            //remove from the sweep queue\n-            queueDAO.remove(DECIDER_QUEUE, workflow.getWorkflowId());\n-            // Remove from the task queue if they were there\n-            tasks.forEach(task -> queueDAO.remove(QueueUtils.getQueueName(task), task.getTaskId()));\n         } finally {\n             executionLockService.releaseLock(workflow.getWorkflowId());\n             executionLockService.deleteLock(workflow.getWorkflowId());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTc0NQ==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488325745", "bodyText": "Does this also account for partial failures?", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:21:36Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -1447,6 +1446,19 @@ boolean scheduleTask(Workflow workflow, List<Task> tasks) {\n             // rollbackTasks(workflow.getWorkflowId(), createdTasks);\n             throw new TerminateWorkflowException(errorMsg);\n         }\n+\n+        // On addTaskToQueue failures, ignore the exceptions and let WorkflowRepairService take care of republishing the messages to the queue.", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTczOQ==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r489081739", "bodyText": "Yes. Partial failures when adding to queue are fine. For eg., if only 2 of 5 messages are added to the queue and the rest failed, the sweeper service would still check if the queue contains each message as long as the task is in scheduled state, and this can be recovered.", "author": "kishorebanala", "createdAt": "2020-09-15T23:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTc0NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNTc5Nw==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488325797", "bodyText": "Please add license header", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:21:47Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\nindex 8c292cc2..96b4dff0 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n\n@@ -1,3 +1,15 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n package com.netflix.conductor.core.execution;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyNjAxNg==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488326016", "bodyText": "It would be better to link out to the method from the javadoc.", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:22:39Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.common.run.Workflow;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.tasks.WorkflowSystemTask;\n+import com.netflix.conductor.dao.ExecutionDAO;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A helper service that tries to keep ExecutionDAO and QueueDAO in sync, based on the\n+ * task or workflow state.\n+ *\n+ * This service expects that the underlying Queueing layer implements QueueDAO.containsMessage method. This can be controlled\n+ * with Configuration.isWorkflowRepairServiceEnabled() property.", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\nindex 8c292cc2..96b4dff0 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n\n@@ -1,3 +1,15 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n package com.netflix.conductor.core.execution;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODA4OA==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488328088", "bodyText": "For system tasks, the tasks are enqueued in the task type queues and not by the task def name, does this line need to change?", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:29:31Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.netflix.conductor.core.execution;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.netflix.conductor.common.metadata.tasks.Task;\n+import com.netflix.conductor.common.run.Workflow;\n+import com.netflix.conductor.core.config.Configuration;\n+import com.netflix.conductor.core.execution.tasks.WorkflowSystemTask;\n+import com.netflix.conductor.dao.ExecutionDAO;\n+import com.netflix.conductor.dao.QueueDAO;\n+import com.netflix.conductor.metrics.Monitors;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.inject.Inject;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A helper service that tries to keep ExecutionDAO and QueueDAO in sync, based on the\n+ * task or workflow state.\n+ *\n+ * This service expects that the underlying Queueing layer implements QueueDAO.containsMessage method. This can be controlled\n+ * with Configuration.isWorkflowRepairServiceEnabled() property.\n+ */\n+public class WorkflowRepairService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(WorkflowRepairService.class);\n+\n+    private final ExecutionDAO executionDAO;\n+    private final QueueDAO queueDAO;\n+    private final Configuration configuration;\n+\n+    private final Predicate<Task> isSystemTask = task -> WorkflowSystemTask.is(task.getTaskType());\n+\n+    @Inject\n+    public WorkflowRepairService(\n+            ExecutionDAO executionDAO,\n+            QueueDAO queueDAO,\n+            Configuration configuration\n+    ) {\n+        this.executionDAO = executionDAO;\n+        this.queueDAO = queueDAO;\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Verify and repair if the workflowId exists in deciderQueue, and then if each scheduled task has relevant message\n+     * in the queue.\n+     * @param workflowId\n+     * @param includeTasks\n+     * @return\n+     */\n+    public boolean verifyAndRepairWorkflow(String workflowId, boolean includeTasks) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, includeTasks);\n+        AtomicBoolean repaired = new AtomicBoolean(false);\n+        repaired.set(verifyAndRepairDeciderQueue(workflow));\n+        if (includeTasks) {\n+            workflow.getTasks().forEach(task -> {\n+                repaired.set(verifyAndRepairTask(task));\n+            });\n+        }\n+        return repaired.get();\n+    }\n+\n+    /**\n+     * Verify and repair tasks in a workflow\n+     * @param workflowId\n+     */\n+    public void verifyAndRepairWorkflowTasks(String workflowId) {\n+        Workflow workflow = executionDAO.getWorkflow(workflowId, true);\n+        workflow.getTasks().forEach(task -> verifyAndRepairTask(task));\n+    }\n+\n+    /**\n+     * Verify and fix if Workflow decider queue contains this workflowId.\n+     * @param workflow\n+     * @return\n+     */\n+    private boolean verifyAndRepairDeciderQueue(Workflow workflow) {\n+        if (!workflow.getStatus().isTerminal()) {\n+            String queueName = WorkflowExecutor.DECIDER_QUEUE;\n+            if (!queueDAO.containsMessage(queueName, workflow.getWorkflowId())) {\n+                queueDAO.push(queueName, workflow.getWorkflowId(), configuration.getSweepFrequency());\n+                Monitors.recordQueueMessageRepushFromRepairService(queueName);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Verify if ExecutionDAO and QueueDAO agree for the provided task.\n+     * @param task\n+     * @return\n+     */\n+    @VisibleForTesting\n+    protected boolean verifyAndRepairTask(Task task) {\n+        WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n+        if (task.getStatus().equals(Task.Status.SCHEDULED)) {\n+            if (isSystemTask.test(task) && !workflowSystemTask.isAsync()) {\n+                return false;\n+            }\n+            // Ensure QueueDAO contains this taskId\n+            if (!queueDAO.containsMessage(task.getTaskDefName(), task.getTaskId())) {", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\nindex 8c292cc2..96b4dff0 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowRepairService.java\n\n@@ -1,3 +1,15 @@\n+/*\n+ * Copyright 2020 Netflix, Inc.\n+ * <p>\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n package com.netflix.conductor.core.execution;\n \n import com.google.common.annotations.VisibleForTesting;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMyODUyNQ==", "url": "https://github.com/Netflix/conductor/pull/1830#discussion_r488328525", "bodyText": "Since this annotation and the interceptor are used only for testing, can this abstracted out from the execution path. Maybe through some combination of Spy and Mock?", "author": "apanicker-nflx", "createdAt": "2020-09-15T01:31:02Z", "path": "redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/RedisExecutionDAO.java", "diffHunk": "@@ -115,6 +116,7 @@ public RedisExecutionDAO(DynoProxy dynoClient, ObjectMapper objectMapper, Config\n \t\treturn tasks;\n \t}\n \n+\t@FaultInjectionInterceptor", "originalCommit": "114a91d6d1608693e7011275f987a29c4b08a33f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff7514d7f08995e2205a85270523de8a6dce42d2", "chunk": "diff --git a/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/RedisExecutionDAO.java b/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/RedisExecutionDAO.java\nindex 10c31e2b..1962bd39 100644\n--- a/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/RedisExecutionDAO.java\n+++ b/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/RedisExecutionDAO.java\n\n@@ -116,7 +115,6 @@ public class RedisExecutionDAO extends BaseDynoDAO implements ExecutionDAO {\n \t\treturn tasks;\n \t}\n \n-\t@FaultInjectionInterceptor\n \t@Override\n \tpublic List<Task> createTasks(List<Task> tasks) {\n \n"}}, {"oid": "b9a18d1fb6da47188af6a2d5449c01e6565bbf28", "url": "https://github.com/Netflix/conductor/commit/b9a18d1fb6da47188af6a2d5449c01e6565bbf28", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.", "committedDate": "2020-09-15T23:45:42Z", "type": "forcePushed"}, {"oid": "ff7514d7f08995e2205a85270523de8a6dce42d2", "url": "https://github.com/Netflix/conductor/commit/ff7514d7f08995e2205a85270523de8a6dce42d2", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.\n\nReplaced AOP based QueueDAO failure tests with Spock Spy's", "committedDate": "2020-09-18T01:05:06Z", "type": "forcePushed"}, {"oid": "d51db575022710c24e1cfb406f9d3544b7b3dccc", "url": "https://github.com/Netflix/conductor/commit/d51db575022710c24e1cfb406f9d3544b7b3dccc", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.\n\nReplaced AOP based QueueDAO failure tests with Spock Spy's", "committedDate": "2020-09-18T01:21:14Z", "type": "commit"}, {"oid": "d51db575022710c24e1cfb406f9d3544b7b3dccc", "url": "https://github.com/Netflix/conductor/commit/d51db575022710c24e1cfb406f9d3544b7b3dccc", "message": "Support for task resiliency on persistence features, and tests to verify the same using AOP based failure injection.\n\nAdded the configuration to control WorkflowRepairService from the sweeper service.\n\nReplaced AOP based QueueDAO failure tests with Spock Spy's", "committedDate": "2020-09-18T01:21:14Z", "type": "forcePushed"}]}