{"pr_number": 1728, "pr_title": "LocalOnly sharding strategy for dyno queues", "pr_createdAt": "2020-06-05T08:59:14Z", "pr_url": "https://github.com/Netflix/conductor/pull/1728", "timeline": [{"oid": "a40b042cecec528909497dbd2e2e64b1486039df", "url": "https://github.com/Netflix/conductor/commit/a40b042cecec528909497dbd2e2e64b1486039df", "message": "Introduce LocalOnly locking provider\n\nThis implementation provides sufficient locking for a single\nnode deployment.\n\nImplemented inside JVM only (locks are not persisted).\n\nCan be used in a cluster deployment but only when localOnly sharding\nstrategy is used for dyno queues.\n\nSigned-off-by: Maros Marsalek <mmarsalek@frinx.io>", "committedDate": "2020-06-09T12:54:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyNDU5OA==", "url": "https://github.com/Netflix/conductor/pull/1728#discussion_r440524598", "bodyText": "Nit: Please use the latest copyright.", "author": "kishorebanala", "createdAt": "2020-06-16T00:50:53Z", "path": "core/src/main/java/com/netflix/conductor/core/utils/LocalOnlyLock.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright (c) 2019 Netflix, Inc.", "originalCommit": "a40b042cecec528909497dbd2e2e64b1486039df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcwMzQ3OQ==", "url": "https://github.com/Netflix/conductor/pull/1728#discussion_r440703479", "bodyText": "Used the latest 2020 copyright header I found", "author": "marosmars", "createdAt": "2020-06-16T09:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUyNDU5OA=="}], "type": "inlineReview", "revised_code": {"commit": "71f86fef47cdab180ea5ec8d96df496a569dea81", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/utils/LocalOnlyLock.java b/core/src/main/java/com/netflix/conductor/core/utils/LocalOnlyLock.java\ndeleted file mode 100644\nindex fc579ef6..00000000\n--- a/core/src/main/java/com/netflix/conductor/core/utils/LocalOnlyLock.java\n+++ /dev/null\n\n@@ -1,97 +0,0 @@\n-/*\n- * Copyright (c) 2019 Netflix, Inc.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package com.netflix.conductor.core.utils;\n-\n-import com.google.common.cache.CacheBuilder;\n-import com.google.common.cache.CacheLoader;\n-import com.google.common.cache.LoadingCache;\n-import com.netflix.servo.util.VisibleForTesting;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeUnit;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class LocalOnlyLock implements Lock {\n-\n-    private static final Logger logger = LoggerFactory.getLogger(LocalOnlyLock.class);\n-\n-    private static final CacheLoader<String, Semaphore> LOADER = new CacheLoader<String, Semaphore>() {\n-        @Override\n-        public Semaphore load(String key) {\n-            return new Semaphore(1, true);\n-        }\n-    };\n-    private static final LoadingCache<String, Semaphore> CACHE = CacheBuilder.newBuilder().build(LOADER);\n-    private static final ThreadGroup THREAD_GROUP = new ThreadGroup(\"LocalOnlyLock-scheduler\");\n-    private static final ThreadFactory THREAD_FACTORY = runnable -> new Thread(THREAD_GROUP, runnable);\n-    private static final ScheduledExecutorService SCHEDULER = Executors.newScheduledThreadPool(1, THREAD_FACTORY);\n-\n-    @Override\n-    public void acquireLock(String lockId) {\n-        logger.trace(\"Locking {}\", lockId);\n-        CACHE.getUnchecked(lockId).acquireUninterruptibly();\n-    }\n-\n-    @Override\n-    public boolean acquireLock(String lockId, long timeToTry, TimeUnit unit) {\n-        try {\n-            logger.trace(\"Locking {} with timeout {} {}\", lockId, timeToTry, unit);\n-            return CACHE.getUnchecked(lockId).tryAcquire(timeToTry, unit);\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    @Override\n-    public boolean acquireLock(String lockId, long timeToTry, long leaseTime, TimeUnit unit) {\n-        logger.trace(\"Locking {} with timeout {} {} for {} {}\", lockId, timeToTry, unit, leaseTime, unit);\n-        if (acquireLock(lockId, timeToTry, unit)) {\n-            logger.trace(\"Releasing {} automatically after {} {}\", lockId, leaseTime, unit);\n-            SCHEDULER.schedule(() -> releaseLock(lockId), leaseTime, unit);\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    @Override\n-    public void releaseLock(String lockId) {\n-        // Synchronized to prevent race condition between semaphore check and actual release\n-        // The check is here to prevent semaphore getting above 1\n-        // e.g. in case when lease runs out but release is also called\n-        synchronized (CACHE) {\n-            if (CACHE.getUnchecked(lockId).availablePermits() == 0) {\n-                logger.trace(\"Releasing {}\", lockId);\n-                CACHE.getUnchecked(lockId).release();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void deleteLock(String lockId) {\n-        logger.trace(\"Deleting {}\", lockId);\n-        CACHE.invalidate(lockId);\n-    }\n-\n-    @VisibleForTesting\n-    LoadingCache<String, Semaphore> cache() {\n-        return CACHE;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMDk4Mw==", "url": "https://github.com/Netflix/conductor/pull/1728#discussion_r440530983", "bodyText": "Unused imports?", "author": "kishorebanala", "createdAt": "2020-06-16T01:14:41Z", "path": "redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/queue/DynoQueueDAO.java", "diffHunk": "@@ -24,6 +24,8 @@\n import com.netflix.dyno.queues.ShardSupplier;\n import com.netflix.dyno.queues.redis.RedisDynoQueue;\n import com.netflix.dyno.queues.redis.RedisQueues;\n+import com.netflix.dyno.queues.redis.sharding.RoundRobinStrategy;", "originalCommit": "a40b042cecec528909497dbd2e2e64b1486039df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcwMzUwNg==", "url": "https://github.com/Netflix/conductor/pull/1728#discussion_r440703506", "bodyText": "Done", "author": "marosmars", "createdAt": "2020-06-16T09:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMDk4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "2308ba92dc5b7a979353ae94c5395df72c7fb98f", "chunk": "diff --git a/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/queue/DynoQueueDAO.java b/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/queue/DynoQueueDAO.java\nindex f4b34939..74af6afd 100644\n--- a/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/queue/DynoQueueDAO.java\n+++ b/redis-persistence/src/main/java/com/netflix/conductor/dao/dynomite/queue/DynoQueueDAO.java\n\n@@ -24,14 +24,11 @@ import com.netflix.dyno.queues.Message;\n import com.netflix.dyno.queues.ShardSupplier;\n import com.netflix.dyno.queues.redis.RedisDynoQueue;\n import com.netflix.dyno.queues.redis.RedisQueues;\n-import com.netflix.dyno.queues.redis.sharding.RoundRobinStrategy;\n-import com.netflix.dyno.queues.redis.sharding.ShardingStrategy;\n import com.netflix.dyno.queues.shard.DynoShardSupplier;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n import java.util.concurrent.TimeUnit;\n import java.util.stream.Collectors;\n import javax.inject.Inject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMjE4NQ==", "url": "https://github.com/Netflix/conductor/pull/1728#discussion_r440532185", "bodyText": "Nit: Please use the latest copyright.", "author": "kishorebanala", "createdAt": "2020-06-16T01:19:15Z", "path": "redis-persistence/src/main/java/com/netflix/conductor/dyno/RedisQueuesShardingStrategyProvider.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2016 Netflix, Inc.", "originalCommit": "a40b042cecec528909497dbd2e2e64b1486039df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDcwMzUzMg==", "url": "https://github.com/Netflix/conductor/pull/1728#discussion_r440703532", "bodyText": "Used the latest 2020 copyright header I found", "author": "marosmars", "createdAt": "2020-06-16T09:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDUzMjE4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "71f86fef47cdab180ea5ec8d96df496a569dea81", "chunk": "diff --git a/redis-persistence/src/main/java/com/netflix/conductor/dyno/RedisQueuesShardingStrategyProvider.java b/redis-persistence/src/main/java/com/netflix/conductor/dyno/RedisQueuesShardingStrategyProvider.java\nindex d6643602..5e1ec458 100644\n--- a/redis-persistence/src/main/java/com/netflix/conductor/dyno/RedisQueuesShardingStrategyProvider.java\n+++ b/redis-persistence/src/main/java/com/netflix/conductor/dyno/RedisQueuesShardingStrategyProvider.java\n\n@@ -56,7 +56,7 @@ public class RedisQueuesShardingStrategyProvider implements Provider<ShardingStr\n         }\n     }\n \n-    static final class LocalOnlyStrategy implements ShardingStrategy {\n+    private static final class LocalOnlyStrategy implements ShardingStrategy {\n         private static final Logger logger = LoggerFactory.getLogger(RedisQueuesShardingStrategyProvider.class);\n \n         private final ShardSupplier shardSupplier;\n"}}, {"oid": "71f86fef47cdab180ea5ec8d96df496a569dea81", "url": "https://github.com/Netflix/conductor/commit/71f86fef47cdab180ea5ec8d96df496a569dea81", "message": "LocalOnly sharding strategy for dyno queues\n\nAllow no distribution of workload in dyno queues.\nBy default tasks are distributed across all conductor instances using\ndyno queue shards.\nNow it is possible to only queue workfload for conductor-server that\nstarted the workflow.\n\nMore in docs.", "committedDate": "2020-06-16T08:46:17Z", "type": "commit"}, {"oid": "1b184888dac090d40963eb1d7332c897c79b1403", "url": "https://github.com/Netflix/conductor/commit/1b184888dac090d40963eb1d7332c897c79b1403", "message": "Add unit test for sharding strategy provider\n\nSigned-off-by: Maros Marsalek <mmarsalek@frinx.io>", "committedDate": "2020-06-16T08:46:17Z", "type": "commit"}, {"oid": "e93ef8a1a2d84d793eb92593376511049bed5dcf", "url": "https://github.com/Netflix/conductor/commit/e93ef8a1a2d84d793eb92593376511049bed5dcf", "message": "Introduce LocalOnly locking provider\n\nThis implementation provides sufficient locking for a single\nnode deployment.\n\nImplemented inside JVM only (locks are not persisted).\n\nCan be used in a cluster deployment but only when localOnly sharding\nstrategy is used for dyno queues.\n\nSigned-off-by: Maros Marsalek <mmarsalek@frinx.io>", "committedDate": "2020-06-16T08:46:17Z", "type": "commit"}, {"oid": "2308ba92dc5b7a979353ae94c5395df72c7fb98f", "url": "https://github.com/Netflix/conductor/commit/2308ba92dc5b7a979353ae94c5395df72c7fb98f", "message": "Fix headers and unused imports for localOnly sharding\n\nSigned-off-by: Maros Marsalek <mmarsalek@frinx.io>", "committedDate": "2020-06-16T09:03:07Z", "type": "commit"}, {"oid": "2308ba92dc5b7a979353ae94c5395df72c7fb98f", "url": "https://github.com/Netflix/conductor/commit/2308ba92dc5b7a979353ae94c5395df72c7fb98f", "message": "Fix headers and unused imports for localOnly sharding\n\nSigned-off-by: Maros Marsalek <mmarsalek@frinx.io>", "committedDate": "2020-06-16T09:03:07Z", "type": "forcePushed"}]}