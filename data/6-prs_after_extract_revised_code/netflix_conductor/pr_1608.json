{"pr_number": 1608, "pr_title": "change nonterminal task statuses to SKIPPED when a TERMINATE task executes", "pr_createdAt": "2020-03-27T13:23:32Z", "pr_url": "https://github.com/Netflix/conductor/pull/1608", "timeline": [{"oid": "39e74f6114b22d1c6b99a9019753b04ced751bb5", "url": "https://github.com/Netflix/conductor/commit/39e74f6114b22d1c6b99a9019753b04ced751bb5", "message": "change non-terminal task statuses to SKIPPED when a TERMINATE task executes", "committedDate": "2020-03-27T13:14:19Z", "type": "commit"}, {"oid": "b677f8a64ea26e33cfa28fd08b3de248adc69466", "url": "https://github.com/Netflix/conductor/commit/b677f8a64ea26e33cfa28fd08b3de248adc69466", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-03-31T11:36:58Z", "type": "commit"}, {"oid": "7a180038382566254439838054500c1a9439d63f", "url": "https://github.com/Netflix/conductor/commit/7a180038382566254439838054500c1a9439d63f", "message": "handle subworkflows that are still running when TERMINATE task executes in parent workflow", "committedDate": "2020-03-31T11:42:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r402694138", "bodyText": "In the case of sub workflows, would it be better to terminate the sub workflow instead? The reason could be that the parent workflow was terminated using TERMINATE task.", "author": "apanicker-nflx", "createdAt": "2020-04-03T01:55:30Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,6 +987,26 @@ public boolean decide(String workflowId) {\n                                 workflow.setStatus(workflowInstance.getStatus());\n                                 workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped", "originalCommit": "7a180038382566254439838054500c1a9439d63f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjk2Njk4OA==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r402966988", "bodyText": "There are a couple of issues that make terminating the subworkflows problematic (I think). Firstly, I think if the terminate task specifies COMPLETED as the terminationStatus and the subworkflow is terminated, the termination of the subworkflow would actually cause the ultimate status of the parent workflow to be FAILED which wouldn't honor the contract of the terminate task.\nAlso, I tried the below code and there is a StackOverflowError because WorkflowExecutor.decide() would call terminateWorkflow() which would call decide() to terminate the parent workflow, etc.\nif (TERMINATE.name().equals(task.getTaskType())) {\n\tworkflow.setStatus(workflowInstance.getStatus());\n\tworkflow.setOutput(workflowInstance.getOutput());\n\tdeciderService.externalizeWorkflowData(workflow);\n\t/*\n\t * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n\t */\n\tfor(Task workflowTask : workflow.getTasks()) {\n\t\tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n\t\t\tworkflowTask.setStatus(SKIPPED);\n\t\t\ttasksToBeUpdated.add(workflowTask);\n\t\t}\n\t}\n\t/*\n\t * Now find nested subworkflows that also need to have their tasks skipped\n\t */\n\tfor(Task workflowTask : workflow.getTasks()) {\n\t\tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n\t\t\tterminateWorkflow(workflowTask.getSubWorkflowId(), \"Parent workflow was terminated with a TERMINATE task\");\n\t\t/*                                \t\t\n\t\t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n\t\t\tif(subWorkflow != null) {\n\t\t\t\tskipTasksAffectedByTerminateTask(subWorkflow);                                \t\t\n\t\t\t}\n\t\t*/                                \t\t\n\t\t}\n\t}\n}\n\n\nThat said, I could probably make it work but that would involve a lot of changes that might create unforeseen problems elsewhere.\nWhat are your thoughts?", "author": "rickfish", "createdAt": "2020-04-03T12:24:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNzU5OA==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408517598", "bodyText": "f the terminate task specifies COMPLETED as the terminationStatus and the subworkflow is terminated, the termination of the subworkflow would actually cause the ultimate status of the parent workflow to be FAILED\n\nThis observation is correct. Agreed with the reasoning and implementation.", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5NDEzOA=="}], "type": "inlineReview", "revised_code": {"commit": "4059393e455e6d96564375c6919523793f702221", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 58fde4bc..757200ef 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n\n@@ -984,16 +984,17 @@ public class WorkflowExecutor {\n                         if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n                             // FIXME: temporary hack to workaround TERMINATE task\n                             if (TERMINATE.name().equals(task.getTaskType())) {\n-                                workflow.setStatus(workflowInstance.getStatus());\n-                                workflow.setOutput(workflowInstance.getOutput());\n                                 deciderService.externalizeWorkflowData(workflow);\n+                                executionDAOFacade.updateTask(task);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n                                 /*\n                                  * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n                                  */\n                                 for(Task workflowTask : workflow.getTasks()) {\n                                 \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n                                 \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\ttasksToBeUpdated.add(workflowTask);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n                                 \t}\n                                 }\n                                 /*\n"}}, {"oid": "b68abd4d979a3d14325dc90c088b529490fb4b4a", "url": "https://github.com/Netflix/conductor/commit/b68abd4d979a3d14325dc90c088b529490fb4b4a", "message": "Merge branch 'master' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-04-09T17:06:10Z", "type": "commit"}, {"oid": "8e066d95c6cee046913eabdb26ad66ff8f638269", "url": "https://github.com/Netflix/conductor/commit/8e066d95c6cee046913eabdb26ad66ff8f638269", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-04-09T17:34:27Z", "type": "commit"}, {"oid": "e20ff1b40c3d1ea22d617e8c9b88a34f5d251fa1", "url": "https://github.com/Netflix/conductor/commit/e20ff1b40c3d1ea22d617e8c9b88a34f5d251fa1", "message": "added subworkflow testing to the terminate task testcase", "committedDate": "2020-04-09T20:22:01Z", "type": "commit"}, {"oid": "cda751672c4657707378f89f51df1d64ee9cf4ca", "url": "https://github.com/Netflix/conductor/commit/cda751672c4657707378f89f51df1d64ee9cf4ca", "message": "added testing that the subworkflow has a valid status and its task also has a valid statusin the terminate task testcase", "committedDate": "2020-04-09T23:38:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408515896", "bodyText": "Since this is a workflow with wait task, this method can be named createWorkflowWithWaitTask() for better clarity.", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:41:58Z", "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5272,64 +5274,43 @@ public void testLambda() {\n \n     @Test\n     public void testTerminateTaskWithCompletedStatus() {\n-        WorkflowDef workflowDef = new WorkflowDef();\n-        workflowDef.setName(\"test_terminate_task_wf\");\n-        workflowDef.setSchemaVersion(2);\n-\n-        Map<String, Object> lambdaTaskInputParams = new HashMap<>();\n-        lambdaTaskInputParams.put(\"input\", \"${workflow.input}\");\n-        lambdaTaskInputParams.put(\"scriptExpression\", \"if ($.input.a==1){return {testvalue: true}} else{return {testvalue: false}}\");\n+    \ttestTerminateTask(WorkflowStatus.COMPLETED);\n+    }\n \n-        WorkflowTask lambdaWorkflowTask = new WorkflowTask();\n-        lambdaWorkflowTask.setWorkflowTaskType(TaskType.LAMBDA);\n-        lambdaWorkflowTask.setName(\"lambda\");\n-        lambdaWorkflowTask.setInputParameters(lambdaTaskInputParams);\n-        lambdaWorkflowTask.setTaskReferenceName(\"lambda0\");\n+    @Test\n+    public void testTerminateTaskWithFailedStatus() {\n+    \ttestTerminateTask(WorkflowStatus.FAILED);\n+    }\n \n-        Map<String, Object> terminateTaskInputParams = new HashMap<>();\n-        terminateTaskInputParams.put(Terminate.getTerminationStatusParameter(), \"COMPLETED\");\n-        terminateTaskInputParams.put(Terminate.getTerminationWorkflowOutputParameter(), \"${lambda0.output}\");\n+    private WorkflowDef createSubworkflowDefWithWaitTask() {", "originalCommit": "cda751672c4657707378f89f51df1d64ee9cf4ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxODE0NQ==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408518145", "bodyText": "Also, please add another task after the wait task in this workflow, and check that this task is not scheduled when parent workflow is completed using terminate.", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODI3NQ==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408928275", "bodyText": "made the requested changes", "author": "rickfish", "createdAt": "2020-04-15T15:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNTg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "81052d4c6ee0a95b62bf6ed919dc54df82264d25", "chunk": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 2b2773ba..aa796f9e 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n\n@@ -5282,7 +5282,7 @@ public abstract class AbstractWorkflowServiceTest {\n     \ttestTerminateTask(WorkflowStatus.FAILED);\n     }\n \n-    private WorkflowDef createSubworkflowDefWithWaitTask() {\n+    private WorkflowDef createWorkflowWithWaitTask() {\n         WorkflowDef workflowDef = new WorkflowDef();\n         workflowDef.setName(\"test_subworkflow_task_wf\");\n         workflowDef.setSchemaVersion(2);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjczMw==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408516733", "bodyText": "The last task in the left fork is the terminate task, however, the join is set to an intermediate task (wait). This looks incorrect.", "author": "apanicker-nflx", "createdAt": "2020-04-15T00:45:01Z", "path": "test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java", "diffHunk": "@@ -5350,11 +5337,28 @@ public void testTerminateTaskWithFailedStatus() {\n         terminateWorkflowTask.setInputParameters(terminateTaskInputParams);\n         terminateWorkflowTask.setTaskReferenceName(\"terminate0\");\n \n-        WorkflowTask workflowTask2 = new WorkflowTask();\n-        workflowTask2.setName(\"junit_task_2\");\n-        workflowTask2.setTaskReferenceName(\"t2\");\n+        // right fork\n+        WorkflowTask subWorkflow = new WorkflowTask();\n+        subWorkflow.setType(SUB_WORKFLOW.name());\n+        SubWorkflowParams sw = new SubWorkflowParams();\n+        sw.setName(subworkflowDef.getName());\n+        subWorkflow.setSubWorkflowParam(sw);\n+        subWorkflow.setTaskReferenceName(\"sw1\");\n+\n+        fanoutTask.getForkTasks().add(Arrays.asList(subWorkflow));\n+        fanoutTask.getForkTasks().add(Arrays.asList(lambdaWorkflowTask, waitWorkflowTask, terminateWorkflowTask));\n+\n+        // join task\n+        WorkflowTask joinTask = new WorkflowTask();\n+        joinTask.setType(TaskType.JOIN.name());\n+        joinTask.setTaskReferenceName(\"fanouttask_join\");\n+        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"leftfork-wait0\"));", "originalCommit": "cda751672c4657707378f89f51df1d64ee9cf4ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyODQ0MQ==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r408928441", "bodyText": "made the requested change", "author": "rickfish", "createdAt": "2020-04-15T15:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUxNjczMw=="}], "type": "inlineReview", "revised_code": {"commit": "81052d4c6ee0a95b62bf6ed919dc54df82264d25", "chunk": "diff --git a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\nindex 2b2773ba..aa796f9e 100644\n--- a/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n+++ b/test-harness/src/test/java/com/netflix/conductor/tests/integration/AbstractWorkflowServiceTest.java\n\n@@ -5352,7 +5364,7 @@ public abstract class AbstractWorkflowServiceTest {\n         WorkflowTask joinTask = new WorkflowTask();\n         joinTask.setType(TaskType.JOIN.name());\n         joinTask.setTaskReferenceName(\"fanouttask_join\");\n-        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"leftfork-wait0\"));\n+        joinTask.setJoinOn(Arrays.asList(\"sw1\", \"terminate0\"));\n         \n         WorkflowDef workflowDef = new WorkflowDef();\n         workflowDef.setName(\"test_terminate_task_wf\");\n"}}, {"oid": "4c00498dcd2571ad794ee88b335b1d0d5bf29df5", "url": "https://github.com/Netflix/conductor/commit/4c00498dcd2571ad794ee88b335b1d0d5bf29df5", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-04-15T14:16:55Z", "type": "commit"}, {"oid": "81052d4c6ee0a95b62bf6ed919dc54df82264d25", "url": "https://github.com/Netflix/conductor/commit/81052d4c6ee0a95b62bf6ed919dc54df82264d25", "message": "for terminate task testing, add simple task to subworkflow and make the join task wait on the terminate task", "committedDate": "2020-04-15T15:21:11Z", "type": "commit"}, {"oid": "4059393e455e6d96564375c6919523793f702221", "url": "https://github.com/Netflix/conductor/commit/4059393e455e6d96564375c6919523793f702221", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T17:00:08Z", "type": "commit"}, {"oid": "43491539bbb1bdee7ec88ac22c647cab4eef5619", "url": "https://github.com/Netflix/conductor/commit/43491539bbb1bdee7ec88ac22c647cab4eef5619", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T17:06:21Z", "type": "commit"}, {"oid": "5b816dbd76011bf02aae22d0070ead7bc5cc7859", "url": "https://github.com/Netflix/conductor/commit/5b816dbd76011bf02aae22d0070ead7bc5cc7859", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T17:07:35Z", "type": "commit"}, {"oid": "48cc0783553b643d53d594afd873ae6526aa79ea", "url": "https://github.com/Netflix/conductor/commit/48cc0783553b643d53d594afd873ae6526aa79ea", "message": "Merge branch 'dev' into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-05-04T17:39:36Z", "type": "commit"}, {"oid": "78682a73c5eda54f52a765a1ddcedbba464245e3", "url": "https://github.com/Netflix/conductor/commit/78682a73c5eda54f52a765a1ddcedbba464245e3", "message": "complete/fail workflow quicker (bypass decider) on a TERMINATE task", "committedDate": "2020-05-04T21:41:38Z", "type": "commit"}, {"oid": "8579a60ea3d108ca525e2c93fda2ceddb322bdad", "url": "https://github.com/Netflix/conductor/commit/8579a60ea3d108ca525e2c93fda2ceddb322bdad", "message": "Merge branch 'terminate-task-handle-nonterminal-tasks' of https://github.com/rickfish/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-05-04T21:42:36Z", "type": "commit"}, {"oid": "f05fba9a015ff9e8940d18f3bc34d8fe2e47c805", "url": "https://github.com/Netflix/conductor/commit/f05fba9a015ff9e8940d18f3bc34d8fe2e47c805", "message": "add workflow defs", "committedDate": "2020-07-01T20:14:08Z", "type": "commit"}, {"oid": "6cb53c0575b097c4405c0953b891cbcef7ac82af", "url": "https://github.com/Netflix/conductor/commit/6cb53c0575b097c4405c0953b891cbcef7ac82af", "message": "deleted sample json files", "committedDate": "2020-07-02T11:42:48Z", "type": "commit"}, {"oid": "26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "url": "https://github.com/Netflix/conductor/commit/26f6bb75870e2904ebbc154d8291c2f2bfa66dda", "message": "prepare for merge of current dev", "committedDate": "2020-07-02T12:03:07Z", "type": "commit"}, {"oid": "1db5b7aafd1307fc4f4de577e9d4135e9114e25a", "url": "https://github.com/Netflix/conductor/commit/1db5b7aafd1307fc4f4de577e9d4135e9114e25a", "message": "Merge branch 'dev' of https://github.com/Netflix/conductor into terminate-task-handle-nonterminal-tasks", "committedDate": "2020-07-02T12:04:12Z", "type": "commit"}, {"oid": "342abee796c9f06def4a7c1b6478d85e011bcbbe", "url": "https://github.com/Netflix/conductor/commit/342abee796c9f06def4a7c1b6478d85e011bcbbe", "message": "fix subworkflows when TERMINATE task is executed and there is a nonterminal subworkflow", "committedDate": "2020-07-02T12:23:15Z", "type": "commit"}, {"oid": "82d88f21cf2b59c0849b60723e61cfb715b15093", "url": "https://github.com/Netflix/conductor/commit/82d88f21cf2b59c0849b60723e61cfb715b15093", "message": "Added back ending curly brace - not sure how it got deleted", "committedDate": "2020-07-03T13:59:36Z", "type": "commit"}, {"oid": "92d2b36bf9aa03876ffacecf1085ec0fe7dad2e6", "url": "https://github.com/Netflix/conductor/commit/92d2b36bf9aa03876ffacecf1085ec0fe7dad2e6", "message": "add logging to see what test failed", "committedDate": "2020-07-03T14:41:31Z", "type": "commit"}, {"oid": "bfe93c84e96ad1545277bed8751882bb1685c669", "url": "https://github.com/Netflix/conductor/commit/bfe93c84e96ad1545277bed8751882bb1685c669", "message": "remove logging to see what test failed", "committedDate": "2020-07-03T15:14:54Z", "type": "commit"}, {"oid": "3e45cb69f6ad8b843482717a11344cf2447afd70", "url": "https://github.com/Netflix/conductor/commit/3e45cb69f6ad8b843482717a11344cf2447afd70", "message": "alter the test for a failure workflow where the workflow was terminated with a TERMINATE task", "committedDate": "2020-07-03T18:23:16Z", "type": "commit"}, {"oid": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "url": "https://github.com/Netflix/conductor/commit/09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "message": "changed the way to terminate the parent workflow and added back the failureWorkflow tests", "committedDate": "2020-07-03T20:01:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA5MzMxMw==", "url": "https://github.com/Netflix/conductor/pull/1608#discussion_r452093313", "bodyText": "This exception message: Unable to start system task: is not relevant, as we're not starting any system tasks here.", "author": "kishorebanala", "createdAt": "2020-07-09T09:39:31Z", "path": "core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java", "diffHunk": "@@ -985,29 +986,56 @@ public boolean decide(String workflowId) {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                        // FIXME: temporary hack to workaround TERMINATE task\n-                        if (TERMINATE.name().equals(task.getTaskType())) {\n-                            deciderService.externalizeTaskData(task);\n-                            executionDAOFacade.updateTask(task);\n-                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                completeWorkflow(workflow);\n-                            } else {\n-                                workflow.setStatus(workflowInstance.getStatus());\n-                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                    try {\n+                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                            // FIXME: temporary hack to workaround TERMINATE task\n+                            if (TERMINATE.name().equals(task.getTaskType())) {\n+                                deciderService.externalizeTaskData(task);\n+                                executionDAOFacade.updateTask(task);\n+                                workflow.setOutput(workflowInstance.getOutput());\n+                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n+                                /*\n+                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n+                                \t\tworkflowTask.setStatus(SKIPPED);\n+                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n+                                \t}\n+                                }\n+                                /*\n+                                 * Now find nested subworkflows that also need to have their tasks skipped\n+                                 */\n+                                for(Task workflowTask : workflow.getTasks()) {\n+                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n+                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n+                                \t\tif(subWorkflow != null) {\n+                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n+                                \t\t}\n+                                \t}\n+                                }\n+                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n+                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                \tcompleteWorkflow(workflow);\n+                                } else {\n+                                    workflow.setStatus(workflowInstance.getStatus());\n+                                \tterminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                                }\n+                                return true;\n                             }\n-                            return true;\n-                        }\n-                        deciderService.externalizeTaskData(task);\n-                        tasksToBeUpdated.add(task);\n-                        stateChanged = true;\n-                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                        // and continues with the current decide.\n-                        if (updateParentWorkflow(task, workflow)) {\n+                            deciderService.externalizeTaskData(task);\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n+                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                            // and continues with the current decide.\n+                            if (updateParentWorkflow(task, workflow)) {\n+                                tasksToBeUpdated.add(task);\n+                                stateChanged = true;\n+                            }\n                         }\n+                    } catch (Exception e) {\n+                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);", "originalCommit": "09f9b492f6ad9f03ae4ae924ec84d04d9b6979ad", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "chunk": "diff --git a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\nindex 8b84afcc..762ca72e 100644\n--- a/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n+++ b/core/src/main/java/com/netflix/conductor/core/execution/WorkflowExecutor.java\n\n@@ -986,56 +992,29 @@ public class WorkflowExecutor {\n                 if (isSystemTask.and(isNonTerminalTask).test(task)) {\n                     WorkflowSystemTask workflowSystemTask = WorkflowSystemTask.get(task.getTaskType());\n                     Workflow workflowInstance = deciderService.populateWorkflowAndTaskData(workflow);\n-                    try {\n-                        if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n-                            // FIXME: temporary hack to workaround TERMINATE task\n-                            if (TERMINATE.name().equals(task.getTaskType())) {\n-                                deciderService.externalizeTaskData(task);\n-                                executionDAOFacade.updateTask(task);\n-                                workflow.setOutput(workflowInstance.getOutput());\n-                                List<Task> terminateTasksToBeUpdated = new ArrayList<Task>();\n-                                /*\n-                                 * The TERMINATE task completes the workflow but does not do anything with SCHEDULED or IN_PROGRESS tasks to complete them\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(workflowTask != task && !workflowTask.getStatus().isTerminal()) {\n-                                \t\tworkflowTask.setStatus(SKIPPED);\n-                                \t\tterminateTasksToBeUpdated.add(workflowTask);\n-                                \t}\n-                                }\n-                                /*\n-                                 * Now find nested subworkflows that also need to have their tasks skipped\n-                                 */\n-                                for(Task workflowTask : workflow.getTasks()) {\n-                                \tif(TaskType.SUB_WORKFLOW.name().equals(workflowTask.getTaskType()) && StringUtils.isNotBlank(workflowTask.getSubWorkflowId())) {\n-                                   \t\tWorkflow subWorkflow = executionDAOFacade.getWorkflowById(workflowTask.getSubWorkflowId(), true);\n-                                \t\tif(subWorkflow != null) {\n-                                \t\t\tskipTasksAffectedByTerminateTask(subWorkflow);\n-                                \t\t}\n-                                \t}\n-                                }\n-                                executionDAOFacade.updateTasks(terminateTasksToBeUpdated);\n-                                if(workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n-                                \tcompleteWorkflow(workflow);\n-                                } else {\n-                                    workflow.setStatus(workflowInstance.getStatus());\n-                                \tterminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n-                                }\n-                                return true;\n-                            }\n+                    if (!workflowSystemTask.isAsync() && workflowSystemTask.execute(workflowInstance, task, this)) {\n+                        // FIXME: temporary hack to workaround TERMINATE task\n+                        if (TERMINATE.name().equals(task.getTaskType())) {\n                             deciderService.externalizeTaskData(task);\n+                            executionDAOFacade.updateTask(task);\n+                            if (workflowInstance.getStatus().equals(WorkflowStatus.COMPLETED)) {\n+                                completeWorkflow(workflow);\n+                            } else {\n+                                workflow.setStatus(workflowInstance.getStatus());\n+                                terminate(workflow, new TerminateWorkflowException(\"Workflow is FAILED by TERMINATE task: \" + task.getTaskId()));\n+                            }\n+                            return true;\n+                        }\n+                        deciderService.externalizeTaskData(task);\n+                        tasksToBeUpdated.add(task);\n+                        stateChanged = true;\n+                    } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n+                        // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n+                        // and continues with the current decide.\n+                        if (updateParentWorkflow(task, workflow)) {\n                             tasksToBeUpdated.add(task);\n                             stateChanged = true;\n-                        } else if (SUB_WORKFLOW.name().equals(task.getTaskType()) && task.getStatus().equals(IN_PROGRESS)) {\n-                            // Verifies and updates the task inplace, based on the Subworkflow and parent Workflow state,\n-                            // and continues with the current decide.\n-                            if (updateParentWorkflow(task, workflow)) {\n-                                tasksToBeUpdated.add(task);\n-                                stateChanged = true;\n-                            }\n                         }\n-                    } catch (Exception e) {\n-                        throw new ApplicationException(Code.INTERNAL_ERROR, String.format(\"Unable to start system task: %s\", workflowSystemTask.getName()), e);\n                     }\n                 }\n             }\n"}}, {"oid": "49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "url": "https://github.com/Netflix/conductor/commit/49f25ef2072688e52a48f1ee95ca2d42a4fd3a72", "message": "prepare for merge", "committedDate": "2020-07-09T12:38:10Z", "type": "commit"}]}