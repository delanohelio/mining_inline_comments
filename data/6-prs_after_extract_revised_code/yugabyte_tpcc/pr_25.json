{"pr_number": 25, "pr_title": "Adding support for connection pooling in TPCC.", "pr_createdAt": "2020-06-11T02:07:27Z", "pr_url": "https://github.com/yugabyte/tpcc/pull/25", "timeline": [{"oid": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "url": "https://github.com/yugabyte/tpcc/commit/b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "message": "Adding support for connection pooling in TPCC.\n\nSummary:\nWe need 10X the number of terminals with respect to the number of\nwarehouses to get a good TPM-C number. Each terminal gets its own\nconnection to perform transactions. This is fine for smaller number of\nwarehouses. But as the number increases, we reach the limit of the max\nnumber of connections supported by the DB.\n\nGiven that each terminal spends most of its time waiting for keying or\nfor thinking, we could reuse the connections across the terminals.\n\nThis change creates a Hikari pool one per endpoint and each worker gets\na reference to the pool rather than an actual connection. When the\nworker executes a transaction, it gets a connection from the pool and\n gives the connection back to the pool once the transaction is done.\n\nEach worker prepares a statement every time it executes a transaction.\nThis is fine since the driver has a cache of PreparedStatements per\nconnection of size 256. The number of unique statements in the\napplication is 33. Hence we don't send the PrepareStatement requests to\nthe server every time.\n\nReviewers:\nNeha, Mikhail, Karthik", "committedDate": "2020-06-11T01:59:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzQxMg==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r438537412", "bodyText": "I don't agree with catching and ignoring exceptions. There must be a better way to get an element from an XML file. Or, if you must catch and ignore this particular exception, encapsulate that logic in a helper function taking an xml config and a key and do not wrap additional code in these exception-suppressing blocks.", "author": "mbautin", "createdAt": "2020-06-11T04:34:35Z", "path": "src/com/oltpbenchmark/DBWorkload.java", "diffHunk": "@@ -264,6 +264,26 @@ public static void main(String[] args) throws Exception {\n                 // Nothing to do here !\n             }\n \n+            try {\n+                wrkld.setPort(xmlConfig.getInt(\"port\"));\n+            } catch(NoSuchElementException nse) {\n+                // Nothing to do here !\n+            }\n+\n+            try {\n+                wrkld.setNumDBConnections(xmlConfig.getInt(\"numDBConnections\"));\n+            } catch(NoSuchElementException nse) {\n+                // Nothing to do here !\n+            }", "originalCommit": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEwOTY5MQ==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439109691", "bodyText": "Done", "author": "psudheer21", "createdAt": "2020-06-11T22:40:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzQxMg=="}], "type": "inlineReview", "revised_code": {"commit": "593c92326cccbf74baa84c2344c096c47541c843", "chunk": "diff --git a/src/com/oltpbenchmark/DBWorkload.java b/src/com/oltpbenchmark/DBWorkload.java\nindex 25d63b5..18cf166 100644\n--- a/src/com/oltpbenchmark/DBWorkload.java\n+++ b/src/com/oltpbenchmark/DBWorkload.java\n\n@@ -234,46 +234,28 @@ public class DBWorkload {\n             wrkld.setRecordAbortMessages(xmlConfig.getBoolean(\"recordabortmessages\", false));\n             wrkld.setDataDir(xmlConfig.getString(\"datadir\", \".\"));\n \n-            double selectivity = -1;\n-            try {\n-                selectivity = xmlConfig.getDouble(\"selectivity\");\n-                wrkld.setSelectivity(selectivity);\n+            if (xmlConfig.containsKey(\"useKeyingTime\")) {\n+                wrkld.setUseKeyingTime(xmlConfig.getBoolean(\"useKeyingTime\"));\n             }\n-            catch(NoSuchElementException nse) {\n-                // Nothing to do here !\n+            if (xmlConfig.containsKey(\"useThinkTime\")) {\n+                wrkld.setUseKeyingTime(xmlConfig.getBoolean(\"useThinkTime\"));\n             }\n \n-            try {\n-              // Whether to enable the queuing and keying times based on the TPC-C standard.\n-              wrkld.setUseKeyingTime(xmlConfig.getBoolean(\"useKeyingTime\"));\n-              wrkld.setUseThinkTime(xmlConfig.getBoolean(\"useThinkTime\"));\n-            } catch(NoSuchElementException nse) {\n-                // Nothing to do here !\n+            if (xmlConfig.containsKey(\"enableForeignKeysAfterLoad\")) {\n+                wrkld.setEnableForeignKeysAfterLoad(xmlConfig.getBoolean(\"enableForeignKeysAfterLoad\"));\n             }\n \n-            try {\n-              // Whether to defer the foreign key checks until after the loading of the data is done.\n-              wrkld.setEnableForeignKeysAfterLoad(xmlConfig.getBoolean(\"enableForeignKeysAfterLoad\"));\n-            } catch(NoSuchElementException nse) {\n-                // Nothing to do here !\n+            if (xmlConfig.containsKey(\"batchSize\")) {\n+                wrkld.setBatchSize(xmlConfig.getInt(\"batchSize\"));\n             }\n \n-            try {\n-              wrkld.setBatchSize(xmlConfig.getInt(\"batchSize\"));\n-            } catch(NoSuchElementException nse) {\n-                // Nothing to do here !\n-            }\n-\n-            try {\n+            if (xmlConfig.containsKey(\"port\")) {\n+                LOG.info(\"port exists\");\n                 wrkld.setPort(xmlConfig.getInt(\"port\"));\n-            } catch(NoSuchElementException nse) {\n-                // Nothing to do here !\n             }\n \n-            try {\n+            if (xmlConfig.containsKey(\"numDBConnections\")) {\n                 wrkld.setNumDBConnections(xmlConfig.getInt(\"numDBConnections\"));\n-            } catch(NoSuchElementException nse) {\n-                // Nothing to do here !\n             }\n \n             if (wrkld.getNumDBConnections() <= 0) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzY4MA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r438537680", "bodyText": "Fix indentation", "author": "mbautin", "createdAt": "2020-06-11T04:35:45Z", "path": "src/com/oltpbenchmark/WorkloadConfiguration.java", "diffHunk": "@@ -103,12 +105,12 @@ public DatabaseType getDBType() {\n         return db_type;\n     }\n \n-\tpublic void setDBConnections(List<String> connections) {\n-      this.dbConnections = connections;\n+\tpublic void setNodes(List<String> nodes) {\n+      this.nodes = nodes;", "originalCommit": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEwOTczNA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439109734", "bodyText": "Done.", "author": "psudheer21", "createdAt": "2020-06-11T22:40:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzY4MA=="}], "type": "inlineReview", "revised_code": {"commit": "593c92326cccbf74baa84c2344c096c47541c843", "chunk": "diff --git a/src/com/oltpbenchmark/WorkloadConfiguration.java b/src/com/oltpbenchmark/WorkloadConfiguration.java\nindex b273b5c..c6f4b88 100644\n--- a/src/com/oltpbenchmark/WorkloadConfiguration.java\n+++ b/src/com/oltpbenchmark/WorkloadConfiguration.java\n\n@@ -105,13 +105,9 @@ public class WorkloadConfiguration {\n         return db_type;\n     }\n \n-\tpublic void setNodes(List<String> nodes) {\n-      this.nodes = nodes;\n-\t}\n+\tpublic void setNodes(List<String> nodes) { this.nodes = nodes; }\n \n-\tpublic List<String> getNodes() {\n-\t\treturn nodes;\n-\t}\n+\tpublic List<String> getNodes() { return nodes; }\n \n \tpublic void setDBName(String dbname) {\n \t\tthis.db_name = dbname;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzcxMw==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r438537713", "bodyText": "Fix indentation", "author": "mbautin", "createdAt": "2020-06-11T04:35:54Z", "path": "src/com/oltpbenchmark/WorkloadConfiguration.java", "diffHunk": "@@ -103,12 +105,12 @@ public DatabaseType getDBType() {\n         return db_type;\n     }\n \n-\tpublic void setDBConnections(List<String> connections) {\n-      this.dbConnections = connections;\n+\tpublic void setNodes(List<String> nodes) {\n+      this.nodes = nodes;\n \t}\n \n-\tpublic List<String> getDBConnections() {\n-\t\treturn dbConnections;\n+\tpublic List<String> getNodes() {\n+\t\treturn nodes;", "originalCommit": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "593c92326cccbf74baa84c2344c096c47541c843", "chunk": "diff --git a/src/com/oltpbenchmark/WorkloadConfiguration.java b/src/com/oltpbenchmark/WorkloadConfiguration.java\nindex b273b5c..c6f4b88 100644\n--- a/src/com/oltpbenchmark/WorkloadConfiguration.java\n+++ b/src/com/oltpbenchmark/WorkloadConfiguration.java\n\n@@ -105,13 +105,9 @@ public class WorkloadConfiguration {\n         return db_type;\n     }\n \n-\tpublic void setNodes(List<String> nodes) {\n-      this.nodes = nodes;\n-\t}\n+\tpublic void setNodes(List<String> nodes) { this.nodes = nodes; }\n \n-\tpublic List<String> getNodes() {\n-\t\treturn nodes;\n-\t}\n+\tpublic List<String> getNodes() { return nodes; }\n \n \tpublic void setDBName(String dbname) {\n \t\tthis.db_name = dbname;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzkyOA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r438537928", "bodyText": "Why are we just logging an exception and proceeding here? Wouldn't it be better to let the workload crash at this point? (E.g. wrap and re-throw the exception as a RuntimeException if necessary.)", "author": "mbautin", "createdAt": "2020-06-11T04:36:49Z", "path": "src/com/oltpbenchmark/api/BenchmarkModule.java", "diffHunk": "@@ -95,28 +99,37 @@ public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boo\n         this.catalog = (withCatalog ? new Catalog(this) : null);\n         File xmlFile = this.getSQLDialect();\n         this.dialects = new StatementDialects(this.workConf.getDBType(), xmlFile);\n+\n+        try {\n+            createDataSource();\n+        } catch (Exception e) {\n+            LOG.error(\"Failed to create Data source\", e);\n+        }", "originalCommit": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMDQ2NA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439110464", "bodyText": "Done.", "author": "psudheer21", "createdAt": "2020-06-11T22:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzkyOA=="}], "type": "inlineReview", "revised_code": {"commit": "593c92326cccbf74baa84c2344c096c47541c843", "chunk": "diff --git a/src/com/oltpbenchmark/api/BenchmarkModule.java b/src/com/oltpbenchmark/api/BenchmarkModule.java\nindex 5d9bd05..e240c44 100644\n--- a/src/com/oltpbenchmark/api/BenchmarkModule.java\n+++ b/src/com/oltpbenchmark/api/BenchmarkModule.java\n\n@@ -91,7 +91,7 @@ public abstract class BenchmarkModule {\n      */\n     private final Random rng = new Random();\n \n-    public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boolean withCatalog) {\n+    public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boolean withCatalog) throws Exception {\n         assert (workConf != null) : \"The WorkloadConfiguration instance is null.\";\n \n         this.benchmarkName = benchmarkName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzODMwMQ==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r438538301", "bodyText": "This should probably be a \"ceiling\" value, i.e. (totalConnections + numNodes - 1) / numNodes.", "author": "mbautin", "createdAt": "2020-06-11T04:38:21Z", "path": "src/com/oltpbenchmark/api/BenchmarkModule.java", "diffHunk": "@@ -95,28 +99,37 @@ public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boo\n         this.catalog = (withCatalog ? new Catalog(this) : null);\n         File xmlFile = this.getSQLDialect();\n         this.dialects = new StatementDialects(this.workConf.getDBType(), xmlFile);\n+\n+        try {\n+            createDataSource();\n+        } catch (Exception e) {\n+            LOG.error(\"Failed to create Data source\", e);\n+        }\n     }\n \n-    // --------------------------------------------------------------------------\n-    // DATABASE CONNETION\n-    // --------------------------------------------------------------------------\n+    private List<HikariDataSource> listDataSource = new ArrayList<>();\n+\n+    public void createDataSource() throws SQLException {\n+        int numConnections = workConf.getNumDBConnections() / workConf.getNodes().size();", "originalCommit": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyMzMzNg==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439123336", "bodyText": "Makes sense.", "author": "psudheer21", "createdAt": "2020-06-11T23:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzODMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "593c92326cccbf74baa84c2344c096c47541c843", "chunk": "diff --git a/src/com/oltpbenchmark/api/BenchmarkModule.java b/src/com/oltpbenchmark/api/BenchmarkModule.java\nindex 5d9bd05..e240c44 100644\n--- a/src/com/oltpbenchmark/api/BenchmarkModule.java\n+++ b/src/com/oltpbenchmark/api/BenchmarkModule.java\n\n@@ -91,7 +91,7 @@ public abstract class BenchmarkModule {\n      */\n     private final Random rng = new Random();\n \n-    public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boolean withCatalog) {\n+    public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boolean withCatalog) throws Exception {\n         assert (workConf != null) : \"The WorkloadConfiguration instance is null.\";\n \n         this.benchmarkName = benchmarkName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzODQyMg==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r438538422", "bodyText": "Add a space after the comma", "author": "mbautin", "createdAt": "2020-06-11T04:38:51Z", "path": "src/com/oltpbenchmark/benchmarks/tpcc/TPCCWorker.java", "diffHunk": "@@ -67,7 +68,7 @@ public TPCCWorker(TPCCBenchmark benchmarkModule, int id,\n \t * Executes a single TPCC transaction of type transactionType.\n \t */\n \t@Override\n-    protected TransactionStatus executeWork(TransactionType nextTransaction) throws UserAbortException, SQLException {\n+    protected TransactionStatus executeWork(Connection conn,TransactionType nextTransaction) throws UserAbortException, SQLException {", "originalCommit": "b474698deaa8f916e6b50cee2f2a3d2ecf3d8234", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyMzIyMw==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439123223", "bodyText": "Done.", "author": "psudheer21", "createdAt": "2020-06-11T23:24:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzODQyMg=="}], "type": "inlineReview", "revised_code": {"commit": "593c92326cccbf74baa84c2344c096c47541c843", "chunk": "diff --git a/src/com/oltpbenchmark/benchmarks/tpcc/TPCCWorker.java b/src/com/oltpbenchmark/benchmarks/tpcc/TPCCWorker.java\nindex ad050c7..a2a77c9 100644\n--- a/src/com/oltpbenchmark/benchmarks/tpcc/TPCCWorker.java\n+++ b/src/com/oltpbenchmark/benchmarks/tpcc/TPCCWorker.java\n\n@@ -68,7 +68,7 @@ public class TPCCWorker extends Worker<TPCCBenchmark> {\n \t * Executes a single TPCC transaction of type transactionType.\n \t */\n \t@Override\n-    protected TransactionStatus executeWork(Connection conn,TransactionType nextTransaction) throws UserAbortException, SQLException {\n+    protected TransactionStatus executeWork(Connection conn, TransactionType nextTransaction) throws UserAbortException, SQLException {\n         try {\n             TPCCProcedure proc = (TPCCProcedure) this.getProcedure(nextTransaction.getProcedureClass());\n \n"}}, {"oid": "593c92326cccbf74baa84c2344c096c47541c843", "url": "https://github.com/yugabyte/tpcc/commit/593c92326cccbf74baa84c2344c096c47541c843", "message": "Addressed comments.", "committedDate": "2020-06-11T23:40:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzMzUxOA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439133518", "bodyText": "Nit: indentation seems inconsistent in this file.", "author": "mbautin", "createdAt": "2020-06-12T00:01:56Z", "path": "src/com/oltpbenchmark/WorkloadConfiguration.java", "diffHunk": "@@ -43,14 +43,16 @@ public void setBenchmarkName(String benchmarkName) {\n         this.benchmarkName = benchmarkName;\n     }\n \n-    private List<String> dbConnections;\n+    private List<String> nodes;\n \tprivate String db_name;", "originalCommit": "593c92326cccbf74baa84c2344c096c47541c843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0MzAzNA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439243034", "bodyText": "Reformatted the entire code...", "author": "psudheer21", "createdAt": "2020-06-12T07:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzMzUxOA=="}], "type": "inlineReview", "revised_code": {"commit": "c6af2378b505889c9f0c281267627b7a46d70c5d", "chunk": "diff --git a/src/com/oltpbenchmark/WorkloadConfiguration.java b/src/com/oltpbenchmark/WorkloadConfiguration.java\nindex c6f4b88..21c6407 100644\n--- a/src/com/oltpbenchmark/WorkloadConfiguration.java\n+++ b/src/com/oltpbenchmark/WorkloadConfiguration.java\n\n@@ -17,334 +17,352 @@\n \n package com.oltpbenchmark;\n \n+import com.oltpbenchmark.api.TransactionTypes;\n+import com.oltpbenchmark.types.DatabaseType;\n+import com.oltpbenchmark.util.StringUtil;\n+import com.oltpbenchmark.util.ThreadUtil;\n+import org.apache.commons.collections15.map.ListOrderedMap;\n+import org.apache.commons.configuration.XMLConfiguration;\n+\n import java.lang.reflect.Field;\n import java.sql.Connection;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n \n-import org.apache.commons.collections15.map.ListOrderedMap;\n-import org.apache.commons.configuration.XMLConfiguration;\n-\n-import com.oltpbenchmark.api.TransactionTypes;\n-import com.oltpbenchmark.types.DatabaseType;\n-import com.oltpbenchmark.util.StringUtil;\n-import com.oltpbenchmark.util.ThreadUtil;\n-\n public class WorkloadConfiguration {\n \n-\tprivate DatabaseType db_type;\n-\tprivate String benchmarkName;\n-\tpublic String getBenchmarkName() {\n-        return benchmarkName;\n-    }\n-\n-    public void setBenchmarkName(String benchmarkName) {\n-        this.benchmarkName = benchmarkName;\n-    }\n-\n-    private List<String> nodes;\n-\tprivate String db_name;\n-\tprivate String db_username;\n-\tprivate String db_password;\n-\tprivate String db_driver;\n-\tprivate double scaleFactor = 1.0;\n-\tprivate double selectivity = -1.0;\n-\tprivate int terminals;\n-\tprivate int numDBConnections = -1;\n-\tprivate int port = 5433;\n-\tprivate int loaderThreads = ThreadUtil.availableProcessors();\n-\tprivate int numTxnTypes;\n-    private TraceReader traceReader = null;\n-    private boolean useKeyingTime = true;\n-    private boolean useThinkTime = true;\n-    private boolean enableForeignKeysAfterLoad = true;\n-    private int batchSize = 128;\n-\n-    public TraceReader getTraceReader() {\n-        return traceReader;\n-    }\n-    public void setTraceReader(TraceReader traceReader) {\n-        this.traceReader = traceReader;\n-    }\n-\n-\tprivate XMLConfiguration xmlConfig = null;\n-\n-\tprivate List<Phase> works = new ArrayList<Phase>();\n-\tprivate WorkloadState workloadState;\n-\n-\tpublic WorkloadState getWorkloadState() {\n-        return workloadState;\n-    }\n-\n-\t/**\n-\t * Initiate a new benchmark and workload state\n-\t */\n-    public WorkloadState initializeState(BenchmarkState benchmarkState) {\n-        assert (workloadState == null);\n-        workloadState = new WorkloadState(benchmarkState, works, terminals, traceReader);\n-        return workloadState;\n-    }\n-\n-    private int numberOfPhases = 0;\n-\tprivate TransactionTypes transTypes = null;\n-\tprivate int isolationMode = Connection.TRANSACTION_SERIALIZABLE;\n-\tprivate boolean recordAbortMessages = false;\n-    private String dataDir = null;\n-\n-    public void addWork(int time, int warmup, int rate, List<String> weights, boolean rateLimited, boolean disabled, boolean serial, boolean timed, int active_terminals, Phase.Arrival arrival) {\n-        works.add(new Phase(benchmarkName, numberOfPhases, time, warmup, rate, weights, rateLimited, disabled, serial, timed, active_terminals, arrival));\n-\t\tnumberOfPhases++;\n-\t}\n-\n-\tpublic void setDBType(DatabaseType dbType) {\n-        db_type = dbType;\n-    }\n-\n-\tpublic DatabaseType getDBType() {\n-        return db_type;\n-    }\n-\n-\tpublic void setNodes(List<String> nodes) { this.nodes = nodes; }\n-\n-\tpublic List<String> getNodes() { return nodes; }\n-\n-\tpublic void setDBName(String dbname) {\n-\t\tthis.db_name = dbname;\n-\t}\n-\n-\tpublic void setLoaderThreads(int loaderThreads) {\n-        this.loaderThreads = loaderThreads;\n-    }\n-\n-\t/**\n-\t * The number of loader threads that the framework is allowed to use.\n-\t * @return\n-\t */\n-\tpublic int getLoaderThreads() {\n-        return this.loaderThreads;\n-    }\n-\n-\tpublic int getNumTxnTypes() {\n-\t\treturn numTxnTypes;\n-\t}\n-\n-\tpublic void setNumTxnTypes(int numTxnTypes) {\n-\t\tthis.numTxnTypes = numTxnTypes;\n-\t}\n-\n-\tpublic String getDBName() {\n-\t\treturn db_name;\n-\t}\n-\n-\tpublic void setDBUsername(String username) {\n-\t\tthis.db_username = username;\n-\t}\n-\n-\tpublic String getDBUsername() {\n-\t\treturn db_username;\n-\t}\n-\n-\tpublic void setDBPassword(String password) {\n-\t\tthis.db_password = password;\n-\t}\n-\n-\tpublic String getDBPassword() {\n-\t\treturn this.db_password;\n-\t}\n-\n-\tpublic void setSelectivity(double selectivity) {\n-        this.selectivity = selectivity;\n-    }\n-\n-\tpublic double getSelectivity() {\n-\t    return this.selectivity;\n-\t}\n-\n-\tpublic void setDBDriver(String driver) {\n-\t\tthis.db_driver = driver;\n-\t}\n-\n-\tpublic String getDBDriver() {\n-\t\treturn this.db_driver;\n-\t}\n-\n-\tpublic void setRecordAbortMessages(boolean recordAbortMessages) {\n-        this.recordAbortMessages = recordAbortMessages;\n-    }\n-\n-\t/**\n-\t * Whether each worker should record the transaction's UserAbort messages\n-\t * This primarily useful for debugging a benchmark\n-\t */\n-\tpublic boolean getRecordAbortMessages() {\n-        return (this.recordAbortMessages);\n-    }\n-\n-\t/**\n-\t * Set the scale factor for the database\n-\t * A value of 1 means the default size.\n-\t * A value greater than 1 means the database is larger\n-\t * A value less than 1 means the database is smaller\n-\t * @param scaleFactor\n-\t */\n-\tpublic void setScaleFactor(double scaleFactor) {\n-        this.scaleFactor = scaleFactor;\n-    }\n-\t/**\n-\t * Return the scale factor of the database size\n-\t * @return\n-\t */\n-\tpublic double getScaleFactor() {\n-        return this.scaleFactor;\n-    }\n-\n-\t/**\n-\t * Return the number of phases specified in the config file\n-\t * @return\n-\t */\n-\tpublic int getNumberOfPhases() {\n-\t\treturn this.numberOfPhases;\n-\t}\n-\n-\t/**\n-     * Set the directory in which we can find the data files (for example, CSV\n-     * files) for loading the database.\n-     */\n-    public void setDataDir(String dir) {\n-        this.dataDir = dir;\n-    }\n-\n-    /**\n-     * Return the directory in which we can find the data files (for example, CSV\n-     * files) for loading the database.\n-     */\n-    public String getDataDir() {\n-        return this.dataDir;\n-    }\n-\n-    /**\n-\t * A utility method that init the phaseIterator and dialectMap\n-\t */\n-\tpublic void init() {\n-\t    try {\n-\t        Class.forName(this.db_driver);\n-\t    } catch (ClassNotFoundException ex) {\n-\t        throw new RuntimeException(\"Failed to initialize JDBC driver '\" + this.db_driver + \"'\", ex);\n-\t    }\n-\t}\n-\n-\tpublic void setTerminals(int terminals) {\n-\t\tthis.terminals = terminals;\n-\t}\n-\n-\tpublic int getTerminals() {\n-\t\treturn terminals;\n-\t}\n-\n-\tpublic void setNumDBConnections(int numDBConnections) { this.numDBConnections = numDBConnections; }\n-\n-\tpublic int getNumDBConnections() { return this.numDBConnections; }\n-\n-\tpublic void setPort(int port) { this.port = port; }\n-\n-\tpublic int getPort() { return port; }\n-\n-\tpublic TransactionTypes getTransTypes() {\n-\t\treturn transTypes;\n-\t}\n-\n-\tpublic void setTransTypes(TransactionTypes transTypes) {\n-\t\tthis.transTypes = transTypes;\n-\t}\n-\n-\tpublic List<Phase> getAllPhases() {\n-\t\treturn works;\n-\t}\n-\n-\tpublic void setXmlConfig(XMLConfiguration xmlConfig) {\n-\t\tthis.xmlConfig = xmlConfig;\n-\t}\n-\n-\tpublic XMLConfiguration getXmlConfig() {\n-\t\treturn xmlConfig;\n-\t}\n-\n-\tpublic int getIsolationMode() {\n-\t\treturn isolationMode;\n-\t}\n-\n-    public String getIsolationString() {\n-        if(this.isolationMode== Connection.TRANSACTION_SERIALIZABLE)\n-            return \"TRANSACTION_SERIALIZABLE\";\n-        else if(this.isolationMode==Connection.TRANSACTION_READ_COMMITTED)\n-            return \"TRANSACTION_READ_COMMITTED\";\n-        else if(this.isolationMode==Connection.TRANSACTION_REPEATABLE_READ)\n-            return \"TRANSACTION_REPEATABLE_READ\";\n-        else if(this.isolationMode==Connection.TRANSACTION_READ_UNCOMMITTED)\n-            return \"TRANSACTION_READ_UNCOMMITTED\";\n-        else\n-            return \"TRANSACTION_SERIALIZABLE [DEFAULT]\";\n-    }\n-\n-\tpublic void setIsolationMode(String mode) {\n-\t\tif(mode.equals(\"TRANSACTION_SERIALIZABLE\"))\n-\t\t\tthis.isolationMode= Connection.TRANSACTION_SERIALIZABLE;\n-\t\telse if(mode.equals(\"TRANSACTION_READ_COMMITTED\"))\n-\t\t\tthis.isolationMode=Connection.TRANSACTION_READ_COMMITTED;\n-\t\telse if(mode.equals(\"TRANSACTION_REPEATABLE_READ\"))\n-\t\t\tthis.isolationMode=Connection.TRANSACTION_REPEATABLE_READ;\n-\t\telse if(mode.equals(\"TRANSACTION_READ_UNCOMMITTED\"))\n-\t\t\tthis.isolationMode=Connection.TRANSACTION_READ_UNCOMMITTED;\n-\t\telse if(!mode.isEmpty())\n-\t\t\tSystem.out.println(\"Indefined isolation mode, set to default [TRANSACTION_SERIALIZABLE]\");\n-\t}\n-\n-    public boolean getUseKeyingTime() {\n-      return useKeyingTime;\n-    }\n-\n-    public void setUseKeyingTime(boolean useKeyingTime) {\n-      this.useKeyingTime = useKeyingTime;\n-    }\n-\n-    public boolean getUseThinkTime() {\n-      return useThinkTime;\n-    }\n-\n-    public void setUseThinkTime(boolean useThinkTime) {\n-      this.useThinkTime = useThinkTime;\n-    }\n-\n-    public boolean getEnableForeignKeysAfterLoad() {\n-      return enableForeignKeysAfterLoad;\n-    }\n-\n-    public void setEnableForeignKeysAfterLoad(boolean enableForeignKeysAfterLoad) {\n-      this.enableForeignKeysAfterLoad = enableForeignKeysAfterLoad;\n-    }\n-\n-    public int getBatchSize() {\n-      return batchSize;\n-    }\n-\n-    public void setBatchSize(int batchSize) {\n-      this.batchSize = batchSize;\n-    }\n-\n-\t@Override\n-\tpublic String toString() {\n-        Class<?> confClass = this.getClass();\n-        Map<String, Object> m = new ListOrderedMap<String, Object>();\n-        for (Field f : confClass.getDeclaredFields()) {\n-            Object obj = null;\n-            try {\n-                obj = f.get(this);\n-            } catch (IllegalAccessException ex) {\n-                throw new RuntimeException(ex);\n-            }\n-            m.put(f.getName().toUpperCase(), obj);\n-        } // FOR\n-        return StringUtil.formatMaps(m);\n+  private DatabaseType db_type;\n+  private String benchmarkName;\n+\n+  public String getBenchmarkName() {\n+    return benchmarkName;\n+  }\n+\n+  public void setBenchmarkName(String benchmarkName) {\n+    this.benchmarkName = benchmarkName;\n+  }\n+\n+  private List<String> nodes;\n+  private String db_name;\n+  private String db_username;\n+  private String db_password;\n+  private String db_driver;\n+  private double scaleFactor = 1.0;\n+  private double selectivity = -1.0;\n+  private int terminals;\n+  private int numDBConnections = -1;\n+  private int port = 5433;\n+  private int loaderThreads = ThreadUtil.availableProcessors();\n+  private int numTxnTypes;\n+  private TraceReader traceReader = null;\n+  private boolean useKeyingTime = true;\n+  private boolean useThinkTime = true;\n+  private boolean enableForeignKeysAfterLoad = true;\n+  private int batchSize = 128;\n+\n+  public TraceReader getTraceReader() {\n+    return traceReader;\n+  }\n+\n+  public void setTraceReader(TraceReader traceReader) {\n+    this.traceReader = traceReader;\n+  }\n+\n+  private XMLConfiguration xmlConfig = null;\n+\n+  private final List<Phase> works = new ArrayList<Phase>();\n+  private WorkloadState workloadState;\n+\n+  public WorkloadState getWorkloadState() {\n+    return workloadState;\n+  }\n+\n+  /**\n+   * Initiate a new benchmark and workload state\n+   */\n+  public WorkloadState initializeState(BenchmarkState benchmarkState) {\n+    assert (workloadState == null);\n+    workloadState = new WorkloadState(benchmarkState, works, terminals, traceReader);\n+    return workloadState;\n+  }\n+\n+  private int numberOfPhases = 0;\n+  private TransactionTypes transTypes = null;\n+  private int isolationMode = Connection.TRANSACTION_SERIALIZABLE;\n+  private boolean recordAbortMessages = false;\n+  private String dataDir = null;\n+\n+  public void addWork(int time, int warmup, int rate, List<String> weights, boolean rateLimited, boolean disabled, boolean serial, boolean timed, int active_terminals, Phase.Arrival arrival) {\n+    works.add(new Phase(benchmarkName, numberOfPhases, time, warmup, rate, weights, rateLimited, disabled, serial, timed, active_terminals, arrival));\n+    numberOfPhases++;\n+  }\n+\n+  public void setDBType(DatabaseType dbType) {\n+    db_type = dbType;\n+  }\n+\n+  public DatabaseType getDBType() {\n+    return db_type;\n+  }\n+\n+  public void setNodes(List<String> nodes) {\n+    this.nodes = nodes;\n+  }\n+\n+  public List<String> getNodes() {\n+    return nodes;\n+  }\n+\n+  public void setDBName(String dbname) {\n+    this.db_name = dbname;\n+  }\n+\n+  public void setLoaderThreads(int loaderThreads) {\n+    this.loaderThreads = loaderThreads;\n+  }\n+\n+  /**\n+   * The number of loader threads that the framework is allowed to use.\n+   *\n+   * @return\n+   */\n+  public int getLoaderThreads() {\n+    return this.loaderThreads;\n+  }\n+\n+  public int getNumTxnTypes() {\n+    return numTxnTypes;\n+  }\n+\n+  public void setNumTxnTypes(int numTxnTypes) {\n+    this.numTxnTypes = numTxnTypes;\n+  }\n+\n+  public String getDBName() {\n+    return db_name;\n+  }\n+\n+  public void setDBUsername(String username) {\n+    this.db_username = username;\n+  }\n+\n+  public String getDBUsername() {\n+    return db_username;\n+  }\n+\n+  public void setDBPassword(String password) {\n+    this.db_password = password;\n+  }\n+\n+  public String getDBPassword() {\n+    return this.db_password;\n+  }\n+\n+  public void setSelectivity(double selectivity) {\n+    this.selectivity = selectivity;\n+  }\n+\n+  public double getSelectivity() {\n+    return this.selectivity;\n+  }\n+\n+  public void setDBDriver(String driver) {\n+    this.db_driver = driver;\n+  }\n+\n+  public String getDBDriver() {\n+    return this.db_driver;\n+  }\n+\n+  public void setRecordAbortMessages(boolean recordAbortMessages) {\n+    this.recordAbortMessages = recordAbortMessages;\n+  }\n+\n+  /**\n+   * Whether each worker should record the transaction's UserAbort messages\n+   * This primarily useful for debugging a benchmark\n+   */\n+  public boolean getRecordAbortMessages() {\n+    return (this.recordAbortMessages);\n+  }\n+\n+  /**\n+   * Set the scale factor for the database\n+   * A value of 1 means the default size.\n+   * A value greater than 1 means the database is larger\n+   * A value less than 1 means the database is smaller\n+   *\n+   * @param scaleFactor\n+   */\n+  public void setScaleFactor(double scaleFactor) {\n+    this.scaleFactor = scaleFactor;\n+  }\n+\n+  /**\n+   * Return the scale factor of the database size\n+   *\n+   * @return\n+   */\n+  public double getScaleFactor() {\n+    return this.scaleFactor;\n+  }\n+\n+  /**\n+   * Return the number of phases specified in the config file\n+   *\n+   * @return\n+   */\n+  public int getNumberOfPhases() {\n+    return this.numberOfPhases;\n+  }\n+\n+  /**\n+   * Set the directory in which we can find the data files (for example, CSV\n+   * files) for loading the database.\n+   */\n+  public void setDataDir(String dir) {\n+    this.dataDir = dir;\n+  }\n+\n+  /**\n+   * Return the directory in which we can find the data files (for example, CSV\n+   * files) for loading the database.\n+   */\n+  public String getDataDir() {\n+    return this.dataDir;\n+  }\n+\n+  /**\n+   * A utility method that init the phaseIterator and dialectMap\n+   */\n+  public void init() {\n+    try {\n+      Class.forName(this.db_driver);\n+    } catch (ClassNotFoundException ex) {\n+      throw new RuntimeException(\"Failed to initialize JDBC driver '\" + this.db_driver + \"'\", ex);\n     }\n+  }\n+\n+  public void setTerminals(int terminals) {\n+    this.terminals = terminals;\n+  }\n+\n+  public int getTerminals() {\n+    return terminals;\n+  }\n+\n+  public void setNumDBConnections(int numDBConnections) {\n+    this.numDBConnections = numDBConnections;\n+  }\n+\n+  public int getNumDBConnections() {\n+    return this.numDBConnections;\n+  }\n+\n+  public void setPort(int port) {\n+    this.port = port;\n+  }\n+\n+  public int getPort() {\n+    return port;\n+  }\n+\n+  public TransactionTypes getTransTypes() {\n+    return transTypes;\n+  }\n+\n+  public void setTransTypes(TransactionTypes transTypes) {\n+    this.transTypes = transTypes;\n+  }\n+\n+  public List<Phase> getAllPhases() {\n+    return works;\n+  }\n+\n+  public void setXmlConfig(XMLConfiguration xmlConfig) {\n+    this.xmlConfig = xmlConfig;\n+  }\n+\n+  public XMLConfiguration getXmlConfig() {\n+    return xmlConfig;\n+  }\n+\n+  public int getIsolationMode() {\n+    return isolationMode;\n+  }\n+\n+  public String getIsolationString() {\n+    if (this.isolationMode == Connection.TRANSACTION_SERIALIZABLE)\n+      return \"TRANSACTION_SERIALIZABLE\";\n+    else if (this.isolationMode == Connection.TRANSACTION_READ_COMMITTED)\n+      return \"TRANSACTION_READ_COMMITTED\";\n+    else if (this.isolationMode == Connection.TRANSACTION_REPEATABLE_READ)\n+      return \"TRANSACTION_REPEATABLE_READ\";\n+    else if (this.isolationMode == Connection.TRANSACTION_READ_UNCOMMITTED)\n+      return \"TRANSACTION_READ_UNCOMMITTED\";\n+    else\n+      return \"TRANSACTION_SERIALIZABLE [DEFAULT]\";\n+  }\n+\n+  public void setIsolationMode(String mode) {\n+    if (mode.equals(\"TRANSACTION_SERIALIZABLE\"))\n+      this.isolationMode = Connection.TRANSACTION_SERIALIZABLE;\n+    else if (mode.equals(\"TRANSACTION_READ_COMMITTED\"))\n+      this.isolationMode = Connection.TRANSACTION_READ_COMMITTED;\n+    else if (mode.equals(\"TRANSACTION_REPEATABLE_READ\"))\n+      this.isolationMode = Connection.TRANSACTION_REPEATABLE_READ;\n+    else if (mode.equals(\"TRANSACTION_READ_UNCOMMITTED\"))\n+      this.isolationMode = Connection.TRANSACTION_READ_UNCOMMITTED;\n+    else if (!mode.isEmpty())\n+      System.out.println(\"Indefined isolation mode, set to default [TRANSACTION_SERIALIZABLE]\");\n+  }\n+\n+  public boolean getUseKeyingTime() {\n+    return useKeyingTime;\n+  }\n+\n+  public void setUseKeyingTime(boolean useKeyingTime) {\n+    this.useKeyingTime = useKeyingTime;\n+  }\n+\n+  public boolean getUseThinkTime() {\n+    return useThinkTime;\n+  }\n+\n+  public void setUseThinkTime(boolean useThinkTime) {\n+    this.useThinkTime = useThinkTime;\n+  }\n+\n+  public boolean getEnableForeignKeysAfterLoad() {\n+    return enableForeignKeysAfterLoad;\n+  }\n+\n+  public void setEnableForeignKeysAfterLoad(boolean enableForeignKeysAfterLoad) {\n+    this.enableForeignKeysAfterLoad = enableForeignKeysAfterLoad;\n+  }\n+\n+  public int getBatchSize() {\n+    return batchSize;\n+  }\n+\n+  public void setBatchSize(int batchSize) {\n+    this.batchSize = batchSize;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    Class<?> confClass = this.getClass();\n+    Map<String, Object> m = new ListOrderedMap<String, Object>();\n+    for (Field f : confClass.getDeclaredFields()) {\n+      Object obj = null;\n+      try {\n+        obj = f.get(this);\n+      } catch (IllegalAccessException ex) {\n+        throw new RuntimeException(ex);\n+      }\n+      m.put(f.getName().toUpperCase(), obj);\n+    } // FOR\n+    return StringUtil.formatMaps(m);\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzMzY2OA==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439133668", "bodyText": "Nit: remove an extra space after r", "author": "mbautin", "createdAt": "2020-06-12T00:02:33Z", "path": "src/com/oltpbenchmark/api/BenchmarkModule.java", "diffHunk": "@@ -87,36 +91,47 @@\n      */\n     private final Random rng = new Random();\n \n-    public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boolean withCatalog) {\n+    public BenchmarkModule(String benchmarkName, WorkloadConfiguration workConf, boolean withCatalog) throws Exception {\n         assert (workConf != null) : \"The WorkloadConfiguration instance is null.\";\n \n         this.benchmarkName = benchmarkName;\n         this.workConf = workConf;\n         this.catalog = (withCatalog ? new Catalog(this) : null);\n         File xmlFile = this.getSQLDialect();\n         this.dialects = new StatementDialects(this.workConf.getDBType(), xmlFile);\n+\n+        try {\n+            createDataSource();\n+        } catch (Exception e) {\n+            LOG.error(\"Failed to create Data source\", e);\n+            throw e;\n+        }\n     }\n \n-    // --------------------------------------------------------------------------\n-    // DATABASE CONNETION\n-    // --------------------------------------------------------------------------\n+    private List<HikariDataSource> listDataSource = new ArrayList<>();\n+\n+    public void createDataSource() throws SQLException {\n+        int numConnections =\n+            (workConf.getNumDBConnections() + workConf.getNodes().size() - 1) / workConf.getNodes().size();\n+        for (String ip : workConf.getNodes()) {\n+            Properties props = new Properties();\n+            props.setProperty(\"dataSourceClassName\", \"org.postgresql.ds.PGSimpleDataSource\");\n+            props.setProperty(\"dataSource.serverName\", ip);\n+            props.setProperty(\"dataSource.portNumber\", Integer.toString(workConf.getPort()));\n+            props.setProperty(\"dataSource.user\", workConf.getDBUsername());\n+            props.setProperty(\"dataSource.password\", workConf.getDBPassword());\n+            props.setProperty(\"dataSource.databaseName\", workConf.getDBName());\n+            props.setProperty(\"maximumPoolSize\", Integer.toString(numConnections));\n+\n+            HikariConfig config = new HikariConfig(props);\n+            listDataSource.add(new HikariDataSource(config));\n+        }\n+    }\n \n-    /**\n-     *\n-     * @return\n-     * @throws SQLException\n-     */\n-    public final Connection makeConnection() throws SQLException {\n-        java.util.Properties props = new java.util.Properties();\n-        props.put(\"user\", workConf.getDBUsername());\n-        props.put(\"password\", workConf.getDBPassword());\n-        props.put(\"reWriteBatchedInserts\", \"true\");\n-\n-        List<String> dbConnections = workConf.getDBConnections();\n-        int r = (int)TPCCUtil.randomNumber(0, dbConnections.size() - 1, rng);\n-        Connection conn = DriverManager.getConnection(dbConnections.get(r), props);\n-        Catalog.setSeparator(conn);\n-        return (conn);\n+    private static AtomicInteger dataSourceCounter = new AtomicInteger(0);\n+    public final HikariDataSource getDataSource() {\n+        int r =  dataSourceCounter.getAndIncrement() % workConf.getNodes().size();", "originalCommit": "593c92326cccbf74baa84c2344c096c47541c843", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0NTMxMg==", "url": "https://github.com/yugabyte/tpcc/pull/25#discussion_r439245312", "bodyText": "Done", "author": "psudheer21", "createdAt": "2020-06-12T07:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEzMzY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "c6af2378b505889c9f0c281267627b7a46d70c5d", "chunk": "diff --git a/src/com/oltpbenchmark/api/BenchmarkModule.java b/src/com/oltpbenchmark/api/BenchmarkModule.java\nindex e240c44..72875b4 100644\n--- a/src/com/oltpbenchmark/api/BenchmarkModule.java\n+++ b/src/com/oltpbenchmark/api/BenchmarkModule.java\n\n@@ -130,7 +130,7 @@ public abstract class BenchmarkModule {\n \n     private static AtomicInteger dataSourceCounter = new AtomicInteger(0);\n     public final HikariDataSource getDataSource() {\n-        int r =  dataSourceCounter.getAndIncrement() % workConf.getNodes().size();\n+        int r = dataSourceCounter.getAndIncrement() % workConf.getNodes().size();\n         return listDataSource.get(r);\n     }\n \n"}}, {"oid": "c6af2378b505889c9f0c281267627b7a46d70c5d", "url": "https://github.com/yugabyte/tpcc/commit/c6af2378b505889c9f0c281267627b7a46d70c5d", "message": "Reformat code", "committedDate": "2020-06-12T07:07:09Z", "type": "commit"}, {"oid": "c6af2378b505889c9f0c281267627b7a46d70c5d", "url": "https://github.com/yugabyte/tpcc/commit/c6af2378b505889c9f0c281267627b7a46d70c5d", "message": "Reformat code", "committedDate": "2020-06-12T07:07:09Z", "type": "forcePushed"}]}