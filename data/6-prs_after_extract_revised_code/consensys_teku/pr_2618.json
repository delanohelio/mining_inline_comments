{"pr_number": 2618, "pr_title": "[Issue 2600] find a common ancestor slot to sync from", "pr_createdAt": "2020-08-19T03:25:10Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2618", "timeline": [{"oid": "80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "url": "https://github.com/ConsenSys/teku/commit/80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "message": "[Issue 2600] find a common ancestor slot to sync from\n\n - If there are at least 10_000 slots after the local finalized slot, interrogate a set of slots in the range of 3000-2000 behind our head slot, and see if there are any in common with the peer. If that finds a match, use that as the first slot to sync from. Otherwise, sync from the finalized checkpoint as previously.\n\n fixes #2600\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-19T03:24:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0MzMzMw==", "url": "https://github.com/ConsenSys/teku/pull/2618#discussion_r472643333", "bodyText": "10,000 slots seems like it's too many.  I wonder if we should just make this the same as optimistic history length. We only make one extra request if we trigger this logic so it's very cheap compared to downloading all the blocks since finalisation.", "author": "ajsutton", "createdAt": "2020-08-19T03:32:45Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.eth2.peers.PeerStatus;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseStreamListener;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class CommonAncestor {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MINIMUM_VIABLE_SLOTS = 10000;", "originalCommit": "80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\nindex cb527a7190..27f734e6d1 100644\n--- a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n+++ b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n\n@@ -25,50 +25,45 @@ import tech.pegasys.teku.storage.client.RecentChainData;\n \n public class CommonAncestor {\n   private static final Logger LOG = LogManager.getLogger();\n-  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n-  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n   private final RecentChainData storageClient;\n \n+  static final UInt64 OPTIMISTIC_HISTORY_LENGTH = UInt64.valueOf(3000);\n+  // prysm allows a maximum range of 1000 blocks (endSlot - startSlot) due to database limitations\n+  static final UInt64 MAX_BLOCK_RANGE = UInt64.valueOf(1000);\n+  static final UInt64 SAMPLE_RATE = UInt64.valueOf(50);\n+  static final UInt64 BLOCK_COUNT = MAX_BLOCK_RANGE.dividedBy(SAMPLE_RATE);\n+\n   public CommonAncestor(final RecentChainData storageClient) {\n     this.storageClient = storageClient;\n   }\n \n   public SafeFuture<UInt64> getCommonAncestor(\n       final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n-    final UInt64 localHead = storageClient.getHeadSlot();\n-    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n-    // data\n-    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n-        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n-      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n-      final UInt64 count = UInt64.valueOf(20);\n-      final UInt64 freq = UInt64.valueOf(50);\n-      final UInt64 firstRequestedSlot =\n-          localNonFinalisedSlotCount.isGreaterThanOrEqualTo(UInt64.valueOf(MINIMUM_VIABLE_SLOTS))\n-              ? localHead.minus(OPTIMISTIC_HISTORY_LENGTH)\n-              : firstNonFinalSlot;\n-      final UInt64 lastSlot = firstRequestedSlot.plus(count.times(freq));\n-      LOG.debug(\n-          \"Local head slot {}. Have {} non finalized slots, \"\n-              + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n-          localHead,\n-          localNonFinalisedSlotCount,\n-          freq,\n-          firstRequestedSlot,\n-          lastSlot,\n-          status.getHeadSlot());\n+    final UInt64 lowestHeadSlot = storageClient.getHeadSlot().min(status.getHeadSlot());\n+    if (lowestHeadSlot.isLessThan(firstNonFinalSlot.plus(OPTIMISTIC_HISTORY_LENGTH))) {\n+      return SafeFuture.completedFuture(firstNonFinalSlot);\n+    }\n \n-      final BestBlockListener blockListener =\n-          new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final UInt64 localNonFinalisedSlotCount = lowestHeadSlot.minus(firstNonFinalSlot);\n+    final UInt64 firstRequestedSlot = lowestHeadSlot.minus(OPTIMISTIC_HISTORY_LENGTH);\n+    final UInt64 lastSlot = firstRequestedSlot.plus(MAX_BLOCK_RANGE);\n \n-      final PeerSyncBlockRequest request =\n-          new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n+    LOG.debug(\n+        \"Local head slot {}. Have {} non finalized slots, \"\n+            + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n+        storageClient.getHeadSlot(),\n+        localNonFinalisedSlotCount,\n+        SAMPLE_RATE,\n+        firstRequestedSlot,\n+        lastSlot,\n+        status.getHeadSlot());\n \n-      return peer.requestBlocksByRange(firstRequestedSlot, count, freq, request)\n-          .thenApply(__ -> blockListener.getBestSlot());\n-    }\n+    final BestBlockListener blockListener = new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final PeerSyncBlockRequest request =\n+        new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n \n-    return SafeFuture.completedFuture(firstNonFinalSlot);\n+    return peer.requestBlocksByRange(firstRequestedSlot, BLOCK_COUNT, SAMPLE_RATE, request)\n+        .thenApply(__ -> blockListener.getBestSlot());\n   }\n \n   private static class BestBlockListener implements ResponseStreamListener<SignedBeaconBlock> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0Njc0OA==", "url": "https://github.com/ConsenSys/teku/pull/2618#discussion_r472646748", "bodyText": "I think we want localHead.min(status.getHeadSlot()) because in rare cases it's possible that the peer has a lower head slot but a higher finalised epoch which would cause us to sync to it.  This would be the case if 2/3rds of the Medalla validators all attested that there had been no blocks since finalisation stopped - head block would be back in epoch 2289 but the finalised epoch would be 3287.", "author": "ajsutton", "createdAt": "2020-08-19T03:38:47Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.eth2.peers.PeerStatus;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseStreamListener;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class CommonAncestor {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n+  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n+  private final RecentChainData storageClient;\n+\n+  public CommonAncestor(final RecentChainData storageClient) {\n+    this.storageClient = storageClient;\n+  }\n+\n+  public SafeFuture<UInt64> getCommonAncestor(\n+      final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n+    final UInt64 localHead = storageClient.getHeadSlot();", "originalCommit": "80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\nindex cb527a7190..27f734e6d1 100644\n--- a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n+++ b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n\n@@ -25,50 +25,45 @@ import tech.pegasys.teku.storage.client.RecentChainData;\n \n public class CommonAncestor {\n   private static final Logger LOG = LogManager.getLogger();\n-  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n-  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n   private final RecentChainData storageClient;\n \n+  static final UInt64 OPTIMISTIC_HISTORY_LENGTH = UInt64.valueOf(3000);\n+  // prysm allows a maximum range of 1000 blocks (endSlot - startSlot) due to database limitations\n+  static final UInt64 MAX_BLOCK_RANGE = UInt64.valueOf(1000);\n+  static final UInt64 SAMPLE_RATE = UInt64.valueOf(50);\n+  static final UInt64 BLOCK_COUNT = MAX_BLOCK_RANGE.dividedBy(SAMPLE_RATE);\n+\n   public CommonAncestor(final RecentChainData storageClient) {\n     this.storageClient = storageClient;\n   }\n \n   public SafeFuture<UInt64> getCommonAncestor(\n       final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n-    final UInt64 localHead = storageClient.getHeadSlot();\n-    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n-    // data\n-    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n-        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n-      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n-      final UInt64 count = UInt64.valueOf(20);\n-      final UInt64 freq = UInt64.valueOf(50);\n-      final UInt64 firstRequestedSlot =\n-          localNonFinalisedSlotCount.isGreaterThanOrEqualTo(UInt64.valueOf(MINIMUM_VIABLE_SLOTS))\n-              ? localHead.minus(OPTIMISTIC_HISTORY_LENGTH)\n-              : firstNonFinalSlot;\n-      final UInt64 lastSlot = firstRequestedSlot.plus(count.times(freq));\n-      LOG.debug(\n-          \"Local head slot {}. Have {} non finalized slots, \"\n-              + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n-          localHead,\n-          localNonFinalisedSlotCount,\n-          freq,\n-          firstRequestedSlot,\n-          lastSlot,\n-          status.getHeadSlot());\n+    final UInt64 lowestHeadSlot = storageClient.getHeadSlot().min(status.getHeadSlot());\n+    if (lowestHeadSlot.isLessThan(firstNonFinalSlot.plus(OPTIMISTIC_HISTORY_LENGTH))) {\n+      return SafeFuture.completedFuture(firstNonFinalSlot);\n+    }\n \n-      final BestBlockListener blockListener =\n-          new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final UInt64 localNonFinalisedSlotCount = lowestHeadSlot.minus(firstNonFinalSlot);\n+    final UInt64 firstRequestedSlot = lowestHeadSlot.minus(OPTIMISTIC_HISTORY_LENGTH);\n+    final UInt64 lastSlot = firstRequestedSlot.plus(MAX_BLOCK_RANGE);\n \n-      final PeerSyncBlockRequest request =\n-          new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n+    LOG.debug(\n+        \"Local head slot {}. Have {} non finalized slots, \"\n+            + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n+        storageClient.getHeadSlot(),\n+        localNonFinalisedSlotCount,\n+        SAMPLE_RATE,\n+        firstRequestedSlot,\n+        lastSlot,\n+        status.getHeadSlot());\n \n-      return peer.requestBlocksByRange(firstRequestedSlot, count, freq, request)\n-          .thenApply(__ -> blockListener.getBestSlot());\n-    }\n+    final BestBlockListener blockListener = new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final PeerSyncBlockRequest request =\n+        new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n \n-    return SafeFuture.completedFuture(firstNonFinalSlot);\n+    return peer.requestBlocksByRange(firstRequestedSlot, BLOCK_COUNT, SAMPLE_RATE, request)\n+        .thenApply(__ -> blockListener.getBestSlot());\n   }\n \n   private static class BestBlockListener implements ResponseStreamListener<SignedBeaconBlock> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0Nzc3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2618#discussion_r472647776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n          \n          \n            \n                    && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n          \n          \n            \n                if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n          \n          \n            \n                    && status.getHeadSlot().isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))) {\n          \n      \n    \n    \n  \n\nfor consistency", "author": "ajsutton", "createdAt": "2020-08-19T03:40:27Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.eth2.peers.PeerStatus;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseStreamListener;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class CommonAncestor {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n+  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n+  private final RecentChainData storageClient;\n+\n+  public CommonAncestor(final RecentChainData storageClient) {\n+    this.storageClient = storageClient;\n+  }\n+\n+  public SafeFuture<UInt64> getCommonAncestor(\n+      final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n+    final UInt64 localHead = storageClient.getHeadSlot();\n+    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n+    // data\n+    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n+        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {", "originalCommit": "80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MTU4MQ==", "url": "https://github.com/ConsenSys/teku/pull/2618#discussion_r472661581", "bodyText": "And probably invert the if condition so that we return early instead of having the whole method inside the if.", "author": "ajsutton", "createdAt": "2020-08-19T04:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY0Nzc3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\nindex cb527a7190..27f734e6d1 100644\n--- a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n+++ b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n\n@@ -25,50 +25,45 @@ import tech.pegasys.teku.storage.client.RecentChainData;\n \n public class CommonAncestor {\n   private static final Logger LOG = LogManager.getLogger();\n-  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n-  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n   private final RecentChainData storageClient;\n \n+  static final UInt64 OPTIMISTIC_HISTORY_LENGTH = UInt64.valueOf(3000);\n+  // prysm allows a maximum range of 1000 blocks (endSlot - startSlot) due to database limitations\n+  static final UInt64 MAX_BLOCK_RANGE = UInt64.valueOf(1000);\n+  static final UInt64 SAMPLE_RATE = UInt64.valueOf(50);\n+  static final UInt64 BLOCK_COUNT = MAX_BLOCK_RANGE.dividedBy(SAMPLE_RATE);\n+\n   public CommonAncestor(final RecentChainData storageClient) {\n     this.storageClient = storageClient;\n   }\n \n   public SafeFuture<UInt64> getCommonAncestor(\n       final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n-    final UInt64 localHead = storageClient.getHeadSlot();\n-    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n-    // data\n-    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n-        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n-      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n-      final UInt64 count = UInt64.valueOf(20);\n-      final UInt64 freq = UInt64.valueOf(50);\n-      final UInt64 firstRequestedSlot =\n-          localNonFinalisedSlotCount.isGreaterThanOrEqualTo(UInt64.valueOf(MINIMUM_VIABLE_SLOTS))\n-              ? localHead.minus(OPTIMISTIC_HISTORY_LENGTH)\n-              : firstNonFinalSlot;\n-      final UInt64 lastSlot = firstRequestedSlot.plus(count.times(freq));\n-      LOG.debug(\n-          \"Local head slot {}. Have {} non finalized slots, \"\n-              + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n-          localHead,\n-          localNonFinalisedSlotCount,\n-          freq,\n-          firstRequestedSlot,\n-          lastSlot,\n-          status.getHeadSlot());\n+    final UInt64 lowestHeadSlot = storageClient.getHeadSlot().min(status.getHeadSlot());\n+    if (lowestHeadSlot.isLessThan(firstNonFinalSlot.plus(OPTIMISTIC_HISTORY_LENGTH))) {\n+      return SafeFuture.completedFuture(firstNonFinalSlot);\n+    }\n \n-      final BestBlockListener blockListener =\n-          new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final UInt64 localNonFinalisedSlotCount = lowestHeadSlot.minus(firstNonFinalSlot);\n+    final UInt64 firstRequestedSlot = lowestHeadSlot.minus(OPTIMISTIC_HISTORY_LENGTH);\n+    final UInt64 lastSlot = firstRequestedSlot.plus(MAX_BLOCK_RANGE);\n \n-      final PeerSyncBlockRequest request =\n-          new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n+    LOG.debug(\n+        \"Local head slot {}. Have {} non finalized slots, \"\n+            + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n+        storageClient.getHeadSlot(),\n+        localNonFinalisedSlotCount,\n+        SAMPLE_RATE,\n+        firstRequestedSlot,\n+        lastSlot,\n+        status.getHeadSlot());\n \n-      return peer.requestBlocksByRange(firstRequestedSlot, count, freq, request)\n-          .thenApply(__ -> blockListener.getBestSlot());\n-    }\n+    final BestBlockListener blockListener = new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final PeerSyncBlockRequest request =\n+        new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n \n-    return SafeFuture.completedFuture(firstNonFinalSlot);\n+    return peer.requestBlocksByRange(firstRequestedSlot, BLOCK_COUNT, SAMPLE_RATE, request)\n+        .thenApply(__ -> blockListener.getBestSlot());\n   }\n \n   private static class BestBlockListener implements ResponseStreamListener<SignedBeaconBlock> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY1OTIxOA==", "url": "https://github.com/ConsenSys/teku/pull/2618#discussion_r472659218", "bodyText": "Probably make these constants and show the calculation - ie that it's important they total just 1000 slots, and with a comment about Prysm's limitations.", "author": "ajsutton", "createdAt": "2020-08-19T03:59:09Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.eth2.peers.PeerStatus;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseStreamListener;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class CommonAncestor {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n+  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n+  private final RecentChainData storageClient;\n+\n+  public CommonAncestor(final RecentChainData storageClient) {\n+    this.storageClient = storageClient;\n+  }\n+\n+  public SafeFuture<UInt64> getCommonAncestor(\n+      final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n+    final UInt64 localHead = storageClient.getHeadSlot();\n+    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n+    // data\n+    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n+        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n+      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n+      final UInt64 count = UInt64.valueOf(20);\n+      final UInt64 freq = UInt64.valueOf(50);", "originalCommit": "80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\nindex cb527a7190..27f734e6d1 100644\n--- a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n+++ b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n\n@@ -25,50 +25,45 @@ import tech.pegasys.teku.storage.client.RecentChainData;\n \n public class CommonAncestor {\n   private static final Logger LOG = LogManager.getLogger();\n-  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n-  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n   private final RecentChainData storageClient;\n \n+  static final UInt64 OPTIMISTIC_HISTORY_LENGTH = UInt64.valueOf(3000);\n+  // prysm allows a maximum range of 1000 blocks (endSlot - startSlot) due to database limitations\n+  static final UInt64 MAX_BLOCK_RANGE = UInt64.valueOf(1000);\n+  static final UInt64 SAMPLE_RATE = UInt64.valueOf(50);\n+  static final UInt64 BLOCK_COUNT = MAX_BLOCK_RANGE.dividedBy(SAMPLE_RATE);\n+\n   public CommonAncestor(final RecentChainData storageClient) {\n     this.storageClient = storageClient;\n   }\n \n   public SafeFuture<UInt64> getCommonAncestor(\n       final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n-    final UInt64 localHead = storageClient.getHeadSlot();\n-    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n-    // data\n-    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n-        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n-      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n-      final UInt64 count = UInt64.valueOf(20);\n-      final UInt64 freq = UInt64.valueOf(50);\n-      final UInt64 firstRequestedSlot =\n-          localNonFinalisedSlotCount.isGreaterThanOrEqualTo(UInt64.valueOf(MINIMUM_VIABLE_SLOTS))\n-              ? localHead.minus(OPTIMISTIC_HISTORY_LENGTH)\n-              : firstNonFinalSlot;\n-      final UInt64 lastSlot = firstRequestedSlot.plus(count.times(freq));\n-      LOG.debug(\n-          \"Local head slot {}. Have {} non finalized slots, \"\n-              + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n-          localHead,\n-          localNonFinalisedSlotCount,\n-          freq,\n-          firstRequestedSlot,\n-          lastSlot,\n-          status.getHeadSlot());\n+    final UInt64 lowestHeadSlot = storageClient.getHeadSlot().min(status.getHeadSlot());\n+    if (lowestHeadSlot.isLessThan(firstNonFinalSlot.plus(OPTIMISTIC_HISTORY_LENGTH))) {\n+      return SafeFuture.completedFuture(firstNonFinalSlot);\n+    }\n \n-      final BestBlockListener blockListener =\n-          new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final UInt64 localNonFinalisedSlotCount = lowestHeadSlot.minus(firstNonFinalSlot);\n+    final UInt64 firstRequestedSlot = lowestHeadSlot.minus(OPTIMISTIC_HISTORY_LENGTH);\n+    final UInt64 lastSlot = firstRequestedSlot.plus(MAX_BLOCK_RANGE);\n \n-      final PeerSyncBlockRequest request =\n-          new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n+    LOG.debug(\n+        \"Local head slot {}. Have {} non finalized slots, \"\n+            + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n+        storageClient.getHeadSlot(),\n+        localNonFinalisedSlotCount,\n+        SAMPLE_RATE,\n+        firstRequestedSlot,\n+        lastSlot,\n+        status.getHeadSlot());\n \n-      return peer.requestBlocksByRange(firstRequestedSlot, count, freq, request)\n-          .thenApply(__ -> blockListener.getBestSlot());\n-    }\n+    final BestBlockListener blockListener = new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final PeerSyncBlockRequest request =\n+        new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n \n-    return SafeFuture.completedFuture(firstNonFinalSlot);\n+    return peer.requestBlocksByRange(firstRequestedSlot, BLOCK_COUNT, SAMPLE_RATE, request)\n+        .thenApply(__ -> blockListener.getBestSlot());\n   }\n \n   private static class BestBlockListener implements ResponseStreamListener<SignedBeaconBlock> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjY2MDk3NQ==", "url": "https://github.com/ConsenSys/teku/pull/2618#discussion_r472660975", "bodyText": "nit: Make MINIMUM_VIABLE_SLOTS a UInt in the constant to make this more readable.", "author": "ajsutton", "createdAt": "2020-08-19T04:01:53Z", "path": "sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.teku.networking.eth2.peers.PeerStatus;\n+import tech.pegasys.teku.networking.eth2.rpc.core.ResponseStreamListener;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class CommonAncestor {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n+  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n+  private final RecentChainData storageClient;\n+\n+  public CommonAncestor(final RecentChainData storageClient) {\n+    this.storageClient = storageClient;\n+  }\n+\n+  public SafeFuture<UInt64> getCommonAncestor(\n+      final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n+    final UInt64 localHead = storageClient.getHeadSlot();\n+    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n+    // data\n+    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n+        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n+      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n+      final UInt64 count = UInt64.valueOf(20);\n+      final UInt64 freq = UInt64.valueOf(50);\n+      final UInt64 firstRequestedSlot =\n+          localNonFinalisedSlotCount.isGreaterThanOrEqualTo(UInt64.valueOf(MINIMUM_VIABLE_SLOTS))", "originalCommit": "80804f421c9b90ff7c27c88d5a791b40f8ed84c9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\nindex cb527a7190..27f734e6d1 100644\n--- a/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n+++ b/sync/src/main/java/tech/pegasys/teku/sync/CommonAncestor.java\n\n@@ -25,50 +25,45 @@ import tech.pegasys.teku.storage.client.RecentChainData;\n \n public class CommonAncestor {\n   private static final Logger LOG = LogManager.getLogger();\n-  private static final int MINIMUM_VIABLE_SLOTS = 10000;\n-  private static final int OPTIMISTIC_HISTORY_LENGTH = 3000;\n   private final RecentChainData storageClient;\n \n+  static final UInt64 OPTIMISTIC_HISTORY_LENGTH = UInt64.valueOf(3000);\n+  // prysm allows a maximum range of 1000 blocks (endSlot - startSlot) due to database limitations\n+  static final UInt64 MAX_BLOCK_RANGE = UInt64.valueOf(1000);\n+  static final UInt64 SAMPLE_RATE = UInt64.valueOf(50);\n+  static final UInt64 BLOCK_COUNT = MAX_BLOCK_RANGE.dividedBy(SAMPLE_RATE);\n+\n   public CommonAncestor(final RecentChainData storageClient) {\n     this.storageClient = storageClient;\n   }\n \n   public SafeFuture<UInt64> getCommonAncestor(\n       final Eth2Peer peer, final PeerStatus status, final UInt64 firstNonFinalSlot) {\n-    final UInt64 localHead = storageClient.getHeadSlot();\n-    // more than 10000 blocks behind, try to find a better starting slot if we have non finalized\n-    // data\n-    if (localHead.isGreaterThanOrEqualTo(firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS))\n-        && firstNonFinalSlot.plus(MINIMUM_VIABLE_SLOTS).isLessThan(status.getHeadSlot())) {\n-      final UInt64 localNonFinalisedSlotCount = localHead.minus(firstNonFinalSlot);\n-      final UInt64 count = UInt64.valueOf(20);\n-      final UInt64 freq = UInt64.valueOf(50);\n-      final UInt64 firstRequestedSlot =\n-          localNonFinalisedSlotCount.isGreaterThanOrEqualTo(UInt64.valueOf(MINIMUM_VIABLE_SLOTS))\n-              ? localHead.minus(OPTIMISTIC_HISTORY_LENGTH)\n-              : firstNonFinalSlot;\n-      final UInt64 lastSlot = firstRequestedSlot.plus(count.times(freq));\n-      LOG.debug(\n-          \"Local head slot {}. Have {} non finalized slots, \"\n-              + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n-          localHead,\n-          localNonFinalisedSlotCount,\n-          freq,\n-          firstRequestedSlot,\n-          lastSlot,\n-          status.getHeadSlot());\n+    final UInt64 lowestHeadSlot = storageClient.getHeadSlot().min(status.getHeadSlot());\n+    if (lowestHeadSlot.isLessThan(firstNonFinalSlot.plus(OPTIMISTIC_HISTORY_LENGTH))) {\n+      return SafeFuture.completedFuture(firstNonFinalSlot);\n+    }\n \n-      final BestBlockListener blockListener =\n-          new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final UInt64 localNonFinalisedSlotCount = lowestHeadSlot.minus(firstNonFinalSlot);\n+    final UInt64 firstRequestedSlot = lowestHeadSlot.minus(OPTIMISTIC_HISTORY_LENGTH);\n+    final UInt64 lastSlot = firstRequestedSlot.plus(MAX_BLOCK_RANGE);\n \n-      final PeerSyncBlockRequest request =\n-          new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n+    LOG.debug(\n+        \"Local head slot {}. Have {} non finalized slots, \"\n+            + \"will sample ahead every {} slots from {} to {}. Peer head is {}\",\n+        storageClient.getHeadSlot(),\n+        localNonFinalisedSlotCount,\n+        SAMPLE_RATE,\n+        firstRequestedSlot,\n+        lastSlot,\n+        status.getHeadSlot());\n \n-      return peer.requestBlocksByRange(firstRequestedSlot, count, freq, request)\n-          .thenApply(__ -> blockListener.getBestSlot());\n-    }\n+    final BestBlockListener blockListener = new BestBlockListener(storageClient, firstNonFinalSlot);\n+    final PeerSyncBlockRequest request =\n+        new PeerSyncBlockRequest(SafeFuture.COMPLETE, lastSlot, blockListener);\n \n-    return SafeFuture.completedFuture(firstNonFinalSlot);\n+    return peer.requestBlocksByRange(firstRequestedSlot, BLOCK_COUNT, SAMPLE_RATE, request)\n+        .thenApply(__ -> blockListener.getBestSlot());\n   }\n \n   private static class BestBlockListener implements ResponseStreamListener<SignedBeaconBlock> {\n"}}, {"oid": "04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "url": "https://github.com/ConsenSys/teku/commit/04318b62f285824876fe0e0a89fb2a9e51aa5bc8", "message": "review feedback.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-19T05:26:53Z", "type": "commit"}, {"oid": "3a084b0228d6951670d0a7cfbcd8dfe6f029e29a", "url": "https://github.com/ConsenSys/teku/commit/3a084b0228d6951670d0a7cfbcd8dfe6f029e29a", "message": "Merge remote-tracking branch 'upstream/master' into optimistic-sync", "committedDate": "2020-08-19T05:36:15Z", "type": "commit"}]}