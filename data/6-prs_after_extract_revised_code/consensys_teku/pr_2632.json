{"pr_number": 2632, "pr_title": "Do not add attestations from different forks to produced block", "pr_createdAt": "2020-08-20T13:25:02Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2632", "timeline": [{"oid": "ae442afc3f4488684ee6503624208ab2a9f072cf", "url": "https://github.com/ConsenSys/teku/commit/ae442afc3f4488684ee6503624208ab2a9f072cf", "message": "Do not add attestations from different forks to produced block", "committedDate": "2020-08-20T12:50:36Z", "type": "commit"}, {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a", "url": "https://github.com/ConsenSys/teku/commit/f5eabee0d97e6ed77d5288232100bc2d7680040a", "message": "Run spotless", "committedDate": "2020-08-20T13:26:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474332501", "bodyText": "I think we should simplify this further to just store the randao rather than spending time calculating the entire shuffling seed.  If the randao matches, the shuffling seed will as well.  So just:\nget_randao_mix(state, compute_epoch_at_slot(attestation.getData().getSlot()))", "author": "ajsutton", "createdAt": "2020-08-20T23:51:59Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +56,37 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed;\n+  }\n+\n+  public Bytes32 getCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveCommitteeShufflingSeed(BeaconState state) {\n+    Bytes32 committeeShufflingSeed =\n+        get_seed(\n+            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);", "originalCommit": "f5eabee0d97e6ed77d5288232100bc2d7680040a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNzA2MQ==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474337061", "bodyText": "Sorry, this is wrong - we need to do the same randaoIndex calculation as in get_seed so worth extracting that bit of get_seed as a method we can reuse but it effectively becomes:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Bytes32 committeeShufflingSeed =\n          \n          \n            \n                    get_seed(\n          \n          \n            \n                        state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);\n          \n          \n            \n                UInt64 epoch = compute_epoch_at_slot(attestation.getData().getSlot());\n          \n          \n            \n                UInt64 randaoIndex = epoch.plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n          \n          \n            \n                return get_randao_mix(state, randaoIndex);", "author": "ajsutton", "createdAt": "2020-08-21T00:08:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM0MTA0Mw==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474341043", "bodyText": "Following conversation with Proto, sticking with seed probably does make sense - just make sure that we calculate the seed for the block only once, not once per attestation or group.", "author": "ajsutton", "createdAt": "2020-08-21T00:22:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4OTU2OA==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474489568", "bodyText": "Makes sense to me.", "author": "cemozerr", "createdAt": "2020-08-21T07:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5MjIyNA==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474492224", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-08-21T07:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "8eeaa55fca2301aecf5465ef7946d1ea5eb4650f", "chunk": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java b/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\nindex d1585bac7..67a9424f2 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\n\n@@ -67,26 +68,27 @@ public class ValidateableAttestation {\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n-    return maybeCommitteeShufflingSeed;\n+  public Optional<Bytes32> getMaybeRandaoMix() {\n+    return maybeRandaoMix;\n   }\n \n-  public Bytes32 getCommitteeShufflingSeed() {\n-    return maybeCommitteeShufflingSeed.orElseThrow(\n+  public Bytes32 getRandaoMix() {\n+    return maybeRandaoMix.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n-                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+                \"ValidateableAttestation does not have a randao mix yet.\"));\n   }\n \n   public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n     this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n   }\n \n-  public void saveCommitteeShufflingSeed(BeaconState state) {\n-    Bytes32 committeeShufflingSeed =\n-        get_seed(\n-            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);\n-    this.maybeCommitteeShufflingSeed = Optional.of(committeeShufflingSeed);\n+  public void saveRandaoMix(BeaconState state) {\n+    UInt64 randaoIndex =\n+        compute_epoch_at_slot(attestation.getData().getSlot())\n+            .plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n+    Bytes32 mix = get_randao_mix(state, randaoIndex);\n+    this.maybeRandaoMix = Optional.of(mix);\n   }\n \n   public boolean markGossiped() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzM1NQ==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474333355", "bodyText": "We should apply this filter to the MatchingDataAttestationGroup as a whole rather than to every individual attestation.  If the attestation data matches and the signature is valid (both already checked), then either the entire group can be included, or the entire group can be excluded because they're all pointing to the same block root.\nAnd we should get the randao for the block's state prior to this stream so that we only get it once rather than for every group.", "author": "ajsutton", "createdAt": "2020-08-20T23:55:08Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java", "diffHunk": "@@ -126,11 +129,23 @@ public int getSize() {\n         .filter(group -> isValid(stateAtBlockSlot, group.getAttestationData()))\n         .flatMap(MatchingDataAttestationGroup::stream)\n         .limit(attestations.getMaxSize())\n+        .filter(attestation -> fromCorrectFork(stateAtBlockSlot, attestation))", "originalCommit": "f5eabee0d97e6ed77d5288232100bc2d7680040a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDA4MQ==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474544081", "bodyText": "The slot of the attestation data is important for the randao mix, so we have to get it for every group. Because different attestation groups might be from different epochs.\nMaybe if only attestation groups that point to the last two epochs are valid, we could get the randao mixes for those two epochs, and check if any groups randao mixes match those.", "author": "cemozerr", "createdAt": "2020-08-21T08:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDM3OQ==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474544379", "bodyText": "Applying the filter to the Group as a whole makes sense to me.", "author": "cemozerr", "createdAt": "2020-08-21T08:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8eeaa55fca2301aecf5465ef7946d1ea5eb4650f", "chunk": "diff --git a/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java b/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java\nindex c9a22392e..b29ae7159 100644\n--- a/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java\n+++ b/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java\n\n@@ -143,7 +143,7 @@ public class AggregatingAttestationPool implements SlotEventsChannel {\n             compute_epoch_at_slot(validateableAttestation.getData().getSlot()),\n             DOMAIN_BEACON_ATTESTER);\n \n-    return committeeShufflingSeed.equals(validateableAttestation.getCommitteeShufflingSeed());\n+    return committeeShufflingSeed.equals(validateableAttestation.getRandaoMix());\n   }\n \n   private boolean isValid(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNTE3MA==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474335170", "bodyText": "This is going to destroy us performance-wise.   We will suddenly be missing checkpoint state caches a whole lot more.\nGiven that the target checkpoint must be for the epoch matching the slot we should continue using the state for the target state.  ie from ForkChoiceUtil.validateOnAttestation:\n    if (!target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot()))) {\n      return AttestationProcessingResult.invalid(\"Attestation slot must be within specified epoch\");\n    }\n\nRemember that if the randao in the state we validate against was different to the one used when creating the attestation, the signature would be invalid because the committees wouldn't match up.  So we can safely validate against any state from one epoch prior to the attestation's slot.", "author": "ajsutton", "createdAt": "2020-08-21T00:01:27Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -136,15 +136,18 @@ private void processHead(Optional<UInt64> nodeSlot) {\n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n-        .retrieveCheckpointState(attestation.getData().getTarget())\n+        .retrieveBlockState(attestation.getData().getBeacon_block_root())", "originalCommit": "f5eabee0d97e6ed77d5288232100bc2d7680040a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NjI5Mg==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474556292", "bodyText": "I had forgotten the rule above, i.e. target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot()), in light of that, what you say makes total sense.", "author": "cemozerr", "createdAt": "2020-08-21T09:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNTE3MA=="}], "type": "inlineReview", "revised_code": {"commit": "31e4fe2e5c445d65163d4133a2110d6c41c734ec", "chunk": "diff --git a/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java b/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java\nindex b06995889..15f67ff68 100644\n--- a/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java\n+++ b/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java\n\n@@ -136,18 +136,15 @@ public class ForkChoice {\n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n-        .retrieveBlockState(attestation.getData().getBeacon_block_root())\n+        .retrieveCheckpointState(attestation.getData().getTarget())\n         .thenCompose(\n-            attestedBlockState ->\n+            targetBlockState ->\n                 withLock(\n                     () -> {\n                       final StoreTransaction transaction = recentChainData.startStoreTransaction();\n                       final AttestationProcessingResult result =\n                           on_attestation(\n-                              transaction,\n-                              attestation,\n-                              attestedBlockState,\n-                              getForkChoiceStrategy());\n+                              transaction, attestation, targetBlockState, getForkChoiceStrategy());\n                       return result.isSuccessful()\n                           ? transaction.commit().thenApply(__ -> result)\n                           : SafeFuture.completedFuture(result);\n"}}, {"oid": "8eeaa55fca2301aecf5465ef7946d1ea5eb4650f", "url": "https://github.com/ConsenSys/teku/commit/8eeaa55fca2301aecf5465ef7946d1ea5eb4650f", "message": "Use randao mix instead of the seed", "committedDate": "2020-08-21T07:57:22Z", "type": "commit"}, {"oid": "31e4fe2e5c445d65163d4133a2110d6c41c734ec", "url": "https://github.com/ConsenSys/teku/commit/31e4fe2e5c445d65163d4133a2110d6c41c734ec", "message": "Check randao mix of attestation group", "committedDate": "2020-08-21T10:18:38Z", "type": "commit"}, {"oid": "6ee9d197f7e4fb4ced405d6a05d9ea6b0f079073", "url": "https://github.com/ConsenSys/teku/commit/6ee9d197f7e4fb4ced405d6a05d9ea6b0f079073", "message": "Merge branch 'master' into checkAttestationForkBeforeIncludingInBlock", "committedDate": "2020-08-21T10:19:09Z", "type": "commit"}, {"oid": "4e714a0e727d5cd0115667a283d9c2b9c0ea9c6c", "url": "https://github.com/ConsenSys/teku/commit/4e714a0e727d5cd0115667a283d9c2b9c0ea9c6c", "message": "Implement ForkChecker and fix tests", "committedDate": "2020-08-21T12:50:57Z", "type": "commit"}, {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442", "url": "https://github.com/ConsenSys/teku/commit/8637bc4b5ef53d394ac63d2431d8ffa3ff622442", "message": "Add test specific for AggregatingAttestationsPool", "committedDate": "2020-08-21T13:11:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475926343", "bodyText": "It may be cleaner to just call attestation.saveRandoMix here and have the method do nothing if it already has a randaoMix saved.  Otherwise it takes a bit of reasoning to understand why the absence of an indexed attestation means we need to save randao mix.", "author": "ajsutton", "createdAt": "2020-08-24T22:19:57Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -399,6 +402,11 @@ private static AttestationProcessingResult indexAndValidateAttestation(\n         .ifSuccessful(\n             () -> {\n               attestation.setIndexedAttestation(indexedAttestation);\n+\n+              if (attestation.getMaybeIndexedAttestation().isEmpty()) {\n+                attestation.saveRandaoMix(targetState);\n+              }", "originalCommit": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMzkzNA==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475933934", "bodyText": "My bad, I was actually trying to call attestation.getMaybeRandaoMix().isEmpty()", "author": "cemozerr", "createdAt": "2020-08-24T22:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzNDEzMA==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475934130", "bodyText": "But your suggestion below makes sense. I'll apply that one.", "author": "cemozerr", "createdAt": "2020-08-24T22:42:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3OTEyMA==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r476279120", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-08-25T08:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d7b4399a976bf116ae0e4ef1e4dd3c02a74e19a5", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java b/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java\nindex 3e0f29d63..cfba34083 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java\n+++ b/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java\n\n@@ -402,10 +403,7 @@ public class ForkChoiceUtil {\n         .ifSuccessful(\n             () -> {\n               attestation.setIndexedAttestation(indexedAttestation);\n-\n-              if (attestation.getMaybeIndexedAttestation().isEmpty()) {\n-                attestation.saveRandaoMix(targetState);\n-              }\n+              attestation.saveRandaoMix(targetState);\n \n               return SUCCESSFUL;\n             });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTQ0Nw==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475929447", "bodyText": "I'm not really a fan of the Maybe in these method names.  I'd be tempted to just move to having a single getRandaoMix which returns an optional and do the orElseThrow in the caller if desired (and same for getIndexedAttestation).", "author": "ajsutton", "createdAt": "2020-08-24T22:28:21Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +57,38 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeRandaoMix() {", "originalCommit": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5MjM2Mg==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r476292362", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-08-25T09:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTQ0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d7b4399a976bf116ae0e4ef1e4dd3c02a74e19a5", "chunk": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java b/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\nindex 67a9424f2..a8e9da28e 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\n\n@@ -84,6 +85,10 @@ public class ValidateableAttestation {\n   }\n \n   public void saveRandaoMix(BeaconState state) {\n+    if (maybeRandaoMix.isPresent()) {\n+      return;\n+    }\n+\n     UInt64 randaoIndex =\n         compute_epoch_at_slot(attestation.getData().getSlot())\n             .plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTc3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475929777", "bodyText": "Didn't we circle back round to storing the seed? Sorry, I know I said randao mix but I was overthinking the performance implications I think.  As long as we don't have to calculate a seed for every attestation when producing blocks it will be fine.", "author": "ajsutton", "createdAt": "2020-08-24T22:29:19Z", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +57,38 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeRandaoMix() {\n+    return maybeRandaoMix;\n+  }\n+\n+  public Bytes32 getRandaoMix() {\n+    return maybeRandaoMix.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a randao mix yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveRandaoMix(BeaconState state) {\n+    UInt64 randaoIndex =\n+        compute_epoch_at_slot(attestation.getData().getSlot())\n+            .plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n+    Bytes32 mix = get_randao_mix(state, randaoIndex);\n+    this.maybeRandaoMix = Optional.of(mix);", "originalCommit": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMzNDY5Mg==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r476334692", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-08-25T10:08:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTc3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "d7b4399a976bf116ae0e4ef1e4dd3c02a74e19a5", "chunk": "diff --git a/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java b/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\nindex 67a9424f2..a8e9da28e 100644\n--- a/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\n+++ b/ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java\n\n@@ -84,6 +85,10 @@ public class ValidateableAttestation {\n   }\n \n   public void saveRandaoMix(BeaconState state) {\n+    if (maybeRandaoMix.isPresent()) {\n+      return;\n+    }\n+\n     UInt64 randaoIndex =\n         compute_epoch_at_slot(attestation.getData().getSlot())\n             .plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMDYwMw==", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475930603", "bodyText": "Good idea to make this its own class.", "author": "ajsutton", "createdAt": "2020-08-24T22:31:38Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition.attestation;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_randao_mix;\n+import static tech.pegasys.teku.util.config.Constants.EPOCHS_PER_HISTORICAL_VECTOR;\n+import static tech.pegasys.teku.util.config.Constants.MIN_SEED_LOOKAHEAD;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class AttestationForkChecker {", "originalCommit": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "30bc6e024891c163075359829e353c2c1dc1e6de", "chunk": "diff --git a/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java b/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java\nindex 7aa88a153..b63d293d5 100644\n--- a/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java\n+++ b/ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java\n\n@@ -13,37 +13,35 @@\n \n package tech.pegasys.teku.statetransition.attestation;\n \n-import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n-import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_randao_mix;\n-import static tech.pegasys.teku.util.config.Constants.EPOCHS_PER_HISTORICAL_VECTOR;\n-import static tech.pegasys.teku.util.config.Constants.MIN_SEED_LOOKAHEAD;\n-\n-import java.util.HashSet;\n-import java.util.Set;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n \n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_seed;\n+import static tech.pegasys.teku.util.config.Constants.DOMAIN_BEACON_ATTESTER;\n+\n public class AttestationForkChecker {\n \n-  private final Set<Bytes32> validRandaoMixes = new HashSet<>();\n+  private final Set<Bytes32> validCommitteeShufflingSeeds = new HashSet<>();\n \n-  public AttestationForkChecker(BeaconState currentState) {\n+  public AttestationForkChecker(BeaconState state) {\n \n-    UInt64 currentStateEpoch = compute_epoch_at_slot(currentState.getSlot());\n-    UInt64 randaoIndexCurrentEpoch =\n-        currentStateEpoch.plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n-    UInt64 randaoIndexPreviousEpoch =\n-        currentStateEpoch.plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 2);\n+    UInt64 epoch = compute_epoch_at_slot(state.getSlot());\n+    Bytes32 currentEpochSeed = get_seed(state, epoch, DOMAIN_BEACON_ATTESTER);\n+    validCommitteeShufflingSeeds.add(currentEpochSeed);\n \n-    Bytes32 randaoMixCurrentEpoch = get_randao_mix(currentState, randaoIndexCurrentEpoch);\n-    Bytes32 randaoMixPreviousEpoch = get_randao_mix(currentState, randaoIndexPreviousEpoch);\n-    validRandaoMixes.add(randaoMixCurrentEpoch);\n-    validRandaoMixes.add(randaoMixPreviousEpoch);\n+    if (epoch != UInt64.ZERO) {\n+      Bytes32 previousEpochSeed = get_seed(state, epoch.minus(UInt64.ONE), DOMAIN_BEACON_ATTESTER);\n+      validCommitteeShufflingSeeds.add(previousEpochSeed);\n+    }\n   }\n \n   public boolean areAttestationsFromCorrectFork(\n       final MatchingDataAttestationGroup attestationGroup) {\n-    return validRandaoMixes.contains(attestationGroup.getRandaoMix());\n+    return validCommitteeShufflingSeeds.contains(attestationGroup.getCommitteeShufflingSeed());\n   }\n }\n"}}, {"oid": "d7b4399a976bf116ae0e4ef1e4dd3c02a74e19a5", "url": "https://github.com/ConsenSys/teku/commit/d7b4399a976bf116ae0e4ef1e4dd3c02a74e19a5", "message": "Directly call save randao mix method", "committedDate": "2020-08-25T08:39:46Z", "type": "commit"}, {"oid": "1a3c3898a8eb59b7484db1b4e7e73043209678cc", "url": "https://github.com/ConsenSys/teku/commit/1a3c3898a8eb59b7484db1b4e7e73043209678cc", "message": "Run spotless", "committedDate": "2020-08-25T08:40:12Z", "type": "commit"}, {"oid": "a89cc112771d08225f6309e93a0d20ad6e1d34ec", "url": "https://github.com/ConsenSys/teku/commit/a89cc112771d08225f6309e93a0d20ad6e1d34ec", "message": "Remove maybe methods", "committedDate": "2020-08-25T09:00:43Z", "type": "commit"}, {"oid": "30bc6e024891c163075359829e353c2c1dc1e6de", "url": "https://github.com/ConsenSys/teku/commit/30bc6e024891c163075359829e353c2c1dc1e6de", "message": "Revert back to using seed as distinct fork identifier", "committedDate": "2020-08-25T09:55:37Z", "type": "commit"}, {"oid": "95a3543fe2cfde8759a11ddb8a9c7187d4c6e64d", "url": "https://github.com/ConsenSys/teku/commit/95a3543fe2cfde8759a11ddb8a9c7187d4c6e64d", "message": "Run spotless", "committedDate": "2020-08-25T09:56:48Z", "type": "commit"}, {"oid": "4736955ee953b281e3c0daecbc3d1f3200752e87", "url": "https://github.com/ConsenSys/teku/commit/4736955ee953b281e3c0daecbc3d1f3200752e87", "message": "Fix equality check bug", "committedDate": "2020-08-25T10:02:22Z", "type": "commit"}, {"oid": "7b059e5f1fd6c99c9cbe0483ff6ae1d31bfa2e13", "url": "https://github.com/ConsenSys/teku/commit/7b059e5f1fd6c99c9cbe0483ff6ae1d31bfa2e13", "message": "Merge remote-tracking branch 'remotes/origin/master' into checkAttestationForkBeforeIncludingInBlock\n\n# Conflicts:\n#\tethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "committedDate": "2020-08-25T10:04:37Z", "type": "commit"}]}