{"pr_number": 1118, "pr_title": "[BC-202] Fetch unknown ancestor blocks", "pr_createdAt": "2020-01-28T16:49:42Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1118", "timeline": [{"oid": "095be470ff78a51d7e3cadac0587a9301f5c57f4", "url": "https://github.com/ConsenSys/teku/commit/095be470ff78a51d7e3cadac0587a9301f5c57f4", "message": "Start working on service to fetch recent blocks", "committedDate": "2020-01-27T20:08:49Z", "type": "commit"}, {"oid": "4519de70a6f77f06b0216dad64ae36ea5093cbfe", "url": "https://github.com/ConsenSys/teku/commit/4519de70a6f77f06b0216dad64ae36ea5093cbfe", "message": "Drop invalid blocks so that we can clear out invalid block requests", "committedDate": "2020-01-27T20:08:49Z", "type": "commit"}, {"oid": "b16c4379f29530d3b9796981ba1d1cb1f728cd85", "url": "https://github.com/ConsenSys/teku/commit/b16c4379f29530d3b9796981ba1d1cb1f728cd85", "message": "Add tests for FetchBlockTask", "committedDate": "2020-01-27T20:08:49Z", "type": "commit"}, {"oid": "095176ad71f56d17dcea4018b6141ad9dc4d5ec0", "url": "https://github.com/ConsenSys/teku/commit/095176ad71f56d17dcea4018b6141ad9dc4d5ec0", "message": "Cleanup names", "committedDate": "2020-01-27T20:08:49Z", "type": "commit"}, {"oid": "17b632857e1687ae81163601da232d8245f48653", "url": "https://github.com/ConsenSys/teku/commit/17b632857e1687ae81163601da232d8245f48653", "message": "Add retry test, fix calculation", "committedDate": "2020-01-27T21:06:29Z", "type": "commit"}, {"oid": "4277f2c8e9a262712d2fdae24f63f408ff0263d6", "url": "https://github.com/ConsenSys/teku/commit/4277f2c8e9a262712d2fdae24f63f408ff0263d6", "message": "Fix typo", "committedDate": "2020-01-27T23:14:25Z", "type": "commit"}, {"oid": "cfb1dd01902748e406d8ad115a6fcf21f5059146", "url": "https://github.com/ConsenSys/teku/commit/cfb1dd01902748e406d8ad115a6fcf21f5059146", "message": "Add basic integration test", "committedDate": "2020-01-28T15:08:50Z", "type": "commit"}, {"oid": "2bdd5b4daa96d18dbf4c8ea910799b4d06478ecc", "url": "https://github.com/ConsenSys/teku/commit/2bdd5b4daa96d18dbf4c8ea910799b4d06478ecc", "message": "Add helper for managing syncing nodes", "committedDate": "2020-01-28T15:48:55Z", "type": "commit"}, {"oid": "30da333a66310d239dda0e51f6992ac4cd4ba994", "url": "https://github.com/ConsenSys/teku/commit/30da333a66310d239dda0e51f6992ac4cd4ba994", "message": "Merge branch 'master' into bc-202/fetch-unknown-ancestor-blocks", "committedDate": "2020-01-28T15:51:03Z", "type": "commit"}, {"oid": "9c778436b811d4cb42032c7213bb66cb50fcb662", "url": "https://github.com/ConsenSys/teku/commit/9c778436b811d4cb42032c7213bb66cb50fcb662", "message": "Make sure children of invalid blocks are marked invalid", "committedDate": "2020-01-28T16:29:09Z", "type": "commit"}, {"oid": "4899a98b0b1c06417738517c065fc0d711421df4", "url": "https://github.com/ConsenSys/teku/commit/4899a98b0b1c06417738517c065fc0d711421df4", "message": "Clarify shuffle operation", "committedDate": "2020-01-28T16:52:27Z", "type": "commit"}, {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3", "url": "https://github.com/ConsenSys/teku/commit/4ee1c1b7cd1b5530efcee0f1908fbb63691615f3", "message": "Simplify comparator", "committedDate": "2020-01-28T17:02:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2ODc2Mg==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r371968762", "bodyText": "nice.", "author": "cemozerr", "createdAt": "2020-01-28T18:07:43Z", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/ResponseStreamImpl.java", "diffHunk": "@@ -76,4 +76,13 @@ public void completeSuccessfully() {\n   public void completeWithError(final Throwable error) {\n     completionFuture.completeExceptionally(error);\n   }\n+\n+  public void subscribeCompleted(RequestCompleteSubscriber subscriber) {\n+    completionFuture.finish(\n+        res -> subscriber.onRequestComplete(true), err -> subscriber.onRequestComplete(false));", "originalCommit": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwNTUzMA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372005530", "bodyText": "do you not just do tasks.forEach() to make sure to not run futures added after you called this method?", "author": "cemozerr", "createdAt": "2020-01-28T19:20:37Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);", "originalCommit": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxODUxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372018515", "bodyText": "Right - we only want to run tasks that are currently tracked.  Some of these tasks might trigger additional scheduled tasks.", "author": "mbaxter", "createdAt": "2020-01-28T19:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwNTUzMA=="}], "type": "inlineReview", "revised_code": {"commit": "3c8ca4ebd12bb25c9c69632f68f0680c8643a175", "chunk": "diff --git a/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java b/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java\ndeleted file mode 100644\nindex e528e42a8..000000000\n--- a/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java\n+++ /dev/null\n\n@@ -1,176 +0,0 @@\n-/*\n- * Copyright 2020 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.util.executors;\n-\n-import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.stream.Collectors;\n-\n-public class MockExecutorService implements ExecutorService {\n-\n-  private boolean autoRun = false;\n-\n-  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n-\n-  // Test utility for inspecting executor's futures\n-  public List<Future<?>> getFutures() {\n-    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n-  }\n-\n-  public void setAutoRun(final boolean shouldAutoRunTasks) {\n-    this.autoRun = shouldAutoRunTasks;\n-  }\n-\n-  public void runPendingFutures() {\n-    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n-    currentTasks.forEach(ExecutorTask::run);\n-  }\n-\n-  public long getPendingFuturesCount() {\n-    return tasks.stream().filter(ExecutorTask::isPending).count();\n-  }\n-\n-  public void runPendingFuturesInSeparateThreads(final ExecutorService executorService) {\n-    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n-    currentTasks.forEach(task -> executorService.execute(task::run));\n-  }\n-\n-  @Override\n-  public void shutdown() {}\n-\n-  @Override\n-  public List<Runnable> shutdownNow() {\n-    return Collections.emptyList();\n-  }\n-\n-  @Override\n-  public boolean isShutdown() {\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean isTerminated() {\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean awaitTermination(final long timeout, final TimeUnit unit)\n-      throws InterruptedException {\n-    return false;\n-  }\n-\n-  @Override\n-  public <T> Future<T> submit(final Callable<T> task) {\n-    ExecutorTask<T> execTask = new ExecutorTask<>(task::call);\n-    tasks.add(execTask);\n-    if (autoRun) {\n-      execTask.run();\n-    }\n-\n-    return execTask.getFuture();\n-  }\n-\n-  @Override\n-  public <T> Future<T> submit(final Runnable task, final T result) {\n-    return submit(\n-        () -> {\n-          task.run();\n-          return result;\n-        });\n-  }\n-\n-  @Override\n-  public Future<?> submit(final Runnable task) {\n-    return submit(\n-        () -> {\n-          task.run();\n-          return null;\n-        });\n-  }\n-\n-  @Override\n-  public <T> List<Future<T>> invokeAll(final Collection<? extends Callable<T>> tasks)\n-      throws InterruptedException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public <T> List<Future<T>> invokeAll(\n-      final Collection<? extends Callable<T>> tasks, final long timeout, final TimeUnit unit)\n-      throws InterruptedException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public <T> T invokeAny(final Collection<? extends Callable<T>> tasks)\n-      throws InterruptedException, ExecutionException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public <T> T invokeAny(\n-      final Collection<? extends Callable<T>> tasks, final long timeout, final TimeUnit unit)\n-      throws InterruptedException, ExecutionException, TimeoutException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public void execute(final Runnable command) {\n-    ignoreFuture(submit(command));\n-  }\n-\n-  private static class ExecutorTask<T> {\n-    private final CompletableFuture<T> future;\n-    private final Callable<T> taskRunner;\n-    private boolean isPending = true;\n-\n-    private ExecutorTask(final Callable<T> taskRunner) {\n-      this.future = new CompletableFuture<>();\n-      this.taskRunner = taskRunner;\n-    }\n-\n-    public void run() {\n-      if (!isPending) {\n-        return;\n-      }\n-\n-      isPending = false;\n-      try {\n-        T result = taskRunner.call();\n-        future.complete(result);\n-      } catch (final Exception e) {\n-        future.completeExceptionally(e);\n-      }\n-    }\n-\n-    public CompletableFuture<T> getFuture() {\n-      return future;\n-    }\n-\n-    public boolean isPending() {\n-      return isPending;\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODcwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372008705", "bodyText": "Did you implement these because extending the interface required you to do so? I don't understand why you return the same exact thing that was passed into the argument.", "author": "cemozerr", "createdAt": "2020-01-28T19:26:52Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(ExecutorTask::run);\n+  }\n+\n+  public long getPendingFuturesCount() {\n+    return tasks.stream().filter(ExecutorTask::isPending).count();\n+  }\n+\n+  public void runPendingFuturesInSeparateThreads(final ExecutorService executorService) {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(task -> executorService.execute(task::run));\n+  }\n+\n+  @Override\n+  public void shutdown() {}\n+\n+  @Override\n+  public List<Runnable> shutdownNow() {\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public boolean isShutdown() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isTerminated() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean awaitTermination(final long timeout, final TimeUnit unit)\n+      throws InterruptedException {\n+    return false;\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Callable<T> task) {\n+    ExecutorTask<T> execTask = new ExecutorTask<>(task::call);\n+    tasks.add(execTask);\n+    if (autoRun) {\n+      execTask.run();\n+    }\n+\n+    return execTask.getFuture();\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Runnable task, final T result) {", "originalCommit": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTA2OA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372021068", "bodyText": "This task gets channeled to the submit method on line 85 which adds tracking arounds the tasks.", "author": "mbaxter", "createdAt": "2020-01-28T19:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTg2Nw==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372021867", "bodyText": "I grabbed these utils from besu btw: https://github.com/hyperledger/besu/blob/6060a79d6618fbeebf6e5e1da7e9f788a213598a/testutil/src/main/java/org/hyperledger/besu/testutil/MockExecutorService.java", "author": "mbaxter", "createdAt": "2020-01-28T19:52:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "3c8ca4ebd12bb25c9c69632f68f0680c8643a175", "chunk": "diff --git a/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java b/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java\ndeleted file mode 100644\nindex e528e42a8..000000000\n--- a/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java\n+++ /dev/null\n\n@@ -1,176 +0,0 @@\n-/*\n- * Copyright 2020 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.util.executors;\n-\n-import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-import java.util.stream.Collectors;\n-\n-public class MockExecutorService implements ExecutorService {\n-\n-  private boolean autoRun = false;\n-\n-  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n-\n-  // Test utility for inspecting executor's futures\n-  public List<Future<?>> getFutures() {\n-    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n-  }\n-\n-  public void setAutoRun(final boolean shouldAutoRunTasks) {\n-    this.autoRun = shouldAutoRunTasks;\n-  }\n-\n-  public void runPendingFutures() {\n-    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n-    currentTasks.forEach(ExecutorTask::run);\n-  }\n-\n-  public long getPendingFuturesCount() {\n-    return tasks.stream().filter(ExecutorTask::isPending).count();\n-  }\n-\n-  public void runPendingFuturesInSeparateThreads(final ExecutorService executorService) {\n-    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n-    currentTasks.forEach(task -> executorService.execute(task::run));\n-  }\n-\n-  @Override\n-  public void shutdown() {}\n-\n-  @Override\n-  public List<Runnable> shutdownNow() {\n-    return Collections.emptyList();\n-  }\n-\n-  @Override\n-  public boolean isShutdown() {\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean isTerminated() {\n-    return false;\n-  }\n-\n-  @Override\n-  public boolean awaitTermination(final long timeout, final TimeUnit unit)\n-      throws InterruptedException {\n-    return false;\n-  }\n-\n-  @Override\n-  public <T> Future<T> submit(final Callable<T> task) {\n-    ExecutorTask<T> execTask = new ExecutorTask<>(task::call);\n-    tasks.add(execTask);\n-    if (autoRun) {\n-      execTask.run();\n-    }\n-\n-    return execTask.getFuture();\n-  }\n-\n-  @Override\n-  public <T> Future<T> submit(final Runnable task, final T result) {\n-    return submit(\n-        () -> {\n-          task.run();\n-          return result;\n-        });\n-  }\n-\n-  @Override\n-  public Future<?> submit(final Runnable task) {\n-    return submit(\n-        () -> {\n-          task.run();\n-          return null;\n-        });\n-  }\n-\n-  @Override\n-  public <T> List<Future<T>> invokeAll(final Collection<? extends Callable<T>> tasks)\n-      throws InterruptedException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public <T> List<Future<T>> invokeAll(\n-      final Collection<? extends Callable<T>> tasks, final long timeout, final TimeUnit unit)\n-      throws InterruptedException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public <T> T invokeAny(final Collection<? extends Callable<T>> tasks)\n-      throws InterruptedException, ExecutionException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public <T> T invokeAny(\n-      final Collection<? extends Callable<T>> tasks, final long timeout, final TimeUnit unit)\n-      throws InterruptedException, ExecutionException, TimeoutException {\n-    throw new UnsupportedOperationException();\n-  }\n-\n-  @Override\n-  public void execute(final Runnable command) {\n-    ignoreFuture(submit(command));\n-  }\n-\n-  private static class ExecutorTask<T> {\n-    private final CompletableFuture<T> future;\n-    private final Callable<T> taskRunner;\n-    private boolean isPending = true;\n-\n-    private ExecutorTask(final Callable<T> taskRunner) {\n-      this.future = new CompletableFuture<>();\n-      this.taskRunner = taskRunner;\n-    }\n-\n-    public void run() {\n-      if (!isPending) {\n-        return;\n-      }\n-\n-      isPending = false;\n-      try {\n-        T result = taskRunner.call();\n-        future.complete(result);\n-      } catch (final Exception e) {\n-        future.completeExceptionally(e);\n-      }\n-    }\n-\n-    public CompletableFuture<T> getFuture() {\n-      return future;\n-    }\n-\n-    public boolean isPending() {\n-      return isPending;\n-    }\n-  }\n-}\n"}}, {"oid": "0a7cc36f82e5d831017feaa5a44e280c5e756627", "url": "https://github.com/ConsenSys/teku/commit/0a7cc36f82e5d831017feaa5a44e280c5e756627", "message": "Merge branch 'master' into bc-202/fetch-unknown-ancestor-blocks", "committedDate": "2020-01-28T19:40:44Z", "type": "commit"}, {"oid": "17e46577d91ee26473f612375686764f594fe0e7", "url": "https://github.com/ConsenSys/teku/commit/17e46577d91ee26473f612375686764f594fe0e7", "message": "Update disabled test message", "committedDate": "2020-01-28T19:56:01Z", "type": "commit"}, {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730", "url": "https://github.com/ConsenSys/teku/commit/9e40cfe955405983c7a14303c33a4b5a2858a730", "message": "Merge branch 'master' into bc-202/fetch-unknown-ancestor-blocks", "committedDate": "2020-01-28T22:27:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5OTQ0OA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372099448", "bodyText": "We have an AsyncRunner interface now, (along with DelayedExecutorAsyncRunner and StubAsyncRunner) now so MockScheduledExecutor might be overkill for now, or else, we can remove the AsyncRunner, and refactor to use MockScheduledExecutor. In any case, we should pick one to prevent duplication.\nWith AsyncRunner interface, this is how the connect() method in PeerManager.java would look like:\n  public SafeFuture<?> connect(final Multiaddr peer, final Network network) {\n    STDOUT.log(Level.DEBUG, \"Connecting to \" + peer);\n    return SafeFuture.of(network.connect(peer))\n        .whenComplete(\n            (conn, throwable) -> {\n              if (throwable != null) {\n                STDOUT.log(\n                    Level.DEBUG,\n                    \"Connection to \" + peer + \" failed. Will retry shortly: \" + throwable);\n                    asyncRunner.runAfterDelay(\n                        () -> connect(peer, network),\n                        RECONNECT_TIMEOUT,\n                        TimeUnit.MILLISECONDS);\n              } else {\n                STDOUT.log(\n                    Level.DEBUG,\n                    \"Connection to peer: \"\n                        + conn.secureSession().getRemoteId()\n                        + \" was successful\");\n                SafeFuture.of(conn.closeFuture())\n                    .finish(\n                        () -> {\n                          LOG.debug(\"Connection to {} closed. Will retry shortly\", peer);\n                              asyncRunner.runAfterDelay(\n                                  () -> connect(peer, network),\n                                  RECONNECT_TIMEOUT,\n                                  TimeUnit.MILLISECONDS));\n                        });\n              }\n            });\n  }", "author": "cemozerr", "createdAt": "2020-01-28T22:40:39Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class MockScheduledExecutor extends MockExecutorService implements ScheduledExecutorService {", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzODE5MA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372438190", "bodyText": "Makes sense - will look into this", "author": "mbaxter", "createdAt": "2020-01-29T15:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5OTQ0OA=="}], "type": "inlineReview", "revised_code": {"commit": "3c8ca4ebd12bb25c9c69632f68f0680c8643a175", "chunk": "diff --git a/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java b/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java\ndeleted file mode 100644\nindex 50551577c..000000000\n--- a/util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java\n+++ /dev/null\n\n@@ -1,99 +0,0 @@\n-/*\n- * Copyright 2020 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.util.executors;\n-\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Delayed;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-public class MockScheduledExecutor extends MockExecutorService implements ScheduledExecutorService {\n-\n-  @Override\n-  public ScheduledFuture<?> schedule(\n-      final Runnable command, final long delay, final TimeUnit unit) {\n-    final Future<?> future = this.submit(command);\n-    return new MockScheduledFuture<>(future);\n-  }\n-\n-  @Override\n-  public <V> ScheduledFuture<V> schedule(\n-      final Callable<V> callable, final long delay, final TimeUnit unit) {\n-    final Future<V> future = this.submit(callable);\n-    return new MockScheduledFuture<>(future);\n-  }\n-\n-  @Override\n-  public ScheduledFuture<?> scheduleAtFixedRate(\n-      final Runnable command, final long initialDelay, final long period, final TimeUnit unit) {\n-    final Future<?> future = this.submit(command);\n-    return new MockScheduledFuture<>(future);\n-  }\n-\n-  @Override\n-  public ScheduledFuture<?> scheduleWithFixedDelay(\n-      final Runnable command, final long initialDelay, final long delay, final TimeUnit unit) {\n-    final Future<?> future = this.submit(command);\n-    return new MockScheduledFuture<>(future);\n-  }\n-\n-  private static class MockScheduledFuture<T> implements ScheduledFuture<T> {\n-\n-    private final Future<T> future;\n-\n-    public MockScheduledFuture(final Future<T> future) {\n-      this.future = future;\n-    }\n-\n-    @Override\n-    public long getDelay(final TimeUnit unit) {\n-      return 0;\n-    }\n-\n-    @Override\n-    public int compareTo(final Delayed o) {\n-      return 0;\n-    }\n-\n-    @Override\n-    public boolean cancel(final boolean mayInterruptIfRunning) {\n-      return future.cancel(mayInterruptIfRunning);\n-    }\n-\n-    @Override\n-    public boolean isCancelled() {\n-      return future.isCancelled();\n-    }\n-\n-    @Override\n-    public boolean isDone() {\n-      return future.isDone();\n-    }\n-\n-    @Override\n-    public T get() throws InterruptedException, ExecutionException {\n-      return future.get();\n-    }\n-\n-    @Override\n-    public T get(final long timeout, final TimeUnit unit)\n-        throws InterruptedException, ExecutionException, TimeoutException {\n-      return future.get(timeout, unit);\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMjEyMA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372102120", "bodyText": "nice.", "author": "cemozerr", "createdAt": "2020-01-28T22:47:33Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/RetryDelayFunction.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import java.time.Duration;\n+\n+public interface RetryDelayFunction {\n+  public Duration getRetryDelay(final int retryCount);\n+\n+  static RetryDelayFunction createExponentialRetry(", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMzA4MA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372103080", "bodyText": "(nit) one Waiter.waitFor() uses the whole definition, the other one is just waitFor()", "author": "cemozerr", "createdAt": "2020-01-28T22:50:09Z", "path": "sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.util.Waiter.waitFor;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.data.BlockProcessingRecord;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2NetworkFactory;\n+import tech.pegasys.artemis.statetransition.events.BlockProposedEvent;\n+import tech.pegasys.artemis.util.Waiter;\n+import tech.pegasys.artemis.util.bls.BLSKeyGenerator;\n+import tech.pegasys.artemis.util.bls.BLSKeyPair;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockPropagationIntegrationTest {\n+  private final List<BLSKeyPair> validatorKeys = BLSKeyGenerator.generateKeyPairs(3);\n+  private final Eth2NetworkFactory networkFactory = new Eth2NetworkFactory();\n+\n+  @AfterEach\n+  public void tearDown() {\n+    networkFactory.stopAll();\n+  }\n+\n+  @Test\n+  public void shouldFetchUnknownAncestorsOfPropagatedBlock() throws Exception {\n+    UnsignedLong currentSlot = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n+\n+    // Setup node 1\n+    SyncingNodeManager node1 = SyncingNodeManager.create(networkFactory, validatorKeys);\n+    node1.chainUtil().setSlot(currentSlot);\n+\n+    // Add some blocks to node1, which node 2 will need to fetch\n+    final List<SignedBeaconBlock> blocksToFetch = new ArrayList<>();\n+    for (int i = 0; i < 3; i++) {\n+      currentSlot = currentSlot.plus(UnsignedLong.ONE);\n+      final BlockProcessingRecord record =\n+          node1.chainUtil().createAndImportBlockAtSlot(currentSlot);\n+      blocksToFetch.add(record.getBlock());\n+    }\n+\n+    // Setup node 2\n+    SyncingNodeManager node2 = SyncingNodeManager.create(networkFactory, validatorKeys);\n+\n+    // Connect networks\n+    waitFor(node1.network().connect(node2.network().getNodeAddress()));\n+    // Wait for connections to get set up\n+    Waiter.waitFor(", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa1abdb251b5acc25017c8e86518e706799babcf", "chunk": "diff --git a/sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java b/sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java\nindex 2120f2100..0cb4c88bb 100644\n--- a/sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java\n+++ b/sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java\n\n@@ -14,7 +14,6 @@\n package tech.pegasys.artemis.sync;\n \n import static org.assertj.core.api.Assertions.assertThat;\n-import static tech.pegasys.artemis.util.Waiter.waitFor;\n \n import com.google.common.primitives.UnsignedLong;\n import java.util.ArrayList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTI1NQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372105255", "bodyText": "Any reason we want to suppress the callback exceptions?", "author": "cemozerr", "createdAt": "2020-01-28T22:56:01Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -46,15 +48,20 @@\n   private static final UnsignedLong GENESIS_SLOT = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n \n   private final EventBus eventBus;\n+  private final Subscribers<RequiredBlockRootSubscriber> requiredBlockRootSubscribers =\n+      Subscribers.create(true);", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ0MjcwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372442701", "bodyText": "It means that if any subscriber ends up throwing an exception, it doesn't bubble up to this class and interrupt its processing.  Otherwise - we have to assume that any time we dispatch events the subscribers might throw errors and we'd have to handle that here.  Since we have no context, at best we'd just end up logging the exception.  Instead, the Subscribers class just handles that for us by logging the errors.", "author": "mbaxter", "createdAt": "2020-01-29T15:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTI1NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MDg5MQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372160891", "bodyText": "This class and the static nested class is beautifully written. \ud83c\udf89", "author": "cemozerr", "createdAt": "2020-01-29T02:25:35Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchBlockTask.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+class FetchBlockTask {", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MTY3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372161672", "bodyText": "If we're only going to use the statically declared RetryDelayFunction above, why also have a member variable instance of it?", "author": "cemozerr", "createdAt": "2020-01-29T02:29:29Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ0ODYwNA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372448604", "bodyText": "This pattern lets us inject mock values for testing.  But it doesn't look like I'm really doing anything special with this in the tests.  I'll look into simplifying.", "author": "mbaxter", "createdAt": "2020-01-29T15:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MTY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3c8ca4ebd12bb25c9c69632f68f0680c8643a175", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java b/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java\nindex ee8bc24ec..cf59f2744 100644\n--- a/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java\n+++ b/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java\n\n@@ -13,8 +13,6 @@\n \n package tech.pegasys.artemis.sync;\n \n-import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n-\n import com.google.common.annotations.VisibleForTesting;\n import java.time.Duration;\n import java.util.Collection;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3MTA5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372171092", "bodyText": "(nit) I wound consider renaming pendingItemsByRequiredBlockRoot to requiredBlockRootToPendingItems. It took me a loooong while to figure out", "author": "cemozerr", "createdAt": "2020-01-29T03:15:50Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -116,16 +123,23 @@ public void add(T item) {\n     }\n \n     final Bytes32 itemRoot = hashTreeRootFunction.apply(item);\n-    final Collection<Bytes32> dependentBlockRoots = dependentBlockHashFunction.apply(item);\n+    final Collection<Bytes32> requiredRoots = requiredBlockRootsFunction.apply(item);\n \n-    dependentBlockRoots.forEach(\n-        dependentBlockRoot ->\n-            // Index block by parent\n-            pendingItemsByDependentBlockRoot\n+    requiredRoots.forEach(\n+        requiredRoot ->\n+            // Index item by required roots\n+            pendingItemsByRequiredBlockRoot", "originalCommit": "9e40cfe955405983c7a14303c33a4b5a2858a730", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "fa1abdb251b5acc25017c8e86518e706799babcf", "url": "https://github.com/ConsenSys/teku/commit/fa1abdb251b5acc25017c8e86518e706799babcf", "message": "Use consistent style for waits", "committedDate": "2020-01-29T15:28:13Z", "type": "commit"}, {"oid": "3c8ca4ebd12bb25c9c69632f68f0680c8643a175", "url": "https://github.com/ConsenSys/teku/commit/3c8ca4ebd12bb25c9c69632f68f0680c8643a175", "message": "Use AsynRunner instead of ScheduledExecutor", "committedDate": "2020-01-29T16:08:06Z", "type": "commit"}, {"oid": "e8e7371e48c641f199abda260fd5749a34c1692f", "url": "https://github.com/ConsenSys/teku/commit/e8e7371e48c641f199abda260fd5749a34c1692f", "message": "Add new AsyncRunner utility method", "committedDate": "2020-01-29T16:15:10Z", "type": "commit"}, {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "url": "https://github.com/ConsenSys/teku/commit/1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "message": "Merge branch 'master' into bc-202/fetch-unknown-ancestor-blocks", "committedDate": "2020-01-29T16:15:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5ODIxOQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372498219", "bodyText": "very neat.", "author": "cemozerr", "createdAt": "2020-01-29T16:41:13Z", "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchBlockTaskTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.artemis.networking.p2p.mock.MockNodeId;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class FetchBlockTaskTest {", "originalCommit": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjI2NQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372506265", "bodyText": "(nit)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final Bytes32 itemRoot = hashTreeRootFunction.apply(item);\n          \n          \n            \n                final Bytes32 pendingItemRoot = hashTreeRootFunction.apply(item);", "author": "cemozerr", "createdAt": "2020-01-29T16:55:03Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -116,16 +123,23 @@ public void add(T item) {\n     }\n \n     final Bytes32 itemRoot = hashTreeRootFunction.apply(item);", "originalCommit": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjcwNw==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372506707", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final Bytes32 itemRoot = hashTreeRootFunction.apply(item);\n          \n          \n            \n                final Bytes32 pendingItemRoot = hashTreeRootFunction.apply(pendingItem);", "author": "cemozerr", "createdAt": "2020-01-29T16:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjI2NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTM5MA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372545390", "bodyText": "In what scenario here can the if statement return false?", "author": "cemozerr", "createdAt": "2020-01-29T18:09:29Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.DelayedExecutorAsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;\n+  private final Subscribers<BlockSubscriber> blockSubscribers = Subscribers.create(true);\n+  private final AsyncRunner asyncRunner;\n+\n+  FetchRecentBlocksService(\n+      final AsyncRunner asyncRunner,\n+      final Eth2Network eth2Network,\n+      final PendingPool<SignedBeaconBlock> pendingBlocksPool,\n+      final FetchBlockTaskFactory fetchBlockTaskFactory,\n+      final RetryDelayFunction retryDelayFunction,\n+      final int maxConcurrentRequests) {\n+    this.asyncRunner = asyncRunner;\n+    this.maxConcurrentRequests = maxConcurrentRequests;\n+    this.eth2Network = eth2Network;\n+    this.pendingBlocksPool = pendingBlocksPool;\n+    this.fetchBlockTaskFactory = fetchBlockTaskFactory;\n+    this.retryDelayFunction = retryDelayFunction;\n+  }\n+\n+  public static FetchRecentBlocksService create(\n+      final Eth2Network eth2Network, final PendingPool<SignedBeaconBlock> pendingBlocksPool) {\n+    return new FetchRecentBlocksService(\n+        new DelayedExecutorAsyncRunner(),\n+        eth2Network,\n+        pendingBlocksPool,\n+        FetchBlockTask::create,\n+        DEFAULT_RETRY_DELAY_FUNCTION,\n+        MAX_CONCURRENT_REQUESTS);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStart() {\n+    setupSubscribers();\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStop() {\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  public long subscribeBlockFetched(final BlockSubscriber subscriber) {\n+    return blockSubscribers.subscribe(subscriber);\n+  }\n+\n+  public void unsubscribeBlockFetched(final int subscriberId) {\n+    blockSubscribers.unsubscribe(subscriberId);\n+  }\n+\n+  private void setupSubscribers() {\n+    this.pendingBlocksPool.subscribeRequiredBlockRoot(this::requestRecentBlock);\n+    this.pendingBlocksPool.subscribeRequiredBlockRootDropped(this::cancelRecentBlockRequest);\n+  }\n+\n+  public void requestRecentBlock(final Bytes32 blockRoot) {\n+    if (pendingBlocksPool.contains(blockRoot)) {\n+      // We've already got this block\n+      return;\n+    }\n+    final FetchBlockTask task = fetchBlockTaskFactory.create(eth2Network, blockRoot);\n+    if (allTasks.putIfAbsent(blockRoot, task) != null) {\n+      // We're already tracking this task\n+      task.cancel();\n+      return;\n+    }\n+    LOG.trace(\"Queue block to be fetched: {}\", blockRoot);\n+    queueTask(task);\n+  }\n+\n+  public void cancelRecentBlockRequest(final Bytes32 blockRoot) {\n+    final FetchBlockTask task = allTasks.get(blockRoot);\n+    if (task != null) {\n+      task.cancel();\n+    }\n+  }\n+\n+  private synchronized void checkTasks() {\n+    // If we have capacity, execute the next task\n+    if (activeTasks.size() < maxConcurrentRequests) {\n+      final FetchBlockTask nextTask = pendingTasks.poll();\n+      if (nextTask == null) {\n+        return;\n+      }\n+      runNextTask(nextTask);\n+    }\n+  }\n+\n+  private void runNextTask(final FetchBlockTask task) {\n+    registerActiveTask(task);\n+    task.run()\n+        .thenAccept(res -> processFetchResult(task, res))\n+        .exceptionally(\n+            (err) -> {\n+              LOG.warn(\"Failed to run \" + task.getClass().getSimpleName(), err);\n+              return null;\n+            })\n+        .always(() -> deregisterActiveTask(task));\n+  }\n+\n+  private void processFetchResult(final FetchBlockTask task, final FetchBlockResult result) {\n+    switch (result.getStatus()) {\n+      case SUCCESSFUL:\n+        handleFetchedBlock(task, result.getBlock());\n+        break;\n+      case NO_AVAILABLE_PEERS:\n+        // Wait a bit and then requeue\n+        queueTaskWithDelay(task, WAIT_FOR_PEERS_DURATION);\n+        break;\n+      case FETCH_FAILED:\n+        // Push task back onto queue to retry\n+        queueTaskWithRetryDelay(task);\n+        break;\n+      case CANCELLED:\n+        LOG.trace(\"Request for block cancelled: {}.\", task.getBlockRoot());\n+        removeTask(task);\n+        break;\n+    }\n+  }\n+\n+  private void registerActiveTask(FetchBlockTask task) {\n+    LOG.trace(\"Fetch block {}\", task.getBlockRoot());\n+    activeTasks.add(task);\n+  }\n+\n+  private void deregisterActiveTask(FetchBlockTask task) {\n+    activeTasks.remove(task);\n+    checkTasks();\n+  }\n+\n+  private void removeTask(FetchBlockTask task) {\n+    // Stop tracking task\n+    task.cancel();\n+    allTasks.compute(\n+        task.getBlockRoot(),\n+        (root, existingTask) -> {\n+          if (Objects.equals(task, existingTask)) {", "originalCommit": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTc1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372545756", "bodyText": "And if there can be multiple tasks for each block root, why not have a set instead of a 1 to 1 mapping", "author": "cemozerr", "createdAt": "2020-01-29T18:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNDU3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372604572", "bodyText": "I don't think this should ever actually return false - its just a safety thing to make sure that if somehow the task had been overwritten with a separate task, we won't interfere with the newer task.  There's a simpler way to do this though:  allTasks.remove(task.getBlockRoot(), task).  Will update.", "author": "mbaxter", "createdAt": "2020-01-29T20:08:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTM5MA=="}], "type": "inlineReview", "revised_code": {"commit": "076bfb916d17650f690267025523e641992f5b17", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java b/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java\nindex 4042d4506..be82ce960 100644\n--- a/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java\n+++ b/sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java\n\n@@ -17,7 +17,6 @@ import com.google.common.annotations.VisibleForTesting;\n import java.time.Duration;\n import java.util.Collection;\n import java.util.Map;\n-import java.util.Objects;\n import java.util.Queue;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NzYzNg==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372547636", "bodyText": "Why use the @mock annotation instead of the mock() method?", "author": "cemozerr", "createdAt": "2020-01-29T18:14:17Z", "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.sync.FetchRecentBlocksService.FetchBlockTaskFactory;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class FetchRecentBlocksServiceTest {\n+\n+  @Mock private Eth2Network eth2Network;", "originalCommit": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNTkwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372605901", "bodyText": "I'm mainly using it because I don't know create a generic mock (PendingPool<SignedBeaconBlock>) with the mock() method without using casting and suppressing warnings.", "author": "mbaxter", "createdAt": "2020-01-29T20:11:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NzYzNg=="}], "type": "inlineReview", "revised_code": {"commit": "076bfb916d17650f690267025523e641992f5b17", "chunk": "diff --git a/sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java b/sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java\nindex b3703150a..59bce1c9b 100644\n--- a/sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java\n+++ b/sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java\n\n@@ -15,14 +15,12 @@ package tech.pegasys.artemis.sync;\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.ArgumentMatchers.anyInt;\n import static org.mockito.Mockito.lenient;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.never;\n import static org.mockito.Mockito.verify;\n import static org.mockito.Mockito.when;\n \n-import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwMzMwMQ==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372603301", "bodyText": "(nit)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (blockIsInvalid(block)) {\n          \n          \n            \n                if (blockIsKnown(block) || blockIsInvalid(block)) {\n          \n      \n    \n    \n  \n\nThis way we can get rid of the blockIsKnown() check in the on gossipedBlock. It's confusing to have those checks in different functions imo.", "author": "cemozerr", "createdAt": "2020-01-29T20:05:28Z", "path": "sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java", "diffHunk": "@@ -87,43 +108,55 @@ void onBlockImported(BlockImportedEvent blockImportedEvent) {\n     final SignedBeaconBlock block = blockImportedEvent.getBlock();\n     final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n     pendingBlocks.remove(block);\n-    pendingBlocks\n-        .childrenOf(blockRoot)\n-        .forEach(\n-            child -> {\n-              pendingBlocks.remove(child);\n-              importBlock(child);\n-            });\n+    final List<SignedBeaconBlock> children = pendingBlocks.getItemsDependingOn(blockRoot, false);\n+    children.forEach(pendingBlocks::remove);\n+    children.forEach(this::importBlock);\n   }\n \n   @Subscribe\n   void onSlot(final SlotEvent slotEvent) {\n     futureBlocks.prune(slotEvent.getSlot()).forEach(this::importBlock);\n   }\n \n+  private boolean blockIsInvalid(final SignedBeaconBlock block) {\n+    return invalidBlockRoots.contains(block.getMessage().hash_tree_root())\n+        || invalidBlockRoots.contains(block.getParent_root());\n+  }\n+\n   private boolean blockIsKnown(final SignedBeaconBlock block) {\n     return pendingBlocks.contains(block)\n         || storageClient.getBlockByRoot(block.getMessage().hash_tree_root()).isPresent();\n   }\n \n   private void importBlock(final SignedBeaconBlock block) {\n+    if (blockIsInvalid(block)) {", "originalCommit": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8d3d9667ddee7ceaf200c74bd09dca1f0a81aa44", "chunk": "diff --git a/sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java b/sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java\nindex 670347894..04b0233df 100644\n--- a/sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java\n+++ b/sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java\n\n@@ -113,24 +112,9 @@ public class BlockPropagationManager extends Service {\n     children.forEach(this::importBlock);\n   }\n \n-  @Subscribe\n-  void onSlot(final SlotEvent slotEvent) {\n-    futureBlocks.prune(slotEvent.getSlot()).forEach(this::importBlock);\n-  }\n-\n-  private boolean blockIsInvalid(final SignedBeaconBlock block) {\n-    return invalidBlockRoots.contains(block.getMessage().hash_tree_root())\n-        || invalidBlockRoots.contains(block.getParent_root());\n-  }\n-\n-  private boolean blockIsKnown(final SignedBeaconBlock block) {\n-    return pendingBlocks.contains(block)\n-        || storageClient.getBlockByRoot(block.getMessage().hash_tree_root()).isPresent();\n-  }\n-\n   private void importBlock(final SignedBeaconBlock block) {\n-    if (blockIsInvalid(block)) {\n-      dropInvalidBlock(block);\n+    recentBlockFetcher.cancelRecentBlockRequest(block.getMessage().hash_tree_root());\n+    if (!shouldImportBlock(block)) {\n       return;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNzY3OA==", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372607678", "bodyText": "I think this should be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Gossip all blocks except the first\n          \n          \n            \n                // Gossip all blocks except the first two", "author": "cemozerr", "createdAt": "2020-01-29T20:15:34Z", "path": "sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java", "diffHunk": "@@ -155,6 +168,78 @@ public void onBlockImported_withPendingBlocks() throws Exception {\n     assertThat(pendingBlocks.size()).isEqualTo(0);\n   }\n \n+  @Test\n+  public void onBlockImportFailure_withPendingDependantBlocks() throws Exception {\n+    final int invalidChainDepth = 3;\n+    final List<SignedBeaconBlock> invalidBlockDescendants = new ArrayList<>(invalidChainDepth);\n+\n+    final SignedBeaconBlock invalidBlock =\n+        remoteChain.createBlockAtSlotFromInvalidProposer(incrementSlot());\n+    Bytes32 parentBlockRoot = invalidBlock.getMessage().hash_tree_root();\n+    for (int i = 0; i < invalidChainDepth; i++) {\n+      final UnsignedLong nextSlot = incrementSlot();\n+      final SignedBeaconBlock block =\n+          DataStructureUtil.randomSignedBeaconBlock(nextSlot.longValue(), parentBlockRoot, i);\n+      invalidBlockDescendants.add(block);\n+      parentBlockRoot = block.getMessage().hash_tree_root();\n+    }\n+\n+    // Gossip all blocks except the first\n+    invalidBlockDescendants.stream().map(GossipedBlockEvent::new).forEach(localEventBus::post);\n+    assertThat(importedBlocks.get()).isEmpty();\n+    assertThat(pendingBlocks.size()).isEqualTo(invalidChainDepth);\n+\n+    // Gossip next block, causing dependent blocks to be dropped when the import fails\n+    localEventBus.post(new GossipedBlockEvent(invalidBlock));\n+    assertThat(importedBlocks.get()).isEmpty();\n+    assertThat(pendingBlocks.size()).isEqualTo(0);\n+\n+    // If any invalid block is again gossiped, it should be ignored\n+    invalidBlockDescendants.stream().map(GossipedBlockEvent::new).forEach(localEventBus::post);\n+    assertThat(importedBlocks.get()).isEmpty();\n+    assertThat(pendingBlocks.size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void onBlockImportFailure_withUnconnectedPendingDependantBlocks() throws Exception {\n+    final int invalidChainDepth = 3;\n+    final List<SignedBeaconBlock> invalidBlockDescendants = new ArrayList<>(invalidChainDepth);\n+\n+    final SignedBeaconBlock invalidBlock =\n+        remoteChain.createBlockAtSlotFromInvalidProposer(incrementSlot());\n+    Bytes32 parentBlockRoot = invalidBlock.getMessage().hash_tree_root();\n+    for (int i = 0; i < invalidChainDepth; i++) {\n+      final UnsignedLong nextSlot = incrementSlot();\n+      final SignedBeaconBlock block =\n+          DataStructureUtil.randomSignedBeaconBlock(nextSlot.longValue(), parentBlockRoot, i);\n+      invalidBlockDescendants.add(block);\n+      parentBlockRoot = block.getMessage().hash_tree_root();\n+    }\n+\n+    // Gossip all blocks except the first", "originalCommit": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c221a459f8fad0b1537907b1c587257c4a3647e", "chunk": "diff --git a/sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java b/sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java\nindex 085011e87..5680cf414 100644\n--- a/sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java\n+++ b/sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java\n\n@@ -216,7 +216,7 @@ public class BlockPropagationManagerTest {\n       parentBlockRoot = block.getMessage().hash_tree_root();\n     }\n \n-    // Gossip all blocks except the first\n+    // Gossip all blocks except the first two\n     invalidBlockDescendants.subList(1, invalidChainDepth).stream()\n         .map(GossipedBlockEvent::new)\n         .forEach(localEventBus::post);\n"}}, {"oid": "076bfb916d17650f690267025523e641992f5b17", "url": "https://github.com/ConsenSys/teku/commit/076bfb916d17650f690267025523e641992f5b17", "message": "Remove unnecessary constructor params, simplify map operation", "committedDate": "2020-01-29T20:17:31Z", "type": "commit"}, {"oid": "4c221a459f8fad0b1537907b1c587257c4a3647e", "url": "https://github.com/ConsenSys/teku/commit/4c221a459f8fad0b1537907b1c587257c4a3647e", "message": "Clarify comment\n\nCo-Authored-By: Cem Ozer <cemozer2018@u.northwestern.edu>", "committedDate": "2020-01-29T20:36:00Z", "type": "commit"}, {"oid": "70c43ea624d226ed842d4332c777c71cbaaecfb8", "url": "https://github.com/ConsenSys/teku/commit/70c43ea624d226ed842d4332c777c71cbaaecfb8", "message": "Merge branch 'master' into bc-202/fetch-unknown-ancestor-blocks", "committedDate": "2020-01-29T20:36:22Z", "type": "commit"}, {"oid": "8d3d9667ddee7ceaf200c74bd09dca1f0a81aa44", "url": "https://github.com/ConsenSys/teku/commit/8d3d9667ddee7ceaf200c74bd09dca1f0a81aa44", "message": "Consolidate block checks, reorganize for readability", "committedDate": "2020-01-30T14:58:37Z", "type": "commit"}, {"oid": "3d36fb40089a6f1be0959b8edc61ba7527c3bef7", "url": "https://github.com/ConsenSys/teku/commit/3d36fb40089a6f1be0959b8edc61ba7527c3bef7", "message": "Merge branch 'master' into bc-202/fetch-unknown-ancestor-blocks", "committedDate": "2020-01-30T14:58:58Z", "type": "commit"}]}