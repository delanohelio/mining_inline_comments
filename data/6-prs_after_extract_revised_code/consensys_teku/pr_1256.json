{"pr_number": 1256, "pr_title": "#1161: Refactoring BeaconBlockHandler to use CombinedChainDataClient.", "pr_createdAt": "2020-03-02T15:26:31Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1256", "timeline": [{"oid": "c4f61551d39144dbb924300774db07fbce54db98", "url": "https://github.com/ConsenSys/teku/commit/c4f61551d39144dbb924300774db07fbce54db98", "message": "#1161: Refactoring BeaconBlockHandler to use CombinedChainDataClient.", "committedDate": "2020-03-02T15:25:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4OTE0MA==", "url": "https://github.com/ConsenSys/teku/pull/1256#discussion_r386689140", "bodyText": "is doReturn better than the other way?", "author": "macfarla", "createdAt": "2020-03-02T22:27:01Z", "path": "data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java", "diffHunk": "@@ -174,75 +186,91 @@ public void shouldReturnBlockWhenEpochQuery() throws Exception {\n     final String epochNum = \"1\";\n     final Map<String, List<String>> params = Map.of(EPOCH, List.of(epochNum));\n \n-    when(context.queryParamMap()).thenReturn(params);\n-    when(context.queryParam(any())).thenReturn(epochNum);\n-    when(storageClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n-    when(storageClient.getStore()).thenReturn(store);\n-    when(store.getSignedBlock(any())).thenReturn(signedBeaconBlock);\n-    when(historicalChainData.getFinalizedBlockAtSlot(any()))\n-        .thenReturn(SafeFuture.completedFuture(empty()));\n+    doReturn(params).when(context).queryParamMap();", "originalCommit": "c4f61551d39144dbb924300774db07fbce54db98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyMDY3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1256#discussion_r386720677", "bodyText": "We prefer when(context.queryParamMap()).thenReturn(...) if at all possible because it's actually type safe. This includes if you have to declare the mock as a generic type and use SuppressWarnings because mock(Supplier.class) is untyped. Otherwise if the return type changes, the compiler won't flag it.\nBut sometimes it's unavoidable  (e.g. if something returns a SafeFuture<?> you can't ever have something that satisfies that because it can't know what ? is to see if you satisfied it, and I think there are a few other corner cases as well.", "author": "ajsutton", "createdAt": "2020-03-02T23:50:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY4OTE0MA=="}], "type": "inlineReview", "revised_code": {"commit": "20642928206838c4679774485ff83da0c3852c62", "chunk": "diff --git a/data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java b/data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java\nindex 47c0c5d126..2929840155 100644\n--- a/data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java\n+++ b/data/beaconrestapi/src/test/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandlerTest.java\n\n@@ -185,46 +176,40 @@ public class BeaconBlockHandlerTest {\n   public void shouldReturnBlockWhenEpochQuery() throws Exception {\n     final String epochNum = \"1\";\n     final Map<String, List<String>> params = Map.of(EPOCH, List.of(epochNum));\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n \n-    doReturn(params).when(context).queryParamMap();\n-    doReturn(epochNum).when(context).queryParam(any());\n-    doReturn(Optional.of(blockRoot)).when(storageClient).getBlockRootBySlot(any());\n-    doReturn(store).when(storageClient).getStore();\n-    doReturn(signedBeaconBlock).when(store).getSignedBlock(any());\n-    doReturn(SafeFuture.completedFuture(empty()))\n-        .when(historicalChainData)\n-        .getLatestFinalizedBlockAtSlot(any());\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(epochNum);\n+    when(combinedChainDataClient.getBlockBySlot(any())).thenCallRealMethod();\n+    when(combinedChainDataClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n+    when(combinedChainDataClient.getStore()).thenReturn(store);\n+    when(store.getSignedBlock(any())).thenReturn(signedBeaconBlock);\n \n     handler.handle(context);\n \n-    final String jsonResponse =\n-        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n-\n     verify(context).result(argumentCaptor.capture());\n-    assertThat(waitFor(argumentCaptor.getValue())).isEqualTo(jsonResponse);\n+    assertThat(argumentCaptor.getValue().get()).isEqualTo(jsonResponse);\n   }\n \n   @Test\n   public void shouldReturnBlockWhenSlotQuery() throws Exception {\n     final String slotNum = \"1\";\n     final Map<String, List<String>> params = Map.of(SLOT, List.of(slotNum));\n+    final String jsonResponse =\n+        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n \n-    doReturn(params).when(context).queryParamMap();\n-    doReturn(slotNum).when(context).queryParam(any());\n-    doReturn(store).when(storageClient).getStore();\n-    doReturn(Optional.of(blockRoot)).when(storageClient).getBlockRootBySlot(any());\n-    doReturn(signedBeaconBlock).when(store).getSignedBlock(any());\n-    doReturn(SafeFuture.completedFuture(empty()))\n-        .when(historicalChainData)\n-        .getLatestFinalizedBlockAtSlot(any());\n+    when(context.queryParamMap()).thenReturn(params);\n+    when(context.queryParam(any())).thenReturn(slotNum);\n+    when(combinedChainDataClient.getBlockBySlot(any())).thenCallRealMethod();\n+    when(combinedChainDataClient.getBlockRootBySlot(any())).thenReturn(Optional.of(blockRoot));\n+    when(combinedChainDataClient.getStore()).thenReturn(store);\n+    when(store.getSignedBlock(any())).thenReturn(signedBeaconBlock);\n \n     handler.handle(context);\n \n-    final String jsonResponse =\n-        jsonProvider.objectToJSON(new BeaconBlockResponse(signedBeaconBlock));\n-\n     verify(context).result(argumentCaptor.capture());\n-    assertThat(waitFor(argumentCaptor.getValue())).isEqualTo(jsonResponse);\n+    assertThat(argumentCaptor.getValue().get()).isEqualTo(jsonResponse);\n   }\n \n   @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDA4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1256#discussion_r386630085", "bodyText": "i just added the same thing in my PR :) well, very similar - isStoreAvailable, I figured we'd mostly only be wanting to access it to check if its set, rather than to use directly... just an observation, no change required.", "author": "rolfyone", "createdAt": "2020-03-02T20:25:11Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/CombinedChainDataClient.java", "diffHunk": "@@ -171,11 +171,32 @@ private boolean isFinalized(final UnsignedLong slot) {\n   }\n \n   public Optional<Bytes32> getBestBlockRoot() {\n-    final Store store = recentChainData.getStore();\n-    if (store == null) {\n+    if (getStore() == null) {\n       LOG.trace(\"No block found because the store is not set\");\n       return Optional.empty();\n     }\n     return Optional.ofNullable(recentChainData.getBestBlockRoot());\n   }\n+\n+  public Store getStore() {\n+    return recentChainData.getStore();\n+  }", "originalCommit": "c4f61551d39144dbb924300774db07fbce54db98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc2MTcwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1256#discussion_r386761709", "bodyText": "Great point. \ud83d\udc4d", "author": "mark-terry", "createdAt": "2020-03-03T02:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDA4NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMTYxMA==", "url": "https://github.com/ConsenSys/teku/pull/1256#discussion_r386631610", "bodyText": "should probably add Unit Test to CombinedChainDataClientTest", "author": "rolfyone", "createdAt": "2020-03-02T20:28:02Z", "path": "storage/src/main/java/tech/pegasys/artemis/storage/CombinedChainDataClient.java", "diffHunk": "@@ -171,11 +171,32 @@ private boolean isFinalized(final UnsignedLong slot) {\n   }\n \n   public Optional<Bytes32> getBestBlockRoot() {\n-    final Store store = recentChainData.getStore();\n-    if (store == null) {\n+    if (getStore() == null) {\n       LOG.trace(\"No block found because the store is not set\");\n       return Optional.empty();\n     }\n     return Optional.ofNullable(recentChainData.getBestBlockRoot());\n   }\n+\n+  public Store getStore() {\n+    return recentChainData.getStore();\n+  }\n+\n+  public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot) {\n+    return recentChainData.getBlockRootBySlot(slot);\n+  }\n+\n+  public SafeFuture<Optional<SignedBeaconBlock>> getBlockBySlot(final UnsignedLong slot) {\n+    final Optional<Bytes32> blockRootBySlot = getBlockRootBySlot(slot);\n+    final Optional<Bytes32> bestBlockRoot = getBestBlockRoot();\n+\n+    if (blockRootBySlot.isPresent()) {\n+      return SafeFuture.completedFuture(\n+          Optional.ofNullable(getStore().getSignedBlock(blockRootBySlot.get())));\n+    } else if (bestBlockRoot.isPresent()) {\n+      return getBlockAtSlotExact(slot, bestBlockRoot.get());\n+    } else {\n+      return SafeFuture.completedFuture(Optional.empty());\n+    }\n+  }", "originalCommit": "c4f61551d39144dbb924300774db07fbce54db98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwODYzMw==", "url": "https://github.com/ConsenSys/teku/pull/1256#discussion_r386808633", "bodyText": "Done.", "author": "mark-terry", "createdAt": "2020-03-03T05:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMTYxMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "77380189ea0e0c1ea8e5ade16fb23218b945c838", "url": "https://github.com/ConsenSys/teku/commit/77380189ea0e0c1ea8e5ade16fb23218b945c838", "message": "Merge branch 'master' into 1161-combinedchainclient", "committedDate": "2020-03-03T02:12:37Z", "type": "commit"}, {"oid": "a2ed9d8704b18be2a414f33c0adf4b29e3ddc60a", "url": "https://github.com/ConsenSys/teku/commit/a2ed9d8704b18be2a414f33c0adf4b29e3ddc60a", "message": "Merge branch 'master' into 1161-combinedchainclient", "committedDate": "2020-03-03T02:48:11Z", "type": "commit"}, {"oid": "20642928206838c4679774485ff83da0c3852c62", "url": "https://github.com/ConsenSys/teku/commit/20642928206838c4679774485ff83da0c3852c62", "message": "#1161: PR fixes and test refactoring.", "committedDate": "2020-03-03T05:38:11Z", "type": "commit"}, {"oid": "69173d058ef85900168d11364d6ed968133ad16f", "url": "https://github.com/ConsenSys/teku/commit/69173d058ef85900168d11364d6ed968133ad16f", "message": "Merge branch 'master' into 1161-combinedchainclient", "committedDate": "2020-03-03T05:44:00Z", "type": "commit"}, {"oid": "1f4b910fb26f2c9f2a251813281fbceebe1f4ee5", "url": "https://github.com/ConsenSys/teku/commit/1f4b910fb26f2c9f2a251813281fbceebe1f4ee5", "message": "Merge branch 'master' into 1161-combinedchainclient", "committedDate": "2020-03-03T05:54:39Z", "type": "commit"}]}