{"pr_number": 2145, "pr_title": "Removes recursion from get_ancestor()", "pr_createdAt": "2020-06-14T15:52:13Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2145", "timeline": [{"oid": "f3a09c8f631cca006dee0ca4792ce87cdf51bb49", "url": "https://github.com/ConsenSys/teku/commit/f3a09c8f631cca006dee0ca4792ce87cdf51bb49", "message": "Removes recursion from get_ancestor()\n\nI and others have been experiencing stack overflows during a long period\nof non-finalisation. Removing the recursion from get_ancestor() should\nhelp.", "committedDate": "2020-06-14T15:26:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2NjYzOQ==", "url": "https://github.com/ConsenSys/teku/pull/2145#discussion_r439866639", "bodyText": "This isn't quite right - the Optional returned by forkChoiceStrategy.blockSlot(parentRoot) may be empty (which would indicate we're importing a block from an invalid fork).\nWe'll want:\nBytes32 parentRoot = root;\n    Optional<UnsignedLong> blockSlot = forkChoiceStrategy.blockSlot(parentRoot);\n    while (blockSlot.isPresent() && blockSlot.get().compareTo(slot) > 0) {\n      parentRoot = forkChoiceStrategy.blockParentRoot(parentRoot).orElseThrow();\n      blockSlot = forkChoiceStrategy.blockSlot(parentRoot);\n    }\n    return blockSlot.isPresent() ? Optional.of(parentRoot) : Optional.empty();", "author": "ajsutton", "createdAt": "2020-06-14T20:55:00Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -84,23 +84,11 @@ public static UnsignedLong compute_slots_since_epoch_start(UnsignedLong slot) {\n    */\n   private static Optional<Bytes32> get_ancestor(\n       ForkChoiceStrategy forkChoiceStrategy, Bytes32 root, UnsignedLong slot) {\n-    return forkChoiceStrategy\n-        .blockSlot(root)\n-        .flatMap(\n-            blockSlot -> {\n-              if (blockSlot.compareTo(slot) > 0) {\n-                return get_ancestor(\n-                    forkChoiceStrategy,\n-                    forkChoiceStrategy.blockParentRoot(root).orElseThrow(),\n-                    slot);\n-              } else if (blockSlot.equals(slot)) {\n-                return Optional.of(root);\n-              } else {\n-                // root is older than the queried slot, thus a skip slot. Return earliest root prior\n-                // to slot.\n-                return Optional.of(root);\n-              }\n-            });\n+    Bytes32 parentRoot = root;\n+    while (forkChoiceStrategy.blockSlot(parentRoot).get().compareTo(slot) > 0) {\n+      parentRoot = forkChoiceStrategy.blockParentRoot(parentRoot).orElseThrow();\n+    }\n+    return Optional.of(parentRoot);", "originalCommit": "f3a09c8f631cca006dee0ca4792ce87cdf51bb49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2NzMwNQ==", "url": "https://github.com/ConsenSys/teku/pull/2145#discussion_r439867305", "bodyText": "Given you're probably asleep and I've already written the code, I've pushed this up.  Will get @cemozerr to review. :)", "author": "ajsutton", "createdAt": "2020-06-14T21:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2NjYzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4494455e5de9ebf7bfe48e2d3aa9a44447979977", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java b/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java\nindex 166fe1b134..6f33380c93 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java\n+++ b/ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java\n\n@@ -85,10 +85,12 @@ public class ForkChoiceUtil {\n   private static Optional<Bytes32> get_ancestor(\n       ForkChoiceStrategy forkChoiceStrategy, Bytes32 root, UnsignedLong slot) {\n     Bytes32 parentRoot = root;\n-    while (forkChoiceStrategy.blockSlot(parentRoot).get().compareTo(slot) > 0) {\n+    Optional<UnsignedLong> blockSlot = forkChoiceStrategy.blockSlot(root);\n+    while (blockSlot.isPresent() && blockSlot.get().compareTo(slot) > 0) {\n       parentRoot = forkChoiceStrategy.blockParentRoot(parentRoot).orElseThrow();\n+      blockSlot = forkChoiceStrategy.blockSlot(parentRoot);\n     }\n-    return Optional.of(parentRoot);\n+    return blockSlot.isPresent() ? Optional.of(parentRoot) : Optional.empty();\n   }\n \n   /*\n"}}, {"oid": "4494455e5de9ebf7bfe48e2d3aa9a44447979977", "url": "https://github.com/ConsenSys/teku/commit/4494455e5de9ebf7bfe48e2d3aa9a44447979977", "message": "Handle unknown parent blocks in get_ancestor.", "committedDate": "2020-06-14T21:02:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5MzI1Mw==", "url": "https://github.com/ConsenSys/teku/pull/2145#discussion_r440193253", "bodyText": "This looks good to me, but independent from this PR, makes me wonder if throwing here when the parentRoot does not exist in our ProtoArray was the right call. Seems like we simply should be returning an empty optional when we don't have the parent root, since the parent root is potentially a root of a block in a non-finalized fork, and we should be fine with that. Will do a follow-up PR on this.", "author": "cemozerr", "createdAt": "2020-06-15T13:55:22Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -84,23 +84,13 @@ public static UnsignedLong compute_slots_since_epoch_start(UnsignedLong slot) {\n    */\n   private static Optional<Bytes32> get_ancestor(\n       ForkChoiceStrategy forkChoiceStrategy, Bytes32 root, UnsignedLong slot) {\n-    return forkChoiceStrategy\n-        .blockSlot(root)\n-        .flatMap(\n-            blockSlot -> {\n-              if (blockSlot.compareTo(slot) > 0) {\n-                return get_ancestor(\n-                    forkChoiceStrategy,\n-                    forkChoiceStrategy.blockParentRoot(root).orElseThrow(),\n-                    slot);\n-              } else if (blockSlot.equals(slot)) {\n-                return Optional.of(root);\n-              } else {\n-                // root is older than the queried slot, thus a skip slot. Return earliest root prior\n-                // to slot.\n-                return Optional.of(root);\n-              }\n-            });\n+    Bytes32 parentRoot = root;\n+    Optional<UnsignedLong> blockSlot = forkChoiceStrategy.blockSlot(root);\n+    while (blockSlot.isPresent() && blockSlot.get().compareTo(slot) > 0) {\n+      parentRoot = forkChoiceStrategy.blockParentRoot(parentRoot).orElseThrow();", "originalCommit": "4494455e5de9ebf7bfe48e2d3aa9a44447979977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyOTEwOQ==", "url": "https://github.com/ConsenSys/teku/pull/2145#discussion_r440329109", "bodyText": "Actually throwing there does make sense because, for a block that we found the slot in the ProtoArray, we should have the complete ProtoNode anyway.", "author": "cemozerr", "createdAt": "2020-06-15T17:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE5MzI1Mw=="}], "type": "inlineReview", "revised_code": null}, {"oid": "d59b2945378dc934515d4b2bb2f5c002e628ad31", "url": "https://github.com/ConsenSys/teku/commit/d59b2945378dc934515d4b2bb2f5c002e628ad31", "message": "Merge branch 'master' into unrecurse-get-ancestor", "committedDate": "2020-06-15T14:33:54Z", "type": "commit"}]}