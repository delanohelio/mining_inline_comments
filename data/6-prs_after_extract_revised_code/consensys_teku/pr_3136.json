{"pr_number": 3136, "pr_title": "Use ProtoArray instead of BlockTree in Store", "pr_createdAt": "2020-11-03T10:38:00Z", "pr_url": "https://github.com/ConsenSys/teku/pull/3136", "timeline": [{"oid": "22dabb067bb95eee134f66343d1ee51e73d7f8f2", "url": "https://github.com/ConsenSys/teku/commit/22dabb067bb95eee134f66343d1ee51e73d7f8f2", "message": "Store checkpoint epochs with new blocks.\nLoad full block information when creating store. Currently still loading protoarray from snapshot and no migration.", "committedDate": "2020-11-02T05:48:01Z", "type": "commit"}, {"oid": "22b95878d483eedf7d8b611d763a933a9489a18a", "url": "https://github.com/ConsenSys/teku/commit/22b95878d483eedf7d8b611d763a933a9489a18a", "message": "Load protoarray from same block information used for store.\nAdd migration to store checkpoint epochs when not already present.", "committedDate": "2020-11-02T06:55:49Z", "type": "commit"}, {"oid": "d449e30ea4210318a1303258ffeb7e7b7e7e45df", "url": "https://github.com/ConsenSys/teku/commit/d449e30ea4210318a1303258ffeb7e7b7e7e45df", "message": "Delete protoarray snapshot after migration.", "committedDate": "2020-11-02T07:01:32Z", "type": "commit"}, {"oid": "f872514e00d0d8eb32e4faf04f1300283169e982", "url": "https://github.com/ConsenSys/teku/commit/f872514e00d0d8eb32e4faf04f1300283169e982", "message": "Update tests.", "committedDate": "2020-11-02T07:24:57Z", "type": "commit"}, {"oid": "227af7ff8392a8bb78057d58f833395e48a21704", "url": "https://github.com/ConsenSys/teku/commit/227af7ff8392a8bb78057d58f833395e48a21704", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-proto-snapshots", "committedDate": "2020-11-02T07:25:04Z", "type": "commit"}, {"oid": "8b863ef19023f1b1e30bf1eab8d11df5c728f701", "url": "https://github.com/ConsenSys/teku/commit/8b863ef19023f1b1e30bf1eab8d11df5c728f701", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-proto-snapshots", "committedDate": "2020-11-02T20:17:13Z", "type": "commit"}, {"oid": "6c4e7f68c1117021d9a351a11558603da0e67bb7", "url": "https://github.com/ConsenSys/teku/commit/6c4e7f68c1117021d9a351a11558603da0e67bb7", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-proto-snapshots", "committedDate": "2020-11-02T20:20:22Z", "type": "commit"}, {"oid": "7e388758d187eeded56f6bdf16d28b2d637686ca", "url": "https://github.com/ConsenSys/teku/commit/7e388758d187eeded56f6bdf16d28b2d637686ca", "message": "Add more tests.", "committedDate": "2020-11-03T00:36:26Z", "type": "commit"}, {"oid": "4efe624f6c0da7c6a250e5e949b2e849b4dac433", "url": "https://github.com/ConsenSys/teku/commit/4efe624f6c0da7c6a250e5e949b2e849b4dac433", "message": "Errorprone.", "committedDate": "2020-11-03T00:50:31Z", "type": "commit"}, {"oid": "a3d970957358c47a20ae4aea13973bb6628aa6e7", "url": "https://github.com/ConsenSys/teku/commit/a3d970957358c47a20ae4aea13973bb6628aa6e7", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-proto-snapshots\n\n# Conflicts:\n#\tstorage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java\n#\tstorage/src/main/java/tech/pegasys/teku/storage/store/StoreBuilder.java", "committedDate": "2020-11-03T01:10:55Z", "type": "commit"}, {"oid": "d081db2c54e873915c1bd443c8386d569a807dbf", "url": "https://github.com/ConsenSys/teku/commit/d081db2c54e873915c1bd443c8386d569a807dbf", "message": "Introduce BlockMetadataStore so Store can use either BlockTree or ProtoArrayForkChoiceStrategy to store block metadata.\nWhen ProtoArrayForkChoiceStrategy is used, two copies are held and the one used by Store isn't pruned.", "committedDate": "2020-11-03T09:48:45Z", "type": "commit"}, {"oid": "e0965ecef68705da39de8d21e515f75771cb9bc8", "url": "https://github.com/ConsenSys/teku/commit/e0965ecef68705da39de8d21e515f75771cb9bc8", "message": "Use the ProtoArrayForkChoiceStrategy instance from Store for everything.\nUse BlockTree only for initial migration, then switch the store to ProtoArray backing.", "committedDate": "2020-11-03T10:32:27Z", "type": "commit"}, {"oid": "37b163986ec8d48ff41c93bfb49d0b208b51936f", "url": "https://github.com/ConsenSys/teku/commit/37b163986ec8d48ff41c93bfb49d0b208b51936f", "message": "Rename.", "committedDate": "2020-11-03T10:37:45Z", "type": "commit"}, {"oid": "e6dc6067f957374b13229b0007aa3da858ca51a5", "url": "https://github.com/ConsenSys/teku/commit/e6dc6067f957374b13229b0007aa3da858ca51a5", "message": "Update StoreAssertions.", "committedDate": "2020-11-03T11:11:53Z", "type": "commit"}, {"oid": "9e0113baad6896889a0fb282f196afdd35b34fb6", "url": "https://github.com/ConsenSys/teku/commit/9e0113baad6896889a0fb282f196afdd35b34fb6", "message": "Exclude nodes that should have been pruned when processing nodes in chain.", "committedDate": "2020-11-03T11:31:47Z", "type": "commit"}, {"oid": "5dbad8854f281c76f89dfda08fce4289b07f5c2e", "url": "https://github.com/ConsenSys/teku/commit/5dbad8854f281c76f89dfda08fce4289b07f5c2e", "message": "Fix test.", "committedDate": "2020-11-03T20:41:35Z", "type": "commit"}, {"oid": "0af7efa56181b462e695d4984171d5849f538de3", "url": "https://github.com/ConsenSys/teku/commit/0af7efa56181b462e695d4984171d5849f538de3", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-03T20:41:44Z", "type": "commit"}, {"oid": "e0a97daa5f3fd8ffebff5f257f48033b98d8b463", "url": "https://github.com/ConsenSys/teku/commit/e0a97daa5f3fd8ffebff5f257f48033b98d8b463", "message": "Remove todo.", "committedDate": "2020-11-03T20:58:21Z", "type": "commit"}, {"oid": "64dc6d47ffeecadda895930244dae491c68827b4", "url": "https://github.com/ConsenSys/teku/commit/64dc6d47ffeecadda895930244dae491c68827b4", "message": "Merge branch 'master' into no-snapshot-proto-in-store", "committedDate": "2020-11-04T00:47:59Z", "type": "commit"}, {"oid": "4ea5e8a16538f39db0dc10b729a5e5c407dea7f0", "url": "https://github.com/ConsenSys/teku/commit/4ea5e8a16538f39db0dc10b729a5e5c407dea7f0", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-04T03:55:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r517577001", "bodyText": "I think you need to process the base blocks first so the parentRoot-based filtering works", "author": "mbaxter", "createdAt": "2020-11-04T19:21:21Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java", "diffHunk": "@@ -159,10 +170,37 @@ private StoreTransactionUpdates buildFinalizedUpdates(final Checkpoint finalized\n     return states;\n   }\n \n-  private void calculatePrunedHotBlockRoots(StoreTransaction tx, final BlockTree prunedTree) {\n-    tx.getBlockRoots().stream()\n-        .filter(root -> !prunedTree.contains(root))\n-        .forEach(prunedHotBlockRoots::add);\n+  private boolean shouldPrune(\n+      final SignedBeaconBlock finalizedBlock,\n+      final Bytes32 blockRoot,\n+      final UInt64 slot,\n+      final Bytes32 parentRoot) {\n+    return (slot.isLessThanOrEqualTo(finalizedBlock.getSlot())\n+            || prunedHotBlockRoots.contains(parentRoot))\n+        // Keep the actual finalized block\n+        && !blockRoot.equals(finalizedBlock.getRoot());\n+  }\n+\n+  private void calculatePrunedHotBlockRoots() {\n+    final SignedBeaconBlock finalizedBlock = tx.getLatestFinalized().getBlock();\n+    tx.blockAndStates.values().stream()\n+        // Iterate new blocks in slot order to guarantee we see parents first\n+        .sorted(Comparator.comparing(SignedBlockAndState::getSlot))\n+        .filter(\n+            newBlockAndState ->\n+                shouldPrune(\n+                    finalizedBlock,\n+                    newBlockAndState.getRoot(),\n+                    newBlockAndState.getSlot(),\n+                    newBlockAndState.getParentRoot()))\n+        .forEach(newBlockAndState -> prunedHotBlockRoots.add(newBlockAndState.getRoot()));\n+\n+    baseStore.blockMetadata.processAllInOrder(", "originalCommit": "4ea5e8a16538f39db0dc10b729a5e5c407dea7f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTUwNQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r517621505", "bodyText": "ooo, good spot.", "author": "ajsutton", "createdAt": "2020-11-04T20:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1Mzg4Nw==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520753887", "bodyText": "We should add a test that covers this if we don't already have one.", "author": "mbaxter", "createdAt": "2020-11-10T17:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NTkwOA==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521095908", "bodyText": "Done.", "author": "ajsutton", "createdAt": "2020-11-11T03:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "fc5ca6c929acace9fb59df98fcf0a1af5d68e04b", "chunk": "diff --git a/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java b/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java\nindex 45d367c7a4..1a81431a75 100644\n--- a/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java\n+++ b/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java\n\n@@ -183,6 +183,13 @@ class StoreTransactionUpdatesFactory {\n \n   private void calculatePrunedHotBlockRoots() {\n     final SignedBeaconBlock finalizedBlock = tx.getLatestFinalized().getBlock();\n+    baseStore.blockMetadata.processAllInOrder(\n+        (blockRoot, slot, parentRoot) -> {\n+          if (shouldPrune(finalizedBlock, blockRoot, slot, parentRoot)) {\n+            prunedHotBlockRoots.add(blockRoot);\n+          }\n+        });\n+\n     tx.blockAndStates.values().stream()\n         // Iterate new blocks in slot order to guarantee we see parents first\n         .sorted(Comparator.comparing(SignedBlockAndState::getSlot))\n"}}, {"oid": "fc5ca6c929acace9fb59df98fcf0a1af5d68e04b", "url": "https://github.com/ConsenSys/teku/commit/fc5ca6c929acace9fb59df98fcf0a1af5d68e04b", "message": "Iterate existing blocks first, before new ones to ensure new blocks which don't descend from a new finalized checkpoint are pruned correctly.", "committedDate": "2020-11-04T20:45:19Z", "type": "commit"}, {"oid": "6caf75e96622bd5a49493c7d7523ab008c1c44dc", "url": "https://github.com/ConsenSys/teku/commit/6caf75e96622bd5a49493c7d7523ab008c1c44dc", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-04T20:45:27Z", "type": "commit"}, {"oid": "032be5b0904ea509535f48fa88d5d9c8af0d5a29", "url": "https://github.com/ConsenSys/teku/commit/032be5b0904ea509535f48fa88d5d9c8af0d5a29", "message": "Fix compile errors from master merges.", "committedDate": "2020-11-04T20:51:24Z", "type": "commit"}, {"oid": "d3aa00f64597696058ffee6531271f4f8c26b762", "url": "https://github.com/ConsenSys/teku/commit/d3aa00f64597696058ffee6531271f4f8c26b762", "message": "Fix checkpoint epochs from anchor state.", "committedDate": "2020-11-04T21:04:19Z", "type": "commit"}, {"oid": "7c8e2924089191b43c9b5dbca8c5b04aafb5295c", "url": "https://github.com/ConsenSys/teku/commit/7c8e2924089191b43c9b5dbca8c5b04aafb5295c", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-05T00:41:26Z", "type": "commit"}, {"oid": "71292ad645560bf726b312db2e3d1df02bc83e09", "url": "https://github.com/ConsenSys/teku/commit/71292ad645560bf726b312db2e3d1df02bc83e09", "message": "Avoid deadlock when updating fork choice scores.\nEnsure the store lock is still taken first, before the protoArray lock.", "committedDate": "2020-11-05T04:24:26Z", "type": "commit"}, {"oid": "0694168cbf8705525b8ce9b4b5201df65657495c", "url": "https://github.com/ConsenSys/teku/commit/0694168cbf8705525b8ce9b4b5201df65657495c", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-05T04:45:31Z", "type": "commit"}, {"oid": "3512338dda4cac69d937a73aaec734eb26f9dec5", "url": "https://github.com/ConsenSys/teku/commit/3512338dda4cac69d937a73aaec734eb26f9dec5", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-05T20:12:58Z", "type": "commit"}, {"oid": "19279080d5350605a32356ab1ab2798229c2022b", "url": "https://github.com/ConsenSys/teku/commit/19279080d5350605a32356ab1ab2798229c2022b", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-05T22:23:15Z", "type": "commit"}, {"oid": "25c1d01d815dee2f0ff3150e35467fbfaacf8052", "url": "https://github.com/ConsenSys/teku/commit/25c1d01d815dee2f0ff3150e35467fbfaacf8052", "message": "Add tests and remove redundant classes.", "committedDate": "2020-11-06T00:19:26Z", "type": "commit"}, {"oid": "a6f1d6ef6c5a1ef9ffbc26e2d238d6e8aaaa174c", "url": "https://github.com/ConsenSys/teku/commit/a6f1d6ef6c5a1ef9ffbc26e2d238d6e8aaaa174c", "message": "Test BlockMetadataStore methods.", "committedDate": "2020-11-06T02:45:39Z", "type": "commit"}, {"oid": "918916c01b09b2bc1a3b61d90d07773aba57bb04", "url": "https://github.com/ConsenSys/teku/commit/918916c01b09b2bc1a3b61d90d07773aba57bb04", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-06T02:45:44Z", "type": "commit"}, {"oid": "2d49c56289fcd14ebaf10be227be0457a56b8364", "url": "https://github.com/ConsenSys/teku/commit/2d49c56289fcd14ebaf10be227be0457a56b8364", "message": "Add @Override.", "committedDate": "2020-11-06T04:24:32Z", "type": "commit"}, {"oid": "15d828d2d0108476493a33f09fdb44e714d3cc2e", "url": "https://github.com/ConsenSys/teku/commit/15d828d2d0108476493a33f09fdb44e714d3cc2e", "message": "Add more @Override.", "committedDate": "2020-11-06T04:25:59Z", "type": "commit"}, {"oid": "03b4a7f812f616116cc2b3edab28efa481d58e17", "url": "https://github.com/ConsenSys/teku/commit/03b4a7f812f616116cc2b3edab28efa481d58e17", "message": "Errorprone", "committedDate": "2020-11-06T04:39:00Z", "type": "commit"}, {"oid": "6c862ed659438d0e55bfae39238a8d59722d888c", "url": "https://github.com/ConsenSys/teku/commit/6c862ed659438d0e55bfae39238a8d59722d888c", "message": "Fix tests.", "committedDate": "2020-11-06T05:24:03Z", "type": "commit"}, {"oid": "2c3cda7bdeb1f4d97c1230b02fbf3dbb0229e939", "url": "https://github.com/ConsenSys/teku/commit/2c3cda7bdeb1f4d97c1230b02fbf3dbb0229e939", "message": "Merge branch 'master' into no-snapshot-proto-in-store", "committedDate": "2020-11-06T05:47:16Z", "type": "commit"}, {"oid": "1aca601b246470418dadd781b1ee2193b2cce023", "url": "https://github.com/ConsenSys/teku/commit/1aca601b246470418dadd781b1ee2193b2cce023", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-08T23:23:47Z", "type": "commit"}, {"oid": "711c364e8f91b0af33a479431bfd892629ee8cb0", "url": "https://github.com/ConsenSys/teku/commit/711c364e8f91b0af33a479431bfd892629ee8cb0", "message": "Merge branch 'no-snapshot-proto-in-store' of github.com:ajsutton/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-08T23:23:55Z", "type": "commit"}, {"oid": "36b261539eb2193410edaf5bf205516b9df1718c", "url": "https://github.com/ConsenSys/teku/commit/36b261539eb2193410edaf5bf205516b9df1718c", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-09T22:40:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMDk2Ng==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520800966", "bodyText": "Why are we invoking this from store rather than just holding the logic in the tx object?", "author": "mbaxter", "createdAt": "2020-11-10T18:58:03Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java", "diffHunk": "@@ -137,6 +137,15 @@ public VoteTracker getVote(UInt64 validatorIndex) {\n     return vote;\n   }\n \n+  @Override\n+  public Bytes32 applyForkChoiceScoreChanges(\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    return store.applyForkChoiceScoreChanges(", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NTQ3Mg==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520965472", "bodyText": "Mostly because exposing the Store locks made me really, really nervous.  I'll give it a go and see what happens.", "author": "ajsutton", "createdAt": "2020-11-11T00:43:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMDk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NjA3MQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520966071", "bodyText": "oh look, the lock is already passed to the transaction - I totally missed that....", "author": "ajsutton", "createdAt": "2020-11-11T00:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMDk2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "33227f755168611b9fefe977efcca34f4a7df3f7", "chunk": "diff --git a/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java b/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java\nindex 49e99cb379..36aac09bca 100644\n--- a/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java\n+++ b/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java\n\n@@ -142,8 +142,18 @@ class StoreTransaction implements UpdatableStore.StoreTransaction {\n       final Checkpoint finalizedCheckpoint,\n       final Checkpoint justifiedCheckpoint,\n       final BeaconState justifiedCheckpointState) {\n-    return store.applyForkChoiceScoreChanges(\n-        this, finalizedCheckpoint, justifiedCheckpoint, justifiedCheckpointState);\n+\n+    // Ensure the store lock is taken before entering forkChoiceStrategy. Otherwise it takes the\n+    // protoArray lock first, and may deadlock when it later needs to get votes which requires the\n+    // store lock.\n+    lock.writeLock().lock();\n+    try {\n+      return store\n+          .getForkChoiceStrategy()\n+          .findHead(this, finalizedCheckpoint, justifiedCheckpoint, justifiedCheckpointState);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n   }\n \n   @CheckReturnValue\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYyNw==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520811627", "bodyText": "Probably worth adding some comments on the indices and nodes variables / getters explaining how they differ wrt pruning.", "author": "mbaxter", "createdAt": "2020-11-10T19:13:30Z", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "diffHunk": "@@ -405,4 +405,8 @@ public UInt64 getFinalizedEpoch() {\n   public UInt64 getInitialEpoch() {\n     return initialEpoch;\n   }\n+\n+  public void removeBlockRoot(final Bytes32 blockRoot) {\n+    indices.remove(blockRoot);", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MjYxMA==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520972610", "bodyText": "Added comments.", "author": "ajsutton", "createdAt": "2020-11-11T00:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYyNw=="}], "type": "inlineReview", "revised_code": {"commit": "1ac0159395cd43fa4cc1d17671541479f5688576", "chunk": "diff --git a/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java b/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java\nindex 151bfc54d7..d9d7a9a02e 100644\n--- a/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java\n+++ b/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java\n\n@@ -406,6 +423,14 @@ public class ProtoArray {\n     return initialEpoch;\n   }\n \n+  /**\n+   * Removes a block root from the lookup map. The actual node is not removed from the protoarray to\n+   * avoid recalculating indices. As a result, looking up the block by root will not find it but it\n+   * may still be \"found\" when iterating through all nodes or following links to parent or ancestor\n+   * nodes.\n+   *\n+   * @param blockRoot the block root to remove from the lookup map.\n+   */\n   public void removeBlockRoot(final Bytes32 blockRoot) {\n     indices.remove(blockRoot);\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjkwNQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520812905", "bodyText": "There's also:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final UInt64 epoch = BeaconStateUtil.compute_epoch_at_slot(block.getSlot()).plus(1);\n          \n          \n            \n                final UInt64 epoch = BeaconStateUtil.compute_next_epoch_boundary(block.getSlot());\n          \n      \n    \n    \n  \n\n:D", "author": "mbaxter", "createdAt": "2020-11-10T19:15:37Z", "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java", "diffHunk": "@@ -97,6 +102,11 @@ void getAncestors_shouldGetSequenceOfRootsWhenStartIsPriorToFinalizedCheckpoint(\n     assertThat(rootsBySlot).containsExactlyEntriesOf(getRootsForBlocks(5, 7));\n   }\n \n+  private Checkpoint createCheckpointFromBlock(final SignedBeaconBlock block) {\n+    final UInt64 epoch = BeaconStateUtil.compute_epoch_at_slot(block.getSlot()).plus(1);", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "05fb923b9f96e28683b640e14077f0ea1c35317a", "chunk": "diff --git a/ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java b/ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java\nindex 3520b42275..702b4847fd 100644\n--- a/ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java\n+++ b/ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java\n\n@@ -103,7 +104,7 @@ class ForkChoiceUtilTest {\n   }\n \n   private Checkpoint createCheckpointFromBlock(final SignedBeaconBlock block) {\n-    final UInt64 epoch = BeaconStateUtil.compute_epoch_at_slot(block.getSlot()).plus(1);\n+    final UInt64 epoch = compute_next_epoch_boundary(block.getSlot());\n     return new Checkpoint(epoch, block.getRoot());\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyODI5MA==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520828290", "bodyText": "Looks like ForkChoiceStrategy.onBlock is no longer used in production.  We should probably see if we can get rid of this method - looks like its used in some storage-related tests which could be interfering with test outcomes ...", "author": "mbaxter", "createdAt": "2020-11-10T19:42:09Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -149,20 +148,17 @@ private void processHead(Optional<UInt64> nodeSlot) {\n                       forkChoiceStrategy.onAttestation(transaction, indexedAttestation));\n           return transaction\n               .commit()\n-              .thenRun(() -> updateForkChoiceForImportedBlock(block, forkChoiceStrategy, result))\n+              .thenRun(() -> updateForkChoiceForImportedBlock(block, result))\n               .thenApply(__ -> result);\n         });\n   }\n \n   private void updateForkChoiceForImportedBlock(\n-      final SignedBeaconBlock block,\n-      final ForkChoiceStrategy forkChoiceStrategy,\n-      final BlockImportResult result) {\n+      final SignedBeaconBlock block, final BlockImportResult result) {\n     result\n         .getBlockProcessingRecord()\n         .ifPresent(\n             record -> {\n-              forkChoiceStrategy.onBlock(block.getMessage(), record.getPostState());", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwOTE3MQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521009171", "bodyText": "Removed.  Hopefully tests should pass because the protoarray gets updated as part of adding a block in a transaction now, but I guess we'll find out.", "author": "ajsutton", "createdAt": "2020-11-11T01:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyODI5MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzAxNw==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520833017", "bodyText": "Maybe we should add some methods like getTrackedNodeCount() and getNonFinalNodeCount() or similar to make it clearer what these size values mean.", "author": "mbaxter", "createdAt": "2020-11-10T19:50:07Z", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "diffHunk": "@@ -234,7 +230,11 @@ Bytes32 findHead(\n \n       List<Long> deltas =\n           ProtoArrayScoreCalculator.computeDeltas(\n-              store, protoArray.getIndices(), oldBalances, newBalances);\n+              store,\n+              protoArray.getNodes().size(),", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1MjI1Nw==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521052257", "bodyText": "Added getTotalTrackedNodeCount. I don't think we ever use the number of nodes in the index map.", "author": "ajsutton", "createdAt": "2020-11-11T02:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzAxNw=="}], "type": "inlineReview", "revised_code": {"commit": "ccbe873896dabd8e36dbd91b4e264f5312eb582c", "chunk": "diff --git a/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java b/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java\nindex f742d3d29e..d735f67b11 100644\n--- a/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java\n+++ b/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java\n\n@@ -230,11 +202,7 @@ public class ProtoArrayForkChoiceStrategy implements ForkChoiceStrategy, BlockMe\n \n       List<Long> deltas =\n           ProtoArrayScoreCalculator.computeDeltas(\n-              store,\n-              protoArray.getNodes().size(),\n-              protoArray.getIndices(),\n-              oldBalances,\n-              newBalances);\n+              store, getTotalTrackedNodeCount(), protoArray.getIndices(), oldBalances, newBalances);\n \n       protoArray.applyScoreChanges(deltas, justifiedEpoch, finalizedEpoch);\n       balances = new ArrayList<>(newBalances);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0Mjc2Ng==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520842766", "bodyText": "Shouldn't we check that these were processed in order?", "author": "mbaxter", "createdAt": "2020-11-10T20:07:22Z", "path": "protoarray/src/test/java/tech/pegasys/teku/protoarray/AbstractBlockMetadataStoreTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.protoarray;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.util.config.Constants.GENESIS_EPOCH;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.datastructures.blocks.BlockAndCheckpointEpochs;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.blocks.StateAndBlockSummary;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+abstract class AbstractBlockMetadataStoreTest {\n+\n+  private final ChainBuilder chainBuilder = ChainBuilder.createDefault();\n+  private final SignedBlockAndState genesis = chainBuilder.generateGenesis();\n+  private final Checkpoint genesisCheckpoint =\n+      new Checkpoint(UInt64.valueOf(GENESIS_EPOCH), genesis.getRoot());\n+\n+  @Test\n+  void contains_shouldOnlyContainBlocksThatExist() {\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    assertThat(store.contains(genesis.getRoot())).isTrue();\n+    assertThat(store.contains(Bytes32.ZERO)).isFalse();\n+  }\n+\n+  @Test\n+  void contains_shouldContainAddedBlocks() {\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final BlockAndCheckpointEpochs block1 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(1));\n+    final BlockAndCheckpointEpochs block2 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(2));\n+    final BlockAndCheckpointEpochs block3 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(3));\n+\n+    final BlockMetadataStore updatedStore =\n+        store.applyUpdate(\n+            List.of(block1, block2, block3), Collections.emptySet(), genesisCheckpoint);\n+\n+    chainBuilder\n+        .streamBlocksAndStates()\n+        .forEach(block -> assertThat(updatedStore.contains(block.getRoot())).isTrue());\n+  }\n+\n+  @Test\n+  void contains_shouldNotContainRemovedBlocks() {\n+    BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final BlockAndCheckpointEpochs block1 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(1));\n+    final BlockAndCheckpointEpochs block2 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(2));\n+    final BlockAndCheckpointEpochs block3 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(3));\n+\n+    store =\n+        store.applyUpdate(\n+            List.of(block1, block2, block3),\n+            Set.of(genesis.getRoot(), block1.getRoot()),\n+            new Checkpoint(UInt64.ONE, block2.getRoot()));\n+\n+    assertThat(store.contains(genesis.getRoot())).isFalse();\n+    assertThat(store.contains(block1.getRoot())).isFalse();\n+    assertThat(store.contains(block2.getRoot())).isTrue();\n+    assertThat(store.contains(block3.getRoot())).isTrue();\n+  }\n+\n+  @Test\n+  void processAllInOrder_shouldVisitAllBlocksInSingleChain() {\n+    final int lastSlot = 10;\n+    chainBuilder.generateBlocksUpToSlot(lastSlot);\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final AtomicInteger expectedNextSlot = new AtomicInteger(0);\n+    store.processAllInOrder(\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(slot).isEqualTo(UInt64.valueOf(expectedNextSlot.getAndIncrement()));\n+          final SignedBeaconBlock block = chainBuilder.getBlockAtSlot(slot);\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+        });\n+    // We should have processed the block in the last slot and now be expected the one after\n+    assertThat(expectedNextSlot).hasValue(lastSlot + 1);\n+  }\n+\n+  @Test\n+  void processAllInOrder_shouldVisitParentBlocksBeforeChildBlocksInForks() {\n+    // First chain has all blocks up to 10\n+    // Fork chain has 0-5, skips 6 and then has 7-10\n+    chainBuilder.generateBlocksUpToSlot(5);\n+    final ChainBuilder forkBuilder = chainBuilder.fork();\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    forkBuilder.generateBlockAtSlot(7);\n+    forkBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store =\n+        createBlockMetadataStore(chainBuilder)\n+            .applyUpdate(\n+                forkBuilder\n+                    .streamBlocksAndStates()\n+                    .map(BlockAndCheckpointEpochs::fromBlockAndState)\n+                    .collect(toList()),\n+                Collections.emptySet(),\n+                genesisCheckpoint);\n+\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    store.processAllInOrder(\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          if (!seenBlocks.isEmpty()) {\n+            // First block won't have visited the parent\n+            assertThat(seenBlocks).contains(parentRoot);\n+          }\n+\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block =\n+              chainBuilder\n+                  .getBlock(childRoot)\n+                  .or(() -> forkBuilder.getBlock(childRoot))\n+                  .orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+        });\n+    // Check every block was seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        Stream.concat(chainBuilder.streamBlocksAndStates(), forkBuilder.streamBlocksAndStates())\n+            .map(StateAndBlockSummary::getRoot)\n+            .collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);\n+  }\n+\n+  @Test\n+  void processHashesInChain_shouldWalkUpSpecifiedChain() {\n+    // First chain has all blocks up to 10\n+    // Fork chain has 0-5, skips 6 and then has 7-10\n+    chainBuilder.generateBlocksUpToSlot(5);\n+    final ChainBuilder forkBuilder = chainBuilder.fork();\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    forkBuilder.generateBlockAtSlot(7);\n+    forkBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store =\n+        createBlockMetadataStore(chainBuilder)\n+            .applyUpdate(\n+                forkBuilder\n+                    .streamBlocksAndStates()\n+                    .map(BlockAndCheckpointEpochs::fromBlockAndState)\n+                    .collect(toList()),\n+                Collections.emptySet(),\n+                genesisCheckpoint);\n+\n+    verifyHashesInChain(\n+        store,\n+        forkBuilder,\n+        forkBuilder.getLatestBlockAndState().getRoot(),\n+        forkBuilder.streamBlocksAndStates());\n+    verifyHashesInChain(\n+        store,\n+        chainBuilder,\n+        chainBuilder.getLatestBlockAndState().getRoot(),\n+        chainBuilder.streamBlocksAndStates());\n+\n+    // And check we can start from part way along the chain\n+    verifyHashesInChain(\n+        store,\n+        chainBuilder,\n+        chainBuilder.getBlockAtSlot(6).getRoot(),\n+        chainBuilder.streamBlocksAndStates(0, 6));\n+  }\n+\n+  @Test\n+  void processHashesInChainWhile_shouldStopProcessingWhenProcessorReturnsFalse() {\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+\n+    // And check we can start from part way along the chain\n+    final Bytes32 headRoot = chainBuilder.getBlockAtSlot(6).getRoot();\n+    final Stream<SignedBlockAndState> expectedBlocks = chainBuilder.streamBlocksAndStates(3, 6);\n+\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    final AtomicReference<Bytes32> expectedBlock = new AtomicReference<>(headRoot);\n+    store.processHashesInChainWhile(\n+        headRoot,\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block = chainBuilder.getBlock(expectedBlock.get()).orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+\n+          expectedBlock.set(block.getParentRoot());\n+          return !slot.equals(UInt64.valueOf(3));\n+        });\n+    // Check all fork blocks were seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        expectedBlocks.map(StateAndBlockSummary::getRoot).collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);\n+  }\n+\n+  private void verifyHashesInChain(\n+      final BlockMetadataStore store,\n+      final ChainBuilder chain,\n+      final Bytes32 headRoot,\n+      final Stream<SignedBlockAndState> expectedBlocks) {\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    final AtomicReference<Bytes32> expectedBlock = new AtomicReference<>(headRoot);\n+    store.processHashesInChain(\n+        headRoot,\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block = chain.getBlock(expectedBlock.get()).orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+\n+          expectedBlock.set(block.getParentRoot());\n+        });\n+    // Check all fork blocks were seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        expectedBlocks.map(StateAndBlockSummary::getRoot).collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1NTQ5Nw==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521055497", "bodyText": "We're tracking that we go from child to parent on each step which also checks order.", "author": "ajsutton", "createdAt": "2020-11-11T02:54:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0Mjc2Ng=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTg1NQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520849855", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ProtoArrayForkChoiceStrategy.initialize(store, protoArrayStorageChannel).join();\n          \n          \n            \n                      ProtoArrayForkChoiceStrategy.initializeAndMigrateStorage(store, protoArrayStorageChannel).join();", "author": "mbaxter", "createdAt": "2020-11-10T20:20:37Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -169,33 +183,88 @@ public static UpdatableStore create(\n         CachingTaskQueue.create(\n             asyncRunner, metricsSystem, \"memory_states\", config.getStateCacheSize());\n \n-    // Build block tree structure\n-    HashTree.Builder treeBuilder = HashTree.builder().rootHash(finalizedAnchor.getRoot());\n-    childToParentRoot.forEach(treeBuilder::childAndParentRoots);\n-    final BlockTree blockTree = BlockTree.create(treeBuilder.build(), rootToSlotMap);\n-    if (blockTree.size() < childToParentRoot.size()) {\n-      final int invalidBlockCount = childToParentRoot.size() - blockTree.size();\n-      throw new IllegalStateException(\n-          invalidBlockCount\n-              + \" invalid non-canonical block(s) supplied to Store that do not descend from the latest finalized block.\");\n+    final Optional<ProtoArrayForkChoiceStrategy> maybeForkChoiceStrategy =\n+        buildProtoArray(blockInfoByRoot, initialCheckpoint, justifiedCheckpoint, finalizedAnchor)\n+            .map(ProtoArrayForkChoiceStrategy::initialize);\n+\n+    final BlockMetadataStore blockMetadataStore =\n+        maybeForkChoiceStrategy\n+            .<BlockMetadataStore>map(a -> a)\n+            .orElseGet(\n+                () -> {\n+                  // Build block tree structure\n+                  final Map<Bytes32, Bytes32> childToParentRoot =\n+                      Maps.transformValues(blockInfoByRoot, StoredBlockMetadata::getParentRoot);\n+                  final Map<Bytes32, UInt64> rootToSlotMap =\n+                      Maps.transformValues(blockInfoByRoot, StoredBlockMetadata::getBlockSlot);\n+                  HashTree.Builder treeBuilder =\n+                      HashTree.builder().rootHash(finalizedAnchor.getRoot());\n+                  childToParentRoot.forEach(treeBuilder::childAndParentRoots);\n+                  final BlockTree blockTree = BlockTree.create(treeBuilder.build(), rootToSlotMap);\n+                  if (blockTree.size() < childToParentRoot.size()) {\n+                    final int invalidBlockCount = childToParentRoot.size() - blockTree.size();\n+                    throw new IllegalStateException(\n+                        invalidBlockCount\n+                            + \" invalid non-canonical block(s) supplied to Store that do not descend from the latest finalized block.\");\n+                  }\n+                  return blockTree;\n+                });\n+\n+    final Store store =\n+        new Store(\n+            metricsSystem,\n+            config.getHotStatePersistenceFrequencyInEpochs(),\n+            blockProvider,\n+            stateAndBlockProvider,\n+            stateTaskQueue,\n+            initialCheckpoint,\n+            time,\n+            genesisTime,\n+            finalizedAnchor,\n+            justifiedCheckpoint,\n+            bestJustifiedCheckpoint,\n+            blockMetadataStore,\n+            votes,\n+            blocks,\n+            checkpointStateTaskQueue);\n+    if (maybeForkChoiceStrategy.isEmpty()) {\n+      final ProtoArrayForkChoiceStrategy forkChoiceStrategy =\n+          ProtoArrayForkChoiceStrategy.initialize(store, protoArrayStorageChannel).join();", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ccbe873896dabd8e36dbd91b4e264f5312eb582c", "chunk": "diff --git a/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java b/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java\nindex 39781e68b1..b82356ba84 100644\n--- a/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java\n+++ b/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java\n\n@@ -229,7 +228,7 @@ class Store implements UpdatableStore {\n             checkpointStateTaskQueue);\n     if (maybeForkChoiceStrategy.isEmpty()) {\n       final ProtoArrayForkChoiceStrategy forkChoiceStrategy =\n-          ProtoArrayForkChoiceStrategy.initialize(store, protoArrayStorageChannel).join();\n+          ProtoArrayForkChoiceStrategy.initializeAndMigrateStorage(store, protoArrayStorageChannel).join();\n       store.blockMetadata = forkChoiceStrategy;\n       store.forkChoiceStrategy = forkChoiceStrategy;\n     } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NTc5Mg==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520865792", "bodyText": "To make sure I understand, the deadlock would happen in the following way?:\n\nWe enter this method, run findHead and acquire the protoarray locks\nAnother transaction finishes, acquires store locks, and tries to acquire protoarray locks in BlockMetadataStore.applyUpdates, but can't\nfindHead now tries to acquire the store locks but can't", "author": "mbaxter", "createdAt": "2020-11-10T20:51:07Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -597,4 +676,21 @@ private void putBlock(final SignedBeaconBlock block) {\n       writeLock.unlock();\n     }\n   }\n+\n+  Bytes32 applyForkChoiceScoreChanges(\n+      final MutableStore transaction,\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    // Ensure the store lock is taken before entering forkChoiceStrategy. Otherwise it takes the\n+    // protoArray lock first, and may deadlock when it later needs to get votes which requires the\n+    // store lock.", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2OTA2NQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520869065", "bodyText": "And ProtoArrayForkChoiceStrategy.onAttestation doesn't create a similar problem because it's only acquiring the votesLock?", "author": "mbaxter", "createdAt": "2020-11-10T20:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NTc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1NzUzOQ==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521057539", "bodyText": "Correct on both counts. The deadlock is between two transactions, one that's running through findHead and one that's importing blocks.", "author": "ajsutton", "createdAt": "2020-11-11T02:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NTc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "33227f755168611b9fefe977efcca34f4a7df3f7", "chunk": "diff --git a/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java b/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java\nindex 39781e68b1..6f2e2c6218 100644\n--- a/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java\n+++ b/storage/src/main/java/tech/pegasys/teku/storage/store/Store.java\n\n@@ -676,21 +675,4 @@ class Store implements UpdatableStore {\n       writeLock.unlock();\n     }\n   }\n-\n-  Bytes32 applyForkChoiceScoreChanges(\n-      final MutableStore transaction,\n-      final Checkpoint finalizedCheckpoint,\n-      final Checkpoint justifiedCheckpoint,\n-      final BeaconState justifiedCheckpointState) {\n-    // Ensure the store lock is taken before entering forkChoiceStrategy. Otherwise it takes the\n-    // protoArray lock first, and may deadlock when it later needs to get votes which requires the\n-    // store lock.\n-    lock.writeLock().lock();\n-    try {\n-      return forkChoiceStrategy.findHead(\n-          transaction, finalizedCheckpoint, justifiedCheckpoint, justifiedCheckpointState);\n-    } finally {\n-      lock.writeLock().unlock();\n-    }\n-  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzUzMA==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520877530", "bodyText": "Doesn't this only save the first epoch boundary seen as processing hashes on the chain instead of saving the latest one?", "author": "cemozerr", "createdAt": "2020-11-10T21:14:02Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -500,17 +566,14 @@ VoteTracker getVote(UInt64 validatorIndex) {\n     final AtomicReference<SlotAndBlockRoot> latestEpochBoundary = new AtomicReference<>();\n     readLock.lock();\n     try {\n-      blockTree\n-          .getHashTree()\n-          .processHashesInChain(\n-              blockRoot,\n-              (root, parent) -> {\n-                treeBuilder.childAndParentRoots(root, parent);\n-                if (shouldPersistState(blockTree, root)) {\n-                  latestEpochBoundary.compareAndExchange(\n-                      null, new SlotAndBlockRoot(blockTree.getSlot(root), root));\n-                }\n-              });\n+      blockMetadata.processHashesInChain(\n+          blockRoot,\n+          (root, slot, parent) -> {\n+            treeBuilder.childAndParentRoots(root, parent);\n+            if (shouldPersistState(slot, parent)) {\n+              latestEpochBoundary.compareAndExchange(null, new SlotAndBlockRoot(slot, root));", "originalCommit": "36b261539eb2193410edaf5bf205516b9df1718c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Nzg5NA==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520877894", "bodyText": ".compareAndExchange seems to only set the value to the second argument, if the reference is equal to the first argument.", "author": "cemozerr", "createdAt": "2020-11-10T21:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1ODM1Mw==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521058353", "bodyText": "We're walking from the head backwards through the chain and want to capture the one closest to head, which will be the first one seen.", "author": "ajsutton", "createdAt": "2020-11-11T02:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzUzMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "fc611f117583a06b3f904c723331a51e59ea93fd", "url": "https://github.com/ConsenSys/teku/commit/fc611f117583a06b3f904c723331a51e59ea93fd", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-11T00:43:08Z", "type": "commit"}, {"oid": "33227f755168611b9fefe977efcca34f4a7df3f7", "url": "https://github.com/ConsenSys/teku/commit/33227f755168611b9fefe977efcca34f4a7df3f7", "message": "Move logic to apply fork choice score changes to the transaction instead of going back to the store.", "committedDate": "2020-11-11T00:47:18Z", "type": "commit"}, {"oid": "1ac0159395cd43fa4cc1d17671541479f5688576", "url": "https://github.com/ConsenSys/teku/commit/1ac0159395cd43fa4cc1d17671541479f5688576", "message": "Add comments explaining what happens when nodes are removed.", "committedDate": "2020-11-11T00:56:32Z", "type": "commit"}, {"oid": "05fb923b9f96e28683b640e14077f0ea1c35317a", "url": "https://github.com/ConsenSys/teku/commit/05fb923b9f96e28683b640e14077f0ea1c35317a", "message": "Remove onBlock.", "committedDate": "2020-11-11T01:45:37Z", "type": "commit"}, {"oid": "85b73a79a947b94a97ecef1b3a8e79a083d4babb", "url": "https://github.com/ConsenSys/teku/commit/85b73a79a947b94a97ecef1b3a8e79a083d4babb", "message": "Merge branch 'master' of github.com:ConsenSys/teku into no-snapshot-proto-in-store", "committedDate": "2020-11-11T03:07:18Z", "type": "commit"}, {"oid": "ccbe873896dabd8e36dbd91b4e264f5312eb582c", "url": "https://github.com/ConsenSys/teku/commit/ccbe873896dabd8e36dbd91b4e264f5312eb582c", "message": "Review feedback.", "committedDate": "2020-11-11T03:16:34Z", "type": "commit"}, {"oid": "4e3142607c1581f87f4e66ab2405ccc9a39afef8", "url": "https://github.com/ConsenSys/teku/commit/4e3142607c1581f87f4e66ab2405ccc9a39afef8", "message": "Spotless.", "committedDate": "2020-11-11T03:42:49Z", "type": "commit"}, {"oid": "f8dce8b0b1396439ed7ed4e85a37b4b2d0feb93d", "url": "https://github.com/ConsenSys/teku/commit/f8dce8b0b1396439ed7ed4e85a37b4b2d0feb93d", "message": "Add test to confirm newly added blocks invalidated by a new finalization and pruned.", "committedDate": "2020-11-11T03:51:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQzMTAyNg==", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521431026", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * <p>The list may contain nodes which have been removed from the array either because they are\n          \n          \n            \n               * <p>The list may contain nodes which have been removed from the indices collection either because they are", "author": "mbaxter", "createdAt": "2020-11-11T15:19:15Z", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "diffHunk": "@@ -33,7 +33,24 @@\n   // When starting from genesis, this value is zero (genesis epoch)\n   private final UInt64 initialEpoch;\n \n+  /**\n+   * Lists all the known nodes. It is guaranteed that a node will be after its parent in the list.\n+   *\n+   * <p>The list may contain nodes which have been removed from the array either because they are", "originalCommit": "f8dce8b0b1396439ed7ed4e85a37b4b2d0feb93d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2eea073d0ce9957b50cf118d358008426d556d2f", "chunk": "diff --git a/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java b/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java\nindex 2f375cb28b..67465eef1f 100644\n--- a/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java\n+++ b/protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java\n\n@@ -36,7 +36,7 @@ public class ProtoArray {\n   /**\n    * Lists all the known nodes. It is guaranteed that a node will be after its parent in the list.\n    *\n-   * <p>The list may contain nodes which have been removed from the array either because they are\n+   * <p>The list may contain nodes which have been removed from the indices collection either because they are\n    * now before the finalized checkpoint but pruning has not yet occurred or because they extended\n    * from a now-invalid chain and were removed. This avoids having to update the indices to entries\n    * in the list too often.\n"}}, {"oid": "2eea073d0ce9957b50cf118d358008426d556d2f", "url": "https://github.com/ConsenSys/teku/commit/2eea073d0ce9957b50cf118d358008426d556d2f", "message": "Improve comment.\n\nCo-authored-by: mbaxter <meredith.baxter@consensys.net>", "committedDate": "2020-11-11T23:16:04Z", "type": "commit"}, {"oid": "35c6ec4a789cf4aee2e61376c7fccbb088c9d74f", "url": "https://github.com/ConsenSys/teku/commit/35c6ec4a789cf4aee2e61376c7fccbb088c9d74f", "message": "Merge branch 'master' into no-snapshot-proto-in-store", "committedDate": "2020-11-11T23:16:15Z", "type": "commit"}, {"oid": "ee587f0265046364a53c93df3c0d870cd6c5b738", "url": "https://github.com/ConsenSys/teku/commit/ee587f0265046364a53c93df3c0d870cd6c5b738", "message": "Spotless.", "committedDate": "2020-11-11T23:24:23Z", "type": "commit"}, {"oid": "8bbc133dfb4a6762e2fb5a4c62d0d69396cf9dfd", "url": "https://github.com/ConsenSys/teku/commit/8bbc133dfb4a6762e2fb5a4c62d0d69396cf9dfd", "message": "Merge branch 'master' into no-snapshot-proto-in-store", "committedDate": "2020-11-11T23:52:02Z", "type": "commit"}]}