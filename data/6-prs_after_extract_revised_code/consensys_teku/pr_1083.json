{"pr_number": 1083, "pr_title": "Implement Eth1DataManager", "pr_createdAt": "2020-01-09T19:11:25Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1083", "timeline": [{"oid": "3d92ae0bac0b304ab6a7d26f24d34b2234c34d57", "url": "https://github.com/ConsenSys/teku/commit/3d92ae0bac0b304ab6a7d26f24d34b2234c34d57", "message": "Implement Eth1DataManager", "committedDate": "2020-01-09T19:07:22Z", "type": "commit"}, {"oid": "75dd4100238881faf5246d1f9a85fad8593abdc6", "url": "https://github.com/ConsenSys/teku/commit/75dd4100238881faf5246d1f9a85fad8593abdc6", "message": "Add magic number to Constants", "committedDate": "2020-01-09T19:14:18Z", "type": "commit"}, {"oid": "4ceb20e540a6ef816a520d67ecbd0f95974beb46", "url": "https://github.com/ConsenSys/teku/commit/4ceb20e540a6ef816a520d67ecbd0f95974beb46", "message": "Remove printlns", "committedDate": "2020-01-09T19:17:29Z", "type": "commit"}, {"oid": "8180a116ea0c2aa0e9f406c58d2fbe121ef81952", "url": "https://github.com/ConsenSys/teku/commit/8180a116ea0c2aa0e9f406c58d2fbe121ef81952", "message": "Run spotless", "committedDate": "2020-01-09T20:19:04Z", "type": "commit"}, {"oid": "014ac57d9a3b1a89167a3d1db1ad45d016355ba5", "url": "https://github.com/ConsenSys/teku/commit/014ac57d9a3b1a89167a3d1db1ad45d016355ba5", "message": "Fix VC related bug", "committedDate": "2020-01-09T21:26:46Z", "type": "commit"}, {"oid": "cac772b278845ad6177eb1b2bd69368f9ecac9dd", "url": "https://github.com/ConsenSys/teku/commit/cac772b278845ad6177eb1b2bd69368f9ecac9dd", "message": "Add default vote", "committedDate": "2020-01-09T22:17:49Z", "type": "commit"}, {"oid": "be90c306678c60521b0c39ae641273762f98b70a", "url": "https://github.com/ConsenSys/teku/commit/be90c306678c60521b0c39ae641273762f98b70a", "message": "Add second comparison test", "committedDate": "2020-01-10T14:31:23Z", "type": "commit"}, {"oid": "f9079bc457c49a6e429a0e1d089284aa189d492b", "url": "https://github.com/ConsenSys/teku/commit/f9079bc457c49a6e429a0e1d089284aa189d492b", "message": "Run spotless", "committedDate": "2020-01-10T14:36:34Z", "type": "commit"}, {"oid": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "url": "https://github.com/ConsenSys/teku/commit/ebdec8d13dcc2173e4af68d7fb418b3509658a05", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-10T14:42:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365295538", "bodyText": "I think we could get this data more efficiently by just polling for blocks at a certain height at regular time intervals, rather than using the new block event as a signal to query for blocks.\nI'm thinking we could do something like:\n\nOn startup:\n\nQuery the chain for the current block height\nCalculate the block number where we want to start caching using current height and SECONDS_PER_ETH1_BLOCK and other relevant constants\nPull blocks by number until our cache covers the time range we want\n\n\nPeriodically (every SECONDS_PER_ETH1_BLOCK?) query for new blocks to add to the cache", "author": "mbaxter", "createdAt": "2020-01-10T15:41:57Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQwMjI0NQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365402245", "bodyText": "I agree that we probably should have a more aggressive approach on startup, to make sure we fill the eth1 blocks cache since we might be proposing a block soon (although voting without having seen too many eth1Blocks is not a significant issue for the validator): https://pegasys1.atlassian.net/browse/BC-21.  But for periodic updates, I think subscribing to each block is more straightforward.", "author": "cemozerr", "createdAt": "2020-01-10T19:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzMDY3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365430673", "bodyText": "We can execute periodic logic to pull blocks in onSlot for example, which is pretty straightforward.  It's just that we're subscribing to new blocks and putting load on the eth1 node without really needing to.  We really just need a block number to get us started, and then we can pull blocks sequentially.", "author": "mbaxter", "createdAt": "2020-01-10T21:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzMDkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365430927", "bodyText": "Also - is BC-21 the link you meant to post?", "author": "mbaxter", "createdAt": "2020-01-10T21:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTI5NTUzOA=="}], "type": "inlineReview", "revised_code": {"commit": "b9600daa6b65178cfc63465da530941790a8d144", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\nindex 50e00b126..f4bb9a015 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n\n@@ -39,7 +39,7 @@ public class BlockListener {\n                       block\n                           .getBlock()\n                           .getNumber()\n-                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));\n                   EthBlock.Block eth1Block =\n                       web3j\n                           .ethGetBlockByNumber(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMjc5NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365332794", "bodyText": "We should be careful about blocking with join - can we just wait on these futures and then post the event when they resolve?", "author": "mbaxter", "createdAt": "2020-01-10T16:57:15Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(\n+                block -> {\n+                  BigInteger cacheBlockNumber =\n+                      block\n+                          .getBlock()\n+                          .getNumber()\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                  EthBlock.Block eth1Block =\n+                      web3j\n+                          .ethGetBlockByNumber(\n+                              DefaultBlockParameter.valueOf(cacheBlockNumber), false)\n+                          .send()\n+                          .getBlock();\n+\n+                  Bytes32 eth1BlockHash = Bytes32.fromHexString(eth1Block.getHash());\n+                  UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(eth1Block.getTimestamp());\n+                  UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(eth1Block.getNumber());\n+                  UnsignedLong count =\n+                      depositContractListener.getDepositCount(cacheBlockNumber).join();\n+                  Bytes32 root = depositContractListener.getDepositRoot(cacheBlockNumber).join();", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQxODU4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365418589", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMjc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "b9600daa6b65178cfc63465da530941790a8d144", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\nindex 50e00b126..f4bb9a015 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n\n@@ -39,7 +39,7 @@ public class BlockListener {\n                       block\n                           .getBlock()\n                           .getNumber()\n-                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));\n                   EthBlock.Block eth1Block =\n                       web3j\n                           .ethGetBlockByNumber(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMzA2Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365333067", "bodyText": "Suggest using sendAsync here to get a future back", "author": "mbaxter", "createdAt": "2020-01-10T16:57:50Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(\n+                block -> {\n+                  BigInteger cacheBlockNumber =\n+                      block\n+                          .getBlock()\n+                          .getNumber()\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                  EthBlock.Block eth1Block =\n+                      web3j\n+                          .ethGetBlockByNumber(\n+                              DefaultBlockParameter.valueOf(cacheBlockNumber), false)\n+                          .send()", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQxODU2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365418561", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzMzA2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b9600daa6b65178cfc63465da530941790a8d144", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\nindex 50e00b126..f4bb9a015 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n\n@@ -39,7 +39,7 @@ public class BlockListener {\n                       block\n                           .getBlock()\n                           .getNumber()\n-                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));\n                   EthBlock.Block eth1Block =\n                       web3j\n                           .ethGetBlockByNumber(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzI5OQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365337299", "bodyText": "Might be a good idea to have a specific exception for this - maybe Eth1RequestFailed", "author": "mbaxter", "createdAt": "2020-01-10T17:07:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java", "diffHunk": "@@ -51,11 +64,56 @@ public DepositContractListener(EventBus eventBus, DepositContract contract) {\n                 });\n   }\n \n+  @SuppressWarnings(\"rawtypes\")\n+  public SafeFuture<Bytes32> getDepositRoot(BigInteger blockHeight) {\n+    String encodedFunction = contract.get_deposit_root().encodeFunctionCall();\n+    return callFunctionAtBlockHeight(encodedFunction, blockHeight)\n+        .thenApply(\n+            ethCall -> {\n+              if (ethCall.hasError()) {\n+                throw new UnsupportedOperationException(", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQ0Mjk4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365442986", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T21:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzI5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7cfe1e793cbdcfbdaa8503797a63a976a5f888c0", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java\nindex 23eb06010..4aa64fe08 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java\n\n@@ -71,7 +73,7 @@ public class DepositContractListener {\n         .thenApply(\n             ethCall -> {\n               if (ethCall.hasError()) {\n-                throw new UnsupportedOperationException(\n+                throw new DepositRootRequestException(\n                     \"Eth1 call get_deposit_root() has failed:\" + ethCall.getError().getMessage());\n               }\n               String value = ethCall.getValue();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzg5MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365337890", "bodyText": "How about just Eth1BlockEvent?", "author": "mbaxter", "createdAt": "2020-01-10T17:08:37Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/event/CacheEth1BlockEvent.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.event;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class CacheEth1BlockEvent {\n+\n+  private final UnsignedLong blockNumber;\n+  private final Bytes32 blockHash;\n+  private final UnsignedLong blockTimestamp;\n+  private final Bytes32 depositRoot;\n+  private final UnsignedLong depositCount;\n+\n+  public CacheEth1BlockEvent(", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyMDgzOQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365420839", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTMzNzg5MA=="}], "type": "inlineReview", "revised_code": {"commit": "fc97a541a150e798fed650af1c2826e0d90dc9a0", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/event/CacheEth1BlockEvent.java b/pow/src/main/java/tech/pegasys/artemis/pow/event/Eth1BlockEvent.java\nsimilarity index 96%\nrename from pow/src/main/java/tech/pegasys/artemis/pow/event/CacheEth1BlockEvent.java\nrename to pow/src/main/java/tech/pegasys/artemis/pow/event/Eth1BlockEvent.java\nindex 40850ef0f..aa93dcbc2 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/event/CacheEth1BlockEvent.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/event/Eth1BlockEvent.java\n\n@@ -17,7 +17,7 @@ import com.google.common.base.MoreObjects;\n import com.google.common.primitives.UnsignedLong;\n import org.apache.tuweni.bytes.Bytes32;\n \n-public class CacheEth1BlockEvent {\n+public class Eth1BlockEvent {\n \n   private final UnsignedLong blockNumber;\n   private final Bytes32 blockHash;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MDI3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365340273", "bodyText": "I don't think we want to weaken the safe follow distance (ETH1_FOLLOW_DISTANCE) too much.  What about changing this parameter to something like ETH1_CACHE_BUFFER - so that we'll start caching blocks some small distance ahead of ETH1_FOLLOW_DISTANCE.", "author": "mbaxter", "createdAt": "2020-01-10T17:14:02Z", "path": "util/src/main/java/tech/pegasys/artemis/util/config/Constants.java", "diffHunk": "@@ -100,6 +101,7 @@\n   public static double TIME_TICKER_REFRESH_RATE = 2; // per sec\n   public static UnsignedLong GENESIS_START_DELAY = UnsignedLong.valueOf(5);\n   public static int COMMITTEE_INDEX_SUBSCRIPTION_LENGTH = 2; // in epochs\n+  public static int ETH1_CACHE_FOLLOW_DISTANCE = 100; // in blocks", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM3MjA3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365372074", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T18:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM0MDI3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "b9600daa6b65178cfc63465da530941790a8d144", "chunk": "diff --git a/util/src/main/java/tech/pegasys/artemis/util/config/Constants.java b/util/src/main/java/tech/pegasys/artemis/util/config/Constants.java\nindex fd4a4d345..6923a4ce4 100644\n--- a/util/src/main/java/tech/pegasys/artemis/util/config/Constants.java\n+++ b/util/src/main/java/tech/pegasys/artemis/util/config/Constants.java\n\n@@ -93,16 +93,6 @@ public class Constants {\n   public static UnsignedLong TARGET_AGGREGATORS_PER_COMMITTEE = UnsignedLong.valueOf(16);\n   public static UnsignedLong SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(14L);\n \n-  // Artemis specific\n-  public static String SIM_DEPOSIT_VALUE = \"1000000000000000000\";\n-  public static int DEPOSIT_DATA_SIZE = 512; //\n-  public static int VALIDATOR_CLIENT_PORT_BASE = 50000;\n-  public static Bytes32 ZERO_HASH = Bytes32.ZERO;\n-  public static double TIME_TICKER_REFRESH_RATE = 2; // per sec\n-  public static UnsignedLong GENESIS_START_DELAY = UnsignedLong.valueOf(5);\n-  public static int COMMITTEE_INDEX_SUBSCRIPTION_LENGTH = 2; // in epochs\n-  public static int ETH1_CACHE_FOLLOW_DISTANCE = 100; // in blocks\n-\n   // Deposit\n   public static String DEPOSIT_NORMAL = \"normal\";\n   public static String DEPOSIT_TEST = \"test\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NDI4OQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365354289", "bodyText": "I know this is written to match the spec, but I think we should try to implement this more efficiently.  There are a few O(n^2) loops here.  Suggest doing something like:\n    NavigableSet<Eth1Data> votesToConsider = getVotesToConsider();\n    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n    int index = 0;\n    for (Eth1Data eth1Vote : state.getEth1_data_votes()) {\n      if (!votesToConsider.contains(eth1Vote)) {\n        continue;\n      }\n      Eth1Vote vote = votes.computeIfAbsent(key -> new Eth1Vote(eth1Vote));\n      vote.incrementVotes();\n      vote.setIndex(index);\n      index++;\n    }\n\n    return validVotes.values()\n      .stream()\n      .max(Eth1Vote::compare)\n      .orElse(votesToConsider.last());", "author": "mbaxter", "createdAt": "2020-01-10T17:49:26Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(CacheEth1BlockEvent cacheEth1BlockEvent) {\n+    return new Eth1Data(\n+        cacheEth1BlockEvent.getDepositRoot(),\n+        cacheEth1BlockEvent.getDepositCount(),\n+        cacheEth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(CacheEth1BlockEvent cacheEth1BlockEvent) {\n+    eth1ChainCache.put(cacheEth1BlockEvent.getBlockTimestamp(), getEth1Data(cacheEth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    List<Eth1Data> validVotes = new ArrayList<>(state.getEth1_data_votes());\n+    validVotes.removeIf(v -> !votesToConsider.containsValue(v));", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5NTE2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365395161", "bodyText": "Done. It made the code less readable but I agree that efficiency might be important here, especially since this has to be done during block production.", "author": "cemozerr", "createdAt": "2020-01-10T19:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1NDI4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "f85c569e4483cf417e310c9e7308eb073c4b0203", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nindex 42aca3b1a..563a01541 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n\n@@ -19,7 +19,9 @@ import com.google.common.primitives.UnsignedLong;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n+import java.util.HashMap;\n import java.util.List;\n+import java.util.Map;\n import java.util.NavigableMap;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentSkipListMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODA1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365358056", "bodyText": "If we're creating a block, the store must be initialized right?  Do we need this check?  Or should we just return early and log a warning if eth1DataManager is null?", "author": "mbaxter", "createdAt": "2020-01-10T17:59:11Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/ValidatorCoordinator.java", "diffHunk": "@@ -331,9 +319,25 @@ private void createBlockIfNecessary(\n \n       final Signer signer = getSigner(proposer);\n       final Bytes32 parentRoot = previousBlock.signing_root(\"signature\");\n+\n+      Eth1Data eth1Data;\n+      if (eth1DataManager == null) {", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzNzY0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365437643", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-10T21:29:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c75d07a2baf60ff1474cf9ef7dd69f53c4894f94", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/ValidatorCoordinator.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/ValidatorCoordinator.java\nindex 48fa12620..ff7a59e96 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/ValidatorCoordinator.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/ValidatorCoordinator.java\n\n@@ -320,13 +320,7 @@ public class ValidatorCoordinator {\n       final Signer signer = getSigner(proposer);\n       final Bytes32 parentRoot = previousBlock.signing_root(\"signature\");\n \n-      Eth1Data eth1Data;\n-      if (eth1DataManager == null) {\n-        final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n-        eth1Data = StartupUtil.get_eth1_data_stub(previousState, newEpoch);\n-      } else {\n-        eth1Data = eth1DataManager.get_eth1_vote(newState);\n-      }\n+      Eth1Data eth1Data = eth1DataManager.get_eth1_vote(newState);\n \n       newBlock =\n           blockCreator.createNewBlock(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODcxMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365358713", "bodyText": "Might be a good idea to set distinct values for the various constants to guard against bugs where we use the wrong constant.", "author": "mbaxter", "createdAt": "2020-01-10T18:01:00Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = new EventBus();\n+  private final UnsignedLong genesisTime = UnsignedLong.ZERO;\n+\n+  static {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(10);\n+    Constants.ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(100);\n+    Constants.SLOTS_PER_ETH1_VOTING_PERIOD = 10;\n+    Constants.SECONDS_PER_SLOT = 10;", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyNzY4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365427685", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1ODcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "fc97a541a150e798fed650af1c2826e0d90dc9a0", "chunk": "diff --git a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\nindex be6d100b4..53f69df70 100644\n--- a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n+++ b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n\n@@ -25,7 +25,7 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n-import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n import tech.pegasys.artemis.storage.events.SlotEvent;\n import tech.pegasys.artemis.util.SSZTypes.SSZList;\n import tech.pegasys.artemis.util.config.Constants;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1OTgzMg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365359832", "bodyText": "I thought the later index should win - so we take the most recent vote in case of a tie.", "author": "mbaxter", "createdAt": "2020-01-10T18:03:51Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = new EventBus();\n+  private final UnsignedLong genesisTime = UnsignedLong.ZERO;\n+\n+  static {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(10);\n+    Constants.ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(100);\n+    Constants.SLOTS_PER_ETH1_VOTING_PERIOD = 10;\n+    Constants.SECONDS_PER_SLOT = 10;\n+  }\n+\n+  // RANGE_CONSTANT = 1000\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private Eth1DataManager eth1DataManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getGenesis_time()).thenReturn(genesisTime);\n+    eth1DataManager = new Eth1DataManager(beaconState, eventBus);\n+  }\n+\n+  @Test\n+  void majorityVoteWins() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data2);\n+  }\n+\n+  @Test\n+  void smallestDistanceWinsIfNoMajority() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data1);", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQzOTE4OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365439188", "bodyText": "yeah, the spec says -valid_votes.index(v), the \"-\" is the key there :D", "author": "cemozerr", "createdAt": "2020-01-10T21:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM1OTgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "fc97a541a150e798fed650af1c2826e0d90dc9a0", "chunk": "diff --git a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\nindex be6d100b4..53f69df70 100644\n--- a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n+++ b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n\n@@ -25,7 +25,7 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n-import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n import tech.pegasys.artemis.storage.events.SlotEvent;\n import tech.pegasys.artemis.util.SSZTypes.SSZList;\n import tech.pegasys.artemis.util.config.Constants;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjMwMg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365362302", "bodyText": "Suggest checking the lower bound here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        currentTime.minus(RANGE_CONSTANT),\n          \n          \n            \n                        currentTime.minus(RANGE_CONSTANT.times(UnsignedLong.valueOf(2))),", "author": "mbaxter", "createdAt": "2020-01-10T18:10:02Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = new EventBus();\n+  private final UnsignedLong genesisTime = UnsignedLong.ZERO;\n+\n+  static {\n+    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(10);\n+    Constants.ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(100);\n+    Constants.SLOTS_PER_ETH1_VOTING_PERIOD = 10;\n+    Constants.SECONDS_PER_SLOT = 10;\n+  }\n+\n+  // RANGE_CONSTANT = 1000\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private Eth1DataManager eth1DataManager;\n+\n+  @BeforeEach\n+  void setUp() {\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getGenesis_time()).thenReturn(genesisTime);\n+    eth1DataManager = new Eth1DataManager(beaconState, eventBus);\n+  }\n+\n+  @Test\n+  void majorityVoteWins() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data2);\n+  }\n+\n+  @Test\n+  void smallestDistanceWinsIfNoMajority() {\n+    UnsignedLong slot = UnsignedLong.valueOf(200);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),\n+            Bytes32.fromHexString(\"0x2222\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data1 = Eth1DataManager.getEth1Data(eth1BlockEvent1);\n+\n+    CacheEth1BlockEvent eth1BlockEvent2 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x3333\"),\n+            currentTime.minus(RANGE_CONSTANT).minus(UnsignedLong.ONE),\n+            Bytes32.fromHexString(\"0x4444\"),\n+            UnsignedLong.valueOf(10L));\n+    Eth1Data eth1Data2 = Eth1DataManager.getEth1Data(eth1BlockEvent2);\n+\n+    SSZList<Eth1Data> eth1DataVotes =\n+        new SSZList<>(List.of(eth1Data1, eth1Data2), 10, Eth1Data.class);\n+    BeaconState beaconState = mock(BeaconState.class);\n+    when(beaconState.getEth1_data_votes()).thenReturn(eth1DataVotes);\n+\n+    eventBus.post(eth1BlockEvent1);\n+    eventBus.post(eth1BlockEvent2);\n+\n+    assertThat(eth1DataManager.get_eth1_vote(beaconState)).isEqualTo(eth1Data1);\n+  }\n+\n+  @Test\n+  void oldVoteDoesNotCount() {\n+    UnsignedLong slot = UnsignedLong.valueOf(300);\n+    UnsignedLong currentTime = slot.times(UnsignedLong.valueOf(Constants.SECONDS_PER_SLOT));\n+    eventBus.post(new SlotEvent(slot));\n+\n+    CacheEth1BlockEvent eth1BlockEvent1 =\n+        new CacheEth1BlockEvent(\n+            UnsignedLong.ZERO,\n+            Bytes32.fromHexString(\"0x1111\"),\n+            currentTime.minus(RANGE_CONSTANT),", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTQyNTY1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365425656", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T20:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "fc97a541a150e798fed650af1c2826e0d90dc9a0", "chunk": "diff --git a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\nindex be6d100b4..53f69df70 100644\n--- a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n+++ b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n\n@@ -25,7 +25,7 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n-import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n import tech.pegasys.artemis.storage.events.SlotEvent;\n import tech.pegasys.artemis.util.SSZTypes.SSZList;\n import tech.pegasys.artemis.util.config.Constants;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjcxNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365362715", "bodyText": "Organizationally, feels like these utilities should live in the tech.pegasys.artemis.services.powchain package.", "author": "mbaxter", "createdAt": "2020-01-10T18:11:14Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5ODY1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365398656", "bodyText": "I agree, but that's a fairly big change that I don't want to incorporate into this PR.", "author": "cemozerr", "createdAt": "2020-01-10T19:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2MjcxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b9600daa6b65178cfc63465da530941790a8d144", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\nindex 50e00b126..f4bb9a015 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n\n@@ -39,7 +39,7 @@ public class BlockListener {\n                       block\n                           .getBlock()\n                           .getNumber()\n-                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_FOLLOW_DISTANCE));\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));\n                   EthBlock.Block eth1Block =\n                       web3j\n                           .ethGetBlockByNumber(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2Mjk0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365362946", "bodyText": "Should we cut this altogether and require callers to supply eth1data?", "author": "mbaxter", "createdAt": "2020-01-10T18:11:54Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java", "diffHunk": "@@ -59,15 +60,38 @@ public BeaconBlock createNewBlock(\n       final SSZList<Deposit> deposits)\n       throws StateTransitionException {\n     final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n+    return createNewBlock(\n+        signer,\n+        newSlot,\n+        previousState,\n+        parentBlockSigningRoot,\n+        StartupUtil.get_eth1_data_stub(previousState, newEpoch),", "originalCommit": "ebdec8d13dcc2173e4af68d7fb418b3509658a05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5NzEzMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365397133", "bodyText": "Fair point.", "author": "cemozerr", "createdAt": "2020-01-10T19:34:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2Mjk0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM5NzgxNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365397814", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-10T19:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTM2Mjk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "92d6cc5052a9f8103695fb4b8c8b04c3c31e9826", "chunk": "diff --git a/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java b/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java\nindex 22584c259..78a827778 100644\n--- a/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java\n+++ b/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java\n\n@@ -50,27 +50,6 @@ public class BlockProposalUtil {\n     this.stateTransition = stateTransition;\n   }\n \n-  public BeaconBlock createNewBlock(\n-      final Signer signer,\n-      final UnsignedLong newSlot,\n-      final BeaconState previousState,\n-      final Bytes32 parentBlockSigningRoot,\n-      final SSZList<Attestation> attestations,\n-      final SSZList<ProposerSlashing> slashings,\n-      final SSZList<Deposit> deposits)\n-      throws StateTransitionException {\n-    final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n-    return createNewBlock(\n-        signer,\n-        newSlot,\n-        previousState,\n-        parentBlockSigningRoot,\n-        StartupUtil.get_eth1_data_stub(previousState, newEpoch),\n-        attestations,\n-        slashings,\n-        deposits);\n-  }\n-\n   public BeaconBlock createNewBlock(\n       final Signer signer,\n       final UnsignedLong newSlot,\n"}}, {"oid": "b9600daa6b65178cfc63465da530941790a8d144", "url": "https://github.com/ConsenSys/teku/commit/b9600daa6b65178cfc63465da530941790a8d144", "message": "Change constant name", "committedDate": "2020-01-10T19:32:23Z", "type": "commit"}, {"oid": "f85c569e4483cf417e310c9e7308eb073c4b0203", "url": "https://github.com/ConsenSys/teku/commit/f85c569e4483cf417e310c9e7308eb073c4b0203", "message": "Optimize get_eth1_vote", "committedDate": "2020-01-10T19:32:37Z", "type": "commit"}, {"oid": "92d6cc5052a9f8103695fb4b8c8b04c3c31e9826", "url": "https://github.com/ConsenSys/teku/commit/92d6cc5052a9f8103695fb4b8c8b04c3c31e9826", "message": "Refactor async code", "committedDate": "2020-01-10T20:32:15Z", "type": "commit"}, {"oid": "fc97a541a150e798fed650af1c2826e0d90dc9a0", "url": "https://github.com/ConsenSys/teku/commit/fc97a541a150e798fed650af1c2826e0d90dc9a0", "message": "Change event name", "committedDate": "2020-01-10T20:34:58Z", "type": "commit"}, {"oid": "359233c5db63b1697e29f7111171303b442d9b51", "url": "https://github.com/ConsenSys/teku/commit/359233c5db63b1697e29f7111171303b442d9b51", "message": "Use .finish() instead of .thenRun()", "committedDate": "2020-01-10T20:48:02Z", "type": "commit"}, {"oid": "79d56a4a40c2570fddd05d5514e445119017ac5b", "url": "https://github.com/ConsenSys/teku/commit/79d56a4a40c2570fddd05d5514e445119017ac5b", "message": "Check the lower bound", "committedDate": "2020-01-10T20:53:11Z", "type": "commit"}, {"oid": "d8afe461d7ed092545065e8a27bbe5647d69ad94", "url": "https://github.com/ConsenSys/teku/commit/d8afe461d7ed092545065e8a27bbe5647d69ad94", "message": "Use distinct values for constants", "committedDate": "2020-01-10T20:57:08Z", "type": "commit"}, {"oid": "c75d07a2baf60ff1474cf9ef7dd69f53c4894f94", "url": "https://github.com/ConsenSys/teku/commit/c75d07a2baf60ff1474cf9ef7dd69f53c4894f94", "message": "Remove unnecessary null check", "committedDate": "2020-01-10T21:32:39Z", "type": "commit"}, {"oid": "7cfe1e793cbdcfbdaa8503797a63a976a5f888c0", "url": "https://github.com/ConsenSys/teku/commit/7cfe1e793cbdcfbdaa8503797a63a976a5f888c0", "message": "Add custom exceptions for rpc request failures", "committedDate": "2020-01-10T21:46:45Z", "type": "commit"}, {"oid": "fbb38d8e868b1658c27c0c6b9c2c6a430885c31d", "url": "https://github.com/ConsenSys/teku/commit/fbb38d8e868b1658c27c0c6b9c2c6a430885c31d", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-10T21:47:09Z", "type": "commit"}, {"oid": "d509aa772a8d394b9e4d9235371b73c6f7322215", "url": "https://github.com/ConsenSys/teku/commit/d509aa772a8d394b9e4d9235371b73c6f7322215", "message": "Fix bug", "committedDate": "2020-01-10T22:18:16Z", "type": "commit"}, {"oid": "964dae9a9c4e54b8116ee61948e71f604f062de1", "url": "https://github.com/ConsenSys/teku/commit/964dae9a9c4e54b8116ee61948e71f604f062de1", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-13T15:22:33Z", "type": "commit"}, {"oid": "247e77560c6ab125af4dc187639964faaecfa19f", "url": "https://github.com/ConsenSys/teku/commit/247e77560c6ab125af4dc187639964faaecfa19f", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-15T01:22:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMDE0MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366930141", "bodyText": "What if we just reuse the previous eth1data instead of making something up?:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StartupUtil.get_eth1_data_stub(previousState, newEpoch),\n          \n          \n            \n                    previousState.getEth1_data(),", "author": "mbaxter", "createdAt": "2020-01-15T15:13:40Z", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java", "diffHunk": "@@ -92,11 +95,13 @@ public BeaconBlock createEmptyBlock(\n       final BeaconState previousState,\n       final Bytes32 parentBlockSigningRoot)\n       throws StateTransitionException {\n+    final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n     return createNewBlock(\n         signer,\n         newSlot,\n         previousState,\n         parentBlockSigningRoot,\n+        StartupUtil.get_eth1_data_stub(previousState, newEpoch),", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MDEyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366980124", "bodyText": "The get_eth1_data_stub method was built for interop, to easily mock an eth1 data stub, we could totally get eth1 data from the previous state. However, I don't think it would add any value to change it, and it might introduce problems if we were to try interop testing again.", "author": "cemozerr", "createdAt": "2020-01-15T16:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMDE0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ea33291aa022b61cd418d4c3ebd8c29c12a44420", "chunk": "diff --git a/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java b/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java\nindex 78a827778..fcae8a3a4 100644\n--- a/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java\n+++ b/ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/BlockProposalUtil.java\n\n@@ -73,41 +74,41 @@ public class BlockProposalUtil {\n \n     // Create initial block with some stubs\n     final Bytes32 tmpStateRoot = Bytes32.ZERO;\n-    final BLSSignature tmpSignature = BLSSignature.empty();\n     final BeaconBlock newBlock =\n-        new BeaconBlock(\n-            newSlot, parentBlockSigningRoot, tmpStateRoot, beaconBlockBody, tmpSignature);\n+        new BeaconBlock(newSlot, parentBlockSigningRoot, tmpStateRoot, beaconBlockBody);\n \n     // Run state transition and set state root\n-    Bytes32 stateRoot = stateTransition.initiate(newState, newBlock, false).hash_tree_root();\n+    Bytes32 stateRoot =\n+        stateTransition\n+            .initiate(newState, new SignedBeaconBlock(newBlock, BLSSignature.empty()), false)\n+            .hash_tree_root();\n     newBlock.setState_root(stateRoot);\n \n     // Sign block and set block signature\n     BLSSignature blockSignature = getBlockSignature(newState, newBlock, signer);\n-    newBlock.setSignature(blockSignature);\n \n-    return newBlock;\n+    return new SignedBeaconBlock(newBlock, blockSignature);\n   }\n \n-  public BeaconBlock createEmptyBlock(\n+  public SignedBeaconBlock createEmptyBlock(\n       final Signer signer,\n       final UnsignedLong newSlot,\n       final BeaconState previousState,\n-      final Bytes32 parentBlockSigningRoot)\n+      final Bytes32 parentBlockRoot)\n       throws StateTransitionException {\n     final UnsignedLong newEpoch = compute_epoch_at_slot(newSlot);\n     return createNewBlock(\n         signer,\n         newSlot,\n         previousState,\n-        parentBlockSigningRoot,\n+        parentBlockRoot,\n         StartupUtil.get_eth1_data_stub(previousState, newEpoch),\n         BeaconBlockBodyLists.createAttestations(),\n         BeaconBlockBodyLists.createProposerSlashings(),\n         BeaconBlockBodyLists.createDeposits());\n   }\n \n-  public BeaconBlock createBlockWithAttestations(\n+  public SignedBeaconBlock createBlockWithAttestations(\n       final Signer signer,\n       final UnsignedLong newSlot,\n       final BeaconState previousState,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMjkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366932927", "bodyText": "I think we want to subtract the follow distance and then add the eth1_cache_buffer:  cacheBlockNumber = Math.min(latestBlockNumber, latestBlockNumber - ETH1_FOLLOW_DISTANCE + ETH1_CACHE_BUFFER)\nEdit:  I was thinking that ETH1_CACHE_BUFFER was the difference from ETH1_FOLLOW_DISTANCE, but I see it's already being calculated relative to the follow distance.  Suggest either renaming to ETH1_CACHE_FOLLOW_DISTANCE or keeping the current name and setting it to just the difference from the ETH1_FOLLOW_DISTANCE (10).", "author": "mbaxter", "createdAt": "2020-01-15T15:18:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.newBlockSubscription =\n+        web3j\n+            .blockFlowable(false)\n+            .subscribe(\n+                block -> {\n+                  BigInteger cacheBlockNumber =\n+                      block\n+                          .getBlock()\n+                          .getNumber()\n+                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzODk5Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366938992", "bodyText": "It also seems that cacheBlockNumber is basically an estimate since we're now collecting eth1data based on block timestamps.  So I think we actually want to define the leading edge of the buffer based on timestamp with something like: cacheStartTimestamp = now - ETH1_CACHE_BUFFER * SECONDS_PER_ETH1_BLOCK.", "author": "mbaxter", "createdAt": "2020-01-15T15:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjkzMjkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\ndeleted file mode 100644\nindex ab61c66f2..000000000\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-/*\n- * Copyright 2020 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.pow;\n-\n-import com.google.common.eventbus.EventBus;\n-import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n-import java.math.BigInteger;\n-import org.apache.tuweni.bytes.Bytes32;\n-import org.web3j.protocol.Web3j;\n-import org.web3j.protocol.core.DefaultBlockParameter;\n-import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n-import tech.pegasys.artemis.util.async.SafeFuture;\n-import tech.pegasys.artemis.util.config.Constants;\n-\n-public class BlockListener {\n-\n-  private final Disposable newBlockSubscription;\n-\n-  public BlockListener(\n-      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n-    this.newBlockSubscription =\n-        web3j\n-            .blockFlowable(false)\n-            .subscribe(\n-                block -> {\n-                  BigInteger cacheBlockNumber =\n-                      block\n-                          .getBlock()\n-                          .getNumber()\n-                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));\n-\n-                  SafeFuture<EthBlock> blockFuture =\n-                      SafeFuture.of(\n-                          web3j\n-                              .ethGetBlockByNumber(\n-                                  DefaultBlockParameter.valueOf(cacheBlockNumber), false)\n-                              .sendAsync());\n-\n-                  SafeFuture<UnsignedLong> countFuture =\n-                      SafeFuture.of(depositContractListener.getDepositCount(cacheBlockNumber));\n-                  SafeFuture<Bytes32> rootFuture =\n-                      SafeFuture.of(depositContractListener.getDepositRoot(cacheBlockNumber));\n-\n-                  SafeFuture.allOf(blockFuture, countFuture, rootFuture)\n-                      .finish(\n-                          () -> {\n-                            EthBlock.Block eth1Block = blockFuture.join().getBlock();\n-                            Bytes32 eth1BlockHash = Bytes32.fromHexString(eth1Block.getHash());\n-                            UnsignedLong eth1BlockTimestamp =\n-                                UnsignedLong.valueOf(eth1Block.getTimestamp());\n-                            UnsignedLong eth1BlockNumber =\n-                                UnsignedLong.valueOf(eth1Block.getNumber());\n-                            eventBus.post(\n-                                new Eth1BlockEvent(\n-                                    eth1BlockNumber,\n-                                    eth1BlockHash,\n-                                    eth1BlockTimestamp,\n-                                    rootFuture.join(),\n-                                    countFuture.join()));\n-                          });\n-                });\n-  }\n-\n-  public void stop() {\n-    newBlockSubscription.dispose();\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0NzY3MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366947670", "bodyText": "If we've got the root cause, we should keep it rather than converting it to a string:\n  public Eth1RequestException(Throwable cause) {\n    super(cause);\n  }\n\nThis will give us more context when the exception gets logged.", "author": "mbaxter", "createdAt": "2020-01-15T15:42:01Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.exception;\n+\n+public class Eth1RequestException extends RuntimeException {\n+  public Eth1RequestException(String err) {\n+    super(err);\n+  }\n+\n+  public Eth1RequestException(RuntimeException e) {\n+    super(e.toString());\n+  }", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MDMzNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368170334", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T22:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0NzY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "74bc03ac5f7e9a8350f58653b7eadd264e5dd730", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java b/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java\nindex 53d7e495e..0c6e6d894 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java\n\n@@ -19,6 +19,6 @@ public class Eth1RequestException extends RuntimeException {\n   }\n \n   public Eth1RequestException(RuntimeException e) {\n-    super(e.toString());\n+    super(e);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0Nzk3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366947972", "bodyText": "nice :D", "author": "mbaxter", "createdAt": "2020-01-15T15:42:29Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/exception/DepositCountRequestException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.exception;\n+\n+public class DepositCountRequestException extends Eth1RequestException {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk4MDg2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366980861", "bodyText": "haha thank you!!", "author": "cemozerr", "createdAt": "2020-01-15T16:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0Nzk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/exception/DepositCountRequestException.java b/pow/src/main/java/tech/pegasys/artemis/pow/exception/DepositCountRequestException.java\ndeleted file mode 100644\nindex 35e690292..000000000\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/exception/DepositCountRequestException.java\n+++ /dev/null\n\n@@ -1,24 +0,0 @@\n-/*\n- * Copyright 2020 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.pow.exception;\n-\n-public class DepositCountRequestException extends Eth1RequestException {\n-  public DepositCountRequestException(String err) {\n-    super(err);\n-  }\n-\n-  public DepositCountRequestException(RuntimeException e) {\n-    super(e);\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0OTk3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366949974", "bodyText": "(optional) Naming nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n          \n          \n            \n              static Eth1Data createEth1Data(Eth1BlockEvent eth1BlockEvent) {", "author": "mbaxter", "createdAt": "2020-01-15T15:45:45Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MDY4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368170682", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T22:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk0OTk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MTI1NQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366951255", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n          \n          \n            \n              private final NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();", "author": "mbaxter", "createdAt": "2020-01-15T15:47:46Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MDkxMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368170910", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T23:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MTI1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzAyOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366953028", "bodyText": "You can just keep using else if's rather than adding the extra nesting in this else block.", "author": "mbaxter", "createdAt": "2020-01-15T15:50:41Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();\n+                newVote.setIndex(finalI);\n+                return newVote;\n+              });\n+      vote.incrementVotes();\n+      i++;\n+    }\n+\n+    Eth1Data defaultVote =\n+        !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();\n+\n+    Optional<Eth1Data> vote =\n+        validVotes.entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey);\n+\n+    return vote.orElse(defaultVote);\n+  }\n+\n+  public static class Eth1Vote implements Comparable<Eth1Vote> {\n+\n+    private int vote = 0;\n+    private int index = -1;\n+\n+    public void incrementVotes() {\n+      vote++;\n+    }\n+\n+    public void setIndex(int i) {\n+      index = i;\n+    }\n+\n+    @Override\n+    public int compareTo(Eth1Vote eth1Vote) {\n+      if (this.vote > eth1Vote.vote) {\n+        return 1;\n+      } else if (this.vote < eth1Vote.vote) {\n+        return -1;\n+      } else {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MTU3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368171577", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T23:03:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzAyOA=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzM5NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366953394", "bodyText": "Internal classes usually go at the bottom of the class.", "author": "mbaxter", "createdAt": "2020-01-15T15:51:15Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();\n+                newVote.setIndex(finalI);\n+                return newVote;\n+              });\n+      vote.incrementVotes();\n+      i++;\n+    }\n+\n+    Eth1Data defaultVote =\n+        !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();\n+\n+    Optional<Eth1Data> vote =\n+        validVotes.entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey);\n+\n+    return vote.orElse(defaultVote);\n+  }\n+\n+  public static class Eth1Vote implements Comparable<Eth1Vote> {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MTY3Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368171673", "bodyText": "it now has its own class.", "author": "cemozerr", "createdAt": "2020-01-17T23:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1MzM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NTE1Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366955152", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  int finalI = i;\n          \n          \n            \n                  final int currentIndex = i;", "author": "mbaxter", "createdAt": "2020-01-15T15:54:07Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE3MTg4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368171886", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-17T23:04:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NTE1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NjAyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366956024", "bodyText": "(nit) You could pass the index into the constructor and make the index variable final.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Eth1Vote newVote = new Eth1Vote();\n          \n          \n            \n                            Eth1Vote newVote = new Eth1Vote(currentIndex);", "author": "mbaxter", "createdAt": "2020-01-15T15:55:31Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDQxMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369690410", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-22T17:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NjAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NzQ1MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366957450", "bodyText": "(nit) - could slightly simplify this with:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();\n          \n          \n            \n                    votesToConsider.isEmpty() ? state.getEth1_data() : votesToConsider.lastEntry().getValue();", "author": "mbaxter", "createdAt": "2020-01-15T15:57:48Z", "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManager {\n+\n+  private final EventBus eventBus;\n+  private final UnsignedLong genesisTime;\n+\n+  private NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n+  private final UnsignedLong RANGE_CONSTANT =\n+      Constants.SECONDS_PER_ETH1_BLOCK.times(Constants.ETH1_FOLLOW_DISTANCE);\n+  private volatile UnsignedLong currentVotingPeriodStartTime;\n+\n+  static Eth1Data getEth1Data(Eth1BlockEvent eth1BlockEvent) {\n+    return new Eth1Data(\n+        eth1BlockEvent.getDepositRoot(),\n+        eth1BlockEvent.getDepositCount(),\n+        eth1BlockEvent.getBlockHash());\n+  }\n+\n+  public Eth1DataManager(BeaconState genesisState, EventBus eventBus) {\n+    this.eventBus = eventBus;\n+    this.genesisTime = genesisState.getGenesis_time();\n+    this.currentVotingPeriodStartTime = voting_period_start_time(genesisState.getSlot());\n+    this.eventBus.register(this);\n+  }\n+\n+  @Subscribe\n+  public void onCacheEth1BlockEvent(Eth1BlockEvent eth1BlockEvent) {\n+    eth1ChainCache.put(eth1BlockEvent.getBlockTimestamp(), getEth1Data(eth1BlockEvent));\n+  }\n+\n+  @Subscribe\n+  public void onSlot(SlotEvent slotEvent) {\n+    UnsignedLong slot = slotEvent.getSlot();\n+    UnsignedLong voting_period_start_time = voting_period_start_time(slot);\n+\n+    if (voting_period_start_time.equals(currentVotingPeriodStartTime)) {\n+      return;\n+    }\n+\n+    currentVotingPeriodStartTime = voting_period_start_time;\n+    prune(voting_period_start_time);\n+  }\n+\n+  public Eth1Data get_eth1_vote(BeaconState state) {\n+    NavigableMap<UnsignedLong, Eth1Data> votesToConsider = getVotesToConsider();\n+    Map<Eth1Data, Eth1Vote> validVotes = new HashMap<>();\n+\n+    int i = 0;\n+    for (Eth1Data eth1Data : state.getEth1_data_votes()) {\n+      if (!votesToConsider.containsValue(eth1Data)) {\n+        continue;\n+      }\n+\n+      int finalI = i;\n+      Eth1Vote vote =\n+          validVotes.computeIfAbsent(\n+              eth1Data,\n+              key -> {\n+                Eth1Vote newVote = new Eth1Vote();\n+                newVote.setIndex(finalI);\n+                return newVote;\n+              });\n+      vote.incrementVotes();\n+      i++;\n+    }\n+\n+    Eth1Data defaultVote =\n+        !votesToConsider.isEmpty() ? votesToConsider.lastEntry().getValue() : state.getEth1_data();", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDk4Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369690982", "bodyText": "done.", "author": "cemozerr", "createdAt": "2020-01-22T17:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk1NzQ1MA=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nsimilarity index 51%\nrename from validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\nrename to validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\nindex 4876ea6da..10faa8f42 100644\n--- a/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManager.java\n+++ b/validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/Eth1DataCache.java\n\n@@ -13,9 +13,16 @@\n \n package tech.pegasys.artemis.validator.coordinator;\n \n+import static tech.pegasys.artemis.pow.Eth1DataManager.getCacheRangeLowerBound;\n+import static tech.pegasys.artemis.pow.Eth1DataManager.hasBeenApproximately;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n+import java.util.Date;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.NavigableMap;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MjIyMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366962220", "bodyText": "Nice tests!  Suggest adding a few more to check that the pruning functionality works, and to test what happens when the state contains votes that the manager doesn't have.", "author": "mbaxter", "createdAt": "2020-01-15T16:05:25Z", "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1DataManagerTest {", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIxNzM0MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371217341", "bodyText": "Done!", "author": "cemozerr", "createdAt": "2020-01-27T12:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2MjIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\nindex 1f0fb91c5..9f23e0601 100644\n--- a/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n+++ b/validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/Eth1DataManagerTest.java\n\n@@ -25,10 +25,10 @@ import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n-import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n-import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n import tech.pegasys.artemis.util.SSZTypes.SSZList;\n import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.SlotEvent;\n \n public class Eth1DataManagerTest {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njk2OTE4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r366969186", "bodyText": "Probably worth adding a test or two for this class.", "author": "mbaxter", "createdAt": "2020-01-15T16:17:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockListener {\n+\n+  private final Disposable newBlockSubscription;\n+\n+  public BlockListener(", "originalCommit": "247e77560c6ab125af4dc187639964faaecfa19f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "aee7ddb31d023da565f0bb03b483e02de2234c75", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\ndeleted file mode 100644\nindex ab61c66f2..000000000\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/BlockListener.java\n+++ /dev/null\n\n@@ -1,80 +0,0 @@\n-/*\n- * Copyright 2020 ConsenSys AG.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n- * the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n- * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations under the License.\n- */\n-\n-package tech.pegasys.artemis.pow;\n-\n-import com.google.common.eventbus.EventBus;\n-import com.google.common.primitives.UnsignedLong;\n-import io.reactivex.disposables.Disposable;\n-import java.math.BigInteger;\n-import org.apache.tuweni.bytes.Bytes32;\n-import org.web3j.protocol.Web3j;\n-import org.web3j.protocol.core.DefaultBlockParameter;\n-import org.web3j.protocol.core.methods.response.EthBlock;\n-import tech.pegasys.artemis.pow.event.Eth1BlockEvent;\n-import tech.pegasys.artemis.util.async.SafeFuture;\n-import tech.pegasys.artemis.util.config.Constants;\n-\n-public class BlockListener {\n-\n-  private final Disposable newBlockSubscription;\n-\n-  public BlockListener(\n-      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n-    this.newBlockSubscription =\n-        web3j\n-            .blockFlowable(false)\n-            .subscribe(\n-                block -> {\n-                  BigInteger cacheBlockNumber =\n-                      block\n-                          .getBlock()\n-                          .getNumber()\n-                          .subtract(BigInteger.valueOf(Constants.ETH1_CACHE_BUFFER));\n-\n-                  SafeFuture<EthBlock> blockFuture =\n-                      SafeFuture.of(\n-                          web3j\n-                              .ethGetBlockByNumber(\n-                                  DefaultBlockParameter.valueOf(cacheBlockNumber), false)\n-                              .sendAsync());\n-\n-                  SafeFuture<UnsignedLong> countFuture =\n-                      SafeFuture.of(depositContractListener.getDepositCount(cacheBlockNumber));\n-                  SafeFuture<Bytes32> rootFuture =\n-                      SafeFuture.of(depositContractListener.getDepositRoot(cacheBlockNumber));\n-\n-                  SafeFuture.allOf(blockFuture, countFuture, rootFuture)\n-                      .finish(\n-                          () -> {\n-                            EthBlock.Block eth1Block = blockFuture.join().getBlock();\n-                            Bytes32 eth1BlockHash = Bytes32.fromHexString(eth1Block.getHash());\n-                            UnsignedLong eth1BlockTimestamp =\n-                                UnsignedLong.valueOf(eth1Block.getTimestamp());\n-                            UnsignedLong eth1BlockNumber =\n-                                UnsignedLong.valueOf(eth1Block.getNumber());\n-                            eventBus.post(\n-                                new Eth1BlockEvent(\n-                                    eth1BlockNumber,\n-                                    eth1BlockHash,\n-                                    eth1BlockTimestamp,\n-                                    rootFuture.join(),\n-                                    countFuture.join()));\n-                          });\n-                });\n-  }\n-\n-  public void stop() {\n-    newBlockSubscription.dispose();\n-  }\n-}\n"}}, {"oid": "aee7ddb31d023da565f0bb03b483e02de2234c75", "url": "https://github.com/ConsenSys/teku/commit/aee7ddb31d023da565f0bb03b483e02de2234c75", "message": "Implement cache range independent of beacon state", "committedDate": "2020-01-17T22:44:23Z", "type": "commit"}, {"oid": "1dc34a5ebb13226a99b8e9c2319371a5b473b213", "url": "https://github.com/ConsenSys/teku/commit/1dc34a5ebb13226a99b8e9c2319371a5b473b213", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-17T22:44:48Z", "type": "commit"}, {"oid": "f420b2451b6a28621225b9351ee0d2721ce2b8ac", "url": "https://github.com/ConsenSys/teku/commit/f420b2451b6a28621225b9351ee0d2721ce2b8ac", "message": "Delete Eth1DataResponse", "committedDate": "2020-01-17T22:50:43Z", "type": "commit"}, {"oid": "169f3610cbbef8b146ec6f436014447e4910ab6a", "url": "https://github.com/ConsenSys/teku/commit/169f3610cbbef8b146ec6f436014447e4910ab6a", "message": "Delete Eth1DataRequest", "committedDate": "2020-01-17T22:51:08Z", "type": "commit"}, {"oid": "74bc03ac5f7e9a8350f58653b7eadd264e5dd730", "url": "https://github.com/ConsenSys/teku/commit/74bc03ac5f7e9a8350f58653b7eadd264e5dd730", "message": "Keep root cause of exception", "committedDate": "2020-01-17T22:58:02Z", "type": "commit"}, {"oid": "45ec394ca175953f50606abf2e65e997d98752f2", "url": "https://github.com/ConsenSys/teku/commit/45ec394ca175953f50606abf2e65e997d98752f2", "message": "Change function name", "committedDate": "2020-01-17T22:59:10Z", "type": "commit"}, {"oid": "55e94f8daedbd2eece38830ad2d6b9d0f64cbdd3", "url": "https://github.com/ConsenSys/teku/commit/55e94f8daedbd2eece38830ad2d6b9d0f64cbdd3", "message": "Make cache object final", "committedDate": "2020-01-17T23:00:01Z", "type": "commit"}, {"oid": "67127b266841cfa639a2138b744fd227e2f114f8", "url": "https://github.com/ConsenSys/teku/commit/67127b266841cfa639a2138b744fd227e2f114f8", "message": "Refactor nesting if statement", "committedDate": "2020-01-17T23:03:01Z", "type": "commit"}, {"oid": "5c485718197db71ad3941f35bb824a271bb310b2", "url": "https://github.com/ConsenSys/teku/commit/5c485718197db71ad3941f35bb824a271bb310b2", "message": "Change variable name", "committedDate": "2020-01-17T23:04:43Z", "type": "commit"}, {"oid": "397bcc3f4022a4a86bbb288d2f491866bc0565d5", "url": "https://github.com/ConsenSys/teku/commit/397bcc3f4022a4a86bbb288d2f491866bc0565d5", "message": "Fix bug", "committedDate": "2020-01-17T23:06:11Z", "type": "commit"}, {"oid": "d76024dedb1a61447e4b4806e56fda273b5b182b", "url": "https://github.com/ConsenSys/teku/commit/d76024dedb1a61447e4b4806e56fda273b5b182b", "message": "Run spotless", "committedDate": "2020-01-17T23:07:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODczOTkyOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368739928", "bodyText": "delete line.", "author": "cemozerr", "createdAt": "2020-01-20T22:03:56Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTkyNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368741927", "bodyText": "change this to the argument", "author": "cemozerr", "createdAt": "2020-01-20T22:13:10Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actual_time_diff = latestBlockTimestamp.minus(blockTimestamp);\n+              return blockNumberDiff.dividedBy(actual_time_diff);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockNumberFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture) {\n+    return SafeFuture.allOf(latestBlockNumberFuture, blockNumberDiffFuture)\n+        .thenCompose(\n+            done -> {\n+              UnsignedLong latestBlockNumber = latestBlockNumberFuture.getNow(null);\n+              checkNotNull(latestBlockNumber);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+\n+              return getEth1BlockFuture(latestBlockNumber.minus(blockNumberDiff));\n+            });\n+  }\n+\n+  private static boolean isTimestampInRange(UnsignedLong timestamp) {\n+    return timestamp.compareTo(getCacheRangeLowerBound()) >= 0\n+        && timestamp.compareTo(getCacheRangeUpperBound()) <= 0;\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockTimestampFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(\n+        ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getTimestamp()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getNumber()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberDiffWithMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> secondsPerEth1BlockFuture,\n+      UnsignedLong rcrAverage) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, secondsPerEth1BlockFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong secondsPerEth1Block = secondsPerEth1BlockFuture.getNow(null);\n+              checkNotNull(secondsPerEth1Block);\n+\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              if (latestBlockTimestamp.compareTo(rcrAverage) < 0) {\n+                throw new RuntimeException(\n+                    \"Latest block timestamp is less than the cache mid-range\");\n+              }\n+              UnsignedLong timeDiff = latestBlockTimestamp.minus(rcrAverage);\n+              return timeDiff.dividedBy(secondsPerEth1Block);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(UnsignedLong blockNumber) {\n+    DefaultBlockParameter blockParameter =\n+        DefaultBlockParameter.valueOf(blockNumber.bigIntegerValue());\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(DefaultBlockParameter blockParameter) {\n+    return SafeFuture.of(web3j.ethGetBlockByNumber(blockParameter, false).sendAsync());\n+  }\n+\n+  private SafeFuture<EthBlock> getLatestEth1BlockFuture() {\n+    DefaultBlockParameter blockParameter = DefaultBlockParameterName.LATEST;\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<Void> postCacheEth1BlockEvent(UnsignedLong blockNumber, EthBlock.Block block) {\n+    SafeFuture<UnsignedLong> countFuture =\n+        SafeFuture.of(depositContractListener.getDepositCount(blockNumber));\n+    SafeFuture<Bytes32> rootFuture =\n+        SafeFuture.of(depositContractListener.getDepositRoot(blockNumber));\n+\n+    return SafeFuture.allOf(countFuture, rootFuture)\n+        .thenRun(\n+            () -> {\n+              Bytes32 root = rootFuture.getNow(null);\n+              checkNotNull(root);\n+\n+              UnsignedLong count = countFuture.getNow(null);\n+              checkNotNull(count);\n+\n+              Bytes32 eth1BlockHash = Bytes32.fromHexString(block.getHash());\n+              UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(block.getNumber());\n+\n+              eventBus.post(\n+                  new CacheEth1BlockEvent(\n+                      eth1BlockNumber, eth1BlockHash, eth1BlockTimestamp, root, count));\n+            });\n+  }\n+\n+  public static UnsignedLong getCacheRangeLowerBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(UnsignedLong.valueOf(SLOTS_PER_ETH1_VOTING_PERIOD * SECONDS_PER_SLOT))\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK).times(UnsignedLong.valueOf(2)));\n+  }\n+\n+  public static UnsignedLong getCacheRangeUpperBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK))\n+        .plus(ETH1_REQUEST_BUFFER);\n+  }\n+\n+  public static boolean hasBeenApproximately(UnsignedLong seconds, Date date) {\n+    return UnsignedLong.valueOf(date.getTime())\n+        .mod(SECONDS_PER_ETH1_BLOCK)", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTY0MDkwNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r365640907", "bodyText": "This should just be super(e) so we don't loose the original stack trace.", "author": "ajsutton", "createdAt": "2020-01-13T03:52:02Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow.exception;\n+\n+public class Eth1RequestException extends RuntimeException {\n+  public Eth1RequestException(String err) {\n+    super(err);\n+  }\n+\n+  public Eth1RequestException(RuntimeException e) {\n+    super(e.toString());", "originalCommit": "d509aa772a8d394b9e4d9235371b73c6f7322215", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "74bc03ac5f7e9a8350f58653b7eadd264e5dd730", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java b/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java\nindex 53d7e495e..0c6e6d894 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/exception/Eth1RequestException.java\n\n@@ -19,6 +19,6 @@ public class Eth1RequestException extends RuntimeException {\n   }\n \n   public Eth1RequestException(RuntimeException e) {\n-    super(e.toString());\n+    super(e);\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTAxNg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368375016", "bodyText": "I'd probably use a thenApply here which does the ethCall.hasError() check and throws an exception. That way this method a nice intuitive SafeFuture which completes normally when there's an error and we can avoid some duplication.\nI'd probably just have a common JsonRpcException or Eth1NodeException rather than the two specific exceptions for deposit count and deposit root.", "author": "ajsutton", "createdAt": "2020-01-20T05:30:03Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java", "diffHunk": "@@ -51,11 +65,56 @@ public DepositContractListener(EventBus eventBus, DepositContract contract) {\n                 });\n   }\n \n+  @SuppressWarnings(\"rawtypes\")\n+  public SafeFuture<Bytes32> getDepositRoot(UnsignedLong blockHeight) {\n+    String encodedFunction = contract.get_deposit_root().encodeFunctionCall();\n+    return callFunctionAtBlockNumber(encodedFunction, blockHeight)\n+        .thenApply(\n+            ethCall -> {\n+              if (ethCall.hasError()) {\n+                throw new DepositRootRequestException(\n+                    \"Eth1 call get_deposit_root() has failed:\" + ethCall.getError().getMessage());\n+              }\n+              String value = ethCall.getValue();\n+              List<Type> list = contract.get_deposit_root().decodeFunctionResponse(value);\n+              return Bytes32.wrap((byte[]) list.get(0).getValue());\n+            });\n+  }\n+\n+  @SuppressWarnings(\"rawtypes\")\n+  public SafeFuture<UnsignedLong> getDepositCount(UnsignedLong blockHeight) {\n+    String encodedFunction = contract.get_deposit_count().encodeFunctionCall();\n+    return callFunctionAtBlockNumber(encodedFunction, blockHeight)\n+        .thenApply(\n+            ethCall -> {\n+              if (ethCall.hasError()) {\n+                throw new DepositCountRequestException(\n+                    \"Eth1 call get_deposit_count() has failed:\" + ethCall.getError().getMessage());\n+              }\n+              String value = ethCall.getValue();\n+              List<Type> list = contract.get_deposit_count().decodeFunctionResponse(value);\n+              byte[] bytes = (byte[]) list.get(0).getValue();\n+              long deposit_count = Bytes.wrap(bytes).reverse().toLong();\n+              return UnsignedLong.valueOf(deposit_count);\n+            });\n+  }\n+\n   public DepositContract getContract() {\n     return contract;\n   }\n \n   public void stop() {\n     subscriptionNewDeposit.dispose();\n   }\n+\n+  private SafeFuture<EthCall> callFunctionAtBlockNumber(\n+      String encodedFunction, UnsignedLong blockHeight) {\n+    return SafeFuture.of(\n+        web3j\n+            .ethCall(\n+                Transaction.createEthCallTransaction(\n+                    null, contract.getContractAddress(), encodedFunction),\n+                DefaultBlockParameter.valueOf(blockHeight.bigIntegerValue()))\n+            .sendAsync());", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTA5NjM2NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369096364", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-21T16:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTAxNg=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java b/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java\nindex 886559b9c..285382337 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/DepositContractListener.java\n\n@@ -70,12 +68,7 @@ public class DepositContractListener {\n     String encodedFunction = contract.get_deposit_root().encodeFunctionCall();\n     return callFunctionAtBlockNumber(encodedFunction, blockHeight)\n         .thenApply(\n-            ethCall -> {\n-              if (ethCall.hasError()) {\n-                throw new DepositRootRequestException(\n-                    \"Eth1 call get_deposit_root() has failed:\" + ethCall.getError().getMessage());\n-              }\n-              String value = ethCall.getValue();\n+            value -> {\n               List<Type> list = contract.get_deposit_root().decodeFunctionResponse(value);\n               return Bytes32.wrap((byte[]) list.get(0).getValue());\n             });\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTg0OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368375848", "bodyText": "We should probably bail out if the cache startup logic hasn't finished yet (or if it failed).  Otherwise this will throw because there's no value to get.", "author": "ajsutton", "createdAt": "2020-01-20T05:35:07Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNjIzNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369136235", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-21T17:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NTg0OA=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NjMyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368376324", "bodyText": "There's never anything that logs why were were  unsuccessful here so if it goes wrong we won't have any information to diagnose why.  Not sure what information is needed but it seems weird to fail with no indication as to why.", "author": "ajsutton", "createdAt": "2020-01-20T05:38:04Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNjYxOQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369136619", "bodyText": "Removed startup logic states, as discussed offline, to propagate up the exception.", "author": "cemozerr", "createdAt": "2020-01-21T17:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NjMyNA=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NzAwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368377005", "bodyText": "seconds is never used.", "author": "ajsutton", "createdAt": "2020-01-20T05:42:09Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actual_time_diff = latestBlockTimestamp.minus(blockTimestamp);\n+              return blockNumberDiff.dividedBy(actual_time_diff);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockNumberFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture) {\n+    return SafeFuture.allOf(latestBlockNumberFuture, blockNumberDiffFuture)\n+        .thenCompose(\n+            done -> {\n+              UnsignedLong latestBlockNumber = latestBlockNumberFuture.getNow(null);\n+              checkNotNull(latestBlockNumber);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+\n+              return getEth1BlockFuture(latestBlockNumber.minus(blockNumberDiff));\n+            });\n+  }\n+\n+  private static boolean isTimestampInRange(UnsignedLong timestamp) {\n+    return timestamp.compareTo(getCacheRangeLowerBound()) >= 0\n+        && timestamp.compareTo(getCacheRangeUpperBound()) <= 0;\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockTimestampFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(\n+        ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getTimestamp()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getNumber()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberDiffWithMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> secondsPerEth1BlockFuture,\n+      UnsignedLong rcrAverage) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, secondsPerEth1BlockFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong secondsPerEth1Block = secondsPerEth1BlockFuture.getNow(null);\n+              checkNotNull(secondsPerEth1Block);\n+\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              if (latestBlockTimestamp.compareTo(rcrAverage) < 0) {\n+                throw new RuntimeException(\n+                    \"Latest block timestamp is less than the cache mid-range\");\n+              }\n+              UnsignedLong timeDiff = latestBlockTimestamp.minus(rcrAverage);\n+              return timeDiff.dividedBy(secondsPerEth1Block);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(UnsignedLong blockNumber) {\n+    DefaultBlockParameter blockParameter =\n+        DefaultBlockParameter.valueOf(blockNumber.bigIntegerValue());\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(DefaultBlockParameter blockParameter) {\n+    return SafeFuture.of(web3j.ethGetBlockByNumber(blockParameter, false).sendAsync());\n+  }\n+\n+  private SafeFuture<EthBlock> getLatestEth1BlockFuture() {\n+    DefaultBlockParameter blockParameter = DefaultBlockParameterName.LATEST;\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<Void> postCacheEth1BlockEvent(UnsignedLong blockNumber, EthBlock.Block block) {\n+    SafeFuture<UnsignedLong> countFuture =\n+        SafeFuture.of(depositContractListener.getDepositCount(blockNumber));\n+    SafeFuture<Bytes32> rootFuture =\n+        SafeFuture.of(depositContractListener.getDepositRoot(blockNumber));\n+\n+    return SafeFuture.allOf(countFuture, rootFuture)\n+        .thenRun(\n+            () -> {\n+              Bytes32 root = rootFuture.getNow(null);\n+              checkNotNull(root);\n+\n+              UnsignedLong count = countFuture.getNow(null);\n+              checkNotNull(count);\n+\n+              Bytes32 eth1BlockHash = Bytes32.fromHexString(block.getHash());\n+              UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(block.getNumber());\n+\n+              eventBus.post(\n+                  new CacheEth1BlockEvent(\n+                      eth1BlockNumber, eth1BlockHash, eth1BlockTimestamp, root, count));\n+            });\n+  }\n+\n+  public static UnsignedLong getCacheRangeLowerBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(UnsignedLong.valueOf(SLOTS_PER_ETH1_VOTING_PERIOD * SECONDS_PER_SLOT))\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK).times(UnsignedLong.valueOf(2)));\n+  }\n+\n+  public static UnsignedLong getCacheRangeUpperBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK))\n+        .plus(ETH1_REQUEST_BUFFER);\n+  }\n+\n+  public static boolean hasBeenApproximately(UnsignedLong seconds, Date date) {", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MDg4MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369140881", "bodyText": "replaced with seconds_per_eth1_block", "author": "cemozerr", "createdAt": "2020-01-21T17:30:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM3NzAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTYwOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368381608", "bodyText": "checkNotNull returns the value provided so you can do this as:\nUnsignedLong blockTimestamp = checkNotNull(blockTimestampFuture.getNow(null)`\n\nNot sure if it's actually better though...", "author": "ajsutton", "createdAt": "2020-01-20T06:08:47Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNzQ5OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369137498", "bodyText": "I think its more legible the first way, so I'm going to keep it that way unless you have a strong desire.", "author": "cemozerr", "createdAt": "2020-01-21T17:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTYwOA=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTcxNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368381714", "bodyText": "This may be better described as the average time difference - in PoW networks it will vary significantly.", "author": "ajsutton", "createdAt": "2020-01-20T06:09:22Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      SafeFuture<UnsignedLong> blockTimestampFuture) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture, blockTimestampFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockTimestamp = blockTimestampFuture.getNow(null);\n+              checkNotNull(blockTimestamp);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actual_time_diff = latestBlockTimestamp.minus(blockTimestamp);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MDI2OA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369140268", "bodyText": "I think I might be missing your point here. The actual time difference here represents the time difference between the latest block's timestamp and the block that we have in hand. We previously had estimated a different time difference if this function is getting called. So I'm not sure if calling it \"average\" would be appropriate.", "author": "cemozerr", "createdAt": "2020-01-21T17:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM4MTcxNA=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDI0Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368740246", "bodyText": "We probably should have runCacheStartupLogic just return a SafeFuture<Void> and if it fails the SafeFuture completes exceptionally.  Then here we can catch that exception (with either exceptionally or finish(onSuccess, onFailure)) and retry after a short delay.  If we never retry then artemis will lose connection with the Eth1 chain and need to be restarted before it recovers.", "author": "ajsutton", "createdAt": "2020-01-20T22:05:29Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzMjcyNA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369132724", "bodyText": "Done. Actually had to make runCacheStartupLogic implement .finish() in itself due to needing to schedule the retry attempts multiple times in the future, so runCacheStartupLogic returns void in the end. Hopefully, that was the right thing to do.", "author": "cemozerr", "createdAt": "2020-01-21T17:14:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDI0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDY0Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r368740642", "bodyText": "Leave the exception to propagate back out as a failed future here rather than converting to a state and losing the detail of what exception was thrown.", "author": "ajsutton", "createdAt": "2020-01-20T22:07:17Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+\n+  private enum StartupLogicStates {\n+    SUCCESSFULLY_COMPLETED,\n+    UNSUCCESSFULLY_COMPLETED,\n+    UNABLE_TO_EXPLORE_BLOCKS,\n+    DONE_EXPLORING,\n+  }\n+\n+  public Eth1DataManager(\n+      Web3j web3j, EventBus eventBus, DepositContractListener depositContractListener) {\n+    this.web3j = web3j;\n+    this.depositContractListener = depositContractListener;\n+    this.eventBus = eventBus;\n+    eventBus.register(this);\n+\n+    runCacheStartupLogic()\n+        .finish(\n+            (result) -> {\n+              if (!result.equals(StartupLogicStates.SUCCESSFULLY_COMPLETED)) {\n+                throw new RuntimeException(\"Eth1DataManager unable to fill cache at startup\");\n+              }\n+            });\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds.\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true)\n+        .finish(\n+            res -> {\n+              if (!res.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                LOG.warn(\"Failed to import new eth1 blocks\");\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> runCacheStartupLogic() {\n+    UnsignedLong cacheRangeLowerBound = getCacheRangeLowerBound();\n+    UnsignedLong cacheRangerUpperBound = getCacheRangeUpperBound();\n+\n+    UnsignedLong cacheMidRange =\n+        cacheRangerUpperBound.plus(cacheRangeLowerBound).dividedBy(UnsignedLong.valueOf(2));\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> blockNumberDiffFuture =\n+        getBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRange);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, blockNumberDiffFuture);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture,\n+                        blockNumberDiffFuture,\n+                        SafeFuture.completedFuture(timestamp));\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture, realSecondsPerEth1BlockFuture, cacheMidRange);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<StartupLogicStates> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<StartupLogicStates> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture)\n+                  .thenApply(\n+                      done -> {\n+                        StartupLogicStates exploreUpResult = exploreUpResultFuture.getNow(null);\n+                        checkNotNull(exploreUpResult);\n+\n+                        StartupLogicStates exploreDownResult = exploreDownResultFuture.getNow(null);\n+                        checkNotNull(exploreDownResult);\n+\n+                        if (exploreDownResult.equals(StartupLogicStates.DONE_EXPLORING)\n+                            && exploreUpResult.equals(StartupLogicStates.DONE_EXPLORING)) {\n+                          return StartupLogicStates.SUCCESSFULLY_COMPLETED;\n+                        } else {\n+                          return StartupLogicStates.UNSUCCESSFULLY_COMPLETED;\n+                        }\n+                      });\n+            });\n+  }\n+\n+  private SafeFuture<StartupLogicStates> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture\n+        .thenCompose(\n+            ethBlock -> {\n+              EthBlock.Block block = ethBlock.getBlock();\n+              if (isDirectionUp) latestBlockReference.set(block);\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+              if (isTimestampInRange(timestamp)) {\n+                return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+              }\n+              return SafeFuture.completedFuture(StartupLogicStates.DONE_EXPLORING);\n+            })\n+        .exceptionally(err -> StartupLogicStates.UNABLE_TO_EXPLORE_BLOCKS);", "originalCommit": "d76024dedb1a61447e4b4806e56fda273b5b182b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNzc1MA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r369137750", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-21T17:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex f545a5292..391a5dbd9 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -25,7 +25,15 @@ import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n import java.util.Date;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n+\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"oid": "ea33291aa022b61cd418d4c3ebd8c29c12a44420", "url": "https://github.com/ConsenSys/teku/commit/ea33291aa022b61cd418d4c3ebd8c29c12a44420", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-20T23:10:16Z", "type": "commit"}, {"oid": "f7bcd1888dfd7ffd5fb13f14595218fd92f20bd9", "url": "https://github.com/ConsenSys/teku/commit/f7bcd1888dfd7ffd5fb13f14595218fd92f20bd9", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-21T21:06:27Z", "type": "commit"}, {"oid": "c2158dca8ca832b749e0fa6a917008a571a33dc7", "url": "https://github.com/ConsenSys/teku/commit/c2158dca8ca832b749e0fa6a917008a571a33dc7", "message": "WIP: trying to run cache startup multiple times", "committedDate": "2020-01-21T21:28:55Z", "type": "commit"}, {"oid": "0fa8e22d14b48abc818f49dae4e952b60cf13863", "url": "https://github.com/ConsenSys/teku/commit/0fa8e22d14b48abc818f49dae4e952b60cf13863", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-22T15:40:24Z", "type": "commit"}, {"oid": "b859e27b9497e09314d822a2e4f32a4092da937d", "url": "https://github.com/ConsenSys/teku/commit/b859e27b9497e09314d822a2e4f32a4092da937d", "message": "Fix running cache startup multiple times", "committedDate": "2020-01-22T16:45:06Z", "type": "commit"}, {"oid": "6ab835fcac380d5bd8083fdafa6ffba3c305fd47", "url": "https://github.com/ConsenSys/teku/commit/6ab835fcac380d5bd8083fdafa6ffba3c305fd47", "message": "Run spotless", "committedDate": "2020-01-22T16:47:23Z", "type": "commit"}, {"oid": "f4e642d9495de5193043137c63f3089a37ec2fd2", "url": "https://github.com/ConsenSys/teku/commit/f4e642d9495de5193043137c63f3089a37ec2fd2", "message": "Change test-suite name", "committedDate": "2020-01-22T16:48:43Z", "type": "commit"}, {"oid": "eed0cf6e920b43e3cf272ca440072897879a47eb", "url": "https://github.com/ConsenSys/teku/commit/eed0cf6e920b43e3cf272ca440072897879a47eb", "message": "Finish cache tests and change nits", "committedDate": "2020-01-22T21:22:45Z", "type": "commit"}, {"oid": "b4c19e5bfb81d38d990e4080b022651ee4649a4e", "url": "https://github.com/ConsenSys/teku/commit/b4c19e5bfb81d38d990e4080b022651ee4649a4e", "message": "Add tests for voting in a new period", "committedDate": "2020-01-22T22:14:24Z", "type": "commit"}, {"oid": "f03caacf497a2fec42eab473dd1fd97e0acdff61", "url": "https://github.com/ConsenSys/teku/commit/f03caacf497a2fec42eab473dd1fd97e0acdff61", "message": "Run spotless", "committedDate": "2020-01-22T22:15:09Z", "type": "commit"}, {"oid": "59e76200223fe16886602413359638ce19573895", "url": "https://github.com/ConsenSys/teku/commit/59e76200223fe16886602413359638ce19573895", "message": "Implement tests for Eth1DataManager", "committedDate": "2020-01-24T00:01:18Z", "type": "commit"}, {"oid": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "url": "https://github.com/ConsenSys/teku/commit/7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "message": "Suppress warnings", "committedDate": "2020-01-24T17:14:46Z", "type": "commit"}, {"oid": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "url": "https://github.com/ConsenSys/teku/commit/ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "message": "Finish Eth1DataManager tests", "committedDate": "2020-01-24T21:47:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzMzIyMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370833220", "bodyText": "nit: I tend to init mocks in the field declaration rather than in setup just for brevity.", "author": "ajsutton", "createdAt": "2020-01-24T20:42:17Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private Eth1DataManager eth1DataManager;\n+  private Web3j web3j;\n+  private DepositContractListener depositContractListener;\n+\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+\n+  private final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+  private final UnsignedLong LATEST_BLOCK_TIMESTAMP =\n+      UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+  private final UnsignedLong INCONSEQUENTIAL_BLOCK_NUMBER = UnsignedLong.valueOf(100000);\n+  private final Request mockLatestBlockRequest =\n+      mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, LATEST_BLOCK_TIMESTAMP);\n+\n+  @BeforeEach\n+  void setUp() {\n+    web3j = mock(Web3j.class);\n+    depositContractListener = mock(DepositContractListener.class);", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIxODA2Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371218066", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-27T12:40:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzMzIyMA=="}], "type": "inlineReview", "revised_code": {"commit": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 0e22b5de7..58e643e05 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -17,13 +17,17 @@ import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n \n import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n+import java.util.Date;\n import java.util.concurrent.CompletableFuture;\n import java.util.stream.Collectors;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNDcxMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370834713", "bodyText": "It would be better if we injected an instance of java.time.Clock into the class and used that to retrieve the current instant rather than the static Instant.now().  In production you'd use Clock.systemUTC to create the instance so you get real time, but in tests you can use Clock.fixed to create a clock at a fixed time so tests are deterministic.  We may want something like https://github.com/hyperledger/besu/blob/bac5c673d3603b2aba70b7ffd77afd57a44775c8/testutil/src/main/java/org/hyperledger/besu/testutil/TestClock.java#L14 to make life easier and allow tests to manually step time forward.", "author": "ajsutton", "createdAt": "2020-01-24T20:46:26Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+  private final AsyncRunner asyncRunner;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+  private AtomicInteger cacheStartupRetry = new AtomicInteger(0);\n+  private AtomicBoolean cacheStartupDone = new AtomicBoolean(false);\n+\n+  public Eth1DataManager(\n+      Web3j web3j,\n+      EventBus eventBus,\n+      DepositContractListener depositContractListener,\n+      AsyncRunner asyncRunner) {\n+    this.web3j = web3j;\n+    this.eventBus = eventBus;\n+    this.depositContractListener = depositContractListener;\n+    this.asyncRunner = asyncRunner;\n+    eventBus.register(this);\n+\n+    runCacheStartup();\n+  }\n+\n+  @Subscribe\n+  public void onTick(Date date) {\n+    // Fetch new Eth1 blocks every SECONDS_PER_ETH1_BLOCK seconds\n+    // (can't use slot events here as an approximation due to this needing to be run pre-genesis)\n+    if (!hasBeenApproximately(SECONDS_PER_ETH1_BLOCK, date)) {\n+      return;\n+    }\n+\n+    // Bail if cache startup logic hasn't finished yet\n+    if (!cacheStartupDone.get()) {\n+      return;\n+    }\n+\n+    EthBlock.Block latestBlock = latestBlockReference.get();\n+    UnsignedLong latestTimestamp = UnsignedLong.valueOf(latestBlock.getTimestamp());\n+\n+    // Don't get newer blocks if the timestamp of the last block fetched is\n+    // still higher than the range upper bound\n+    if (latestTimestamp.compareTo(getCacheRangeUpperBound()) > 0) {\n+      return;\n+    }\n+\n+    UnsignedLong latestBlockNumber = UnsignedLong.valueOf(latestBlock.getNumber());\n+    exploreBlocksInDirection(latestBlockNumber, true).reportExceptions();\n+  }\n+\n+  public void runCacheStartup() {\n+    doCacheStartup()\n+        .finish(\n+            () -> {\n+              LOG.info(\"Eth1DataManager successfully ran cache startup logic\");\n+              cacheStartupDone.set(true);\n+            });\n+  }\n+\n+  private SafeFuture<Void> doCacheStartup() {\n+    final UnsignedLong cacheMidRangeTimestamp = getCacheMidRangeTimestamp();\n+\n+    SafeFuture<EthBlock> latestEthBlockFuture = getLatestEth1BlockFuture();\n+\n+    SafeFuture<UnsignedLong> latestBlockTimestampFuture =\n+        getBlockTimestampFuture(latestEthBlockFuture);\n+    SafeFuture<UnsignedLong> latestBlockNumberFuture = getBlockNumberFuture(latestEthBlockFuture);\n+\n+    SafeFuture<UnsignedLong> approximatedBlockNumberDiff =\n+        getApproximatedBlockNumberDiffWithMidRangeBlock(\n+            latestBlockTimestampFuture,\n+            SafeFuture.completedFuture(SECONDS_PER_ETH1_BLOCK),\n+            cacheMidRangeTimestamp);\n+\n+    SafeFuture<EthBlock> blockFuture =\n+        getMidRangeBlock(latestBlockNumberFuture, approximatedBlockNumberDiff);\n+\n+    return blockFuture\n+        .thenCompose(\n+            eth1block -> {\n+              EthBlock.Block block = eth1block.getBlock();\n+              UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              SafeFuture<EthBlock> middleBlockFuture = blockFuture;\n+              if (!isTimestampInRange(timestamp)) {\n+\n+                SafeFuture<UnsignedLong> realSecondsPerEth1BlockFuture =\n+                    calculateRealSecondsPerEth1BlockFuture(\n+                        latestBlockTimestampFuture, approximatedBlockNumberDiff, timestamp);\n+\n+                SafeFuture<UnsignedLong> newBlockNumberDiffFuture =\n+                    getApproximatedBlockNumberDiffWithMidRangeBlock(\n+                        latestBlockTimestampFuture,\n+                        realSecondsPerEth1BlockFuture,\n+                        cacheMidRangeTimestamp);\n+\n+                middleBlockFuture =\n+                    getMidRangeBlock(latestBlockNumberFuture, newBlockNumberDiffFuture);\n+              }\n+              return middleBlockFuture;\n+            })\n+        .thenCompose(\n+            middleBlock -> {\n+              EthBlock.Block block = middleBlock.getBlock();\n+              UnsignedLong middleBlockNumber = UnsignedLong.valueOf(block.getNumber());\n+              postCacheEth1BlockEvent(middleBlockNumber, block).reportExceptions();\n+              SafeFuture<Void> exploreUpResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, true);\n+              SafeFuture<Void> exploreDownResultFuture =\n+                  exploreBlocksInDirection(middleBlockNumber, false);\n+              return SafeFuture.allOf(exploreUpResultFuture, exploreDownResultFuture);\n+            })\n+        .exceptionallyCompose(\n+            err -> {\n+              if (cacheStartupRetry.incrementAndGet()\n+                  == Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP) {\n+                return SafeFuture.failedFuture(\n+                    new RuntimeException(\n+                        \"Eth1DataManager aborted due to multiple failed startup attempts\"));\n+              }\n+\n+              LOG.debug(\n+                  \"Eth1DataManager failed to run cache startup logic. Retry in \"\n+                      + Constants.ETH1_CACHE_STARTUP_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::doCacheStartup,\n+                  Constants.ETH1_CACHE_STARTUP_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private SafeFuture<Void> exploreBlocksInDirection(\n+      UnsignedLong blockNumber, final boolean isDirectionUp) {\n+    blockNumber =\n+        isDirectionUp ? blockNumber.plus(UnsignedLong.ONE) : blockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock> blockFuture = getEth1BlockFuture(blockNumber);\n+    UnsignedLong finalBlockNumber = blockNumber;\n+    return blockFuture.thenCompose(\n+        ethBlock -> {\n+          EthBlock.Block block = ethBlock.getBlock();\n+          if (isDirectionUp) latestBlockReference.set(block);\n+          UnsignedLong timestamp = UnsignedLong.valueOf(block.getTimestamp());\n+          postCacheEth1BlockEvent(finalBlockNumber, block).reportExceptions();\n+          if (isTimestampInRange(timestamp)) {\n+            return exploreBlocksInDirection(finalBlockNumber, isDirectionUp);\n+          }\n+          return SafeFuture.completedFuture(null);\n+        });\n+  }\n+\n+  private SafeFuture<UnsignedLong> calculateRealSecondsPerEth1BlockFuture(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture,\n+      UnsignedLong blockTimestamp) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, blockNumberDiffFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              UnsignedLong actualTimeDiff = latestBlockTimestamp.minus(blockTimestamp);\n+              return actualTimeDiff.dividedBy(blockNumberDiff);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockNumberFuture,\n+      SafeFuture<UnsignedLong> blockNumberDiffFuture) {\n+    return SafeFuture.allOf(latestBlockNumberFuture, blockNumberDiffFuture)\n+        .thenCompose(\n+            done -> {\n+              UnsignedLong latestBlockNumber = latestBlockNumberFuture.getNow(null);\n+              checkNotNull(latestBlockNumber);\n+              UnsignedLong blockNumberDiff = blockNumberDiffFuture.getNow(null);\n+              checkNotNull(blockNumberDiff);\n+\n+              return getEth1BlockFuture(latestBlockNumber.minus(blockNumberDiff));\n+            });\n+  }\n+\n+  private static boolean isTimestampInRange(UnsignedLong timestamp) {\n+    return timestamp.compareTo(getCacheRangeLowerBound()) >= 0\n+        && timestamp.compareTo(getCacheRangeUpperBound()) <= 0;\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockTimestampFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(\n+        ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getTimestamp()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getBlockNumberFuture(SafeFuture<EthBlock> blockFuture) {\n+    return blockFuture.thenApply(ethBlock -> UnsignedLong.valueOf(ethBlock.getBlock().getNumber()));\n+  }\n+\n+  private SafeFuture<UnsignedLong> getApproximatedBlockNumberDiffWithMidRangeBlock(\n+      SafeFuture<UnsignedLong> latestBlockTimestampFuture,\n+      SafeFuture<UnsignedLong> secondsPerEth1BlockFuture,\n+      UnsignedLong cacheMidRangeTimestamp) {\n+    return SafeFuture.allOf(latestBlockTimestampFuture, secondsPerEth1BlockFuture)\n+        .thenApply(\n+            done -> {\n+              UnsignedLong secondsPerEth1Block = secondsPerEth1BlockFuture.getNow(null);\n+              checkNotNull(secondsPerEth1Block);\n+\n+              UnsignedLong latestBlockTimestamp = latestBlockTimestampFuture.getNow(null);\n+              checkNotNull(latestBlockTimestamp);\n+\n+              if (latestBlockTimestamp.compareTo(cacheMidRangeTimestamp) < 0) {\n+                throw new RuntimeException(\n+                    \"Latest block timestamp is less than the cache mid-range\");\n+              }\n+              UnsignedLong timeDiff = latestBlockTimestamp.minus(cacheMidRangeTimestamp);\n+              return timeDiff.dividedBy(secondsPerEth1Block);\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(UnsignedLong blockNumber) {\n+    DefaultBlockParameter blockParameter =\n+        DefaultBlockParameter.valueOf(blockNumber.bigIntegerValue());\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<EthBlock> getEth1BlockFuture(DefaultBlockParameter blockParameter) {\n+    return SafeFuture.of(web3j.ethGetBlockByNumber(blockParameter, false).sendAsync());\n+  }\n+\n+  private SafeFuture<EthBlock> getLatestEth1BlockFuture() {\n+    DefaultBlockParameter blockParameter = DefaultBlockParameterName.LATEST;\n+    return getEth1BlockFuture(blockParameter);\n+  }\n+\n+  private SafeFuture<Void> postCacheEth1BlockEvent(UnsignedLong blockNumber, EthBlock.Block block) {\n+    SafeFuture<UnsignedLong> countFuture =\n+        SafeFuture.of(depositContractListener.getDepositCount(blockNumber));\n+    SafeFuture<Bytes32> rootFuture =\n+        SafeFuture.of(depositContractListener.getDepositRoot(blockNumber));\n+\n+    return SafeFuture.allOf(countFuture, rootFuture)\n+        .thenRun(\n+            () -> {\n+              Bytes32 root = rootFuture.getNow(null);\n+              checkNotNull(root);\n+\n+              UnsignedLong count = countFuture.getNow(null);\n+              checkNotNull(count);\n+\n+              Bytes32 eth1BlockHash = Bytes32.fromHexString(block.getHash());\n+              UnsignedLong eth1BlockTimestamp = UnsignedLong.valueOf(block.getTimestamp());\n+              UnsignedLong eth1BlockNumber = UnsignedLong.valueOf(block.getNumber());\n+\n+              eventBus.post(\n+                  new CacheEth1BlockEvent(\n+                      eth1BlockNumber, eth1BlockHash, eth1BlockTimestamp, root, count));\n+            });\n+  }\n+\n+  public static UnsignedLong getCacheRangeLowerBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+    return current_time\n+        .minus(UnsignedLong.valueOf(SLOTS_PER_ETH1_VOTING_PERIOD * SECONDS_PER_SLOT))\n+        .minus(ETH1_FOLLOW_DISTANCE.times(SECONDS_PER_ETH1_BLOCK).times(UnsignedLong.valueOf(2)));\n+  }\n+\n+  static UnsignedLong getCacheRangeUpperBound() {\n+    UnsignedLong current_time = UnsignedLong.valueOf(Instant.now().getEpochSecond());", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIxODEzNw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371218137", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-27T12:40:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNDcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex 44d0f4e92..a8e120ba1 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -23,7 +23,6 @@ import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_P\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n-import java.time.Instant;\n import java.util.Date;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370835233", "bodyText": "This will catch all events posted, not just CacheEth1BlockEvent instances because ArgumentCaptor doesn't actually do type checks.", "author": "ajsutton", "createdAt": "2020-01-24T20:47:54Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private Eth1DataManager eth1DataManager;\n+  private Web3j web3j;\n+  private DepositContractListener depositContractListener;\n+\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+\n+  private final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+  private final UnsignedLong LATEST_BLOCK_TIMESTAMP =\n+      UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+  private final UnsignedLong INCONSEQUENTIAL_BLOCK_NUMBER = UnsignedLong.valueOf(100000);\n+  private final Request mockLatestBlockRequest =\n+      mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, LATEST_BLOCK_TIMESTAMP);\n+\n+  @BeforeEach\n+  void setUp() {\n+    web3j = mock(Web3j.class);\n+    depositContractListener = mock(DepositContractListener.class);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    UnsignedLong midRangeTimestamp =\n+        Eth1DataManager.getCacheRangeUpperBound().minus(UnsignedLong.ONE);\n+\n+    UnsignedLong firstUpwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.plus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondUpwardNumber = firstUpwardNumber.plus(UnsignedLong.ONE);\n+    UnsignedLong secondUpwardTimestamp = UnsignedLong.MAX_VALUE;\n+\n+    UnsignedLong firstDownwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.minus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondDownwardNumber = firstDownwardNumber.minus(UnsignedLong.ONE);\n+    UnsignedLong secondDownwardTimestamp = UnsignedLong.ONE;\n+\n+    Request midRangeBlockRequest =\n+        mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, midRangeTimestamp);\n+    Request firstUpwardBlockRequest = mockBlockRequest(firstUpwardNumber, midRangeTimestamp);\n+    Request secondUpwardBlockRequest = mockBlockRequest(secondUpwardNumber, secondUpwardTimestamp);\n+    Request firstDownwardBlockRequest = mockBlockRequest(firstDownwardNumber, midRangeTimestamp);\n+    Request secondDownwardBlockRequest =\n+        mockBlockRequest(secondDownwardNumber, secondDownwardTimestamp);\n+\n+    when(web3j.ethGetBlockByNumber(any(), eq(false)))\n+        .thenReturn(mockLatestBlockRequest)\n+        .thenReturn(midRangeBlockRequest)\n+        .thenReturn(firstUpwardBlockRequest)\n+        .thenReturn(secondUpwardBlockRequest)\n+        .thenReturn(firstDownwardBlockRequest)\n+        .thenReturn(secondDownwardBlockRequest);\n+\n+    eth1DataManager = new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner);\n+\n+    ArgumentCaptor<CacheEth1BlockEvent> eventArgumentCaptor =\n+        ArgumentCaptor.forClass(CacheEth1BlockEvent.class);\n+    verify(eventBus, times(5)).post(eventArgumentCaptor.capture());", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTMyOTY3Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371329677", "bodyText": "To account for this I'm doing this now:\n List<CacheEth1BlockEvent> eth1BlockEvents = eventArgumentCaptor.getAllValues().stream().filter(event -> event.getClass().equals(CacheEth1BlockEvent.class)).collect(Collectors.toList());", "author": "cemozerr", "createdAt": "2020-01-27T16:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ1NzYxMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371457613", "bodyText": "But the filtered events will still count as one of the 5 calls that times(5) requires, causing the test to fail because of too many invocations.", "author": "ajsutton", "createdAt": "2020-01-27T20:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU2MDMyOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371560328", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T00:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzNTIzMw=="}], "type": "inlineReview", "revised_code": {"commit": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 0e22b5de7..58e643e05 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -17,13 +17,17 @@ import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n \n import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n+import java.util.Date;\n import java.util.concurrent.CompletableFuture;\n import java.util.stream.Collectors;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzODkwNQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370838905", "bodyText": "I'd remove this call from the constructor and make runCacheStartup() a public start method.  Probably register with the eventBus in that method too rather than the constructor.\nIt will make the tests a lot clearer - right now they look like they are creating Eth1DataManager but never using it.  And generally it's good policy for constructors to not do any work so you have a separation of concerns between creating objects and actually starting work.", "author": "ajsutton", "createdAt": "2020-01-24T20:58:04Z", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+/*\n+\n+Eth1Data management strays from the spec to enable a cache for quick access to\n+Eth1Data without having spiky batches of requests. Below is the definition of how we\n+define such a robust cache that is the superset of the range defined by the spec.\n+\n+Definitions:\n+  t: current time\n+  Request Buffer: the time it will take for potential eth1 data request to complete\n+\n+Constants:\n+  Eth1 Follow Distance Time = Seconds Per Eth1 Block * Eth1 Follow Distance\n+  Slots Per Eth1 Voting Period Time = Seconds Per Slot * Slots Per Eth1 Voting Period\n+\n+cache range =\n+((t - (Slots Per Eth1 Voting Period Time) - (Eth1 Follow Distance Time * 2),\n+(t - (Eth1 Follow Distance Time) + Request Buffer))\n+\n+At startup: (implemented in this class)\n+  - Find the cache range\n+  - Search Eth1 blocks to find blocks in the cache range (pseudo-code defined below)\n+\n+On every Slot Event: (implemented in this class)\n+  - Get the latest block number you have\n+  - Calculate upper bound, i.e.  (t - (Eth1 Follow Distance Time) + Request Buffer))\n+  - Request blocks from i = 0 to  i = to infinity, until latest block number + i\u2019s timestamp\n+  is greater than the upper bound\n+\n+On every VotingPeriodStart change: (implemented in Eth1DataCache)\n+  - Prune anything that is before than:\n+  ((t - (Slots Per Eth1 Voting Period Time - One Slot Time) - (Eth1 Follow Distance Time * 2)\n+\n+Search Eth1 Blocks to find blocks in the cache range:\n+  1) Get the latest block\u2019s time stamp and block number\n+  2) rcr_average = ((rcr_lower_bound + rcr_upper_bound) / 2)\n+  3) time_diff = latest_block_timestamp - rcr_average\n+  4) seconds_per_eth1_block = SECONDS_PER_ETH1_BLOCK\n+  5) block_number_diff = time_diff / seconds_per_eth1_block\n+  6) block_number = latest_block_number - block_number_diff\n+  7) block_timestamp = getEthBlock(block_number).timestamp\n+  8) if isTimestampInRCR(block_timestamp):\n+      - go in both directions until you\u2019re not in the range\n+      - post each block to event bus\n+     else:\n+      - actual_time_diff = latest_block_timestamp - block_timestamp\n+      - seconds_per_eth1_block = block_number_diff / actual_time_diff\n+      - go back to step 5\n+\n+ */\n+\n+public class Eth1DataManager {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Web3j web3j;\n+  private final DepositContractListener depositContractListener;\n+  private final EventBus eventBus;\n+  private final AsyncRunner asyncRunner;\n+\n+  private AtomicReference<EthBlock.Block> latestBlockReference = new AtomicReference<>();\n+  private AtomicInteger cacheStartupRetry = new AtomicInteger(0);\n+  private AtomicBoolean cacheStartupDone = new AtomicBoolean(false);\n+\n+  public Eth1DataManager(\n+      Web3j web3j,\n+      EventBus eventBus,\n+      DepositContractListener depositContractListener,\n+      AsyncRunner asyncRunner) {\n+    this.web3j = web3j;\n+    this.eventBus = eventBus;\n+    this.depositContractListener = depositContractListener;\n+    this.asyncRunner = asyncRunner;\n+    eventBus.register(this);\n+\n+    runCacheStartup();", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg2MDU1Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370860556", "bodyText": "I'm happy to report that I made the exact change you suggested before seeing your comment. \ud83d\ude0e", "author": "cemozerr", "createdAt": "2020-01-24T21:57:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDgzODkwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "chunk": "diff --git a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\nindex 44d0f4e92..a8e120ba1 100644\n--- a/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n+++ b/pow/src/main/java/tech/pegasys/artemis/pow/Eth1DataManager.java\n\n@@ -23,7 +23,6 @@ import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_P\n import com.google.common.eventbus.EventBus;\n import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n-import java.time.Instant;\n import java.util.Date;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicBoolean;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NjUzOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r370856538", "bodyText": "I don't think this is giving us a very realistic set of results from web3j.  For example when we initially request the latest block, it returnsINCONSEQUENTIAL_BLOCK_NUMBER but then firstUpwardNumber is one block higher than that which it can't be because INCONSEQUENTIAL_BLOCK_NUMBER is the chain head.  Really INCONSEQUENTIAL_BLOCK_NUMBER should be LATEST_BLOCK_NUMBER and everything should be before that.\nAnd both INCONSEQUENTIAL_BLOKC_NUMBER and firstUpwardBlockRequest have the same timestamp which also can't happen.\nI suspect we need to do the math to work out what the blockchain actually needs to look like realistically. I'd say start the test with something like:\nfinal List<CacheEth1BlockEvent > blocks = Arrays.asList(\n mockBlock(10, <timestamp>),\n mockBlock(11, <timestamp>),\n .. for each block in the relevant range ..\n mockBlock(25, <timestamp>));\n\nThen you can setup the web3j mock to respond to any request by block number for those blocks specifically instead of using any() and just need to add in an expectation for getting the latest block which would return the last block in the list. And I would actually use plain numbers not constants for both block number and timestamps in that list for maximum readability.  You'll have to inject a Clock as I mentioned earlier so that you can have a fixed time rather than having to calculate things around Instant.now().\nDoing it this way means we have a very clear, readable list of the blocks involved in the chain we're trying to explore - easy to see that they're valid and work out why we're expecting what we are from the test.\nOne very useful trick you'll need to make this work instead of any() - DefaultBlockParameter doesn't provide useful equals methods so we need a custom argument matcher or mockito will never match the params.\nprivate DefaultBlockParameter blockParameterEq(final DefaultBlockParameter expected) {\n    return argThat(arg -> arg != null && arg.getValue().equals(expected.getValue()));\n  }\n\nwhich would be used like:\nwhen(web3j.ethGetBlockByNumber(blockParameterEq(blockParam), eq(false))).thenReturn(request);", "author": "ajsutton", "createdAt": "2020-01-24T21:45:51Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.utils.Numeric;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private Eth1DataManager eth1DataManager;\n+  private Web3j web3j;\n+  private DepositContractListener depositContractListener;\n+\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+\n+  private final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+  private final UnsignedLong LATEST_BLOCK_TIMESTAMP =\n+      UnsignedLong.valueOf(Instant.now().getEpochSecond());\n+  private final UnsignedLong INCONSEQUENTIAL_BLOCK_NUMBER = UnsignedLong.valueOf(100000);\n+  private final Request mockLatestBlockRequest =\n+      mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, LATEST_BLOCK_TIMESTAMP);\n+\n+  @BeforeEach\n+  void setUp() {\n+    web3j = mock(Web3j.class);\n+    depositContractListener = mock(DepositContractListener.class);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    UnsignedLong midRangeTimestamp =\n+        Eth1DataManager.getCacheRangeUpperBound().minus(UnsignedLong.ONE);\n+\n+    UnsignedLong firstUpwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.plus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondUpwardNumber = firstUpwardNumber.plus(UnsignedLong.ONE);\n+    UnsignedLong secondUpwardTimestamp = UnsignedLong.MAX_VALUE;\n+\n+    UnsignedLong firstDownwardNumber = INCONSEQUENTIAL_BLOCK_NUMBER.minus(UnsignedLong.ONE);\n+\n+    UnsignedLong secondDownwardNumber = firstDownwardNumber.minus(UnsignedLong.ONE);\n+    UnsignedLong secondDownwardTimestamp = UnsignedLong.ONE;\n+\n+    Request midRangeBlockRequest =\n+        mockBlockRequest(INCONSEQUENTIAL_BLOCK_NUMBER, midRangeTimestamp);\n+    Request firstUpwardBlockRequest = mockBlockRequest(firstUpwardNumber, midRangeTimestamp);\n+    Request secondUpwardBlockRequest = mockBlockRequest(secondUpwardNumber, secondUpwardTimestamp);\n+    Request firstDownwardBlockRequest = mockBlockRequest(firstDownwardNumber, midRangeTimestamp);\n+    Request secondDownwardBlockRequest =\n+        mockBlockRequest(secondDownwardNumber, secondDownwardTimestamp);\n+\n+    when(web3j.ethGetBlockByNumber(any(), eq(false)))\n+        .thenReturn(mockLatestBlockRequest)\n+        .thenReturn(midRangeBlockRequest)\n+        .thenReturn(firstUpwardBlockRequest)\n+        .thenReturn(secondUpwardBlockRequest)\n+        .thenReturn(firstDownwardBlockRequest)\n+        .thenReturn(secondDownwardBlockRequest);", "originalCommit": "7f5679eb5f19f5c476bc9bc536ebd76abd5391be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU1MDUxOA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371550518", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T00:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDg1NjUzOA=="}], "type": "inlineReview", "revised_code": {"commit": "ec2cd6af1454f5a27f6f11d1d10331e7e9c5417b", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 0e22b5de7..58e643e05 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -17,13 +17,17 @@ import static org.assertj.core.api.Assertions.assertThat;\n import static org.mockito.ArgumentMatchers.any;\n import static org.mockito.ArgumentMatchers.eq;\n import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.times;\n import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n \n import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.time.Instant;\n+import java.util.Date;\n import java.util.concurrent.CompletableFuture;\n import java.util.stream.Collectors;\n import org.apache.tuweni.bytes.Bytes32;\n"}}, {"oid": "f86d118c52d49bed0f865034d81a8dd83e312d4d", "url": "https://github.com/ConsenSys/teku/commit/f86d118c52d49bed0f865034d81a8dd83e312d4d", "message": "Refactor tests to make them more legible", "committedDate": "2020-01-27T22:17:42Z", "type": "commit"}, {"oid": "4a1f6beca715d582ff9f02ce5f538e9e0d16f020", "url": "https://github.com/ConsenSys/teku/commit/4a1f6beca715d582ff9f02ce5f538e9e0d16f020", "message": "Fix bug", "committedDate": "2020-01-27T22:28:21Z", "type": "commit"}, {"oid": "893e1cee34ee0c3ee5d5b6ee03ffe4a6c7af07a6", "url": "https://github.com/ConsenSys/teku/commit/893e1cee34ee0c3ee5d5b6ee03ffe4a6c7af07a6", "message": "Refactor the time dependency out of the Eth1Data cache tests", "committedDate": "2020-01-28T00:03:32Z", "type": "commit"}, {"oid": "2acf153ebeb06683fa84a0b453e5d4f116a4d9bb", "url": "https://github.com/ConsenSys/teku/commit/2acf153ebeb06683fa84a0b453e5d4f116a4d9bb", "message": "Use static class to capture specific events", "committedDate": "2020-01-28T00:43:08Z", "type": "commit"}, {"oid": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "url": "https://github.com/ConsenSys/teku/commit/6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-28T00:43:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTU3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371591574", "bodyText": "I'd use a stub here for simplicity rather than a mock.  If this was the only place we were likely to need it, a mock would be fine but we're going to mock TimeProvider a lot so it makes sense to introduce a stub for it in test-support.  Something like:\npublic class StubTimeProvider extends TimeProvider {\n  private UnsignedLong timeInSeconds;\n\n  public StubTimeProvider() {\n    this(UnsignedLong.valueOf(29842948));\n  }\n\n  public StubTimeProvider(final long timeInSeconds) {\n    this(UnsignedLong.valueOf(timeInSeconds));\n  }\n\n  public StubTimeProvider(final UnsignedLong timeInSeconds) {\n    this.timeInSeconds = timeInSeconds;\n  }\n\n  public void advanceTimeBySeconds(final long seconds) {\n    this.timeInSeconds = timeInSeconds.plus(UnsignedLong.valueOf(seconds));\n  }\n\n  @Override\n  public UnsignedLong getTimeInSeconds() {\n    return timeInSeconds;\n  }\n}", "author": "ajsutton", "createdAt": "2020-01-28T03:10:19Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxMTI3Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371911272", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 14c34630f..6b0c92c24 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -52,12 +52,11 @@ import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n-import tech.pegasys.artemis.util.time.TimeProvider;\n+import tech.pegasys.artemis.util.time.StubTimeProvider;\n \n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class Eth1DataManagerTest {\n \n-  private final TimeProvider timeProvider = mock(TimeProvider.class);\n   private final Web3j web3j = mock(Web3j.class);\n   private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n   private final DepositContractListener depositContractListener =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTgwMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371591800", "bodyText": "I don't think you need this filter now.", "author": "ajsutton", "createdAt": "2020-01-28T03:11:37Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);\n+  private final Web3j web3j = mock(Web3j.class);\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+  private final DepositContractListener depositContractListener =\n+      mock(DepositContractListener.class);\n+\n+  private EventBus eventBus;\n+  private Eth1DataManager eth1DataManager;\n+  private EventCapture eventCapture;\n+\n+  private static final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+\n+  static {\n+    ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(4);\n+    SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(6);\n+    ETH1_REQUEST_BUFFER = UnsignedLong.valueOf(1);\n+    SLOTS_PER_ETH1_VOTING_PERIOD = 5;\n+    SECONDS_PER_SLOT = 2;\n+  }\n+\n+  private final UnsignedLong testStartTime = UnsignedLong.valueOf(200);\n+\n+  // Cache Range:\n+  //    Lower Bound = 200 - (5 * 2) - (4 * 6 * 2) = 142\n+  //    Upper Bound = 200 - (4 * 6) + 1 = 177\n+  //    Mid-Range =  (142 + 177) / 2 = 160 (given that we use Half Up rounding (i.e. normal math\n+  // rounding))\n+  //\n+  // Number of blocks to middle\n+  //    = (current-time - mid-range) / (seconds_per_eth1_block)\n+  //    = (200 - 160) / (6)\n+  //    = 7 (here we use\n+  //    i.e. Teku will assume the middle-range block has block number current head - 7\n+\n+  @BeforeEach\n+  void setUp() {\n+    eventBus = new EventBus();\n+    eventCapture = new EventCapture(eventBus);\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+  }\n+\n+  @Test\n+  void checkTimeValues() {\n+    assertThat(eth1DataManager.getCacheRangeLowerBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(142));\n+    assertThat(eth1DataManager.getCacheRangeUpperBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(177));\n+    assertThat(Eth1DataManager.getCacheMidRangeTimestamp(timeProvider.getTimeInSeconds()))\n+        .isEqualByComparingTo(UnsignedLong.valueOf(160));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            new MockBlock(19, 186));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(8);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps)\n+        .containsExactlyInAnyOrder(138, 144, 150, 156, 162, 168, 174, 180);\n+  }\n+\n+  @Test\n+  void cacheStartup_recalculateSecondsToFindMidRangeBlock() {\n+    // There is ice-age! Average block times are at about 20 seconds! What does Teku do? FUNCTION.\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(15, 78),\n+            new MockBlock(16, 98),\n+            new MockBlock(17, 118),\n+            new MockBlock(18, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(19, 158),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(20, 178));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(3);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxMjYyMw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371912623", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MTgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 14c34630f..6b0c92c24 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -52,12 +52,11 @@ import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n-import tech.pegasys.artemis.util.time.TimeProvider;\n+import tech.pegasys.artemis.util.time.StubTimeProvider;\n \n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class Eth1DataManagerTest {\n \n-  private final TimeProvider timeProvider = mock(TimeProvider.class);\n   private final Web3j web3j = mock(Web3j.class);\n   private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n   private final DepositContractListener depositContractListener =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjM5Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371592396", "bodyText": "I'd avoid spies here and just assert that there's no registration on the event bus until start is called:\neventBus = mock(EventBus.class);\neth1DataManager = new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\nverifyZeroInteractions(eventBus);\n\nBoth approaches are a bit specific to the implementation but at least this one will catch all potential interactions, even if Eth1DataManager switches to to a different event type.", "author": "ajsutton", "createdAt": "2020-01-28T03:15:15Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);\n+  private final Web3j web3j = mock(Web3j.class);\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+  private final DepositContractListener depositContractListener =\n+      mock(DepositContractListener.class);\n+\n+  private EventBus eventBus;\n+  private Eth1DataManager eth1DataManager;\n+  private EventCapture eventCapture;\n+\n+  private static final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+\n+  static {\n+    ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(4);\n+    SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(6);\n+    ETH1_REQUEST_BUFFER = UnsignedLong.valueOf(1);\n+    SLOTS_PER_ETH1_VOTING_PERIOD = 5;\n+    SECONDS_PER_SLOT = 2;\n+  }\n+\n+  private final UnsignedLong testStartTime = UnsignedLong.valueOf(200);\n+\n+  // Cache Range:\n+  //    Lower Bound = 200 - (5 * 2) - (4 * 6 * 2) = 142\n+  //    Upper Bound = 200 - (4 * 6) + 1 = 177\n+  //    Mid-Range =  (142 + 177) / 2 = 160 (given that we use Half Up rounding (i.e. normal math\n+  // rounding))\n+  //\n+  // Number of blocks to middle\n+  //    = (current-time - mid-range) / (seconds_per_eth1_block)\n+  //    = (200 - 160) / (6)\n+  //    = 7 (here we use\n+  //    i.e. Teku will assume the middle-range block has block number current head - 7\n+\n+  @BeforeEach\n+  void setUp() {\n+    eventBus = new EventBus();\n+    eventCapture = new EventCapture(eventBus);\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+  }\n+\n+  @Test\n+  void checkTimeValues() {\n+    assertThat(eth1DataManager.getCacheRangeLowerBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(142));\n+    assertThat(eth1DataManager.getCacheRangeUpperBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(177));\n+    assertThat(Eth1DataManager.getCacheMidRangeTimestamp(timeProvider.getTimeInSeconds()))\n+        .isEqualByComparingTo(UnsignedLong.valueOf(160));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            new MockBlock(19, 186));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(8);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps)\n+        .containsExactlyInAnyOrder(138, 144, 150, 156, 162, 168, 174, 180);\n+  }\n+\n+  @Test\n+  void cacheStartup_recalculateSecondsToFindMidRangeBlock() {\n+    // There is ice-age! Average block times are at about 20 seconds! What does Teku do? FUNCTION.\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(15, 78),\n+            new MockBlock(16, 98),\n+            new MockBlock(17, 118),\n+            new MockBlock(18, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(19, 158),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(20, 178));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(3);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps).containsExactlyInAnyOrder(158, 138, 178);\n+  }\n+\n+  @Test\n+  void cacheStartup_retryStartup() {\n+    Request mockRequest = mockFailedRequest();\n+    when(web3j.ethGetBlockByNumber(any(), eq(false))).thenReturn(mockRequest);\n+\n+    eth1DataManager.start();\n+\n+    verify(web3j, times(Math.toIntExact(Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP)))\n+        .ethGetBlockByNumber(any(), eq(false));\n+  }\n+\n+  @Test\n+  void onTick_startupNotDone() {\n+    eventBus = spy(new EventBus());\n+    eth1DataManager =\n+        spy(\n+            new Eth1DataManager(\n+                web3j, eventBus, depositContractListener, asyncRunner, timeProvider));\n+    eventBus.post(new Date());\n+    verifyNoInteractions(eth1DataManager);", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNDA4Ng==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371914086", "bodyText": "Makes sense. Tests are less brittle that way. Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjM5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 14c34630f..6b0c92c24 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -52,12 +52,11 @@ import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n-import tech.pegasys.artemis.util.time.TimeProvider;\n+import tech.pegasys.artemis.util.time.StubTimeProvider;\n \n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class Eth1DataManagerTest {\n \n-  private final TimeProvider timeProvider = mock(TimeProvider.class);\n   private final Web3j web3j = mock(Web3j.class);\n   private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n   private final DepositContractListener depositContractListener =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjYwOQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371592609", "bodyText": "With the stub this would just become timeProvider.advanceTimeBySeconds(4).", "author": "ajsutton", "createdAt": "2020-01-28T03:16:23Z", "path": "pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.argThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_REQUEST_BUFFER;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.SLOTS_PER_ETH1_VOTING_PERIOD;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.web3j.protocol.Web3j;\n+import org.web3j.protocol.core.DefaultBlockParameter;\n+import org.web3j.protocol.core.DefaultBlockParameterName;\n+import org.web3j.protocol.core.Request;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.event.CacheEth1BlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.util.time.TimeProvider;\n+\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+public class Eth1DataManagerTest {\n+\n+  private final TimeProvider timeProvider = mock(TimeProvider.class);\n+  private final Web3j web3j = mock(Web3j.class);\n+  private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n+  private final DepositContractListener depositContractListener =\n+      mock(DepositContractListener.class);\n+\n+  private EventBus eventBus;\n+  private Eth1DataManager eth1DataManager;\n+  private EventCapture eventCapture;\n+\n+  private static final Bytes32 HEX_STRING = Bytes32.fromHexString(\"0xdeadbeef\");\n+\n+  static {\n+    ETH1_FOLLOW_DISTANCE = UnsignedLong.valueOf(4);\n+    SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(6);\n+    ETH1_REQUEST_BUFFER = UnsignedLong.valueOf(1);\n+    SLOTS_PER_ETH1_VOTING_PERIOD = 5;\n+    SECONDS_PER_SLOT = 2;\n+  }\n+\n+  private final UnsignedLong testStartTime = UnsignedLong.valueOf(200);\n+\n+  // Cache Range:\n+  //    Lower Bound = 200 - (5 * 2) - (4 * 6 * 2) = 142\n+  //    Upper Bound = 200 - (4 * 6) + 1 = 177\n+  //    Mid-Range =  (142 + 177) / 2 = 160 (given that we use Half Up rounding (i.e. normal math\n+  // rounding))\n+  //\n+  // Number of blocks to middle\n+  //    = (current-time - mid-range) / (seconds_per_eth1_block)\n+  //    = (200 - 160) / (6)\n+  //    = 7 (here we use\n+  //    i.e. Teku will assume the middle-range block has block number current head - 7\n+\n+  @BeforeEach\n+  void setUp() {\n+    eventBus = new EventBus();\n+    eventCapture = new EventCapture(eventBus);\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime);\n+    when(depositContractListener.getDepositCount(any()))\n+        .thenReturn(SafeFuture.completedFuture(UnsignedLong.valueOf(1234)));\n+    when(depositContractListener.getDepositRoot(any()))\n+        .thenReturn(SafeFuture.completedFuture(HEX_STRING));\n+\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+  }\n+\n+  @Test\n+  void checkTimeValues() {\n+    assertThat(eth1DataManager.getCacheRangeLowerBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(142));\n+    assertThat(eth1DataManager.getCacheRangeUpperBound())\n+        .isEqualByComparingTo(UnsignedLong.valueOf(177));\n+    assertThat(Eth1DataManager.getCacheMidRangeTimestamp(timeProvider.getTimeInSeconds()))\n+        .isEqualByComparingTo(UnsignedLong.valueOf(160));\n+  }\n+\n+  @Test\n+  void cacheStartup_blockActuallyInMidRange() {\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            new MockBlock(19, 186));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(8);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps)\n+        .containsExactlyInAnyOrder(138, 144, 150, 156, 162, 168, 174, 180);\n+  }\n+\n+  @Test\n+  void cacheStartup_recalculateSecondsToFindMidRangeBlock() {\n+    // There is ice-age! Average block times are at about 20 seconds! What does Teku do? FUNCTION.\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(15, 78),\n+            new MockBlock(16, 98),\n+            new MockBlock(17, 118),\n+            new MockBlock(18, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(19, 158),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(20, 178));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    assertThat(eventCapture.getEth1BlockEvents().size()).isEqualTo(3);\n+\n+    List<Integer> eth1BlockTimestamps =\n+        eventCapture.getEth1BlockEvents().stream()\n+            .filter(event -> event.getClass().equals(CacheEth1BlockEvent.class))\n+            .map(CacheEth1BlockEvent::getBlockTimestamp)\n+            .map(UnsignedLong::intValue)\n+            .collect(Collectors.toList());\n+\n+    assertThat(eth1BlockTimestamps).containsExactlyInAnyOrder(158, 138, 178);\n+  }\n+\n+  @Test\n+  void cacheStartup_retryStartup() {\n+    Request mockRequest = mockFailedRequest();\n+    when(web3j.ethGetBlockByNumber(any(), eq(false))).thenReturn(mockRequest);\n+\n+    eth1DataManager.start();\n+\n+    verify(web3j, times(Math.toIntExact(Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP)))\n+        .ethGetBlockByNumber(any(), eq(false));\n+  }\n+\n+  @Test\n+  void onTick_startupNotDone() {\n+    eventBus = spy(new EventBus());\n+    eth1DataManager =\n+        spy(\n+            new Eth1DataManager(\n+                web3j, eventBus, depositContractListener, asyncRunner, timeProvider));\n+    eventBus.post(new Date());\n+    verifyNoInteractions(eth1DataManager);\n+  }\n+\n+  @Test\n+  void onTick_startupDoneGetNewBlocks() {\n+    eth1DataManager =\n+        new Eth1DataManager(web3j, eventBus, depositContractListener, asyncRunner, timeProvider);\n+\n+    List<MockBlock> eth1Blocks =\n+        Arrays.asList(\n+            new MockBlock(10, 132),\n+            new MockBlock(11, 138),\n+            // Cache Range Lower Bound: 142\n+            new MockBlock(12, 144),\n+            new MockBlock(13, 150),\n+            new MockBlock(14, 156),\n+            new MockBlock(15, 162),\n+            new MockBlock(16, 168),\n+            new MockBlock(17, 174),\n+            // Cache Range Upper Bound: 177\n+            new MockBlock(18, 180),\n+            // Cache Range Updated Upper Bound: 181\n+            new MockBlock(19, 186),\n+            new MockBlock(20, 192));\n+\n+    MockBlock latestBlockRequest = new MockBlock(21, 198);\n+\n+    setupWeb3jMockedBlockResponses(eth1Blocks, latestBlockRequest);\n+\n+    eth1DataManager.start();\n+\n+    when(timeProvider.getTimeInSeconds()).thenReturn(testStartTime.plus(UnsignedLong.valueOf(4)));", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNDk4NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371914984", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MjYwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "chunk": "diff --git a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\nindex 14c34630f..6b0c92c24 100644\n--- a/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n+++ b/pow/src/test/java/tech/pegasys/artemis/pow/Eth1DataManagerTest.java\n\n@@ -52,12 +52,11 @@ import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.AsyncRunnerTest;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n-import tech.pegasys.artemis.util.time.TimeProvider;\n+import tech.pegasys.artemis.util.time.StubTimeProvider;\n \n @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n public class Eth1DataManagerTest {\n \n-  private final TimeProvider timeProvider = mock(TimeProvider.class);\n   private final Web3j web3j = mock(Web3j.class);\n   private final AsyncRunner asyncRunner = new AsyncRunnerTest();\n   private final DepositContractListener depositContractListener =\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzQ1Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371593457", "bodyText": "I'd call this DelayedExecutorAsyncRunner - the name relates to what makes it's implementation special (e.g. ArrayList because it uses an array backing).", "author": "ajsutton", "createdAt": "2020-01-28T03:21:07Z", "path": "util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerProd implements AsyncRunner {", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNTM2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371915361", "bodyText": "That makes sense to me. Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:32:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "chunk": "diff --git a/util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java b/util/src/main/java/tech/pegasys/artemis/util/async/DelayedExecutorAsyncRunner.java\nsimilarity index 94%\nrename from util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java\nrename to util/src/main/java/tech/pegasys/artemis/util/async/DelayedExecutorAsyncRunner.java\nindex a351f3ab3..98f8f5672 100644\n--- a/util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java\n+++ b/util/src/main/java/tech/pegasys/artemis/util/async/DelayedExecutorAsyncRunner.java\n\n@@ -20,9 +20,7 @@ import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n \n-public class AsyncRunnerProd implements AsyncRunner {\n-\n-  public AsyncRunnerProd() {}\n+public class DelayedExecutorAsyncRunner implements AsyncRunner {\n \n   @Override\n   public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action, final Executor executor) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzY3NA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371593674", "bodyText": "I would have thought this would be StubAsyncRunner and it would still delay running the provided action, but would do so until the test called an extra method to execute.  So an implementation like:\npublic class StubAsyncRunner implements AsyncRunner {\n  private List<Runnable> queuedActions = new ArrayList<>();\n\n  @Override\n  public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action, final Executor executor) {\n    final SafeFuture<U> result = new SafeFuture<>();\n    queuedActions.add(\n        () -> {\n          try {\n            propagateResult(action.get(), result);\n          } catch (final Throwable t) {\n            result.completeExceptionally(t);\n          }\n        });\n    return result;\n  }\n\n  @Override\n  public <U> SafeFuture<U> runAfterDelay(\n      Supplier<SafeFuture<U>> action, long delayAmount, TimeUnit delayUnit) {\n    return runAsync(action, null); // Executor is ignored anyway.\n  }\n\n  public void executeQueuedActions() {\n    final List<Runnable> actionsToExecute = queuedActions;\n    queuedActions = new ArrayList<>();\n    actionsToExecute.forEach(Runnable::run);\n  }\n\n  public boolean hasDelayedActions() {\n    return !queuedActions.isEmpty();\n  }\n}\n\nand then Eth1DataManager.catchStartup_retryStartup becomes:\n  @Test\n  void cacheStartup_retryStartup() {\n    Request mockRequest = mockFailedRequest();\n    when(web3j.ethGetBlockByNumber(any(), eq(false))).thenReturn(mockRequest);\n\n    eth1DataManager.start();\n\n    verify(web3j).ethGetBlockByNumber(any(), eq(false)); // First failed attempt\n\n    for (int i = 2; i <= Constants.ETH1_CACHE_STARTUP_RETRY_GIVEUP; i++) {\n      asyncRunner.executeQueuedActions();\n      verify(web3j, times(i)).ethGetBlockByNumber(any(), eq(false));\n    }\n\n    assertThat(asyncRunner.hasDelayedActions()).isFalse();\n  }\n\nThe main reason for this is that it preserves the important property that AsyncRunner doesn't execute the action immediately which we want to test.", "author": "ajsutton", "createdAt": "2020-01-28T03:22:27Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerTest implements AsyncRunner {", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkyNTE0Mg==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371925142", "bodyText": "Makes sense. Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5MzY3NA=="}], "type": "inlineReview", "revised_code": {"commit": "51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "chunk": "diff --git a/util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java b/util/src/test-support/java/tech/pegasys/artemis/util/async/StubAsyncRunner.java\nsimilarity index 58%\nrename from util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java\nrename to util/src/test-support/java/tech/pegasys/artemis/util/async/StubAsyncRunner.java\nindex f800d7fba..03272555b 100644\n--- a/util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java\n+++ b/util/src/test-support/java/tech/pegasys/artemis/util/async/StubAsyncRunner.java\n\n@@ -15,30 +15,42 @@ package tech.pegasys.artemis.util.async;\n \n import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n \n-import java.util.concurrent.CompletableFuture;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n \n-public class AsyncRunnerTest implements AsyncRunner {\n-\n-  public AsyncRunnerTest() {}\n+public class StubAsyncRunner implements AsyncRunner {\n+  private List<Runnable> queuedActions = new ArrayList<>();\n \n   @Override\n   public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action, final Executor executor) {\n     final SafeFuture<U> result = new SafeFuture<>();\n-    try {\n-      propagateResult(action.get(), result);\n-    } catch (final Throwable t) {\n-      result.completeExceptionally(t);\n-    }\n+    queuedActions.add(\n+            () -> {\n+              try {\n+                propagateResult(action.get(), result);\n+              } catch (final Throwable t) {\n+                result.completeExceptionally(t);\n+              }\n+            });\n     return result;\n   }\n \n   @Override\n   public <U> SafeFuture<U> runAfterDelay(\n-      Supplier<SafeFuture<U>> action, long delayAmount, TimeUnit delayUnit) {\n-    Executor delayed = CompletableFuture.delayedExecutor(delayAmount, delayUnit);\n-    return runAsync(action, delayed);\n+          Supplier<SafeFuture<U>> action, long delayAmount, TimeUnit delayUnit) {\n+    return runAsync(action, null); // Executor is ignored anyway.\n+  }\n+\n+  public void executeQueuedActions() {\n+    final List<Runnable> actionsToExecute = queuedActions;\n+    queuedActions = new ArrayList<>();\n+    actionsToExecute.forEach(Runnable::run);\n+  }\n+\n+  public boolean hasDelayedActions() {\n+    return !queuedActions.isEmpty();\n   }\n-}\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDEyMA==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371594120", "bodyText": "A no-arg constructor is provided by default so this can be omitted.", "author": "ajsutton", "createdAt": "2020-01-28T03:25:12Z", "path": "util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerTest implements AsyncRunner {\n+\n+  public AsyncRunnerTest() {}", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNjI5Nw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371916297", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "chunk": "diff --git a/util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java b/util/src/test-support/java/tech/pegasys/artemis/util/async/StubAsyncRunner.java\nsimilarity index 58%\nrename from util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java\nrename to util/src/test-support/java/tech/pegasys/artemis/util/async/StubAsyncRunner.java\nindex f800d7fba..03272555b 100644\n--- a/util/src/test-support/java/tech/pegasys/artemis/util/async/AsyncRunnerTest.java\n+++ b/util/src/test-support/java/tech/pegasys/artemis/util/async/StubAsyncRunner.java\n\n@@ -15,30 +15,42 @@ package tech.pegasys.artemis.util.async;\n \n import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n \n-import java.util.concurrent.CompletableFuture;\n+import java.util.ArrayList;\n+import java.util.List;\n import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n \n-public class AsyncRunnerTest implements AsyncRunner {\n-\n-  public AsyncRunnerTest() {}\n+public class StubAsyncRunner implements AsyncRunner {\n+  private List<Runnable> queuedActions = new ArrayList<>();\n \n   @Override\n   public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action, final Executor executor) {\n     final SafeFuture<U> result = new SafeFuture<>();\n-    try {\n-      propagateResult(action.get(), result);\n-    } catch (final Throwable t) {\n-      result.completeExceptionally(t);\n-    }\n+    queuedActions.add(\n+            () -> {\n+              try {\n+                propagateResult(action.get(), result);\n+              } catch (final Throwable t) {\n+                result.completeExceptionally(t);\n+              }\n+            });\n     return result;\n   }\n \n   @Override\n   public <U> SafeFuture<U> runAfterDelay(\n-      Supplier<SafeFuture<U>> action, long delayAmount, TimeUnit delayUnit) {\n-    Executor delayed = CompletableFuture.delayedExecutor(delayAmount, delayUnit);\n-    return runAsync(action, delayed);\n+          Supplier<SafeFuture<U>> action, long delayAmount, TimeUnit delayUnit) {\n+    return runAsync(action, null); // Executor is ignored anyway.\n+  }\n+\n+  public void executeQueuedActions() {\n+    final List<Runnable> actionsToExecute = queuedActions;\n+    queuedActions = new ArrayList<>();\n+    actionsToExecute.forEach(Runnable::run);\n+  }\n+\n+  public boolean hasDelayedActions() {\n+    return !queuedActions.isEmpty();\n   }\n-}\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDE0Mw==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371594143", "bodyText": "A no-arg constructor is provided by default so this can be omitted.", "author": "ajsutton", "createdAt": "2020-01-28T03:25:21Z", "path": "util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.async;\n+\n+import static tech.pegasys.artemis.util.async.SafeFuture.propagateResult;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+\n+public class AsyncRunnerProd implements AsyncRunner {\n+\n+  public AsyncRunnerProd() {}", "originalCommit": "6047f7bb33ea6eb5ab7b0411990d6a99a94b5007", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkxNjM1MQ==", "url": "https://github.com/ConsenSys/teku/pull/1083#discussion_r371916351", "bodyText": "Done.", "author": "cemozerr", "createdAt": "2020-01-28T16:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTU5NDE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "chunk": "diff --git a/util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java b/util/src/main/java/tech/pegasys/artemis/util/async/DelayedExecutorAsyncRunner.java\nsimilarity index 94%\nrename from util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java\nrename to util/src/main/java/tech/pegasys/artemis/util/async/DelayedExecutorAsyncRunner.java\nindex a351f3ab3..98f8f5672 100644\n--- a/util/src/main/java/tech/pegasys/artemis/util/async/AsyncRunnerProd.java\n+++ b/util/src/main/java/tech/pegasys/artemis/util/async/DelayedExecutorAsyncRunner.java\n\n@@ -20,9 +20,7 @@ import java.util.concurrent.Executor;\n import java.util.concurrent.TimeUnit;\n import java.util.function.Supplier;\n \n-public class AsyncRunnerProd implements AsyncRunner {\n-\n-  public AsyncRunnerProd() {}\n+public class DelayedExecutorAsyncRunner implements AsyncRunner {\n \n   @Override\n   public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action, final Executor executor) {\n"}}, {"oid": "6db516ae0dfd96e38505b1420b9a5d0021125176", "url": "https://github.com/ConsenSys/teku/commit/6db516ae0dfd96e38505b1420b9a5d0021125176", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-28T16:15:27Z", "type": "commit"}, {"oid": "5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "url": "https://github.com/ConsenSys/teku/commit/5a04c34deb5e0e3e5be0a7b4cfc9c9de54d6e292", "message": "Replace TimeProvider mocks with StubTimeProvider", "committedDate": "2020-01-28T16:26:44Z", "type": "commit"}, {"oid": "7f881ce904f9b4fc40b86ada51168682f1d00563", "url": "https://github.com/ConsenSys/teku/commit/7f881ce904f9b4fc40b86ada51168682f1d00563", "message": "Remove unnecessary filter", "committedDate": "2020-01-28T16:28:16Z", "type": "commit"}, {"oid": "c8f9b13570e759ec0075f324a9132ca528e638e8", "url": "https://github.com/ConsenSys/teku/commit/c8f9b13570e759ec0075f324a9132ca528e638e8", "message": "Make test more robust", "committedDate": "2020-01-28T16:31:06Z", "type": "commit"}, {"oid": "51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "url": "https://github.com/ConsenSys/teku/commit/51c122ac2060f70cb78d4c67c1f5eb876f2b66a8", "message": "Use eventSink and better test asyncRunner", "committedDate": "2020-01-28T16:54:06Z", "type": "commit"}, {"oid": "b81d84e28eefb82c8166c4925c78fb24229eb75b", "url": "https://github.com/ConsenSys/teku/commit/b81d84e28eefb82c8166c4925c78fb24229eb75b", "message": "Run spotless", "committedDate": "2020-01-28T16:55:19Z", "type": "commit"}, {"oid": "3dada667f085e40f47444349bdc138622c1d31a9", "url": "https://github.com/ConsenSys/teku/commit/3dada667f085e40f47444349bdc138622c1d31a9", "message": "Fix bug", "committedDate": "2020-01-28T17:10:08Z", "type": "commit"}, {"oid": "372d1f8830e1bf7f35630d5f8f42f3bbdf6aeb74", "url": "https://github.com/ConsenSys/teku/commit/372d1f8830e1bf7f35630d5f8f42f3bbdf6aeb74", "message": "Merge branch 'master' into implementEth1DataManager", "committedDate": "2020-01-28T21:46:48Z", "type": "commit"}, {"oid": "2c0b98832f6216306d55a290b92c1650ff1d037f", "url": "https://github.com/ConsenSys/teku/commit/2c0b98832f6216306d55a290b92c1650ff1d037f", "message": "Run spotless after merge", "committedDate": "2020-01-28T21:53:04Z", "type": "commit"}]}