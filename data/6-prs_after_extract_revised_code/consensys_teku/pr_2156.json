{"pr_number": 2156, "pr_title": "Retrieve block root at slot from protoarray to avoid regenerating states", "pr_createdAt": "2020-06-16T04:43:14Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2156", "timeline": [{"oid": "c0958cc4a915ee260bb5d741f699d6dca674deaf", "url": "https://github.com/ConsenSys/teku/commit/c0958cc4a915ee260bb5d741f699d6dca674deaf", "message": "Retrieve block root at slot from protoarray to avoid regenerating states.\nLimit the number of blocks included in BeaconBlocksByRange responses.", "committedDate": "2020-06-16T04:38:21Z", "type": "commit"}, {"oid": "bc801f3567dbe615da05df81708193548e26c44b", "url": "https://github.com/ConsenSys/teku/commit/bc801f3567dbe615da05df81708193548e26c44b", "message": "Fix integration tests.", "committedDate": "2020-06-16T05:02:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NTYyOA==", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r440865628", "bodyText": "nit: We could make the test more explicit by saying count = Constants.MAX_BLOCK_BY_RANGE_REQUEST_SIZE + 1", "author": "cemozerr", "createdAt": "2020-06-16T13:50:32Z", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java", "diffHunk": "@@ -269,6 +272,23 @@ public void shouldRejectRequestWhenStepIsZero() {\n     verifyNoMoreInteractions(combinedChainDataClient);\n   }\n \n+  @Test\n+  void shouldLimitNumberOfBlocksReturned() {\n+    final RequestState requestState =\n+        new RequestState(\n+            new BeaconBlocksByRangeRequestMessage(\n+                UnsignedLong.ZERO, UnsignedLong.valueOf(500), UnsignedLong.ONE),\n+            UnsignedLong.valueOf(10000),", "originalCommit": "bc801f3567dbe615da05df81708193548e26c44b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDMzMA==", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r441184330", "bodyText": "Done.", "author": "ajsutton", "createdAt": "2020-06-16T22:48:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NTYyOA=="}], "type": "inlineReview", "revised_code": {"commit": "c06bd4f05356485fa745b438bd13a56fdcafa5a9", "chunk": "diff --git a/networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java b/networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java\nindex 0eaf3a4341..a13b276960 100644\n--- a/networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java\n+++ b/networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java\n\n@@ -277,7 +277,9 @@ class BeaconBlocksByRangeMessageHandlerTest {\n     final RequestState requestState =\n         new RequestState(\n             new BeaconBlocksByRangeRequestMessage(\n-                UnsignedLong.ZERO, UnsignedLong.valueOf(500), UnsignedLong.ONE),\n+                UnsignedLong.ZERO,\n+                Constants.MAX_BLOCK_BY_RANGE_REQUEST_SIZE.plus(UnsignedLong.ONE),\n+                UnsignedLong.ONE),\n             UnsignedLong.valueOf(10000),\n             Bytes32.ZERO,\n             listener);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NzMwOA==", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r440867308", "bodyText": "Are we okay with not being able to get any block root before finalization?", "author": "cemozerr", "createdAt": "2020-06-16T13:52:40Z", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -304,87 +308,17 @@ public boolean containsBlock(final Bytes32 root) {\n     return Optional.ofNullable(store.getBlockState(blockRoot));\n   }\n \n-  public Optional<BeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n-    return getBlockRootBySlot(slot)\n-        .map(blockRoot -> store.getBlock(blockRoot))\n-        .filter(block -> block.getSlot().equals(slot));\n-  }\n-\n   public Optional<BeaconState> getStateInEffectAtSlot(final UnsignedLong slot) {\n     return getBlockRootBySlot(slot).map(blockRoot -> store.getBlockState(blockRoot));\n   }\n \n-  public boolean isIncludedInBestState(final Bytes32 blockRoot) {\n-    if (store == null) {\n-      return false;\n-    }\n-    final BeaconBlock block = store.getBlock(blockRoot);\n-    if (block == null) {\n-      return false;\n-    }\n-    return getBlockRootBySlot(block.getSlot())\n-        .map(actualRoot -> actualRoot.equals(block.hash_tree_root()))\n-        .orElse(false);\n-  }\n-\n   public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot) {\n-    if (store == null || chainHead.isEmpty() || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return getBlockRootBySlot(slot, chainHead.get());\n+    return chainHead.flatMap(head -> getBlockRootBySlot(slot, head.getRoot()));\n   }\n \n-  public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot, final Bytes32 headRoot) {\n-    if (store == null || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return store.getBlockAndState(headRoot).flatMap(head -> getBlockRootBySlot(slot, head));\n-  }\n-\n-  private boolean isHistoricalBlockRootAtSlotUnavailable(final UnsignedLong slot) {\n-    // If slot is prior to genesis, it is not available\n-    final UnsignedLong genesisSlot = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n-    if (slot.compareTo(genesisSlot) < 0) {\n-      return true;\n-    }\n-\n-    // If slot is out of range of the latest finalized block, it is unavailable\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    final UnsignedLong oldestAvailableState = store.getLatestFinalizedBlockSlot();\n-    final UnsignedLong oldestAvailableRoot =\n-        oldestAvailableState.compareTo(slotsPerHistoricalRoot) >= 0\n-            ? oldestAvailableState.minus(slotsPerHistoricalRoot)\n-            : UnsignedLong.ZERO;\n-    return slot.compareTo(oldestAvailableRoot) < 0;\n-  }\n-\n-  private Optional<Bytes32> getBlockRootBySlot(\n-      final UnsignedLong slot, final SignedBlockAndState headBlock) {\n-    checkNotNull(slot);\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    // Since older blocks are pruned - query the newest queryable slot where possible\n-    final UnsignedLong youngestQueryableSlot = slot.plus(slotsPerHistoricalRoot);\n-\n-    SignedBlockAndState currentBlock = headBlock;\n-    while (currentBlock != null) {\n-      if (currentBlock.getSlot().compareTo(slot) <= 0) {\n-        // The current block is less than or equal to the target slot, so it must be the block in\n-        // effect\n-        return Optional.of(currentBlock.getRoot());\n-      }\n-      if (BeaconStateUtil.isBlockRootAvailableFromState(currentBlock.getState(), slot)) {\n-        // The root is available from the current state\n-        return Optional.of(BeaconStateUtil.get_block_root_at_slot(currentBlock.getState(), slot));\n-      }\n-\n-      // Pull an older block to search\n-      final UnsignedLong oldestQueryableSlot = currentBlock.getSlot().minus(slotsPerHistoricalRoot);\n-      final UnsignedLong olderSlot = max(youngestQueryableSlot, oldestQueryableSlot);\n-      final Bytes32 olderRoot = get_block_root_at_slot(currentBlock.getState(), olderSlot);\n-      currentBlock = store.getBlockAndState(olderRoot).orElse(null);\n-    }\n-\n-    return Optional.empty();\n+  public Optional<Bytes32> getBlockRootBySlot(", "originalCommit": "bc801f3567dbe615da05df81708193548e26c44b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3MDEzOA==", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r440870138", "bodyText": "If we do want to use ProtoArray for collecting block roots pre-finalization, we could modify it in such a way that findHead (and thus computeDeltas) would not traverse through ProtoNodes pre-finalization, and stop at the finalization slot, but we'd still have access to information on nodes pre-finalization. This way ForkChoice could stay efficient.", "author": "cemozerr", "createdAt": "2020-06-16T13:56:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NzMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzQxNQ==", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r441183415", "bodyText": "There was always a limit to how far back we could go with RecentChainData anyway so I think it's fine if it cuts off at the finalised block.  We don't have the blocks or states before that anyway.", "author": "ajsutton", "createdAt": "2020-06-16T22:45:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NzMwOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "c06bd4f05356485fa745b438bd13a56fdcafa5a9", "url": "https://github.com/ConsenSys/teku/commit/c06bd4f05356485fa745b438bd13a56fdcafa5a9", "message": "Clearer test.", "committedDate": "2020-06-16T22:47:58Z", "type": "commit"}, {"oid": "5d5d9536079efb5380fef8fc2c5f6ad31e7ea3b1", "url": "https://github.com/ConsenSys/teku/commit/5d5d9536079efb5380fef8fc2c5f6ad31e7ea3b1", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into block-root-from-protoarray", "committedDate": "2020-06-16T22:48:05Z", "type": "commit"}]}