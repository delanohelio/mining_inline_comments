{"pr_number": 1592, "pr_title": "Delay performing duties until the epoch has been scheduled", "pr_createdAt": "2020-04-15T03:40:26Z", "pr_url": "https://github.com/ConsenSys/teku/pull/1592", "timeline": [{"oid": "d2a12c6779f177293fcff3a2038247a72e96a946", "url": "https://github.com/ConsenSys/teku/commit/d2a12c6779f177293fcff3a2038247a72e96a946", "message": "Delay performing duties until the epoch has been scheduled.", "committedDate": "2020-04-15T01:57:37Z", "type": "commit"}, {"oid": "e4623f808ddfee4f82f8e43df29d9b476e2f9bed", "url": "https://github.com/ConsenSys/teku/commit/e4623f808ddfee4f82f8e43df29d9b476e2f9bed", "message": "Ensure duties are still performed in the correct order.\nDon't schedule block production for the genesis slot.", "committedDate": "2020-04-15T03:29:34Z", "type": "commit"}, {"oid": "887d38099bb5e40d9c5172a70a7dcafdab2991d1", "url": "https://github.com/ConsenSys/teku/commit/887d38099bb5e40d9c5172a70a7dcafdab2991d1", "message": "Add comments and ensure the pending tasks are only removed once they have all completed.", "committedDate": "2020-04-15T03:55:09Z", "type": "commit"}, {"oid": "b4ee3cb8c37a7c5a18065cf6e89c1c8a4b887b6a", "url": "https://github.com/ConsenSys/teku/commit/b4ee3cb8c37a7c5a18065cf6e89c1c8a4b887b6a", "message": "More comments.", "committedDate": "2020-04-15T03:58:09Z", "type": "commit"}, {"oid": "84d2137460e33f834c5f1c7da5daf00ca00c55be", "url": "https://github.com/ConsenSys/teku/commit/84d2137460e33f834c5f1c7da5daf00ca00c55be", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into delay-duties", "committedDate": "2020-04-15T03:58:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNzg3OA==", "url": "https://github.com/ConsenSys/teku/pull/1592#discussion_r408907878", "bodyText": "This line assumes that this validator won't have any duties for this epoch, so it will need to remove the future above, right?", "author": "cemozerr", "createdAt": "2020-04-15T14:56:06Z", "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/DutyScheduler.java", "diffHunk": "@@ -69,13 +86,19 @@ public void onSlot(final UnsignedLong slotNumber) {\n           for (UnsignedLong currentEpoch = startEpoch;\n               currentEpoch.compareTo(endEpoch) <= 0;\n               currentEpoch = currentEpoch.plus(ONE)) {\n-            scheduleDutiesForEpoch(currentEpoch).reportExceptions();\n+            scheduleDutiesForEpoch(currentEpoch);\n           }\n           return startEpoch.compareTo(endEpoch) > 0 ? lastRequestedEpoch : endEpoch;\n         });\n   }\n \n-  private SafeFuture<Void> scheduleDutiesForEpoch(final UnsignedLong epoch) {\n+  private void scheduleDutiesForEpoch(final UnsignedLong epoch) {\n+    final SafeFuture<Void> future = requestAndScheduleDutiesForEpoch(epoch);\n+    pendingTasksByEpoch.put(epoch, future);\n+    removeWhenAllTasksComplete(epoch, future);", "originalCommit": "84d2137460e33f834c5f1c7da5daf00ca00c55be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5NjY2MQ==", "url": "https://github.com/ConsenSys/teku/pull/1592#discussion_r409096661", "bodyText": "removeWhenAllTasksComplete will only remove the entry if the key and value match.  So this is handling the normal case where we are scheduling duties ahead of time and it completes scheduling before those slots occur.  In that case when future completes it will still be the value in the map and so will be removed.  When the slots occur there's no entry in the map so they execute immediately.\nIf however while the request for duties is in-flight one of the slots for that epoch occurs, that slot will replace this future with the one for it's own task and this call to removeWhenAllTasksComplete will wind up doing nothing. Responsibility for cleaning up moves to the task that was scheduled by onSlot (and this process repeats for each scheduled task - it gets tacked onto the end and takes responsibility for removing things).\nWhich I think is a long winded way of saying yes. :)", "author": "ajsutton", "createdAt": "2020-04-15T19:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3NjQ4NQ==", "url": "https://github.com/ConsenSys/teku/pull/1592#discussion_r409176485", "bodyText": "Thanks for the detailed answer :)", "author": "cemozerr", "createdAt": "2020-04-15T22:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNzg3OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwODk3NA==", "url": "https://github.com/ConsenSys/teku/pull/1592#discussion_r408908974", "bodyText": "Isn't there any side effect of chaining multiple .always() to the same Future chain? So they don't get overwritten or anything?", "author": "cemozerr", "createdAt": "2020-04-15T14:57:30Z", "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/DutyScheduler.java", "diffHunk": "@@ -182,16 +205,43 @@ private void scheduleAggregation(\n \n   @Override\n   public void onBlockProductionDue(final UnsignedLong slot) {\n-    scheduledDuties.produceBlock(slot);\n+    whenDutiesScheduled(slot, scheduledDuties::produceBlock);\n   }\n \n   @Override\n   public void onAttestationCreationDue(final UnsignedLong slot) {\n-    scheduledDuties.produceAttestations(slot);\n+    whenDutiesScheduled(slot, scheduledDuties::produceAttestations);\n   }\n \n   @Override\n   public void onAttestationAggregationDue(final UnsignedLong slot) {\n-    scheduledDuties.performAggregation(slot);\n+    whenDutiesScheduled(slot, scheduledDuties::performAggregation);\n+  }\n+\n+  private void whenDutiesScheduled(final UnsignedLong slot, final Consumer<UnsignedLong> action) {\n+    // We chain the futures to ensure all actions always happen in their original order.\n+    final UnsignedLong epoch = compute_epoch_at_slot(slot);\n+    final SafeFuture<Void> delayedAction =\n+        pendingTasksByEpoch.computeIfPresent(\n+            epoch, (key, previousTask) -> previousTask.thenRun(() -> action.accept(slot)));\n+    if (delayedAction == null) {\n+      // There was no pending tasks so execute immediately.\n+      action.accept(slot);\n+    } else {\n+      removeWhenAllTasksComplete(epoch, delayedAction);\n+    }\n+  }\n+\n+  /**\n+   * Once each new task has been added to {@link #pendingTasksByEpoch}, this function ensures that\n+   * the task queue is removed when that tasks completes, if and only if it is still the last task\n+   * in the queue.\n+   *\n+   * @param epoch the epoch the task was queued for\n+   * @param enqueuedTask the task that was queued\n+   */\n+  private void removeWhenAllTasksComplete(\n+      final UnsignedLong epoch, final SafeFuture<Void> enqueuedTask) {\n+    enqueuedTask.always(() -> pendingTasksByEpoch.remove(epoch, enqueuedTask));", "originalCommit": "84d2137460e33f834c5f1c7da5daf00ca00c55be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5ODI3NA==", "url": "https://github.com/ConsenSys/teku/pull/1592#discussion_r409098274", "bodyText": ".always winds up mapping to a .handle call under the covers - it's just like any other kind of chaining call on CompletableFuture, so perfectly fine to call multiple times.  In this case though it's actually only called once per future anyway because it's a different future passed into this function each time.", "author": "ajsutton", "createdAt": "2020-04-15T19:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwODk3NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b5230df1bea9f318331585e5ea92bc56dc4a5d8d", "url": "https://github.com/ConsenSys/teku/commit/b5230df1bea9f318331585e5ea92bc56dc4a5d8d", "message": "Merge branch 'master' into delay-duties", "committedDate": "2020-04-15T19:55:48Z", "type": "commit"}]}