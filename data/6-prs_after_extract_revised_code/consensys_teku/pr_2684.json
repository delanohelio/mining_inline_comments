{"pr_number": 2684, "pr_title": "Added import and export for slashing protection data.", "pr_createdAt": "2020-08-28T06:34:33Z", "pr_url": "https://github.com/ConsenSys/teku/pull/2684", "timeline": [{"oid": "a099100c7557a6ae7be9f7fd8396b86e5bab9283", "url": "https://github.com/ConsenSys/teku/commit/a099100c7557a6ae7be9f7fd8396b86e5bab9283", "message": "Added import and export for slashing protection data.\n\n - teku slashing-protection export --data-path=<PATH> --to=<FILE>\n\n - teku slashing-protection import --data-path=<PATH> --from=<FILE>\n\n - --data-path defaults to the default path for teku.\n\n Exporting will only export to the minimal interchange format, as that is all that's stored by teku.\n\n On import, complete or minimal files are supported, and summarised for use by teku. If the genesis_validators_root does not match, the process will halt rather than corrupting existing data. If an existing file is found, the MAX of the exting data and imported data will be stored, to ensure there is no possibility of stepping 'backwards' in slashing protection data.\n\n fixes #2601\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-28T06:30:49Z", "type": "commit"}, {"oid": "9eeadfcb1975e8d5dabbc4ac2ca6e88abe124c49", "url": "https://github.com/ConsenSys/teku/commit/9eeadfcb1975e8d5dabbc4ac2ca6e88abe124c49", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-28T06:36:50Z", "type": "commit"}, {"oid": "e2ad26ddd740a61adaa95e71720f284665e8ad21", "url": "https://github.com/ConsenSys/teku/commit/e2ad26ddd740a61adaa95e71720f284665e8ad21", "message": "pretty print json\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-28T08:26:04Z", "type": "commit"}, {"oid": "eb3177ec919a4e223c24c4669b5e465a7b4c9fa5", "url": "https://github.com/ConsenSys/teku/commit/eb3177ec919a4e223c24c4669b5e465a7b4c9fa5", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-28T08:26:37Z", "type": "commit"}, {"oid": "d3883af67b0f04ccabfb199e01fef693b9107ca0", "url": "https://github.com/ConsenSys/teku/commit/d3883af67b0f04ccabfb199e01fef693b9107ca0", "message": "spotless\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-28T22:29:42Z", "type": "commit"}, {"oid": "8309149015da96df940e011f940141708608c702", "url": "https://github.com/ConsenSys/teku/commit/8309149015da96df940e011f940141708608c702", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-30T21:03:51Z", "type": "commit"}, {"oid": "4544b5e5e628c4054bd9c19a239985585e38e702", "url": "https://github.com/ConsenSys/teku/commit/4544b5e5e628c4054bd9c19a239985585e38e702", "message": "make NEVER_SIGNED be null, and conversion logic associated, as well as go back to using sync writer.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T03:01:19Z", "type": "commit"}, {"oid": "52a0e02188c5f3aba6fefd33775084fa4fa7468d", "url": "https://github.com/ConsenSys/teku/commit/52a0e02188c5f3aba6fefd33775084fa4fa7468d", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-08-31T03:02:56Z", "type": "commit"}, {"oid": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "url": "https://github.com/ConsenSys/teku/commit/9dbb02d37f6f50ec791669fb938ab5a937317a20", "message": "typo\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T03:24:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MTYyOA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479871628", "bodyText": "This should go via SubcommandLogger.error", "author": "ajsutton", "createdAt": "2020-08-31T03:39:46Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex da4e38d7af..56f2af01cc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -13,14 +13,18 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n import tech.pegasys.teku.data.slashinginterchange.Metadata;\n import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MTg5Mw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479871893", "bodyText": "I'm not convinced the YamlProvider should be dealing with file IO.  I'd expect it to mirror JsonProvider and just do the conversion to/from bytes (potentially to/from InputStream if we wanted to be able to stream the data.", "author": "ajsutton", "createdAt": "2020-08-31T03:41:06Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0MDgzNw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480440837", "bodyText": "i dont mind the concept of passing input streams and output streams, but in terms of the provider dealing with the IO, i kind of think its cleaner... maybe not 100% the way it is now, but for the core processing to just get the data and use it, and this deals with reading/writing the yaml seems like a nice single responsibility...", "author": "rolfyone", "createdAt": "2020-08-31T22:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MTg5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex da4e38d7af..56f2af01cc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -13,14 +13,18 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n import tech.pegasys.teku.data.slashinginterchange.Metadata;\n import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MjQ5OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479872498", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final String pubkey = file.getName().substring(0, file.getName().length() - 4);\n          \n          \n            \n                  final String pubkey = file.getName().substring(0, file.getName().length() - \".yml\".length());", "author": "ajsutton", "createdAt": "2020-08-31T03:43:49Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());\n+        System.exit(1);\n+      }\n+      final String pubkey = file.getName().substring(0, file.getName().length() - 4);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex da4e38d7af..56f2af01cc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -13,14 +13,18 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n import tech.pegasys.teku.data.slashinginterchange.Metadata;\n import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MjkyOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479872929", "bodyText": "Probably should catch the exception thrown when this filename turns out to not be a valid public key and provide a useful error message that includes the filename.", "author": "ajsutton", "createdAt": "2020-08-31T03:45:36Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());\n+        System.exit(1);\n+      }\n+      final String pubkey = file.getName().substring(0, file.getName().length() - 4);\n+      minimalSigningHistoryList.add(\n+          new MinimalSigningHistory(BLSPubKey.fromHexString(pubkey), slashingProtectionRecord));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex da4e38d7af..56f2af01cc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -13,14 +13,18 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n import tech.pegasys.teku.data.slashinginterchange.Metadata;\n import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MzIxOA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479873218", "bodyText": "Probably would be better to just convert to JSON with jsonProvider.objectToPrettyJSON then write to file rather than using getObjectMapper and having the Jackson specific code leak out to here.", "author": "ajsutton", "createdAt": "2020-08-31T03:47:00Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try {\n+      SlashingProtectionRecord slashingProtectionRecord =\n+          yamlProvider.fileToObject(file, SlashingProtectionRecord.class);\n+      if (genesisValidatorsRoot == null && slashingProtectionRecord.genesisValidatorsRoot != null) {\n+        this.genesisValidatorsRoot = slashingProtectionRecord.genesisValidatorsRoot;\n+      } else if (slashingProtectionRecord.genesisValidatorsRoot != null\n+          && !genesisValidatorsRoot.equals(slashingProtectionRecord.genesisValidatorsRoot)) {\n+        System.err.println(\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());\n+        System.exit(1);\n+      }\n+      final String pubkey = file.getName().substring(0, file.getName().length() - 4);\n+      minimalSigningHistoryList.add(\n+          new MinimalSigningHistory(BLSPubKey.fromHexString(pubkey), slashingProtectionRecord));\n+    } catch (IOException e) {\n+      System.err.println(\"Failed to read from file \" + file.toString());\n+      System.exit(1);\n+    }\n+  }\n+\n+  public void saveToFile(final String toFileName) throws IOException {\n+\n+    jsonProvider\n+        .getObjectMapper()\n+        .writerWithDefaultPrettyPrinter()\n+        .writeValue(\n+            new File(toFileName),\n+            new MinimalSlashingProtectionInterchangeFormat(\n+                new Metadata(InterchangeFormat.minimal, UInt64.valueOf(2L), genesisValidatorsRoot),\n+                minimalSigningHistoryList));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex da4e38d7af..56f2af01cc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -13,14 +13,18 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import java.io.File;\n import java.io.IOException;\n+import java.nio.file.Files;\n import java.nio.file.Path;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n import tech.pegasys.teku.data.slashinginterchange.Metadata;\n import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3MzQzNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479873434", "bodyText": "SubCommandLogger.error", "author": "ajsutton", "createdAt": "2020-08-31T03:48:06Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex eb523d86a1..0cc7845733 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -13,6 +13,8 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NDIyMQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479874221", "bodyText": "nit: I'd have this return the result rather than assign to data so the if above is symmetric with both versions assigning to data inline.", "author": "ajsutton", "createdAt": "2020-08-31T03:51:59Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex eb523d86a1..0cc7845733 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -13,6 +13,8 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NDYzNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479874635", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        sourceEpoch.orElse(null),\n          \n          \n            \n                        targetEpoch.orElse(null),\n          \n          \n            \n                        sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n          \n          \n            \n                        targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),", "author": "ajsutton", "createdAt": "2020-08-31T03:54:05Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    data =\n+        completeSigningData.stream()\n+            .map(this::minimalSigningHistoryConverter)\n+            .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    SlashingProtectionRecord record =\n+        new SlashingProtectionRecord(\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(null),\n+            targetEpoch.orElse(null),", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NjYzMg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480396632", "bodyText": "Can't access that from this context, it'd be cyclic dependency...", "author": "rolfyone", "createdAt": "2020-08-31T21:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NDYzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex eb523d86a1..0cc7845733 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -13,6 +13,8 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NTExOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479875119", "bodyText": "SubCommandLogger.display", "author": "ajsutton", "createdAt": "2020-08-31T03:56:20Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    data =\n+        completeSigningData.stream()\n+            .map(this::minimalSigningHistoryConverter)\n+            .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    SlashingProtectionRecord record =\n+        new SlashingProtectionRecord(\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(null),\n+            targetEpoch.orElse(null),\n+            metadata.genesisValidatorsRoot);\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    System.out.println(\"Importing \" + validatorString);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex eb523d86a1..0cc7845733 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -13,6 +13,8 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3NTY5Nw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479875697", "bodyText": "I'd load all the existing validator records upfront and check they all match prior to starting to apply changes.  Otherwise we risk having some records imported and some not.\nBasically I'd import by reading the incoming records, reading all the existing records, merging the two and writing them out.  It might still fail while writing out because of IO errors but at least you've done all the validation up-front and given yourself a chance.\nAlso SubCommandLogger", "author": "ajsutton", "createdAt": "2020-08-31T03:59:19Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final YamlProvider yamlProvider = new YamlProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+    metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+    if (!metadata.interchangeFormatVersion.equals(UInt64.valueOf(2L))) {\n+      System.err.println(\n+          \"Import file \" + inputFile.toString() + \" is not format version 2, cannot continue.\");\n+      System.exit(1);\n+    }\n+    if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+      data =\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+    } else {\n+      summariseCompleteInterchangeFormat(\n+          Arrays.asList(\n+              jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+    }\n+  }\n+\n+  private void summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    data =\n+        completeSigningData.stream()\n+            .map(this::minimalSigningHistoryConverter)\n+            .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    SlashingProtectionRecord record =\n+        new SlashingProtectionRecord(\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(null),\n+            targetEpoch.orElse(null),\n+            metadata.genesisValidatorsRoot);\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    System.out.println(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n+    Optional<SlashingProtectionRecord> existingRecord = Optional.empty();\n+    if (outputFile.toFile().exists()) {\n+      try {\n+        existingRecord =\n+            Optional.ofNullable(\n+                yamlProvider.fileToObject(outputFile.toFile(), SlashingProtectionRecord.class));\n+      } catch (IOException e) {\n+        System.err.println(\"Failed to read existing file: \" + outputFile.toString());\n+        System.exit(1);\n+      }\n+    }\n+    if (existingRecord.isPresent()\n+        && metadata.genesisValidatorsRoot.compareTo(existingRecord.get().genesisValidatorsRoot)\n+            != 0) {\n+      System.err.println(\n+          \"Validator \"\n+              + minimalSigningHistory.pubkey.toHexString()\n+              + \" has a different validators signing root to the data being imported\");", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex eb523d86a1..0cc7845733 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -13,6 +13,8 @@\n \n package tech.pegasys.teku.data;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import java.io.File;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3Nzc3MQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479877771", "bodyText": "Mentioned above, but I'd get rid of these or at most have versions that take InputStream/OutputStream so they don't care where the data is coming from.", "author": "ajsutton", "createdAt": "2020-08-31T04:09:42Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/YamlProvider.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data.slashinginterchange;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.core.Version;\n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import java.io.File;\n+import java.io.IOException;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.provider.Bytes32Deserializer;\n+import tech.pegasys.teku.provider.BytesSerializer;\n+\n+public class YamlProvider {\n+  private final ObjectMapper objectMapper;\n+\n+  public YamlProvider() {\n+    this.objectMapper = new ObjectMapper(new YAMLFactory());\n+    addTekuMappers();\n+  }\n+\n+  private void addTekuMappers() {\n+    SimpleModule module = new SimpleModule(\"TekuYaml\", new Version(1, 0, 0, null, null, null));\n+    module.addDeserializer(UInt64.class, new UInt64Deserializer());\n+    module.addSerializer(UInt64.class, new UInt64Serializer());\n+    module.addDeserializer(Bytes32.class, new Bytes32Deserializer());\n+    module.addSerializer(Bytes.class, new BytesSerializer());\n+    objectMapper.registerModule(module).writer(new DefaultPrettyPrinter());\n+  }\n+\n+  public <T> String objectToYaml(T object) throws JsonProcessingException {\n+    return objectMapper.writeValueAsString(object);\n+  }\n+\n+  public <T> T yamlToObject(String json, Class<T> clazz) throws JsonProcessingException {\n+    return objectMapper.readValue(json, clazz);\n+  }\n+\n+  public <T> T fileToObject(File file, Class<T> clazz) throws IOException {\n+    return objectMapper.readValue(file, clazz);\n+  }\n+\n+  public <T> void writeToFile(File file, T object) throws IOException {\n+    objectMapper.writerWithDefaultPrettyPrinter().writeValue(file, object);\n+  }", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2332d9b2e25a1d362ce894e38009409506b89216", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/YamlProvider.java b/data/yaml/src/main/java/tech/pegasys/teku/data/yaml/YamlProvider.java\nsimilarity index 66%\nrename from data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/YamlProvider.java\nrename to data/yaml/src/main/java/tech/pegasys/teku/data/yaml/YamlProvider.java\nindex 7f1d4e6d52..b88d3c11b8 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/YamlProvider.java\n+++ b/data/yaml/src/main/java/tech/pegasys/teku/data/yaml/YamlProvider.java\n\n@@ -11,22 +11,28 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.teku.data.slashinginterchange;\n+package tech.pegasys.teku.data.yaml;\n \n+import com.fasterxml.jackson.core.JsonGenerationException;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.core.JsonProcessingException;\n import com.fasterxml.jackson.core.Version;\n import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.Module;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.module.SimpleModule;\n import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n-import java.io.File;\n+import java.io.ByteArrayOutputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.stream.Stream;\n import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3OTA4NQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479879085", "bodyText": "It would make more sense to pass genesis validators root into maySignBlock so that if it is allowed to sign, it just creates a new ValidatorSigningRecord that already holds the right genesis validators root.  It should also refuse to sign if it has a validators root that is different to what is passed in as that indicates that the slashing protection DB is from the wrong chain and something has gone wrong (make sure to log an error message in this case as well as the return or it won't be clear why it refused to sign).", "author": "ajsutton", "createdAt": "2020-08-31T04:16:04Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java", "diffHunk": "@@ -18,50 +18,64 @@\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.BLSPublicKey;\n import tech.pegasys.teku.core.signatures.record.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n+import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n \n public class SlashingProtector {\n-\n+  private static final Logger LOG = LogManager.getLogger();\n   private final Map<BLSPublicKey, ValidatorSigningRecord> signingRecords = new HashMap<>();\n-\n   private final SyncDataAccessor dataAccessor;\n+  private final YamlProvider yamlProvider = new YamlProvider();\n   private final Path slashingProtectionBaseDir;\n \n   public SlashingProtector(\n       final SyncDataAccessor dataAccessor, final Path slashingProtectionBaseDir) {\n-    this.dataAccessor = dataAccessor;\n     this.slashingProtectionBaseDir = slashingProtectionBaseDir;\n+    this.dataAccessor = dataAccessor;\n   }\n \n   public synchronized SafeFuture<Boolean> maySignBlock(\n-      final BLSPublicKey validator, final UInt64 slot) {\n+      final BLSPublicKey validator, final ForkInfo forkInfo, final UInt64 slot) {\n     return SafeFuture.of(\n         () -> {\n           final ValidatorSigningRecord signingRecord = loadSigningRecord(validator);\n-          return handleResult(validator, signingRecord.maySignBlock(slot));\n+          return handleResult(\n+              validator, forkInfo.getGenesisValidatorsRoot(), signingRecord.maySignBlock(slot));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwMTQ0OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480401448", "bodyText": "we discussed the validation against the existing validators root being a separate ticket?\ni've updated maySignBlock and maySignAttestation to have bytes32 instead of forkInfo come in", "author": "rolfyone", "createdAt": "2020-08-31T21:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg3OTA4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "31497fb11449f47719f2f4f4376871a95c7472a0", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java\nindex 127d42f3af..283da481c7 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java\n+++ b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java\n\n@@ -25,7 +25,6 @@ import tech.pegasys.teku.bls.BLSPublicKey;\n import tech.pegasys.teku.core.signatures.record.ValidatorSigningRecord;\n import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n-import tech.pegasys.teku.datastructures.state.ForkInfo;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDA3MA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880070", "bodyText": "How did we manage to make this so much more complex?  Can we go back to how we were doing serialisation for ValidatorSigningRecord?  We seem to have wound up with yaml, IO and data model responsibilities scattered all through the code now.", "author": "ajsutton", "createdAt": "2020-08-31T04:21:10Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java", "diffHunk": "@@ -74,15 +88,35 @@ private ValidatorSigningRecord loadSigningRecord(final BLSPublicKey validator)\n     record =\n         dataAccessor\n             .read(validatorRecordPath(validator))\n-            .map(ValidatorSigningRecord::fromBytes)\n+            .map(\n+                val -> {\n+                  try {\n+                    return yamlProvider\n+                        .getObjectMapper()\n+                        .readValue(val.toArray(), SlashingProtectionRecord.class);\n+                  } catch (IOException e) {\n+                    LOG.trace(\n+                        \"error parsing slashing protection file \" + validatorRecordPath(validator),\n+                        e);\n+                  }\n+                  return new SlashingProtectionRecord();\n+                })\n+            .map(ValidatorSigningRecord::fromSlashingProtectionRecord)", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzNzQ1MQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480437451", "bodyText": "this is mostly because i had removed the separate yaml processor that had specific logic for how to export the validatorSigningRecord, and used the one in data. If we want two versions of yaml processor we could go back to the old version and clean that up a bit, but it was also doing things in a weird way... i could clean that up rather than pushing this through the other processor?\nI guess i'd really like to have 1 yaml provider and 1 object definition for the serialized file, and its hard to access it from the import/export commands, so pushing it to one with minimal dependencies so that it could be reused was where i was headed...", "author": "rolfyone", "createdAt": "2020-08-31T22:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDA3MA=="}], "type": "inlineReview", "revised_code": {"commit": "2332d9b2e25a1d362ce894e38009409506b89216", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java\nindex 127d42f3af..e13f1f40af 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java\n+++ b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/SlashingProtector.java\n\n@@ -18,69 +18,62 @@ import java.nio.file.Path;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Optional;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.BLSPublicKey;\n-import tech.pegasys.teku.core.signatures.record.ValidatorSigningRecord;\n-import tech.pegasys.teku.data.slashinginterchange.SlashingProtectionRecord;\n-import tech.pegasys.teku.data.slashinginterchange.YamlProvider;\n-import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n \n public class SlashingProtector {\n-  private static final Logger LOG = LogManager.getLogger();\n+\n   private final Map<BLSPublicKey, ValidatorSigningRecord> signingRecords = new HashMap<>();\n+\n   private final SyncDataAccessor dataAccessor;\n-  private final YamlProvider yamlProvider = new YamlProvider();\n   private final Path slashingProtectionBaseDir;\n \n   public SlashingProtector(\n       final SyncDataAccessor dataAccessor, final Path slashingProtectionBaseDir) {\n-    this.slashingProtectionBaseDir = slashingProtectionBaseDir;\n     this.dataAccessor = dataAccessor;\n+    this.slashingProtectionBaseDir = slashingProtectionBaseDir;\n   }\n \n   public synchronized SafeFuture<Boolean> maySignBlock(\n-      final BLSPublicKey validator, final ForkInfo forkInfo, final UInt64 slot) {\n+      final BLSPublicKey validator, final Bytes32 genesisValidatorsRoot, final UInt64 slot) {\n     return SafeFuture.of(\n         () -> {\n-          final ValidatorSigningRecord signingRecord = loadSigningRecord(validator);\n-          return handleResult(\n-              validator, forkInfo.getGenesisValidatorsRoot(), signingRecord.maySignBlock(slot));\n+          final ValidatorSigningRecord signingRecord =\n+              loadSigningRecord(validator, genesisValidatorsRoot);\n+          return handleResult(validator, signingRecord.maySignBlock(genesisValidatorsRoot, slot));\n         });\n   }\n \n   public synchronized SafeFuture<Boolean> maySignAttestation(\n       final BLSPublicKey validator,\n-      final ForkInfo forkInfo,\n+      final Bytes32 genesisValidatorsRoot,\n       final UInt64 sourceEpoch,\n       final UInt64 targetEpoch) {\n     return SafeFuture.of(\n         () -> {\n-          final ValidatorSigningRecord signingRecord = loadSigningRecord(validator);\n+          final ValidatorSigningRecord signingRecord =\n+              loadSigningRecord(validator, genesisValidatorsRoot);\n           return handleResult(\n               validator,\n-              forkInfo.getGenesisValidatorsRoot(),\n-              signingRecord.maySignAttestation(sourceEpoch, targetEpoch));\n+              signingRecord.maySignAttestation(genesisValidatorsRoot, sourceEpoch, targetEpoch));\n         });\n   }\n \n   private Boolean handleResult(\n-      final BLSPublicKey validator,\n-      final Bytes32 validatorsRoot,\n-      final Optional<ValidatorSigningRecord> newRecord)\n+      final BLSPublicKey validator, final Optional<ValidatorSigningRecord> newRecord)\n       throws IOException {\n     if (newRecord.isEmpty()) {\n       return false;\n     }\n-    writeSigningRecord(validator, validatorsRoot, newRecord.get());\n+    writeSigningRecord(validator, newRecord.get());\n     return true;\n   }\n \n-  private ValidatorSigningRecord loadSigningRecord(final BLSPublicKey validator)\n-      throws IOException {\n+  private ValidatorSigningRecord loadSigningRecord(\n+      final BLSPublicKey validator, final Bytes32 genesisValidatorsRoot) throws IOException {\n     ValidatorSigningRecord record = signingRecords.get(validator);\n     if (record != null) {\n       return record;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDU1Mg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880552", "bodyText": "Would be good to keep these as a simple delegation so that this class is focussed on being the data model and the details of serialisation are handled separately.\nBut they've also wound up only being used by tests which suggests the tests aren't actually testing what the production code now does.", "author": "ajsutton", "createdAt": "2020-08-31T04:23:29Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java", "diffHunk": "@@ -52,11 +60,24 @@ public ValidatorSigningRecord(\n   }\n \n   public static ValidatorSigningRecord fromBytes(final Bytes data) {\n-    return ValidatorSigningRecordSerialization.readRecord(data);\n+    try {\n+      final SlashingProtectionRecord spr =\n+          yamlProvider.getObjectMapper().readValue(data.toArray(), SlashingProtectionRecord.class);\n+      return ValidatorSigningRecord.fromSlashingProtectionRecord(spr);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n   }\n \n   public Bytes toBytes() {\n-    return ValidatorSigningRecordSerialization.writeRecord(this);\n+    try {\n+      return Bytes.wrap(\n+          yamlProvider.getObjectMapper().writeValueAsBytes(this.toSlashingProtectionRecord(null)));\n+    } catch (JsonGenerationException | JsonMappingException e) {\n+      throw new IllegalStateException(\"Failed to serialize ValidatorSigningRecord\", e);\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n   }", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzODczMw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r480438733", "bodyText": "My original implementation had this all removed pretty much, and the tests actually wrote to file, and checked the file contents. It as closer to production because it was following it more faithfully, but we didn't want to remove the sync data writer, so i went back to this, but i think i preferred the old one more...", "author": "rolfyone", "createdAt": "2020-08-31T22:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDU1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2332d9b2e25a1d362ce894e38009409506b89216", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java b/data/signingrecord/src/main/java/tech/pegasys/teku/data/signingrecord/ValidatorSigningRecord.java\nsimilarity index 56%\nrename from ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\nrename to data/signingrecord/src/main/java/tech/pegasys/teku/data/signingrecord/ValidatorSigningRecord.java\nindex c46ed8972f..62ab8cf2bb 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\n+++ b/data/signingrecord/src/main/java/tech/pegasys/teku/data/signingrecord/ValidatorSigningRecord.java\n\n@@ -36,114 +32,111 @@ import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n  * be signed if source >= previousSource AND target > previousTarget\n  */\n public class ValidatorSigningRecord {\n+  private static final Logger LOG = LogManager.getLogger();\n \n-  private static final YamlProvider yamlProvider = new YamlProvider();\n   public static final UInt64 NEVER_SIGNED = null;\n \n+  private final Bytes32 genesisValidatorsRoot;\n+\n   private final UInt64 blockSlot;\n \n   private final UInt64 attestationSourceEpoch;\n \n   private final UInt64 attestationTargetEpoch;\n \n-  public ValidatorSigningRecord() {\n-    this(UInt64.ZERO, NEVER_SIGNED, NEVER_SIGNED);\n+  public ValidatorSigningRecord(final Bytes32 genesisValidatorsRoot) {\n+    this(genesisValidatorsRoot, UInt64.ZERO, NEVER_SIGNED, NEVER_SIGNED);\n   }\n \n   public ValidatorSigningRecord(\n+      final Bytes32 genesisValidatorsRoot,\n       final UInt64 blockSlot,\n       final UInt64 attestationSourceEpoch,\n       final UInt64 attestationTargetEpoch) {\n+    this.genesisValidatorsRoot = genesisValidatorsRoot;\n     this.blockSlot = blockSlot;\n     this.attestationSourceEpoch = attestationSourceEpoch;\n     this.attestationTargetEpoch = attestationTargetEpoch;\n   }\n \n+  public static boolean isNeverSigned(final UInt64 value) {\n+    return Objects.equals(value, NEVER_SIGNED);\n+  }\n+\n   public static ValidatorSigningRecord fromBytes(final Bytes data) {\n-    try {\n-      final SlashingProtectionRecord spr =\n-          yamlProvider.getObjectMapper().readValue(data.toArray(), SlashingProtectionRecord.class);\n-      return ValidatorSigningRecord.fromSlashingProtectionRecord(spr);\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n+    return ValidatorSigningRecordSerialization.readRecord(data);\n   }\n \n   public Bytes toBytes() {\n-    try {\n-      return Bytes.wrap(\n-          yamlProvider.getObjectMapper().writeValueAsBytes(this.toSlashingProtectionRecord(null)));\n-    } catch (JsonGenerationException | JsonMappingException e) {\n-      throw new IllegalStateException(\"Failed to serialize ValidatorSigningRecord\", e);\n-    } catch (IOException e) {\n-      throw new UncheckedIOException(e);\n-    }\n+    return ValidatorSigningRecordSerialization.writeRecord(this);\n   }\n \n   /**\n    * Determine if it is safe to sign a block at the specified slot.\n    *\n+   * @param genesisValidatorsRoot the genesis validators root for the chain being signed\n    * @param slot the slot of the block being signed\n    * @return an Optional containing an updated {@link ValidatorSigningRecord} with the state after\n    *     the block is signed or empty if it is not safe to sign the block.\n    */\n-  public Optional<ValidatorSigningRecord> maySignBlock(final UInt64 slot) {\n+  public Optional<ValidatorSigningRecord> maySignBlock(\n+      final Bytes32 genesisValidatorsRoot, final UInt64 slot) {\n+    if (this.genesisValidatorsRoot != null\n+        && !this.genesisValidatorsRoot.equals(genesisValidatorsRoot)) {\n+      LOG.error(\n+          \"Refusing to sign block because validator signing record is from the wrong chain. Expected genesis validators root \"\n+              + this.genesisValidatorsRoot\n+              + \" but attempting to sign for \"\n+              + genesisValidatorsRoot);\n+      return Optional.empty();\n+    }\n     // We never allow signing a block at slot 0 because we shouldn't be signing the genesis block.\n     if (blockSlot.compareTo(slot) < 0) {\n       return Optional.of(\n-          new ValidatorSigningRecord(slot, attestationSourceEpoch, attestationTargetEpoch));\n+          new ValidatorSigningRecord(\n+              genesisValidatorsRoot, slot, attestationSourceEpoch, attestationTargetEpoch));\n     }\n     return Optional.empty();\n   }\n \n-  public static ValidatorSigningRecord fromSlashingProtectionRecord(\n-      final SlashingProtectionRecord slashingProtectionRecord) {\n-    final UInt64 sourceEpoch =\n-        slashingProtectionRecord.lastSignedAttestationSourceEpoch == null\n-            ? NEVER_SIGNED\n-            : slashingProtectionRecord.lastSignedAttestationSourceEpoch;\n-    final UInt64 targetEpoch =\n-        slashingProtectionRecord.lastSignedAttestationTargetEpoch == null\n-            ? NEVER_SIGNED\n-            : slashingProtectionRecord.lastSignedAttestationTargetEpoch;\n-    return new ValidatorSigningRecord(\n-        slashingProtectionRecord.lastSignedBlockSlot, sourceEpoch, targetEpoch);\n-  }\n-\n-  public SlashingProtectionRecord toSlashingProtectionRecord(final Bytes32 validatorsRoot) {\n-    final UInt64 sourceEpoch =\n-        attestationSourceEpoch == null || attestationSourceEpoch.equals(UInt64.MAX_VALUE)\n-            ? null\n-            : attestationSourceEpoch;\n-    final UInt64 targetEpoch =\n-        attestationTargetEpoch == null || attestationTargetEpoch.equals(UInt64.MAX_VALUE)\n-            ? null\n-            : attestationTargetEpoch;\n-    return new SlashingProtectionRecord(blockSlot, sourceEpoch, targetEpoch, validatorsRoot);\n-  }\n-\n   /**\n    * Determine if it is safe to sign an attestation with the specified source and target epochs.\n    *\n+   * @param genesisValidatorsRoot the genesis validators root for the chain being signed\n    * @param sourceEpoch the source epoch of the attestation to sign\n    * @param targetEpoch the target epoch of the attestation to sign\n    * @return an Optional containing an updated {@link ValidatorSigningRecord} with the state after\n    *     the attestation is signed or empty if it is not safe to sign the attestation.\n    */\n   public Optional<ValidatorSigningRecord> maySignAttestation(\n-      final UInt64 sourceEpoch, final UInt64 targetEpoch) {\n+      final Bytes32 genesisValidatorsRoot, final UInt64 sourceEpoch, final UInt64 targetEpoch) {\n+    if (this.genesisValidatorsRoot != null\n+        && !this.genesisValidatorsRoot.equals(genesisValidatorsRoot)) {\n+      LOG.error(\n+          \"Refusing to sign attestation because validator signing record is from the wrong chain. Expected genesis validators root \"\n+              + this.genesisValidatorsRoot\n+              + \" but attempting to sign for \"\n+              + genesisValidatorsRoot);\n+      return Optional.empty();\n+    }\n     if (isSafeSourceEpoch(sourceEpoch) && isSafeTargetEpoch(targetEpoch)) {\n-      return Optional.of(new ValidatorSigningRecord(blockSlot, sourceEpoch, targetEpoch));\n+      return Optional.of(\n+          new ValidatorSigningRecord(genesisValidatorsRoot, blockSlot, sourceEpoch, targetEpoch));\n     }\n     return Optional.empty();\n   }\n \n   private boolean isSafeSourceEpoch(final UInt64 sourceEpoch) {\n-    return attestationSourceEpoch == null || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n+    return isNeverSigned(attestationSourceEpoch)\n+        || attestationSourceEpoch.isLessThanOrEqualTo(sourceEpoch);\n   }\n \n   private boolean isSafeTargetEpoch(final UInt64 targetEpoch) {\n-    return attestationTargetEpoch == null || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n+    return isNeverSigned(attestationTargetEpoch) || attestationTargetEpoch.isLessThan(targetEpoch);\n+  }\n+\n+  public Bytes32 getGenesisValidatorsRoot() {\n+    return genesisValidatorsRoot;\n   }\n \n   public UInt64 getBlockSlot() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDczMQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880731", "bodyText": "We should be consistent with using NEVER_SIGNED rather than using null directly.", "author": "ajsutton", "createdAt": "2020-08-31T04:24:34Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java", "diffHunk": "@@ -92,24 +139,22 @@ public Bytes toBytes() {\n   }\n \n   private boolean isSafeSourceEpoch(final UInt64 sourceEpoch) {\n-    return attestationSourceEpoch.equals(NEVER_SIGNED)\n-        || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n+    return attestationSourceEpoch == null || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "31497fb11449f47719f2f4f4376871a95c7472a0", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\nindex c46ed8972f..268135f8e0 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\n+++ b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\n\n@@ -146,18 +146,6 @@ public class ValidatorSigningRecord {\n     return attestationTargetEpoch == null || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n   }\n \n-  public UInt64 getBlockSlot() {\n-    return blockSlot;\n-  }\n-\n-  public UInt64 getAttestationSourceEpoch() {\n-    return attestationSourceEpoch;\n-  }\n-\n-  public UInt64 getAttestationTargetEpoch() {\n-    return attestationTargetEpoch;\n-  }\n-\n   @Override\n   public boolean equals(final Object o) {\n     if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MDkxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479880919", "bodyText": "These shouldn't be public as we want to encapsulate the data as much as we can and just have the maySign* methods as the key public API.  They do appear to be unused now though.", "author": "ajsutton", "createdAt": "2020-08-31T04:25:16Z", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java", "diffHunk": "@@ -92,24 +139,22 @@ public Bytes toBytes() {\n   }\n \n   private boolean isSafeSourceEpoch(final UInt64 sourceEpoch) {\n-    return attestationSourceEpoch.equals(NEVER_SIGNED)\n-        || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n+    return attestationSourceEpoch == null || attestationSourceEpoch.compareTo(sourceEpoch) <= 0;\n   }\n \n   private boolean isSafeTargetEpoch(final UInt64 targetEpoch) {\n-    return attestationTargetEpoch.equals(NEVER_SIGNED)\n-        || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n+    return attestationTargetEpoch == null || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n   }\n \n-  UInt64 getBlockSlot() {\n+  public UInt64 getBlockSlot() {\n     return blockSlot;\n   }\n \n-  UInt64 getAttestationSourceEpoch() {\n+  public UInt64 getAttestationSourceEpoch() {\n     return attestationSourceEpoch;\n   }\n \n-  UInt64 getAttestationTargetEpoch() {\n+  public UInt64 getAttestationTargetEpoch() {\n     return attestationTargetEpoch;\n   }", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "31497fb11449f47719f2f4f4376871a95c7472a0", "chunk": "diff --git a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\nindex c46ed8972f..268135f8e0 100644\n--- a/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\n+++ b/ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/record/ValidatorSigningRecord.java\n\n@@ -146,18 +146,6 @@ public class ValidatorSigningRecord {\n     return attestationTargetEpoch == null || attestationTargetEpoch.compareTo(targetEpoch) < 0;\n   }\n \n-  public UInt64 getBlockSlot() {\n-    return blockSlot;\n-  }\n-\n-  public UInt64 getAttestationSourceEpoch() {\n-    return attestationSourceEpoch;\n-  }\n-\n-  public UInt64 getAttestationTargetEpoch() {\n-    return attestationTargetEpoch;\n-  }\n-\n   @Override\n   public boolean equals(final Object o) {\n     if (this == o) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTMxNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479881314", "bodyText": "This is a human friendly name so:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Mixin(name = \"DataStorage\")\n          \n          \n            \n              @Mixin(name = \"Data Storage\")", "author": "ajsutton", "createdAt": "2020-08-31T04:27:13Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java", "diffHunk": "@@ -149,6 +152,9 @@\n   @Mixin(name = \"Data\")\n   private DataOptions dataOptions;\n \n+  @Mixin(name = \"DataStorage\")", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/teku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java b/teku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java\nindex 0b6ff31273..407224c0c9 100644\n--- a/teku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java\n+++ b/teku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java\n\n@@ -152,7 +152,7 @@ public class BeaconNodeCommand implements Callable<Integer> {\n   @Mixin(name = \"Data\")\n   private DataOptions dataOptions;\n \n-  @Mixin(name = \"DataStorage\")\n+  @Mixin(name = \"Data Storage\")\n   private DataStorageOptions dataStorageOptions;\n \n   @Mixin(name = \"Store\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTkwNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479881904", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                description = \"Export slashing protection database in Minimal format.\",\n          \n          \n            \n                description = \"Export slashing protection database in minimal format.\",", "author": "ajsutton", "createdAt": "2020-08-31T04:30:02Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.cli.slashingprotection;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.util.Strings;\n+import picocli.CommandLine;\n+import tech.pegasys.teku.cli.options.DataOptions;\n+import tech.pegasys.teku.data.SlashingProtectionExporter;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n+\n+@CommandLine.Command(\n+    name = \"export\",\n+    description = \"Export slashing protection database in Minimal format.\",", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NDQ1MA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479884450", "bodyText": "you sure? minimal is the name of the format...", "author": "rolfyone", "createdAt": "2020-08-31T04:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4NDgxOQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479884819", "bodyText": "Docs team might overrule me but even with it being the name of the format it's not a proper noun so doesn't deserve a capital.", "author": "ajsutton", "createdAt": "2020-08-31T04:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MTkwNA=="}], "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java b/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java\nindex ffb212aa6f..9eaee95383 100644\n--- a/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java\n+++ b/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java\n\n@@ -24,7 +24,7 @@ import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n \n @CommandLine.Command(\n     name = \"export\",\n-    description = \"Export slashing protection database in Minimal format.\",\n+    description = \"Export slashing protection database in minimal format.\",\n     mixinStandardHelpOptions = true,\n     abbreviateSynopsis = true,\n     versionProvider = PicoCliVersionProvider.class,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MjI0Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479882246", "bodyText": "We should probably display an error an exit if there are no slashing protection records found (ie the directory exists but is empty)", "author": "ajsutton", "createdAt": "2020-08-31T04:31:39Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.cli.slashingprotection;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.util.Strings;\n+import picocli.CommandLine;\n+import tech.pegasys.teku.cli.options.DataOptions;\n+import tech.pegasys.teku.data.SlashingProtectionExporter;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n+\n+@CommandLine.Command(\n+    name = \"export\",\n+    description = \"Export slashing protection database in Minimal format.\",\n+    mixinStandardHelpOptions = true,\n+    abbreviateSynopsis = true,\n+    versionProvider = PicoCliVersionProvider.class,\n+    synopsisHeading = \"%n\",\n+    descriptionHeading = \"%nDescription:%n%n\",\n+    optionListHeading = \"%nOptions:%n\",\n+    footerHeading = \"%n\",\n+    footer = \"Teku is licensed under the Apache License 2.0\")\n+public class ExportCommand implements Runnable {\n+  public static final SubCommandLogger SUB_COMMAND_LOG = new SubCommandLogger();\n+\n+  @CommandLine.Mixin(name = \"Data\")\n+  private DataOptions dataOptions;\n+\n+  @CommandLine.Option(\n+      names = {\"--to\"},\n+      paramLabel = \"<FILENAME>\",\n+      description = \"The file to export the slashing protection database to.\",\n+      required = true,\n+      arity = \"1\")\n+  private String toFileName = Strings.EMPTY;\n+\n+  @Override\n+  public void run() {\n+\n+    final Path slashProtectionPath =\n+        DataOptions.getValidatorsSlashingProtectionPath(dataOptions.getDataPath());\n+    verifySlashingProtectionPathExists(slashProtectionPath);\n+\n+    SlashingProtectionExporter slashingProtectionExporter = new SlashingProtectionExporter();\n+\n+    SUB_COMMAND_LOG.display(\"Reading slashing protection data from: \" + slashProtectionPath);\n+    slashingProtectionExporter.initialise(slashProtectionPath);", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3OTc3OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479979778", "bodyText": "I could potentially also output each file that I load? I ended up doing this on import, but maybe i should do it on export also...", "author": "rolfyone", "createdAt": "2020-08-31T08:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MjI0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java b/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java\nindex ffb212aa6f..9eaee95383 100644\n--- a/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java\n+++ b/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ExportCommand.java\n\n@@ -24,7 +24,7 @@ import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n \n @CommandLine.Command(\n     name = \"export\",\n-    description = \"Export slashing protection database in Minimal format.\",\n+    description = \"Export slashing protection database in minimal format.\",\n     mixinStandardHelpOptions = true,\n     abbreviateSynopsis = true,\n     versionProvider = PicoCliVersionProvider.class,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MjM1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479882356", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    \"Import slashing protection database. Supports Minimal or Complete interchange format.\",\n          \n          \n            \n                    \"Import slashing protection database. Supports minimal or complete interchange format.\",", "author": "ajsutton", "createdAt": "2020-08-31T04:32:16Z", "path": "teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ImportCommand.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.cli.slashingprotection;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.util.Strings;\n+import picocli.CommandLine;\n+import tech.pegasys.teku.cli.options.DataOptions;\n+import tech.pegasys.teku.data.SlashingProtectionImporter;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.util.cli.PicoCliVersionProvider;\n+\n+@CommandLine.Command(\n+    name = \"import\",\n+    description =\n+        \"Import slashing protection database. Supports Minimal or Complete interchange format.\",", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ed0521d9708edd5f3432d5dfaa791003a578287d", "chunk": "diff --git a/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ImportCommand.java b/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ImportCommand.java\nindex 82c893a166..05960d1fa3 100644\n--- a/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ImportCommand.java\n+++ b/teku/src/main/java/tech/pegasys/teku/cli/slashingprotection/ImportCommand.java\n\n@@ -13,6 +13,8 @@\n \n package tech.pegasys.teku.cli.slashingprotection;\n \n+import static tech.pegasys.teku.logging.SubCommandLogger.SUB_COMMAND_LOG;\n+\n import java.io.File;\n import java.io.IOException;\n import java.nio.file.Path;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzYxNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479883615", "bodyText": "Calculating the slashingProtectionPath should stay inside ValidatorClientService.  The ServiceController class should know as little as possible about the details of the service and basically just create and pass the ServiceConfig.", "author": "ajsutton", "createdAt": "2020-08-31T04:38:29Z", "path": "teku/src/main/java/tech/pegasys/teku/services/ServiceController.java", "diffHunk": "@@ -37,7 +39,9 @@ public ServiceController(final ServiceConfig config) {\n     if (config.getConfig().isRemoteValidatorApiEnabled()) {\n       services.add(new RemoteValidatorService(config));\n     } else {\n-      services.add(ValidatorClientService.create(config));\n+      final Path slashingProtectionPath =\n+          DataOptions.getValidatorsSlashingProtectionPath(config.getConfig().getDataPath());\n+      services.add(ValidatorClientService.create(config, slashingProtectionPath));", "originalCommit": "9dbb02d37f6f50ec791669fb938ab5a937317a20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk3Nzk3Nw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r479977977", "bodyText": "I had settled on this because DataOptions wasn't available to the validatorClient, and validatorClient wasn't available to the import/export, so I'll have to have a think about how this is all going to link together and come up with another solution i guess.", "author": "rolfyone", "createdAt": "2020-08-31T08:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNzYzOA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481517638", "bodyText": "Maybe just add a separate item to TekuConfiguration that has the slashing protection path.  Right now it would be calculated off of data dir but then we'd be in a good place to be able to make it a separate CLI arg in the future.", "author": "ajsutton", "createdAt": "2020-09-02T01:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTg4MzYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "08181b921cf76fd2d4c850792be37b4857145b0e", "chunk": "diff --git a/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java b/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java\nindex 3fb27a4a75..22b93a0fb1 100644\n--- a/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java\n+++ b/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java\n\n@@ -39,8 +38,7 @@ public class ServiceController extends Service {\n     if (config.getConfig().isRemoteValidatorApiEnabled()) {\n       services.add(new RemoteValidatorService(config));\n     } else {\n-      final Path slashingProtectionPath =\n-          DataOptions.getValidatorsSlashingProtectionPath(config.getConfig().getDataPath());\n+      final Path slashingProtectionPath = config.getConfig().getValidatorsSlashingProtectionPath();\n       services.add(ValidatorClientService.create(config, slashingProtectionPath));\n     }\n     services.add(new TimerService(config));\n"}}, {"oid": "ed0521d9708edd5f3432d5dfaa791003a578287d", "url": "https://github.com/ConsenSys/teku/commit/ed0521d9708edd5f3432d5dfaa791003a578287d", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T08:32:13Z", "type": "commit"}, {"oid": "31497fb11449f47719f2f4f4376871a95c7472a0", "url": "https://github.com/ConsenSys/teku/commit/31497fb11449f47719f2f4f4376871a95c7472a0", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-08-31T21:30:52Z", "type": "commit"}, {"oid": "2332d9b2e25a1d362ce894e38009409506b89216", "url": "https://github.com/ConsenSys/teku/commit/2332d9b2e25a1d362ce894e38009409506b89216", "message": "merged 2601-signingrecord, and fixed build to work with the new signing record package.\n\nalso added some output and summaries to the command line output.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-01T07:00:13Z", "type": "commit"}, {"oid": "9f19e239c4b52c0f89b8a64e66a9951209808a15", "url": "https://github.com/ConsenSys/teku/commit/9f19e239c4b52c0f89b8a64e66a9951209808a15", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-01T20:25:40Z", "type": "commit"}, {"oid": "afb3d19ea738a63dfdf8bcd7499991070971d066", "url": "https://github.com/ConsenSys/teku/commit/afb3d19ea738a63dfdf8bcd7499991070971d066", "message": "updated interchange version to v.3\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-01T22:14:35Z", "type": "commit"}, {"oid": "457a0940eb6551dbfd9cd8eecb1ce2253f66f5cf", "url": "https://github.com/ConsenSys/teku/commit/457a0940eb6551dbfd9cd8eecb1ce2253f66f5cf", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-01T22:15:00Z", "type": "commit"}, {"oid": "70d80edf2d3ed5d86cf5d5cccc622ae2d41ea20a", "url": "https://github.com/ConsenSys/teku/commit/70d80edf2d3ed5d86cf5d5cccc622ae2d41ea20a", "message": "negative testing for import.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T00:02:03Z", "type": "commit"}, {"oid": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "url": "https://github.com/ConsenSys/teku/commit/e7c50eaf64bd873153414b11f7bec3d9b8aca957", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T00:09:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwNzgwNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481507805", "bodyText": "nit: Since we're reading all the bytes at once anyway we can just use:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try (InputStream input = Files.newInputStream(file.toPath())) {\n          \n          \n            \n                  ValidatorSigningRecord validatorSigningRecord =\n          \n          \n            \n                      ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n          \n          \n            \n                try {\n          \n          \n            \n                  ValidatorSigningRecord validatorSigningRecord =\n          \n          \n            \n                      ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(file.toPath)));", "author": "ajsutton", "createdAt": "2020-09-02T00:39:39Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionExporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try (InputStream input = Files.newInputStream(file.toPath())) {\n+      ValidatorSigningRecord validatorSigningRecord =\n+          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75786833b1c3c1ec15e377923e08a5bcceeed9b6", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex ef39ebcd6a..205b39a3bc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -54,9 +54,9 @@ public class SlashingProtectionExporter {\n   }\n \n   private void readSlashProtectionFile(final File file) {\n-    try (InputStream input = Files.newInputStream(file.toPath())) {\n+    try {\n       ValidatorSigningRecord validatorSigningRecord =\n-          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+          ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(file.toPath)));\n       if (genesisValidatorsRoot == null\n           && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n         this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwODc3Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481508776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"the genesisValidatorsRoot of \"\n          \n          \n            \n                        \"The genesisValidatorsRoot of \"", "author": "ajsutton", "createdAt": "2020-09-02T00:43:24Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionExporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try (InputStream input = Files.newInputStream(file.toPath())) {\n+      ValidatorSigningRecord validatorSigningRecord =\n+          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+      if (genesisValidatorsRoot == null\n+          && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n+        this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n+      } else if (validatorSigningRecord.getGenesisValidatorsRoot() != null\n+          && !genesisValidatorsRoot.equals(validatorSigningRecord.getGenesisValidatorsRoot())) {\n+        log.exit(\n+            1,\n+            \"the genesisValidatorsRoot of \"", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "75786833b1c3c1ec15e377923e08a5bcceeed9b6", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex ef39ebcd6a..205b39a3bc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -54,9 +54,9 @@ public class SlashingProtectionExporter {\n   }\n \n   private void readSlashProtectionFile(final File file) {\n-    try (InputStream input = Files.newInputStream(file.toPath())) {\n+    try {\n       ValidatorSigningRecord validatorSigningRecord =\n-          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+          ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(file.toPath)));\n       if (genesisValidatorsRoot == null\n           && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n         this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwODg1NA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481508854", "bodyText": "Not sure why there's a toLowerCase on this.", "author": "ajsutton", "createdAt": "2020-09-02T00:43:41Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.api.schema.PublicKeyException;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSlashingProtectionInterchangeFormat;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionExporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private final List<MinimalSigningHistory> minimalSigningHistoryList = new ArrayList<>();\n+  private Bytes32 genesisValidatorsRoot = null;\n+\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionExporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final Path slashProtectionPath) {\n+    File slashingProtectionRecords = slashProtectionPath.toFile();\n+    Arrays.stream(slashingProtectionRecords.listFiles())\n+        .filter(file -> file.isFile() && file.getName().endsWith(\".yml\"))\n+        .forEach(this::readSlashProtectionFile);\n+  }\n+\n+  private void readSlashProtectionFile(final File file) {\n+    try (InputStream input = Files.newInputStream(file.toPath())) {\n+      ValidatorSigningRecord validatorSigningRecord =\n+          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+      if (genesisValidatorsRoot == null\n+          && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n+        this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n+      } else if (validatorSigningRecord.getGenesisValidatorsRoot() != null\n+          && !genesisValidatorsRoot.equals(validatorSigningRecord.getGenesisValidatorsRoot())) {\n+        log.exit(\n+            1,\n+            \"the genesisValidatorsRoot of \"\n+                + file.getName()\n+                + \" does not match the expected \"\n+                + genesisValidatorsRoot.toHexString().toLowerCase());", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUzMjQ0NA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481532444", "bodyText": "just to guarantee lower case, I can remove it... it was just something i got in the habit of when doing rest api because we always wanted it in lowercase...", "author": "rolfyone", "createdAt": "2020-09-02T01:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUwODg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "75786833b1c3c1ec15e377923e08a5bcceeed9b6", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\nindex ef39ebcd6a..205b39a3bc 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\n@@ -54,9 +54,9 @@ public class SlashingProtectionExporter {\n   }\n \n   private void readSlashProtectionFile(final File file) {\n-    try (InputStream input = Files.newInputStream(file.toPath())) {\n+    try {\n       ValidatorSigningRecord validatorSigningRecord =\n-          ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes()));\n+          ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(file.toPath)));\n       if (genesisValidatorsRoot == null\n           && validatorSigningRecord.getGenesisValidatorsRoot() != null) {\n         this.genesisValidatorsRoot = validatorSigningRecord.getGenesisValidatorsRoot();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTI2Mg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481511262", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n          \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();", "author": "ajsutton", "createdAt": "2020-09-02T00:46:46Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTQwNQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481511405", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n          \n          \n            \n                  String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();", "author": "ajsutton", "createdAt": "2020-09-02T00:46:57Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMTg2MA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481511860", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n          \n          \n            \n                  if (!INTERCHANGE_VERSION.equals(metadata.interchangeFormatVersion)) {\n          \n      \n    \n    \n  \n\nto avoid potential NullPointerException if the version is missing (Jackson might have caught it already but doesn't hurt to be paranoid)", "author": "ajsutton", "createdAt": "2020-09-02T00:48:40Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjAxNw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481512017", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        \"Import file \"\n          \n          \n            \n                            + inputFile.toString()\n          \n          \n            \n                            + \" is not format version \"\n          \n          \n            \n                            + INTERCHANGE_VERSION.toString()\n          \n          \n            \n                            + \", cannot continue.\");\n          \n          \n            \n                        \"Import file \"\n          \n          \n            \n                            + inputFile.toString()\n          \n          \n            \n                            + \" has unsupported format version \"\n          \n          \n            \n                            + metadata.interchangeFormatVersion\n          \n          \n            \n                            + \". Required version is \"\n          \n          \n            \n                            + INTERCHANGE_VERSION);", "author": "ajsutton", "createdAt": "2020-09-02T00:49:18Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjUxMg==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481512512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n          \n          \n            \n                String validatorString = minimalSigningHistory.pubkey.toUnprefixedHexString().toLowerCase();", "author": "ajsutton", "createdAt": "2020-09-02T00:51:05Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMjYzNA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481512634", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n          \n          \n            \n                Path outputFile = slashingProtectionPath.resolve(validatorString + \".yml\");", "author": "ajsutton", "createdAt": "2020-09-02T00:51:40Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    log.display(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxMzQ1OQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481513459", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  try (InputStream input = Files.newInputStream(outputFile)) {\n          \n          \n            \n                    existingRecord =\n          \n          \n            \n                        Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes())));\n          \n          \n            \n                  try {\n          \n          \n            \n                    existingRecord =\n          \n          \n            \n                        Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(Files.readAllBytes(outputFile)));", "author": "ajsutton", "createdAt": "2020-09-02T00:53:19Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    log.display(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n+    Optional<ValidatorSigningRecord> existingRecord = Optional.empty();\n+    if (outputFile.toFile().exists()) {\n+      try (InputStream input = Files.newInputStream(outputFile)) {\n+        existingRecord =\n+            Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes())));", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNTE1Ng==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481515156", "bodyText": "Actually probably should use SyncDataAccessor here to make sure the change is really persisted to disk.  Likely have to move it to a different module but it's very standalone so that should be easy enough.", "author": "ajsutton", "createdAt": "2020-09-02T00:55:07Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data;\n+\n+import static tech.pegasys.teku.data.slashinginterchange.Metadata.INTERCHANGE_VERSION;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.util.Strings;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.data.slashinginterchange.CompleteSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.InterchangeFormat;\n+import tech.pegasys.teku.data.slashinginterchange.Metadata;\n+import tech.pegasys.teku.data.slashinginterchange.MinimalSigningHistory;\n+import tech.pegasys.teku.data.slashinginterchange.SignedAttestation;\n+import tech.pegasys.teku.data.slashinginterchange.SignedBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.logging.SubCommandLogger;\n+import tech.pegasys.teku.provider.JsonProvider;\n+\n+public class SlashingProtectionImporter {\n+  private final JsonProvider jsonProvider = new JsonProvider();\n+  private Path slashingProtectionPath;\n+  private List<MinimalSigningHistory> data = new ArrayList<>();\n+  private Metadata metadata;\n+  private final SubCommandLogger log;\n+\n+  public SlashingProtectionImporter(final SubCommandLogger log) {\n+    this.log = log;\n+  }\n+\n+  public void initialise(final File inputFile) throws IOException {\n+    final ObjectMapper jsonMapper = jsonProvider.getObjectMapper();\n+    try {\n+      final JsonNode jsonNode = jsonMapper.readTree(inputFile);\n+\n+      metadata = jsonMapper.treeToValue(jsonNode.get(\"metadata\"), Metadata.class);\n+      if (metadata == null) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" does not appear to have metadata information, and cannot be loaded.\");\n+        return; // Testing mocks log.exit\n+      }\n+      if (!metadata.interchangeFormatVersion.equals(INTERCHANGE_VERSION)) {\n+        log.exit(\n+            1,\n+            \"Import file \"\n+                + inputFile.toString()\n+                + \" is not format version \"\n+                + INTERCHANGE_VERSION.toString()\n+                + \", cannot continue.\");\n+        return; // Testing mocks log.exit\n+      }\n+\n+      if (metadata.interchangeFormat.equals(InterchangeFormat.minimal)) {\n+        data =\n+            Arrays.asList(\n+                jsonMapper.treeToValue(jsonNode.get(\"data\"), MinimalSigningHistory[].class));\n+      } else {\n+        data =\n+            summariseCompleteInterchangeFormat(\n+                Arrays.asList(\n+                    jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n+      }\n+    } catch (JsonMappingException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n+    } catch (JsonParseException e) {\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      log.exit(1, \"Json does not appear valid in file \" + inputFile.getName() + \". \" + cause);\n+    }\n+  }\n+\n+  private List<MinimalSigningHistory> summariseCompleteInterchangeFormat(\n+      final List<CompleteSigningHistory> completeSigningData) {\n+    return completeSigningData.stream()\n+        .map(this::minimalSigningHistoryConverter)\n+        .collect(Collectors.toList());\n+  }\n+\n+  private MinimalSigningHistory minimalSigningHistoryConverter(\n+      final CompleteSigningHistory completeSigningHistory) {\n+    final Optional<UInt64> lastSlot =\n+        completeSigningHistory.signedBlocks.stream()\n+            .map(SignedBlock::getSlot)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> sourceEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getSourceEpoch)\n+            .max(UInt64::compareTo);\n+    final Optional<UInt64> targetEpoch =\n+        completeSigningHistory.signedAttestations.stream()\n+            .map(SignedAttestation::getTargetEpoch)\n+            .max(UInt64::compareTo);\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            metadata.genesisValidatorsRoot,\n+            lastSlot.orElse(UInt64.ZERO),\n+            sourceEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED),\n+            targetEpoch.orElse(ValidatorSigningRecord.NEVER_SIGNED));\n+    return new MinimalSigningHistory(completeSigningHistory.pubkey, record);\n+  }\n+\n+  public void updateLocalRecords(final Path slashingProtectionPath) {\n+    this.slashingProtectionPath = slashingProtectionPath;\n+    data.forEach(this::updateLocalRecord);\n+    log.display(\"Updated \" + data.size() + \" validator slashing protection records\");\n+  }\n+\n+  private void updateLocalRecord(final MinimalSigningHistory minimalSigningHistory) {\n+    String validatorString = minimalSigningHistory.pubkey.toHexString().substring(2).toLowerCase();\n+\n+    log.display(\"Importing \" + validatorString);\n+    Path outputFile = slashingProtectionPath.resolve(validatorString.concat(\".yml\"));\n+    Optional<ValidatorSigningRecord> existingRecord = Optional.empty();\n+    if (outputFile.toFile().exists()) {\n+      try (InputStream input = Files.newInputStream(outputFile)) {\n+        existingRecord =\n+            Optional.ofNullable(ValidatorSigningRecord.fromBytes(Bytes.of(input.readAllBytes())));\n+      } catch (IOException e) {\n+        log.exit(1, \"Failed to read existing file: \" + outputFile.toString());\n+      }\n+    }\n+    if (existingRecord.isPresent()\n+        && metadata.genesisValidatorsRoot.compareTo(existingRecord.get().getGenesisValidatorsRoot())\n+            != 0) {\n+      log.exit(\n+          1,\n+          \"Validator \"\n+              + minimalSigningHistory.pubkey.toHexString()\n+              + \" has a different validators signing root to the data being imported\");\n+    }\n+\n+    try (OutputStream out = Files.newOutputStream(outputFile)) {\n+      out.write(\n+          minimalSigningHistory\n+              .toValidatorSigningRecord(existingRecord, metadata.genesisValidatorsRoot)\n+              .toBytes()\n+              .toArray());\n+    } catch (IOException e) {", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "chunk": "diff --git a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\nindex 2f2090ee49..758727d2ae 100644\n--- a/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n+++ b/data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\n@@ -90,7 +90,7 @@ public class SlashingProtectionImporter {\n                     jsonMapper.treeToValue(jsonNode.get(\"data\"), CompleteSigningHistory[].class)));\n       }\n     } catch (JsonMappingException e) {\n-      String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n+      String cause = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n       log.exit(1, \"Failed to load data from \" + inputFile.getName() + \". \" + cause);\n     } catch (JsonParseException e) {\n       String cause = e.getCause() != null ? e.getCause().getMessage() : Strings.EMPTY;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjI2OA==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481516268", "bodyText": "I think these are going to be renamed - probably wind up with a version 4.  Ok to merge as-is but we probably should wait for that change to come through before we really announce this so that we don't have to maintain support for version 3.", "author": "ajsutton", "createdAt": "2020-09-02T00:56:17Z", "path": "data/dataexchange/src/main/java/tech/pegasys/teku/data/slashinginterchange/MinimalSigningHistory.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.data.slashinginterchange;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.api.schema.BLSPubKey;\n+import tech.pegasys.teku.data.signingrecord.ValidatorSigningRecord;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class MinimalSigningHistory {\n+  @JsonProperty(\"pubkey\")\n+  public final BLSPubKey pubkey;\n+\n+  @JsonProperty(\"last_signed_block_slot\")\n+  public final UInt64 lastSignedBlockSlot;\n+\n+  @JsonProperty(\"last_signed_attestation_source_epoch\")\n+  public final UInt64 lastSignedAttestationSourceEpoch;\n+\n+  @JsonProperty(\"last_signed_attestation_target_epoch\")", "originalCommit": "e7c50eaf64bd873153414b11f7bec3d9b8aca957", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY5ODMzNw==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481698337", "bodyText": "interesting, but sounds like not a merge issue, so will mark resolved", "author": "rolfyone", "createdAt": "2020-09-02T05:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTUxNjI2OA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "1f09c1fce8dff230cde09070cc23ea8320f7036a", "url": "https://github.com/ConsenSys/teku/commit/1f09c1fce8dff230cde09070cc23ea8320f7036a", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:35:11Z", "type": "commit"}, {"oid": "75786833b1c3c1ec15e377923e08a5bcceeed9b6", "url": "https://github.com/ConsenSys/teku/commit/75786833b1c3c1ec15e377923e08a5bcceeed9b6", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:37:50Z", "type": "commit"}, {"oid": "627914166a4c205c66ecf2cd12c53c28903f38d9", "url": "https://github.com/ConsenSys/teku/commit/627914166a4c205c66ecf2cd12c53c28903f38d9", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:00Z", "type": "commit"}, {"oid": "24d97258daf97966b13f8d3a23d36876b8ae7a7c", "url": "https://github.com/ConsenSys/teku/commit/24d97258daf97966b13f8d3a23d36876b8ae7a7c", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionExporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:15Z", "type": "commit"}, {"oid": "4a17a90feb94e961c04d61be00512a348ea75479", "url": "https://github.com/ConsenSys/teku/commit/4a17a90feb94e961c04d61be00512a348ea75479", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:39Z", "type": "commit"}, {"oid": "ef7344b897003978cfa619a0b840262ace522b10", "url": "https://github.com/ConsenSys/teku/commit/ef7344b897003978cfa619a0b840262ace522b10", "message": "Update data/dataexchange/src/main/java/tech/pegasys/teku/data/SlashingProtectionImporter.java\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T01:38:47Z", "type": "commit"}, {"oid": "08181b921cf76fd2d4c850792be37b4857145b0e", "url": "https://github.com/ConsenSys/teku/commit/08181b921cf76fd2d4c850792be37b4857145b0e", "message": "review feedback\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T02:14:38Z", "type": "commit"}, {"oid": "0ae95c4d890ce0d8e9f97919babd2eae1ae7f3c4", "url": "https://github.com/ConsenSys/teku/commit/0ae95c4d890ce0d8e9f97919babd2eae1ae7f3c4", "message": "Merge branch '2601' of https://github.com/rolfyone/artemis into 2601", "committedDate": "2020-09-02T02:14:54Z", "type": "commit"}, {"oid": "763c14507da9e17d390f028f2d879ad4de9db582", "url": "https://github.com/ConsenSys/teku/commit/763c14507da9e17d390f028f2d879ad4de9db582", "message": "use SyncDataAccessor in import/export operations.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T03:30:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTYzODk3OQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481638979", "bodyText": "Since we're creating a new module (which is a good idea), I'd call it :infrastructure:io rather than :data:files.", "author": "ajsutton", "createdAt": "2020-09-02T04:02:42Z", "path": "data/files/src/main/java/tech/pegasys/teku/data/files/SyncDataAccessor.java", "diffHunk": "@@ -11,7 +11,7 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.teku.core.signatures;\n+package tech.pegasys.teku.data.files;", "originalCommit": "763c14507da9e17d390f028f2d879ad4de9db582", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2bdab638cedd5029026af934fa1011ca93995ca3", "chunk": "diff --git a/data/files/src/main/java/tech/pegasys/teku/data/files/SyncDataAccessor.java b/infrastructure/io/src/main/java/tech/pegasys/teku/infrastructure/io/SyncDataAccessor.java\nsimilarity index 98%\nrename from data/files/src/main/java/tech/pegasys/teku/data/files/SyncDataAccessor.java\nrename to infrastructure/io/src/main/java/tech/pegasys/teku/infrastructure/io/SyncDataAccessor.java\nindex 32a18d09b3..d1f2ab6f12 100644\n--- a/data/files/src/main/java/tech/pegasys/teku/data/files/SyncDataAccessor.java\n+++ b/infrastructure/io/src/main/java/tech/pegasys/teku/infrastructure/io/SyncDataAccessor.java\n\n@@ -11,7 +11,7 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.teku.data.files;\n+package tech.pegasys.teku.infrastructure.io;\n \n import java.io.File;\n import java.io.IOException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTY0MTI0OQ==", "url": "https://github.com/ConsenSys/teku/pull/2684#discussion_r481641249", "bodyText": "We can just pass in config now and have ValidatorClientService get the slashing protection path from the config itself.", "author": "ajsutton", "createdAt": "2020-09-02T04:05:09Z", "path": "teku/src/main/java/tech/pegasys/teku/services/ServiceController.java", "diffHunk": "@@ -37,7 +38,8 @@ public ServiceController(final ServiceConfig config) {\n     if (config.getConfig().isRemoteValidatorApiEnabled()) {\n       services.add(new RemoteValidatorService(config));\n     } else {\n-      services.add(ValidatorClientService.create(config));\n+      final Path slashingProtectionPath = config.getConfig().getValidatorsSlashingProtectionPath();\n+      services.add(ValidatorClientService.create(config, slashingProtectionPath));", "originalCommit": "763c14507da9e17d390f028f2d879ad4de9db582", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2bdab638cedd5029026af934fa1011ca93995ca3", "chunk": "diff --git a/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java b/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java\nindex 22b93a0fb1..2ba469f347 100644\n--- a/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java\n+++ b/teku/src/main/java/tech/pegasys/teku/services/ServiceController.java\n\n@@ -38,8 +37,7 @@ public class ServiceController extends Service {\n     if (config.getConfig().isRemoteValidatorApiEnabled()) {\n       services.add(new RemoteValidatorService(config));\n     } else {\n-      final Path slashingProtectionPath = config.getConfig().getValidatorsSlashingProtectionPath();\n-      services.add(ValidatorClientService.create(config, slashingProtectionPath));\n+      services.add(ValidatorClientService.create(config));\n     }\n     services.add(new TimerService(config));\n     if (!config.getConfig().isInteropEnabled() && config.getConfig().isEth1Enabled()) {\n"}}, {"oid": "2bdab638cedd5029026af934fa1011ca93995ca3", "url": "https://github.com/ConsenSys/teku/commit/2bdab638cedd5029026af934fa1011ca93995ca3", "message": "rename new package for SyncDataAccessor to infrastructure:io\n\n - also get slashingProtection path from tekuConfig rather than passing into ValidatorClientService.\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T04:36:34Z", "type": "commit"}, {"oid": "810bfd8d16d4191b9495ec373bdb11f55527be3e", "url": "https://github.com/ConsenSys/teku/commit/810bfd8d16d4191b9495ec373bdb11f55527be3e", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T04:52:15Z", "type": "commit"}, {"oid": "99efafb5fb82e8ee163205c40c3e7eaf60142978", "url": "https://github.com/ConsenSys/teku/commit/99efafb5fb82e8ee163205c40c3e7eaf60142978", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T09:12:51Z", "type": "commit"}, {"oid": "e0a906950a6d841ec04cd324416ca0dbe0a10a9a", "url": "https://github.com/ConsenSys/teku/commit/e0a906950a6d841ec04cd324416ca0dbe0a10a9a", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T20:01:28Z", "type": "commit"}, {"oid": "d16da80777f6a5068494ec437676e27a8a2814d3", "url": "https://github.com/ConsenSys/teku/commit/d16da80777f6a5068494ec437676e27a8a2814d3", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T21:54:46Z", "type": "commit"}, {"oid": "deb83c4c61cdec1a2eb43323f9ef233de3694e3b", "url": "https://github.com/ConsenSys/teku/commit/deb83c4c61cdec1a2eb43323f9ef233de3694e3b", "message": "Merge remote-tracking branch 'upstream/master' into 2601", "committedDate": "2020-09-02T22:20:17Z", "type": "commit"}, {"oid": "cc10af22eb1df1c2e362c841e064f94fb9b8513c", "url": "https://github.com/ConsenSys/teku/commit/cc10af22eb1df1c2e362c841e064f94fb9b8513c", "message": "Apply suggestions from code review\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>", "committedDate": "2020-09-02T22:51:17Z", "type": "commit"}, {"oid": "e4d59728e912bc492b1c4416fa6cbac101bb3ac3", "url": "https://github.com/ConsenSys/teku/commit/e4d59728e912bc492b1c4416fa6cbac101bb3ac3", "message": "fix build\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T23:11:47Z", "type": "commit"}, {"oid": "b448687f8c9e7cbabbb2550c6dc911f1694d5ee4", "url": "https://github.com/ConsenSys/teku/commit/b448687f8c9e7cbabbb2550c6dc911f1694d5ee4", "message": "unit test fix\n\nSigned-off-by: Paul Harris <paul.harris@consensys.net>", "committedDate": "2020-09-02T23:20:22Z", "type": "commit"}]}