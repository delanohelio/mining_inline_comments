{"pr_number": 3032, "pr_title": "Reduce BeaconState backing tree memory footprint by ~25% ", "pr_createdAt": "2020-10-20T18:25:38Z", "pr_url": "https://github.com/ConsenSys/teku/pull/3032", "timeline": [{"oid": "00f7d335b8f33c28d79f9de82a23e075c3465e44", "url": "https://github.com/ConsenSys/teku/commit/00f7d335b8f33c28d79f9de82a23e075c3465e44", "message": "Add compressed backing LeafNode implementation to save memory for container members with types < 32bytes", "committedDate": "2020-10-20T18:18:01Z", "type": "commit"}, {"oid": "492ed79ee007933f5eec1a7ac13bdfb98ea24b59", "url": "https://github.com/ConsenSys/teku/commit/492ed79ee007933f5eec1a7ac13bdfb98ea24b59", "message": "Fix LeafNode equals() method", "committedDate": "2020-10-20T18:35:35Z", "type": "commit"}, {"oid": "e83ae3db39b0a48968c34ec25ed8ce0d43722b44", "url": "https://github.com/ConsenSys/teku/commit/e83ae3db39b0a48968c34ec25ed8ce0d43722b44", "message": "Update blocks dump", "committedDate": "2020-10-21T14:38:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU5MDM3MQ==", "url": "https://github.com/ConsenSys/teku/pull/3032#discussion_r509590371", "bodyText": "Why are we appling this only when the byteIndex is zero? Can we not use a compressed tree node even when the byte index is not 0?", "author": "cemozerr", "createdAt": "2020-10-21T19:01:36Z", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/type/BasicViewTypes.java", "diffHunk": "@@ -31,27 +31,35 @@\n \n /** The collection of commonly used basic types */\n public class BasicViewTypes {\n+  private static final TreeNode SINGLE_FALSE_NODE = TreeNode.createCompressedLeafNode(Bytes.of(0));\n+  private static final TreeNode SINGLE_TRUE_NODE = TreeNode.createCompressedLeafNode(Bytes.of(1));\n \n   public static final BasicViewType<BitView> BIT_TYPE =\n       new BasicViewType<>(1) {\n         @Override\n         public BitView createFromBackingNode(TreeNode node, int idx) {\n-          return new BitView((node.hashTreeRoot().get(idx / 8) & (1 << (idx % 8))) != 0);\n+          return BitView.viewOf((node.hashTreeRoot().get(idx / 8) & (1 << (idx % 8))) != 0);\n         }\n \n         @Override\n         public TreeNode updateBackingNode(TreeNode srcNode, int idx, ViewRead newValue) {\n-          MutableBytes32 dest = srcNode.hashTreeRoot().mutableCopy();\n           int byteIndex = idx / 8;\n           int bitIndex = idx % 8;\n-          byte b = dest.get(byteIndex);\n-          if (((BitView) newValue).get()) {\n+          Bytes32 originalBytes = srcNode.hashTreeRoot();\n+          byte b = originalBytes.get(byteIndex);\n+          boolean bit = ((BitView) newValue).get();\n+          if (bit) {\n             b = (byte) (b | (1 << bitIndex));\n           } else {\n             b = (byte) (b & ~(1 << bitIndex));\n           }\n-          dest.set(byteIndex, b);\n-          return TreeNode.createLeafNode(dest);\n+          if (srcNode.isZero() && byteIndex == 0) {", "originalCommit": "e83ae3db39b0a48968c34ec25ed8ce0d43722b44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDIwODg4NQ==", "url": "https://github.com/ConsenSys/teku/pull/3032#discussion_r510208885", "bodyText": "This optimization is primarily intended for 'small' types (like UInt64) in containers which are effectively value bytes right padded with zeroes to Bytes32 and are created exactly with\nupdateBackingNode(zeroLeafNode, 0, myUInt64ValueView)\nIf you are updating a node with idx > 0 that may only mean that this is a List/Vector with packed basic values and optimizing this case makes things more complicated and doesn't yield much benefit.\nHere you may see what I'm referring to:\n(sample backing tree of a Validator structure: )\n\u251c\u2500\u2510\n\u2502 \u251c\u2500\u2510\n\u2502 \u2502 \u251c\u2500\u2510\n\u2502 \u2502 \u2502 \u251c\u2500[0x8c43edcff6f1d56f2a42072637c0cfd9467ddfccb918ce1a8c2d1babb9cdd658]\n\u2502 \u2502 \u2502 \u2514\u2500[0x4b601dde9b2bafe027be489bbdcf82ef00000000000000000000000000000000]\n\u2502 \u2502 \u2514\u2500[0x92fcc742102977503966d35cb217fc55bd583232b0c551605c08b9c319485bb5]\n\u2502 \u2514\u2500\u2510\n\u2502   \u251c\u2500[0x0040597307000000000000000000000000000000000000000000000000000000]\n\u2502   \u2514\u2500[0x0]\n\u2514\u2500\u2510\n  \u251c\u2500\u2510\n  \u2502 \u251c\u2500[0xffffffffffffffff000000000000000000000000000000000000000000000000]\n  \u2502 \u2514\u2500[0xffffffffffffffff000000000000000000000000000000000000000000000000]\n  \u2514\u2500\u2510\n    \u251c\u2500[0xffffffffffffffff000000000000000000000000000000000000000000000000]\n    \u2514\u2500[0xffffffffffffffff000000000000000000000000000000000000000000000000]\n\nIdeally the publicKey here (Bytes48) can be optimized as well cause it has 16 trailing zero bytes but for this case we would need more expensive check that all the bytes to right a zeroes while TreeNode.isZero() is almost free", "author": "Nashatyrev", "createdAt": "2020-10-22T14:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU5MDM3MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "e42f93ebdfd1e5b60e988031f96b2323ad3ba399", "url": "https://github.com/ConsenSys/teku/commit/e42f93ebdfd1e5b60e988031f96b2323ad3ba399", "message": "Merge branch 'master' into feature/optimize-mem-backing-tree", "committedDate": "2020-10-22T14:30:06Z", "type": "commit"}]}