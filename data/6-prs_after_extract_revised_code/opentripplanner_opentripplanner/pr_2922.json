{"pr_number": 2922, "pr_title": "Make the TransitLayerMapper multi-threaded to decrease startup time.", "pr_createdAt": "2020-01-10T19:18:41Z", "pr_url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc5Mjc5Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r366792796", "bodyText": "This modify its input - sideeffects.", "author": "t2gran", "createdAt": "2020-01-15T10:12:52Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -139,70 +145,119 @@ private TransitLayer map() {\n             LOG.info(\"This TransitLayerMapper got a realtime timetable snapshot. The TransitLayer will reflect realtime updates to scheduled service.\");\n         }\n         Set<ServiceDate> allServiceDates = serviceIdsForServiceDate.keySet();\n-        Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n-        for (ServiceDate serviceDate : allServiceDates) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-            TIntSet serviceCodesRunning = new TIntHashSet();\n-\n-            for (FeedScopedId serviceId : serviceIdsForServiceDate.get(serviceDate)) {\n-                serviceCodesRunning.add(graph.serviceCodes.get(serviceId));\n-            }\n+        ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new ConcurrentHashMap<>();\n \n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                // Get an updated or scheduled timetable depending on the date. This might have the\n-                // trips pre-filtered for the specified date, that needs to be investigated. But in\n-                // any case we might end up with a scheduled timetable, which can include\n-                // non-running trips. So filter the trips according to which service IDs are running\n-                // on the given day.\n-                Timetable timetable = oldTripPattern.scheduledTimetable;\n-                if (timetableSnapshot != null) {\n-                    timetable = timetableSnapshot.resolve(oldTripPattern, serviceDate);\n-                }\n-                List<TripSchedule> newTripSchedules = new ArrayList<>();\n-                // The TripTimes are not sorted by departure time in the source timetable because\n-                // OTP1 performs a simple/ linear search. Raptor results depend on trips being\n-                // sorted. We reuse the same timetables many times on different days, so cache the\n-                // sorted versions to avoid repeated compute-intensive sorting. Anecdotally this\n-                // reduces mapping time by more than half, but it is still rather slow. NL Mapping\n-                // takes 32 seconds sorting every timetable, 9 seconds with cached sorting, and 6\n-                // seconds with no timetable sorting at all.\n-                List<TripTimes> sortedTripTimes = sortedTripTimesForTimetable.computeIfAbsent(\n-                    timetable,\n-                    TransitLayerMapper::getSortedTripTimes\n-                );\n-                for (TripTimes tripTimes : sortedTripTimes) {\n-                    if (!serviceCodesRunning.contains(tripTimes.serviceCode)) {\n-                        continue;\n-                    }\n-                    if (tripTimes.getRealTimeState() == RealTimeState.CANCELED) {\n-                        continue;\n-                    }\n-                    TripSchedule tripSchedule = tripScheduleForTripTimes.computeIfAbsent(\n-                        tripTimes,\n-                        // The following are two alternative implementations of TripSchedule\n-                        tt -> new TripScheduleWrapperImpl(tt, oldTripPattern)\n-                        // tt -> tt.toTripSchedulImpl(oldTripPattern)\n+        // CONCURRENT !!! The following stream is running in multiple threads. For a dataset like\n+        // the Norwegian NeTEx hole of Norway, running this in parallel on a Mac book PRO, JAN 2020,\n+        // this saves 20 seconds - from 36s down to 15s.\n+        allServiceDates\n+                .parallelStream()\n+                .forEach(serviceDate -> {\n+                    // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n+                    // the return Map.\n+                    LocalDate date = ServiceCalendarMapper.localDateFromServiceDate(\n+                            serviceDate);\n+\n+                    List<TripPatternForDate> res = mapTripPatternForDay(\n+                            serviceIdsForServiceDate,\n+                            allTripPatterns,\n+                            newTripPatternForOld,\n+                            tripScheduleForTripTimes,\n+                            sortedTripTimesForTimetable,\n+                            serviceDate,\n+                            date\n                     );\n-                    newTripSchedules.add(tripSchedule);\n-                } \n-                TripPattern newTripPattern = newTripPatternForOld.get(oldTripPattern);\n-                TripPatternForDate tripPatternForDate = new TripPatternForDate(\n-                        newTripPattern,\n-                        newTripSchedules,\n-                        localDate\n+                    if(!res.isEmpty()) {\n+                        synchronized (tripPatternsForDates) {\n+                            tripPatternsForDates.put(date, res);\n+                        }\n+                    }\n+                });\n+        return tripPatternsForDates;\n+    }\n+\n+    /**\n+     * Create a list of trip patterns for a given {@code serviceDate}.\n+     * <p>\n+     * THREAD SAFE - This method is called from multiple threads and MUST be thread safe.\n+     *", "originalCommit": "73068f9245c5b79b1ca63c6397bf23bb3dce453e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "chunk": "diff --git a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java\nindex 80f25db09..e61a54fa5 100644\n--- a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java\n+++ b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java\n\n@@ -80,217 +66,71 @@ public class TransitLayerMapper {\n         return new TransitLayer(\n             tripPatternsByStopByDate,\n             transferByStopIndex,\n-            stopIndex.stops,\n-            stopIndex.indexByStop,\n+            stopIndex,\n             graph.getTimeZone().toZoneId()\n         );\n     }\n \n     /**\n      * Map pre-Raptor TripPatterns and Trips to the corresponding Raptor classes.\n-     *\n-     * TODO OTP2 - This can be refactored and broken up into smaller. Se discussion in PR #2794\n+     * <p>\n+     * Part of this method runs in parallel.\n+     * <p>\n      */\n-    private HashMap<LocalDate, List<TripPatternForDate>> mapTripPatterns (StopIndexForRaptor stopIndex) {\n-        // CalendarService has one main implementation (CalendarServiceImpl) which contains a\n-        // CalendarServiceData which can easily supply all of the dates. But it's impossible to\n-        // actually see those dates without modifying the interfaces and inheritance. So we have\n-        // to work around this abstraction and reconstruct the CalendarData.\n-        // Note the \"multiCalendarServiceImpl\" which has docs saying it expects one single\n-        // CalendarData. It seems to merge the calendar services from multiple GTFS feeds, but\n-        // its only documentation says it's a hack.\n-        // TODO OTP2 - This cleanup is added to the 'Final cleanup OTP2' issue #2757\n-\n-        // Reconstruct set of all dates where service is defined, keeping track of which services\n-        // run on which days.\n-        CalendarService calendarService = graph.getCalendarService();\n-        Multimap<ServiceDate, FeedScopedId> serviceIdsForServiceDate = HashMultimap.create();\n-\n-        for (FeedScopedId serviceId : calendarService.getServiceIds()) {\n-            Set<ServiceDate> serviceDatesForService = calendarService.getServiceDatesForServiceId(serviceId);\n-            for (ServiceDate serviceDate : serviceDatesForService) {\n-                serviceIdsForServiceDate.put(serviceDate, serviceId);\n-            }\n-        }\n-\n-        // If we are using realtime updates, we want to include both the TripPatterns in the scheduled (static) data\n-        // and any new patterns that were created by realtime data (added or rerouted trips).\n-        // So far, realtime messages cannot add new stops or service IDs, so we can use those straight from the Graph.\n-        final Collection<org.opentripplanner.model.TripPattern> allTripPatterns = new HashSet<>(graph.tripPatternForId.values());\n-\n-        if (timetableSnapshot != null && !timetableSnapshot.getAllRealtimeTripPatterns().isEmpty()) {\n-            // Make a protective copy, also removing duplicates between the scheduled and updated patterns.\n-            // This may be somewhat inefficient since we copy all patterns into a Set even when none have been added.\n-            // However references to the TripPatternCache are private, and none is held by the timetableSnapshot so\n-            // this is simpler.\n-            allTripPatterns.addAll(timetableSnapshot.getAllRealtimeTripPatterns());\n-        }\n-\n-        final Map<org.opentripplanner.model.TripPattern, TripPattern> newTripPatternForOld;\n-        newTripPatternForOld = mapOldTripPatternToRaptorTripPattern(stopIndex, allTripPatterns);\n+    private HashMap<LocalDate, List<TripPatternForDate>> mapTripPatterns (\n+        StopIndexForRaptor stopIndex\n+    ) {\n+        Collection<org.opentripplanner.model.TripPattern> allTripPatterns =\n+            graph.tripPatternForId.values();\n \n-        // Presumably even when applying realtime, many TripTimes will recur on future dates.\n-        // This Map is used to deduplicate the resulting TripSchedules.\n-        ConcurrentMap<TripTimes, TripSchedule> tripScheduleForTripTimes = new ConcurrentHashMap<>();\n+        final Map<org.opentripplanner.model.TripPattern, TripPattern>\n+        newTripPatternForOld =\n+            mapOldTripPatternToRaptorTripPattern(stopIndex, allTripPatterns);\n \n         // The return value of this entire process.\n         HashMap<LocalDate, List<TripPatternForDate>> tripPatternsForDates = new HashMap<>();\n \n-        // Loop over all dates for which any service is defined. We need the original TripPattern to look it up in the\n-        // timetable snapshot, but also need to convert it to a new Raptor TripPattern. Get a frozen snapshot of\n-        // timetable data so it isn't changed by incoming realtime data while we're iterating.\n-        if (timetableSnapshot == null) {\n-            LOG.info(\"This TransitLayerMapper could not get a realtime timetable snapshot. The TransitLayer will reflect only scheduled service.\");\n-        } else {\n-            LOG.info(\"This TransitLayerMapper got a realtime timetable snapshot. The TransitLayer will reflect realtime updates to scheduled service.\");\n-        }\n-        Set<ServiceDate> allServiceDates = serviceIdsForServiceDate.keySet();\n-        ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new ConcurrentHashMap<>();\n+        TripPatternForDateMapper tripPatternForDateMapper = new TripPatternForDateMapper(\n+            graph.index.getServiceCodesRunningForDate(),\n+            newTripPatternForOld\n+        );\n+\n+        Set<ServiceDate> allServiceDates = graph.index.getServiceCodesRunningForDate().keySet();\n \n-        // CONCURRENT !!! The following stream is running in multiple threads. For a dataset like\n-        // the Norwegian NeTEx hole of Norway, running this in parallel on a Mac book PRO, JAN 2020,\n-        // this saves 20 seconds - from 36s down to 15s.\n         allServiceDates\n-                .parallelStream()\n-                .forEach(serviceDate -> {\n-                    // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-                    // the return Map.\n-                    LocalDate date = ServiceCalendarMapper.localDateFromServiceDate(\n-                            serviceDate);\n-\n-                    List<TripPatternForDate> res = mapTripPatternForDay(\n-                            serviceIdsForServiceDate,\n-                            allTripPatterns,\n-                            newTripPatternForOld,\n-                            tripScheduleForTripTimes,\n-                            sortedTripTimesForTimetable,\n-                            serviceDate,\n-                            date\n+            .parallelStream()\n+            .forEach(serviceDate -> {\n+                // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n+                // the return Map.\n+                LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n+\n+                // Create a List to hold the values for one entry in the return Map.\n+                List<TripPatternForDate> values = new ArrayList<>();\n+\n+                // This nested loop could be quite inefficient.\n+                // Maybe determine in advance which patterns are running on each service and day.\n+                for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n+                    TripPatternForDate tripPatternForDate =\n+                        tripPatternForDateMapper.map(\n+                            oldTripPattern.scheduledTimetable,\n+                            serviceDate\n                     );\n-                    if(!res.isEmpty()) {\n-                        synchronized (tripPatternsForDates) {\n-                            tripPatternsForDates.put(date, res);\n-                        }\n+                    if (tripPatternForDate != null) {\n+                        values.add(tripPatternForDate);\n                     }\n-                });\n-        return tripPatternsForDates;\n-    }\n-\n-    /**\n-     * Create a list of trip patterns for a given {@code serviceDate}.\n-     * <p>\n-     * THREAD SAFE - This method is called from multiple threads and MUST be thread safe.\n-     *\n-     * @param serviceIdsForServiceDate    all serviceIds for given date - READ ONLY.\n-     * @param allTripPatterns             list of all trip patterns - READ ONLY.\n-     * @param newTripPatternForOld        map between otp model and raptor model trip pattern - READ\n-     *                                    ONLY\n-     * @param tripScheduleForTripTimes    this method adds values to map;\n-     *                                    Hence {@link ConcurrentMap} - MODIFIED.\n-     * @param sortedTripTimesForTimetable this method adds values to map;\n-     *                                    Hence {@link ConcurrentMap} - MODIFIED.\n-     * @param serviceDate                 the current service date\n-     * @param serviceDateAsLocalTime      the current service date as Java LocalDate\n-     * @return a full list of all trip patterns for given service date.\n-     */\n-    private List<TripPatternForDate> mapTripPatternForDay(\n-            final Multimap<ServiceDate, FeedScopedId> serviceIdsForServiceDate,\n-            final Collection<org.opentripplanner.model.TripPattern> allTripPatterns,\n-            final Map<org.opentripplanner.model.TripPattern, TripPattern> newTripPatternForOld,\n-            final ConcurrentMap<TripTimes, TripSchedule> tripScheduleForTripTimes,\n-            final ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable,\n-            final ServiceDate serviceDate,\n-            final LocalDate serviceDateAsLocalTime\n-    ) {\n-        // Create a List to hold the values for one entry in the return Map.\n-        List<TripPatternForDate> result = new ArrayList<>();\n-        TIntSet serviceCodesRunning = new TIntHashSet();\n-\n-        for (FeedScopedId serviceId : serviceIdsForServiceDate.get(serviceDate)) {\n-            serviceCodesRunning.add(graph.serviceCodes.get(serviceId));\n-        }\n-\n-        // This nested loop could be quite inefficient.\n-        // Maybe determine in advance which patterns are running on each service and day.\n-        for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-            // Get an updated or scheduled timetable depending on the date. This might have the\n-            // trips pre-filtered for the specified date, that needs to be investigated. But in\n-            // any case we might end up with a scheduled timetable, which can include\n-            // non-running trips. So filter the trips according to which service IDs are running\n-            // on the given day.\n-            Timetable timetable = oldTripPattern.scheduledTimetable;\n-            if (timetableSnapshot != null) {\n-                timetable = timetableSnapshot.resolve(oldTripPattern, serviceDate);\n-            }\n-            List<TripSchedule> newTripSchedules = new ArrayList<>();\n-            // The TripTimes are not sorted by departure time in the source timetable because\n-            // OTP1 performs a simple/ linear search. Raptor results depend on trips being\n-            // sorted. We reuse the same timetables many times on different days, so cache the\n-            // sorted versions to avoid repeated compute-intensive sorting. Anecdotally this\n-            // reduces mapping time by more than half, but it is still rather slow. NL Mapping\n-            // takes 32 seconds sorting every timetable, 9 seconds with cached sorting, and 6\n-            // seconds with no timetable sorting at all.\n-            List<TripTimes> sortedTripTimes = sortedTripTimesForTimetable.computeIfAbsent(\n-                timetable,\n-                TransitLayerMapper::getSortedTripTimes\n-            );\n-            for (TripTimes tripTimes : sortedTripTimes) {\n-                if (!serviceCodesRunning.contains(tripTimes.serviceCode)) {\n-                    continue;\n                 }\n-                if (tripTimes.getRealTimeState() == RealTimeState.CANCELED) {\n-                    continue;\n+                if (!values.isEmpty()) {\n+                    synchronized (tripPatternsForDates) {\n+                        tripPatternsForDates.put(localDate, values);\n+                    }\n                 }\n-                TripSchedule tripSchedule = tripScheduleForTripTimes.computeIfAbsent(\n-                    tripTimes,\n-                    // The following are two alternative implementations of TripSchedule\n-                    tt -> new TripScheduleWrapperImpl(tt, oldTripPattern)\n-                    // tt -> tt.toTripSchedulImpl(oldTripPattern)\n-                );\n-                newTripSchedules.add(tripSchedule);\n-            }\n-            TripPattern newTripPattern = newTripPatternForOld.get(oldTripPattern);\n-            TripPatternForDate tripPatternForDate = new TripPatternForDate(\n-                    newTripPattern,\n-                    newTripSchedules,\n-                    serviceDateAsLocalTime\n-            );\n-            result.add(tripPatternForDate);\n-        }\n-        return result;\n-    }\n-\n-    /**\n-     * Convert all old TripPatterns into new ones, keeping a Map between the two.\n-     * Do this conversion up front (rather than lazily on demand) to ensure pattern IDs match\n-     * the sequence of patterns in source data.\n-     */\n-    private static Map<org.opentripplanner.model.TripPattern, TripPattern> mapOldTripPatternToRaptorTripPattern(\n-            StopIndexForRaptor stopIndex,\n-            Collection<org.opentripplanner.model.TripPattern> oldTripPatterns\n-    ) {\n-        Map<org.opentripplanner.model.TripPattern, TripPattern> newTripPatternForOld;\n-        newTripPatternForOld = new HashMap<>();\n-        int patternId = 0;\n-\n-        for (org.opentripplanner.model.TripPattern oldTripPattern : oldTripPatterns) {\n-            TripPattern newTripPattern = new TripPattern(\n-                    patternId++,\n-                    // TripPatternForDate should never access the tripTimes inside the TripPattern,\n-                    // so I've left them null.\n-                    // No TripSchedules in the pattern itself; put them in the TripPatternForDate\n-                    null,\n-                    oldTripPattern.mode,\n-                    stopIndex.listStopIndexesForStops(oldTripPattern.stopPattern.stops)\n-            );\n-            newTripPatternForOld.put(oldTripPattern, newTripPattern);\n-        }\n-        return newTripPatternForOld;\n+            });\n+        return tripPatternsForDates;\n     }\n \n-    // TODO About 80% of the mapping time is spent in this method. Should be consider pre-sorting these before\n-    // TODO serializing the graph?\n-    private static List<TripTimes> getSortedTripTimes (Timetable timetable) {\n+    // TODO We can save time by either pre-sorting these or use a sorting algorithm that is\n+    //      optimized for sorting nearly sorted list\n+    static List<TripTimes> getSortedTripTimes (Timetable timetable) {\n         return timetable.tripTimes.stream()\n                 .sorted(Comparator.comparing(t -> t.getArrivalTime(0)))\n                 .collect(Collectors.toList());\n"}}, {"oid": "e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/e0b3e7c15ed9222ba9e89dad38d9d3132cf1b69e", "message": "Make the TransitLayerMapper multithreaded to decrease startup time", "committedDate": "2020-02-06T09:35:17Z", "type": "commit"}, {"oid": "d316e88e3246fac699cd64092fa6c58338844150", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/d316e88e3246fac699cd64092fa6c58338844150", "message": "Improve logging for Graph indexing, to be able to see, when it start and ends. This is a major part of the startup time.", "committedDate": "2020-02-06T09:44:28Z", "type": "commit"}, {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9dfaedb5e58d7682842e8fe645ab30618209cb7", "message": "Added javadoc", "committedDate": "2020-02-06T09:55:27Z", "type": "commit"}, {"oid": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/a9dfaedb5e58d7682842e8fe645ab30618209cb7", "message": "Added javadoc", "committedDate": "2020-02-06T09:55:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMjA0OQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377932049", "bodyText": "Mak a comment here so it is REALY easy to see this this is running in multiple threads.", "author": "t2gran", "createdAt": "2020-02-11T22:15:19Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java", "diffHunk": "@@ -90,29 +95,39 @@ private TransitLayer map() {\n             newTripPatternForOld\n         );\n \n-        for (ServiceDate serviceDate : graph.index.getServiceCodesRunningForDate().keySet()) {\n-            // Create LocalDate equivalent to the OTP/GTFS ServiceDate object, serving as the key of\n-            // the return Map.\n-            LocalDate localDate = ServiceCalendarMapper.localDateFromServiceDate(serviceDate);\n-\n-            // Create a List to hold the values for one entry in the return Map.\n-            List<TripPatternForDate> values = new ArrayList<>();\n-\n-            // This nested loop could be quite inefficient.\n-            // Maybe determine in advance which patterns are running on each service and day.\n-            for (org.opentripplanner.model.TripPattern oldTripPattern : allTripPatterns) {\n-                TripPatternForDate tripPatternForDate = tripPatternForDateMapper.map(oldTripPattern.scheduledTimetable, serviceDate);\n-                if (tripPatternForDate != null) {\n-                    values.add(tripPatternForDate);\n+        Set<ServiceDate> allServiceDates = graph.index.getServiceCodesRunningForDate().keySet();\n+\n+        allServiceDates", "originalCommit": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ce162fb04225dcfd144e610b46c79562249becec", "chunk": "diff --git a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java\nindex e61a54fa5..bb48b5f7c 100644\n--- a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java\n+++ b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TransitLayerMapper.java\n\n@@ -97,6 +97,8 @@ public class TransitLayerMapper {\n \n         Set<ServiceDate> allServiceDates = graph.index.getServiceCodesRunningForDate().keySet();\n \n+        // THIS CODE RUNS IN PARALLEL\n+\n         allServiceDates\n             .parallelStream()\n             .forEach(serviceDate -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMzgwMQ==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377933801", "bodyText": "This class needs JavaDoc documentation that it is Thread safe - why it is so.", "author": "t2gran", "createdAt": "2020-02-11T22:19:14Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -28,14 +29,20 @@\n \n   private static final Logger LOG = LoggerFactory.getLogger(TripPatternForDateMapper.class);\n \n-  private final Map<Timetable, List<TripTimes>> sortedTripTimesForTimetable = new HashMap<>();\n+  private final ConcurrentMap<Timetable, List<TripTimes>> sortedTripTimesForTimetable =\n+      new ConcurrentHashMap<>();", "originalCommit": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ce162fb04225dcfd144e610b46c79562249becec", "chunk": "diff --git a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java\nindex b1cbbc56d..3131467be 100644\n--- a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java\n+++ b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java\n\n@@ -24,6 +25,10 @@ import java.util.concurrent.ConcurrentMap;\n  *\n  * If the Timetable contains a ServiceDate that is not valid for any of its trips, a message is\n  * logged.\n+ *\n+ * This class is THREAD SAFE because the collections initialized as part of the class state are\n+ * concurrent and because the collections passed in on the constructor or their elements are not\n+ * modified. The objects passed into the map method are also not modified.\n  */\n public class TripPatternForDateMapper {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNjQ4Ng==", "url": "https://github.com/opentripplanner/OpenTripPlanner/pull/2922#discussion_r377936486", "bodyText": "Using the Collection.unmodifiableMap(...) would be good idea here, then it becomes clear that these are READ_ONLY.", "author": "t2gran", "createdAt": "2020-02-11T22:25:17Z", "path": "src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java", "diffHunk": "@@ -44,6 +51,13 @@\n     this.newTripPatternForOld = newTripPatternForOld;\n   }", "originalCommit": "a9dfaedb5e58d7682842e8fe645ab30618209cb7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ce162fb04225dcfd144e610b46c79562249becec", "chunk": "diff --git a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java\nindex b1cbbc56d..3131467be 100644\n--- a/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java\n+++ b/src/main/java/org/opentripplanner/routing/algorithm/raptor/transit/mappers/TripPatternForDateMapper.java\n\n@@ -47,8 +52,8 @@ public class TripPatternForDateMapper {\n       Map<ServiceDate, TIntSet> serviceCodesRunningForDate,\n       Map<org.opentripplanner.model.TripPattern, TripPattern> newTripPatternForOld\n   ) {\n-    this.serviceCodesRunningForDate = serviceCodesRunningForDate;\n-    this.newTripPatternForOld = newTripPatternForOld;\n+    this.serviceCodesRunningForDate = Collections.unmodifiableMap(serviceCodesRunningForDate);\n+    this.newTripPatternForOld = Collections.unmodifiableMap(newTripPatternForOld);\n   }\n \n   /**\n"}}, {"oid": "ce162fb04225dcfd144e610b46c79562249becec", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/ce162fb04225dcfd144e610b46c79562249becec", "message": "Added javadoc and comments", "committedDate": "2020-02-12T11:52:00Z", "type": "commit"}, {"oid": "9f385bb4b66946e8db7fcdf60cb64df19deb366c", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/9f385bb4b66946e8db7fcdf60cb64df19deb366c", "message": "Merge branch 'dev-2.x' into otp2_TransitLayerMapper_optimize", "committedDate": "2020-02-12T11:52:30Z", "type": "commit"}, {"oid": "584245f686b23423c013cfd797a9e9880ab72290", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/584245f686b23423c013cfd797a9e9880ab72290", "message": "Merge branch 'dev-2.x' into otp2_TransitLayerMapper_optimize", "committedDate": "2020-02-12T13:53:28Z", "type": "commit"}, {"oid": "165fb5414bcb5c172fa781fdb6678f3d15a9ee13", "url": "https://github.com/opentripplanner/OpenTripPlanner/commit/165fb5414bcb5c172fa781fdb6678f3d15a9ee13", "message": "Review - Minor cosmetic changes, removed 'synchronized' block by converting to a 'ConcurrentHashMap' instead.", "committedDate": "2020-02-12T14:20:36Z", "type": "commit"}]}