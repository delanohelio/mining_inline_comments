{"pr_number": 417, "pr_title": "Optimize schema parsing by reusing ParseResult instances", "pr_createdAt": "2020-09-22T01:39:08Z", "pr_url": "https://github.com/linkedin/rest.li/pull/417", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MTgzNw==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492441837", "bodyText": "Should this be public since it is meant to be used by others", "author": "BrianPin", "createdAt": "2020-09-22T02:17:57Z", "path": "generator/src/main/java/com/linkedin/pegasus/generator/FileFormatDataSchemaParser.java", "diffHunk": "@@ -62,10 +63,15 @@ public FileFormatDataSchemaParser(String resolverPath, DataSchemaResolver schema\n     _schemaParserFactory = schemaParserFactory;\n   }\n \n-  public DataSchemaParser.ParseResult parseSources(String sources[]) throws IOException\n+  public DataSchemaParser.ParseResult parseSources(String[] sources) throws IOException\n   {\n     final DataSchemaParser.ParseResult result = new DataSchemaParser.ParseResult();\n+    parseSources(sources, result);\n+    return result;\n+  }\n \n+  void parseSources(String[] sources, DataSchemaParser.ParseResult result) throws IOException", "originalCommit": "939460b48c98f400e7f58b66222d2a2e38ac3d51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MzAyMw==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492443023", "bodyText": "I think it is only used in DataSchemaParser, so package private looks like a right approach to me.\n@BrianPin why do you think we need to make a new API of FileFormatDataSchemaParser?", "author": "nickibi", "createdAt": "2020-09-22T02:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MTgzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0OTY4Ng==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492449686", "bodyText": "+1 on Yingjie's comment. It's not meant for public consumption, at least not yet. Keeping things initially restricted makes it easier to make changes later.", "author": "evanw555", "createdAt": "2020-09-22T02:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MTgzNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MzgxNg==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492443816", "bodyText": "Do you mind removing this unused constant in your PR?", "author": "nickibi", "createdAt": "2020-09-22T02:27:53Z", "path": "generator/src/main/java/com/linkedin/pegasus/generator/FileFormatDataSchemaParser.java", "diffHunk": "@@ -48,7 +48,8 @@\n  * @author Keren Jin\n  * @author Joe Betz\n  */\n-public class FileFormatDataSchemaParser {\n+public class FileFormatDataSchemaParser\n+{\n   static final String SCHEMA_PATH_PREFIX = SchemaDirectoryName.PEGASUS.getName() + \"/\";\n   static final String EXTENSION_PATH_ENTRY = SchemaDirectoryName.EXTENSIONS.getName() + \"/\";", "originalCommit": "939460b48c98f400e7f58b66222d2a2e38ac3d51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0OTIyOA==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492449228", "bodyText": "It's package-private, so theoretically it can be referenced by a subclass. I can open a separate PR and label it as backward-incompatible.", "author": "evanw555", "createdAt": "2020-09-22T02:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MzgxNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0NDcyMg==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492444722", "bodyText": "The _resolverPath is not used anywhere, but It's an input of this class's constructor. I am thinking about shall we create a new constructor which remove the resolverPath as input. We could deprecate the current constructor later. But it is totally out of the scope of this PR, I just came to know it by reading this PR.", "author": "nickibi", "createdAt": "2020-09-22T02:32:31Z", "path": "generator/src/main/java/com/linkedin/pegasus/generator/FileFormatDataSchemaParser.java", "diffHunk": "@@ -48,7 +48,8 @@\n  * @author Keren Jin\n  * @author Joe Betz\n  */\n-public class FileFormatDataSchemaParser {\n+public class FileFormatDataSchemaParser\n+{\n   static final String SCHEMA_PATH_PREFIX = SchemaDirectoryName.PEGASUS.getName() + \"/\";\n   static final String EXTENSION_PATH_ENTRY = SchemaDirectoryName.EXTENSIONS.getName() + \"/\";\n   private final String _resolverPath;", "originalCommit": "939460b48c98f400e7f58b66222d2a2e38ac3d51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0OTM4MA==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492449380", "bodyText": "Interesting... I didn't notice that \ud83e\udd14  I can make the new constructor.", "author": "evanw555", "createdAt": "2020-09-22T02:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0NDcyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1NDk3Mw==", "url": "https://github.com/linkedin/rest.li/pull/417#discussion_r492454973", "bodyText": "Nevermind, deprecations should be done in minor releases. I'll deprecate it in the other PR.", "author": "evanw555", "createdAt": "2020-09-22T03:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0NDcyMg=="}], "type": "inlineReview", "revised_code": null}, {"oid": "485eca3b80f4b974a7970529e6777cba7874b023", "url": "https://github.com/linkedin/rest.li/commit/485eca3b80f4b974a7970529e6777cba7874b023", "message": "Optimize schema parsing by reusing ParseResult instances\n\nPR #376 made schema parsing deterministic in part by sorting parser\nresults. When using DataSchemaParser to parse data schemas from multiple\nsources, a separate ParseResult instance is constructed for each source\nthen ultimately combined into a new singular instance. This introduced a\nperformance regression when parsing from many sources due to redundant\nsorting done when creating the combined ParseResult. This change fixes\nthat by allowing FileFormatDataSchemaParser to reuse the same instance\nrather than constructing a new one.", "committedDate": "2020-09-22T03:43:33Z", "type": "forcePushed"}, {"oid": "15f716aad324890c0e570e67705abbf7de3a7413", "url": "https://github.com/linkedin/rest.li/commit/15f716aad324890c0e570e67705abbf7de3a7413", "message": "Optimize schema parsing by reusing ParseResult instances\n\nPR #376 made schema parsing deterministic in part by sorting parser\nresults. When using DataSchemaParser to parse data schemas from multiple\nsources, a separate ParseResult instance is constructed for each source\nthen ultimately combined into a new singular instance. This introduced a\nperformance regression when parsing from many sources due to redundant\nsorting done when creating the combined ParseResult. This change fixes\nthat by allowing FileFormatDataSchemaParser to reuse the same instance\nrather than constructing a new one.", "committedDate": "2020-09-22T20:05:26Z", "type": "forcePushed"}, {"oid": "58ee644ea3a21900856c4386f17459cb1246fd4a", "url": "https://github.com/linkedin/rest.li/commit/58ee644ea3a21900856c4386f17459cb1246fd4a", "message": "Optimize schema parsing by reusing ParseResult instances\n\nPR #376 made schema parsing deterministic in part by sorting parser\nresults. When using DataSchemaParser to parse data schemas from multiple\nsources, a separate ParseResult instance is constructed for each source\nthen ultimately combined into a new singular instance. This introduced a\nperformance regression when parsing from many sources due to redundant\nsorting done when creating the combined ParseResult. This change fixes\nthat by allowing FileFormatDataSchemaParser to reuse the same instance\nrather than constructing a new one.", "committedDate": "2020-09-22T21:57:49Z", "type": "commit"}, {"oid": "58ee644ea3a21900856c4386f17459cb1246fd4a", "url": "https://github.com/linkedin/rest.li/commit/58ee644ea3a21900856c4386f17459cb1246fd4a", "message": "Optimize schema parsing by reusing ParseResult instances\n\nPR #376 made schema parsing deterministic in part by sorting parser\nresults. When using DataSchemaParser to parse data schemas from multiple\nsources, a separate ParseResult instance is constructed for each source\nthen ultimately combined into a new singular instance. This introduced a\nperformance regression when parsing from many sources due to redundant\nsorting done when creating the combined ParseResult. This change fixes\nthat by allowing FileFormatDataSchemaParser to reuse the same instance\nrather than constructing a new one.", "committedDate": "2020-09-22T21:57:49Z", "type": "forcePushed"}]}