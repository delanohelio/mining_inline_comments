{"pr_number": 183, "pr_title": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "pr_createdAt": "2020-02-21T08:14:52Z", "pr_url": "https://github.com/linkedin/rest.li/pull/183", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NTk3Nw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382485977", "bodyText": "Technically, this isn't true. Inline types are not necessarily referenced by simple name (e.g. referencing an inline type with an overridden namespace). The point is that they can't be imported.\nTo be completely accurate, this set is just \"a set of simple type names which shouldn't be imported in this document\", because (1) importing types with the same simple name as an inline type is prohibited and will cause a parser error, and (2) being able to reference something in the current namespace by simple name is prioritized (thus anytime an intra-namespace reference is present, that simple name should be off-limits for importing).", "author": "evanw555", "createdAt": "2020-02-21T09:44:00Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -733,13 +734,17 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    Set<String> inlinedTypeNames = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, inlinedTypeNames);\n+    // Collects the set of simple names of types that can use simple reference because\n+    // 1. They are defined inline or", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4MjUxOQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382682519", "bodyText": "My comment was describing the same, made it clear now..", "author": "karthikbalasub", "createdAt": "2020-02-21T16:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NTk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex 08e097f27..cafbb93a5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -734,9 +735,10 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    // Collects the set of simple names of types that can use simple reference because\n+    // Collects the set of simple names of types that can cause conflicts with imports because\n     // 1. They are defined inline or\n-    // 2. They are in the same namespace as their surrounding context (including namespace overrides).\n+    // 2. They are in the same namespace as their surrounding context (including namespace overrides) and are\n+    //    preferred use simple reference\n     Set<String> typeNamesWithSimpleReference = new HashSet<>();\n     gatherTypes(schema, true, encounteredTypes, typeNamesWithSimpleReference, rootNamespace);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NzA1Mw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382487053", "bodyText": "As my other comment mentions above, I'd rephrase this as \"add to the set of non-importable simple names\" (or something along those lines).", "author": "evanw555", "createdAt": "2020-02-21T09:46:06Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -749,25 +754,29 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   }\n \n   /**\n-   * Gather all types (both referenced and inlined) found in this schema and in all its descendents.\n+   * Gather all types (both referenced and inlined) and names of types that should use simple reference from this schema\n+   * and in all its descendents.\n    * @param schema schema to traverse.\n    * @param isDeclaredInline true if the schema should be treated as an inline declaration, false if it should be\n    *                         considered a by-name reference.\n    * @param encounteredTypes cumulative set of all encountered types in this schema (and its descendents).\n-   * @param inlinedTypeNames cumulative set of simple names of all inlined types in this schema (and its descendents).\n+   * @param typeNamesWithSimpleReference cumulative set of simple names of all types in this schema (and its\n+   *                                    descendents) that can use simple reference.\n+   * @param currentNamespace namespace of the current scope.\n    */\n   private void gatherTypes(DataSchema schema, boolean isDeclaredInline, Set<Name> encounteredTypes,\n-      Set<String> inlinedTypeNames)\n+      Set<String> typeNamesWithSimpleReference, String currentNamespace)\n   {\n     // If named type, add to the set of encountered types\n     if (schema instanceof NamedDataSchema)\n     {\n       NamedDataSchema namedSchema = (NamedDataSchema) schema;\n       encounteredTypes.add(new Name(namedSchema.getFullName()));\n-      // If declared inline, add to the set of inlined types\n-      if (isDeclaredInline)\n+      // If declared inline or of the namespace matches the current namespace, add to the set of types with simple\n+      // reference.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY5MTAxMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382691013", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:50:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4NzA1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex 08e097f27..cafbb93a5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -760,23 +762,23 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n    * @param isDeclaredInline true if the schema should be treated as an inline declaration, false if it should be\n    *                         considered a by-name reference.\n    * @param encounteredTypes cumulative set of all encountered types in this schema (and its descendents).\n-   * @param typeNamesWithSimpleReference cumulative set of simple names of all types in this schema (and its\n-   *                                    descendents) that can use simple reference.\n+   * @param nonImportableTypeNames cumulative set of simple names of all types in this schema (and its descendents)\n+   *                              that can conflict with imports.\n    * @param currentNamespace namespace of the current scope.\n    */\n   private void gatherTypes(DataSchema schema, boolean isDeclaredInline, Set<Name> encounteredTypes,\n-      Set<String> typeNamesWithSimpleReference, String currentNamespace)\n+      Set<String> nonImportableTypeNames, String currentNamespace)\n   {\n     // If named type, add to the set of encountered types\n     if (schema instanceof NamedDataSchema)\n     {\n       NamedDataSchema namedSchema = (NamedDataSchema) schema;\n       encounteredTypes.add(new Name(namedSchema.getFullName()));\n-      // If declared inline or of the namespace matches the current namespace, add to the set of types with simple\n-      // reference.\n+      // If declared inline or of the namespace matches the current namespace, add to the set of non-importable\n+      // simple names.\n       if (isDeclaredInline || currentNamespace.equals(namedSchema.getNamespace()))\n       {\n-        typeNamesWithSimpleReference.add(namedSchema.getName());\n+        nonImportableTypeNames.add(namedSchema.getName());\n       }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTIwMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382489203", "bodyText": "nit: identifier -> simple name", "author": "evanw555", "createdAt": "2020-02-21T09:50:38Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace\n+    if (_importsByLocalName.containsKey(schema.getName()) &&\n+        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace()))\n     {\n+      // Write only identifier if there is an import matching the schema.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NTc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382685799", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:41:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTIwMw=="}], "type": "inlineReview", "revised_code": {"commit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex 08e097f27..cafbb93a5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -816,21 +818,20 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n       {\n         MapDataSchema mapSchema = (MapDataSchema) schema;\n         gatherTypes(mapSchema.getValues(), mapSchema.isValuesDeclaredInline(), encounteredTypes,\n-            typeNamesWithSimpleReference, currentNamespace);\n+            nonImportableTypeNames, currentNamespace);\n       }\n       else if (schema instanceof ArrayDataSchema)\n       {\n         ArrayDataSchema arraySchema = (ArrayDataSchema) schema;\n         gatherTypes(arraySchema.getItems(), arraySchema.isItemsDeclaredInline(), encounteredTypes,\n-            typeNamesWithSimpleReference, currentNamespace);\n+            nonImportableTypeNames, currentNamespace);\n       }\n     }\n   }\n \n   /**\n-   * Writes the .pdl escaped source identifier for the given named type.\n-   * The simple name will be written if writing within the type's namespace or if this type has been imported, otherwise\n-   * the fully qualified name will be written.\n+   * Writes the .pdl escaped source identifier for the given named type. Writes either the simple or fully qualified\n+   * name based on the imports in the document and current namespace.\n    *\n    * @param schema the named schema to get a .pdl escaped source identifier for.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTUyMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382489523", "bodyText": "nit: Write only simple name for schemas in the current namespace only if there are no corresponding imports", "author": "evanw555", "createdAt": "2020-02-21T09:51:13Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace\n+    if (_importsByLocalName.containsKey(schema.getName()) &&\n+        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace()))\n     {\n+      // Write only identifier if there is an import matching the schema.\n+      _builder.writeIdentifier(schema.getName());\n+    }\n+    else if (_namespace.equals(schema.getNamespace()) && !_importsByLocalName.containsKey(schema.getName()))\n+    {\n+      // Write only identifier for schemas in the current namespace only if there are no imports with the same simple", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NjYxMw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382686613", "bodyText": "fixed.\ncorresponding imports -> conflicting imports", "author": "karthikbalasub", "createdAt": "2020-02-21T16:42:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4OTUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex 08e097f27..cafbb93a5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -816,21 +818,20 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n       {\n         MapDataSchema mapSchema = (MapDataSchema) schema;\n         gatherTypes(mapSchema.getValues(), mapSchema.isValuesDeclaredInline(), encounteredTypes,\n-            typeNamesWithSimpleReference, currentNamespace);\n+            nonImportableTypeNames, currentNamespace);\n       }\n       else if (schema instanceof ArrayDataSchema)\n       {\n         ArrayDataSchema arraySchema = (ArrayDataSchema) schema;\n         gatherTypes(arraySchema.getItems(), arraySchema.isItemsDeclaredInline(), encounteredTypes,\n-            typeNamesWithSimpleReference, currentNamespace);\n+            nonImportableTypeNames, currentNamespace);\n       }\n     }\n   }\n \n   /**\n-   * Writes the .pdl escaped source identifier for the given named type.\n-   * The simple name will be written if writing within the type's namespace or if this type has been imported, otherwise\n-   * the fully qualified name will be written.\n+   * Writes the .pdl escaped source identifier for the given named type. Writes either the simple or fully qualified\n+   * name based on the imports in the document and current namespace.\n    *\n    * @param schema the named schema to get a .pdl escaped source identifier for.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDEyOQ==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382490129", "bodyText": "The javadoc for this method is now incorrect. Tbh you can probably just remove the detail and say it writes simple name or FQN depending on the current namespace and present imports.", "author": "evanw555", "createdAt": "2020-02-21T09:52:29Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -821,10 +836,17 @@ else if (schema instanceof ArrayDataSchema)\n    */\n   private void writeReference(NamedDataSchema schema) throws IOException\n   {\n-    if (schema.getNamespace().equals(_namespace) ||\n-        (_importsByLocalName.containsKey(schema.getName()) &&\n-        _importsByLocalName.get(schema.getName()).getNamespace().equals(schema.getNamespace())))\n+    // Imports take precedence over current namespace", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4NzM3NA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382687374", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5MDEyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex 08e097f27..cafbb93a5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -816,21 +818,20 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n       {\n         MapDataSchema mapSchema = (MapDataSchema) schema;\n         gatherTypes(mapSchema.getValues(), mapSchema.isValuesDeclaredInline(), encounteredTypes,\n-            typeNamesWithSimpleReference, currentNamespace);\n+            nonImportableTypeNames, currentNamespace);\n       }\n       else if (schema instanceof ArrayDataSchema)\n       {\n         ArrayDataSchema arraySchema = (ArrayDataSchema) schema;\n         gatherTypes(arraySchema.getItems(), arraySchema.isItemsDeclaredInline(), encounteredTypes,\n-            typeNamesWithSimpleReference, currentNamespace);\n+            nonImportableTypeNames, currentNamespace);\n       }\n     }\n   }\n \n   /**\n-   * Writes the .pdl escaped source identifier for the given named type.\n-   * The simple name will be written if writing within the type's namespace or if this type has been imported, otherwise\n-   * the fully qualified name will be written.\n+   * Writes the .pdl escaped source identifier for the given named type. Writes either the simple or fully qualified\n+   * name based on the imports in the document and current namespace.\n    *\n    * @param schema the named schema to get a .pdl escaped source identifier for.\n    */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5NDM0MA==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382494340", "bodyText": "I'd say Importing the type wouldn't force some intra-namespace reference to become fully-qualified.", "author": "evanw555", "createdAt": "2020-02-21T10:01:13Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -719,6 +719,7 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n    * (1) The type is outside the root namespace of the document.\n    * (2) The type is declared outside the document (i.e. not inlined in this document).\n    * (3) The type's name does not conflict with name of an Inlined type.\n+   * (4) The type's name does not conflict with another type that can use simple reference.", "originalCommit": "b436a37e981a85ff139eacb21629a11dc43da6d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY4OTA4Mw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382689083", "bodyText": "fixed", "author": "karthikbalasub", "createdAt": "2020-02-21T16:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ5NDM0MA=="}], "type": "inlineReview", "revised_code": {"commit": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex 08e097f27..cafbb93a5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -719,7 +719,8 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n    * (1) The type is outside the root namespace of the document.\n    * (2) The type is declared outside the document (i.e. not inlined in this document).\n    * (3) The type's name does not conflict with name of an Inlined type.\n-   * (4) The type's name does not conflict with another type that can use simple reference.\n+   * (4) Importing the type should not force using FQN for another type that is in the same namespace as its\n+   *     surrounding.\n    *\n    * When multiple referenced types with the same unqualified name may be imported, the type with the alphabetically\n    * first namespace is chosen. (e.g. \"com.a.b.c.Foo\" is chosen over \"com.x.y.z.Foo\")\n"}}, {"oid": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "url": "https://github.com/linkedin/rest.li/commit/ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "message": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "committedDate": "2020-02-21T16:55:48Z", "type": "commit"}, {"oid": "ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "url": "https://github.com/linkedin/rest.li/commit/ad8cd60cb0e672f1756648f75aae7f8a31f973d6", "message": "Fix bug in PDL encoding logic for imports when there are conflicting types in use.", "committedDate": "2020-02-21T16:55:48Z", "type": "forcePushed"}, {"oid": "27869c9d66a4e6c93c0534b8e3c82d569ce91329", "url": "https://github.com/linkedin/rest.li/commit/27869c9d66a4e6c93c0534b8e3c82d569ce91329", "message": "Fix a typo", "committedDate": "2020-02-21T23:14:58Z", "type": "commit"}, {"oid": "3ee790ea6db314b7baf23801bbf05a590cb7615e", "url": "https://github.com/linkedin/rest.li/commit/3ee790ea6db314b7baf23801bbf05a590cb7615e", "message": "Rename record name in test.", "committedDate": "2020-02-21T23:53:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg3NTgwNw==", "url": "https://github.com/linkedin/rest.li/pull/183#discussion_r382875807", "bodyText": "You should also name this to nonImportableTypeNames to be consistent.", "author": "evanw555", "createdAt": "2020-02-22T01:57:41Z", "path": "data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java", "diffHunk": "@@ -733,13 +735,18 @@ private void writeDocAndProperties(RecordDataSchema.Field field) throws IOExcept\n   private Map<String, Name> computeImports(DataSchema schema, String rootNamespace)\n   {\n     Set<Name> encounteredTypes = new HashSet<>();\n-    Set<String> inlinedTypeNames = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, inlinedTypeNames);\n+    // Collects the set of simple names of types that can cause conflicts with imports because\n+    // 1. They are defined inline or\n+    // 2. They are in the same namespace as their surrounding context (including namespace overrides) and are\n+    //    preferred use simple reference\n+    Set<String> typeNamesWithSimpleReference = new HashSet<>();", "originalCommit": "3ee790ea6db314b7baf23801bbf05a590cb7615e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6a03ea42606adc6d24b7b38cb23936595feccaec", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\nindex cafbb93a5..13fbea51d 100644\n--- a/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n+++ b/data/src/main/java/com/linkedin/data/schema/SchemaToPdlEncoder.java\n\n@@ -739,14 +739,14 @@ public class SchemaToPdlEncoder extends AbstractSchemaEncoder\n     // 1. They are defined inline or\n     // 2. They are in the same namespace as their surrounding context (including namespace overrides) and are\n     //    preferred use simple reference\n-    Set<String> typeNamesWithSimpleReference = new HashSet<>();\n-    gatherTypes(schema, true, encounteredTypes, typeNamesWithSimpleReference, rootNamespace);\n+    Set<String> nonImportableTypeNames = new HashSet<>();\n+    gatherTypes(schema, true, encounteredTypes, nonImportableTypeNames, rootNamespace);\n \n     // Filter out types that shouldn't have an import and return as a mapping from simple name to typed name\n     return encounteredTypes\n         .stream()\n         .filter(name -> !name.getNamespace().equals(rootNamespace)\n-            && !typeNamesWithSimpleReference.contains(name.getName()))\n+            && !nonImportableTypeNames.contains(name.getName()))\n         .collect(Collectors.toMap(\n             Name::getName,\n             Function.identity(),\n"}}, {"oid": "6a03ea42606adc6d24b7b38cb23936595feccaec", "url": "https://github.com/linkedin/rest.li/commit/6a03ea42606adc6d24b7b38cb23936595feccaec", "message": "Address Evan's comments", "committedDate": "2020-02-22T02:15:31Z", "type": "commit"}]}