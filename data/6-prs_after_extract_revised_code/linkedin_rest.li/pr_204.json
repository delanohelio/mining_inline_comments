{"pr_number": 204, "pr_title": "Make TraverseContext and some of its method in DataSchemaRichContextTraverser public so custmoized SchemaVisitor can access", "pr_createdAt": "2020-03-03T00:49:22Z", "pr_url": "https://github.com/linkedin/rest.li/pull/204", "timeline": [{"oid": "2e16306b41f8540f59eb1b3399494311cbf6f993", "url": "https://github.com/linkedin/rest.li/commit/2e16306b41f8540f59eb1b3399494311cbf6f993", "message": "Make TraverseContext and some of its method in DataSchemaRichContextTraverser public so custmoized SchemaVisitor can access.", "committedDate": "2020-03-03T00:44:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjQ1OA==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387252458", "bodyText": "You want customized visitor to modify context?", "author": "mchen07", "createdAt": "2020-03-03T19:45:25Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java", "diffHunk": "@@ -505,6 +508,16 @@ TraverserContext getNextContext(String nextTraversePathComponent, String nextSch\n       return nextContext;\n     }\n \n+    public DataSchema getOriginalTopLevelSchema()\n+    {\n+      return _originalTopLevelSchema;\n+    }\n+\n+    void setOriginalTopLevelSchema(DataSchema originalTopLevelSchema)", "originalCommit": "2e16306b41f8540f59eb1b3399494311cbf6f993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxNjg1MQ==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387316851", "bodyText": "You want customized visitor to modify context?\n\n(1) some of the methods still have access control, they can't set all the field of the context.\n(2) but yes, the visitor implementation could have access \"currentSchema\" and \"topLevelSchema\" now. I weighted between \"hide implementation for transparency\" vs \"expose implementation for optimization\", and feel that visitor implementation should have access to the details.", "author": "junchuanwang", "createdAt": "2020-03-03T21:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM3MzE1Mw==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387373153", "bodyText": "Make all the setters private and then create a new method for getFirstContext? That way you don't have to expose the setters outside of this class.\nInfact, you should consider defining an interface for the context and then making this implementation class private.", "author": "karthikbalasub", "createdAt": "2020-03-04T00:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MTExOA==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387851118", "bodyText": "As @karthikbalasub commented, I may prefer that we make all setters private.", "author": "mchen07", "createdAt": "2020-03-04T18:26:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjQ1OA=="}], "type": "inlineReview", "revised_code": {"commit": "7098b7477294172348d7a23458ad9a7396ebdf9b", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\nindex 2593fb0d4..91ade7d81 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n\n@@ -508,12 +403,7 @@ public class DataSchemaRichContextTraverser\n       return nextContext;\n     }\n \n-    public DataSchema getOriginalTopLevelSchema()\n-    {\n-      return _originalTopLevelSchema;\n-    }\n-\n-    void setOriginalTopLevelSchema(DataSchema originalTopLevelSchema)\n+    private void setOriginalTopLevelSchema(DataSchema originalTopLevelSchema)\n     {\n       _originalTopLevelSchema = originalTopLevelSchema;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2ODgwMw==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387368803", "bodyText": "I suggest making this a top-level class now that its scope has increased", "author": "karthikbalasub", "createdAt": "2020-03-04T00:06:24Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java", "diffHunk": "@@ -411,7 +412,7 @@ public String formatToErrorMessage()\n    * A new {@link TraverserContext} object will be created before entering child from parent.\n    * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n    */\n-  static class TraverserContext\n+  public static class TraverserContext", "originalCommit": "2e16306b41f8540f59eb1b3399494311cbf6f993", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7098b7477294172348d7a23458ad9a7396ebdf9b", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\nindex 2593fb0d4..91ade7d81 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n\n@@ -266,162 +266,57 @@ public class DataSchemaRichContextTraverser\n   {\n   }\n \n+\n   /**\n-   * The traversal result stores states of the traversal result for each visitor.\n-   * It should tell whether the traversal is successful and stores error messages if not\n-   *\n-   * There are two kinds of error messages\n-   * (1) An error message with {@link Message} type, it will be collected to the {@link Message} list and formatted and\n-   * outputted by the string builder.\n-   * (2) User can also directly add string literal messages and output them using the string builder.\n+   * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n    *\n-   * @see Message\n+   * A new {@link TraverserContext} object will be created before entering child from parent.\n+   * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n    */\n-  public static class VisitorTraversalResult\n+  public interface TraverserContext\n   {\n-\n-    boolean _isTraversalSuccessful = true;\n-    MessageList<Message> _messages = new MessageList<>();\n-    StringBuilder _messageBuilder = new StringBuilder();\n     /**\n-     * The {@link SchemaVisitor} should not mutate the original {@link DataSchema} that {@link DataSchemaRichContextTraverser} is traversing,\n-     * instead it needs to construct a new one if it needs to update the original schema.\n-     * This is useful if the new updated {@link DataSchema} is needed for later reuse.\n-     * If no update on the original schema is needed, this variable should remain null.\n+     * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+     * This variable can be set to null if want default behavior.\n      */\n-    DataSchema _constructedSchema = null;\n-\n-    public DataSchema getConstructedSchema()\n-    {\n-      return _constructedSchema;\n-    }\n-\n-    public void setConstructedSchema(DataSchema constructedSchema)\n-    {\n-      _constructedSchema = constructedSchema;\n-    }\n+    void setShouldContinue(Boolean shouldContinue);\n \n     /**\n-     * Return whether there are errors detected during the traversal.\n-     * @return boolean to tell whether the traversal is successful or not\n+     * SchemaAnnotationVisitors can set customized context\n+     * @see VisitorContext\n      */\n-    public boolean isTraversalSuccessful()\n-    {\n-      return _isTraversalSuccessful;\n-    }\n+    VisitorContext getVisitorContext();\n \n-    /**\n-     * private method for setting whether the traversal is successful.\n-     *\n-     * @param traversalSuccessful the boolean value to represent whether the traversal is successful\n-     *\n-     * @see #isTraversalSuccessful()\n-     */\n-    private void setTraversalSuccessful(boolean traversalSuccessful)\n-    {\n-      _isTraversalSuccessful = traversalSuccessful;\n-    }\n+    void setVisitorContext(VisitorContext visitorContext);\n \n     /**\n-     * Getter for messages lists\n-     * @return collection of messages gather during traversal\n+     * Return the top level schema the traverser is traversing on.\n+     * @return top level schema;\n      */\n-    public Collection<Message> getMessages()\n-    {\n-      return _messages;\n-    }\n+    DataSchema getTopLevelSchema();\n \n     /**\n-     * Setter for message lists\n-     * @param messages\n+     * During traversal, the {@link TraverserContext} can return the current schema under traversal\n+     * @return the current schema under traversal\n      */\n-    public void setMessages(MessageList<Message> messages)\n-    {\n-      _messages = messages;\n-      if (messages != null && messages.size() > 0)\n-      {\n-        setTraversalSuccessful(false);\n-      }\n-    }\n+    DataSchema getCurrentSchema();\n \n     /**\n-     * Add a message to the message list and the string builder\n-     * @param message\n+     * During traversal, the {@link TraverserContext} can return the parent schema of the current schema under traversal\n+     * @return the parent schema of the current schema.\n      */\n-    public void addMessage(Message message)\n-    {\n-      _messages.add(message);\n-      MessageUtil.appendMessages(getMessageBuilder(), Arrays.asList(message));\n-      setTraversalSuccessful(false);\n-    }\n+    DataSchema getParentSchema();\n \n     /**\n-     * Add a {@link Message} to the message list using constructor of the {@link Message}\n-     * and also add to the string builder\n-     *\n-     * @param path path to show in the message\n-     * @param format format of the message to show\n-     * @param args args for the format string\n-     *\n-     * @see Message\n-     */\n-    public void addMessage(ArrayDeque<String> path, String format, Object... args)\n-    {\n-      Message msg = new Message(path.toArray(), format, args);\n-      addMessage(msg);\n-    }\n-\n-    /**\n-     * Add multiple {@link Message}s to the message list and the string builder\n-     * These message added shows same path\n-     *\n-     * @param path path of the location where the messages are added\n-     * @param messages the message to add to the message list\n-     *\n-     * @see Message\n-     */\n-    public void addMessages(ArrayDeque<String> path, Collection<? extends Message> messages)\n-    {\n-      List<Message> msgs = messages.stream()\n-                                   .map(msg -> new Message(path.toArray(), ((Message) msg).toString()))\n-                                   .collect(Collectors.toList());\n-      _messages.addAll(msgs);\n-      MessageUtil.appendMessages(getMessageBuilder(), msgs);\n-      setTraversalSuccessful(false);\n-    }\n-\n-    public StringBuilder getMessageBuilder()\n-    {\n-      return _messageBuilder;\n-    }\n-\n-    /**\n-     * Output the string builder content as a string\n-     *\n-     * @return a string output by the string builder\n+     * If the context is passing down from a {@link RecordDataSchema}, this attribute will be set with the enclosing\n+     * {@link RecordDataSchema.Field}\n      */\n-    public String formatToErrorMessage()\n-    {\n-      return getMessageBuilder().toString();\n-    }\n-  }\n-\n-  /**\n-   * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n-   *\n-   * A new {@link TraverserContext} object will be created before entering child from parent.\n-   * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n-   */\n-  public static class TraverserContext\n-  {\n+    RecordDataSchema.Field getEnclosingField();\n     /**\n-     * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-     * This variable can be set to null if want default behavior.\n+     * If the context is passing down from a {@link UnionDataSchema}, this attribute will be set with the enclosing\n+     * {@link UnionDataSchema.Member}\n      */\n-    Boolean _shouldContinue = null;\n-    DataSchema _parentSchema;\n-    DataSchema _currentSchema;\n-    DataSchema _originalTopLevelSchema;\n+    UnionDataSchema.Member getEnclosingUnionMember();\n     /**\n      * This traverse path is a very detailed path, and is same as the path used in {@link DataSchemaTraverse}\n      * This path's every component corresponds to a move by traverser, and its components have TypeRef components and record name.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2OTE2Mg==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387369162", "bodyText": "You should make all these variables private. Package-private is still loose a constraint.\nAnd also create a final constructor so this cannot be extended.", "author": "karthikbalasub", "createdAt": "2020-03-04T00:07:41Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java", "diffHunk": "@@ -420,6 +421,7 @@ public String formatToErrorMessage()\n     Boolean _shouldContinue = null;", "originalCommit": "2e16306b41f8540f59eb1b3399494311cbf6f993", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4MjMxMw==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387982313", "bodyText": "I don't think you can make a constructor final? What is the purpose?", "author": "junchuanwang", "createdAt": "2020-03-04T22:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2OTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4MzcwNg==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387983706", "bodyText": "I mean make the class final, the goal is to avoid extending this class", "author": "karthikbalasub", "createdAt": "2020-03-04T22:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2OTE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk4NTQyMA==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r387985420", "bodyText": "I made \"TraverserContext\" an interface, and made a \"TraverserContextImpl\" private implementation class now so it shouldn't be extended.", "author": "junchuanwang", "createdAt": "2020-03-04T22:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM2OTE2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7098b7477294172348d7a23458ad9a7396ebdf9b", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\nindex 2593fb0d4..91ade7d81 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n\n@@ -266,162 +266,57 @@ public class DataSchemaRichContextTraverser\n   {\n   }\n \n+\n   /**\n-   * The traversal result stores states of the traversal result for each visitor.\n-   * It should tell whether the traversal is successful and stores error messages if not\n-   *\n-   * There are two kinds of error messages\n-   * (1) An error message with {@link Message} type, it will be collected to the {@link Message} list and formatted and\n-   * outputted by the string builder.\n-   * (2) User can also directly add string literal messages and output them using the string builder.\n+   * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n    *\n-   * @see Message\n+   * A new {@link TraverserContext} object will be created before entering child from parent.\n+   * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n    */\n-  public static class VisitorTraversalResult\n+  public interface TraverserContext\n   {\n-\n-    boolean _isTraversalSuccessful = true;\n-    MessageList<Message> _messages = new MessageList<>();\n-    StringBuilder _messageBuilder = new StringBuilder();\n     /**\n-     * The {@link SchemaVisitor} should not mutate the original {@link DataSchema} that {@link DataSchemaRichContextTraverser} is traversing,\n-     * instead it needs to construct a new one if it needs to update the original schema.\n-     * This is useful if the new updated {@link DataSchema} is needed for later reuse.\n-     * If no update on the original schema is needed, this variable should remain null.\n+     * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+     * This variable can be set to null if want default behavior.\n      */\n-    DataSchema _constructedSchema = null;\n-\n-    public DataSchema getConstructedSchema()\n-    {\n-      return _constructedSchema;\n-    }\n-\n-    public void setConstructedSchema(DataSchema constructedSchema)\n-    {\n-      _constructedSchema = constructedSchema;\n-    }\n+    void setShouldContinue(Boolean shouldContinue);\n \n     /**\n-     * Return whether there are errors detected during the traversal.\n-     * @return boolean to tell whether the traversal is successful or not\n+     * SchemaAnnotationVisitors can set customized context\n+     * @see VisitorContext\n      */\n-    public boolean isTraversalSuccessful()\n-    {\n-      return _isTraversalSuccessful;\n-    }\n+    VisitorContext getVisitorContext();\n \n-    /**\n-     * private method for setting whether the traversal is successful.\n-     *\n-     * @param traversalSuccessful the boolean value to represent whether the traversal is successful\n-     *\n-     * @see #isTraversalSuccessful()\n-     */\n-    private void setTraversalSuccessful(boolean traversalSuccessful)\n-    {\n-      _isTraversalSuccessful = traversalSuccessful;\n-    }\n+    void setVisitorContext(VisitorContext visitorContext);\n \n     /**\n-     * Getter for messages lists\n-     * @return collection of messages gather during traversal\n+     * Return the top level schema the traverser is traversing on.\n+     * @return top level schema;\n      */\n-    public Collection<Message> getMessages()\n-    {\n-      return _messages;\n-    }\n+    DataSchema getTopLevelSchema();\n \n     /**\n-     * Setter for message lists\n-     * @param messages\n+     * During traversal, the {@link TraverserContext} can return the current schema under traversal\n+     * @return the current schema under traversal\n      */\n-    public void setMessages(MessageList<Message> messages)\n-    {\n-      _messages = messages;\n-      if (messages != null && messages.size() > 0)\n-      {\n-        setTraversalSuccessful(false);\n-      }\n-    }\n+    DataSchema getCurrentSchema();\n \n     /**\n-     * Add a message to the message list and the string builder\n-     * @param message\n+     * During traversal, the {@link TraverserContext} can return the parent schema of the current schema under traversal\n+     * @return the parent schema of the current schema.\n      */\n-    public void addMessage(Message message)\n-    {\n-      _messages.add(message);\n-      MessageUtil.appendMessages(getMessageBuilder(), Arrays.asList(message));\n-      setTraversalSuccessful(false);\n-    }\n+    DataSchema getParentSchema();\n \n     /**\n-     * Add a {@link Message} to the message list using constructor of the {@link Message}\n-     * and also add to the string builder\n-     *\n-     * @param path path to show in the message\n-     * @param format format of the message to show\n-     * @param args args for the format string\n-     *\n-     * @see Message\n-     */\n-    public void addMessage(ArrayDeque<String> path, String format, Object... args)\n-    {\n-      Message msg = new Message(path.toArray(), format, args);\n-      addMessage(msg);\n-    }\n-\n-    /**\n-     * Add multiple {@link Message}s to the message list and the string builder\n-     * These message added shows same path\n-     *\n-     * @param path path of the location where the messages are added\n-     * @param messages the message to add to the message list\n-     *\n-     * @see Message\n-     */\n-    public void addMessages(ArrayDeque<String> path, Collection<? extends Message> messages)\n-    {\n-      List<Message> msgs = messages.stream()\n-                                   .map(msg -> new Message(path.toArray(), ((Message) msg).toString()))\n-                                   .collect(Collectors.toList());\n-      _messages.addAll(msgs);\n-      MessageUtil.appendMessages(getMessageBuilder(), msgs);\n-      setTraversalSuccessful(false);\n-    }\n-\n-    public StringBuilder getMessageBuilder()\n-    {\n-      return _messageBuilder;\n-    }\n-\n-    /**\n-     * Output the string builder content as a string\n-     *\n-     * @return a string output by the string builder\n+     * If the context is passing down from a {@link RecordDataSchema}, this attribute will be set with the enclosing\n+     * {@link RecordDataSchema.Field}\n      */\n-    public String formatToErrorMessage()\n-    {\n-      return getMessageBuilder().toString();\n-    }\n-  }\n-\n-  /**\n-   * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n-   *\n-   * A new {@link TraverserContext} object will be created before entering child from parent.\n-   * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n-   */\n-  public static class TraverserContext\n-  {\n+    RecordDataSchema.Field getEnclosingField();\n     /**\n-     * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-     * This variable can be set to null if want default behavior.\n+     * If the context is passing down from a {@link UnionDataSchema}, this attribute will be set with the enclosing\n+     * {@link UnionDataSchema.Member}\n      */\n-    Boolean _shouldContinue = null;\n-    DataSchema _parentSchema;\n-    DataSchema _currentSchema;\n-    DataSchema _originalTopLevelSchema;\n+    UnionDataSchema.Member getEnclosingUnionMember();\n     /**\n      * This traverse path is a very detailed path, and is same as the path used in {@link DataSchemaTraverse}\n      * This path's every component corresponds to a move by traverser, and its components have TypeRef components and record name.\n"}}, {"oid": "7098b7477294172348d7a23458ad9a7396ebdf9b", "url": "https://github.com/linkedin/rest.li/commit/7098b7477294172348d7a23458ad9a7396ebdf9b", "message": "created traverserContext interface and use impl class", "committedDate": "2020-03-04T22:57:53Z", "type": "commit"}, {"oid": "09071afe51994e97f9252cbb1c8f5be53a9a8c86", "url": "https://github.com/linkedin/rest.li/commit/09071afe51994e97f9252cbb1c8f5be53a9a8c86", "message": "add override annotation", "committedDate": "2020-03-04T23:06:44Z", "type": "commit"}, {"oid": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "url": "https://github.com/linkedin/rest.li/commit/1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "message": "refactor a few public members out of DataSchemaRichContextTraverser", "committedDate": "2020-03-05T07:12:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2MDY1NQ==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388560655", "bodyText": "Add javadoc\nBased on the documentation on VistorContext, the visitor should not be modifying the context during traversal. So this method is not needed?\nAt least, make the documentation consistent.", "author": "karthikbalasub", "createdAt": "2020-03-05T20:56:04Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ */\n+public interface TraverserContext\n+{\n+  /**\n+   * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+   * This variable can be set to null if want default behavior.\n+   */\n+  void setShouldContinue(Boolean shouldContinue);\n+\n+  /**\n+   * SchemaAnnotationVisitors can set customized context\n+   * @see SchemaVisitor.VisitorContext\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n+  void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2MzM4Mg==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388563382", "bodyText": "Be consistent on spacing. If you are leaving a new line between each method, follow it for all methods.", "author": "karthikbalasub", "createdAt": "2020-03-05T21:01:42Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ */\n+public interface TraverserContext\n+{\n+  /**\n+   * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+   * This variable can be set to null if want default behavior.\n+   */\n+  void setShouldContinue(Boolean shouldContinue);\n+\n+  /**\n+   * SchemaAnnotationVisitors can set customized context\n+   * @see SchemaVisitor.VisitorContext\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n+  void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n+\n+  /**\n+   * Return the top level schema the traverser is traversing on.\n+   * @return top level schema;\n+   */\n+  DataSchema getTopLevelSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the current schema under traversal\n+   * @return the current schema under traversal\n+   */\n+  DataSchema getCurrentSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the parent schema of the current schema under traversal\n+   * @return the parent schema of the current schema.\n+   */\n+  DataSchema getParentSchema();\n+\n+  /**\n+   * If the context is passing down from a {@link RecordDataSchema}, this attribute will be set with the enclosing\n+   * {@link RecordDataSchema.Field}\n+   */\n+  RecordDataSchema.Field getEnclosingField();\n+  /**", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NDIyOQ==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388564229", "bodyText": "Is setting to null same as not calling this method? explain that. Explain the default behavior of this method is not called.\nAlso wording: \"This variable can be set to null for default behavior\"", "author": "karthikbalasub", "createdAt": "2020-03-05T21:03:35Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ */\n+public interface TraverserContext\n+{\n+  /**\n+   * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+   * This variable can be set to null if want default behavior.", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NDc1NA==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388564754", "bodyText": "using \"can return\" indicates, it might return null? document the scenarios", "author": "karthikbalasub", "createdAt": "2020-03-05T21:04:44Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ */\n+public interface TraverserContext\n+{\n+  /**\n+   * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+   * This variable can be set to null if want default behavior.\n+   */\n+  void setShouldContinue(Boolean shouldContinue);\n+\n+  /**\n+   * SchemaAnnotationVisitors can set customized context\n+   * @see SchemaVisitor.VisitorContext\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n+  void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n+\n+  /**\n+   * Return the top level schema the traverser is traversing on.\n+   * @return top level schema;\n+   */\n+  DataSchema getTopLevelSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the current schema under traversal", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NDgwOQ==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388564809", "bodyText": "same here", "author": "karthikbalasub", "createdAt": "2020-03-05T21:04:52Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ */\n+public interface TraverserContext\n+{\n+  /**\n+   * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+   * This variable can be set to null if want default behavior.\n+   */\n+  void setShouldContinue(Boolean shouldContinue);\n+\n+  /**\n+   * SchemaAnnotationVisitors can set customized context\n+   * @see SchemaVisitor.VisitorContext\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n+  void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n+\n+  /**\n+   * Return the top level schema the traverser is traversing on.\n+   * @return top level schema;\n+   */\n+  DataSchema getTopLevelSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the current schema under traversal\n+   * @return the current schema under traversal\n+   */\n+  DataSchema getCurrentSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the parent schema of the current schema under traversal", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NTM1Mg==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388565352", "bodyText": "CurrentSchemaEntryMode should be in its own file.", "author": "karthikbalasub", "createdAt": "2020-03-05T21:06:08Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ */\n+public interface TraverserContext\n+{\n+  /**\n+   * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n+   * This variable can be set to null if want default behavior.\n+   */\n+  void setShouldContinue(Boolean shouldContinue);\n+\n+  /**\n+   * SchemaAnnotationVisitors can set customized context\n+   * @see SchemaVisitor.VisitorContext\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n+  void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n+\n+  /**\n+   * Return the top level schema the traverser is traversing on.\n+   * @return top level schema;\n+   */\n+  DataSchema getTopLevelSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the current schema under traversal\n+   * @return the current schema under traversal\n+   */\n+  DataSchema getCurrentSchema();\n+\n+  /**\n+   * During traversal, the {@link TraverserContext} can return the parent schema of the current schema under traversal\n+   * @return the parent schema of the current schema.\n+   */\n+  DataSchema getParentSchema();\n+\n+  /**\n+   * If the context is passing down from a {@link RecordDataSchema}, this attribute will be set with the enclosing\n+   * {@link RecordDataSchema.Field}\n+   */\n+  RecordDataSchema.Field getEnclosingField();\n+  /**\n+   * If the context is passing down from a {@link UnionDataSchema}, this attribute will be set with the enclosing\n+   * {@link UnionDataSchema.Member}\n+   */\n+  UnionDataSchema.Member getEnclosingUnionMember();\n+  /**\n+   * This traverse path is a very detailed path, and is same as the path used in {@link DataSchemaTraverse}\n+   * This path's every component corresponds to a move by traverser, and its components have TypeRef components and record name.\n+   * Example:\n+   * <pre>\n+   * record Test {\n+   *   f1: record Nested {\n+   *     f2: typeref TypeRef_Name=int\n+   *   }\n+   * }\n+   * </pre>\n+   * The traversePath to the f2 field would be as detailed as \"/Test/f1/Nested/f2/TypeRef_Name/int\"\n+   * Meanwhile its schema pathSpec is as simple as \"/f1/f2\"\n+   *\n+   */\n+  ArrayDeque<String> getTraversePath();\n+  /**\n+   * This is the path components corresponds to {@link PathSpec}, it would not have TypeRef component inside its component list, also it would only contain field's name\n+   */\n+  ArrayDeque<String> getSchemaPathSpec();\n+  /**\n+   * This attribute tells how currentSchema stored in the context is linked from its parentSchema\n+   * For example, if the {@link DataSchemaRichContextTraverser.CurrentSchemaEntryMode} specify the currentSchema is an union member of parent Schema,\n+   * User can expect parentSchema is a {@link UnionDataSchema} and the {@link #getEnclosingUnionMember} should return the\n+   * enclosing union member that stores the current schema.\n+   *\n+   * @see DataSchemaRichContextTraverser.CurrentSchemaEntryMode", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NjU3NQ==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388566575", "bodyText": "Prefer using third person in the docs. eg,\n\"In this way, TraverserContext behaves similar to elements inside a stack..\"", "author": "karthikbalasub", "createdAt": "2020-03-05T21:08:53Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2019 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.data.schema.annotation;\n+\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.DataSchemaTraverse;\n+import com.linkedin.data.schema.PathSpec;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.UnionDataSchema;\n+import java.util.ArrayDeque;\n+\n+\n+/**\n+ * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n+ *\n+ * A new {@link TraverserContext} object will be created before entering child from parent.\n+ * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\nindex 8b1b468a0..92ea8ccd5 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/TraverserContext.java\n\n@@ -27,24 +27,34 @@ import java.util.ArrayDeque;\n  * Context defined by {@link DataSchemaRichContextTraverser} that will be updated and handled during traversal\n  *\n  * A new {@link TraverserContext} object will be created before entering child from parent.\n- * In this way, we simulate {@link TraverserContext} as elements inside stack during recursive traversal.\n+ * In this way, {@link TraverserContext} behaves similar to elements inside a stack.\n  */\n public interface TraverserContext\n {\n   /**\n    * Use this flag to control whether DataSchemaRichContextTraverser should continue to traverse from parent to child.\n-   * This variable can be set to null if want default behavior.\n+   * This variable can be set to null for default behavior. Setting to null is equal to not calling this method.\n    */\n   void setShouldContinue(Boolean shouldContinue);\n \n   /**\n-   * SchemaAnnotationVisitors can set customized context\n+   * {@link SchemaVisitor} should not modify other parts of {@link TraverserContext}.\n+   * But if {@link SchemaVisitor}s want to set customized context inside {@link TraverserContext} and retrieve from it,\n+   * {@link SchemaVisitor.VisitorContext} is how {@link SchemaVisitor} should use to\n+   * persist that customized data during traversal. In detail, when the {@link DataSchemaRichContextTraverser} traverses through schema,\n+   * new {@link TraverserContext} could be created, but {@link SchemaVisitor.VisitorContext} will be passed from old {@link TraverserContext} to\n+   * newly created one.\n+   *\n    * @see SchemaVisitor.VisitorContext\n    */\n-  SchemaVisitor.VisitorContext getVisitorContext();\n-\n   void setVisitorContext(SchemaVisitor.VisitorContext visitorContext);\n \n+  /**\n+   * Getter method for {@link SchemaVisitor.VisitorContext} stored inside {@link TraverserContext}\n+   * @return {@link SchemaVisitor.VisitorContext}, if set.\n+   */\n+  SchemaVisitor.VisitorContext getVisitorContext();\n+\n   /**\n    * Return the top level schema the traverser is traversing on.\n    * @return top level schema;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2NzI1OQ==", "url": "https://github.com/linkedin/rest.li/pull/204#discussion_r388567259", "bodyText": "This should be in its own file based on the style guide we follow", "author": "karthikbalasub", "createdAt": "2020-03-05T21:10:15Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java", "diffHunk": "@@ -216,273 +210,39 @@ public static boolean isLeafSchema(DataSchema dataSchema)\n            || (dataSchema.getType() == DataSchema.Type.ENUM);\n   }\n \n-  /**\n-   * Interface for SchemaVisitor, which will be called by {@link DataSchemaRichContextTraverser}.\n-   */\n-  public interface SchemaVisitor\n-  {\n-    /**\n-     * The callback function that will be called by {@link DataSchemaRichContextTraverser} visiting the dataSchema under traversal.\n-     * This function will be called TWICE within {@link DataSchemaRichContextTraverser}, during two {@link DataSchemaTraverse.Order}s\n-     * {@link DataSchemaTraverse.Order#PRE_ORDER} and {@link DataSchemaTraverse.Order#POST_ORDER} respectively.\n-     *\n-     * @param context\n-     * @param order the order given by {@link DataSchemaRichContextTraverser} to tell whether this call happens during pre order or post order\n-     */\n-    void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order);\n-\n-    /**\n-     * {@link SchemaVisitor} implements this method to return an initial {@link VisitorContext}\n-     * {@link VisitorContext} will be stored inside {@link DataSchemaRichContextTraverser.TraverserContext} and then\n-     * passed to {@link SchemaVisitor} during recursive traversal\n-     *\n-     * @return an initial {@link VisitorContext} that will be stored by {@link SchemaVisitor}\n-     *\n-     * @see VisitorContext\n-     */\n-    VisitorContext getInitialVisitorContext();\n-\n-    /**\n-     * The visitor should store a {@link VisitorTraversalResult} which stores this visitor's traversal result.\n-     *\n-     * @return traversal result after the visitor traversed the schema\n-     */\n-    VisitorTraversalResult getVisitorTraversalResult();\n-  }\n-\n-  /**\n-   * A context that is defined and handled by {@link SchemaVisitor}\n-   *\n-   * The {@link DataSchemaRichContextTraverser} will get the initial context and then\n-   * passing this as part of {@link DataSchemaRichContextTraverser.TraverserContext}\n-   *\n-   * {@link SchemaVisitor} implementations can store customized information that want to pass during recursive traversal here\n-   * similar to how {@link DataSchemaRichContextTraverser.TraverserContext} is used.\n-   *\n-   * @see DataSchemaRichContextTraverser.TraverserContext\n-   */\n-  public interface VisitorContext\n+  private static class TraverserContextImpl implements TraverserContext", "originalCommit": "1fd0d3b81eae65e007f1fbacc532be73d3fc8946", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f1b4becf89c1f53d15247f974d636980a9b1cdb", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\nindex e9cf27a96..03551446c 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/DataSchemaRichContextTraverser.java\n\n@@ -209,164 +190,4 @@ public class DataSchemaRichContextTraverser\n            || (dataSchema.getType() == DataSchema.Type.FIXED)\n            || (dataSchema.getType() == DataSchema.Type.ENUM);\n   }\n-\n-  private static class TraverserContextImpl implements TraverserContext\n-  {\n-    private Boolean _shouldContinue = null;\n-    private DataSchema _parentSchema;\n-    private DataSchema _currentSchema;\n-    private DataSchema _originalTopLevelSchema;\n-    private ArrayDeque<String> _traversePath = new ArrayDeque<>();\n-    private ArrayDeque<String> _schemaPathSpec = new ArrayDeque<>();\n-    private RecordDataSchema.Field _enclosingField;\n-    private UnionDataSchema.Member _enclosingUnionMember;\n-    private CurrentSchemaEntryMode _currentSchemaEntryMode;\n-    private SchemaVisitor.VisitorContext _visitorContext;\n-\n-    @Override\n-    public SchemaVisitor.VisitorContext getVisitorContext()\n-    {\n-      return _visitorContext;\n-    }\n-\n-    /**\n-     * Generate a new {@link TraverserContext} for next recursion in {@link DataSchemaRichContextTraverser#doRecursiveTraversal(TraverserContextImpl)}\n-     *\n-     * @param nextTraversePathComponent pathComponent of the traverse path of the next dataSchema to be traversed\n-     * @param nextSchemaPathSpecComponent pathComponent of the schema path of the next dataSchema to be traversed\n-     * @param nextSchema the next dataSchema to be traversed\n-     * @param nextSchemaEntryMode how next dataSchema is linked from current dataSchema.\n-     * @return a new {@link TraverserContext} generated for next recursion\n-     */\n-    private TraverserContextImpl getNextContext(String nextTraversePathComponent, String nextSchemaPathSpecComponent,\n-                                    DataSchema nextSchema, CurrentSchemaEntryMode nextSchemaEntryMode)\n-    {\n-      TraverserContextImpl nextContext = new TraverserContextImpl();\n-      nextContext.setOriginalTopLevelSchema(this.getTopLevelSchema());\n-      nextContext.setParentSchema(this.getCurrentSchema());\n-      nextContext.setSchemaPathSpec(new ArrayDeque<>(this.getSchemaPathSpec()));\n-      nextContext.setVisitorContext(this.getVisitorContext());\n-      nextContext.setEnclosingField(this.getEnclosingField());\n-      nextContext.setEnclosingUnionMember(this.getEnclosingUnionMember());\n-\n-      // Need to make a copy so if it is modified in next recursion\n-      // it won't affect this recursion\n-      nextContext.setTraversePath(new ArrayDeque<>(this.getTraversePath()));\n-      nextContext.getTraversePath().add(nextTraversePathComponent);\n-      // Same as traversePath, we need to make a copy.\n-      nextContext.setSchemaPathSpec(new ArrayDeque<>(this.getSchemaPathSpec()));\n-      // SchemaPathSpecComponent could be null if nextSchema is a TypeRefDataSchema\n-      if (nextSchemaPathSpecComponent != null)\n-      {\n-        nextContext.getSchemaPathSpec().add(nextSchemaPathSpecComponent);\n-      }\n-      nextContext.setCurrentSchema(nextSchema);\n-      nextContext.setCurrentSchemaEntryMode(nextSchemaEntryMode);\n-      return nextContext;\n-    }\n-\n-    private void setOriginalTopLevelSchema(DataSchema originalTopLevelSchema)\n-    {\n-      _originalTopLevelSchema = originalTopLevelSchema;\n-    }\n-\n-    public Boolean shouldContinue()\n-    {\n-      return _shouldContinue;\n-    }\n-\n-    @Override\n-    public void setShouldContinue(Boolean shouldContinue)\n-    {\n-      this._shouldContinue = shouldContinue;\n-    }\n-\n-    public void setVisitorContext(SchemaVisitor.VisitorContext visitorContext)\n-    {\n-      _visitorContext = visitorContext;\n-    }\n-\n-    @Override\n-    public DataSchema getTopLevelSchema()\n-    {\n-      return _originalTopLevelSchema;\n-    }\n-\n-    @Override\n-    public ArrayDeque<String> getSchemaPathSpec()\n-    {\n-      return _schemaPathSpec;\n-    }\n-\n-    private void setSchemaPathSpec(ArrayDeque<String> schemaPathSpec)\n-    {\n-      _schemaPathSpec = schemaPathSpec;\n-    }\n-\n-    @Override\n-    public DataSchema getCurrentSchema()\n-    {\n-      return _currentSchema;\n-    }\n-\n-    private void setCurrentSchema(DataSchema currentSchema)\n-    {\n-      _currentSchema = currentSchema;\n-    }\n-\n-    @Override\n-    public ArrayDeque<String> getTraversePath()\n-    {\n-      return _traversePath;\n-    }\n-\n-    private void setTraversePath(ArrayDeque<String> traversePath)\n-    {\n-      this._traversePath = traversePath;\n-    }\n-\n-    @Override\n-    public DataSchema getParentSchema()\n-    {\n-      return _parentSchema;\n-    }\n-\n-    private void setParentSchema(DataSchema parentSchema)\n-    {\n-      _parentSchema = parentSchema;\n-    }\n-\n-    @Override\n-    public RecordDataSchema.Field getEnclosingField()\n-    {\n-      return _enclosingField;\n-    }\n-\n-    private void setEnclosingField(RecordDataSchema.Field enclosingField)\n-    {\n-      _enclosingField = enclosingField;\n-    }\n-\n-    @Override\n-    public UnionDataSchema.Member getEnclosingUnionMember()\n-    {\n-      return _enclosingUnionMember;\n-    }\n-\n-    private void setEnclosingUnionMember(UnionDataSchema.Member enclosingUnionMember)\n-    {\n-      _enclosingUnionMember = enclosingUnionMember;\n-    }\n-\n-    @Override\n-    public CurrentSchemaEntryMode getCurrentSchemaEntryMode()\n-    {\n-      return _currentSchemaEntryMode;\n-    }\n-\n-    private void setCurrentSchemaEntryMode(CurrentSchemaEntryMode currentSchemaEntryMode)\n-    {\n-      _currentSchemaEntryMode = currentSchemaEntryMode;\n-    }\n-  }\n }\n"}}, {"oid": "4eb3f35b411bb03ff6e224bfb7236dd648ada911", "url": "https://github.com/linkedin/rest.li/commit/4eb3f35b411bb03ff6e224bfb7236dd648ada911", "message": "Edit javadocs in TraverserContext", "committedDate": "2020-03-06T03:03:25Z", "type": "commit"}, {"oid": "2f1b4becf89c1f53d15247f974d636980a9b1cdb", "url": "https://github.com/linkedin/rest.li/commit/2f1b4becf89c1f53d15247f974d636980a9b1cdb", "message": "Address Karthik's comment", "committedDate": "2020-03-06T03:20:58Z", "type": "commit"}, {"oid": "5f61dbb1a31a0e94ab3656c79d45c0662b57c9b9", "url": "https://github.com/linkedin/rest.li/commit/5f61dbb1a31a0e94ab3656c79d45c0662b57c9b9", "message": "Adjust a type", "committedDate": "2020-03-06T03:26:42Z", "type": "commit"}, {"oid": "d2ea02806c513c35432d6876a8613387f59deaad", "url": "https://github.com/linkedin/rest.li/commit/d2ea02806c513c35432d6876a8613387f59deaad", "message": "Merge branch 'master' into captain_proj_support", "committedDate": "2020-03-06T08:11:51Z", "type": "commit"}]}