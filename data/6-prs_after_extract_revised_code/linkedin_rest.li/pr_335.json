{"pr_number": 335, "pr_title": "Supply default values in restli response if the return data does not have it", "pr_createdAt": "2020-06-20T01:53:41Z", "pr_url": "https://github.com/linkedin/rest.li/pull/335", "timeline": [{"oid": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "url": "https://github.com/linkedin/rest.li/commit/29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-06-22T17:32:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTk3NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443829974", "bodyText": "combine these 2 conditions in one statement", "author": "aman1309", "createdAt": "2020-06-22T21:13:58Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,20 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQxNTQ3OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444415479", "bodyText": "Since I added the else section, it seems to me it is ok to keep it separate?", "author": "BrianPin", "createdAt": "2020-06-23T18:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgyOTk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443831615", "bodyText": "can you add integration test for this to test based on query param", "author": "aman1309", "createdAt": "2020-06-22T21:17:22Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQzNzQ0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444437444", "bodyText": "+1, you can probably just add extra test cases to existing integration tests", "author": "evanw555", "createdAt": "2020-06-23T18:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTExNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447111117", "bodyText": "Integration test is added", "author": "BrianPin", "createdAt": "2020-06-29T16:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMTYxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex 02a8fd91b..e2d721867 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n\n@@ -62,6 +62,9 @@ public class TestRestLiDefaultInResponse\n     recordBField2DefaultValues.add(\"defaultValue1\");\n     recordBField2DefaultValues.add(\"defaultValue2\");\n     recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+    DataMap personalRecordD = new DataMap();\n+    personalRecordD.put(\"field3\", 0L);\n+    personalRecordD.put(\"field4\", \"default\");\n \n     return new Object[][]{\n         {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMjkzNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443832935", "bodyText": "$sendDefaults, doc was updated to add $ as prefix to not conflict with other fields.\nAlso, can you move it to as constant instead of hard coding here", "author": "aman1309", "createdAt": "2020-06-22T21:20:16Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +117,19 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(\"sendDefaults\") &&", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExMTI3MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447111270", "bodyText": "this is updated", "author": "BrianPin", "createdAt": "2020-06-29T16:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMjkzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443833719", "bodyText": "move this inside if statement if we have fill defaults", "author": "aman1309", "createdAt": "2020-06-22T21:21:55Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +117,19 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MjYzMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444442632", "bodyText": "+1, logic is only necessary when needed", "author": "evanw555", "createdAt": "2020-06-23T19:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzOTU5Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444539592", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-06-23T22:17:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzMzcxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -125,8 +131,9 @@ public class ResponseUtils\n       }\n \n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(\"sendDefaults\") &&\n-          (Boolean) context.getParameters().get(\"sendDefaults\") && dataSchema != null)\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n+          dataSchema != null)\n       {\n         getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgzNDI5OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r443834299", "bodyText": "as discussed update this logic to fill nested defaults if field value is not null", "author": "aman1309", "createdAt": "2020-06-22T21:23:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,20 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)\n+        {\n+          dataMap.put(field.getName(), field.getDefault());", "originalCommit": "29c278bb6d8e2b9b63019cf0602dcd8db56a9455", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "89a6060586011c826a2609468bd2c969f6aa3f35", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 09bbef46a..ae3975e7d 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -100,6 +96,16 @@ public class ResponseUtils\n         {\n           dataMap.put(field.getName(), field.getDefault());\n         }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();\n+          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          {\n+            DataMap fieldDataMap = new DataMap();\n+            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n+            dataMap.put(field.getName(), fieldDataMap);\n+          }\n+        }\n       }\n     }\n   }\n"}}, {"oid": "bb55c5b526dcc244bcbb2463b41d5de338188168", "url": "https://github.com/linkedin/rest.li/commit/bb55c5b526dcc244bcbb2463b41d5de338188168", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-06-22T23:13:34Z", "type": "forcePushed"}, {"oid": "89a6060586011c826a2609468bd2c969f6aa3f35", "url": "https://github.com/linkedin/rest.li/commit/89a6060586011c826a2609468bd2c969f6aa3f35", "message": "Address Aman's comment about recursive resolve default values for record and fix the query key for this feature", "committedDate": "2020-06-23T18:10:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MTMwNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444441305", "bodyText": "I'd suggest renaming this to something like fillInDefaultValues, since get... seems to imply it's a side effect-less get accessor. Also add a javadoc since it's a public method (alternatively consider reducing to private/p-private)", "author": "evanw555", "createdAt": "2020-06-23T18:59:17Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +86,30 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUzNTEyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444535123", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-06-23T22:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MTMwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzU0Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444443543", "bodyText": "Consider moving this logic to the ResourceContext interface. This is what I did for ResourceContext#isReturnEntityRequested rather than directly looking at the parameters.", "author": "evanw555", "createdAt": "2020-06-23T19:03:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -97,7 +123,20 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n+      DataSchema dataSchema = null;\n+      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+      if (valueClass != null)\n+      {\n+        dataSchema = DataTemplateUtil.getSchema(valueClass);\n+      }\n+\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzM3Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444543372", "bodyText": "Yeah that makes the code consistent, thanks", "author": "BrianPin", "createdAt": "2020-06-23T22:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzU0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -123,19 +148,15 @@ public class ResponseUtils\n                                                          .getResourceEntityType();\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n-      DataSchema dataSchema = null;\n-      Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-      if (valueClass != null)\n-      {\n-        dataSchema = DataTemplateUtil.getSchema(valueClass);\n-      }\n-\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.getParameters().containsKey(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          (Boolean) context.getParameters().get(RestConstants.FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM) &&\n-          dataSchema != null)\n+      if (context.isDefaultValueFillInRequested())\n       {\n-        getAbsentFieldsDefaultValues((RecordDataSchema) dataSchema, dataMap);\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          fillInDefaultValues(dataSchema, dataMap);\n+        }\n       }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0MzY3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444443678", "bodyText": "nit: add newline", "author": "evanw555", "createdAt": "2020-06-23T19:03:36Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..b5dce7cec 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n\n@@ -19,17 +19,13 @@ import com.google.common.collect.ImmutableMap;\n import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n import com.linkedin.data.schema.RecordDataSchema;\n import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n-import java.io.IOException;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n import org.testng.annotations.BeforeTest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444444622", "bodyText": "What's the purpose of this change?", "author": "evanw555", "createdAt": "2020-06-23T19:05:25Z", "path": "restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java", "diffHunk": "@@ -1210,7 +1210,7 @@ public FixedTemplatePlaceholder(Object object, FixedDataSchema schema)\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(RecordTemplatePlaceholder.class,", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ4MTU2MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444481561", "bodyText": "This is good question, so when I do gradle test, this test class failed because it uses the RecordTemplatePlaceholder and it is not a real template,  on the other hand, in my newly added code, i need to have a fully function resource model instance.\nroutingResult.getResourceMethod().getResourceModel().getValueClass();\n\nIf we keep using the RecordTemplatePlaceholder, we will get an exception.\nThe ResourceModel takes an RecordTemplate as the input, the change from  RecordTemplatePlaceholder  to use resourceSchema seems to be a perfect fit. It is needed to say, I don't know why the original code uses the RecordTemplatePlaceholder rather than the real resourceSchema", "author": "BrianPin", "createdAt": "2020-06-23T20:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2OTgxMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r445169812", "bodyText": "I don't think this is a good idea. Using a random record type like ResourceSchema is misleading and made me believe that this logic is inherently related to resource schemas. I'd suggest you do one of two things:\n\nBe explicit about using a dummy record by using something like EmptyRecord.\nFix the issue in RecordTemplatePlaceholder, this is an easy fix, since you can just define the schema as new RecordDataSchema(new Name(RecordTemplatePlaceholder.class.getCanonicalName()), RecordDataSchema.RecordType.RECORD).", "author": "evanw555", "createdAt": "2020-06-24T21:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ5ODEyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447498123", "bodyText": "I removed the change, it looks like I no longer need this change anymore. Will notice your suggestion next time when same situation happen", "author": "BrianPin", "createdAt": "2020-06-30T08:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0NDYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\nindex d0d932cae..21976e6e5 100644\n--- a/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n+++ b/restli-docgen/src/main/java/com/linkedin/restli/docgen/examplegen/ExampleRequestResponseGenerator.java\n\n@@ -1210,7 +1210,7 @@ public class ExampleRequestResponseGenerator\n \n   private static ResourceModel buildPlaceholderResourceModel(ResourceSchema resourceSchema)\n   {\n-    return new ResourceModel(ResourceSchema.class,\n+    return new ResourceModel(RecordTemplatePlaceholder.class,\n         Object.class,\n         null,\n         resourceSchema.getName(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0Njk1Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444446956", "bodyText": "Move to com.linkedin.restli.internal.server.response to be aligned with the location of ResponseUtils", "author": "evanw555", "createdAt": "2020-06-23T19:09:22Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..b5dce7cec 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n\n@@ -19,17 +19,13 @@ import com.google.common.collect.ImmutableMap;\n import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n import com.linkedin.data.schema.RecordDataSchema;\n import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n-import java.io.IOException;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n import org.testng.annotations.BeforeTest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0ODA5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444448097", "bodyText": "Consider renaming this to just be TestResponseUtils to be aligned with the class it's testing.", "author": "evanw555", "createdAt": "2020-06-23T19:11:32Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..b5dce7cec 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n\n@@ -19,17 +19,13 @@ import com.google.common.collect.ImmutableMap;\n import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n import com.linkedin.data.schema.RecordDataSchema;\n import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n-import java.io.IOException;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n import org.testng.annotations.BeforeTest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ0ODMzNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444448337", "bodyText": "Consider renaming this to TestGetAbsentFieldsDefaultValues to be aligned with the method it's testing. If you rename that method, rename this test accordingly.", "author": "evanw555", "createdAt": "2020-06-23T19:12:03Z", "path": "restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.server.test;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.NamedDataSchema;\n+import com.linkedin.data.schema.RecordDataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.SchemaParserFactory;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.response.ResponseUtils;\n+import java.io.File;\n+import java.io.IOException;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestRestLiDefaultInResponse\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    DataList recordBField1 = new DataList(1);\n+    recordBField1.add(-1);\n+\n+    DataMap recordBField2 = new DataMap();\n+    DataList recordBField2DefaultValues = new DataList(2);\n+    recordBField2DefaultValues.add(\"defaultValue1\");\n+    recordBField2DefaultValues.add(\"defaultValue2\");\n+    recordBField2.put(\"defaultKey\", recordBField2DefaultValues);\n+    DataMap personalRecordD = new DataMap();\n+    personalRecordD.put(\"field3\", 0L);\n+    personalRecordD.put(\"field4\", \"default\");\n+\n+    return new Object[][]{\n+        {\n+            \"RecordA.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", 1)\n+                .put(\"field2\", \"2\")\n+                .put(\"field3\", 0L)\n+                .put(\"field4\", \"default\")\n+                .build())\n+        },\n+        {\n+            \"RecordB.pdl\",\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .build()),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"field1\", recordBField1)\n+                .put(\"field2\", recordBField2)\n+                .build())\n+        },\n+        {\n+            \"RecordC.pdl\",\n+            new DataMap(),\n+            new DataMap(new ImmutableMap.Builder<String, Object>()\n+                .put(\"name\", \"default+\")\n+                .put(\"personalRecordD\", personalRecordD)\n+                .build()),\n+        }\n+    };\n+  }\n+\n+  @Test(dataProvider = \"default_serialization\")\n+  public void testSerializingDefaultValue(String filename, DataMap data, DataMap expected)", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\nindex e2d721867..b5dce7cec 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/server/test/TestRestLiDefaultInResponse.java\n\n@@ -19,17 +19,13 @@ import com.google.common.collect.ImmutableMap;\n import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.data.schema.DataSchema;\n-import com.linkedin.data.schema.NamedDataSchema;\n import com.linkedin.data.schema.RecordDataSchema;\n import com.linkedin.data.schema.SchemaFormatType;\n-import com.linkedin.data.schema.SchemaParserFactory;\n import com.linkedin.data.schema.generator.AbstractGenerator;\n-import com.linkedin.data.schema.resolver.FileDataSchemaResolver;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.response.ResponseUtils;\n import java.io.File;\n-import java.io.IOException;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n import org.testng.annotations.BeforeTest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444542146", "bodyText": "test this for typerefs", "author": "aman1309", "createdAt": "2020-06-23T22:24:58Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +86,30 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  {\n+    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    {\n+      if (!dataMap.containsKey(field.getName()))\n+      {\n+        if (field.getDefault() != null)\n+        {\n+          dataMap.put(field.getName(), field.getDefault());\n+        }\n+        else\n+        {\n+          DataSchema fieldSchema = field.getType();", "originalCommit": "89a6060586011c826a2609468bd2c969f6aa3f35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxODkyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r444618923", "bodyText": "Got an exception:\njava.lang.ClassCastException: com.linkedin.data.schema.TyperefDataSchema cannot be cast to com.linkedin.data.schema.RecordDataSchema", "author": "BrianPin", "createdAt": "2020-06-24T03:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMTc0OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447131748", "bodyText": "yeah, you might want to use dereferenced schema for typerefs", "author": "aman1309", "createdAt": "2020-06-29T17:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDAyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447510023", "bodyText": "Resolved this, Aman!", "author": "BrianPin", "createdAt": "2020-06-30T08:34:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MjE0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex ae3975e7d..12852f4e7 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -86,24 +90,45 @@ public class ResponseUtils\n     }\n   }\n \n-  public static void getAbsentFieldsDefaultValues(RecordDataSchema dataSchema, DataMap dataMap)\n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    for (RecordDataSchema.Field field : dataSchema.getFields())\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n     {\n-      if (!dataMap.containsKey(field.getName()))\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (field.getDefault() != null)\n+        if (!dataMap.containsKey(field.getName()))\n         {\n-          dataMap.put(field.getName(), field.getDefault());\n-        }\n-        else\n-        {\n-          DataSchema fieldSchema = field.getType();\n-          if (fieldSchema != null && !fieldSchema.isPrimitive())\n+          if (field.getDefault() != null)\n           {\n-            DataMap fieldDataMap = new DataMap();\n-            getAbsentFieldsDefaultValues((RecordDataSchema) fieldSchema, fieldDataMap);\n-            dataMap.put(field.getName(), fieldDataMap);\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n           }\n         }\n       }\n"}}, {"oid": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "url": "https://github.com/linkedin/rest.li/commit/49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "message": "Address comment: integration test and recursive resolve and typeref test", "committedDate": "2020-06-25T23:26:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NzE0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r446047144", "bodyText": "You need to handle the else part for this.", "author": "karthikbalasub", "createdAt": "2020-06-26T08:35:49Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,51 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        if (!dataMap.containsKey(field.getName()))", "originalCommit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1Mzc0NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r446053744", "bodyText": "This is not needed. You need to traverse the nested schemas only if the value is present at the top-level.\nConsider this:\nrecord Foo {\n  f1: int = 5\n  f2: optional int\n }\n\nrecord Bar {\n   b1: Foo = { f2: 10 }\n   b2: optional Foo\n   b3: Foo\n}\n\n\nSo the scenarios are (top-level is Bar):\n1.\n{\n  b1: {\n    f1: 1\n  },\n  b2: {}\n}\n\n\nOutput with defaults filled in should be:\n{\n  b1: {\n    f1: 1\n  },\n   b2: {\n    f1: 5,     // Filled using default value in Foo\n  }\n}\n\n\nb3 is not present in the input data and so shouldn't be filled in.\n\n\n\n{\n  b3: {\n    f2: 1\n  }\n}\n\n\nOutput with defaults filled in should be:\n{\n b1: {.         // Filled because of default value in Bar\n   f1: 5,        // Filled using default value in Foo\n    f2: 10     // Filled using default value in Bar\n  },\n  b3: {\n    f1: 5,     // Filled using default value in Foo\n    f2: 1\n  }\n}\n\n\nBasically, fill in the defaults for fields only if the record is present or record is filled in using a default. Do not create a record only because a nested field specifies default value.", "author": "karthikbalasub", "createdAt": "2020-06-26T08:48:56Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +90,51 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * This function will look at the dataSchema to see missing fields in the dataMap.\n+   * If the missing field is provided with default values, this function will populate the dataMap\n+   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n+   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n+   * This feature is controlled by:\n+   * Client: add this query parameter in the URL: $sendDefaults=true\n+   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n+   * The feature is controlled\n+   * @param dataSchema a RecordDataSchema that matches the dataMap\n+   * @param dataMap the actual data of the argument dataSchema\n+   */\n+  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        if (!dataMap.containsKey(field.getName()))\n+        {\n+          if (field.getDefault() != null)\n+          {\n+            dataMap.put(field.getName(), field.getDefault());\n+          }\n+          else\n+          {\n+            DataSchema fieldSchema = field.getType();\n+            if (fieldSchema instanceof RecordDataSchema)\n+            {\n+              DataMap fieldDataMap = new DataMap();\n+              fillInDefaultValues(fieldSchema, fieldDataMap);\n+              dataMap.put(field.getName(), fieldDataMap);\n+            }\n+          }", "originalCommit": "49197c74db32fdb4f4e839e88e7a81eb0ae8e383", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NTI1MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447875251", "bodyText": "I think this is addressed, had put exact same cases in test", "author": "BrianPin", "createdAt": "2020-06-30T17:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1Mzc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 12852f4e7..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -91,48 +93,92 @@ public class ResponseUtils\n   }\n \n   /**\n-   * This function will look at the dataSchema to see missing fields in the dataMap.\n-   * If the missing field is provided with default values, this function will populate the dataMap\n-   * with the key and the default value. If the missing field is not primitive (meaning itself is a\n-   * RecordDataSchema) then this function will recursively to fill default values of that field as a record.\n-   * This feature is controlled by:\n-   * Client: add this query parameter in the URL: $sendDefaults=true\n-   * Server: put true to RestLiConfig::isResponseSendDefaultValues\n-   * The feature is controlled\n-   * @param dataSchema a RecordDataSchema that matches the dataMap\n-   * @param dataMap the actual data of the argument dataSchema\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n    */\n-  public static void fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n     if (dataSchema instanceof TyperefDataSchema)\n     {\n       TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n-      fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataMap);\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n     }\n     else if (dataSchema instanceof RecordDataSchema)\n     {\n       RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n       for (RecordDataSchema.Field field : recordDataSchema.getFields())\n       {\n-        if (!dataMap.containsKey(field.getName()))\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+            dataDefaultFilled.put(field.getName(), fieldFilled);\n+          }\n+          else if (field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(fieldSchema, (DataMap) field.getDefault()));\n+          }\n+        }\n+        else if (fieldSchema instanceof TyperefDataSchema)\n         {\n-          if (field.getDefault() != null)\n+          DataSchema dereferencedDataSchema = fieldSchema.getDereferencedDataSchema();\n+          if (dataDefaultFilled.containsKey(field.getName()) && dereferencedDataSchema instanceof RecordDataSchema)\n           {\n-            dataMap.put(field.getName(), field.getDefault());\n+            dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                (DataMap) dataDefaultFilled.get(field.getName())));\n           }\n-          else\n+          else if (field.getDefault() != null)\n           {\n-            DataSchema fieldSchema = field.getType();\n-            if (fieldSchema instanceof RecordDataSchema)\n+            if (dereferencedDataSchema instanceof RecordDataSchema)\n             {\n-              DataMap fieldDataMap = new DataMap();\n-              fillInDefaultValues(fieldSchema, fieldDataMap);\n-              dataMap.put(field.getName(), fieldDataMap);\n+              dataDefaultFilled.put(field.getName(), fillInDefaultValues(dereferencedDataSchema,\n+                  (DataMap) field.getDefault()));\n             }\n+            else\n+            {\n+              dataDefaultFilled.put(field.getName(), field.getDefault());\n+            }\n+          }\n+        }\n+        else // primitive | complex data schemas of this field in the record\n+        {\n+          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n+          {\n+            dataDefaultFilled.put(field.getName(), field.getDefault());\n           }\n         }\n       }\n+      return dataDefaultFilled;\n     }\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMDg1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447530854", "bodyText": "If you change this to a create with return entity, then you can controll the data being returned (by sending it for create) and thus can test multiple scenarios", "author": "karthikbalasub", "createdAt": "2020-06-30T09:06:38Z", "path": "restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.linkedin.restli.examples.greetings.server.defaults;\n+\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.server.annotations.RestLiCollection;\n+import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+\n+\n+@RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n+public class FieldFillInDefaultResources extends CollectionResourceTemplate<Long, HighLevelRecordWithDefault>\n+{\n+  @Override\n+  public HighLevelRecordWithDefault get(Long keyId)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDg1NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447874855", "bodyText": "ok", "author": "BrianPin", "createdAt": "2020-06-30T17:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMDg1NA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\nindex dfa578c84..0ee81a92a 100644\n--- a/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n+++ b/restli-int-test-server/src/main/java/com/linkedin/restli/examples/greetings/server/defaults/FieldFillInDefaultResources.java\n\n@@ -1,8 +1,29 @@\n package com.linkedin.restli.examples.greetings.server.defaults;\n \n+import com.linkedin.restli.common.HttpStatus;\n import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import com.linkedin.restli.examples.greetings.api.Empty;\n+import com.linkedin.restli.server.ActionResult;\n+import com.linkedin.restli.server.BatchFinderResult;\n+import com.linkedin.restli.server.CollectionResult;\n+import com.linkedin.restli.server.PagingContext;\n+import com.linkedin.restli.server.annotations.Action;\n+import com.linkedin.restli.server.annotations.ActionParam;\n+import com.linkedin.restli.server.annotations.BatchFinder;\n+import com.linkedin.restli.server.annotations.Finder;\n+import com.linkedin.restli.server.annotations.PagingContextParam;\n+import com.linkedin.restli.server.annotations.QueryParam;\n import com.linkedin.restli.server.annotations.RestLiCollection;\n import com.linkedin.restli.server.resources.CollectionResourceTemplate;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import sun.util.resources.cldr.ha.CalendarData_ha_Latn_GH;\n \n \n @RestLiCollection(name = \"fillInDefaults\", namespace = \"com.linkedin.restli.examples.defaults.api\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTUyMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447531522", "bodyText": "Complete the doc, I think it would be useful to provide the pseudo code you had in the doc.", "author": "karthikbalasub", "createdAt": "2020-06-30T09:07:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTgzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447531831", "bodyText": "Why do you need to copy?", "author": "karthikbalasub", "createdAt": "2020-06-30T09:08:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3NDQ2MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447874460", "bodyText": "It is for return, If I don't return a DataMap, then for non existing field that has a default value, I will need to pass in a DataMap for putting data.", "author": "BrianPin", "createdAt": "2020-06-30T17:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMTgzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzY3MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447533670", "bodyText": "redundant as the containsKey check above ensures the value wouldn't be null", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:01Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDIzOA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447870238", "bodyText": "yes", "author": "BrianPin", "createdAt": "2020-06-30T17:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzY3MA=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzg4OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447533889", "bodyText": "redundant as you are updating the field value inplace", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:20Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2OTM2NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447869365", "bodyText": "Just to be sure I get you correctly, I don't get why this is redundant, because as for now it is not in place yet.", "author": "BrianPin", "createdAt": "2020-06-30T17:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzMzg4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDE4Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447534182", "bodyText": "Non reachable code block", "author": "karthikbalasub", "createdAt": "2020-06-30T09:11:47Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)\n+        {\n+          if (dataDefaultFilled.containsKey(field.getName()))\n+          {\n+            DataMap fieldDefault = (DataMap) field.getDefault();\n+            DataMap fieldDataAssigned = (DataMap) dataDefaultFilled.get(field.getName());\n+            if (fieldDataAssigned != null)\n+            {\n+              DataMap fieldFilled = fillInDefaultValues(fieldSchema, fieldDataAssigned);\n+              dataDefaultFilled.put(field.getName(), fieldFilled);\n+            }\n+            else if (fieldDefault != null)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg3MDEwOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447870109", "bodyText": "agree, will make fix", "author": "BrianPin", "createdAt": "2020-06-30T17:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDE4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447535229", "bodyText": "Why duplicate the logic for checking Record/Typeref again? Why not just make a recursive call for each field?", "author": "karthikbalasub", "createdAt": "2020-06-30T09:13:27Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +91,90 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   *\n+   * @param dataSchema\n+   * @param dataMap\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+\n+    if (dataSchema instanceof TyperefDataSchema)\n+    {\n+      TyperefDataSchema typerefDataSchema = (TyperefDataSchema) dataSchema;\n+      return fillInDefaultValues(typerefDataSchema.getDereferencedDataSchema(), dataDefaultFilled);\n+    }\n+    else if (dataSchema instanceof RecordDataSchema)\n+    {\n+      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n+      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      {\n+        DataSchema fieldSchema = field.getType();\n+        if (fieldSchema instanceof RecordDataSchema)", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2NTk2Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447865962", "bodyText": "good suggestion -> For each field, make a recursive call for its field schema and data, to make code shorter", "author": "BrianPin", "createdAt": "2020-06-30T17:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MzA5OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r449273098", "bodyText": "I found here it is needed to differentiate the case but I do changed the code for the redundant logic of checking assigned field. but for this part about \"record field and typeref field logic redundancy\" I feel I can not change it because there are some logic necessary, let me know!", "author": "BrianPin", "createdAt": "2020-07-02T21:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTUyNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454615524", "bodyText": "I think you can simplify the logic by reversing the checks.\nFirst check and compute the field value:\nif( dataDefaultFilled.containsKey())\n   Object fieldData = // get data from datamap\nelse if field has default\n  fieldData = // get field default.\nelse\n  // continue (nothing to do).\n\nThen compute the default for the field by calling recursively:\nif fieldData instaceOf DataMap || instance of DataList\n  fieldData = fillInDefaults(fieldData, fieldSchema)\n\ndataDefaultFilled.put(fieldName, fieldData)", "author": "karthikbalasub", "createdAt": "2020-07-14T20:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNTIyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -92,9 +93,26 @@ public class ResponseUtils\n   }\n \n   /**\n-   *\n-   * @param dataSchema\n-   * @param dataMap\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n    * @return a new different data map that contains original data plus the default values\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzOTU4NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447539585", "bodyText": "I'm don't think this would work for batch, finder or action methods. Can you add test coverage for these?\nCheck the restli validator on response method to understand different response structures. I feel it might be easier to add the fill default logic in ResponseBuilders", "author": "karthikbalasub", "createdAt": "2020-06-30T09:20:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -98,6 +189,15 @@ public static RestResponse buildResponse(RoutingResult routingResult, RestLiResp\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n+      if (context.isDefaultValueFillInRequested())\n+      {\n+        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n+        if (valueClass != null)\n+        {\n+          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n+          dataMap = fillInDefaultValues(dataSchema, dataMap);", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2MzIyOA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447863228", "bodyText": "I saw there is a RestLiValidationFilter which implements Filter interface, it has a onResponse function,\nalso there are multiple **ResponseBuilders where they all share same interface RestLiResponseBuilder\nI don't know how to fit the fill-default in there yet, will dig deeper.", "author": "BrianPin", "createdAt": "2020-06-30T17:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzOTU4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 0dba9f8e3..c3b27b521 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -189,15 +195,6 @@ public class ResponseUtils\n     if (restLiResponse.hasData() && ResourceEntityType.STRUCTURED_DATA == resourceEntityType)\n     {\n       DataMap dataMap = restLiResponse.getDataMap();\n-      if (context.isDefaultValueFillInRequested())\n-      {\n-        Class<? extends RecordTemplate> valueClass = routingResult.getResourceMethod().getResourceModel().getValueClass();\n-        if (valueClass != null)\n-        {\n-          DataSchema dataSchema = DataTemplateUtil.getSchema(valueClass);\n-          dataMap = fillInDefaultValues(dataSchema, dataMap);\n-        }\n-      }\n       String mimeType = context.getResponseMimeType();\n       URI requestUri = context.getRequestURI();\n       Map<String, String> requestHeaders = context.getRequestHeaders();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MDMxNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447940317", "bodyText": "I'd suggest renaming this to be consistent with the terminology used elsewhere in this PR. String FILL_DEFAULTS_PARAM = \"$fillDefaults\"; or String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\"", "author": "evanw555", "createdAt": "2020-06-30T19:52:13Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java", "diffHunk": "@@ -77,6 +77,7 @@\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex 37758a929..a2b8a1c0f 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n\n@@ -77,7 +77,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_DEFAULT_VALUE_IN_RESPONSE_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0MTk5Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r447941992", "bodyText": "This is a mouthful. I'd suggest renaming to isFillDefaultsRequested or isFillInDefaultsRequested", "author": "evanw555", "createdAt": "2020-06-30T19:55:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java", "diffHunk": "@@ -220,4 +220,15 @@\n    * @return whether the request specifies that the resource should return an entity\n    */\n   boolean isReturnEntityRequested();\n-}\n\\ No newline at end of file\n+\n+  /**\n+   * This is to determine whether the service will fill in default values when the returned value record has some missing\n+   * field. In case:\n+   * 1. the client is requesting that the default value to be returned. Reads the appropriate\n+   * query parameter to determine this information, defaults to false if the query parameter isn't present.\n+   * 2. the server is configured to return default value for every request-response pair\n+   * @return true if the service need to fill in default value when the field of the return value record is absent\n+   */\n+  boolean isDefaultValueFillInRequested();", "originalCommit": "1c6cb1b990f07b29190506fb1fb283d7e22a533c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\nindex 3acb4a94c..269d659a6 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/ResourceContext.java\n\n@@ -229,6 +229,6 @@ public interface ResourceContext extends CustomRequestContext\n    * 2. the server is configured to return default value for every request-response pair\n    * @return true if the service need to fill in default value when the field of the return value record is absent\n    */\n-  boolean isDefaultValueFillInRequested();\n+  boolean isFillInDefaultsRequested();\n }\n \n"}}, {"oid": "bc7fb8498fbed875417ca1926bb6bdc3560c144d", "url": "https://github.com/linkedin/rest.li/commit/bc7fb8498fbed875417ca1926bb6bdc3560c144d", "message": "address Karthiks comment about right place to fill in default, also review the logic of filling defaults", "committedDate": "2020-07-02T21:13:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMTYwNg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454521606", "bodyText": "Suggest changing the param to $fillInDefaults to be consistent", "author": "karthikbalasub", "createdAt": "2020-07-14T17:27:16Z", "path": "restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java", "diffHunk": "@@ -77,6 +77,7 @@\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE0Mzg5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r457143897", "bodyText": "Yeah, will also need to change design doc", "author": "BrianPin", "createdAt": "2020-07-20T07:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyMTYwNg=="}], "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\nindex a886f9bde..a2b8a1c0f 100644\n--- a/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n+++ b/restli-common/src/main/java/com/linkedin/restli/common/RestConstants.java\n\n@@ -77,7 +77,7 @@ public interface RestConstants\n   String QUERY_BATCH_IDS_PARAM = \"ids\";\n   String FIELDS_PARAM = \"fields\";\n   String ALT_KEY_PARAM = \"altkey\";\n-  String FILL_IN_DEFAULTS_PARAM = \"$sendDefaults\";\n+  String FILL_IN_DEFAULTS_PARAM = \"$fillInDefaults\";\n   String METADATA_FIELDS_PARAM = \"metadataFields\";\n   String PAGING_FIELDS_PARAM = \"pagingFields\";\n   String RETURN_ENTITY_PARAM = \"$returnEntity\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MDQwNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454580405", "bodyText": "nit: remove the extra comma", "author": "karthikbalasub", "createdAt": "2020-07-14T19:07:00Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.ActionRequest;\n+import com.linkedin.restli.client.BatchFindRequest;\n+import com.linkedin.restli.client.BatchGetEntityRequest;\n+import com.linkedin.restli.client.FindRequest;\n+import com.linkedin.restli.client.GetAllRequest;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.response.BatchKVResponse;\n+import com.linkedin.restli.common.BatchFinderCriteriaResult;\n+import com.linkedin.restli.common.EntityResponse;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  private DataMap expectedTestData;\n+\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init(Collections.emptyList());\n+    expectedTestData = new DataMap();\n+    expectedTestData.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex e40135ff5..e452a7e01 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n\n@@ -15,6 +15,8 @@\n */\n package com.linkedin.restli.examples;\n \n+import com.linkedin.data.Data;\n+import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.r2.RemoteInvocationException;\n import com.linkedin.restli.client.ActionRequest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MTE1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454581154", "bodyText": "I suggest you test both scenarios: with fillInDefaults flag and without it.\nYou don't have to do it for all methods, just doing that for GET should be enough. For other methods, test only with fillInDefaults flag.", "author": "karthikbalasub", "createdAt": "2020-07-14T19:08:13Z", "path": "restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.examples;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.r2.RemoteInvocationException;\n+import com.linkedin.restli.client.ActionRequest;\n+import com.linkedin.restli.client.BatchFindRequest;\n+import com.linkedin.restli.client.BatchGetEntityRequest;\n+import com.linkedin.restli.client.FindRequest;\n+import com.linkedin.restli.client.GetAllRequest;\n+import com.linkedin.restli.client.GetRequest;\n+import com.linkedin.restli.client.response.BatchKVResponse;\n+import com.linkedin.restli.common.BatchFinderCriteriaResult;\n+import com.linkedin.restli.common.EntityResponse;\n+import com.linkedin.restli.common.RestConstants;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsGetRequestBuilder;\n+import com.linkedin.restli.examples.defaults.api.FillInDefaultsRequestBuilders;\n+import com.linkedin.restli.examples.defaults.api.HighLevelRecordWithDefault;\n+import com.linkedin.restli.examples.defaults.api.RecordCriteria;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ * @author Brian Pin\n+ */\n+public class TestFillInDefaultValue  extends RestLiIntegrationTest\n+{\n+  private DataMap expectedTestData;\n+\n+  @BeforeClass\n+  public void initClass() throws Exception\n+  {\n+    super.init(Collections.emptyList());\n+    expectedTestData = new DataMap();\n+    expectedTestData.put(\"intDefaultFieldB\", -1);\n+    DataMap case1MidLevelRecordWithDefault = new DataMap();\n+    case1MidLevelRecordWithDefault.put(\"intWithDefault\", 0);\n+    case1MidLevelRecordWithDefault.put(\"intWithoutDefault\", 0);\n+    DataMap case1LowLevelRecordWithDefault = new DataMap();\n+    case1LowLevelRecordWithDefault.put(\"nameWithDefault\", \"a\");\n+    case1LowLevelRecordWithDefault.put(\"nameWithoutDefault\", \"b\");\n+    case1MidLevelRecordWithDefault.put(\"lowLevelRecordWithDefault\", case1LowLevelRecordWithDefault);\n+    expectedTestData.put(\"midLevelRecordWithDefault\", case1MidLevelRecordWithDefault);\n+  }\n+\n+  @AfterClass\n+  public void shutDown() throws Exception\n+  {\n+    super.shutdown();\n+  }\n+\n+  @DataProvider(name = \"testGetData\")\n+  private Object[][] testGetData() throws CloneNotSupportedException\n+  {\n+    HighLevelRecordWithDefault expected = new HighLevelRecordWithDefault(expectedTestData.clone()).setNoDefaultFieldA(1);\n+    return new Object[][] {{1L, expected},};", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\nindex e40135ff5..e452a7e01 100644\n--- a/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n+++ b/restli-int-test/src/test/java/com/linkedin/restli/examples/TestFillInDefaultValue.java\n\n@@ -15,6 +15,8 @@\n */\n package com.linkedin.restli.examples;\n \n+import com.linkedin.data.Data;\n+import com.linkedin.data.DataList;\n import com.linkedin.data.DataMap;\n import com.linkedin.r2.RemoteInvocationException;\n import com.linkedin.restli.client.ActionRequest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4MzYzMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454583633", "bodyText": "remove", "author": "karthikbalasub", "createdAt": "2020-07-14T19:12:49Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n\n@@ -88,13 +88,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n         && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n       DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n       DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n       Object valueWithDefault = null;\n       try\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU5OTY3Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454599677", "bodyText": "Change to a log message (debug/info)", "author": "karthikbalasub", "createdAt": "2020-07-14T19:42:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n\n@@ -88,13 +88,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n         && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n       DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n       DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n       Object valueWithDefault = null;\n       try\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNDUyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454604525", "bodyText": "This section should be refactored to avoid duplication with the else block", "author": "karthikbalasub", "createdAt": "2020-07-14T19:51:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;\n+      }\n+      @SuppressWarnings(\"unchecked\")\n+      FieldDef<Object> actionReturnFieldDef =\n+          (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n+      final ActionResponse<?> actionResponse =\n+          new ActionResponse<>(valueWithDefault, actionReturnFieldDef, actionReturnRecordDataSchema);\n+      return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n\n@@ -88,13 +88,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n         && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n       DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n       DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n       Object valueWithDefault = null;\n       try\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNTU2NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454605564", "bodyText": "Avoid duplication", "author": "karthikbalasub", "createdAt": "2020-07-14T19:53:12Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java", "diffHunk": "@@ -153,9 +154,22 @@ else if (result.getErrors().containsKey(criteria))\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n-      response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(),\n-                                                         resourceContext.getProjectionMode(),\n-                                                         resourceContext.getProjectionMask())));\n+      if (resourceContext.isFillInDefaultsRequested())\n+      {\n+        DataMap elementData = elements.get(j).data();\n+        RecordDataSchema schema = elements.get(j).schema();\n+        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n+        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault,\n+            resourceContext.getProjectionMode(),\n+            resourceContext.getProjectionMask())));", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\nindex 45df1567e..feae705c2 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/BatchFinderResponseBuilder.java\n\n@@ -154,22 +154,15 @@ public class BatchFinderResponseBuilder\n     List<AnyRecord> response = new ArrayList<>(elements.size());\n     for (int j = 0; j < elements.size(); j++)\n     {\n+      DataMap elementData = elements.get(j).data();\n       if (resourceContext.isFillInDefaultsRequested())\n       {\n-        DataMap elementData = elements.get(j).data();\n         RecordDataSchema schema = elements.get(j).schema();\n-        DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(schema, elementData);\n-        response.add(new AnyRecord(RestUtils.projectFields(dataWithDefault,\n-            resourceContext.getProjectionMode(),\n-            resourceContext.getProjectionMask())));\n-\n-      }\n-      else\n-      {\n-        response.add(new AnyRecord(RestUtils.projectFields(elements.get(j).data(),\n-            resourceContext.getProjectionMode(),\n-            resourceContext.getProjectionMask())));\n+        elementData = ResponseUtils.fillInDefaultValues(schema, elementData);\n       }\n+      response.add(new AnyRecord(RestUtils.projectFields(elementData,\n+          resourceContext.getProjectionMode(),\n+          resourceContext.getProjectionMask())));\n     }\n     return response;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwNjgyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454606825", "bodyText": "When you fail to create the value instance, you should return 500 error, not fall back to value without default.", "author": "karthikbalasub", "createdAt": "2020-07-14T19:55:28Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java", "diffHunk": "@@ -85,12 +87,40 @@ public RestLiResponse buildResponse(RoutingResult routingResult,\n       status = HttpStatus.S_200_OK;\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n-    @SuppressWarnings(\"unchecked\")\n-    FieldDef<Object> actionReturnFieldDef =\n-        (FieldDef<Object>) routingResult.getResourceMethod().getActionReturnFieldDef();\n-    final ActionResponse<?> actionResponse =\n-        new ActionResponse<>(value, actionReturnFieldDef, actionReturnRecordDataSchema);\n \n-    return new RestLiResponseDataImpl<>(new ActionResponseEnvelope(status, actionResponse), headers, cookies);\n+    if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n+        && routingResult.getContext().isFillInDefaultsRequested())\n+    {\n+      RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n+      DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n+      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n+          + actionResponseRecordTemplate.schema().getFullName());\n+      DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n+      Object valueWithDefault = null;\n+      try\n+      {\n+        valueWithDefault = (Object) value.getClass().getConstructor(DataMap.class).newInstance(dataWithDefault);\n+      }\n+      catch (Exception e)\n+      {\n+        System.out.println(\"Happened \" + e.getCause());\n+        valueWithDefault = value;", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\nindex ee039b3b9..f565b1ab5 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ActionResponseBuilder.java\n\n@@ -88,13 +88,12 @@ public class ActionResponseBuilder implements RestLiResponseBuilder<RestLiRespon\n     }\n     RecordDataSchema actionReturnRecordDataSchema = routingResult.getResourceMethod().getActionReturnRecordDataSchema();\n \n+    final Object actionResponseValue;\n     if (value != null && RecordTemplate.class.isAssignableFrom(value.getClass())\n         && routingResult.getContext().isFillInDefaultsRequested())\n     {\n       RecordTemplate actionResponseRecordTemplate = (RecordTemplate) value;\n       DataMap dataWithoutDefault = actionResponseRecordTemplate.data();\n-      System.out.println(\"Fill in default for action result \" + value.getClass().getSimpleName() + \", \"\n-          + actionResponseRecordTemplate.schema().getFullName());\n       DataMap dataWithDefault = ResponseUtils.fillInDefaultValues(actionResponseRecordTemplate.schema(), dataWithoutDefault);\n       Object valueWithDefault = null;\n       try\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYwOTkzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454609931", "bodyText": "Initialize with size computed using DataMapBuilder::getOptimumHashMapCapacityFromSize", "author": "karthikbalasub", "createdAt": "2020-07-14T20:01:11Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +92,95 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled = new DataMap();", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -117,11 +118,17 @@ public class ResponseUtils\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled = new DataMap();\n+\n+    DataMap dataDefaultFilled;\n     if (dataMap != null)\n     {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n       dataDefaultFilled.putAll(dataMap);\n     }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();\n+    }\n \n     if (dataSchema instanceof TyperefDataSchema)\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r454615927", "bodyText": "You would also need a method to handle DataLists. What if you have a field which is an array of records?", "author": "karthikbalasub", "createdAt": "2020-07-14T20:12:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +92,95 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)", "originalCommit": "9b36076077498e9ee0b42bc932ff470bc4ddb71f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MDk0NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r456960945", "bodyText": "For fields of array, in the code I assume the following case:\nCase 1 When the schema provide default\ntestFieldArray: array[MidLevelRecordWithDefault] = [{\"intWithDefault\": 0, \"intWithoutDefault\": 0}]\n\nCase 2 When schema does not have default\nIn case 1, I will just use the default provided.\nIn case 2, there will be no defaults filled in.\nI think this is an important case to discuss.\nI think whats the correct way might be: for a field that is an array, if there is no default provided restli provides no value with this field (This statement matches the example I pasted in design doc)\nIf there is default for an array field, I will just use the default.\nI think now the question is, is it just default provided on the schema or the element record all other default values?\nLet me know if this is wrong", "author": "BrianPin", "createdAt": "2020-07-19T22:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMzgyNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458003827", "bodyText": "You should follow the same behavior as complex fields.\n\nif field is not null, fill it with defaults from item's schema recursively.\nif field is null and schema provides default, use the default and fill it with defaults from the item's schema recursively.\nif field is null and not default provided, do nothin.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTkyNw=="}], "type": "inlineReview", "revised_code": {"commit": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c3b27b521..19fcd2134 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -117,11 +118,17 @@ public class ResponseUtils\n    */\n   public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled = new DataMap();\n+\n+    DataMap dataDefaultFilled;\n     if (dataMap != null)\n     {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n       dataDefaultFilled.putAll(dataMap);\n     }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();\n+    }\n \n     if (dataSchema instanceof TyperefDataSchema)\n     {\n"}}, {"oid": "c18cfcc93ec7698ccead9e1a483956c8160fff02", "url": "https://github.com/linkedin/rest.li/commit/c18cfcc93ec7698ccead9e1a483956c8160fff02", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-07-20T07:59:08Z", "type": "forcePushed"}, {"oid": "20edab3a4a167ffb434e6127da064e312c9dc4e0", "url": "https://github.com/linkedin/rest.li/commit/20edab3a4a167ffb434e6127da064e312c9dc4e0", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-07-20T17:41:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMTU3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458001578", "bodyText": "Add javadoc", "author": "karthikbalasub", "createdAt": "2020-07-21T10:38:52Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java", "diffHunk": "@@ -552,4 +555,14 @@ public void setValidateResourceKeys(boolean validateResourceKeys)\n     setMethodConfig(\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n+\n+  public boolean shouldFillInDefaultValues()", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 10603168d..26afccc5e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n\n@@ -556,11 +556,19 @@ public class RestLiConfig\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n \n+  /**\n+   * check config to see if the data in result should fill in default in fields\n+   * @return boolean\n+   */\n   public boolean shouldFillInDefaultValues()\n   {\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * set the flag to decide whether to fill in default values in result record's fields\n+   * @param fillInDefaultValues a boolean for the flag\n+   */\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n     _fillInDefaultValues = fillInDefaultValues;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMTYyNg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458001626", "bodyText": "Add javadoc", "author": "karthikbalasub", "createdAt": "2020-07-21T10:38:57Z", "path": "restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java", "diffHunk": "@@ -552,4 +555,14 @@ public void setValidateResourceKeys(boolean validateResourceKeys)\n     setMethodConfig(\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n+\n+  public boolean shouldFillInDefaultValues()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\nindex 10603168d..26afccc5e 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/server/RestLiConfig.java\n\n@@ -556,11 +556,19 @@ public class RestLiConfig\n         new RestLiMethodConfigBuilder(getMethodConfig()).withShouldValidateResourceKeys(_validateResourceKeys).build());\n   }\n \n+  /**\n+   * check config to see if the data in result should fill in default in fields\n+   * @return boolean\n+   */\n   public boolean shouldFillInDefaultValues()\n   {\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * set the flag to decide whether to fill in default values in result record's fields\n+   * @param fillInDefaultValues a boolean for the flag\n+   */\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n     _fillInDefaultValues = fillInDefaultValues;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwMjcyMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458002720", "bodyText": "For each case, add a short comment on what it is testing.\nOr even better, include a string in the test data with the context and use that string when tests fail.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:40:59Z", "path": "restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.internal.server.response;\n+\n+import com.linkedin.data.DataList;\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import java.io.File;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestResponseUtils\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    // case 1", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 27874a1a3..960281839 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n\n@@ -23,6 +23,7 @@ import com.linkedin.data.schema.generator.AbstractGenerator;\n import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n import com.linkedin.data.template.DataTemplateUtil;\n import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import com.linkedin.restli.server.defaults.Foo;\n import java.io.File;\n import org.testng.Assert;\n import org.testng.annotations.AfterTest;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODAwNTE3Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r458005173", "bodyText": "Can you explain when this is needed? I feel this should just return null here.", "author": "karthikbalasub", "createdAt": "2020-07-21T10:46:08Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  /**\n+   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n+   * Basically, a simplified psuedo code is:\n+   *  FillInDefault(schema, dataMap):\n+   *   for field in schema.fields:\n+   *     fieldSchema = field.getSchema()\n+   *     if fieldSchema instanceOf RecordDataTemplate:\n+   *       if data.contains(field):\n+   *         FillInDefault(fieldSchema, data.get(field))\n+   *       else:\n+   *         if field.hasDefaultValue():\n+   *           DataMap newData = field.getDefault()\n+   *           FillInDefault(fieldSchema, newData)\n+   *       data.put(field, newData)\n+   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n+   *       FillIndFefault(schema.deReference(), data)\n+   *     else:\n+   *       if !data.contains(field) && field.hasDefaultValue():\n+   *         data.put(field, field.getDefaultValue())\n+   * @param dataSchema -> a schema of the corresponding dataMap\n+   * @param dataMap -> a dataMap that needs to be filling the default\n+   * @return a new different data map that contains original data plus the default values\n+   */\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    DataMap dataDefaultFilled;\n+    if (dataMap != null)\n+    {\n+      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+      dataDefaultFilled.putAll(dataMap);\n+    }\n+    else\n+    {\n+      dataDefaultFilled = new DataMap();", "originalCommit": "57c394003c10fab5e85bcb129dc696aa416dca85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9e81643c891572982585ede78eb7b5cd20c8aafa", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex e598f8b12..63bbfff72 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -93,94 +96,96 @@ public class ResponseUtils\n     }\n   }\n \n-  /**\n-   * Used to fill in the default field for a data record if the record is having the field but not \"complete\"\n-   * Basically, a simplified psuedo code is:\n-   *  FillInDefault(schema, dataMap):\n-   *   for field in schema.fields:\n-   *     fieldSchema = field.getSchema()\n-   *     if fieldSchema instanceOf RecordDataTemplate:\n-   *       if data.contains(field):\n-   *         FillInDefault(fieldSchema, data.get(field))\n-   *       else:\n-   *         if field.hasDefaultValue():\n-   *           DataMap newData = field.getDefault()\n-   *           FillInDefault(fieldSchema, newData)\n-   *       data.put(field, newData)\n-   *     else if fieldSchema instanceOf TypeRefDataTemplate:\n-   *       FillIndFefault(schema.deReference(), data)\n-   *     else:\n-   *       if !data.contains(field) && field.hasDefaultValue():\n-   *         data.put(field, field.getDefaultValue())\n-   * @param dataSchema -> a schema of the corresponding dataMap\n-   * @param dataMap -> a dataMap that needs to be filling the default\n-   * @return a new different data map that contains original data plus the default values\n-   */\n-  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n-    DataMap dataDefaultFilled;\n-    if (dataMap != null)\n-    {\n-      dataDefaultFilled = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n-      dataDefaultFilled.putAll(dataMap);\n-    }\n-    else\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      dataDefaultFilled = new DataMap();\n-    }\n-\n-    if (dataSchema instanceof RecordDataSchema)\n-    {\n-      RecordDataSchema recordDataSchema = (RecordDataSchema) dataSchema;\n-      for (RecordDataSchema.Field field : recordDataSchema.getFields())\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n       {\n-        DataSchema fieldSchema = field.getType();\n-        if (fieldSchema instanceof RecordDataSchema)\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) dataDefaultFilled.get(field.getName()));\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n-          else if (field.getDefault() != null)\n-          {\n-            DataMap fieldDataWithDefault = fillInDefaultValues(fieldSchema, (DataMap) field.getDefault());\n-            dataDefaultFilled.put(field.getName(), fieldDataWithDefault);\n-          }\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n         }\n-        else if (fieldSchema instanceof TyperefDataSchema)\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          TyperefDataSchema typerefDataSchema = (TyperefDataSchema) fieldSchema;\n-          DataSchema dereferencedSchema = typerefDataSchema.getDereferencedDataSchema();\n-          if (!dataDefaultFilled.containsKey(field.getName()))\n-          {\n-            if (dereferencedSchema instanceof RecordDataSchema)\n-            {\n-              DataMap fieldDataMapWithDefault = fillInDefaultValues(fieldSchema, null);\n-              if (fieldDataMapWithDefault.size() > 0)\n-              {\n-                dataDefaultFilled.put(field.getName(), fieldDataMapWithDefault);\n-              }\n-            }\n-            else\n-            {\n-              if (field.getDefault() != null)\n-              {\n-                dataDefaultFilled.put(field.getName(), field.getDefault());\n-              }\n-            }\n-          }\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n         }\n-        else // primitive | complex data schemas of this field in the record\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n         {\n-          if (!dataDefaultFilled.containsKey(field.getName()) && field.getDefault() != null)\n-          {\n-            dataDefaultFilled.put(field.getName(), field.getDefault());\n-          }\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n         }\n       }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      if (itemDataSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnArray((ArrayDataSchema) itemDataSchema, (DataList) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnRecord((RecordDataSchema) itemDataSchema, (DataMap) o));\n+      }\n+      else if (itemDataSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        dataListWithDefault.add(fillInDefaultOnTyperef((TyperefDataSchema) itemDataSchema, o));\n+      }\n+      else\n+      {\n+        dataListWithDefault.add(o);\n+      }\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      DataMap dataMap = (DataMap) data;\n+      return (Object) fillInDefaultOnRecord((RecordDataSchema)dataSchema, dataMap);\n+    }\n+    else if (dataSchema.getType() == DataSchema.Type.TYPEREF)\n+    {\n+      return fillInDefaultOnTyperef((TyperefDataSchema) dataSchema, data);\n+    }\n+    else\n+    {\n+      return data;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)\n+  {\n+    if (dataSchema.getType() == DataSchema.Type.RECORD)\n+    {\n+      return fillInDefaultOnRecord((RecordDataSchema) dataSchema, dataMap);\n     }\n-    return dataDefaultFilled;\n+    return dataMap;\n   }\n \n   public static RestResponse buildResponse(RoutingResult routingResult, RestLiResponse restLiResponse)\n"}}, {"oid": "9e81643c891572982585ede78eb7b5cd20c8aafa", "url": "https://github.com/linkedin/rest.li/commit/9e81643c891572982585ede78eb7b5cd20c8aafa", "message": "Address comment for clarity", "committedDate": "2020-07-22T17:20:51Z", "type": "forcePushed"}, {"oid": "68c81b337a69f7cec5dc68f19a09041ca0785647", "url": "https://github.com/linkedin/rest.li/commit/68c81b337a69f7cec5dc68f19a09041ca0785647", "message": "add union method and re-org test cases", "committedDate": "2020-07-23T23:40:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTc0Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461201742", "bodyText": "move this as javadoc for the method", "author": "aman1309", "createdAt": "2020-07-27T22:16:05Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java", "diffHunk": "@@ -626,6 +630,23 @@ public boolean isReturnEntityRequested()\n     return ArgumentUtils.parseReturnEntityParameter(returnEntityValue);\n   }\n \n+  @Override\n+  public boolean isFillInDefaultsRequested()\n+  {\n+    return _fillInDefaultValues;\n+  }\n+\n+  @Override\n+  public void setFillInDefaultValues(boolean fillInDefaultValues)\n+  {\n+    // if a server has a configuration to set the flag to true, it will be set\n+    // through this method, and if the request itself already has the flag set to true\n+    // we will keep the flag remain true even the server config is not set.\n+    // That is => either server config or client request param will be able to\n+    // request fill in default values", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgxNTU0Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461815543", "bodyText": "done", "author": "BrianPin", "createdAt": "2020-07-28T19:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwMTc0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\nindex 3c13ea37f..c7f64eab3 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/ResourceContextImpl.java\n\n@@ -636,14 +639,17 @@ public class ResourceContextImpl implements ServerResourceContext\n     return _fillInDefaultValues;\n   }\n \n+  /**\n+   * if a server has a configuration to set the flag to true, it will be set\n+   * through this method, and if the request itself already has the flag set to true\n+   * we will keep the flag remain true even the server config is not set.\n+   * That is => either server config or client request param will be able to\n+   * request fill in default values\n+   * @param fillInDefaultValues boolean to set the flag for filling default values\n+   */\n   @Override\n   public void setFillInDefaultValues(boolean fillInDefaultValues)\n   {\n-    // if a server has a configuration to set the flag to true, it will be set\n-    // through this method, and if the request itself already has the flag set to true\n-    // we will keep the flag remain true even the server config is not set.\n-    // That is => either server config or client request param will be able to\n-    // request fill in default values\n     _fillInDefaultValues = fillInDefaultValues || _fillInDefaultValues;\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTY5MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461205690", "bodyText": "did you look at any other possible position where this can be inserted instead of response builders? and if not how did we ensure all cases are(will remain) covered where the response is being sent out", "author": "aman1309", "createdAt": "2020-07-27T22:26:18Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java", "diffHunk": "@@ -153,8 +154,13 @@ private D buildRestLiResponseData(final Request request,\n         throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR,\n             \"Unexpected null encountered. Null element inside of a List returned by the resource method: \" + routingResult.getResourceMethod());\n       }\n+      DataMap rawData = entry.data();\n+      if (resourceContext.isFillInDefaultsRequested())\n+      {\n+        rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n+      }", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg0OTI3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461849278", "bodyText": "The way I find the response builder is by looking up all classes that implements the interface RestLiResponseBuilder so there are only 10 classes, I only need to implement this default filling feature in classes : ActionResponseBuilder BatchFinderResponseBuilder BatchGetResponseBuilder GetResponseBuilder and CollectionResponseBuilder, it covers: Action, Get, GetAll, BatchGet, Finder, BatchFinder methods\nThere are other classes that implements this inferface RestLiResponseBuilder I think they don't need to have this:\nBatchCreateResponseBuilder\nBatchResponseBuilder for  BATCH_UPDATE, BATCH_PARTIAL_UPDATE\nCreateResponseBuilder\nEmptyResponseBuilder\nPartialUpdateResponseBuilder\nLet me know if I miss anything", "author": "BrianPin", "createdAt": "2020-07-28T20:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNTY5MA=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\nindex 0b5a19b6c..ab06558bf 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/CollectionResponseBuilder.java\n\n@@ -159,8 +159,7 @@ public abstract class CollectionResponseBuilder<D extends RestLiResponseData<? e\n       {\n         rawData = ResponseUtils.fillInDefaultValues(entry.schema(), rawData);\n       }\n-      processedElements.add(new AnyRecord(RestUtils\n-          .projectFields(rawData, resourceContext.getProjectionMode(), resourceContext.getProjectionMask())));\n+      processedElements.add(new AnyRecord(RestUtils.projectFields(rawData, resourceContext)));\n     }\n \n     //Now for custom metadata\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNjEyNQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461206125", "bodyText": "switch case?", "author": "aman1309", "createdAt": "2020-07-27T22:27:28Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMyMjQwMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r467322400", "bodyText": "Done", "author": "BrianPin", "createdAt": "2020-08-07T23:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwNjEyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIwOTA1Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461209057", "bodyText": "this condition seems common and can be moved out of data schema switch construct", "author": "aman1309", "createdAt": "2020-07-27T22:35:17Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDUxMg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461210512", "bodyText": "fillInDefaultOnXYZ.. can be combined into fillInDefaultValues with switch case. why do we need separate methods for each? and separate switch case constructs?", "author": "aman1309", "createdAt": "2020-07-27T22:39:10Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n+        }\n+      }\n+      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n+      {\n+        dataWithDefault.put(field.getName(), field.getDefault());\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NDAzMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463554033", "bodyText": "+1, it seems there is a lot of duplication.\nYou'd just need one fillDefaultOnData which takes dataSchema and an Object, does the branching based on schema type.\nIn all other methods, you just have to get the nested schema (eg, field, item or value schema) and call this method again.", "author": "karthikbalasub", "createdAt": "2020-07-31T11:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDUxMg=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461212137", "bodyText": "if you are filling in default datamap you shouldn't need to recursively call for record again as all default would be there from schema", "author": "aman1309", "createdAt": "2020-07-27T22:43:37Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      DataSchema dataFieldSchema = field.getType();\n+      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n+      {\n+        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+        {\n+          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n+          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzU5Ng==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461233596", "bodyText": "Well, according to Karthik's example, even there is a default for a record, we still need to figure out other field to see if there is a default. Let me know if we need a sync with Karthik", "author": "BrianPin", "createdAt": "2020-07-27T23:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNDc0OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461234749", "bodyText": "oh yeah no need thanks", "author": "aman1309", "createdAt": "2020-07-27T23:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjEzNw=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461213493", "bodyText": "this would increase the memory consumption unnecessarily can you optimize for this. why do you need this? you're anyway traversing for list of schema fields. can we not update and return the original datamap?", "author": "aman1309", "createdAt": "2020-07-27T22:47:14Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,209 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzMzAwOQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461233009", "bodyText": "Do you mean update and return?", "author": "BrianPin", "createdAt": "2020-07-27T23:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIzNTI5Nw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r461235297", "bodyText": "yup or just update will also be fine", "author": "aman1309", "createdAt": "2020-07-27T23:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzMjMxNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r462032314", "bodyText": "I tried just update without creating new dataMap, in some cases it will return exception because the dataMap is read only.\nI think in this regard we can not just assume we can update the dataMap, we have only one way to make the fill.\nThe exception is like the following:, it is caused by an internal field in DataMap _readOnly, which in the function we can not change it.\nGradle suite > Gradle test > com.linkedin.restli.internal.server.response.TestResponseUtils > testGetAbsentFieldsDefaultValues[4](case5.json) FAILED\n    java.lang.AssertionError: Test failed with exception:\n    java.lang.UnsupportedOperationException: Cannot mutate a read-only map\n        at org.testng.Assert.fail(Assert.java:96)\n        at com.linkedin.restli.internal.server.response.TestResponseUtils.testGetAbsentFieldsDefaultValues(TestResponseUtils.java:84)", "author": "BrianPin", "createdAt": "2020-07-29T04:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwNTMzNA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463705334", "bodyText": "Ah! you may use DataComplex.clone() for shallow copy instead of manual deep copy.", "author": "aman1309", "createdAt": "2020-07-31T16:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMzQ5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex 7883ce4ea..f037ac990 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,56 +95,35 @@ public class ResponseUtils\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n   public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n   {\n     DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n     dataWithDefault.putAll(dataMap);\n     for (RecordDataSchema.Field field : schema.getFields())\n     {\n-      DataSchema dataFieldSchema = field.getType();\n-      if (dataFieldSchema.getType() == DataSchema.Type.RECORD)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnRecord((RecordDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.ARRAY)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataList originalData = dataMap.containsKey(field.getName()) ? (DataList) dataMap.get(field.getName()) : (DataList) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnArray((ArrayDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.TYPEREF)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          Object originalData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnTyperef((TyperefDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.MAP)\n-      {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnMap((MapDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (dataFieldSchema.getType() == DataSchema.Type.UNION)\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n       {\n-        if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n-        {\n-          DataMap originalData = dataMap.containsKey(field.getName()) ? (DataMap) dataMap.get(field.getName()) : (DataMap) field.getDefault();\n-          dataWithDefault.put(field.getName(), fillInDefaultOnUnion((UnionDataSchema) dataFieldSchema, originalData));\n-        }\n-      }\n-      else if (!dataWithDefault.containsKey(field.getName()) && field.getDefault() != null)\n-      {\n-        dataWithDefault.put(field.getName(), field.getDefault());\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n       }\n     }\n     return dataWithDefault;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzU1NjExMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r463556113", "bodyText": "This is an interesting way to provide inputs. One suggestion here is to name the files in a meaningful way.\neg, basic_case.json, array_map.json", "author": "karthikbalasub", "createdAt": "2020-07-31T11:27:01Z", "path": "restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.internal.server.response;\n+\n+import com.linkedin.data.DataMap;\n+import com.linkedin.data.schema.DataSchema;\n+import com.linkedin.data.schema.SchemaFormatType;\n+import com.linkedin.data.schema.generator.AbstractGenerator;\n+import com.linkedin.data.schema.resolver.MultiFormatDataSchemaResolver;\n+import com.linkedin.data.template.DataTemplateUtil;\n+import com.linkedin.restli.internal.server.util.DataMapUtils;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.util.Collections;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import org.testng.reporters.Files;\n+\n+\n+public class TestResponseUtils\n+{\n+  final static String FS = File.separator;\n+  final static String testDir = System.getProperty(\"testDir\", new File(\"src/test\").getAbsolutePath());\n+  final static String pegasusDir = testDir + FS + \"pegasus\" + FS + \"com\" + FS + \"linkedin\" + FS + \"restli\" + FS + \"server\" + FS + \"defaults\";\n+  final static String resolverDir = testDir + FS + \"pegasus\";\n+\n+  @BeforeTest\n+  public void beforeTest()\n+  {\n+    System.setProperty(AbstractGenerator.GENERATOR_RESOLVER_PATH, resolverDir);\n+  }\n+\n+  @DataProvider(name = \"default_serialization\")\n+  public Object[][] schemaFilesForDefaultSerializationTest()\n+  {\n+    return new Object[][]{\n+        {\"case1.json\"},\n+        {\"case2.json\"},\n+        {\"case3.json\"},\n+        {\"case4.json\"},\n+        {\"case5.json\"},\n+        {\"case6.json\"},\n+        {\"case7.json\"},\n+        {\"case8.json\"},", "originalCommit": "68c81b337a69f7cec5dc68f19a09041ca0785647", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9827904cb299eb93d624530e2435a0e023944999", "chunk": "diff --git a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\nindex 0bd6ec9f9..da0d64d52 100644\n--- a/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n+++ b/restli-server/src/test/java/com/linkedin/restli/internal/server/response/TestResponseUtils.java\n\n@@ -50,14 +50,14 @@ public class TestResponseUtils\n   public Object[][] schemaFilesForDefaultSerializationTest()\n   {\n     return new Object[][]{\n-        {\"case1.json\"},\n-        {\"case2.json\"},\n-        {\"case3.json\"},\n-        {\"case4.json\"},\n-        {\"case5.json\"},\n-        {\"case6.json\"},\n-        {\"case7.json\"},\n-        {\"case8.json\"},\n+        {\"default_filling_for_empty_value_but_keyed.json\"},\n+        {\"default_filling_union_without_alias.json\"},\n+        {\"filling_other_field_in_record.json\"},\n+        {\"iterate_array_element_default.json\"},\n+        {\"iterate_map_entry_default.json\"},\n+        {\"record_field_default_case.json\"},\n+        {\"record_field_is_record.json\"},\n+        {\"record_field_with_array_map.json\"},\n     };\n   }\n \n"}}, {"oid": "9827904cb299eb93d624530e2435a0e023944999", "url": "https://github.com/linkedin/rest.li/commit/9827904cb299eb93d624530e2435a0e023944999", "message": "Address logic simplification comment and case renaming comment", "committedDate": "2020-08-07T20:44:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTQ2NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468095464", "bodyText": "initialize size", "author": "karthikbalasub", "createdAt": "2020-08-10T18:25:50Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjc5OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026799", "bodyText": "Updated", "author": "BrianPin", "createdAt": "2020-08-12T06:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NTQ2NA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzgxMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097810", "bodyText": "We should use CheckedUtil::*withoutChecking methods.\nBy default DataMap and DataList check for cycles when a new object is added. However, since we are controling the logic and are not creating cycles, we can skip those checks for performance.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:19Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjc1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026754", "bodyText": "Sure", "author": "BrianPin", "createdAt": "2020-08-12T06:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzgxMA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzg2Mg==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097862", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:25Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzkzMQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097931", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:33Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjY4OQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026689", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5NzkzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzk4OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468097988", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjY1NA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026654", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5Nzk4OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODEyMA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468098120", "bodyText": "use CheckedUtil::*withoutChecking methods.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:30:57Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    if (dataWithDefault.size() == 1)\n+    {\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjYyMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026623", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5ODEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTAwMw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468099003", "bodyText": "This will check all the entries again.. so better option is to create an empty dataMap and put items inside the loop without checking\n(Similar to how you are handling lists)", "author": "karthikbalasub", "createdAt": "2020-08-10T18:32:42Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjU5MA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026590", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTAwMw=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTc4NQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468099785", "bodyText": "Do not initialize the default map with original data. Update it as you iterate the data to fill defaults, use putWithoutchecking", "author": "karthikbalasub", "createdAt": "2020-08-10T18:34:12Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjQ5Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026493", "bodyText": "Recommended method used", "author": "BrianPin", "createdAt": "2020-08-12T06:11:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODA5OTc4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDc3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r468100778", "bodyText": "You don't need this method. Just make fillInDataDefault public and use that.", "author": "karthikbalasub", "createdAt": "2020-08-10T18:36:06Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +95,96 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    switch (schema.getType())\n+    {\n+      case RECORD:\n+        return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case TYPEREF:\n+        return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+      case MAP:\n+        return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case UNION:\n+        return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+      case ARRAY:\n+        return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+      default:\n+        return dataWithoutDefault;\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(DataMapBuilder.getOptimumHashMapCapacityFromSize(dataMap.size()));\n+    dataWithDefault.putAll(dataMap);\n+    for (RecordDataSchema.Field field : schema.getFields())\n+    {\n+      if (dataMap.containsKey(field.getName()) || field.getDefault() != null)\n+      {\n+        Object fieldData = dataMap.containsKey(field.getName()) ? dataMap.get(field.getName()) : field.getDefault();\n+        dataWithDefault.put(field.getName(), fillInDataDefault(field.getType(), fieldData));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnMap(MapDataSchema schema, DataMap dataMap)\n+  {\n+    DataSchema valueSchema = schema.getValues();\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    for (Map.Entry<String, Object> entry : dataWithDefault.entrySet())\n+    {\n+      dataWithDefault.put(entry.getKey(), fillInDataDefault(valueSchema, entry.getValue()));\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static DataList fillInDefaultOnArray(ArrayDataSchema schema, DataList dataList)\n+  {\n+    DataSchema itemDataSchema = schema.getItems();\n+    DataList dataListWithDefault = new DataList();\n+    for (Object o : dataList)\n+    {\n+      dataListWithDefault.add(fillInDataDefault(itemDataSchema, o));\n+    }\n+    return dataListWithDefault;\n+  }\n+\n+  public static DataMap fillInDefaultOnUnion(UnionDataSchema schema, DataMap dataMap)\n+  {\n+    DataMap dataWithDefault = new DataMap(dataMap);\n+    if (dataWithDefault.size() == 1)\n+    {\n+      for (Map.Entry<String, Object> entry: dataWithDefault.entrySet())\n+      {\n+        String memberTypeKey = entry.getKey();\n+        DataSchema memberDataSchema = schema.getTypeByMemberKey(memberTypeKey);\n+        if (memberDataSchema == null)\n+        {\n+          return dataWithDefault;\n+        }\n+        dataWithDefault.put(memberTypeKey, fillInDataDefault(memberDataSchema, entry.getValue()));\n+      }\n+    }\n+    return dataWithDefault;\n+  }\n+\n+  public static Object fillInDefaultOnTyperef(TyperefDataSchema typerefDataSchema, Object data)\n+  {\n+    DataSchema dataSchema = typerefDataSchema.getDereferencedDataSchema();\n+    return fillInDataDefault(dataSchema, data);\n+  }\n+\n+  public static DataMap fillInDefaultValues(DataSchema dataSchema, DataMap dataMap)", "originalCommit": "9827904cb299eb93d624530e2435a0e023944999", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTAyNjM3OA==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r469026378", "bodyText": "Method consolidated", "author": "BrianPin", "createdAt": "2020-08-12T06:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODEwMDc3OA=="}], "type": "inlineReview", "revised_code": {"commit": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex f037ac990..4e77376db 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -95,7 +94,7 @@ public class ResponseUtils\n     }\n   }\n \n-  private static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     switch (schema.getType())\n     {\n"}}, {"oid": "fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "url": "https://github.com/linkedin/rest.li/commit/fa6159a9b0b037b37fd6b1bab17e4e579bbbe417", "message": "address performance related comment", "committedDate": "2020-08-12T06:00:04Z", "type": "forcePushed"}, {"oid": "9dd9423bea7d526770ed897fd0be455f4de070cf", "url": "https://github.com/linkedin/rest.li/commit/9dd9423bea7d526770ed897fd0be455f4de070cf", "message": "address performance related comment", "committedDate": "2020-08-12T06:15:00Z", "type": "forcePushed"}, {"oid": "bbc6a802bd24b4fcb42c11eea1dd6f82a652b9dd", "url": "https://github.com/linkedin/rest.li/commit/bbc6a802bd24b4fcb42c11eea1dd6f82a652b9dd", "message": "Update change log", "committedDate": "2020-08-17T16:45:40Z", "type": "forcePushed"}, {"oid": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "url": "https://github.com/linkedin/rest.li/commit/a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "message": "Use dataMap clone instead of putWithoutChecking to reduce performance impact", "committedDate": "2020-08-18T06:29:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5Njc5MQ==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r472396791", "bodyText": "add javadoc here", "author": "aman1309", "createdAt": "2020-08-18T18:26:21Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,93 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)", "originalCommit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -93,6 +93,11 @@ public class ResponseUtils\n     }\n   }\n \n+  /**\n+   * @param schema schema for the companion data map\n+   * @param dataWithoutDefault data map that is response for a restli request\n+   * @return data object that filled in with default values on the field with default value set on the schema\n+   */\n   public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     try\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjM5NzQ4Mw==", "url": "https://github.com/linkedin/rest.li/pull/335#discussion_r472397483", "bodyText": "change scope to private. not required to be exposed outside. same for other methods", "author": "aman1309", "createdAt": "2020-08-18T18:27:39Z", "path": "restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java", "diffHunk": "@@ -84,6 +93,93 @@ static Object translateCanonicalKeyToAlternativeKeyIfNeeded(Object canonicalKey,\n     }\n   }\n \n+  public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n+  {\n+    try\n+    {\n+      switch (schema.getType())\n+      {\n+        case RECORD:\n+          return fillInDefaultOnRecord((RecordDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case TYPEREF:\n+          return fillInDefaultOnTyperef((TyperefDataSchema) schema, dataWithoutDefault);\n+        case MAP:\n+          return fillInDefaultOnMap((MapDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case UNION:\n+          return fillInDefaultOnUnion((UnionDataSchema) schema, (DataMap) dataWithoutDefault);\n+        case ARRAY:\n+          return fillInDefaultOnArray((ArrayDataSchema) schema, (DataList) dataWithoutDefault);\n+        default:\n+          return dataWithoutDefault;\n+      }\n+    }\n+    catch (CloneNotSupportedException ex)\n+    {\n+      throw new RestLiServiceException(HttpStatus.S_500_INTERNAL_SERVER_ERROR, ex);\n+    }\n+  }\n+\n+  public static DataMap fillInDefaultOnRecord(RecordDataSchema schema, DataMap dataMap) throws CloneNotSupportedException", "originalCommit": "a163e6d93a8fbf927de7f6e5281b610cfc1a2f0e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "chunk": "diff --git a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\nindex c55fdba05..f002ec9fe 100644\n--- a/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n+++ b/restli-server/src/main/java/com/linkedin/restli/internal/server/response/ResponseUtils.java\n\n@@ -93,6 +93,11 @@ public class ResponseUtils\n     }\n   }\n \n+  /**\n+   * @param schema schema for the companion data map\n+   * @param dataWithoutDefault data map that is response for a restli request\n+   * @return data object that filled in with default values on the field with default value set on the schema\n+   */\n   public static Object fillInDataDefault(DataSchema schema, Object dataWithoutDefault)\n   {\n     try\n"}}, {"oid": "409ed62fb17a48648aa502cedf9973ea7b76bb46", "url": "https://github.com/linkedin/rest.li/commit/409ed62fb17a48648aa502cedf9973ea7b76bb46", "message": "address comment on method scope", "committedDate": "2020-08-21T07:53:44Z", "type": "forcePushed"}, {"oid": "307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "url": "https://github.com/linkedin/rest.li/commit/307a3566b44ddc1fd80b7a9b8237e31bed98ec31", "message": "Add default values in response when the flag from the url is set", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "b73b3e314542d4801b66365db7e3367b3fc8fbb1", "url": "https://github.com/linkedin/rest.li/commit/b73b3e314542d4801b66365db7e3367b3fc8fbb1", "message": "Address Aman's comment about recursive resolve default values for record and fix the query key for this feature", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "url": "https://github.com/linkedin/rest.li/commit/9cb3ca70781e4e7e88a41ff70ad7f514c1c2ae06", "message": "Address comment: integration test and recursive resolve and typeref test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "c68a4a87545db83506676ee251b9631b5c18b917", "url": "https://github.com/linkedin/rest.li/commit/c68a4a87545db83506676ee251b9631b5c18b917", "message": "Fix integration test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "4bd6141324db1856d9abee232d5b74cb99ff7365", "url": "https://github.com/linkedin/rest.li/commit/4bd6141324db1856d9abee232d5b74cb99ff7365", "message": "Address Karthiks comment about design", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "8f8eed14e7352cf0964a7881964cf4bfcbdbe88e", "url": "https://github.com/linkedin/rest.li/commit/8f8eed14e7352cf0964a7881964cf4bfcbdbe88e", "message": "fix test failure in TestResourceSchemaCollection", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "3dcb85552f3653b177932480593368e1aa1a835a", "url": "https://github.com/linkedin/rest.li/commit/3dcb85552f3653b177932480593368e1aa1a835a", "message": "address Evan's comment regarding placeholder class in test", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "url": "https://github.com/linkedin/rest.li/commit/bf24dbd3621c9f4f9ae58a612fd44110c5d082a6", "message": "address Karthiks comment about right place to fill in default, also review the logic of filling defaults", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "3e82f796f7b91e25261d42a3479f2cfbfc2be202", "url": "https://github.com/linkedin/rest.li/commit/3e82f796f7b91e25261d42a3479f2cfbfc2be202", "message": "address Evan naming comments", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "4047975c79b41cf1457725b38e511ef8e4bfc405", "url": "https://github.com/linkedin/rest.li/commit/4047975c79b41cf1457725b38e511ef8e4bfc405", "message": "Add function mock to address test regressions caused by the new method of resource context", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "15b992d6f281f0b4dde00e80f157a253d892b1d5", "url": "https://github.com/linkedin/rest.li/commit/15b992d6f281f0b4dde00e80f157a253d892b1d5", "message": "Address Karthiks comment: array test cases, simplify logic", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "url": "https://github.com/linkedin/rest.li/commit/a35a2c37f608f4dd1baf9a22a67d5d89748cb2ae", "message": "Add server config logic in code", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "b555a312099de17a5117f0cd2e5f048d494830d0", "url": "https://github.com/linkedin/rest.li/commit/b555a312099de17a5117f0cd2e5f048d494830d0", "message": "Address comment for clarity", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "793f6419fdfe8446341a5df1782dc58bff3a6e30", "url": "https://github.com/linkedin/rest.li/commit/793f6419fdfe8446341a5df1782dc58bff3a6e30", "message": "add union method and re-org test cases", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "58e8ea8272b72fc5d4084422122e9be77ebcfa86", "url": "https://github.com/linkedin/rest.li/commit/58e8ea8272b72fc5d4084422122e9be77ebcfa86", "message": "address Aman javadoc comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "ecd3ddcfdc82367b38f81384e25aede4b06a5171", "url": "https://github.com/linkedin/rest.li/commit/ecd3ddcfdc82367b38f81384e25aede4b06a5171", "message": "update changelog.md", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "8f39f3c1023fd79c185e53636c412e3d30947827", "url": "https://github.com/linkedin/rest.li/commit/8f39f3c1023fd79c185e53636c412e3d30947827", "message": "Fix typo", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "08362edd6ff6eadc2ca3c2c41a7bbff24aca00b4", "url": "https://github.com/linkedin/rest.li/commit/08362edd6ff6eadc2ca3c2c41a7bbff24aca00b4", "message": "Address logic simplification comment and case renaming comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "436bab3e63d7c17615c4feccb732259825cc08b5", "url": "https://github.com/linkedin/rest.li/commit/436bab3e63d7c17615c4feccb732259825cc08b5", "message": "address performance related comment", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "2ead1d477885929de308e25a636119f9fe069b13", "url": "https://github.com/linkedin/rest.li/commit/2ead1d477885929de308e25a636119f9fe069b13", "message": "Update change log", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "9572e80c471f843034f97a31b79ed3bf8c335b22", "url": "https://github.com/linkedin/rest.li/commit/9572e80c471f843034f97a31b79ed3bf8c335b22", "message": "Fix version string", "committedDate": "2020-08-24T07:44:25Z", "type": "commit"}, {"oid": "e0d533df508a3a213cf4b1909c9100e751792a60", "url": "https://github.com/linkedin/rest.li/commit/e0d533df508a3a213cf4b1909c9100e751792a60", "message": "Use dataMap clone instead of putWithoutChecking to reduce performance impact", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "c2fb120145b0af84c49c14771a7aaf137955bc97", "url": "https://github.com/linkedin/rest.li/commit/c2fb120145b0af84c49c14771a7aaf137955bc97", "message": "address comment on method scope", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "566703eb6c3bfde63d344ce8f2b149e22b0ff1e1", "url": "https://github.com/linkedin/rest.li/commit/566703eb6c3bfde63d344ce8f2b149e22b0ff1e1", "message": "Advance version in change log", "committedDate": "2020-08-24T07:44:26Z", "type": "commit"}, {"oid": "883b9665a463ea86ff0571d6944024f832977cd8", "url": "https://github.com/linkedin/rest.li/commit/883b9665a463ea86ff0571d6944024f832977cd8", "message": "Update change log", "committedDate": "2020-08-24T07:46:04Z", "type": "commit"}, {"oid": "883b9665a463ea86ff0571d6944024f832977cd8", "url": "https://github.com/linkedin/rest.li/commit/883b9665a463ea86ff0571d6944024f832977cd8", "message": "Update change log", "committedDate": "2020-08-24T07:46:04Z", "type": "forcePushed"}, {"oid": "6c33c62d0ba896a583459a000e1fd088042bb016", "url": "https://github.com/linkedin/rest.li/commit/6c33c62d0ba896a583459a000e1fd088042bb016", "message": "Fix merge error on changelog", "committedDate": "2020-08-24T15:46:11Z", "type": "commit"}]}