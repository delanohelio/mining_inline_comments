{"pr_number": 434, "pr_title": "Add method in ParseResult class to get base schema", "pr_createdAt": "2020-10-02T18:04:27Z", "pr_url": "https://github.com/linkedin/rest.li/pull/434", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3OTkxNA==", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498979914", "bodyText": "Please add java doc on both these methods and also for getSchemaAndLocations. Given we have mutliple methods, it would be helpful to document their behavior.", "author": "karthikbalasub", "createdAt": "2020-10-02T18:19:16Z", "path": "generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java", "diffHunk": "@@ -211,24 +209,33 @@ private void init(AbstractMultiFormatDataSchemaResolver resolver,\n       return _schemaAndLocations;\n     }\n \n+    public Map<DataSchema, DataSchemaLocation> getBaseDataSchemaAndLocations()\n+    {\n+      return _schemaAndLocations.entrySet().stream().filter(entry -> !isExtensionSchemaLocation(entry))\n+          .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n     public Map<DataSchema, DataSchemaLocation> getExtensionDataSchemaAndLocations()", "originalCommit": "2588a9447ac0fdb8503d8e9e51e4deca9d5688f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5ODA3OQ==", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498998079", "bodyText": "Added", "author": "BrianPin", "createdAt": "2020-10-02T18:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk3OTkxNA=="}], "type": "inlineReview", "revised_code": {"commit": "2253b518abc4c5b4a187b60accfa8b59eb57518d", "chunk": "diff --git a/generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java b/generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java\nindex e8ba8ccae..c70e6c495 100644\n--- a/generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java\n+++ b/generator/src/main/java/com/linkedin/pegasus/generator/DataSchemaParser.java\n\n@@ -204,17 +204,31 @@ public class DataSchemaParser\n     private final Set<File> _sourceFiles = new HashSet<>();\n     protected final StringBuilder _messageBuilder = new StringBuilder();\n \n+    /**\n+     * Get all schema and schemaLocations in one shot\n+     * @return a map of data schema locations keyed by DataSchema object\n+     */\n     public Map<DataSchema, DataSchemaLocation> getSchemaAndLocations()\n     {\n       return _schemaAndLocations;\n     }\n \n+    /**\n+     * Get all base schemas from the parsing result. The base schema is judged by non-extension schemas.\n+     * @return a map of non-extension data schema locations keyed by DataSchema object\n+     */\n     public Map<DataSchema, DataSchemaLocation> getBaseDataSchemaAndLocations()\n     {\n       return _schemaAndLocations.entrySet().stream().filter(entry -> !isExtensionSchemaLocation(entry))\n           .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n     }\n \n+    /**\n+     * Get all extension schema, the criteria is as:\n+     * 1. The path suffix is like Extensions.pdl\n+     * 2. The path prefix contains \"extensions\" substring.\n+     * @return a map of extension schema and location\n+     */\n     public Map<DataSchema, DataSchemaLocation> getExtensionDataSchemaAndLocations()\n     {\n       return _schemaAndLocations.entrySet().stream().filter(DataSchemaParser.ParseResult::isExtensionSchemaLocation)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTA4Mw==", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498981083", "bodyText": "Not needed as the test will fail for any uncaught exception.", "author": "karthikbalasub", "createdAt": "2020-10-02T18:21:54Z", "path": "generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java", "diffHunk": "@@ -212,6 +212,59 @@ public void testSchemaFilesInExtensionPathInFolder(String[] files, String[] expe\n   }\n \n \n+  @DataProvider(name = \"ERFilesForBaseSchema\")\n+  private Object[][] dataSchemaFiles()\n+  {\n+    return new Object[][]\n+        {\n+            {\n+                new String[]{\n+                    \"extensions/BarExtensions.pdl\",\n+                    \"extensions/FooExtensions.pdl\",\n+                    \"extensions/FuzzExtensions.pdl\",\n+                    \"pegasus/Foo.pdl\",\n+                    \"pegasus/Bar.pdl\",\n+                    \"pegasus/Fuzz.pdsc\"\n+                },\n+                new String[]{\n+                    \"Foo\",\n+                    \"Bar\",\n+                    \"Fuzz\",\n+                    \"InlineRecord\"\n+                }\n+            }\n+        };\n+  }\n+\n+  @Test(dataProvider = \"ERFilesForBaseSchema\")\n+  public void testParseResultToGetBaseSchemas(String[] files, String[] expectedExtensions) throws Exception\n+  {\n+    String pegasusWithFS = pegasusDir + FS;\n+    String resolverPath = pegasusWithFS + \"extensionSchemas/extensions:\"\n+        + pegasusWithFS + \"extensionSchemas/others:\"\n+        + pegasusWithFS + \"extensionSchemas/pegasus\";\n+    try\n+    {\n+      DataSchemaParser parser = new DataSchemaParser(resolverPath);\n+      String[] schemaFiles = Arrays.stream(files).map(casename -> pegasusDir + FS + \"extensionSchemas\" + FS + casename).toArray(String[]::new);\n+      DataSchemaParser.ParseResult parseResult = parser.parseSources(schemaFiles);\n+      Map<DataSchema, DataSchemaLocation> bases = parseResult.getBaseDataSchemaAndLocations();\n+      assertEquals(bases.size(), expectedExtensions.length);\n+      Set<String> actualNames = bases\n+          .keySet()\n+          .stream()\n+          .map(dataSchema -> (NamedDataSchema) dataSchema)\n+          .map(NamedDataSchema::getName)\n+          .collect(Collectors.toSet());\n+      assertEquals(actualNames, Arrays.stream(expectedExtensions).collect(Collectors.toSet()));\n+    }\n+    catch (Exception e)\n+    {\n+      Assert.fail(\"Test failed\");\n+    }", "originalCommit": "2588a9447ac0fdb8503d8e9e51e4deca9d5688f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk5ODI5OQ==", "url": "https://github.com/linkedin/rest.li/pull/434#discussion_r498998299", "bodyText": "Removed", "author": "BrianPin", "createdAt": "2020-10-02T18:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODk4MTA4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "81195434f0762f83fa9fb23943dbee18e110c2d2", "chunk": "diff --git a/generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java b/generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java\nindex 31a596439..7f0dfb91e 100644\n--- a/generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java\n+++ b/generator/src/test/java/com/linkedin/pegasus/generator/TestDataSchemaParser.java\n\n@@ -237,7 +237,7 @@ public class TestDataSchemaParser\n   }\n \n   @Test(dataProvider = \"ERFilesForBaseSchema\")\n-  public void testParseResultToGetBaseSchemas(String[] files, String[] expectedExtensions) throws Exception\n+  public void testParseResultToGetBaseSchemas(String[] files, String[] expectedSchemaNames) throws Exception\n   {\n     String pegasusWithFS = pegasusDir + FS;\n     String resolverPath = pegasusWithFS + \"extensionSchemas/extensions:\"\n"}}, {"oid": "81195434f0762f83fa9fb23943dbee18e110c2d2", "url": "https://github.com/linkedin/rest.li/commit/81195434f0762f83fa9fb23943dbee18e110c2d2", "message": "Add method in ParseResult class to get base schema", "committedDate": "2020-10-02T18:22:25Z", "type": "commit"}, {"oid": "81195434f0762f83fa9fb23943dbee18e110c2d2", "url": "https://github.com/linkedin/rest.li/commit/81195434f0762f83fa9fb23943dbee18e110c2d2", "message": "Add method in ParseResult class to get base schema", "committedDate": "2020-10-02T18:22:25Z", "type": "forcePushed"}, {"oid": "2253b518abc4c5b4a187b60accfa8b59eb57518d", "url": "https://github.com/linkedin/rest.li/commit/2253b518abc4c5b4a187b60accfa8b59eb57518d", "message": "address karthik comments", "committedDate": "2020-10-02T18:56:03Z", "type": "commit"}]}