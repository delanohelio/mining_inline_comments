{"pr_number": 321, "pr_title": "fix dark cluster strategy refresh", "pr_createdAt": "2020-06-04T23:05:26Z", "pr_url": "https://github.com/linkedin/rest.li/pull/321", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzA3OQ==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436907079", "bodyText": "imo comment unnecessary.", "author": "zhang-chris", "createdAt": "2020-06-08T18:25:42Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.", "originalCommit": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NDA3NA==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436954074", "bodyText": "I removed the last sentence, kept the first.", "author": "davidhoa", "createdAt": "2020-06-08T19:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzA3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c53a9098594bd80f2a280da90df1d349adb653f9", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 89ca7afee..eff44fb72 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -150,23 +147,29 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-\n-      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n-      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n-      // transportClientProperty changes, etc.\n+      // It is sufficient to listen on updaet on just the source cluster of the dark clusters, because all\n+      // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n       {\n         try\n         {\n-          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n-          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n+          {\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n           {\n-            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n-            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n-            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n-            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n-            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n-            // problem or worth the effort.\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n             String darkClusterName = entry.getKey();\n             DarkClusterConfig darkClusterConfig = entry.getValue();\n             _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzc4Mg==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436907782", "bodyText": "very minor but I think using _sourceClusterName is clearer.\nand maybe \"updatedDarkConfigMap\" or \"latest...\"?", "author": "zhang-chris", "createdAt": "2020-06-08T18:26:57Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);", "originalCommit": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1NDkzMg==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436954932", "bodyText": "made the two changes.", "author": "davidhoa", "createdAt": "2020-06-08T19:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkwNzc4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c53a9098594bd80f2a280da90df1d349adb653f9", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 89ca7afee..eff44fb72 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -150,23 +147,29 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-\n-      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n-      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n-      // transportClientProperty changes, etc.\n+      // It is sufficient to listen on updaet on just the source cluster of the dark clusters, because all\n+      // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n       {\n         try\n         {\n-          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n-          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n+          {\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n           {\n-            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n-            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n-            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n-            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n-            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n-            // problem or worth the effort.\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n             String darkClusterName = entry.getKey();\n             DarkClusterConfig darkClusterConfig = entry.getValue();\n             _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTUxMw==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436911513", "bodyText": "we also need to handle deletes; this only handles create + update. please add a test for this.", "author": "zhang-chris", "createdAt": "2020-06-08T18:33:46Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n+          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n+            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n+            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n+            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n+            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n+            // problem or worth the effort.\n+            String darkClusterName = entry.getKey();\n+            DarkClusterConfig darkClusterConfig = entry.getValue();\n+            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));", "originalCommit": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzNzMyMg==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437037322", "bodyText": "made the changes we talked about. Also, I realized that the StrategyFactoryImpl's getOrCreate() shouldn't modify the strategyMap, because if there's constant traffic, it would make it impossible to remove a dark cluster strategy if the getOrCreate() added to the strategyMap.", "author": "davidhoa", "createdAt": "2020-06-08T22:31:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkxMTUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "c53a9098594bd80f2a280da90df1d349adb653f9", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 89ca7afee..eff44fb72 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -150,23 +147,29 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-\n-      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n-      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n-      // transportClientProperty changes, etc.\n+      // It is sufficient to listen on updaet on just the source cluster of the dark clusters, because all\n+      // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n       {\n         try\n         {\n-          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n-          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n+          {\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n           {\n-            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n-            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n-            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n-            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n-            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n-            // problem or worth the effort.\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n             String darkClusterName = entry.getKey();\n             DarkClusterConfig darkClusterConfig = entry.getValue();\n             _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MDE0Mg==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436950142", "bodyText": "can be more concise: \"For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\"", "author": "zhang-chris", "createdAt": "2020-06-08T19:29:04Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,30 +150,34 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+\n+      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n+      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n+      // transportClientProperty changes, etc.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n+          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n+            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n+            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n+            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n+            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n+            // problem or worth the effort.", "originalCommit": "23ac402e77cd91ac96cad719f641e99d5e9ee0d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MjUwMw==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r436952503", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-06-08T19:33:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1MDE0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "c53a9098594bd80f2a280da90df1d349adb653f9", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 89ca7afee..eff44fb72 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -150,23 +147,29 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-\n-      // It should be sufficient to listen to updates on just the source cluster of the dark clusters, because all pertinent dark strategy info\n-      // is contained in the source cluster entries. Source cluster changes will include stuff like dark multiplier changes and dark\n-      // transportClientProperty changes, etc.\n+      // It is sufficient to listen on updaet on just the source cluster of the dark clusters, because all\n+      // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n       {\n         try\n         {\n-          DarkClusterConfigMap potentialDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(updatedClusterName);\n-          for (Map.Entry<String, DarkClusterConfig> entry : potentialDarkConfigMap.entrySet())\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n+          {\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n           {\n-            // we need to refresh every dark cluster in this \"source\" cluster, because we don't have an easy way to tell\n-            // what changed in the source cluster. It could have been a dark cluster change, or it could have been an unrelated\n-            // change in the source cluster. Because there are so few changes in cluster znodes, this is not a\n-            // big concern at the moment. If it does become a concern, storing the original darkClusterConfig and comparing with the\n-            // new one is one way to reduce the strategy refreshes. However, since the strategy itself is so lightweight, it probably won't be a\n-            // problem or worth the effort.\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n             String darkClusterName = entry.getKey();\n             DarkClusterConfig darkClusterConfig = entry.getValue();\n             _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));\n"}}, {"oid": "3e1f7ce39a408a7c0e9fa218b4c0acf33be207f6", "url": "https://github.com/linkedin/rest.li/commit/3e1f7ce39a408a7c0e9fa218b4c0acf33be207f6", "message": "fix dark cluster strategy refresh", "committedDate": "2020-06-08T22:26:45Z", "type": "commit"}, {"oid": "c53a9098594bd80f2a280da90df1d349adb653f9", "url": "https://github.com/linkedin/rest.li/commit/c53a9098594bd80f2a280da90df1d349adb653f9", "message": "fix updating strategy mechanism", "committedDate": "2020-06-08T22:26:46Z", "type": "forcePushed"}, {"oid": "7f07b543a7962853c99ee825a17806def1a2b9ca", "url": "https://github.com/linkedin/rest.li/commit/7f07b543a7962853c99ee825a17806def1a2b9ca", "message": "fix updating strategy mechanism", "committedDate": "2020-06-08T22:36:38Z", "type": "commit"}, {"oid": "7f07b543a7962853c99ee825a17806def1a2b9ca", "url": "https://github.com/linkedin/rest.li/commit/7f07b543a7962853c99ee825a17806def1a2b9ca", "message": "fix updating strategy mechanism", "committedDate": "2020-06-08T22:36:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDI0OQ==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437040249", "bodyText": "this is not a new change, nothing has changed in this function. I don't know why github shows a diff here, the file looks fine.", "author": "davidhoa", "createdAt": "2020-06-08T22:40:08Z", "path": "darkcluster/src/test/java/com/linkedin/darkcluster/TestDarkClusterStrategyFactory.java", "diffHunk": "@@ -259,6 +311,18 @@ public void onClusterAdded(String clusterName)\n       // deleting whatever the first cluster listener added. It would have been more straightforward to have\n       // a handle directly to the other clusterListener, but there's no good reason for the StrategyFactory to\n       // expose that or allow it to be passed in, as the clusterListener needs to manipulate internal state.\n+      try", "originalCommit": "7f07b543a7962853c99ee825a17806def1a2b9ca", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "url": "https://github.com/linkedin/rest.li/commit/5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "message": "change getOrCreate to get", "committedDate": "2020-06-09T22:16:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTQ0Ng==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437765446", "bodyText": "-> get", "author": "zhang-chris", "createdAt": "2020-06-09T22:52:29Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do", "originalCommit": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5OTEyNA==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437799124", "bodyText": "fixed.", "author": "davidhoa", "createdAt": "2020-06-10T00:47:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTQ0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "46e68db3397811044fd7b2391d558b9d78aea1ed", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java b/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java\nindex a7ddafcd2..b250195a3 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java\n\n@@ -25,7 +25,7 @@ import com.linkedin.d2.DarkClusterConfig;\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n+   * get retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n    * if the strategy doesn't exist. The darkClusterConfig is passed in so that it can be easily stored if needed.\n    * @param darkClusterName darkClusterName to look up\n    * @param darkClusterConfig darkClusterConfig to store, if needed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTcxOA==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437765718", "bodyText": "Can remove darkClusterConfig if it's not used anymore.", "author": "zhang-chris", "createdAt": "2020-06-09T22:53:18Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java", "diffHunk": "@@ -25,13 +25,13 @@\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. If it doesn't exist, create it\n-   * and return the new strategy. The darkClusterConfig is passed in so that it can be easily stored if needed.\n+   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n+   * if the strategy doesn't exist. The darkClusterConfig is passed in so that it can be easily stored if needed.\n    * @param darkClusterName darkClusterName to look up\n    * @param darkClusterConfig darkClusterConfig to store, if needed.\n    * @return {@link DarkClusterStrategy}\n    */\n-  DarkClusterStrategy getOrCreate(String darkClusterName, DarkClusterConfig darkClusterConfig);\n+  DarkClusterStrategy get(String darkClusterName, DarkClusterConfig darkClusterConfig);", "originalCommit": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMDcyNA==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437800724", "bodyText": "It's not used in our default implementation of DarkClusterStrategy, but I could see someone wanting a different default implementation rather than NO_OP. Because the DarkClusterStrategyFactoryImpl relies on the zookeeper update, it actually can return the NO_OP for quite a few invocations before zookeeper events trigger a strategy creation. So I'd suggest leaving this in the interface.", "author": "davidhoa", "createdAt": "2020-06-10T00:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5MDgwMQ==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r438390801", "bodyText": "removed, if needed in the future we can readd.", "author": "davidhoa", "createdAt": "2020-06-10T20:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NTcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "46e68db3397811044fd7b2391d558b9d78aea1ed", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java b/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java\nindex a7ddafcd2..b250195a3 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/api/DarkClusterStrategyFactory.java\n\n@@ -25,7 +25,7 @@ import com.linkedin.d2.DarkClusterConfig;\n public interface DarkClusterStrategyFactory\n {\n   /**\n-   * getOrCreate retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n+   * get retrieves the {@link DarkClusterStrategy} corresponding to the darkClusterName. The implementation has discretion on what to do\n    * if the strategy doesn't exist. The darkClusterConfig is passed in so that it can be easily stored if needed.\n    * @param darkClusterName darkClusterName to look up\n    * @param darkClusterConfig darkClusterConfig to store, if needed.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NjM5Nw==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437766397", "bodyText": "Can remove comments from line 149-152", "author": "zhang-chris", "createdAt": "2020-06-09T22:55:18Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests", "originalCommit": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMDk2Mg==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437800962", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-06-10T00:54:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NjM5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "46e68db3397811044fd7b2391d558b9d78aea1ed", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 7df80cf6b..ca64ec89e 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -146,10 +146,6 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n     @Override\n     public void onClusterAdded(String updatedClusterName)\n     {\n-      // We will be listening to both the source cluster because we needed the DarkClusterConfig\n-      // from the source cluster, and that called listenToCluster.\n-      // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n-      // to the dark clusters, and will be listening on the dark cluster znodes.\n       // It is sufficient to listen just to source cluster updates, because all\n       // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NzIwMA==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437767200", "bodyText": "can just convert to 1-liner.", "author": "zhang-chris", "createdAt": "2020-06-09T22:57:44Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      // It is sufficient to listen just to source cluster updates, because all\n+      // pertinent dark cluster strategy properties are contained there.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map\n+          Set<String> oldDarkStrategySet = _darkStrategyMap.keySet();\n+          // get the \"updated\" dark clusters\n+          Set<String> updatedDarkClusterConfigKeySet = updatedDarkConfigMap.keySet();\n+          // Any old strategy entry that isn't in the \"updated\" set should be removed from the strategyMap.\n+          oldDarkStrategySet.removeAll(updatedDarkClusterConfigKeySet);\n+          for (String darkClusterToRemove : oldDarkStrategySet)\n           {\n-            // just update the dark cluster that changed\n-            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName,\n-                                                                 darkConfigMap.get(darkClusterName)));\n+            _darkStrategyMap.remove(darkClusterToRemove);\n+          }\n+\n+          // Now update/add the dark clusters.\n+          for (Map.Entry<String, DarkClusterConfig> entry : updatedDarkConfigMap.entrySet())\n+          {\n+            // For simplicity, we refresh all strategies since we expect cluster updates to be rare and refresh to be cheap.\n+            String darkClusterName = entry.getKey();\n+            DarkClusterConfig darkClusterConfig = entry.getValue();\n+            _darkStrategyMap.put(darkClusterName, createStrategy(darkClusterName, darkClusterConfig));", "originalCommit": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMTg3Nw==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437801877", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-06-10T00:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NzIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "46e68db3397811044fd7b2391d558b9d78aea1ed", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 7df80cf6b..ca64ec89e 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -146,10 +146,6 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n     @Override\n     public void onClusterAdded(String updatedClusterName)\n     {\n-      // We will be listening to both the source cluster because we needed the DarkClusterConfig\n-      // from the source cluster, and that called listenToCluster.\n-      // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n-      // to the dark clusters, and will be listening on the dark cluster znodes.\n       // It is sufficient to listen just to source cluster updates, because all\n       // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2ODM1Nw==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437768357", "bodyText": "comments at 161 and 163 can be removed.", "author": "zhang-chris", "createdAt": "2020-06-09T23:00:50Z", "path": "darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java", "diffHunk": "@@ -150,43 +150,52 @@ public void onClusterAdded(String updatedClusterName)\n       // from the source cluster, and that called listenToCluster.\n       // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n       // to the dark clusters, and will be listening on the dark cluster znodes.\n-      // It is more precise to update on just dark cluster updates, because listening on the\n-      // source cluster updates might have unrelated changes, whereas when a dark cluster update happens\n-      // we know for sure we need to update that dark cluster.\n-      if (_darkStrategyMap.containsKey(updatedClusterName))\n+      // It is sufficient to listen just to source cluster updates, because all\n+      // pertinent dark cluster strategy properties are contained there.\n+      if (_sourceClusterName.equals(updatedClusterName))\n       {\n-        // this is a dark cluster name. however, to refresh the strategies, we need to pull the\n-        // darkClusterConfigMap on the parent d2 cluster, because that has the properties needed\n-        // to recreate the dark cluster strategies, such as the multiplier.\n-        String darkClusterName = updatedClusterName;\n         try\n         {\n-          DarkClusterConfigMap darkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n-          if (darkConfigMap.containsKey(darkClusterName))\n+          DarkClusterConfigMap updatedDarkConfigMap = _facilities.getClusterInfoProvider().getDarkClusterConfigMap(_sourceClusterName);\n+\n+          // get the existing entries in the strategy map", "originalCommit": "5b1c36f1716e9a03a2c2d1cc903534aba3911a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMTIzMQ==", "url": "https://github.com/linkedin/rest.li/pull/321#discussion_r437801231", "bodyText": "done.", "author": "davidhoa", "createdAt": "2020-06-10T00:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2ODM1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "46e68db3397811044fd7b2391d558b9d78aea1ed", "chunk": "diff --git a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\nindex 7df80cf6b..ca64ec89e 100644\n--- a/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n+++ b/darkcluster/src/main/java/com/linkedin/darkcluster/impl/DarkClusterStrategyFactoryImpl.java\n\n@@ -146,10 +146,6 @@ public class DarkClusterStrategyFactoryImpl implements DarkClusterStrategyFactor\n     @Override\n     public void onClusterAdded(String updatedClusterName)\n     {\n-      // We will be listening to both the source cluster because we needed the DarkClusterConfig\n-      // from the source cluster, and that called listenToCluster.\n-      // We also will be listening to updates on the dark clusters, because we'll be sending d2 requests\n-      // to the dark clusters, and will be listening on the dark cluster znodes.\n       // It is sufficient to listen just to source cluster updates, because all\n       // pertinent dark cluster strategy properties are contained there.\n       if (_sourceClusterName.equals(updatedClusterName))\n"}}, {"oid": "46e68db3397811044fd7b2391d558b9d78aea1ed", "url": "https://github.com/linkedin/rest.li/commit/46e68db3397811044fd7b2391d558b9d78aea1ed", "message": "addressed comments.", "committedDate": "2020-06-10T01:09:23Z", "type": "commit"}, {"oid": "cf6e02abc88acd587abb1551a144aafa53b181b6", "url": "https://github.com/linkedin/rest.li/commit/cf6e02abc88acd587abb1551a144aafa53b181b6", "message": "change signature of DarkClusterStrategyFactory.get to remove unused DarkClusterConfig. This is an internal\napi only used within this module, so it's safe to change.", "committedDate": "2020-06-10T20:04:42Z", "type": "commit"}, {"oid": "01ea6a9a195b0c3bca7ec7b67e7608053ce3da2e", "url": "https://github.com/linkedin/rest.li/commit/01ea6a9a195b0c3bca7ec7b67e7608053ce3da2e", "message": "additional changes", "committedDate": "2020-06-10T20:30:21Z", "type": "commit"}, {"oid": "e07f1ba0526d8f53729448ce5fd3d4eb62dcd273", "url": "https://github.com/linkedin/rest.li/commit/e07f1ba0526d8f53729448ce5fd3d4eb62dcd273", "message": "additional changes", "committedDate": "2020-06-10T22:12:28Z", "type": "commit"}]}