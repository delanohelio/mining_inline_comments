{"pr_number": 357, "pr_title": "Provide a default symbol table provider implementation", "pr_createdAt": "2020-07-29T05:17:19Z", "pr_url": "https://github.com/linkedin/rest.li/pull/357", "timeline": [{"oid": "8f476a83e4d918538c7f6db1f6b3448b85421a30", "url": "https://github.com/linkedin/rest.li/commit/8f476a83e4d918538c7f6db1f6b3448b85421a30", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services", "committedDate": "2020-07-29T06:20:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0OTQ1NQ==", "url": "https://github.com/linkedin/rest.li/pull/357#discussion_r462649455", "bodyText": "minor: Do you think there will be usecase to inject local symbol table? If so consider adding an API to do that.", "author": "karthikbalasub", "createdAt": "2020-07-29T23:36:51Z", "path": "data/src/test/java/com/linkedin/data/codec/symbol/TestDefaultSymbolTableProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.codec.symbol;\n+\n+import com.linkedin.data.ByteString;\n+import com.linkedin.data.codec.ProtobufDataCodec;\n+import java.net.HttpURLConnection;\n+import static org.mockito.Mockito.*;\n+\n+import java.util.Collections;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestDefaultSymbolTableProvider\n+{\n+  private final String _symbolTableName = \"https://someservice:100|tableName\";\n+  private final SymbolTable _symbolTable = new InMemorySymbolTable(_symbolTableName, Collections.singletonList(\"test\"));\n+\n+  @Test\n+  public void testRemoteSymbolTableSuccess() throws Exception\n+  {\n+    ByteString serializedTable = SymbolTableSerializer.toByteString(DefaultSymbolTableProvider.CODEC, _symbolTable);\n+\n+    HttpURLConnection connection = mock(HttpURLConnection.class);\n+    DefaultSymbolTableProvider provider = spy(new DefaultSymbolTableProvider());\n+    doReturn(connection).when(provider).openConnection(eq(\"https://someservice:100/symbolTable/tableName\"));\n+    when(connection.getResponseCode()).thenReturn(200);\n+    when(connection.getInputStream()).thenReturn(serializedTable.asInputStream());\n+\n+    SymbolTable remoteTable = provider.getSymbolTable(_symbolTableName);\n+    verify(connection).setRequestProperty(eq(\"Accept\"), eq(ProtobufDataCodec.DEFAULT_HEADER));\n+\n+    // Verify table is deserialized correctly.\n+    Assert.assertEquals(_symbolTable, remoteTable);\n+\n+    // Mock out the network to throw exceptions on any interactions.\n+    doThrow(new RuntimeException()).when(provider).openConnection(anyString());\n+\n+    // Verify that table is in cache by retrieving it again.\n+    Assert.assertEquals(provider.getSymbolTable(\"tableName\"), remoteTable);\n+  }\n+\n+  @Test(expectedExceptions = IllegalStateException.class)\n+  public void testRemoteSymbolTableMalformedUrl()\n+  {\n+    String symbolTableName = \"https\\\\someservice:100|tableName\";\n+    new DefaultSymbolTableProvider().getSymbolTable(symbolTableName);\n+  }\n+\n+  @Test(expectedExceptions = IllegalStateException.class)\n+  public void testRemoteSymbolTableErrorResponseCode() throws Exception\n+  {\n+    HttpURLConnection connection = mock(HttpURLConnection.class);\n+    DefaultSymbolTableProvider provider = spy(new DefaultSymbolTableProvider());\n+    doReturn(connection).when(provider).openConnection(eq(\"https://someservice:100/symbolTable/tableName\"));\n+    when(connection.getResponseCode()).thenReturn(500);\n+    provider.getSymbolTable(_symbolTableName);\n+  }\n+\n+  @Test(expectedExceptions = IllegalStateException.class)\n+  public void testRemoteSymbolTableParsingFailure() throws Exception\n+  {\n+    ByteString serializedTable = ByteString.unsafeWrap(\"random\".getBytes());\n+\n+    HttpURLConnection connection = mock(HttpURLConnection.class);\n+    DefaultSymbolTableProvider provider = spy(new DefaultSymbolTableProvider());\n+    doReturn(connection).when(provider).openConnection(eq(\"https://someservice:100/symbolTable/tableName\"));\n+    when(connection.getResponseCode()).thenReturn(200);\n+    when(connection.getInputStream()).thenReturn(serializedTable.asInputStream());\n+\n+    provider.getSymbolTable(_symbolTableName);\n+    verify(connection).setRequestProperty(eq(\"Accept\"), eq(ProtobufDataCodec.DEFAULT_HEADER));\n+  }\n+\n+  @Test\n+  public void testLocalSymbolTableSuccess()\n+  {\n+    DefaultSymbolTableProvider provider = new DefaultSymbolTableProvider();\n+    // Inject the table into the local cache.\n+    provider._cache.put(\"tableName\", _symbolTable);", "originalCommit": "8f476a83e4d918538c7f6db1f6b3448b85421a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNjE0Mg==", "url": "https://github.com/linkedin/rest.li/pull/357#discussion_r462716142", "bodyText": "Good idea. Added.", "author": "karthikrg", "createdAt": "2020-07-30T03:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY0OTQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8facd74bc7be0cb4a5478ef325401b643547af76", "chunk": "diff --git a/data/src/test/java/com/linkedin/data/codec/symbol/TestDefaultSymbolTableProvider.java b/data/src/test/java/com/linkedin/data/codec/symbol/TestDefaultSymbolTableProvider.java\nindex d32653b26..e8842144b 100644\n--- a/data/src/test/java/com/linkedin/data/codec/symbol/TestDefaultSymbolTableProvider.java\n+++ b/data/src/test/java/com/linkedin/data/codec/symbol/TestDefaultSymbolTableProvider.java\n\n@@ -44,6 +44,7 @@ public class TestDefaultSymbolTableProvider\n \n     SymbolTable remoteTable = provider.getSymbolTable(_symbolTableName);\n     verify(connection).setRequestProperty(eq(\"Accept\"), eq(ProtobufDataCodec.DEFAULT_HEADER));\n+    verify(connection).disconnect();\n \n     // Verify table is deserialized correctly.\n     Assert.assertEquals(_symbolTable, remoteTable);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3ODU2OQ==", "url": "https://github.com/linkedin/rest.li/pull/357#discussion_r462678569", "bodyText": "minor: disconnect finally since this is only one use.", "author": "aman1309", "createdAt": "2020-07-30T01:20:53Z", "path": "data/src/main/java/com/linkedin/data/codec/symbol/DefaultSymbolTableProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n+package com.linkedin.data.codec.symbol;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.linkedin.data.codec.ProtobufCodecOptions;\n+import com.linkedin.data.codec.ProtobufDataCodec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * A default {@link SymbolTableProvider} implementation that doesn't use symbol tables for requests/responses of its\n+ * own, but is able to retrieve remote symbol tables to decode responses from other services\n+ */\n+public class DefaultSymbolTableProvider implements SymbolTableProvider\n+{\n+  /**\n+   * Metadata extractor\n+   */\n+  private static final SymbolTableMetadataExtractor METADATA_EXTRACTOR = new SymbolTableMetadataExtractor();\n+\n+  /**\n+   * Accept header\n+   */\n+  private static final String ACCEPT_HEADER = \"Accept\";\n+\n+  /**\n+   * Logger.\n+   */\n+  private static final Logger LOGGER = LoggerFactory.getLogger(DefaultSymbolTableProvider.class.getSimpleName());\n+\n+  /**\n+   * Codec\n+   */\n+  static final ProtobufDataCodec CODEC =\n+      new ProtobufDataCodec(new ProtobufCodecOptions.Builder().setEnableASCIIOnlyStrings(true).build());\n+\n+  /**\n+   * Path from which symbol tables are served by remote Rest.li services.\n+   */\n+  public static final String SYMBOL_TABLE_URI_PATH = \"symbolTable\";\n+\n+  /**\n+   * Cache storing mapping from symbol table name to symbol table.\n+   */\n+  final Cache<String, SymbolTable> _cache;\n+\n+  /**\n+   * Constructor\n+   */\n+  DefaultSymbolTableProvider()\n+  {\n+    _cache = Caffeine.newBuilder().maximumSize(1000).build();\n+  }\n+\n+  @Override\n+  public SymbolTable getSymbolTable(String symbolTableName)\n+  {\n+    try\n+    {\n+      SymbolTableMetadata metadata = METADATA_EXTRACTOR.extractMetadata(symbolTableName);\n+      String serverNodeUri = metadata.getServerNodeUri();\n+      String tableName = metadata.getSymbolTableName();\n+      boolean isRemote = metadata.isRemote();\n+\n+      // First check the cache.\n+      SymbolTable symbolTable = _cache.getIfPresent(tableName);\n+      if (symbolTable != null)\n+      {\n+        return symbolTable;\n+      }\n+\n+      // If this is not a remote table, and we didn't find it in the cache, cry foul.\n+      if (!isRemote)\n+      {\n+        throw new IllegalStateException(\"Unable to fetch symbol table with name: \" + symbolTableName);\n+      }\n+\n+      // Ok, we didn't find it in the cache, let's go query the service the table was served from.\n+      String url = serverNodeUri + \"/\" + SYMBOL_TABLE_URI_PATH + \"/\" + tableName;\n+      HttpURLConnection connection = openConnection(url);", "originalCommit": "8f476a83e4d918538c7f6db1f6b3448b85421a30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNzczNQ==", "url": "https://github.com/linkedin/rest.li/pull/357#discussion_r462717735", "bodyText": "Good catch. Without this we would have leaked sockets on error responses. Fixed.", "author": "karthikrg", "createdAt": "2020-07-30T03:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3ODU2OQ=="}], "type": "inlineReview", "revised_code": {"commit": "8facd74bc7be0cb4a5478ef325401b643547af76", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/codec/symbol/DefaultSymbolTableProvider.java b/data/src/main/java/com/linkedin/data/codec/symbol/DefaultSymbolTableProvider.java\nindex 77013d502..adb9c8f57 100644\n--- a/data/src/main/java/com/linkedin/data/codec/symbol/DefaultSymbolTableProvider.java\n+++ b/data/src/main/java/com/linkedin/data/codec/symbol/DefaultSymbolTableProvider.java\n\n@@ -64,7 +64,7 @@ public class DefaultSymbolTableProvider implements SymbolTableProvider\n   /**\n    * Cache storing mapping from symbol table name to symbol table.\n    */\n-  final Cache<String, SymbolTable> _cache;\n+  private final Cache<String, SymbolTable> _cache;\n \n   /**\n    * Constructor\n"}}, {"oid": "8facd74bc7be0cb4a5478ef325401b643547af76", "url": "https://github.com/linkedin/rest.li/commit/8facd74bc7be0cb4a5478ef325401b643547af76", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services", "committedDate": "2020-07-30T03:52:14Z", "type": "commit"}, {"oid": "8facd74bc7be0cb4a5478ef325401b643547af76", "url": "https://github.com/linkedin/rest.li/commit/8facd74bc7be0cb4a5478ef325401b643547af76", "message": "Provide a default symbol table provider implementation that doesn't use symbol tables for requests/responses of its own, but is able to retrieve remote symbol tables to decode responses from other services", "committedDate": "2020-07-30T03:52:14Z", "type": "forcePushed"}]}