{"pr_number": 192, "pr_title": "Fix for PDL schema cyclic referencing detection in \"includes\" and \"typeref\" ", "pr_createdAt": "2020-02-26T21:39:40Z", "pr_url": "https://github.com/linkedin/rest.li/pull/192", "timeline": [{"oid": "7fd86706ab4cd5f3e9f731000123b2c40d2c082c", "url": "https://github.com/linkedin/rest.li/commit/7fd86706ab4cd5f3e9f731000123b2c40d2c082c", "message": "Fix PDL schema cyclic referencing", "committedDate": "2020-02-26T18:12:14Z", "type": "commit"}, {"oid": "526648f1a54c45f082d2c0dfb8cb629b8bbe5035", "url": "https://github.com/linkedin/rest.li/commit/526648f1a54c45f082d2c0dfb8cb629b8bbe5035", "message": "Fix a test failure due to last changet", "committedDate": "2020-02-26T21:38:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMjQ1MQ==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r384802451", "bodyText": "Can we use MultiFormatDataSchemaResolver instead?", "author": "karthikbalasub", "createdAt": "2020-02-26T22:19:45Z", "path": "data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java", "diffHunk": "@@ -460,22 +697,36 @@ public void testMapDataSchemaResolver()\n                         \"typeref has a circular reference to itself\"\n                     }\n                 }\n+        },\n+        {\n+            \"Circular reference involving typerefs, using alias\",\n+            \"pdl\",\n+            asMap(buildSystemIndependentPath(\"a1\", \"typeref1.pdl\"), \"@aliases = [\\\"typerefAlias1\\\"] typeref typeref1 = typeref2\",\n+                  buildSystemIndependentPath(\"a1\", \"typeref2.pdl\"), \"typeref typeref2 = typerefAlias1\"\n+                 ),\n+            new String[][]\n+                {\n+                    {\n+                        \"typeref1\",\n+                        ERROR,\n+                        \"typeref has a circular reference to itself\"\n+                    }\n+                }\n         }\n     };\n   }\n \n   @Test(dataProvider = \"circularReferenceData\")\n-  public void testCircularReferences(String desc, Map<String, String> testSchemas, String[][] testLookupAndExpectedResults)\n+  public void testCircularReferences(String desc, String extension, Map<String, String> testSchemas, String[][] testLookupAndExpectedResults)\n   {\n     boolean debug = false;\n \n     for (String[] testLookupAndExpectedResult : testLookupAndExpectedResults)\n     {\n-      DataSchemaResolver resolver = new MapDataSchemaResolver(\n-          SchemaParserFactory.instance(),\n-          Arrays.asList(buildSystemIndependentPath(\"a1\")),\n-          \".pdsc\", testSchemas);\n-      lookup(resolver, new String[][] { testLookupAndExpectedResult}, File.separatorChar, debug);\n+      DataSchemaResolver schemaResolver = new MapDataSchemaResolver(\n+          extension.equals(\"pdsc\") ? SchemaParserFactory.instance() : PdlSchemaParserFactory.instance(),", "originalCommit": "526648f1a54c45f082d2c0dfb8cb629b8bbe5035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxNDE0OA==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r384914148", "bodyText": "MapDataSchemaResolver is written for this test cases so that is why I want to re-use them", "author": "junchuanwang", "createdAt": "2020-02-27T05:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgwMjQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "4f8425839c45d8af136e6cbb07d01dff98e9a31b", "chunk": "diff --git a/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java b/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\nindex 89acac84d..60568db27 100644\n--- a/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\n+++ b/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\n\n@@ -700,7 +703,7 @@ public class TestDataSchemaResolver\n         },\n         {\n             \"Circular reference involving typerefs, using alias\",\n-            \"pdl\",\n+            PDL,\n             asMap(buildSystemIndependentPath(\"a1\", \"typeref1.pdl\"), \"@aliases = [\\\"typerefAlias1\\\"] typeref typeref1 = typeref2\",\n                   buildSystemIndependentPath(\"a1\", \"typeref2.pdl\"), \"typeref typeref2 = typerefAlias1\"\n                  ),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NjA2Mg==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r384896062", "bodyText": "Use com.linkedin.data.schema.SchemaFormatType here rather than a String. It's more type-safe.\nThis also gives you easy access to the parser factory instance.", "author": "evanw555", "createdAt": "2020-02-27T03:30:48Z", "path": "data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java", "diffHunk": "@@ -236,6 +238,7 @@ public void testMapDataSchemaResolver()\n     {\n         {\n           \"Two records including each other\",\n+            \"pdsc\",", "originalCommit": "526648f1a54c45f082d2c0dfb8cb629b8bbe5035", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f8425839c45d8af136e6cbb07d01dff98e9a31b", "chunk": "diff --git a/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java b/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\nindex 89acac84d..60568db27 100644\n--- a/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\n+++ b/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\n\n@@ -238,7 +241,7 @@ public class TestDataSchemaResolver\n     {\n         {\n           \"Two records including each other\",\n-            \"pdsc\",\n+            PDSC,\n             asMap(buildSystemIndependentPath(\"a1\", \"include1.pdsc\"), \"{ \\\"name\\\" : \\\"include1\\\", \\\"type\\\" : \\\"record\\\", \\\"include\\\": [\\\"include2\\\"], \\\"fields\\\" : [ { \\\"name\\\" : \\\"member1\\\", \\\"type\\\" : \\\"string\\\" } ] }\",\n                   buildSystemIndependentPath(\"a1\", \"include2.pdsc\"), \"{ \\\"name\\\" : \\\"include2\\\", \\\"type\\\" : \\\"record\\\", \\\"include\\\": [\\\"include1\\\"], \\\"fields\\\" : [ { \\\"name\\\" : \\\"member2\\\", \\\"type\\\" : \\\"string\\\" } ] }\"\n             ),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5Njg0Mg==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r384896842", "bodyText": "This method is now completely identical to AbstractSchemaParser#lookupName. Why don't we just delete this one and use that?", "author": "evanw555", "createdAt": "2020-02-27T03:34:47Z", "path": "data/src/main/java/com/linkedin/data/schema/grammar/PdlSchemaParser.java", "diffHunk": "@@ -1093,6 +1094,10 @@ public DataSchema lookupName(String fullName)\n     if (schema == null)\n     {\n       schema = getResolver().findDataSchema(fullName, errorMessageBuilder());\n+      if (schema != null)", "originalCommit": "526648f1a54c45f082d2c0dfb8cb629b8bbe5035", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxODMwOQ==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r384918309", "bodyText": "good idea", "author": "junchuanwang", "createdAt": "2020-02-27T05:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5Njg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4f8425839c45d8af136e6cbb07d01dff98e9a31b", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/grammar/PdlSchemaParser.java b/data/src/main/java/com/linkedin/data/schema/grammar/PdlSchemaParser.java\nindex 631bbf1e9..f82ec54a1 100644\n--- a/data/src/main/java/com/linkedin/data/schema/grammar/PdlSchemaParser.java\n+++ b/data/src/main/java/com/linkedin/data/schema/grammar/PdlSchemaParser.java\n\n@@ -1082,26 +1082,6 @@ public class PdlSchemaParser extends AbstractSchemaParser\n     }\n   }\n \n-  /**\n-   * Look for {@link DataSchema} with the specified name.\n-   *\n-   * @param fullName to lookup.\n-   * @return the {@link DataSchema} if lookup was successful else return null.\n-   */\n-  public DataSchema lookupName(String fullName)\n-  {\n-    DataSchema schema = DataSchemaUtil.typeStringToPrimitiveDataSchema(fullName);\n-    if (schema == null)\n-    {\n-      schema = getResolver().findDataSchema(fullName, errorMessageBuilder());\n-      if (schema != null)\n-      {\n-        checkForCycleWithInclude(((NamedDataSchema) schema).getFullName());\n-      }\n-    }\n-    return schema;\n-  }\n-\n   private DataSchema toDataSchema(TypeAssignmentContext typeAssignment) throws ParseException {\n     TypeReferenceContext typeReference = typeAssignment.typeReference();\n     if (typeReference != null)\n"}}, {"oid": "4f8425839c45d8af136e6cbb07d01dff98e9a31b", "url": "https://github.com/linkedin/rest.li/commit/4f8425839c45d8af136e6cbb07d01dff98e9a31b", "message": "address Evan's comment", "committedDate": "2020-02-27T06:02:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM4NjU3NQ==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r385386575", "bodyText": "As I mentioned in my previous comment, using the enum gives you easy access to the schema parser instance. You shouldn't be doing extension.equals(PDSC) ? SchemaParserFactory.instance() : PdlSchemaParserFactory.instance(). You should be doing extension.getSchemaParserFactory()", "author": "evanw555", "createdAt": "2020-02-27T21:39:10Z", "path": "data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java", "diffHunk": "@@ -460,22 +700,36 @@ public void testMapDataSchemaResolver()\n                         \"typeref has a circular reference to itself\"\n                     }\n                 }\n+        },\n+        {\n+            \"Circular reference involving typerefs, using alias\",\n+            PDL,\n+            asMap(buildSystemIndependentPath(\"a1\", \"typeref1.pdl\"), \"@aliases = [\\\"typerefAlias1\\\"] typeref typeref1 = typeref2\",\n+                  buildSystemIndependentPath(\"a1\", \"typeref2.pdl\"), \"typeref typeref2 = typerefAlias1\"\n+                 ),\n+            new String[][]\n+                {\n+                    {\n+                        \"typeref1\",\n+                        ERROR,\n+                        \"typeref has a circular reference to itself\"\n+                    }\n+                }\n         }\n     };\n   }\n \n   @Test(dataProvider = \"circularReferenceData\")\n-  public void testCircularReferences(String desc, Map<String, String> testSchemas, String[][] testLookupAndExpectedResults)\n+  public void testCircularReferences(String desc, SchemaFormatType extension, Map<String, String> testSchemas, String[][] testLookupAndExpectedResults)\n   {\n     boolean debug = false;\n \n     for (String[] testLookupAndExpectedResult : testLookupAndExpectedResults)\n     {\n-      DataSchemaResolver resolver = new MapDataSchemaResolver(", "originalCommit": "4f8425839c45d8af136e6cbb07d01dff98e9a31b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM4NzE4NA==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r385387184", "bodyText": "You could potentially also avoid having to pass in the schema parser factory into the MapDataSchemaResolver itself, you could just pass in only the extension, from which you could derive the parser factory and the string extension.", "author": "evanw555", "createdAt": "2020-02-27T21:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM4NjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM4OTY3NQ==", "url": "https://github.com/linkedin/rest.li/pull/192#discussion_r385389675", "bodyText": "I don't see how you second suggestion is significantly better, but I did the change according to your suggestion.", "author": "junchuanwang", "createdAt": "2020-02-27T21:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM4NjU3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "04d785b99f86d29e51fdd89ac98c6c0d7cce1c7c", "chunk": "diff --git a/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java b/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\nindex 60568db27..994e13647 100644\n--- a/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\n+++ b/data/src/test/java/com/linkedin/data/schema/resolver/TestDataSchemaResolver.java\n\n@@ -726,10 +724,10 @@ public class TestDataSchemaResolver\n \n     for (String[] testLookupAndExpectedResult : testLookupAndExpectedResults)\n     {\n-      DataSchemaResolver schemaResolver = new MapDataSchemaResolver(\n-          extension.equals(PDSC) ? SchemaParserFactory.instance() : PdlSchemaParserFactory.instance(),\n-          Arrays.asList(buildSystemIndependentPath(\"a1\")), \".\" + extension.toString().toLowerCase(), testSchemas);\n-      lookup(schemaResolver, new String[][] { testLookupAndExpectedResult}, File.separatorChar, debug, extension);\n+      DataSchemaResolver schemaResolver =\n+          new MapDataSchemaResolver(extension.getSchemaParserFactory(), Arrays.asList(buildSystemIndependentPath(\"a1\")),\n+                                    testSchemas);\n+      lookup(schemaResolver, new String[][]{testLookupAndExpectedResult}, File.separatorChar, debug, extension);\n     }\n   }\n \n"}}, {"oid": "04d785b99f86d29e51fdd89ac98c6c0d7cce1c7c", "url": "https://github.com/linkedin/rest.li/commit/04d785b99f86d29e51fdd89ac98c6c0d7cce1c7c", "message": "signature change in MapDataSchemaResolver, to avoid using extension", "committedDate": "2020-02-27T21:44:51Z", "type": "commit"}, {"oid": "1d7caeb2c82599a22ec114841b9cc5c25f002077", "url": "https://github.com/linkedin/rest.li/commit/1d7caeb2c82599a22ec114841b9cc5c25f002077", "message": "Merge branch 'master' into pdl_includes_cyclicDetection", "committedDate": "2020-02-27T22:12:13Z", "type": "commit"}]}