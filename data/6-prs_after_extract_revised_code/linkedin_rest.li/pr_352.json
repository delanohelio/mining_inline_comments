{"pr_number": 352, "pr_title": "D2 CallTracker Long Array Tracking Optimization", "pr_createdAt": "2020-07-22T20:18:10Z", "pr_url": "https://github.com/linkedin/rest.li/pull/352", "timeline": [{"oid": "29cf1ecb20aac4915aa738ee1023405d21aa9b79", "url": "https://github.com/linkedin/rest.li/commit/29cf1ecb20aac4915aa738ee1023405d21aa9b79", "message": "Refactored LongTracking code to separate quantile tracking from basic tracking", "committedDate": "2020-07-21T23:58:25Z", "type": "commit"}, {"oid": "06ceca8a1be3b2832231aab271670ed692d9b422", "url": "https://github.com/linkedin/rest.li/commit/06ceca8a1be3b2832231aab271670ed692d9b422", "message": "Minor naming changes. Add docs", "committedDate": "2020-07-22T18:28:20Z", "type": "commit"}, {"oid": "06ceca8a1be3b2832231aab271670ed692d9b422", "url": "https://github.com/linkedin/rest.li/commit/06ceca8a1be3b2832231aab271670ed692d9b422", "message": "Minor naming changes. Add docs", "committedDate": "2020-07-22T18:28:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNjg1MA==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459226850", "bodyText": "From backward compatible perspective, it's better to keep LongTracking as is, and create new class for LongTracking without percentile latency. I did a quick search and found that there are about 5 other services that use LongTracking from pegasus, one example is call-tree-app: https://jarvis.corp.linkedin.com/codesearch/result/?name=DeflateCompression.java&path=call-tree-app%2Fcall-tree-frontend%2Fapp%2Fcom%2Flinkedin%2Fcalltree%2Fcompression&reponame=calltree%2Fcall-tree-app#21, so it is important that we keep the compatibility for LongTracking.java.\nIn the long term, we can probably migrate those to use the LongTracking from util (com.linkedin.util.stats.LongTracking)", "author": "rachelhanhan", "createdAt": "2020-07-23T05:50:57Z", "path": "pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java", "diffHunk": "@@ -1,53 +1,13 @@\n-/*\n-   Copyright (c) 2012 LinkedIn Corp.\n-\n-   Licensed under the Apache License, Version 2.0 (the \"License\");\n-   you may not use this file except in compliance with the License.\n-   You may obtain a copy of the License at\n-\n-       http://www.apache.org/licenses/LICENSE-2.0\n-\n-   Unless required by applicable law or agreed to in writing, software\n-   distributed under the License is distributed on an \"AS IS\" BASIS,\n-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-   See the License for the specific language governing permissions and\n-   limitations under the License.\n-*/\n-\n-/**\n- * $Id: LongTracking.java 151859 2010-11-19 21:43:47Z slim $\n- */\n package com.linkedin.common.stats;\n \n-import java.util.Arrays;\n-\n-import com.linkedin.common.util.ConfigHelper;\n-\n-\n-/**\n- * @author Swee Lim\n- * @version $Rev: 151859 $\n- */\n-\n /**\n- * Maintain a collection of values and provide the count, average, standard deviation,\n- * minimum, maximum, percentile values for the collection.\n+ * Tracks count, average, standard deviation, minimum and maximum\n+ * in a memory-efficient way.\n  *\n- * This class implementation is not synchronized. If concurrent access is required, it\n- * must be synchronized externally.\n+ * If percentile information is required, use {@link LongTrackingWithPercentile}.\n  */\n public class LongTracking implements LongTracker", "originalCommit": "06ceca8a1be3b2832231aab271670ed692d9b422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjQyOQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459592429", "bodyText": "Thanks for reviewing the PR!  Changed LongTrackingWithPercentile back to LongTracking, changed LongTracking to SimpleLongTracking.", "author": "rickzx", "createdAt": "2020-07-23T16:55:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNjg1MA=="}], "type": "inlineReview", "revised_code": {"commit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "chunk": "diff --git a/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java b/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\nindex 604085c37..482fd5bd3 100644\n--- a/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\n+++ b/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\n\n@@ -1,85 +1,215 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n package com.linkedin.common.stats;\n \n+import java.util.Arrays;\n+\n+\n /**\n- * Tracks count, average, standard deviation, minimum and maximum\n- * in a memory-efficient way.\n+ * Extends {@link SimpleLongTracking} with additional percentile information.\n  *\n- * If percentile information is required, use {@link LongTrackingWithPercentile}.\n+ * To calculate the percentiles, all values added are recorded in a resizable\n+ * long array buffer. For memory efficiency, use {@link SimpleLongTracking}\n+ * when percentile information is nonessential.\n+ *\n+ * This class implementation is not synchronized. If concurrent access is required, it\n+ * must be synchronized externally.\n  */\n public class LongTracking implements LongTracker\n {\n-  private int                 _count;\n-  private long                _min;\n-  private long                _max;\n-  private long                _sum;\n-  private long                _sumOfSquares;                  // Running sum of squares\n-                                                               // for call times, used for\n-                                                               // std deviation.\n+  private static final int    DEFAULT_INITIAL_CAPACITY = 1000;\n+  private static final double DEFAULT_GROWTH_FACTOR    = 2.0;\n+  private static final int    DEFAULT_MAX_CAPACITY     = 4000;\n \n-  @Override\n-  public void addValue(long value) {\n-    if (_count == 0)\n+  private long[]              _buffer;\n+  private int                 _bufferSize;\n+  private final int           _initialCapacity;\n+  private final double        _growthFactor;\n+  private final int           _maxCapacity;\n+\n+  private int                 _sortedEnd;\n+  private int                 _nextIndex;\n+  private int                 _keepRatio;\n+\n+  private final SimpleLongTracking _simpleLongTracking;\n+\n+  public LongTracking()\n+  {\n+    this(DEFAULT_MAX_CAPACITY, DEFAULT_INITIAL_CAPACITY, DEFAULT_GROWTH_FACTOR);\n+  }\n+\n+  public LongTracking(final int maxCapacity, int initialCapacity, double growthFactor)\n+  {\n+    if (initialCapacity > maxCapacity || initialCapacity <= 0)\n     {\n-      _min = _max = value;\n+      initialCapacity = maxCapacity;\n     }\n-    else if (value < _min)\n+    if (growthFactor <= 1.0)\n     {\n-      _min = value;\n+      growthFactor = DEFAULT_GROWTH_FACTOR;\n     }\n-    else if (value > _max)\n+\n+    _buffer = new long[initialCapacity];\n+    _bufferSize = initialCapacity;\n+    _initialCapacity = initialCapacity;\n+    _growthFactor = growthFactor;\n+    _maxCapacity = maxCapacity;\n+    _simpleLongTracking = new SimpleLongTracking();\n+\n+    reset();\n+  }\n+\n+  @Override\n+  public void reset()\n+  {\n+    _simpleLongTracking.reset();\n+\n+    _sortedEnd = 0;\n+    _nextIndex = 0;\n+    _keepRatio = 1;\n+  }\n+\n+  @Override\n+  public void addValue(long value)\n+  {\n+    _simpleLongTracking.addValue(value);\n+\n+    if (_keepRatio > 1 && (_simpleLongTracking.getCount() % _keepRatio) != 0)\n     {\n-      _max = value;\n+      return;\n     }\n-    _sum += value;\n-    _sumOfSquares += value * value;\n-    _count++;\n+\n+    if (_nextIndex >= _bufferSize)\n+    {\n+      if (_bufferSize < _maxCapacity)\n+      {\n+        grow();\n+      }\n+      else\n+      {\n+        dropHalf();\n+      }\n+    }\n+    _buffer[_nextIndex] = value;\n+    _nextIndex++;\n   }\n \n   @Override\n-  public LongStats getStats() {\n-    return new LongStats(getCount(), getAverage(), getStandardDeviation(),\n-        getMinimum(), getMaximum(),\n-        -1L, -1L, -1L, 1L);\n+  public LongStats getStats()\n+  {\n+    return new LongStats(_simpleLongTracking.getCount(), _simpleLongTracking.getAverage(),\n+        _simpleLongTracking.getStandardDeviation(),\n+        _simpleLongTracking.getMinimum(), _simpleLongTracking.getMaximum(),\n+        get50Pct(), get90Pct(), get95Pct(), get99Pct());\n   }\n \n-  @Override\n-  public void reset() {\n-    _count = 0;\n-    _min = 0;\n-    _max = 0;\n-    _sum = 0;\n-    _sumOfSquares = 0;\n+  public int getBufferSize()\n+  {\n+    return _bufferSize;\n+  }\n+\n+  public int getInitialCapacity()\n+  {\n+    return _initialCapacity;\n+  }\n+\n+  public double getGrowthFactor()\n+  {\n+    return _growthFactor;\n   }\n \n-  protected int getCount()\n+  public int getMaxCapacity()\n   {\n-    return _count;\n+    return _maxCapacity;\n   }\n \n-  protected double getAverage()\n+  private long get50Pct()\n   {\n-    return safeDivide(_sum, _count);\n+    return getPercentile(0.50);\n   }\n \n-  protected double getStandardDeviation()\n+  private long get90Pct()\n   {\n-    double variation;\n-    variation = safeDivide(_sumOfSquares - _sum * getAverage(), getCount());\n-    return Math.sqrt(variation);\n+    return getPercentile(0.90);\n   }\n \n-  protected long getMinimum()\n+  private long get95Pct()\n   {\n-    return _min;\n+    return getPercentile(0.95);\n+  }\n+\n+  private long get99Pct()\n+  {\n+    return getPercentile(0.99);\n+  }\n+\n+  public long getPercentile(double pct)\n+  {\n+    if (_simpleLongTracking.getCount() == 0)\n+    {\n+      return 0;\n+    }\n+    if (_sortedEnd < _nextIndex)\n+    {\n+      Arrays.sort(_buffer, 0, _nextIndex);\n+      _sortedEnd = _nextIndex;\n+    }\n+    if (pct < 0.0)\n+    {\n+      pct = 0;\n+    }\n+    else if (pct > 1.0)\n+    {\n+      pct = 1.0;\n+    }\n+    int index = (int) Math.round(pct * (_sortedEnd - 1));\n+    return _buffer[index];\n   }\n \n-  protected long getMaximum()\n+  private void dropHalf()\n   {\n-    return _max;\n+    _nextIndex = (_nextIndex + 1) / 2;\n+    _sortedEnd = (_sortedEnd + 1) / 2;\n+    _keepRatio += _keepRatio;\n+\n+    int destIndex = 1;\n+    int lastSrcIndex = 0;\n+    // copy half the sorted values by skipping alternate\n+    while (destIndex < _nextIndex)\n+    {\n+      _buffer[destIndex++] = _buffer[lastSrcIndex += 2];\n+    }\n   }\n \n-  private static double safeDivide(final double numerator, final double denominator)\n+  private void grow()\n   {\n-    return denominator != 0 ? numerator / denominator : 0;\n+    int newBufferSize = (int) (_bufferSize * _growthFactor);\n+    if (newBufferSize == _bufferSize)\n+    {\n+      newBufferSize += DEFAULT_INITIAL_CAPACITY;\n+    }\n+    if (newBufferSize > _maxCapacity)\n+    {\n+      newBufferSize = _maxCapacity;\n+    }\n+\n+    long[] newBuffer = new long[newBufferSize];\n+    System.arraycopy(_buffer, 0, newBuffer, 0, _nextIndex);\n+    _buffer = newBuffer;\n+    _bufferSize = newBufferSize;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNjk3Nw==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459226977", "bodyText": "Minor: we need to keep copyright for every single class", "author": "rachelhanhan", "createdAt": "2020-07-23T05:51:28Z", "path": "pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java", "diffHunk": "@@ -1,53 +1,13 @@\n-/*\n-   Copyright (c) 2012 LinkedIn Corp.", "originalCommit": "06ceca8a1be3b2832231aab271670ed692d9b422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjU1NQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459592555", "bodyText": "Fixed", "author": "rickzx", "createdAt": "2020-07-23T16:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNjk3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "chunk": "diff --git a/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java b/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\nindex 604085c37..482fd5bd3 100644\n--- a/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\n+++ b/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\n\n@@ -1,85 +1,215 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n package com.linkedin.common.stats;\n \n+import java.util.Arrays;\n+\n+\n /**\n- * Tracks count, average, standard deviation, minimum and maximum\n- * in a memory-efficient way.\n+ * Extends {@link SimpleLongTracking} with additional percentile information.\n  *\n- * If percentile information is required, use {@link LongTrackingWithPercentile}.\n+ * To calculate the percentiles, all values added are recorded in a resizable\n+ * long array buffer. For memory efficiency, use {@link SimpleLongTracking}\n+ * when percentile information is nonessential.\n+ *\n+ * This class implementation is not synchronized. If concurrent access is required, it\n+ * must be synchronized externally.\n  */\n public class LongTracking implements LongTracker\n {\n-  private int                 _count;\n-  private long                _min;\n-  private long                _max;\n-  private long                _sum;\n-  private long                _sumOfSquares;                  // Running sum of squares\n-                                                               // for call times, used for\n-                                                               // std deviation.\n+  private static final int    DEFAULT_INITIAL_CAPACITY = 1000;\n+  private static final double DEFAULT_GROWTH_FACTOR    = 2.0;\n+  private static final int    DEFAULT_MAX_CAPACITY     = 4000;\n \n-  @Override\n-  public void addValue(long value) {\n-    if (_count == 0)\n+  private long[]              _buffer;\n+  private int                 _bufferSize;\n+  private final int           _initialCapacity;\n+  private final double        _growthFactor;\n+  private final int           _maxCapacity;\n+\n+  private int                 _sortedEnd;\n+  private int                 _nextIndex;\n+  private int                 _keepRatio;\n+\n+  private final SimpleLongTracking _simpleLongTracking;\n+\n+  public LongTracking()\n+  {\n+    this(DEFAULT_MAX_CAPACITY, DEFAULT_INITIAL_CAPACITY, DEFAULT_GROWTH_FACTOR);\n+  }\n+\n+  public LongTracking(final int maxCapacity, int initialCapacity, double growthFactor)\n+  {\n+    if (initialCapacity > maxCapacity || initialCapacity <= 0)\n     {\n-      _min = _max = value;\n+      initialCapacity = maxCapacity;\n     }\n-    else if (value < _min)\n+    if (growthFactor <= 1.0)\n     {\n-      _min = value;\n+      growthFactor = DEFAULT_GROWTH_FACTOR;\n     }\n-    else if (value > _max)\n+\n+    _buffer = new long[initialCapacity];\n+    _bufferSize = initialCapacity;\n+    _initialCapacity = initialCapacity;\n+    _growthFactor = growthFactor;\n+    _maxCapacity = maxCapacity;\n+    _simpleLongTracking = new SimpleLongTracking();\n+\n+    reset();\n+  }\n+\n+  @Override\n+  public void reset()\n+  {\n+    _simpleLongTracking.reset();\n+\n+    _sortedEnd = 0;\n+    _nextIndex = 0;\n+    _keepRatio = 1;\n+  }\n+\n+  @Override\n+  public void addValue(long value)\n+  {\n+    _simpleLongTracking.addValue(value);\n+\n+    if (_keepRatio > 1 && (_simpleLongTracking.getCount() % _keepRatio) != 0)\n     {\n-      _max = value;\n+      return;\n     }\n-    _sum += value;\n-    _sumOfSquares += value * value;\n-    _count++;\n+\n+    if (_nextIndex >= _bufferSize)\n+    {\n+      if (_bufferSize < _maxCapacity)\n+      {\n+        grow();\n+      }\n+      else\n+      {\n+        dropHalf();\n+      }\n+    }\n+    _buffer[_nextIndex] = value;\n+    _nextIndex++;\n   }\n \n   @Override\n-  public LongStats getStats() {\n-    return new LongStats(getCount(), getAverage(), getStandardDeviation(),\n-        getMinimum(), getMaximum(),\n-        -1L, -1L, -1L, 1L);\n+  public LongStats getStats()\n+  {\n+    return new LongStats(_simpleLongTracking.getCount(), _simpleLongTracking.getAverage(),\n+        _simpleLongTracking.getStandardDeviation(),\n+        _simpleLongTracking.getMinimum(), _simpleLongTracking.getMaximum(),\n+        get50Pct(), get90Pct(), get95Pct(), get99Pct());\n   }\n \n-  @Override\n-  public void reset() {\n-    _count = 0;\n-    _min = 0;\n-    _max = 0;\n-    _sum = 0;\n-    _sumOfSquares = 0;\n+  public int getBufferSize()\n+  {\n+    return _bufferSize;\n+  }\n+\n+  public int getInitialCapacity()\n+  {\n+    return _initialCapacity;\n+  }\n+\n+  public double getGrowthFactor()\n+  {\n+    return _growthFactor;\n   }\n \n-  protected int getCount()\n+  public int getMaxCapacity()\n   {\n-    return _count;\n+    return _maxCapacity;\n   }\n \n-  protected double getAverage()\n+  private long get50Pct()\n   {\n-    return safeDivide(_sum, _count);\n+    return getPercentile(0.50);\n   }\n \n-  protected double getStandardDeviation()\n+  private long get90Pct()\n   {\n-    double variation;\n-    variation = safeDivide(_sumOfSquares - _sum * getAverage(), getCount());\n-    return Math.sqrt(variation);\n+    return getPercentile(0.90);\n   }\n \n-  protected long getMinimum()\n+  private long get95Pct()\n   {\n-    return _min;\n+    return getPercentile(0.95);\n+  }\n+\n+  private long get99Pct()\n+  {\n+    return getPercentile(0.99);\n+  }\n+\n+  public long getPercentile(double pct)\n+  {\n+    if (_simpleLongTracking.getCount() == 0)\n+    {\n+      return 0;\n+    }\n+    if (_sortedEnd < _nextIndex)\n+    {\n+      Arrays.sort(_buffer, 0, _nextIndex);\n+      _sortedEnd = _nextIndex;\n+    }\n+    if (pct < 0.0)\n+    {\n+      pct = 0;\n+    }\n+    else if (pct > 1.0)\n+    {\n+      pct = 1.0;\n+    }\n+    int index = (int) Math.round(pct * (_sortedEnd - 1));\n+    return _buffer[index];\n   }\n \n-  protected long getMaximum()\n+  private void dropHalf()\n   {\n-    return _max;\n+    _nextIndex = (_nextIndex + 1) / 2;\n+    _sortedEnd = (_sortedEnd + 1) / 2;\n+    _keepRatio += _keepRatio;\n+\n+    int destIndex = 1;\n+    int lastSrcIndex = 0;\n+    // copy half the sorted values by skipping alternate\n+    while (destIndex < _nextIndex)\n+    {\n+      _buffer[destIndex++] = _buffer[lastSrcIndex += 2];\n+    }\n   }\n \n-  private static double safeDivide(final double numerator, final double denominator)\n+  private void grow()\n   {\n-    return denominator != 0 ? numerator / denominator : 0;\n+    int newBufferSize = (int) (_bufferSize * _growthFactor);\n+    if (newBufferSize == _bufferSize)\n+    {\n+      newBufferSize += DEFAULT_INITIAL_CAPACITY;\n+    }\n+    if (newBufferSize > _maxCapacity)\n+    {\n+      newBufferSize = _maxCapacity;\n+    }\n+\n+    long[] newBuffer = new long[newBufferSize];\n+    System.arraycopy(_buffer, 0, newBuffer, 0, _nextIndex);\n+    _buffer = newBuffer;\n+    _bufferSize = newBufferSize;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNzI1Mg==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459227252", "bodyText": "Probably a typo? 1L should be -1L", "author": "rachelhanhan", "createdAt": "2020-07-23T05:52:42Z", "path": "pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java", "diffHunk": "@@ -120,202 +33,53 @@ else if (value > _max)\n     _sum += value;\n     _sumOfSquares += value * value;\n     _count++;\n-\n-    if (_keepRatio > 1 && (_count % _keepRatio) != 0)\n-    {\n-      return;\n-    }\n-\n-    if (_nextIndex >= _bufferSize)\n-    {\n-      if (_bufferSize < _maxCapacity)\n-      {\n-        grow();\n-      }\n-      else\n-      {\n-        dropHalf();\n-      }\n-    }\n-    _buffer[_nextIndex] = value;\n-    _nextIndex++;\n-  }\n-\n-  public int getBufferSize()\n-  {\n-    return _bufferSize;\n   }\n \n-  public int getInitialCapacity()\n-  {\n-    return _initialCapacity;\n-  }\n-\n-  public double getGrowthFactor()\n-  {\n-    return _growthFactor;\n-  }\n-\n-  public int getMaxCapacity()\n-  {\n-    return _maxCapacity;\n+  @Override\n+  public LongStats getStats() {\n+    return new LongStats(getCount(), getAverage(), getStandardDeviation(),\n+        getMinimum(), getMaximum(),\n+        -1L, -1L, -1L, 1L);", "originalCommit": "06ceca8a1be3b2832231aab271670ed692d9b422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MjY3Mg==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459592672", "bodyText": "Good catch. Fixed", "author": "rickzx", "createdAt": "2020-07-23T16:55:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyNzI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "chunk": "diff --git a/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java b/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\nindex 604085c37..482fd5bd3 100644\n--- a/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\n+++ b/pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java\n\n@@ -1,85 +1,215 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+\n package com.linkedin.common.stats;\n \n+import java.util.Arrays;\n+\n+\n /**\n- * Tracks count, average, standard deviation, minimum and maximum\n- * in a memory-efficient way.\n+ * Extends {@link SimpleLongTracking} with additional percentile information.\n  *\n- * If percentile information is required, use {@link LongTrackingWithPercentile}.\n+ * To calculate the percentiles, all values added are recorded in a resizable\n+ * long array buffer. For memory efficiency, use {@link SimpleLongTracking}\n+ * when percentile information is nonessential.\n+ *\n+ * This class implementation is not synchronized. If concurrent access is required, it\n+ * must be synchronized externally.\n  */\n public class LongTracking implements LongTracker\n {\n-  private int                 _count;\n-  private long                _min;\n-  private long                _max;\n-  private long                _sum;\n-  private long                _sumOfSquares;                  // Running sum of squares\n-                                                               // for call times, used for\n-                                                               // std deviation.\n+  private static final int    DEFAULT_INITIAL_CAPACITY = 1000;\n+  private static final double DEFAULT_GROWTH_FACTOR    = 2.0;\n+  private static final int    DEFAULT_MAX_CAPACITY     = 4000;\n \n-  @Override\n-  public void addValue(long value) {\n-    if (_count == 0)\n+  private long[]              _buffer;\n+  private int                 _bufferSize;\n+  private final int           _initialCapacity;\n+  private final double        _growthFactor;\n+  private final int           _maxCapacity;\n+\n+  private int                 _sortedEnd;\n+  private int                 _nextIndex;\n+  private int                 _keepRatio;\n+\n+  private final SimpleLongTracking _simpleLongTracking;\n+\n+  public LongTracking()\n+  {\n+    this(DEFAULT_MAX_CAPACITY, DEFAULT_INITIAL_CAPACITY, DEFAULT_GROWTH_FACTOR);\n+  }\n+\n+  public LongTracking(final int maxCapacity, int initialCapacity, double growthFactor)\n+  {\n+    if (initialCapacity > maxCapacity || initialCapacity <= 0)\n     {\n-      _min = _max = value;\n+      initialCapacity = maxCapacity;\n     }\n-    else if (value < _min)\n+    if (growthFactor <= 1.0)\n     {\n-      _min = value;\n+      growthFactor = DEFAULT_GROWTH_FACTOR;\n     }\n-    else if (value > _max)\n+\n+    _buffer = new long[initialCapacity];\n+    _bufferSize = initialCapacity;\n+    _initialCapacity = initialCapacity;\n+    _growthFactor = growthFactor;\n+    _maxCapacity = maxCapacity;\n+    _simpleLongTracking = new SimpleLongTracking();\n+\n+    reset();\n+  }\n+\n+  @Override\n+  public void reset()\n+  {\n+    _simpleLongTracking.reset();\n+\n+    _sortedEnd = 0;\n+    _nextIndex = 0;\n+    _keepRatio = 1;\n+  }\n+\n+  @Override\n+  public void addValue(long value)\n+  {\n+    _simpleLongTracking.addValue(value);\n+\n+    if (_keepRatio > 1 && (_simpleLongTracking.getCount() % _keepRatio) != 0)\n     {\n-      _max = value;\n+      return;\n     }\n-    _sum += value;\n-    _sumOfSquares += value * value;\n-    _count++;\n+\n+    if (_nextIndex >= _bufferSize)\n+    {\n+      if (_bufferSize < _maxCapacity)\n+      {\n+        grow();\n+      }\n+      else\n+      {\n+        dropHalf();\n+      }\n+    }\n+    _buffer[_nextIndex] = value;\n+    _nextIndex++;\n   }\n \n   @Override\n-  public LongStats getStats() {\n-    return new LongStats(getCount(), getAverage(), getStandardDeviation(),\n-        getMinimum(), getMaximum(),\n-        -1L, -1L, -1L, 1L);\n+  public LongStats getStats()\n+  {\n+    return new LongStats(_simpleLongTracking.getCount(), _simpleLongTracking.getAverage(),\n+        _simpleLongTracking.getStandardDeviation(),\n+        _simpleLongTracking.getMinimum(), _simpleLongTracking.getMaximum(),\n+        get50Pct(), get90Pct(), get95Pct(), get99Pct());\n   }\n \n-  @Override\n-  public void reset() {\n-    _count = 0;\n-    _min = 0;\n-    _max = 0;\n-    _sum = 0;\n-    _sumOfSquares = 0;\n+  public int getBufferSize()\n+  {\n+    return _bufferSize;\n+  }\n+\n+  public int getInitialCapacity()\n+  {\n+    return _initialCapacity;\n+  }\n+\n+  public double getGrowthFactor()\n+  {\n+    return _growthFactor;\n   }\n \n-  protected int getCount()\n+  public int getMaxCapacity()\n   {\n-    return _count;\n+    return _maxCapacity;\n   }\n \n-  protected double getAverage()\n+  private long get50Pct()\n   {\n-    return safeDivide(_sum, _count);\n+    return getPercentile(0.50);\n   }\n \n-  protected double getStandardDeviation()\n+  private long get90Pct()\n   {\n-    double variation;\n-    variation = safeDivide(_sumOfSquares - _sum * getAverage(), getCount());\n-    return Math.sqrt(variation);\n+    return getPercentile(0.90);\n   }\n \n-  protected long getMinimum()\n+  private long get95Pct()\n   {\n-    return _min;\n+    return getPercentile(0.95);\n+  }\n+\n+  private long get99Pct()\n+  {\n+    return getPercentile(0.99);\n+  }\n+\n+  public long getPercentile(double pct)\n+  {\n+    if (_simpleLongTracking.getCount() == 0)\n+    {\n+      return 0;\n+    }\n+    if (_sortedEnd < _nextIndex)\n+    {\n+      Arrays.sort(_buffer, 0, _nextIndex);\n+      _sortedEnd = _nextIndex;\n+    }\n+    if (pct < 0.0)\n+    {\n+      pct = 0;\n+    }\n+    else if (pct > 1.0)\n+    {\n+      pct = 1.0;\n+    }\n+    int index = (int) Math.round(pct * (_sortedEnd - 1));\n+    return _buffer[index];\n   }\n \n-  protected long getMaximum()\n+  private void dropHalf()\n   {\n-    return _max;\n+    _nextIndex = (_nextIndex + 1) / 2;\n+    _sortedEnd = (_sortedEnd + 1) / 2;\n+    _keepRatio += _keepRatio;\n+\n+    int destIndex = 1;\n+    int lastSrcIndex = 0;\n+    // copy half the sorted values by skipping alternate\n+    while (destIndex < _nextIndex)\n+    {\n+      _buffer[destIndex++] = _buffer[lastSrcIndex += 2];\n+    }\n   }\n \n-  private static double safeDivide(final double numerator, final double denominator)\n+  private void grow()\n   {\n-    return denominator != 0 ? numerator / denominator : 0;\n+    int newBufferSize = (int) (_bufferSize * _growthFactor);\n+    if (newBufferSize == _bufferSize)\n+    {\n+      newBufferSize += DEFAULT_INITIAL_CAPACITY;\n+    }\n+    if (newBufferSize > _maxCapacity)\n+    {\n+      newBufferSize = _maxCapacity;\n+    }\n+\n+    long[] newBuffer = new long[newBufferSize];\n+    System.arraycopy(_buffer, 0, newBuffer, 0, _nextIndex);\n+    _buffer = newBuffer;\n+    _bufferSize = newBufferSize;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyOTAwMQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459229001", "bodyText": "One logic we also want to add - we should keep using the LongTracking with percentile when this CallTrackerImpl is used in DegraderLoadBalancerStrategy, and when it is used under the new RelativeLoadBalancerStrategy, we should start using the new LongTracking without percentile implementation. You probably need to see if you can differentiate these 2 cases from TrackerClientImpl", "author": "rachelhanhan", "createdAt": "2020-07-23T05:59:04Z", "path": "degrader/src/main/java/com/linkedin/util/degrader/CallTrackerImpl.java", "diffHunk": "@@ -439,13 +440,13 @@ public void trackCallWithError(long duration)\n     private int _callStartCount;\n     private int _errorCount;\n     private int _concurrentMax;\n-    private final LongTracking _callTimeTracking;\n+    private final LongTracker _callTimeTracking;\n     //this map is used to store the number of specific errors that happened in one interval only\n     private final Map<ErrorType, Integer> _errorTypeCounts;\n \n     private Tracker()\n     {\n-      _callTimeTracking = new LongTracking();\n+      _callTimeTracking = new LongTrackingWithPercentile();", "originalCommit": "06ceca8a1be3b2832231aab271670ed692d9b422", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU5MzM1MQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459593351", "bodyText": "Logic added.", "author": "rickzx", "createdAt": "2020-07-23T16:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTIyOTAwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "chunk": "diff --git a/degrader/src/main/java/com/linkedin/util/degrader/CallTrackerImpl.java b/degrader/src/main/java/com/linkedin/util/degrader/CallTrackerImpl.java\nindex af220435b..a991b4979 100644\n--- a/degrader/src/main/java/com/linkedin/util/degrader/CallTrackerImpl.java\n+++ b/degrader/src/main/java/com/linkedin/util/degrader/CallTrackerImpl.java\n\n@@ -444,9 +449,15 @@ public class CallTrackerImpl implements CallTracker\n     //this map is used to store the number of specific errors that happened in one interval only\n     private final Map<ErrorType, Integer> _errorTypeCounts;\n \n-    private Tracker()\n+    private Tracker(boolean percentileTrackingEnabled)\n     {\n-      _callTimeTracking = new LongTrackingWithPercentile();\n+      if (percentileTrackingEnabled)\n+      {\n+        _callTimeTracking = new LongTracking();\n+      } else\n+      {\n+        _callTimeTracking = new SimpleLongTracking();\n+      }\n       _errorTypeCounts = new HashMap<ErrorType, Integer>();\n       reset();\n     }\n"}}, {"oid": "4309d4721aaa6788e3beec87b0460bc5b17878de", "url": "https://github.com/linkedin/rest.li/commit/4309d4721aaa6788e3beec87b0460bc5b17878de", "message": "Rename LongTracking for backward compatability. Fix an error in SimpleLongTracking. Add logic to use SimpleLongTracking for RelativeLoadBalancerStrategy.", "committedDate": "2020-07-23T16:52:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwODk1Nw==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459808957", "bodyText": "Wondering what's the difference between doing this and let this class extend the SimpleLongTracking.java, and use super.xxx() instead. Which one is a better option?", "author": "rachelhanhan", "createdAt": "2020-07-24T01:12:19Z", "path": "pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java", "diffHunk": "@@ -80,22 +62,21 @@ public LongTracking(final int maxCapacity, int initialCapacity, double growthFac\n     {\n       growthFactor = DEFAULT_GROWTH_FACTOR;\n     }\n+\n     _buffer = new long[initialCapacity];\n     _bufferSize = initialCapacity;\n     _initialCapacity = initialCapacity;\n     _growthFactor = growthFactor;\n     _maxCapacity = maxCapacity;\n+    _simpleLongTracking = new SimpleLongTracking();", "originalCommit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxOTQzOQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459819439", "bodyText": "I personally prefer delegation over inheritance, because I would like to separate out the basic tracking logic from percentile tracking logic. The SimpleLongTracking instance acts just like a blackbox. I think the difference is pretty subtle here though. Feel free to share your opinion on this.", "author": "rickzx", "createdAt": "2020-07-24T02:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwODk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIwNTQ2Ng==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r460205466", "bodyText": "OK, I don't have a strong preference here", "author": "rachelhanhan", "createdAt": "2020-07-24T17:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwODk1Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTI1Mg==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459809252", "bodyText": "Minor: 2020 instead", "author": "rachelhanhan", "createdAt": "2020-07-24T01:13:37Z", "path": "pegasus-common/src/main/java/com/linkedin/common/stats/SimpleLongTracking.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+   Copyright (c) 2012 LinkedIn Corp.", "originalCommit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgxOTg4OQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459819889", "bodyText": "Fixed", "author": "rickzx", "createdAt": "2020-07-24T02:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTI1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "feca9a135b7eb75a78d22aee9d13a6b2546d4274", "chunk": "diff --git a/pegasus-common/src/main/java/com/linkedin/common/stats/SimpleLongTracking.java b/pegasus-common/src/main/java/com/linkedin/common/stats/SimpleLongTracking.java\nindex bdebc6921..15dd9d992 100644\n--- a/pegasus-common/src/main/java/com/linkedin/common/stats/SimpleLongTracking.java\n+++ b/pegasus-common/src/main/java/com/linkedin/common/stats/SimpleLongTracking.java\n\n@@ -1,5 +1,5 @@\n /*\n-   Copyright (c) 2012 LinkedIn Corp.\n+   Copyright (c) 2020 LinkedIn Corp.\n \n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTczOA==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459809738", "bodyText": "Just want to double check with you that there is no other mps that is using config to create new instance. If not, feel free to directly drop this comment.", "author": "rachelhanhan", "createdAt": "2020-07-24T01:15:37Z", "path": "pegasus-common/src/main/java/com/linkedin/common/stats/LongTracking.java", "diffHunk": "@@ -271,51 +212,4 @@ private void grow()\n     _buffer = newBuffer;\n     _bufferSize = newBufferSize;\n   }\n-\n-  private static double safeDivide(final double numerator, final double denominator)\n-  {\n-    return denominator != 0 ? numerator / denominator : 0;\n-  }\n-\n-  public static class Config", "originalCommit": "4309d4721aaa6788e3beec87b0460bc5b17878de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgyMDQyNA==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r459820424", "bodyText": "It only occurs in a test file for LongTracking in the internal util mp. Please me know if this class should be added back.", "author": "rickzx", "createdAt": "2020-07-24T02:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDIwNTMxOQ==", "url": "https://github.com/linkedin/rest.li/pull/352#discussion_r460205319", "bodyText": "That should be fine then, util test should use the util config instead of the pegasus config class.", "author": "rachelhanhan", "createdAt": "2020-07-24T17:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgwOTczOA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "feca9a135b7eb75a78d22aee9d13a6b2546d4274", "url": "https://github.com/linkedin/rest.li/commit/feca9a135b7eb75a78d22aee9d13a6b2546d4274", "message": "Fix copyright information", "committedDate": "2020-07-24T02:03:45Z", "type": "commit"}]}