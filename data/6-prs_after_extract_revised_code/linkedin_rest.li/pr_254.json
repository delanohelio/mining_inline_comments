{"pr_number": 254, "pr_title": "Update ExtensionSchemaValidation task", "pr_createdAt": "2020-04-08T22:04:45Z", "pr_url": "https://github.com/linkedin/rest.li/pull/254", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzMzg1OA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405933858", "bodyText": "can you help fixing this by adding \"_\" to the prefix? Thanks!", "author": "junchuanwang", "createdAt": "2020-04-09T03:20:31Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java", "diffHunk": "@@ -279,6 +280,8 @@ public void addMessages(Collection<? extends Message> messages)\n     DataSchema _dataSchema;\n     // the pathSpec component list to the dataSchema whose resolved annotation needs to be validated.\n     ArrayDeque<String> pathToSchema;", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4MDg1Ng==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406580856", "bodyText": "fix", "author": "nickibi", "createdAt": "2020-04-10T03:00:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzMzg1OA=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java b/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java\nindex c5e87c009..768780c55 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationHandler.java\n\n@@ -279,9 +279,7 @@ public interface SchemaAnnotationHandler\n     // the dataSchema whose resolved annotation needs to be validated.\n     DataSchema _dataSchema;\n     // the pathSpec component list to the dataSchema whose resolved annotation needs to be validated.\n-    ArrayDeque<String> pathToSchema;\n-    // The field of the dataSchema whose resolved annotation needs to be validated.\n-    private RecordDataSchema.Field _enclosingField;\n+    ArrayDeque<String> _pathToSchema;\n \n     public DataSchema getDataSchema()\n     {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzOTQ4NA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405939484", "bodyText": "Please add JavaDoc for this constructor", "author": "junchuanwang", "createdAt": "2020-04-09T03:44:57Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java", "diffHunk": "@@ -36,11 +36,19 @@\n   private final SchemaAnnotationHandler _schemaAnnotationHandler;\n   private static final Logger LOGGER = LoggerFactory.getLogger(SchemaAnnotationValidationVisitor.class);\n \n+  private boolean _useProperties;\n+\n   public SchemaAnnotationValidationVisitor(SchemaAnnotationHandler schemaAnnotationHandler)\n   {\n     _schemaAnnotationHandler = schemaAnnotationHandler;\n   }\n \n+  public SchemaAnnotationValidationVisitor(SchemaAnnotationHandler schemaAnnotationHandler, boolean useProperties)", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4MTIzNA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406581234", "bodyText": "Added JavaDoc", "author": "nickibi", "createdAt": "2020-04-10T03:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzOTQ4NA=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java b/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java\nindex ba9433786..4b18751c4 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java\n\n@@ -36,19 +36,11 @@ public class SchemaAnnotationValidationVisitor implements SchemaVisitor\n   private final SchemaAnnotationHandler _schemaAnnotationHandler;\n   private static final Logger LOGGER = LoggerFactory.getLogger(SchemaAnnotationValidationVisitor.class);\n \n-  private boolean _useProperties;\n-\n   public SchemaAnnotationValidationVisitor(SchemaAnnotationHandler schemaAnnotationHandler)\n   {\n     _schemaAnnotationHandler = schemaAnnotationHandler;\n   }\n \n-  public SchemaAnnotationValidationVisitor(SchemaAnnotationHandler schemaAnnotationHandler, boolean useProperties)\n-  {\n-    _schemaAnnotationHandler = schemaAnnotationHandler;\n-    _useProperties = useProperties;\n-  }\n-\n   @Override\n   public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order order)\n   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzOTcwOA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405939708", "bodyText": "A bit messy, can you re-organize? Probably using help of parenthesis", "author": "junchuanwang", "createdAt": "2020-04-09T03:46:02Z", "path": "data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java", "diffHunk": "@@ -53,8 +61,14 @@ public void callbackOnContext(TraverserContext context, DataSchemaTraverse.Order\n     SchemaAnnotationHandler.ValidationMetaData metaData = new SchemaAnnotationHandler.ValidationMetaData();\n     metaData.setDataSchema(context.getCurrentSchema());\n     metaData.setPathToSchema(context.getTraversePath());\n-    AnnotationValidationResult annotationValidationResult = _schemaAnnotationHandler.validate(schema.getResolvedProperties(),\n-                                                                                              metaData);\n+    metaData.setEnclosingField(context.getEnclosingField());\n+\n+    // Pass the enclosingField's properties in the validate(), if useProperies flag is on for extension schema annotation case.\n+    AnnotationValidationResult annotationValidationResult = _useProperties\n+        ? _schemaAnnotationHandler.validate(context.getEnclosingField() != null", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU4ODU3Nw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406588577", "bodyText": "reorganized this part.", "author": "nickibi", "createdAt": "2020-04-10T03:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkzOTcwOA=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java b/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java\nindex ba9433786..4b18751c4 100644\n--- a/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java\n+++ b/data/src/main/java/com/linkedin/data/schema/annotation/SchemaAnnotationValidationVisitor.java\n\n@@ -61,14 +53,8 @@ public class SchemaAnnotationValidationVisitor implements SchemaVisitor\n     SchemaAnnotationHandler.ValidationMetaData metaData = new SchemaAnnotationHandler.ValidationMetaData();\n     metaData.setDataSchema(context.getCurrentSchema());\n     metaData.setPathToSchema(context.getTraversePath());\n-    metaData.setEnclosingField(context.getEnclosingField());\n-\n-    // Pass the enclosingField's properties in the validate(), if useProperies flag is on for extension schema annotation case.\n-    AnnotationValidationResult annotationValidationResult = _useProperties\n-        ? _schemaAnnotationHandler.validate(context.getEnclosingField() != null\n-        ? context.getEnclosingField().getProperties() : schema.getProperties(), metaData)\n-        : _schemaAnnotationHandler.validate(schema.getResolvedProperties(), metaData);\n-\n+    AnnotationValidationResult annotationValidationResult = _schemaAnnotationHandler.validate(schema.getResolvedProperties(),\n+                                                                                              metaData);\n     if (!annotationValidationResult.isValid())\n     {\n       // merge messages\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0MjYxOA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405942618", "bodyText": "JavaDoc;\nUse captalized class name;\nAlso can you rename this class? There is already one with same name", "author": "junchuanwang", "createdAt": "2020-04-09T03:58:31Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.annotation;\n+\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.data.schema.resolver.FileDataSchemaResolver.*;\n+\n+\n+public class schemaAnnotationHandlerUtil", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU5MDE0Mw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406590143", "bodyText": "Added JavaDoc, capitalized class name.\nKeep this class name as \"SchemaAnnotationHandlerUtil\"\nUpdated the other one to \"SchemaAnnotationHandlerClassUtil\", since that one is used to get schema annotation handler class names.", "author": "nickibi", "createdAt": "2020-04-10T03:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0MjYxOA=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java b/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\nsimilarity index 79%\nrename from restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\nrename to restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\nindex 0bd5929ff..4e8e9fee0 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\n\n@@ -29,31 +29,49 @@ import org.slf4j.LoggerFactory;\n import static com.linkedin.data.schema.resolver.FileDataSchemaResolver.*;\n \n \n-public class schemaAnnotationHandlerUtil\n+/**\n+ * Schema Annotation Handler utility\n+ */\n+public class SchemaAnnotationHandlerUtil\n {\n-  private static final Logger _logger = LoggerFactory.getLogger(schemaAnnotationHandlerUtil.class);\n+  private static final Logger _logger = LoggerFactory.getLogger(SchemaAnnotationHandlerUtil.class);\n \n-  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames) {\n+  /**\n+   * Based on the handlerJarPaths and handlerClassNames to provide a list of schema annotation handlers.\n+   * @param handlerJarPaths String\n+   * @param handlerClassNames String\n+   * @return a list of schema annotation handlers\n+   */\n+  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames)\n+  {\n     List<SchemaAnnotationHandler> handlers = new ArrayList<>();\n \n     List<String> handlerJarPathsArray = parsePaths(handlerJarPaths);\n     // Use Jar Paths to initiate URL class loaders.\n-    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str -> {\n-      try {\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str ->\n+    {\n+      try\n+      {\n         return Paths.get(str).toUri().toURL();\n-      } catch (Exception e) {\n+      }\n+      catch (Exception e)\n+      {\n         _logger.error(\"URL {} parsing failed\", str, e);\n       }\n       return null;\n     }).filter(Objects::nonNull).toArray(URL[]::new));\n \n-    for (String className : parsePaths(handlerClassNames)) {\n-      try {\n+    for (String className : parsePaths(handlerClassNames))\n+    {\n+      try\n+      {\n         Class<?> handlerClass = Class.forName(className, false, classLoader);\n         SchemaAnnotationHandler handler = (SchemaAnnotationHandler) handlerClass.newInstance();\n         handlers.add(handler);\n         _logger.info(\"added handler {} for annotation namespace \\\"{}\\\"\", className, handler.getAnnotationNamespace());\n-      } catch (Exception e) {\n+      }\n+      catch (Exception | Error e)\n+      {\n         _logger.error(\"Error instantiating handler class {} \", className, e);\n         // fail even just one handler fails\n         throw new IllegalStateException(\"Error instantiating handler class \" + className);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0MzMyOQ==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405943329", "bodyText": "I feel manual test for these is not enough. Can you find a way to write test cases for this line of logic?", "author": "junchuanwang", "createdAt": "2020-04-09T04:01:32Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -132,7 +139,29 @@ private static void parseAndValidateExtensionSchemas(String resolverPath, File i\n           .stream()\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n-      // TODO : Call annotation process to validate each field's annotation, need to create schemaVisitor and handler for extension annotation.\n+\n+      for (RecordDataSchema.Field field : extensionSchemaFields) {\n+        Map<String, Object> properties = field.getProperties();\n+\n+        if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYwODM3NA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406608374", "bodyText": "Adding test cases is not that straight forward. There are multiple validations in this method. If we only want to test this specific logic, it is hard to generate extensionSchemaFields. Why do you think manual test is not enough? I tested following scenarios:\n\nextension schema field with @extension\nextension schema field without any annotation\nextension schema field with annotation but not with \"extension\" namespace\nmultiple extension schema fields, some of them with validate annotation, some of them without validate annotation.", "author": "nickibi", "createdAt": "2020-04-10T05:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0MzMyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex db59160c3..a7e8a7aa3 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -140,28 +157,81 @@ public class ExtensionSchemaValidationCmdLineApp\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n \n-      for (RecordDataSchema.Field field : extensionSchemaFields) {\n-        Map<String, Object> properties = field.getProperties();\n+      checkExtensionSchemaFields(extensionSchemaFields);\n+    }\n+  }\n \n-        if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(\n-            _extension_annotation_namespace)) {\n-          _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+  private static void checkExtensionSchemaFields(List<RecordDataSchema.Field> extensionSchemaFields)\n+  {\n+    for (RecordDataSchema.Field field : extensionSchemaFields)\n+    {\n+      // check extension schema field annotation\n+      Map<String, Object> properties = field.getProperties();\n+      if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(_extension_annotation_namespace))\n+      {\n+        _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+        System.exit(1);\n+      }\n+      Object dataElement = properties.get(_extension_annotation_namespace);\n+\n+      ValidationOptions validationOptions =\n+          new ValidationOptions(RequiredMode.MUST_BE_PRESENT, CoercionMode.STRING_TO_PRIMITIVE, UnrecognizedFieldMode.DISALLOW);\n+      try\n+      {\n+        if (!(dataElement instanceof DataMap))\n+        {\n+          _logger.error(\"extension schema annotation is not a datamap!\");\n+          System.exit(1);\n+        }\n+        DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n+        ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n+        if (!result.isValid()) {\n+          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n           System.exit(1);\n         }\n       }\n-\n-      // Using annotation framework to check the annotations of fields in extension schema.\n-      List<SchemaAnnotationHandler> handlers = schemaAnnotationHandlerUtil.getSchemaAnnotationHandlers(handlerJarPaths, handlerClassNames);\n-\n-      SchemaAnnotationProcessor.SchemaAnnotationProcessResult result =\n-          SchemaAnnotationProcessor.process(handlers, topLevelDataSchema, new SchemaAnnotationProcessor.AnnotationProcessOption());\n-      if (result.hasError())\n+      catch (Exception e)\n       {\n-        _logger.error(\"Annotation processing for schema [{}] failed, detailed error: \\n\",\n-            ((RecordDataSchema) topLevelDataSchema).getFullName());\n-        _logger.error(result.getErrorMsgs());\n+        _logger.error(\"Error while checking extension schema field annotation: \" + e.getMessage());\n         System.exit(1);\n       }\n+      checkExtensionSchemaFieldSchema(field.getType());\n+    }\n+  }\n+\n+  private static void checkExtensionSchemaFieldSchema(DataSchema fieldSchema)\n+  {\n+    if (!isTypedRef(fieldSchema) && !isArrayOfTypedRef(fieldSchema)) {\n+      _logger.error(\"Field schema: [{}] is neither typeRef nor array of TypeRef!\", fieldSchema.toString());\n+      System.exit(1);\n+    }\n+    checkFieldSchemaAnnotation(fieldSchema);\n+  }\n+\n+  private static boolean isTypedRef(DataSchema schema)\n+  {\n+    return schema.getType() == DataSchema.Type.TYPEREF;\n+  }\n+\n+  private static boolean isArrayOfTypedRef(DataSchema schema)\n+  {\n+    if (schema.getType() == DataSchema.Type.ARRAY)\n+    {\n+      DataSchema itemSchema = ((ArrayDataSchema) schema).getItems();\n+      return isTypedRef(itemSchema);\n+    } else\n+      {\n+      return false;\n+    }\n+  }\n+\n+  private static void checkFieldSchemaAnnotation(DataSchema fieldSchema)\n+  {\n+    Map<String, Object> fieldAnnotation = fieldSchema.getProperties();\n+    if (fieldAnnotation.isEmpty() || !fieldAnnotation.containsKey(_resourceKey_annotation_namespace))\n+    {\n+      _logger.error(\"Field schema: [{}] should be annotated with 'resourceKey'\", fieldSchema.toString());\n+      System.exit(1);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0Mzc2NA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405943764", "bodyText": "In your case, should we reword to \"annotation validation\" instead of \"annotation processing\"?", "author": "junchuanwang", "createdAt": "2020-04-09T04:03:06Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -132,7 +139,29 @@ private static void parseAndValidateExtensionSchemas(String resolverPath, File i\n           .stream()\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n-      // TODO : Call annotation process to validate each field's annotation, need to create schemaVisitor and handler for extension annotation.\n+\n+      for (RecordDataSchema.Field field : extensionSchemaFields) {\n+        Map<String, Object> properties = field.getProperties();\n+\n+        if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(\n+            _extension_annotation_namespace)) {\n+          _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+          System.exit(1);\n+        }\n+      }\n+\n+      // Using annotation framework to check the annotations of fields in extension schema.\n+      List<SchemaAnnotationHandler> handlers = schemaAnnotationHandlerUtil.getSchemaAnnotationHandlers(handlerJarPaths, handlerClassNames);\n+\n+      SchemaAnnotationProcessor.SchemaAnnotationProcessResult result =\n+          SchemaAnnotationProcessor.process(handlers, topLevelDataSchema, new SchemaAnnotationProcessor.AnnotationProcessOption());\n+      if (result.hasError())\n+      {\n+        _logger.error(\"Annotation processing for schema [{}] failed, detailed error: \\n\",", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU5MDI4MA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406590280", "bodyText": "Updated log.", "author": "nickibi", "createdAt": "2020-04-10T03:50:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0Mzc2NA=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex db59160c3..a7e8a7aa3 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -140,28 +157,81 @@ public class ExtensionSchemaValidationCmdLineApp\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n \n-      for (RecordDataSchema.Field field : extensionSchemaFields) {\n-        Map<String, Object> properties = field.getProperties();\n+      checkExtensionSchemaFields(extensionSchemaFields);\n+    }\n+  }\n \n-        if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(\n-            _extension_annotation_namespace)) {\n-          _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+  private static void checkExtensionSchemaFields(List<RecordDataSchema.Field> extensionSchemaFields)\n+  {\n+    for (RecordDataSchema.Field field : extensionSchemaFields)\n+    {\n+      // check extension schema field annotation\n+      Map<String, Object> properties = field.getProperties();\n+      if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(_extension_annotation_namespace))\n+      {\n+        _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+        System.exit(1);\n+      }\n+      Object dataElement = properties.get(_extension_annotation_namespace);\n+\n+      ValidationOptions validationOptions =\n+          new ValidationOptions(RequiredMode.MUST_BE_PRESENT, CoercionMode.STRING_TO_PRIMITIVE, UnrecognizedFieldMode.DISALLOW);\n+      try\n+      {\n+        if (!(dataElement instanceof DataMap))\n+        {\n+          _logger.error(\"extension schema annotation is not a datamap!\");\n+          System.exit(1);\n+        }\n+        DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n+        ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n+        if (!result.isValid()) {\n+          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n           System.exit(1);\n         }\n       }\n-\n-      // Using annotation framework to check the annotations of fields in extension schema.\n-      List<SchemaAnnotationHandler> handlers = schemaAnnotationHandlerUtil.getSchemaAnnotationHandlers(handlerJarPaths, handlerClassNames);\n-\n-      SchemaAnnotationProcessor.SchemaAnnotationProcessResult result =\n-          SchemaAnnotationProcessor.process(handlers, topLevelDataSchema, new SchemaAnnotationProcessor.AnnotationProcessOption());\n-      if (result.hasError())\n+      catch (Exception e)\n       {\n-        _logger.error(\"Annotation processing for schema [{}] failed, detailed error: \\n\",\n-            ((RecordDataSchema) topLevelDataSchema).getFullName());\n-        _logger.error(result.getErrorMsgs());\n+        _logger.error(\"Error while checking extension schema field annotation: \" + e.getMessage());\n         System.exit(1);\n       }\n+      checkExtensionSchemaFieldSchema(field.getType());\n+    }\n+  }\n+\n+  private static void checkExtensionSchemaFieldSchema(DataSchema fieldSchema)\n+  {\n+    if (!isTypedRef(fieldSchema) && !isArrayOfTypedRef(fieldSchema)) {\n+      _logger.error(\"Field schema: [{}] is neither typeRef nor array of TypeRef!\", fieldSchema.toString());\n+      System.exit(1);\n+    }\n+    checkFieldSchemaAnnotation(fieldSchema);\n+  }\n+\n+  private static boolean isTypedRef(DataSchema schema)\n+  {\n+    return schema.getType() == DataSchema.Type.TYPEREF;\n+  }\n+\n+  private static boolean isArrayOfTypedRef(DataSchema schema)\n+  {\n+    if (schema.getType() == DataSchema.Type.ARRAY)\n+    {\n+      DataSchema itemSchema = ((ArrayDataSchema) schema).getItems();\n+      return isTypedRef(itemSchema);\n+    } else\n+      {\n+      return false;\n+    }\n+  }\n+\n+  private static void checkFieldSchemaAnnotation(DataSchema fieldSchema)\n+  {\n+    Map<String, Object> fieldAnnotation = fieldSchema.getProperties();\n+    if (fieldAnnotation.isEmpty() || !fieldAnnotation.containsKey(_resourceKey_annotation_namespace))\n+    {\n+      _logger.error(\"Field schema: [{}] should be annotated with 'resourceKey'\", fieldSchema.toString());\n+      System.exit(1);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0ODA0Nw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r405948047", "bodyText": "From my experience, exception won't be enough, you probably will  have to add \"Error\" as well", "author": "junchuanwang", "createdAt": "2020-04-09T04:22:23Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.annotation;\n+\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.data.schema.resolver.FileDataSchemaResolver.*;\n+\n+\n+public class schemaAnnotationHandlerUtil\n+{\n+  private static final Logger _logger = LoggerFactory.getLogger(schemaAnnotationHandlerUtil.class);\n+\n+  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames) {\n+    List<SchemaAnnotationHandler> handlers = new ArrayList<>();\n+\n+    List<String> handlerJarPathsArray = parsePaths(handlerJarPaths);\n+    // Use Jar Paths to initiate URL class loaders.\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str -> {\n+      try {\n+        return Paths.get(str).toUri().toURL();\n+      } catch (Exception e) {\n+        _logger.error(\"URL {} parsing failed\", str, e);\n+      }\n+      return null;\n+    }).filter(Objects::nonNull).toArray(URL[]::new));\n+\n+    for (String className : parsePaths(handlerClassNames)) {\n+      try {\n+        Class<?> handlerClass = Class.forName(className, false, classLoader);\n+        SchemaAnnotationHandler handler = (SchemaAnnotationHandler) handlerClass.newInstance();\n+        handlers.add(handler);\n+        _logger.info(\"added handler {} for annotation namespace \\\"{}\\\"\", className, handler.getAnnotationNamespace());\n+      } catch (Exception e) {", "originalCommit": "2fc719edbacfc6fe2a5158d9a0d4817b7ab90156", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjU5MjI3MA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r406592270", "bodyText": "Updated to - catch (Exception | Error e)", "author": "nickibi", "createdAt": "2020-04-10T04:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk0ODA0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "40149838329eed5c8120b11fa42acf6de0195721", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java b/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\nsimilarity index 79%\nrename from restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\nrename to restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\nindex 0bd5929ff..4e8e9fee0 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\n\n@@ -29,31 +29,49 @@ import org.slf4j.LoggerFactory;\n import static com.linkedin.data.schema.resolver.FileDataSchemaResolver.*;\n \n \n-public class schemaAnnotationHandlerUtil\n+/**\n+ * Schema Annotation Handler utility\n+ */\n+public class SchemaAnnotationHandlerUtil\n {\n-  private static final Logger _logger = LoggerFactory.getLogger(schemaAnnotationHandlerUtil.class);\n+  private static final Logger _logger = LoggerFactory.getLogger(SchemaAnnotationHandlerUtil.class);\n \n-  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames) {\n+  /**\n+   * Based on the handlerJarPaths and handlerClassNames to provide a list of schema annotation handlers.\n+   * @param handlerJarPaths String\n+   * @param handlerClassNames String\n+   * @return a list of schema annotation handlers\n+   */\n+  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames)\n+  {\n     List<SchemaAnnotationHandler> handlers = new ArrayList<>();\n \n     List<String> handlerJarPathsArray = parsePaths(handlerJarPaths);\n     // Use Jar Paths to initiate URL class loaders.\n-    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str -> {\n-      try {\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str ->\n+    {\n+      try\n+      {\n         return Paths.get(str).toUri().toURL();\n-      } catch (Exception e) {\n+      }\n+      catch (Exception e)\n+      {\n         _logger.error(\"URL {} parsing failed\", str, e);\n       }\n       return null;\n     }).filter(Objects::nonNull).toArray(URL[]::new));\n \n-    for (String className : parsePaths(handlerClassNames)) {\n-      try {\n+    for (String className : parsePaths(handlerClassNames))\n+    {\n+      try\n+      {\n         Class<?> handlerClass = Class.forName(className, false, classLoader);\n         SchemaAnnotationHandler handler = (SchemaAnnotationHandler) handlerClass.newInstance();\n         handlers.add(handler);\n         _logger.info(\"added handler {} for annotation namespace \\\"{}\\\"\", className, handler.getAnnotationNamespace());\n-      } catch (Exception e) {\n+      }\n+      catch (Exception | Error e)\n+      {\n         _logger.error(\"Error instantiating handler class {} \", className, e);\n         // fail even just one handler fails\n         throw new IllegalStateException(\"Error instantiating handler class \" + className);\n"}}, {"oid": "40149838329eed5c8120b11fa42acf6de0195721", "url": "https://github.com/linkedin/rest.li/commit/40149838329eed5c8120b11fa42acf6de0195721", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-04-11T20:35:51Z", "type": "forcePushed"}, {"oid": "6a28deda31bd4a0f8506a4a742368116cd2cb288", "url": "https://github.com/linkedin/rest.li/commit/6a28deda31bd4a0f8506a4a742368116cd2cb288", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-04-11T20:41:19Z", "type": "forcePushed"}, {"oid": "a79d474a548303a8bbdb0feb1eaf1d187a28e29e", "url": "https://github.com/linkedin/rest.li/commit/a79d474a548303a8bbdb0feb1eaf1d187a28e29e", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-04-11T20:50:19Z", "type": "forcePushed"}, {"oid": "3d6a0012c85a7d723eef2a6a3d609ccbb8d63b14", "url": "https://github.com/linkedin/rest.li/commit/3d6a0012c85a7d723eef2a6a3d609ccbb8d63b14", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-04-11T20:55:44Z", "type": "forcePushed"}, {"oid": "d34a2d8e5742ff572ec118010f0d5e41cb748a78", "url": "https://github.com/linkedin/rest.li/commit/d34a2d8e5742ff572ec118010f0d5e41cb748a78", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-04-12T02:39:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxNDE4MA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r408614180", "bodyText": "{ to newline :)", "author": "karthikbalasub", "createdAt": "2020-04-15T06:43:22Z", "path": "gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/SchemaAnnotationHandlerClassUtil.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2020 LinkedIn Corp.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.linkedin.pegasus.gradle;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.annotation.Annotation;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarInputStream;\n+import org.gradle.api.GradleException;\n+import org.gradle.api.file.FileCollection;\n+import org.gradle.api.logging.Logger;\n+import org.gradle.api.logging.Logging;\n+\n+/**\n+ * A utility for getting SchemaAnnotationHandler classes.\n+ */\n+public class SchemaAnnotationHandlerClassUtil\n+{\n+  private final static Logger LOGGER = Logging.getLogger(SchemaAnnotationHandlerClassUtil.class);\n+  private static final String SCHEMA_HANDLER_JAVA_ANNOTATION = \"RestLiSchemaAnnotationHandler\";\n+  private static final char FILE_SEPARATOR = File.separatorChar;\n+  private static final char UNIX_FILE_SEPARATOR = '/';\n+  private static final char PACKAGE_SEPARATOR = '.';\n+  private static final String CLASS_SUFFIX = \".class\";\n+  private static ClassLoader _classLoader;\n+\n+  /**\n+   * Based on the handlerJarPath, provide a list of schema annotation handler names.\n+   * @param handlerJarPath FileCollection\n+   * @param expectedHandlersNumber int\n+   * @param taskClassLoader ClassLoader\n+   * @return list of schema annotation handler names.\n+   * @throws IOException\n+   */\n+  public static List<String> getSchemaAnnotationHandlerClassNames(FileCollection handlerJarPath, int expectedHandlersNumber, ClassLoader taskClassLoader)\n+      throws IOException {", "originalCommit": "d34a2d8e5742ff572ec118010f0d5e41cb748a78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUwNTU4NA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r410505584", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-04-17T22:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYxNDE4MA=="}], "type": "inlineReview", "revised_code": {"commit": "e7575986ce60a0f851030165900e9a9bcc213109", "chunk": "diff --git a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/SchemaAnnotationHandlerClassUtil.java b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/SchemaAnnotationHandlerClassUtil.java\nindex c628b8079..9184fc9dd 100644\n--- a/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/SchemaAnnotationHandlerClassUtil.java\n+++ b/gradle-plugins/src/main/java/com/linkedin/pegasus/gradle/SchemaAnnotationHandlerClassUtil.java\n\n@@ -57,7 +57,8 @@ public class SchemaAnnotationHandlerClassUtil\n    * @throws IOException\n    */\n   public static List<String> getSchemaAnnotationHandlerClassNames(FileCollection handlerJarPath, int expectedHandlersNumber, ClassLoader taskClassLoader)\n-      throws IOException {\n+      throws IOException\n+  {\n     List<URL> handlerJarPathUrls = new ArrayList<>();\n \n     for (File f : handlerJarPath)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDcyNQ==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r408624725", "bodyText": "Why is this duplicated? Can't you just use SchemaAnnotationHandlerClassUtil?", "author": "karthikbalasub", "createdAt": "2020-04-15T07:07:13Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+   Copyright (c) 2020 LinkedIn Corp.\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n+*/\n+package com.linkedin.restli.tools.annotation;\n+\n+import com.linkedin.data.schema.annotation.SchemaAnnotationHandler;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.StringTokenizer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.data.schema.resolver.FileDataSchemaResolver.*;\n+\n+\n+/**\n+ * Schema Annotation Handler utility\n+ */\n+public class SchemaAnnotationHandlerUtil", "originalCommit": "d34a2d8e5742ff572ec118010f0d5e41cb748a78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkzMDM0NA==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r409930344", "bodyText": "This utility is getting SchemaAnnotationHandler list, it is in the restli-tools module. So that the SchemaAnnoationValidatorCmdLineApp could use SchemeAnnotationHandler objects. SchemaAnnotationHandlerClassUtil is in gradle-plugin module, it is used to get handler class names(String). Based on the current structure of pegasus gradle tasks, we cannot pass the Object(SchemaAnnotationHandler) from gradle-plugin task to the restli-tools main class, correct me if I am wrong.", "author": "nickibi", "createdAt": "2020-04-17T00:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzOTE0Mw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r414339143", "bodyText": "I don't think you need this class, you should be able to add the handlerJarPaths to the classpath of the javaExec and the just use the default class loader to load the classes.", "author": "karthikbalasub", "createdAt": "2020-04-24T06:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc4MjE0Mw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r454782143", "bodyText": "@karthikbalasub Actually, I am not using schemaAnnotationHandler for this validation.\nI think I'd better remove all those 2 Utils and keep the code as before, because it is unrelated to this change.", "author": "nickibi", "createdAt": "2020-07-15T04:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNDcyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "f9d7a5f5eee4d5064e7104e175bb3251f921e9f8", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java b/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\nsimilarity index 79%\nrename from restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\nrename to restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\nindex 4e8e9fee0..0bd5929ff 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/SchemaAnnotationHandlerUtil.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/annotation/schemaAnnotationHandlerUtil.java\n\n@@ -29,49 +29,31 @@ import org.slf4j.LoggerFactory;\n import static com.linkedin.data.schema.resolver.FileDataSchemaResolver.*;\n \n \n-/**\n- * Schema Annotation Handler utility\n- */\n-public class SchemaAnnotationHandlerUtil\n+public class schemaAnnotationHandlerUtil\n {\n-  private static final Logger _logger = LoggerFactory.getLogger(SchemaAnnotationHandlerUtil.class);\n+  private static final Logger _logger = LoggerFactory.getLogger(schemaAnnotationHandlerUtil.class);\n \n-  /**\n-   * Based on the handlerJarPaths and handlerClassNames to provide a list of schema annotation handlers.\n-   * @param handlerJarPaths String\n-   * @param handlerClassNames String\n-   * @return a list of schema annotation handlers\n-   */\n-  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames)\n-  {\n+  public static List<SchemaAnnotationHandler> getSchemaAnnotationHandlers(String handlerJarPaths, String handlerClassNames) {\n     List<SchemaAnnotationHandler> handlers = new ArrayList<>();\n \n     List<String> handlerJarPathsArray = parsePaths(handlerJarPaths);\n     // Use Jar Paths to initiate URL class loaders.\n-    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str ->\n-    {\n-      try\n-      {\n+    ClassLoader classLoader = new URLClassLoader(handlerJarPathsArray.stream().map(str -> {\n+      try {\n         return Paths.get(str).toUri().toURL();\n-      }\n-      catch (Exception e)\n-      {\n+      } catch (Exception e) {\n         _logger.error(\"URL {} parsing failed\", str, e);\n       }\n       return null;\n     }).filter(Objects::nonNull).toArray(URL[]::new));\n \n-    for (String className : parsePaths(handlerClassNames))\n-    {\n-      try\n-      {\n+    for (String className : parsePaths(handlerClassNames)) {\n+      try {\n         Class<?> handlerClass = Class.forName(className, false, classLoader);\n         SchemaAnnotationHandler handler = (SchemaAnnotationHandler) handlerClass.newInstance();\n         handlers.add(handler);\n         _logger.info(\"added handler {} for annotation namespace \\\"{}\\\"\", className, handler.getAnnotationNamespace());\n-      }\n-      catch (Exception | Error e)\n-      {\n+      } catch (Exception e) {\n         _logger.error(\"Error instantiating handler class {} \", className, e);\n         // fail even just one handler fails\n         throw new IllegalStateException(\"Error instantiating handler class \" + className);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNTgzOQ==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r408625839", "bodyText": "Why only typerefs? Wouldn't checking for resourceKey annotation be enough?", "author": "karthikbalasub", "createdAt": "2020-04-15T07:09:32Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -41,11 +50,24 @@\n import org.slf4j.LoggerFactory;\n \n \n+/**\n+ * This class is used to validate extension schema, the validation covers following parts:\n+ * 1. The extension schema is a validate schema.\n+ * 2. The extension schema's fields should only be annotated by \"extension\" namespace.\n+ * 3. The extension schema's fields annotations should be {@link ExtensionSchemaAnnotation}.\n+ * 4. The extension schema's field's schema should only be typeRef or array of typeRef.", "originalCommit": "d34a2d8e5742ff572ec118010f0d5e41cb748a78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAxMzE1Ng==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r409013156", "bodyText": "Based on LinkedIn TypedUrn concept, check resourceKey annotation should be good enough. I will update the logic here.", "author": "nickibi", "createdAt": "2020-04-15T17:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNTgzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e7575986ce60a0f851030165900e9a9bcc213109", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex 3e1930d0b..5df205faf 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -55,8 +55,7 @@ import org.slf4j.LoggerFactory;\n  * 1. The extension schema is a validate schema.\n  * 2. The extension schema's fields should only be annotated by \"extension\" namespace.\n  * 3. The extension schema's fields annotations should be {@link ExtensionSchemaAnnotation}.\n- * 4. The extension schema's field's schema should only be typeRef or array of typeRef.\n- * 5. The extension schema's field's schema only be annotated by \"resourceKey\" namespace.\n+ * 4. The extension schema's field's schema only be annotated by \"resourceKey\" namespace.\n  *\n  *\n  * @author Yingjie Bi\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNjI5Mg==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r408626292", "bodyText": "static constants should be ALL_CAPS", "author": "karthikbalasub", "createdAt": "2020-04-15T07:10:23Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -41,11 +50,24 @@\n import org.slf4j.LoggerFactory;\n \n \n+/**\n+ * This class is used to validate extension schema, the validation covers following parts:\n+ * 1. The extension schema is a validate schema.\n+ * 2. The extension schema's fields should only be annotated by \"extension\" namespace.\n+ * 3. The extension schema's fields annotations should be {@link ExtensionSchemaAnnotation}.\n+ * 4. The extension schema's field's schema should only be typeRef or array of typeRef.\n+ * 5. The extension schema's field's schema only be annotated by \"resourceKey\" namespace.\n+ *\n+ *\n+ * @author Yingjie Bi\n+ */\n public class ExtensionSchemaValidationCmdLineApp\n {\n   private static final Logger _logger = LoggerFactory.getLogger(ExtensionSchemaValidationCmdLineApp.class);\n   private static final Options _options = new Options();\n   private static final String _pdl = \"pdl\";\n+  private static final String _extension_annotation_namespace = \"extension\";\n+  private static final String _resourceKey_annotation_namespace = \"resourceKey\";", "originalCommit": "d34a2d8e5742ff572ec118010f0d5e41cb748a78", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTQ0MTk5Nw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r415441997", "bodyText": "fixed", "author": "nickibi", "createdAt": "2020-04-27T00:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNjI5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "e7575986ce60a0f851030165900e9a9bcc213109", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex 3e1930d0b..5df205faf 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -55,8 +55,7 @@ import org.slf4j.LoggerFactory;\n  * 1. The extension schema is a validate schema.\n  * 2. The extension schema's fields should only be annotated by \"extension\" namespace.\n  * 3. The extension schema's fields annotations should be {@link ExtensionSchemaAnnotation}.\n- * 4. The extension schema's field's schema should only be typeRef or array of typeRef.\n- * 5. The extension schema's field's schema only be annotated by \"resourceKey\" namespace.\n+ * 4. The extension schema's field's schema only be annotated by \"resourceKey\" namespace.\n  *\n  *\n  * @author Yingjie Bi\n"}}, {"oid": "e7575986ce60a0f851030165900e9a9bcc213109", "url": "https://github.com/linkedin/rest.li/commit/e7575986ce60a0f851030165900e9a9bcc213109", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-04-17T23:34:41Z", "type": "forcePushed"}, {"oid": "f9d7a5f5eee4d5064e7104e175bb3251f921e9f8", "url": "https://github.com/linkedin/rest.li/commit/f9d7a5f5eee4d5064e7104e175bb3251f921e9f8", "message": "Update annotation processing framework to support ER annotation and update ER validation task", "committedDate": "2020-07-15T02:36:21Z", "type": "commit"}, {"oid": "d922a3c7391f497b5b67edbef0aac0bbf48f2a44", "url": "https://github.com/linkedin/rest.li/commit/d922a3c7391f497b5b67edbef0aac0bbf48f2a44", "message": "Fix usingProperties flag mistake", "committedDate": "2020-07-15T02:36:21Z", "type": "commit"}, {"oid": "e90efe9d486a3443baa36a5ce01a47c66fc64d9c", "url": "https://github.com/linkedin/rest.li/commit/e90efe9d486a3443baa36a5ce01a47c66fc64d9c", "message": "Fix property null issue", "committedDate": "2020-07-15T02:36:21Z", "type": "commit"}, {"oid": "44b4c20c48bc8e6657144ad60d502a1aa6ffa617", "url": "https://github.com/linkedin/rest.li/commit/44b4c20c48bc8e6657144ad60d502a1aa6ffa617", "message": "Add ExtensionSchemaAnnoation schema", "committedDate": "2020-07-15T02:36:21Z", "type": "commit"}, {"oid": "30bf3b4e155bde47701bfef7396e0af490de62cc", "url": "https://github.com/linkedin/rest.li/commit/30bf3b4e155bde47701bfef7396e0af490de62cc", "message": "Address review feedback", "committedDate": "2020-07-15T02:36:21Z", "type": "commit"}, {"oid": "80d874283224e9b01ebc53049083d0382ec01b86", "url": "https://github.com/linkedin/rest.li/commit/80d874283224e9b01ebc53049083d0382ec01b86", "message": "Update the ExtensionSchemaValidationCmdLineApp to add extensionSchemaField check", "committedDate": "2020-07-15T02:36:21Z", "type": "commit"}, {"oid": "92c6fe06f54477a071e5aef690091c6cb8b7d317", "url": "https://github.com/linkedin/rest.li/commit/92c6fe06f54477a071e5aef690091c6cb8b7d317", "message": "remove SchemaAnnotationHandlerClassUtil and SchemaAnnotationHandlerUtil since they are not used", "committedDate": "2020-07-16T01:21:38Z", "type": "commit"}, {"oid": "92c6fe06f54477a071e5aef690091c6cb8b7d317", "url": "https://github.com/linkedin/rest.li/commit/92c6fe06f54477a071e5aef690091c6cb8b7d317", "message": "remove SchemaAnnotationHandlerClassUtil and SchemaAnnotationHandlerUtil since they are not used", "committedDate": "2020-07-16T01:21:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3ODAwNw==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r456678007", "bodyText": "Nit. Capitalize, same as line 189", "author": "junchuanwang", "createdAt": "2020-07-17T21:15:53Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -134,10 +155,75 @@ private static void parseAndValidateExtensionSchemas(String resolverPath, File i\n           .stream()\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n-      // TODO : Call annotation process to validate each field's annotation, need to create schemaVisitor and handler for extension annotation.\n+\n+      checkExtensionSchemaFields(extensionSchemaFields);\n+    }\n+  }\n+\n+  private static void checkExtensionSchemaFields(List<RecordDataSchema.Field> extensionSchemaFields)\n+  {\n+    for (RecordDataSchema.Field field : extensionSchemaFields)\n+    {\n+      // check extension schema field annotation\n+      Map<String, Object> properties = field.getProperties();\n+      if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(EXTENSION_ANNOTATION_NAMESPACE))\n+      {\n+        _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+        System.exit(1);\n+      }\n+      Object dataElement = properties.get(EXTENSION_ANNOTATION_NAMESPACE);\n+\n+      ValidationOptions validationOptions =\n+          new ValidationOptions(RequiredMode.MUST_BE_PRESENT, CoercionMode.STRING_TO_PRIMITIVE, UnrecognizedFieldMode.DISALLOW);\n+      try\n+      {\n+        if (!(dataElement instanceof DataMap))\n+        {\n+          _logger.error(\"extension schema annotation is not a datamap!\");\n+          System.exit(1);\n+        }\n+        DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n+        ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n+        if (!result.isValid())\n+        {\n+          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());", "originalCommit": "92c6fe06f54477a071e5aef690091c6cb8b7d317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MTg0Mg==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r456961842", "bodyText": "Fixed", "author": "nickibi", "createdAt": "2020-07-19T22:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY3ODAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "b6585951e1f303f4807e3396eb60bafb10dbbf62", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex 5df205faf..8cdb285b2 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -179,14 +179,14 @@ public class ExtensionSchemaValidationCmdLineApp\n       {\n         if (!(dataElement instanceof DataMap))\n         {\n-          _logger.error(\"extension schema annotation is not a datamap!\");\n+          _logger.error(\"Extension schema annotation is not a datamap!\");\n           System.exit(1);\n         }\n         DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n         ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n         if (!result.isValid())\n         {\n-          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n+          _logger.error(\"Extension schema annotation is not valid: \" + result.getMessages());\n           System.exit(1);\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4ODk3Ng==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r456688976", "bodyText": "Would think it better to remove \"IS\" in the name: isArrayAndItemsAnnotatedWithResourceKey", "author": "junchuanwang", "createdAt": "2020-07-17T21:50:13Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -134,10 +155,75 @@ private static void parseAndValidateExtensionSchemas(String resolverPath, File i\n           .stream()\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n-      // TODO : Call annotation process to validate each field's annotation, need to create schemaVisitor and handler for extension annotation.\n+\n+      checkExtensionSchemaFields(extensionSchemaFields);\n+    }\n+  }\n+\n+  private static void checkExtensionSchemaFields(List<RecordDataSchema.Field> extensionSchemaFields)\n+  {\n+    for (RecordDataSchema.Field field : extensionSchemaFields)\n+    {\n+      // check extension schema field annotation\n+      Map<String, Object> properties = field.getProperties();\n+      if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(EXTENSION_ANNOTATION_NAMESPACE))\n+      {\n+        _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+        System.exit(1);\n+      }\n+      Object dataElement = properties.get(EXTENSION_ANNOTATION_NAMESPACE);\n+\n+      ValidationOptions validationOptions =\n+          new ValidationOptions(RequiredMode.MUST_BE_PRESENT, CoercionMode.STRING_TO_PRIMITIVE, UnrecognizedFieldMode.DISALLOW);\n+      try\n+      {\n+        if (!(dataElement instanceof DataMap))\n+        {\n+          _logger.error(\"extension schema annotation is not a datamap!\");\n+          System.exit(1);\n+        }\n+        DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n+        ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n+        if (!result.isValid())\n+        {\n+          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n+          System.exit(1);\n+        }\n+      }\n+      catch (Exception e)\n+      {\n+        _logger.error(\"Error while checking extension schema field annotation: \" + e.getMessage());\n+        System.exit(1);\n+      }\n+      checkExtensionSchemaFieldSchema(field.getType());\n     }\n   }\n \n+  private static void checkExtensionSchemaFieldSchema(DataSchema fieldSchema)\n+  {\n+    if (!isAnnotatedWithResourceKey(fieldSchema) && !isArrayAndItemIsAnnotatedWithResourceKey(fieldSchema))\n+    {\n+        _logger.error(\"Field schema: [{}] is not annotated with 'resourceKey'\", fieldSchema.toString());\n+        System.exit(1);\n+    }\n+  }\n+\n+  private static boolean isArrayAndItemIsAnnotatedWithResourceKey(DataSchema schema)", "originalCommit": "92c6fe06f54477a071e5aef690091c6cb8b7d317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2MTgyMg==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r456961822", "bodyText": "Removed \"is\"", "author": "nickibi", "createdAt": "2020-07-19T22:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4ODk3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b6585951e1f303f4807e3396eb60bafb10dbbf62", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex 5df205faf..8cdb285b2 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -179,14 +179,14 @@ public class ExtensionSchemaValidationCmdLineApp\n       {\n         if (!(dataElement instanceof DataMap))\n         {\n-          _logger.error(\"extension schema annotation is not a datamap!\");\n+          _logger.error(\"Extension schema annotation is not a datamap!\");\n           System.exit(1);\n         }\n         DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n         ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n         if (!result.isValid())\n         {\n-          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n+          _logger.error(\"Extension schema annotation is not valid: \" + result.getMessages());\n           System.exit(1);\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4OTMwMQ==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r456689301", "bodyText": "Seems this line can be combined into the try catch clause. I personally would try to minimize the number of exit path (the statement System.exit(1))", "author": "junchuanwang", "createdAt": "2020-07-17T21:51:16Z", "path": "restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java", "diffHunk": "@@ -134,10 +155,75 @@ private static void parseAndValidateExtensionSchemas(String resolverPath, File i\n           .stream()\n           .filter(f -> !((RecordDataSchema) topLevelDataSchema).isFieldFromIncludes(f))\n           .collect(Collectors.toList());\n-      // TODO : Call annotation process to validate each field's annotation, need to create schemaVisitor and handler for extension annotation.\n+\n+      checkExtensionSchemaFields(extensionSchemaFields);\n+    }\n+  }\n+\n+  private static void checkExtensionSchemaFields(List<RecordDataSchema.Field> extensionSchemaFields)\n+  {\n+    for (RecordDataSchema.Field field : extensionSchemaFields)\n+    {\n+      // check extension schema field annotation\n+      Map<String, Object> properties = field.getProperties();\n+      if (properties.isEmpty() || properties.keySet().size() != 1 || !properties.containsKey(EXTENSION_ANNOTATION_NAMESPACE))\n+      {\n+        _logger.error(\"The field [{}] of extension schema must and only be annotated with 'extension'\", field.getName());\n+        System.exit(1);\n+      }\n+      Object dataElement = properties.get(EXTENSION_ANNOTATION_NAMESPACE);\n+\n+      ValidationOptions validationOptions =\n+          new ValidationOptions(RequiredMode.MUST_BE_PRESENT, CoercionMode.STRING_TO_PRIMITIVE, UnrecognizedFieldMode.DISALLOW);\n+      try\n+      {\n+        if (!(dataElement instanceof DataMap))\n+        {\n+          _logger.error(\"extension schema annotation is not a datamap!\");\n+          System.exit(1);\n+        }\n+        DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n+        ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n+        if (!result.isValid())\n+        {\n+          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n+          System.exit(1);\n+        }\n+      }\n+      catch (Exception e)\n+      {\n+        _logger.error(\"Error while checking extension schema field annotation: \" + e.getMessage());\n+        System.exit(1);\n+      }\n+      checkExtensionSchemaFieldSchema(field.getType());", "originalCommit": "92c6fe06f54477a071e5aef690091c6cb8b7d317", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk2Mjc3NQ==", "url": "https://github.com/linkedin/rest.li/pull/254#discussion_r456962775", "bodyText": "Sorry, I don't quite understand it, can you please explain more?", "author": "nickibi", "createdAt": "2020-07-19T22:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4OTMwMQ=="}], "type": "inlineReview", "revised_code": {"commit": "b6585951e1f303f4807e3396eb60bafb10dbbf62", "chunk": "diff --git a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\nindex 5df205faf..8cdb285b2 100644\n--- a/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n+++ b/restli-tools/src/main/java/com/linkedin/restli/tools/data/ExtensionSchemaValidationCmdLineApp.java\n\n@@ -179,14 +179,14 @@ public class ExtensionSchemaValidationCmdLineApp\n       {\n         if (!(dataElement instanceof DataMap))\n         {\n-          _logger.error(\"extension schema annotation is not a datamap!\");\n+          _logger.error(\"Extension schema annotation is not a datamap!\");\n           System.exit(1);\n         }\n         DataSchema extensionSchemaAnnotationSchema = new ExtensionSchemaAnnotation().schema();\n         ValidationResult result = ValidateDataAgainstSchema.validate(dataElement, extensionSchemaAnnotationSchema, validationOptions);\n         if (!result.isValid())\n         {\n-          _logger.error(\"extension schema annotation is not valid: \" + result.getMessages());\n+          _logger.error(\"Extension schema annotation is not valid: \" + result.getMessages());\n           System.exit(1);\n         }\n       }\n"}}, {"oid": "b6585951e1f303f4807e3396eb60bafb10dbbf62", "url": "https://github.com/linkedin/rest.li/commit/b6585951e1f303f4807e3396eb60bafb10dbbf62", "message": "Address review feedback", "committedDate": "2020-07-19T22:26:12Z", "type": "commit"}, {"oid": "cc66c86c60f933a7925e524d60886dbf28d564f7", "url": "https://github.com/linkedin/rest.li/commit/cc66c86c60f933a7925e524d60886dbf28d564f7", "message": "Update CHANGELOG", "committedDate": "2020-07-20T22:25:12Z", "type": "commit"}]}