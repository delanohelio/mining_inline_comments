{"pr_number": 14963, "pr_title": "Runtime updates for jaxws-2.3", "pr_createdAt": "2020-11-13T16:17:17Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/14963", "timeline": [{"oid": "7331953aa59a9edd7eed6aa79ef2ca5bd41c3a44", "url": "https://github.com/OpenLiberty/open-liberty/commit/7331953aa59a9edd7eed6aa79ef2ca5bd41c3a44", "message": "Undo changes to jaxws.common by bad merge", "committedDate": "2020-11-13T16:32:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA2NTQ5Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r523065492", "bodyText": "Because these tests use jaxwstest-2.x feature files to override what API's are exported to the APP class path, I've had to break the tests into different versions. I had a problem building them after I undid some tests changes, and for the sake of time I've just stashed them locally to revisit.", "author": "neuwerk", "createdAt": "2020-11-13T16:34:33Z", "path": "dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java", "diffHunk": "@@ -33,7 +33,9 @@\n                 CXFJMXSupportTest.class,\n                 WebServiceMonitorTest.class,\n                 HttpConduitPropertiesTest.class,\n+                //HttpConduitPropertiesTest23.class,", "originalCommit": "7331953aa59a9edd7eed6aa79ef2ca5bd41c3a44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "35259487ef04b4431024027567317336110c630f", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java\nindex 27073572b4..8171613739 100755\n--- a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java\n+++ b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java\n\n@@ -33,9 +36,9 @@ import componenttest.rules.repeater.RepeatTests;\n                 CXFJMXSupportTest.class,\n                 WebServiceMonitorTest.class,\n                 HttpConduitPropertiesTest.class,\n-                //HttpConduitPropertiesTest23.class,\n+                HttpConduitPropertiesTest23.class,\n                 EJBServiceRefBndTest.class,\n-                //EJBServiceRefBndTest23.class,\n+                EJBServiceRefBndTest23.class,\n                 PortComponentRefTest.class,\n                 EndpointPropertiesTest.class,\n                 BindingTypeWsdlMismatchTest.class,\n"}}, {"oid": "35259487ef04b4431024027567317336110c630f", "url": "https://github.com/OpenLiberty/open-liberty/commit/35259487ef04b4431024027567317336110c630f", "message": "jaxws-2.3 runtime and FAT updates", "committedDate": "2020-11-20T02:05:25Z", "type": "forcePushed"}, {"oid": "f16e9b5c5e2b36848268264ad7104e673e34850e", "url": "https://github.com/OpenLiberty/open-liberty/commit/f16e9b5c5e2b36848268264ad7104e673e34850e", "message": "jaxws-2.3 runtime and FAT updates", "committedDate": "2020-11-20T14:14:37Z", "type": "forcePushed"}, {"oid": "5a3991f7a1573d2eb934ef381a59321da8d703bc", "url": "https://github.com/OpenLiberty/open-liberty/commit/5a3991f7a1573d2eb934ef381a59321da8d703bc", "message": "jaxws-2.3 runtime and FAT updates\n\nmerge fixing", "committedDate": "2020-11-20T15:38:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NjQ1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r527886453", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "author": "andymc12", "createdAt": "2020-11-20T18:12:49Z", "path": "dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest23.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 IBM Corporation and others.", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MjQ1OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535342458", "bodyText": "Refactored and deleted this file", "author": "neuwerk", "createdAt": "2020-12-03T15:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NjQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest23.java b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest23.java\nindex 5f68f32b19..196b505596 100755\n--- a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest23.java\n+++ b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest23.java\n\n@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2020 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NzY0Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r527887642", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2019 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2020 IBM Corporation and others.", "author": "andymc12", "createdAt": "2020-11-20T18:15:00Z", "path": "dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/HttpConduitPropertiesTest23.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/*******************************************************************************\n+ * Copyright (c) 2019 IBM Corporation and others.", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0Mjk2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535342969", "bodyText": "Refactored and deleted this file", "author": "neuwerk", "createdAt": "2020-12-03T15:39:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzg4NzY0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/HttpConduitPropertiesTest23.java b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/HttpConduitPropertiesTest23.java\nindex e6fac11336..cad68bf3a1 100755\n--- a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/HttpConduitPropertiesTest23.java\n+++ b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/HttpConduitPropertiesTest23.java\n\n@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2020 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNjg0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528026848", "bodyText": "Could you add //Liberty change comments here to distinguish the code that is specific to Liberty vs the rest of CXF code?", "author": "andymc12", "createdAt": "2020-11-20T23:42:06Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurer.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.ibm.ws.jaxws;\n+\n+import java.util.Dictionary;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.transport.http.HTTPConduit;\n+import org.apache.cxf.transport.http.HTTPConduitConfigurer;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.cm.ConfigurationException;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+\n+/**\n+ *  Allows us to Apply our HTTPConduit configuration on a HTTPConduit via a ManagedService added to the Bus\n+ *  Mostly borrowed from\n+ *  org.apache.cxf.transport.http.asyncclient.Activator\n+ *  org.apache.cxf.transport.http.osgi.HttpConduitConfigApplier\n+ */\n+public class ConduitConfigurer extends ConduitConfigurerService  implements HTTPConduitConfigurer {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurer.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurer.java\nindex 0670003627..6f748973f6 100644\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurer.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurer.java\n\n@@ -41,6 +41,8 @@ import com.ibm.websphere.ras.TraceComponent;\n  *  org.apache.cxf.transport.http.osgi.HttpConduitConfigApplier\n  */\n public class ConduitConfigurer extends ConduitConfigurerService  implements HTTPConduitConfigurer {\n+    \n+    //  Liberty Code change\n     private static final TraceComponent tc = Tr.register(ConduitConfigurer.class);\n     public static final String FACTORY_PID = \"org.apache.cxf.http.conduits\";\n     public ConduitConfigurer(BundleContext context) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNjk4Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528026987", "bodyText": "Same comment here wrt //Liberty change", "author": "andymc12", "createdAt": "2020-11-20T23:42:40Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurerService.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.ibm.ws.jaxws;\n+\n+import java.util.Dictionary;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.ServiceReference;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedService;\n+import org.osgi.util.tracker.ServiceTracker;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+\n+/**\n+ *  Lifted from org.apache.cxf.transport.http.asyncclient.Activator\n+ */\n+public class ConduitConfigurerService extends ServiceTracker<Bus, Bus> implements ManagedService {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurerService.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurerService.java\nindex 2566832a4f..d149247949 100644\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurerService.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/ConduitConfigurerService.java\n\n@@ -40,8 +40,10 @@ import com.ibm.websphere.ras.TraceComponent;\n public class ConduitConfigurerService extends ServiceTracker<Bus, Bus> implements ManagedService {\n     private Map<String, Object> currentConfig;\n     \n+    // Liberty Code Change\n     private static final TraceComponent tc = Tr.register(ConduitConfigurerService.class);\n \n+ // Liberty Code Change\n     public ConduitConfigurerService(BundleContext context) {\n         super(context, Bus.class, null);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzMxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528027316", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Copyright (c) 2012 IBM Corporation and others.\n          \n          \n            \n             * Copyright (c) 2019, 2020 IBM Corporation and others.", "author": "andymc12", "createdAt": "2020-11-20T23:44:00Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2012 IBM Corporation and others.", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java\nindex 7c443a6c93..03de66251e 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java\n\n@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2012 IBM Corporation and others.\n+ * Copyright (c) 2019,2020 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzcyMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528027722", "bodyText": "Remove these lines?", "author": "andymc12", "createdAt": "2020-11-20T23:45:31Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyCustomizeBindingOutInterceptor.java", "diffHunk": "@@ -244,26 +183,95 @@ protected void customizePortAddress(Message message) {\n     }\n \n     private void customizeHttpConduitProperties(Message message, Bus bus, ConfigProperties configProps) {\n-        Conduit conduit = message.getExchange().getConduit(message);\n-        HTTPConduitConfigurer conduitConfigurer = bus.getExtension(HTTPConduitConfigurer.class);\n+        HTTPConduit conduit = (HTTPConduit) message.getExchange().getConduit(message);\n+        // applyClientPolicies(configProps.getProperties(), conduit);\n+\n+        //Conduit conduit = message.getExchange().getConduit(message);", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyCustomizeBindingOutInterceptor.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyCustomizeBindingOutInterceptor.java\nindex c4815a9dc5..782ce609f1 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyCustomizeBindingOutInterceptor.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyCustomizeBindingOutInterceptor.java\n\n@@ -184,9 +184,7 @@ public class LibertyCustomizeBindingOutInterceptor extends AbstractPhaseIntercep\n \n     private void customizeHttpConduitProperties(Message message, Bus bus, ConfigProperties configProps) {\n         HTTPConduit conduit = (HTTPConduit) message.getExchange().getConduit(message);\n-        // applyClientPolicies(configProps.getProperties(), conduit);\n \n-        //Conduit conduit = message.getExchange().getConduit(message);\n         ConduitConfigurer conduitConfigurer = (ConduitConfigurer) bus.getExtension(HTTPConduitConfigurer.class);\n \n      \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODM3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528028377", "bodyText": "Is this just added for auto-trace injection?  I don't think it's necessary unless you also want to add explicit trace statements.", "author": "andymc12", "createdAt": "2020-11-20T23:48:38Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java", "diffHunk": "@@ -27,6 +30,8 @@\n  * JaxWsModuleMetaData holds all the runtime data for the webservice engine, e.g. Container, classloader and etc.\n  */\n public class JaxWsModuleMetaData {\n+    \n+    private static final TraceComponent tc = Tr.register( JaxWsModuleMetaData.class);", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49820a9e33ec2681714c1a6948934639fade187d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java\nindex 585d9d6800..d49d6bfd64 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java\n\n@@ -30,8 +27,6 @@ import com.ibm.wsspi.injectionengine.ReferenceContext;\n  * JaxWsModuleMetaData holds all the runtime data for the webservice engine, e.g. Container, classloader and etc.\n  */\n public class JaxWsModuleMetaData {\n-    \n-    private static final TraceComponent tc = Tr.register( JaxWsModuleMetaData.class);\n \n     private volatile JaxWsServerMetaData serverMetaData;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODUzOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528028539", "bodyText": "Same as above - you can probably remove this unless you want to add explicit trace statements.", "author": "andymc12", "createdAt": "2020-11-20T23:49:16Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsServerMetaData.java", "diffHunk": "@@ -15,11 +15,15 @@\n import java.util.Map.Entry;\n \n import com.ibm.websphere.csi.J2EEName;\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.ws.jaxws.bus.LibertyApplicationBus;\n import com.ibm.ws.jaxws.bus.LibertyApplicationBusFactory;\n \n public class JaxWsServerMetaData {\n \n+    private static final TraceComponent tc = Tr.register( JaxWsServerMetaData.class);", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49820a9e33ec2681714c1a6948934639fade187d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsServerMetaData.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsServerMetaData.java\nindex 5e0ccd5420..d6d1c4eb7f 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsServerMetaData.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsServerMetaData.java\n\n@@ -15,15 +15,11 @@ import java.util.Map;\n import java.util.Map.Entry;\n \n import com.ibm.websphere.csi.J2EEName;\n-import com.ibm.websphere.ras.Tr;\n-import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.ws.jaxws.bus.LibertyApplicationBus;\n import com.ibm.ws.jaxws.bus.LibertyApplicationBusFactory;\n \n public class JaxWsServerMetaData {\n \n-    private static final TraceComponent tc = Tr.register( JaxWsServerMetaData.class);\n-\n     private final LibertyApplicationBus applicationBus;\n \n     private final JaxWsModuleMetaData moduleMetaData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODY5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528028694", "bodyText": "Remove this line too?", "author": "andymc12", "createdAt": "2020-11-20T23:49:47Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -110,7 +110,8 @@ public Policy getEffectivePolicy(BindingMessageInfo bmi) {\n     }\n \n     // @TJJ removed overridde annotation", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex 87e02af87a..ce830f2e8b 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -111,7 +111,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n \n     // @TJJ removed overridde annotation\n     @Override\n-    public Policy getEffectivePolicy(BindingOperationInfo boi, Message M) {\n+    public Policy getEffectivePolicy(BindingOperationInfo boi, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n             Tr.debug(tc, \"getEffectivePolicy for BindingOperationInfo\", boi != null ? boi : null);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODk1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528028953", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Policy getEffectivePolicy(BindingFaultInfo bfi, Message M) {\n          \n          \n            \n                public Policy getEffectivePolicy(BindingFaultInfo bfi, Message m) {\n          \n      \n    \n    \n  \n\nsuggest lowercase for parameter variables", "author": "andymc12", "createdAt": "2020-11-20T23:50:51Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -69,8 +69,8 @@ public String getLocation() {\n         return location;\n     }\n \n-    // @TJJ removed overridde annotation\n-    public Policy getEffectivePolicy(BindingFaultInfo bfi) {\n+    @Override\n+    public Policy getEffectivePolicy(BindingFaultInfo bfi, Message M) {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex 87e02af87a..ce830f2e8b 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -70,7 +70,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n     }\n \n     @Override\n-    public Policy getEffectivePolicy(BindingFaultInfo bfi, Message M) {\n+    public Policy getEffectivePolicy(BindingFaultInfo bfi, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n             Tr.debug(tc, \"getEffectivePolicy for BindingFaultInfo\", bfi != null ? bfi : null);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyOTAwMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528029002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Policy getEffectivePolicy(BindingMessageInfo bmi, Message M) {\n          \n          \n            \n                public Policy getEffectivePolicy(BindingMessageInfo bmi, Message m) {", "author": "andymc12", "createdAt": "2020-11-20T23:51:01Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -89,8 +89,8 @@ public Policy getEffectivePolicy(BindingFaultInfo bfi) {\n         return p;\n     }\n \n-    // @TJJ removed overridde annotation\n-    public Policy getEffectivePolicy(BindingMessageInfo bmi) {\n+    @Override\n+    public Policy getEffectivePolicy(BindingMessageInfo bmi, Message M) {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex 87e02af87a..ce830f2e8b 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -90,7 +90,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n     }\n \n     @Override\n-    public Policy getEffectivePolicy(BindingMessageInfo bmi, Message M) {\n+    public Policy getEffectivePolicy(BindingMessageInfo bmi, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n             Tr.debug(tc, \"getEffectivePolicy for BindingMessageInfo\", bmi != null ? bmi.getMessageInfo() : null);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyOTA0OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528029049", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Policy getEffectivePolicy(BindingOperationInfo boi, Message M) {\n          \n          \n            \n                public Policy getEffectivePolicy(BindingOperationInfo boi, Message m) {", "author": "andymc12", "createdAt": "2020-11-20T23:51:09Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -110,7 +110,8 @@ public Policy getEffectivePolicy(BindingMessageInfo bmi) {\n     }\n \n     // @TJJ removed overridde annotation\n-    public Policy getEffectivePolicy(BindingOperationInfo boi) {\n+    @Override\n+    public Policy getEffectivePolicy(BindingOperationInfo boi, Message M) {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex 87e02af87a..ce830f2e8b 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -111,7 +111,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n \n     // @TJJ removed overridde annotation\n     @Override\n-    public Policy getEffectivePolicy(BindingOperationInfo boi, Message M) {\n+    public Policy getEffectivePolicy(BindingOperationInfo boi, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n             Tr.debug(tc, \"getEffectivePolicy for BindingOperationInfo\", boi != null ? boi : null);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyOTA3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528029074", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Policy getEffectivePolicy(EndpointInfo ei, Message M) {\n          \n          \n            \n                public Policy getEffectivePolicy(EndpointInfo ei, Message m) {", "author": "andymc12", "createdAt": "2020-11-20T23:51:18Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -129,8 +130,8 @@ public Policy getEffectivePolicy(BindingOperationInfo boi) {\n         return p;\n     }\n \n-    // @TJJ removed overridde annotation\n-    public Policy getEffectivePolicy(EndpointInfo ei) {\n+    @Override\n+    public Policy getEffectivePolicy(EndpointInfo ei, Message M) {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex 87e02af87a..ce830f2e8b 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -131,7 +131,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n     }\n \n     @Override\n-    public Policy getEffectivePolicy(EndpointInfo ei, Message M) {\n+    public Policy getEffectivePolicy(EndpointInfo ei, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n             Tr.debug(tc, \"getEffectivePolicy for EndpointInfo\", ei != null ? ei : null);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyOTEwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r528029107", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Policy getEffectivePolicy(ServiceInfo si, Message M) {\n          \n          \n            \n                public Policy getEffectivePolicy(ServiceInfo si, Message m) {", "author": "andymc12", "createdAt": "2020-11-20T23:51:26Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -149,8 +150,8 @@ public Policy getEffectivePolicy(EndpointInfo ei) {\n         return p;\n     }\n \n-    // @TJJ removed overridde annotation\n-    public Policy getEffectivePolicy(ServiceInfo si) {\n+    @Override\n+    public Policy getEffectivePolicy(ServiceInfo si, Message M) {", "originalCommit": "69827679e6e9a49d97b5b5f042d0f5826cbb4878", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "d62924d7aabc0ccc847e83f0fb83f16187405923", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex 87e02af87a..ce830f2e8b 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -151,7 +151,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n     }\n \n     @Override\n-    public Policy getEffectivePolicy(ServiceInfo si, Message M) {\n+    public Policy getEffectivePolicy(ServiceInfo si, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n             Tr.debug(tc, \"getEffectivePolicy for ServiceInfo\", si != null ? si.getName() : null);\n         }\n"}}, {"oid": "d62924d7aabc0ccc847e83f0fb83f16187405923", "url": "https://github.com/OpenLiberty/open-liberty/commit/d62924d7aabc0ccc847e83f0fb83f16187405923", "message": "add wsat\n\njaxws-2.3 runtime and FAT updates\n\nmerge fixing\n\nadditional jaxws-2.3 code clean up changes\n\nAdd jaxws-2.3 changes for code review and more test fixes", "committedDate": "2020-11-23T09:20:09Z", "type": "forcePushed"}, {"oid": "78a64c9e5b5d62deb5cc4f6b5082c628e86f1134", "url": "https://github.com/OpenLiberty/open-liberty/commit/78a64c9e5b5d62deb5cc4f6b5082c628e86f1134", "message": "Update CXF versions to match CXF Core to fix failures in multiple jaxrs and jaxws buckets", "committedDate": "2020-11-24T21:12:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMzc5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r530023791", "bodyText": "@TJJ still here", "author": "WhiteCat22", "createdAt": "2020-11-25T00:07:34Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java", "diffHunk": "@@ -110,7 +110,8 @@ public Policy getEffectivePolicy(BindingMessageInfo bmi) {\n     }\n \n     // @TJJ removed overridde annotation", "originalCommit": "78a64c9e5b5d62deb5cc4f6b5082c628e86f1134", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzODI4Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r530038286", "bodyText": "Nice catch!", "author": "neuwerk", "createdAt": "2020-11-25T00:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMzc5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "33192c7927bae6e5516a9ccb59bbd5edbdff6c9d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\nindex ce830f2e8b..32cfc448ee 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/policy/DynamicAttachmentProvider.java\n\n@@ -109,7 +109,7 @@ public class DynamicAttachmentProvider extends AbstractPolicyProvider implements\n         return p;\n     }\n \n-    // @TJJ removed overridde annotation\n+\n     @Override\n     public Policy getEffectivePolicy(BindingOperationInfo boi, Message m) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNDYwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r530024606", "bodyText": "should be 2019, 2020\nwe are supposed to preserve the original date", "author": "WhiteCat22", "createdAt": "2020-11-25T00:10:09Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2020 IBM Corporation and others.", "originalCommit": "78a64c9e5b5d62deb5cc4f6b5082c628e86f1134", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "33192c7927bae6e5516a9ccb59bbd5edbdff6c9d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java\nindex ea80f08c9c..d6a8fa3e84 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java\n\n@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2020 IBM Corporation and others.\n+ * Copyright (c) 2019,2020 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n"}}, {"oid": "33192c7927bae6e5516a9ccb59bbd5edbdff6c9d", "url": "https://github.com/OpenLiberty/open-liberty/commit/33192c7927bae6e5516a9ccb59bbd5edbdff6c9d", "message": "More code review comments\n\nremove wrong version change\n\nremove wrong version change", "committedDate": "2020-11-25T16:01:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2MDIxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r530560216", "bodyText": "Copyright year adjustment", "author": "BerksanAtes", "createdAt": "2020-11-25T18:06:56Z", "path": "dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/LibertyJaxWsServlet.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2012 IBM Corporation and others.", "originalCommit": "33192c7927bae6e5516a9ccb59bbd5edbdff6c9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MTc2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535351760", "bodyText": "Removed webcontainer bundle", "author": "neuwerk", "createdAt": "2020-12-03T15:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2MDIxNg=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/LibertyJaxWsServlet.java b/dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/LibertyJaxWsServlet.java\ndeleted file mode 100644\nindex c8602eef66..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/LibertyJaxWsServlet.java\n+++ /dev/null\n\n@@ -1,143 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2012 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.jaxws23.webcontainer;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.http.HttpServlet;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-\n-import com.ibm.ws.jaxws.endpoint.JaxWsWebEndpoint;\n-import com.ibm.ws.runtime.metadata.ComponentMetaData;\n-import com.ibm.ws.threadContext.ComponentMetaDataAccessorImpl;\n-import com.ibm.wsspi.webcontainer.collaborator.IWebAppNameSpaceCollaborator;\n-\n-/**\n- *\n- */\n-public class LibertyJaxWsServlet extends HttpServlet {\n-\n-    private static final long serialVersionUID = -6835560282014155024L;\n-\n-    private static final List<String> KNOWN_HTTP_VERBS = Arrays.asList(new String[] { \"POST\", \"GET\", \"PUT\", \"DELETE\", \"HEAD\", \"OPTIONS\", \"TRACE\" });\n-\n-    private static final String HTML_CONTENT_TYPE = \"text/html\";\n-\n-    private final transient JaxWsWebEndpoint endpoint;\n-\n-    private final transient IWebAppNameSpaceCollaborator collaborator;\n-\n-    public LibertyJaxWsServlet(JaxWsWebEndpoint endpoint) {\n-        this(endpoint, null);\n-    }\n-\n-    public LibertyJaxWsServlet(JaxWsWebEndpoint endpoint, IWebAppNameSpaceCollaborator collaborator) {\n-        this.endpoint = endpoint;\n-        this.collaborator = collaborator;\n-    }\n-\n-    @Override\n-    public void init(ServletConfig servletConfig) throws ServletException {\n-        super.init(servletConfig);\n-        endpoint.init(servletConfig);\n-    }\n-\n-    /**\n-     * As AbstractHTTPServlet in CXF, with this, it will make sure that, all the request methods\n-     * will be routed to handleRequest method.\n-     */\n-    @Override\n-    public void service(ServletRequest req, ServletResponse res)\n-                    throws ServletException, IOException {\n-\n-        HttpServletRequest request;\n-        HttpServletResponse response;\n-\n-        try {\n-            request = (HttpServletRequest) req;\n-            if (collaborator != null) {\n-                ComponentMetaData componentMetaData = ComponentMetaDataAccessorImpl.getComponentMetaDataAccessor().getComponentMetaData();\n-                request = new JaxWsHttpServletRequestAdapter(request, collaborator, componentMetaData);\n-            }\n-            response = (HttpServletResponse) res;\n-        } catch (ClassCastException e) {\n-            throw new ServletException(\"Unrecognized HTTP request or response object\", e);\n-        }\n-\n-        String method = request.getMethod();\n-        if (KNOWN_HTTP_VERBS.contains(method)) {\n-            super.service(request, response);\n-        } else {\n-            handleRequest(request, response);\n-        }\n-    }\n-\n-    @Override\n-    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n-        handleRequest(request, response);\n-    }\n-\n-    @Override\n-    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n-        if (null == request.getQueryString()) {\n-            reportAvailableService(request, response);\n-        } else {\n-            handleRequest(request, response);\n-        }\n-    }\n-\n-    /**\n-     * Prints a welcome message for the endpoint\n-     * \n-     * @param resquest\n-     * @param response\n-     */\n-    private void reportAvailableService(HttpServletRequest request, HttpServletResponse response) throws IOException {\n-        PrintWriter writer = response.getWriter();\n-        response.setContentType(HTML_CONTENT_TYPE);\n-        writer.println(\"<h2>\" + request.getServletPath() + \"</h2>\");\n-        writer.println(\"<h3>Hello! This is a CXF Web Service!</h3>\");\n-    }\n-\n-    @Override\n-    protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n-        handleRequest(request, response);\n-    }\n-\n-    @Override\n-    protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n-        handleRequest(request, response);\n-    }\n-\n-    @Override\n-    protected void doHead(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n-        handleRequest(request, response);\n-    }\n-\n-    protected void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException {\n-        endpoint.invoke(request, response);\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void destroy() {\n-        endpoint.destroy();\n-        super.destroy();\n-    }\n-}\n"}}, {"oid": "c612ac854cf268b9805f607807d2963c5b51e676", "url": "https://github.com/OpenLiberty/open-liberty/commit/c612ac854cf268b9805f607807d2963c5b51e676", "message": "Update CXF versions to match CXF Core to fix failures in multiple jaxrs and jaxws buckets\n\nMore code review comments\n\nMore code review comments\n\nremove wrong version change\n\nremove wrong version change\n\nMore code review changes", "committedDate": "2020-11-25T20:58:08Z", "type": "forcePushed"}, {"oid": "432992c3adcb846c4ae54cef461c963d615866c3", "url": "https://github.com/OpenLiberty/open-liberty/commit/432992c3adcb846c4ae54cef461c963d615866c3", "message": "Update CXF versions to match CXF Core to fix failures in multiple jaxrs and jaxws buckets\n\nMore code review comments\n\nMore code review comments\n\nremove wrong version change\n\nremove wrong version change\n\nMore code review changes", "committedDate": "2020-11-28T21:25:07Z", "type": "forcePushed"}, {"oid": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "url": "https://github.com/OpenLiberty/open-liberty/commit/a6acc20fd1ba794ff76daa387c092f02af53f57d", "message": "Update CXF versions to match CXF Core to fix failures in multiple jaxrs and jaxws buckets\n\nMore code review comments\n\nMore code review comments\n\nremove wrong version change\n\nremove wrong version change\n\nMore code review changes\n\nUdno bnd.overrides typo\n\nDiable instrumentation to prevent unncessary FFDCs from being generating by custom JAX-RS execptions", "committedDate": "2020-11-30T15:49:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMDQ3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533030472", "bodyText": "So why do you want to have false?", "author": "jhanders34", "createdAt": "2020-12-01T02:23:48Z", "path": "dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest.java", "diffHunk": "@@ -87,7 +94,10 @@ public void tearDown() throws Exception {\n         }\n \n         if (server.isStarted()) {\n-            server.stopServer();\n+\n+            // Since the individual tests are starting the server due to the config change\n+            // You must remove the false boolean in order to get logs for debuging failures\n+            server.stopServer(false);", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzMDY0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533430646", "bodyText": "That's fair, I was just returning the test to how it was written originally but why it was set to false in the first place doesn't make sense. I'll change it.", "author": "neuwerk", "createdAt": "2020-12-01T14:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMDQ3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest.java b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest.java\nindex 27c3bd11cc..0497534e23 100755\n--- a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest.java\n+++ b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/EJBServiceRefBndTest.java\n\n@@ -94,10 +99,7 @@ public class EJBServiceRefBndTest {\n         }\n \n         if (server.isStarted()) {\n-\n-            // Since the individual tests are starting the server due to the config change\n-            // You must remove the false boolean in order to get logs for debuging failures\n-            server.stopServer(false);\n+            server.stopServer();\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMTEwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533031109", "bodyText": "Why not adding jaxwstest-2.3?  Wouldn't that make combining the tests into a single test like mentioned above possible?", "author": "jhanders34", "createdAt": "2020-12-01T02:25:51Z", "path": "dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java", "diffHunk": "@@ -43,6 +48,6 @@\n })\n public class FATSuite {\n     @ClassRule\n-    public static RepeatTests r = RepeatTests.withoutModification().andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\").removeFeature(\"jaxws-2.2\").removeFeature(\"jsp-2.2\").withID(\"jaxws-2.3\"));\n+    public static RepeatTests r = RepeatTests.withoutModification().andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\").removeFeature(\"jaxws-2.2\").removeFeature(\"jsp-2.2\").removeFeature(\"servlet-3.1\").removeFeature(\"jaxwstest-2.2\").withID(\"jaxws-2.3\"));", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQzNzU1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533437550", "bodyText": "Oh nice catch, I actually didn't intend to leave that removal here. That was a hold over from my initial attempt to keep both versions in one test. I actually hadn't thought of adding the jaxwstest-2.3 here, and maybe that would work? I guess it depends on when the config change described here actually occurs. The test is manually copying the test feature file jaxwstest-2.3.mf to the wlp\\lib directory in the @BeforeClass, method so if the feature is there at that point, I suppose it would work.", "author": "neuwerk", "createdAt": "2020-12-01T14:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMTEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5MDI0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533590245", "bodyText": "yeah I would expect you to add the 2.2 and 2.3 mf files during @BeforeClass and then remove them the same way you do now.", "author": "jhanders34", "createdAt": "2020-12-01T17:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzMTEwOQ=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java\nindex 8171613739..b705b58845 100755\n--- a/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java\n+++ b/dev/com.ibm.ws.jaxws.2.2.webcontainer_fat/fat/src/com/ibm/ws/jaxws/fat/FATSuite.java\n\n@@ -47,7 +41,4 @@ import componenttest.rules.repeater.RepeatTests;\n                 VirtualHostTest.class\n })\n public class FATSuite {\n-    @ClassRule\n-    public static RepeatTests r = RepeatTests.withoutModification().andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\").removeFeature(\"jaxws-2.2\").removeFeature(\"jsp-2.2\").removeFeature(\"servlet-3.1\").removeFeature(\"jaxwstest-2.2\").withID(\"jaxws-2.3\"));\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzNzE4OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533037188", "bodyText": "Again same question about the com.ibm.ws instead of using existing cxf file.", "author": "jhanders34", "createdAt": "2020-12-01T02:45:11Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsConduitConfigActivator.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ4NTEyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533485124", "bodyText": "There are several reasons I did this:\n\nI had to split the original CXF classes as written. The main reason for splitting the classes is that the the way in which the jaxws-2.x integration layer adds it's sub-classed or Open-Liberty specific extensions to CXF's Bus. That's using via Bus Extensions, and the way that our integration layer registers these extensions requires the extension to have a default constructor. I split the single CXF Activator class into the ConduitConfigurer and ConduitConfigurerService because of the need for a default constructor.\nCXF uses an OSGi ManagedService for the configuration application to it's Conduit object, and builds that MangedService with the bundle context via the bundle activation method. I created the JaxWsConduitConfigActivator for two functions: to serve as a declarative service and get the BundleContext needed for the ManagedService, but also to act as an ExtensionProvider so we can register the our ConduitConfigurer class as an HTTPConduitConfigurer extension on the Bus. Of the three classes this is probably the most functionally different from the original CXF class. I \"lifted\" the start() stop() methods, but it's role as an DS Component is unique to Open-Libertry\nThe CXF Activator class relies on another CXF BundleActivator class: the HTTPTransportsActivator class. The JAX-RS team disables that class from being turned on (see com.ibm.ws.cxf.transports.http.NoOpActivator), which means the original CXF class is unusable at runtime by our JAX-WS integration layer. This refactoring allows our integration layer to get around disabling the rest of CXF transport layer's bundle activation.\nThe HttpConduitConfigApplier is a private class, so opening it up to would be a change to CXF which I was trying to avoid. If a change to making the class public is fine, then I do think this class could be dropped entirely.", "author": "neuwerk", "createdAt": "2020-12-01T15:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzNzE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMyNTkyNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535325927", "bodyText": "Then my concern is that we do not have the open liberty copyright.  Should it have both the open liberty copyright and the CXF apache one?  Of course this applies to the other ones as well.", "author": "jhanders34", "createdAt": "2020-12-03T15:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzNzE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "49820a9e33ec2681714c1a6948934639fade187d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsConduitConfigActivator.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsConduitConfigActivator.java\ndeleted file mode 100644\nindex 9dc7236312..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsConduitConfigActivator.java\n+++ /dev/null\n\n@@ -1,82 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.ibm.ws.jaxws;\n-\n-import java.util.Dictionary;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Hashtable;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.bus.extension.Extension;\n-import org.apache.cxf.transport.http.HTTPConduit;\n-import org.apache.cxf.transport.http.HTTPConduitConfigurer;\n-import org.apache.cxf.transport.http.HTTPTransportFactory;\n-import org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory;\n-import org.osgi.framework.BundleActivator;\n-import org.osgi.framework.BundleContext;\n-import org.osgi.framework.Constants;\n-import org.osgi.framework.ServiceReference;\n-import org.osgi.service.cm.ConfigurationException;\n-import org.osgi.service.cm.ManagedService;\n-import org.osgi.service.component.annotations.Activate;\n-import org.osgi.service.component.annotations.Component;\n-import org.osgi.service.component.annotations.ConfigurationPolicy;\n-import org.osgi.service.component.annotations.Deactivate;\n-import org.osgi.util.tracker.ServiceTracker;\n-\n-import com.ibm.ws.jaxws.bus.ExtensionProvider;\n-import com.ibm.ws.jaxws.bus.LibertyApplicationBusListener;\n-\n-/**\n- *  Lifted from org.apache.cxf.transport.http.asyncclient.Activator\n- */\n-//Liberty Code Change\n-@Component(immediate = true, property = { \"service.vendor=IBM\" }, configurationPolicy = ConfigurationPolicy.OPTIONAL)\n-public class JaxwsConduitConfigActivator implements ExtensionProvider {\n-    private ConduitConfigurerService conduitConfigurerService;\n-    public static BundleContext context;\n-    @Activate\n-    public void start(BundleContext context) throws Exception {\n-        conduitConfigurerService = new ConduitConfigurerService(context);\n-        conduitConfigurerService.open();\n-        Dictionary<String, Object> properties = new Hashtable<>();\n-        properties.put(Constants.SERVICE_PID, \"org.apache.cxf.transport.http.async\");\n-        context.registerService(ManagedService.class.getName(), conduitConfigurerService, properties);\n-        this.context = context;\n-    }\n-\n-    @Deactivate\n-    public void stop(BundleContext context) throws Exception {\n-        conduitConfigurerService.close();\n-    }\n-\n- // Liberty Code Change\n-    @Override\n-    public Extension getExtension(Bus bus) {\n-        return new Extension((ConduitConfigurer.class), HTTPConduitConfigurer.class);\n-    }\n-\n-}\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzNzQ0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533037440", "bodyText": "Again same questions.  Could we subclass instead of taking the whole file and bring it over?", "author": "jhanders34", "createdAt": "2020-12-01T02:46:03Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsHttpConduitConfigApplier.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.ibm.ws.jaxws;\n+\n+\n+import java.util.Dictionary;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+import org.apache.cxf.configuration.jsse.TLSClientParameters;\n+import org.apache.cxf.configuration.jsse.TLSParameterJaxBUtils;\n+import org.apache.cxf.configuration.security.AuthorizationPolicy;\n+import org.apache.cxf.configuration.security.CertStoreType;\n+import org.apache.cxf.configuration.security.CertificateConstraintsType;\n+import org.apache.cxf.configuration.security.CombinatorType;\n+import org.apache.cxf.configuration.security.DNConstraintsType;\n+import org.apache.cxf.configuration.security.FiltersType;\n+import org.apache.cxf.configuration.security.KeyManagersType;\n+import org.apache.cxf.configuration.security.KeyStoreType;\n+import org.apache.cxf.configuration.security.ProxyAuthorizationPolicy;\n+import org.apache.cxf.configuration.security.SecureRandomParameters;\n+import org.apache.cxf.configuration.security.TrustManagersType;\n+import org.apache.cxf.transport.http.HTTPConduit;\n+import org.apache.cxf.transport.http.auth.HttpAuthSupplier;\n+import org.apache.cxf.transports.http.configuration.ConnectionType;\n+import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;\n+import org.apache.cxf.transports.http.configuration.ProxyServerType;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+\n+/**\n+ * Applies configuration properties to a HTTPConduit\n+ * Lifted from org.apache.cxf.transport.http.osgi.HttpConduitConfigApplier\n+ */\n+public class JaxwsHttpConduitConfigApplier {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49820a9e33ec2681714c1a6948934639fade187d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsHttpConduitConfigApplier.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsHttpConduitConfigApplier.java\ndeleted file mode 100644\nindex 70fca0f43b..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/JaxwsHttpConduitConfigApplier.java\n+++ /dev/null\n\n@@ -1,387 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package com.ibm.ws.jaxws;\n-\n-\n-import java.util.Dictionary;\n-import java.util.Enumeration;\n-import java.util.List;\n-import java.util.StringTokenizer;\n-\n-import org.apache.cxf.configuration.jsse.TLSClientParameters;\n-import org.apache.cxf.configuration.jsse.TLSParameterJaxBUtils;\n-import org.apache.cxf.configuration.security.AuthorizationPolicy;\n-import org.apache.cxf.configuration.security.CertStoreType;\n-import org.apache.cxf.configuration.security.CertificateConstraintsType;\n-import org.apache.cxf.configuration.security.CombinatorType;\n-import org.apache.cxf.configuration.security.DNConstraintsType;\n-import org.apache.cxf.configuration.security.FiltersType;\n-import org.apache.cxf.configuration.security.KeyManagersType;\n-import org.apache.cxf.configuration.security.KeyStoreType;\n-import org.apache.cxf.configuration.security.ProxyAuthorizationPolicy;\n-import org.apache.cxf.configuration.security.SecureRandomParameters;\n-import org.apache.cxf.configuration.security.TrustManagersType;\n-import org.apache.cxf.transport.http.HTTPConduit;\n-import org.apache.cxf.transport.http.auth.HttpAuthSupplier;\n-import org.apache.cxf.transports.http.configuration.ConnectionType;\n-import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;\n-import org.apache.cxf.transports.http.configuration.ProxyServerType;\n-\n-import com.ibm.websphere.ras.Tr;\n-import com.ibm.websphere.ras.TraceComponent;\n-\n-/**\n- * Applies configuration properties to a HTTPConduit\n- * Lifted from org.apache.cxf.transport.http.osgi.HttpConduitConfigApplier\n- */\n-public class JaxwsHttpConduitConfigApplier {\n-    \n- // Liberty Code Change\n-    private static final TraceComponent tc = Tr.register(JaxwsHttpConduitConfigApplier.class);\n-    private static final String SECURE_HTTP_PREFIX = \"https\";\n-\n-    public JaxwsHttpConduitConfigApplier() {\n-        \n-    }\n-\n-    public void apply(Dictionary<String, String> d, HTTPConduit c, String address) {\n-        applyClientPolicies(d, c);\n-        applyAuthorization(d, c);\n-        applyProxyAuthorization(d, c);\n-        if (address != null && address.startsWith(SECURE_HTTP_PREFIX)) {\n-            applyTlsClientParameters(d, c);\n-        }\n-        applyAuthSupplier(d, c);\n-    }\n-\n-    private void applyTlsClientParameters(Dictionary<String, String> d, HTTPConduit c) {\n-\n-        Enumeration<String> keys = d.keys();\n-        TLSClientParameters p = c.getTlsClientParameters();\n-        SecureRandomParameters srp = null;\n-        KeyManagersType kmt = null;\n-        TrustManagersType tmt = null;\n-        boolean enableRevocation = false;\n-        while (keys.hasMoreElements()) {\n-            String k = keys.nextElement();\n-            if (k.startsWith(\"tlsClientParameters.\")) {\n-                if (p == null) {\n-                    p = new TLSClientParameters();\n-                    c.setTlsClientParameters(p);\n-                }\n-                String v = d.get(k);\n-                k = k.substring(\"tlsClientParameters.\".length());\n-\n-                if (\"secureSocketProtocol\".equals(k)) {\n-                    p.setSecureSocketProtocol(v);\n-                } else if (\"sslCacheTimeout\".equals(k)) {\n-                    p.setSslCacheTimeout(Integer.parseInt(v));\n-                } else if (\"jsseProvider\".equals(k)) {\n-                    p.setJsseProvider(v);\n-                } else if (\"disableCNCheck\".equals(k)) {\n-                    p.setDisableCNCheck(Boolean.parseBoolean(v));\n-                } else if (\"useHttpsURLConnectionDefaultHostnameVerifier\".equals(k)) {\n-                    p.setUseHttpsURLConnectionDefaultHostnameVerifier(Boolean.parseBoolean(v));\n-                } else if (\"useHttpsURLConnectionDefaultSslSocketFactory\".equals(k)) {\n-                    p.setUseHttpsURLConnectionDefaultSslSocketFactory(Boolean.parseBoolean(v));\n-                } else if (\"enableRevocation\".equals(k)) {\n-                    enableRevocation = Boolean.parseBoolean(v);\n-                } else if (k.startsWith(\"certConstraints.\")) {\n-                    parseCertConstaints(p, k, v);\n-                } else if (k.startsWith(\"secureRandomParameters.\")) {\n-                    k = k.substring(\"secureRandomParameters.\".length());\n-                    if (srp == null) {\n-                        srp = new SecureRandomParameters();\n-                    }\n-                    if (\"algorithm\".equals(k)) {\n-                        srp.setAlgorithm(v);\n-                    } else if (\"provider\".equals(k)) {\n-                        srp.setProvider(v);\n-                    }\n-                } else if (k.startsWith(\"cipherSuitesFilter.\")) {\n-                    k = k.substring(\"cipherSuitesFilter.\".length());\n-                    StringTokenizer st = new StringTokenizer(v, \",\");\n-                    FiltersType ft = p.getCipherSuitesFilter();\n-                    if (ft == null) {\n-                        ft = new FiltersType();\n-                        p.setCipherSuitesFilter(ft);\n-                    }\n-                    List<String> lst = \"include\".equals(k) ? ft.getInclude() : ft.getExclude();\n-                    while (st.hasMoreTokens()) {\n-                        lst.add(st.nextToken());\n-                    }\n-                } else if (k.startsWith(\"cipherSuites\")) {\n-                    StringTokenizer st = new StringTokenizer(v, \",\");\n-                    while (st.hasMoreTokens()) {\n-                        p.getCipherSuites().add(st.nextToken());\n-                    }\n-                } else if (k.startsWith(\"trustManagers.\")) {\n-                    tmt = getTrustManagers(tmt,\n-                                          k.substring(\"trustManagers.\".length()),\n-                                          v);\n-                } else if (k.startsWith(\"keyManagers.\")) {\n-                    kmt = getKeyManagers(kmt,\n-                                         k.substring(\"keyManagers.\".length()),\n-                                         v);\n-                }\n-            }\n-        }\n-\n-        try {\n-            if (srp != null) {\n-                p.setSecureRandom(TLSParameterJaxBUtils.getSecureRandom(srp));\n-            }\n-            if (kmt != null) {\n-                p.setKeyManagers(TLSParameterJaxBUtils.getKeyManagers(kmt));\n-            }\n-            if (tmt != null) {\n-                p.setTrustManagers(TLSParameterJaxBUtils.getTrustManagers(tmt, enableRevocation));\n-            }\n-        } catch (RuntimeException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private void parseCertConstaints(TLSClientParameters p, String k, String v) {\n-\n-        k = k.substring(\"certConstraints.\".length());\n-        CertificateConstraintsType cct = p.getCertConstraints();\n-        if (cct == null) {\n-            cct = new CertificateConstraintsType();\n-            p.setCertConstraints(cct);\n-        }\n-        DNConstraintsType dnct = null;\n-        if (k.startsWith(\"SubjectDNConstraints.\")) {\n-            dnct = cct.getSubjectDNConstraints();\n-            if (dnct == null) {\n-                dnct = new DNConstraintsType();\n-                cct.setSubjectDNConstraints(dnct);\n-            }\n-            k = k.substring(\"SubjectDNConstraints.\".length());\n-        } else if (k.startsWith(\"IssuerDNConstraints.\")) {\n-            dnct = cct.getIssuerDNConstraints();\n-            if (dnct == null) {\n-                dnct = new DNConstraintsType();\n-                cct.setIssuerDNConstraints(dnct);\n-            }\n-            k = k.substring(\"IssuerDNConstraints.\".length());\n-        }\n-        if (dnct != null) {\n-            if (\"combinator\".equals(k)) {\n-                dnct.setCombinator(CombinatorType.fromValue(v));\n-            } else if (\"RegularExpression\".equals(k)) {\n-                dnct.getRegularExpression().add(k);\n-            }\n-        }\n-    }\n-\n-    private KeyManagersType getKeyManagers(KeyManagersType keyManagers, String k, String v) {\n- \n-        if (keyManagers == null) {\n-            keyManagers = new KeyManagersType();\n-        }\n-        if (\"factoryAlgorithm\".equals(k)) {\n-            keyManagers.setFactoryAlgorithm(v);\n-        } else if (\"provider\".equals(k)) {\n-            keyManagers.setProvider(v);\n-        } else if (\"keyPassword\".equals(k)) {\n-            keyManagers.setKeyPassword(v);\n-        } else if (k.startsWith(\"keyStore.\")) {\n-            keyManagers.setKeyStore(getKeyStore(keyManagers.getKeyStore(),\n-                                                k.substring(\"keyStore.\".length()),\n-                                                v));\n-        }\n-        return keyManagers;\n-    }\n-\n-    private KeyStoreType getKeyStore(KeyStoreType ks, String k, String v) {\n-        if (ks == null) {\n-            ks = new KeyStoreType();\n-        }\n-        if (\"type\".equals(k)) {\n-            ks.setType(v);\n-        } else if (\"password\".equals(k)) {\n-            ks.setPassword(v);\n-        } else if (\"provider\".equals(k)) {\n-            ks.setProvider(v);\n-        } else if (\"url\".equals(k)) {\n-            ks.setUrl(v);\n-        } else if (\"file\".equals(k)) {\n-            ks.setFile(v);\n-        } else if (\"resource\".equals(k)) {\n-            ks.setResource(v);\n-        }\n-        return ks;\n-    }\n-\n-    private TrustManagersType getTrustManagers(TrustManagersType tmt, String k, String v) {\n-        if (tmt == null) {\n-            tmt = new TrustManagersType();\n-        }\n-        if (\"provider\".equals(k)) {\n-            tmt.setProvider(v);\n-        } else if (\"factoryAlgorithm\".equals(k)) {\n-            tmt.setFactoryAlgorithm(v);\n-        } else if (k.startsWith(\"keyStore.\")) {\n-            tmt.setKeyStore(getKeyStore(tmt.getKeyStore(),\n-                                        k.substring(\"keyStore.\".length()),\n-                                        v));\n-        } else if (k.startsWith(\"certStore\")) {\n-            tmt.setCertStore(getCertStore(tmt.getCertStore(),\n-                                          k.substring(\"certStore.\".length()),\n-                                          v));\n-        }\n-        return tmt;\n-    }\n-\n-    private CertStoreType getCertStore(CertStoreType cs, String k, String v) {\n-        if (cs == null) {\n-            cs = new CertStoreType();\n-        }\n-        if (\"file\".equals(k)) {\n-            cs.setFile(v);\n-        } else if (\"url\".equals(k)) {\n-            cs.setUrl(v);\n-        } else if (\"resource\".equals(k)) {\n-            cs.setResource(v);\n-        }\n-        return cs;\n-    }\n-\n-    private void applyProxyAuthorization(Dictionary<String, String> d, HTTPConduit c) {\n-        Enumeration<String> keys = d.keys();\n-        ProxyAuthorizationPolicy p = c.getProxyAuthorization();\n-        while (keys.hasMoreElements()) {\n-            String k = keys.nextElement();\n-            if (k.startsWith(\"proxyAuthorization.\")) {\n-                if (p == null) {\n-                    p = new ProxyAuthorizationPolicy();\n-                    c.setProxyAuthorization(p);\n-                }\n-                String v = d.get(k);\n-                k = k.substring(\"proxyAuthorization.\".length());\n-\n-                if (\"UserName\".equals(k)) {\n-                    p.setUserName(v);\n-                } else if (\"Password\".equals(k)) {\n-                    p.setPassword(v);\n-                } else if (\"Authorization\".equals(k)) {\n-                    p.setAuthorization(v);\n-                } else if (\"AuthorizationType\".equals(k)) {\n-                    p.setAuthorizationType(v);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void applyAuthorization(Dictionary<String, String> d, HTTPConduit c) {\n-        Enumeration<String> keys = d.keys();\n-        AuthorizationPolicy p = c.getAuthorization();\n-        while (keys.hasMoreElements()) {\n-            String k = keys.nextElement();\n-            if (k.startsWith(\"authorization.\")) {\n-                if (p == null) {\n-                    p = new AuthorizationPolicy();\n-                    c.setAuthorization(p);\n-                }\n-                String v = d.get(k);\n-                k = k.substring(\"authorization.\".length());\n-\n-                if (\"UserName\".equals(k)) {\n-                    p.setUserName(v);\n-                } else if (\"Password\".equals(k)) {\n-                    p.setPassword(v);\n-                } else if (\"Authorization\".equals(k)) {\n-                    p.setAuthorization(v);\n-                } else if (\"AuthorizationType\".equals(k)) {\n-                    p.setAuthorizationType(v);\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    private void applyClientPolicies(Dictionary<String, String> d, HTTPConduit c) {\n-        Enumeration<String> keys = d.keys();\n-        HTTPClientPolicy p = c.getClient();\n-        while (keys.hasMoreElements()) {\n-            String k = keys.nextElement();\n-            if (k.startsWith(\"client.\")) {\n-                if (p == null) {\n-                    p = new HTTPClientPolicy();\n-                    c.setClient(p);\n-                }\n-                String v = d.get(k);\n-                k = k.substring(\"client.\".length());\n-                if (\"ConnectionTimeout\".equals(k)) {\n-                    p.setConnectionTimeout(Long.parseLong(v.trim()));\n-                } else if (\"ReceiveTimeout\".equals(k)) {\n-                    p.setReceiveTimeout(Long.parseLong(v.trim()));\n-                } else if (\"AsyncExecuteTimeout\".equals(k)) {\n-                    p.setAsyncExecuteTimeout(Long.parseLong(v.trim()));\n-                } else if (\"AsyncExecuteTimeoutRejection\".equals(k)) {\n-                    p.setAsyncExecuteTimeoutRejection(Boolean.parseBoolean(v.trim()));\n-                } else if (\"AutoRedirect\".equals(k)) {\n-                    p.setAutoRedirect(Boolean.parseBoolean(v.trim()));\n-                } else if (\"MaxRetransmits\".equals(k)) {\n-                    p.setMaxRetransmits(Integer.parseInt(v.trim()));\n-                } else if (\"AllowChunking\".equals(k)) {\n-                    p.setAllowChunking(Boolean.parseBoolean(v.trim()));\n-                } else if (\"ChunkingThreshold\".equals(k)) {\n-                    p.setChunkingThreshold(Integer.parseInt(v.trim()));\n-                } else if (\"ChunkLength\".equals(k)) {\n-                    p.setChunkLength(Integer.parseInt(v.trim()));\n-                } else if (\"Connection\".equals(k)) {\n-                    p.setConnection(ConnectionType.valueOf(v));\n-                } else if (\"DecoupledEndpoint\".equals(k)) {\n-                    p.setDecoupledEndpoint(v);\n-                } else if (\"ProxyServer\".equals(k)) {\n-                    p.setProxyServer(v);\n-                } else if (\"ProxyServerPort\".equals(k)) {\n-                    p.setProxyServerPort(Integer.parseInt(v.trim()));\n-                } else if (\"ProxyServerType\".equals(k)) {\n-                    p.setProxyServerType(ProxyServerType.fromValue(v));\n-                } else if (\"NonProxyHosts\".equals(k)) {\n-                    p.setNonProxyHosts(v);\n-                }\n-            }\n-        }\n-    }\n-\n-    private void applyAuthSupplier(Dictionary<String, String> d, HTTPConduit c) {\n-        Enumeration<String> keys = d.keys();\n-        while (keys.hasMoreElements()) {\n-            String k = keys.nextElement();\n-            if (k.startsWith(\"authSupplier\")) {\n-                String v = d.get(k);\n-                Object obj;\n-                try {\n-                    obj = Class.forName(v).newInstance();\n-                } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                if (obj instanceof HttpAuthSupplier) {\n-                    c.setAuthSupplier((HttpAuthSupplier)obj);\n-                }\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzODAyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533038028", "bodyText": "Why not just declare them final in the method signature?  Seems silly to make new variables if you can just have it final in the method parameters.", "author": "jhanders34", "createdAt": "2020-12-01T02:47:57Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java", "diffHunk": "@@ -103,9 +106,16 @@ public LibertyApplicationBus createBus(Map<Class<?>, Object> e, Map<String, Obje\n \n         Bus originalBus = getThreadDefaultBus(false);\n \n+        final Map<Class<?>, Object> e1 = e;", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java\nindex 03de66251e..ad680b64a9 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/bus/LibertyApplicationBusFactory.java\n\n@@ -102,18 +102,15 @@ public class LibertyApplicationBusFactory extends CXFBusFactory {\n         return createBus(e, properties, THREAD_CONTEXT_ACCESSOR.getContextClassLoader(Thread.currentThread()));\n     }\n \n-    public LibertyApplicationBus createBus(Map<Class<?>, Object> e, Map<String, Object> properties, ClassLoader classLoader) {\n+    public LibertyApplicationBus createBus(final Map<Class<?>, Object> e,final Map<String, Object> properties,final ClassLoader classLoader) {\n \n         Bus originalBus = getThreadDefaultBus(false);\n \n-        final Map<Class<?>, Object> e1 = e;\n-        final Map<String, Object> properties1 = properties;\n-        final ClassLoader classLoader1 = classLoader;\n         try {\n             LibertyApplicationBus bus = AccessController.doPrivileged(new PrivilegedAction<LibertyApplicationBus>() {\n                 @Override\n                 public LibertyApplicationBus run() {\n-                    return new LibertyApplicationBus(e1, properties1, classLoader1);\n+                    return new LibertyApplicationBus(e, properties, classLoader);\n                 }\n             });\n             //Considering that we have set the default bus in JaxWsService, no need to set default bus\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQwMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533039402", "bodyText": "Should this be done conditionally if there are SSL properties set like is done with JAXRS?", "author": "jhanders34", "createdAt": "2020-12-01T02:52:25Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyServiceImpl.java", "diffHunk": "@@ -158,6 +159,8 @@ protected void configureCustomizeBinding(Client client, QName portName) {\n \n         Set<ConfigProperties> configPropsSet = servicePropertiesMap.get(portName);\n         client.getOutInterceptors().add(new LibertyCustomizeBindingOutInterceptor(wsrInfo, securityConfigService, configPropsSet));\n+\n+        client.getOutInterceptors().add(new LibertyJaxWsClientSSLOutInterceptor(wsrInfo, securityConfigService, configPropsSet, client.getEndpoint().getEndpointInfo()));", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5MDg5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533490897", "bodyText": "I hadn't considered this. I borrowed the SSLOutInterceptor model from the jaxrs-2.1 implementation, but I recycled the original SSL config code that we had in the LibertyCustomizeBindingOutInterceptor. That class has a conditional check that I moved over into the LibertyJaxWsClientSSLOutInterceptor, it's handleMessage() method won't do anything if there's no SSL Config, just like was being done in LibertyCustomizeBindingOutInterceptor. There might be a case for moving the check to registering the interceptor, rather than always enabling it...", "author": "neuwerk", "createdAt": "2020-12-01T15:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYxNDE0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533614146", "bodyText": "I forgot to put a link to the JAXRS way of doing it:  https://github.com/OpenLiberty/open-liberty/blob/integration/dev/com.ibm.ws.jaxrs.2.0.client/src/com/ibm/ws/jaxrs20/client/JAXRSClientImpl.java#L193", "author": "jhanders34", "createdAt": "2020-12-01T18:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzcwNzMwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533707303", "bodyText": "So JAX-RS is using the Config to check whether on not to add the SSL Interceptor, which works on one level but the LibertyJaxWsClientSecurityOutInterceptor (I've renamed it like you suggested) does more than just SSL, like you rightly pointed out, so I do think we should always enable it. I could refactor the interceptor into multiple interceptors for handling SSL, Basic Auth, and WSDL redirects but I'm not convinced that's necessary.", "author": "neuwerk", "createdAt": "2020-12-01T20:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzAzOTQwMg=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyServiceImpl.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyServiceImpl.java\nindex 731c8ccf6c..b92b820382 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyServiceImpl.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyServiceImpl.java\n\n@@ -160,7 +160,7 @@ public class LibertyServiceImpl extends ServiceImpl {\n         Set<ConfigProperties> configPropsSet = servicePropertiesMap.get(portName);\n         client.getOutInterceptors().add(new LibertyCustomizeBindingOutInterceptor(wsrInfo, securityConfigService, configPropsSet));\n \n-        client.getOutInterceptors().add(new LibertyJaxWsClientSSLOutInterceptor(wsrInfo, securityConfigService, configPropsSet, client.getEndpoint().getEndpointInfo()));\n+        client.getOutInterceptors().add(new LibertyJaxWsClientSecurityOutInterceptor(wsrInfo, securityConfigService, configPropsSet, client.getEndpoint().getEndpointInfo()));\n         //need to add an interceptor to clean up HTTPTransportActivator.sorted & props via calling HTTPTransportActivator. deleted(String)\n         //Memory Leak fix for 130985\n         client.getOutInterceptors().add(new LibertyCustomizeBindingOutEndingInterceptor(wsrInfo));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MDM1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533040353", "bodyText": "This added import is not used it would appear.", "author": "jhanders34", "createdAt": "2020-12-01T02:55:28Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java", "diffHunk": "@@ -16,7 +16,10 @@\n import java.util.Map;\n \n import com.ibm.websphere.csi.J2EEName;\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.ws.container.service.app.deploy.ModuleInfo;\n+import com.ibm.ws.jaxws.client.injection.ServiceRefObjectFactory;", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java\nindex 585d9d6800..49dcf22fdd 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/metadata/JaxWsModuleMetaData.java\n\n@@ -19,7 +19,6 @@ import com.ibm.websphere.csi.J2EEName;\n import com.ibm.websphere.ras.Tr;\n import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.ws.container.service.app.deploy.ModuleInfo;\n-import com.ibm.ws.jaxws.client.injection.ServiceRefObjectFactory;\n import com.ibm.ws.jaxws.support.JaxWsInstanceManager;\n import com.ibm.ws.jaxws.utils.JaxWsUtils;\n import com.ibm.ws.runtime.metadata.ModuleMetaData;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MTcyNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533041727", "bodyText": "Is the Endpoint guaranteed to be the same object for a particular endpoint?", "author": "jhanders34", "createdAt": "2020-12-01T02:59:50Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java", "diffHunk": "@@ -77,110 +84,73 @@ public LibertyJaxWsCompatibleWSDLGetInterceptor(String implBeanClazzName, String\n \n     }\n \n-    // @TJJ removed the @Override\n-    public Document getDocument(Message message, String base, Map<String, String> params, String ctxUri, EndpointInfo endpointInfo) {\n-\n-        if (wsdlLoationExisted) {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n-                Tr.warning(tc, \"warn.no.wsdl.generate\", implBeanClazzName);\n-            }\n-            return noWSDLDoc;\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n-                Tr.warning(tc, \"error.no.wsdl.find\", new Object[] { wsdlLocation, implBeanClazzName });\n-            }\n-            return noWSDLLocationDoc;\n-        }\n-    }\n+\n+    private Document getDocument(WSDLGetUtils utils,\n+                                Message message, String base,\n+                                Map<String, String> params, String ctxUri) {\n+       // cannot have two wsdl's being generated for the same endpoint at the same\n+       // time as the addresses may get mixed up\n+       // For WSDL's the WSDLWriter does not share any state between documents.\n+       // For XSD's, the WSDLGetUtils makes a copy of any XSD schema documents before updating\n+       // any addresses and returning them, so for both WSDL and XSD this is the only part that needs\n+       // to be synchronized.\n+       synchronized (message.getExchange().getEndpoint()) {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzQ5NTY2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533495664", "bodyText": "I believe so, the Endpoint is a private field that to my knowledge is only ever set in the Exchange's constructor.", "author": "neuwerk", "createdAt": "2020-12-01T15:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MTcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5NzEyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533597121", "bodyText": "Well that begs the question if the Exchange is different to have a different Endpoint", "author": "jhanders34", "createdAt": "2020-12-01T17:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MTcyNw=="}], "type": "inlineReview", "revised_code": {"commit": "49820a9e33ec2681714c1a6948934639fade187d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java\nindex 4e80a677a2..ccc96b36a1 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java\n\n@@ -84,73 +77,110 @@ public class LibertyJaxWsCompatibleWSDLGetInterceptor extends WSDLGetInterceptor\n \n     }\n \n-\n-    private Document getDocument(WSDLGetUtils utils,\n-                                Message message, String base,\n-                                Map<String, String> params, String ctxUri) {\n-       // cannot have two wsdl's being generated for the same endpoint at the same\n-       // time as the addresses may get mixed up\n-       // For WSDL's the WSDLWriter does not share any state between documents.\n-       // For XSD's, the WSDLGetUtils makes a copy of any XSD schema documents before updating\n-       // any addresses and returning them, so for both WSDL and XSD this is the only part that needs\n-       // to be synchronized.\n-       synchronized (message.getExchange().getEndpoint()) {\n-           return utils.getDocument(message, base, params, ctxUri,\n-                                    message.getExchange().getEndpoint().getEndpointInfo());\n-       }\n-   }\n+    // @TJJ removed the @Override\n+    public Document getDocument(Message message, String base, Map<String, String> params, String ctxUri, EndpointInfo endpointInfo) {\n+\n+        if (wsdlLoationExisted) {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n+                Tr.warning(tc, \"warn.no.wsdl.generate\", implBeanClazzName);\n+            }\n+            return noWSDLDoc;\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n+                Tr.warning(tc, \"error.no.wsdl.find\", new Object[] { wsdlLocation, implBeanClazzName });\n+            }\n+            return noWSDLLocationDoc;\n+        }\n+    }\n \n     /*\n      * Extend from the base class and just customize the response to 404\n      */\n     @Override\n     public void handleMessage(Message message) throws Fault {\n-        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n-        String query = (String)message.get(Message.QUERY_STRING);\n-\n+        String method = (String) message.get(Message.HTTP_REQUEST_METHOD);\n+        String query = (String) message.get(Message.QUERY_STRING);\n         if (!\"GET\".equals(method) || StringUtils.isEmpty(query)) {\n             return;\n         }\n-\n-        String baseUri = (String)message.get(Message.REQUEST_URL);\n-        String ctx = (String)message.get(Message.PATH_INFO);\n-\n-        WSDLGetUtils utils = (WSDLGetUtils)message.getContextualProperty(WSDLGetUtils.class.getName());\n-        if (utils == null) {\n-            utils = new WSDLGetUtils();\n-            message.put(WSDLGetUtils.class, utils);\n-        }\n-        Map<String, String> map = UrlUtils.parseQueryString(query);\n-        if (isRecognizedQuery(map)) {\n-            Document doc = getDocument(utils, message, baseUri, map, ctx);\n-\n-            Endpoint e = message.getExchange().getEndpoint();\n-            Message mout = new MessageImpl();\n-            mout.setExchange(message.getExchange());\n-            mout = e.getBinding().createMessage(mout);\n-            mout.setInterceptorChain(OutgoingChainInterceptor.getOutInterceptorChain(message.getExchange()));\n-            message.getExchange().setOutMessage(mout);\n-\n-            mout.put(DOCUMENT_HOLDER, doc);\n-            mout.put(Message.CONTENT_TYPE, \"text/xml\");\n-            \n-            mout.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_NOT_FOUND);\n-\n-            // just remove the interceptor which should not be used\n-            cleanUpOutInterceptors(mout);\n-\n-            // notice this is being added after the purge above, don't swap the order!\n-            mout.getInterceptorChain().add(wsdlGetOutInterceptor);\n-\n-            message.getExchange().put(TRANSFORM_SKIP, Boolean.TRUE);\n-            // skip the service executor and goto the end of the chain.\n-            message.getInterceptorChain().doInterceptStartingAt(\n-                    message,\n-                    OutgoingChainInterceptor.class.getName());\n+        String baseUri = (String) message.get(Message.REQUEST_URL);\n+        String ctx = (String) message.get(Message.PATH_INFO);\n+\n+        //cannot have two wsdl's being written for the same endpoint at the same\n+        //time as the addresses may get mixed up\n+        synchronized (message.getExchange().getEndpoint()) {\n+            Map<String, String> map = UrlUtils.parseQueryString(query);\n+            if (isRecognizedQuery(map)) {\n+\n+                try {\n+                    Conduit c = message.getExchange().getDestination().getBackChannel(message);\n+                    Message mout = new MessageImpl();\n+                    mout.setExchange(message.getExchange());\n+                    message.getExchange().setOutMessage(mout);\n+                    //Customize the response to 404\n+                    mout.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_NOT_FOUND);\n+                    mout.put(Message.CONTENT_TYPE, \"text/xml\");\n+                    c.prepare(mout);\n+                    OutputStream os = mout.getContent(OutputStream.class);\n+\n+                    Document doc = getDocument(message,\n+                                               baseUri,\n+                                               map,\n+                                               ctx,\n+                                               message.getExchange().getEndpoint().getEndpointInfo());\n+\n+                    String enc = null;\n+                    try {\n+                        enc = doc.getXmlEncoding();\n+                    } catch (Exception ex) {\n+                        //ignore - not dom level 3\n+                    }\n+                    if (enc == null) {\n+                        enc = \"utf-8\";\n+                    }\n+\n+                    XMLStreamWriter writer = null;\n+                    try {\n+                        writer = StaxUtils.createXMLStreamWriter(os, enc);\n+                        StaxUtils.writeNode(doc, writer, true);\n+                        message.getInterceptorChain().abort();\n+                        writer.flush();\n+                        os.flush();\n+                    } catch (IOException ex) {\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isInfoEnabled()) {\n+                            Tr.info(tc, \"error.write.wsdl.stream\", ex);\n+                        }\n+                        //LOG.log(Level.FINE, \"Failure writing full wsdl to the stream\", ex);\n+                        //we can ignore this.   Likely, whatever has requested the WSDL\n+                        //has closed the connection before reading the entire wsdl.\n+                        //WSDL4J has a tendency to not read the closing tags and such\n+                        //and thus can sometimes hit this.   In anycase, it's\n+                        //pretty much ignorable and nothing we can do about it (cannot\n+                        //send a fault or anything anyway\n+                    } finally {\n+                        if (writer != null) {\n+                            try {\n+                                writer.close();\n+                            } catch (Exception e) {\n+                            }\n+                        }\n+                        try {\n+                            os.close();\n+                        } catch (Exception e) {\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    throw new Fault(e);\n+                } catch (XMLStreamException e) {\n+                    throw new Fault(e);\n+                } finally {\n+                    message.getExchange().setOutMessage(null);\n+                }\n+            }\n         }\n     }\n \n-    // Replaced the isRecognizedQuery() from CXF 2.6.2 with this method which\n+    // @TJJ replaced the isRecognizedQuery() from CXF 2.6.2 with this method which\n     // is a direct copy of the WSDLGetInterceptor.isRecognizedQuery(map) in CXF 3.3\n     // I was required to copy it as it changed from a public to private method from CXF 2.6 -> CXF 3.3\n     private boolean isRecognizedQuery(Map<String, String> map) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MjQ2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533042465", "bodyText": "There is a lot of change here.  The copyright should be updated to include 2020.  You should do the same for other classes you changed.", "author": "jhanders34", "createdAt": "2020-12-01T03:02:27Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java", "diffHunk": "@@ -77,110 +84,73 @@ public LibertyJaxWsCompatibleWSDLGetInterceptor(String implBeanClazzName, String\n \n     }\n \n-    // @TJJ removed the @Override\n-    public Document getDocument(Message message, String base, Map<String, String> params, String ctxUri, EndpointInfo endpointInfo) {\n-\n-        if (wsdlLoationExisted) {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n-                Tr.warning(tc, \"warn.no.wsdl.generate\", implBeanClazzName);\n-            }\n-            return noWSDLDoc;\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n-                Tr.warning(tc, \"error.no.wsdl.find\", new Object[] { wsdlLocation, implBeanClazzName });\n-            }\n-            return noWSDLLocationDoc;\n-        }\n-    }\n+\n+    private Document getDocument(WSDLGetUtils utils,", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "49820a9e33ec2681714c1a6948934639fade187d", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java\nindex 4e80a677a2..ccc96b36a1 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/support/LibertyJaxWsCompatibleWSDLGetInterceptor.java\n\n@@ -84,73 +77,110 @@ public class LibertyJaxWsCompatibleWSDLGetInterceptor extends WSDLGetInterceptor\n \n     }\n \n-\n-    private Document getDocument(WSDLGetUtils utils,\n-                                Message message, String base,\n-                                Map<String, String> params, String ctxUri) {\n-       // cannot have two wsdl's being generated for the same endpoint at the same\n-       // time as the addresses may get mixed up\n-       // For WSDL's the WSDLWriter does not share any state between documents.\n-       // For XSD's, the WSDLGetUtils makes a copy of any XSD schema documents before updating\n-       // any addresses and returning them, so for both WSDL and XSD this is the only part that needs\n-       // to be synchronized.\n-       synchronized (message.getExchange().getEndpoint()) {\n-           return utils.getDocument(message, base, params, ctxUri,\n-                                    message.getExchange().getEndpoint().getEndpointInfo());\n-       }\n-   }\n+    // @TJJ removed the @Override\n+    public Document getDocument(Message message, String base, Map<String, String> params, String ctxUri, EndpointInfo endpointInfo) {\n+\n+        if (wsdlLoationExisted) {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n+                Tr.warning(tc, \"warn.no.wsdl.generate\", implBeanClazzName);\n+            }\n+            return noWSDLDoc;\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {\n+                Tr.warning(tc, \"error.no.wsdl.find\", new Object[] { wsdlLocation, implBeanClazzName });\n+            }\n+            return noWSDLLocationDoc;\n+        }\n+    }\n \n     /*\n      * Extend from the base class and just customize the response to 404\n      */\n     @Override\n     public void handleMessage(Message message) throws Fault {\n-        String method = (String)message.get(Message.HTTP_REQUEST_METHOD);\n-        String query = (String)message.get(Message.QUERY_STRING);\n-\n+        String method = (String) message.get(Message.HTTP_REQUEST_METHOD);\n+        String query = (String) message.get(Message.QUERY_STRING);\n         if (!\"GET\".equals(method) || StringUtils.isEmpty(query)) {\n             return;\n         }\n-\n-        String baseUri = (String)message.get(Message.REQUEST_URL);\n-        String ctx = (String)message.get(Message.PATH_INFO);\n-\n-        WSDLGetUtils utils = (WSDLGetUtils)message.getContextualProperty(WSDLGetUtils.class.getName());\n-        if (utils == null) {\n-            utils = new WSDLGetUtils();\n-            message.put(WSDLGetUtils.class, utils);\n-        }\n-        Map<String, String> map = UrlUtils.parseQueryString(query);\n-        if (isRecognizedQuery(map)) {\n-            Document doc = getDocument(utils, message, baseUri, map, ctx);\n-\n-            Endpoint e = message.getExchange().getEndpoint();\n-            Message mout = new MessageImpl();\n-            mout.setExchange(message.getExchange());\n-            mout = e.getBinding().createMessage(mout);\n-            mout.setInterceptorChain(OutgoingChainInterceptor.getOutInterceptorChain(message.getExchange()));\n-            message.getExchange().setOutMessage(mout);\n-\n-            mout.put(DOCUMENT_HOLDER, doc);\n-            mout.put(Message.CONTENT_TYPE, \"text/xml\");\n-            \n-            mout.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_NOT_FOUND);\n-\n-            // just remove the interceptor which should not be used\n-            cleanUpOutInterceptors(mout);\n-\n-            // notice this is being added after the purge above, don't swap the order!\n-            mout.getInterceptorChain().add(wsdlGetOutInterceptor);\n-\n-            message.getExchange().put(TRANSFORM_SKIP, Boolean.TRUE);\n-            // skip the service executor and goto the end of the chain.\n-            message.getInterceptorChain().doInterceptStartingAt(\n-                    message,\n-                    OutgoingChainInterceptor.class.getName());\n+        String baseUri = (String) message.get(Message.REQUEST_URL);\n+        String ctx = (String) message.get(Message.PATH_INFO);\n+\n+        //cannot have two wsdl's being written for the same endpoint at the same\n+        //time as the addresses may get mixed up\n+        synchronized (message.getExchange().getEndpoint()) {\n+            Map<String, String> map = UrlUtils.parseQueryString(query);\n+            if (isRecognizedQuery(map)) {\n+\n+                try {\n+                    Conduit c = message.getExchange().getDestination().getBackChannel(message);\n+                    Message mout = new MessageImpl();\n+                    mout.setExchange(message.getExchange());\n+                    message.getExchange().setOutMessage(mout);\n+                    //Customize the response to 404\n+                    mout.put(Message.RESPONSE_CODE, HttpURLConnection.HTTP_NOT_FOUND);\n+                    mout.put(Message.CONTENT_TYPE, \"text/xml\");\n+                    c.prepare(mout);\n+                    OutputStream os = mout.getContent(OutputStream.class);\n+\n+                    Document doc = getDocument(message,\n+                                               baseUri,\n+                                               map,\n+                                               ctx,\n+                                               message.getExchange().getEndpoint().getEndpointInfo());\n+\n+                    String enc = null;\n+                    try {\n+                        enc = doc.getXmlEncoding();\n+                    } catch (Exception ex) {\n+                        //ignore - not dom level 3\n+                    }\n+                    if (enc == null) {\n+                        enc = \"utf-8\";\n+                    }\n+\n+                    XMLStreamWriter writer = null;\n+                    try {\n+                        writer = StaxUtils.createXMLStreamWriter(os, enc);\n+                        StaxUtils.writeNode(doc, writer, true);\n+                        message.getInterceptorChain().abort();\n+                        writer.flush();\n+                        os.flush();\n+                    } catch (IOException ex) {\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isInfoEnabled()) {\n+                            Tr.info(tc, \"error.write.wsdl.stream\", ex);\n+                        }\n+                        //LOG.log(Level.FINE, \"Failure writing full wsdl to the stream\", ex);\n+                        //we can ignore this.   Likely, whatever has requested the WSDL\n+                        //has closed the connection before reading the entire wsdl.\n+                        //WSDL4J has a tendency to not read the closing tags and such\n+                        //and thus can sometimes hit this.   In anycase, it's\n+                        //pretty much ignorable and nothing we can do about it (cannot\n+                        //send a fault or anything anyway\n+                    } finally {\n+                        if (writer != null) {\n+                            try {\n+                                writer.close();\n+                            } catch (Exception e) {\n+                            }\n+                        }\n+                        try {\n+                            os.close();\n+                        } catch (Exception e) {\n+                        }\n+                    }\n+                } catch (IOException e) {\n+                    throw new Fault(e);\n+                } catch (XMLStreamException e) {\n+                    throw new Fault(e);\n+                } finally {\n+                    message.getExchange().setOutMessage(null);\n+                }\n+            }\n         }\n     }\n \n-    // Replaced the isRecognizedQuery() from CXF 2.6.2 with this method which\n+    // @TJJ replaced the isRecognizedQuery() from CXF 2.6.2 with this method which\n     // is a direct copy of the WSDLGetInterceptor.isRecognizedQuery(map) in CXF 3.3\n     // I was required to copy it as it changed from a public to private method from CXF 2.6 -> CXF 3.3\n     private boolean isRecognizedQuery(Map<String, String> map) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzA0MzY5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533043698", "bodyText": "Should this be in a finally block?", "author": "jhanders34", "createdAt": "2020-12-01T03:06:43Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java", "diffHunk": "@@ -10,15 +10,47 @@\n  *******************************************************************************/\n package com.ibm.ws.jaxws.threading;\n \n+import java.security.AccessController;\n import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n \n import org.apache.cxf.workqueue.AutomaticWorkQueue;\n \n+import com.ibm.ws.util.ThreadContextAccessor;\n import com.ibm.wsspi.threading.WSExecutorService;\n \n public class LibertyJaxWsAutomaticWorkQueueImpl implements AutomaticWorkQueue {\n \n+    private static final ThreadContextAccessor THREAD_CONTEXT_ACCESSOR =\n+                    AccessController.doPrivileged(ThreadContextAccessor.getPrivilegedAction());\n+\n+    /**\n+     * Borrowed from jaxrs-2.x to udpate our LibertyThreadPoolAdapter to match changes need for CXF Updates\n+     * LibertyJaxWsWorker helps to switch the Thread Context Classloader of InvocationCallback & CompletionCallback to application context classloader which can access the jaxws-2.3\n+     * spec API such as Client API\n+     */\n+    public class LibertyJaxWsWorker implements Runnable {\n+\n+        private final Runnable work;\n+        private final ClassLoader appContextClassLoader;\n+\n+        public LibertyJaxWsWorker(Runnable work) {\n+            this.work = work;\n+            //get the application context classloader from main thread\n+            this.appContextClassLoader = THREAD_CONTEXT_ACCESSOR.getContextClassLoader(Thread.currentThread());\n+        }\n+\n+        @Override\n+        public void run() {\n+            //switch thread context classloader of async thread to application context classloader\n+            ClassLoader oClsLoader = THREAD_CONTEXT_ACCESSOR.getContextClassLoader(Thread.currentThread());\n+            THREAD_CONTEXT_ACCESSOR.setContextClassLoader(Thread.currentThread(), appContextClassLoader);\n+            work.run();\n+            //after callback done, switch back the original classloader\n+            THREAD_CONTEXT_ACCESSOR.setContextClassLoader(Thread.currentThread(), oClsLoader);", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java\nindex d6a8fa3e84..7c4b6239fc 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsAutomaticWorkQueueImpl.java\n\n@@ -42,12 +42,17 @@ public class LibertyJaxWsAutomaticWorkQueueImpl implements AutomaticWorkQueue {\n \n         @Override\n         public void run() {\n+\n             //switch thread context classloader of async thread to application context classloader\n             ClassLoader oClsLoader = THREAD_CONTEXT_ACCESSOR.getContextClassLoader(Thread.currentThread());\n-            THREAD_CONTEXT_ACCESSOR.setContextClassLoader(Thread.currentThread(), appContextClassLoader);\n-            work.run();\n-            //after callback done, switch back the original classloader\n-            THREAD_CONTEXT_ACCESSOR.setContextClassLoader(Thread.currentThread(), oClsLoader);\n+            \n+            try {\n+                THREAD_CONTEXT_ACCESSOR.setContextClassLoader(Thread.currentThread(), appContextClassLoader);\n+                work.run();\n+            } finally {\n+                //after callback done, switch back the original classloader\n+                THREAD_CONTEXT_ACCESSOR.setContextClassLoader(Thread.currentThread(), oClsLoader);\n+            }\n         }\n     }\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI5ODk3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533298974", "bodyText": "setThreadContext is not necessary to be here.  initialValue is called on get if nothing is in the ThreadLocal and get will put it in automatically into the ThreadLocal without your needing to call set in initialValue.", "author": "jhanders34", "createdAt": "2020-12-01T10:34:20Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsWorkQueueThreadContextHelper.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.jaxws.threading;\n+\n+/**\n+ *\n+ */\n+public class LibertyJaxWsWorkQueueThreadContextHelper {\n+\n+    private static ThreadLocal<LibertyJaxWsWorkQueueThreadContext> threadLocal = new ThreadLocal<LibertyJaxWsWorkQueueThreadContext>() {\n+\n+        @Override\n+        protected LibertyJaxWsWorkQueueThreadContext initialValue() {\n+            LibertyJaxWsWorkQueueThreadContext wqtc = new LibertyJaxWsWorkQueueThreadContext();\n+            LibertyJaxWsWorkQueueThreadContextHelper.setThreadContext(wqtc);", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsWorkQueueThreadContextHelper.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsWorkQueueThreadContextHelper.java\nindex 18c73f4a4d..c9d75333cd 100644\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsWorkQueueThreadContextHelper.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/threading/LibertyJaxWsWorkQueueThreadContextHelper.java\n\n@@ -20,7 +20,6 @@ public class LibertyJaxWsWorkQueueThreadContextHelper {\n         @Override\n         protected LibertyJaxWsWorkQueueThreadContext initialValue() {\n             LibertyJaxWsWorkQueueThreadContext wqtc = new LibertyJaxWsWorkQueueThreadContext();\n-            LibertyJaxWsWorkQueueThreadContextHelper.setThreadContext(wqtc);\n             return wqtc;\n         }\n     };\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxMjIyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533312225", "bodyText": "Many of these variables could be declared final earlier instead of having to make extra variables just to be final.", "author": "jhanders34", "createdAt": "2020-12-01T10:45:25Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java", "diffHunk": "@@ -91,7 +91,7 @@ public ServiceDelegate createServiceDelegate(URL url, QName qname,\n         AtomicServiceReference<JaxWsSecurityConfigurationService> secConfigSR = securityConfigSR.get();\n         JaxWsSecurityConfigurationService securityConfigService = secConfigSR == null ? null : secConfigSR.getService();\n \n-        // @TJJ create final vars in order to call a doPriv when creating the LibertyServiceImpl as required by java 2 security\n+        // Create final vars in order to call a doPriv when creating the LibertyServiceImpl as required by java 2 security\n         final JaxWsSecurityConfigurationService scs = securityConfigService;\n         final WebServiceRefInfo wi = wsrInfo;\n         final Bus b = bus;", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0Njg4Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535346886", "bodyText": "Marking resolved, but added another comment earlier explaining how this was done for bus doesn't work.", "author": "jhanders34", "createdAt": "2020-12-03T15:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxMjIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java\nindex b46282abd0..181ad40ecd 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java\n\n@@ -73,31 +73,25 @@ public class LibertyProviderImpl extends ProviderImpl {\n             throw new IllegalStateException(e);\n         }\n         \n-        Bus bus = null;\n+\n+        final Bus bus;\n         JaxWsClientMetaData clientMetaData = JaxWsMetaDataManager.getJaxWsClientMetaData();\n-        if (clientMetaData != null) {\n+        boolean hasClientBus = (clientMetaData.getClientBus() != null);\n+        if (clientMetaData != null && hasClientBus) { \n             bus = clientMetaData.getClientBus();\n-        }\n-        if (bus == null) {\n+        } else {\n             bus = BusFactory.getThreadDefaultBus();\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                 Tr.debug(tc, \"No client  bus is found, the thread context default bus \" + bus.getId() + \" is used\");\n             }\n         }\n \n-        WebServiceRefInfo wsrInfo = wsRefInfo.get();\n+        final WebServiceRefInfo wsrInfo = wsRefInfo.get();\n         List<WebServiceFeature> serviceFeatures = wsFeatures.get();\n \n         AtomicServiceReference<JaxWsSecurityConfigurationService> secConfigSR = securityConfigSR.get();\n-        JaxWsSecurityConfigurationService securityConfigService = secConfigSR == null ? null : secConfigSR.getService();\n-\n-        // Create final vars in order to call a doPriv when creating the LibertyServiceImpl as required by java 2 security\n-        final JaxWsSecurityConfigurationService scs = securityConfigService;\n-        final WebServiceRefInfo wi = wsrInfo;\n-        final Bus b = bus;\n-        final URL u = url;\n-        final QName qn = qname;\n-        final Class c = cls;\n+        final JaxWsSecurityConfigurationService securityConfigService = secConfigSR == null ? null : secConfigSR.getService();\n+\n         final List<WebServiceFeature> sf = serviceFeatures;\n \n         if (serviceFeatures != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMxNzcxNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533317717", "bodyText": "This Interceptor seems to handle both SSL and basic auth so the having the name SSL as part of the class name is misleading.  So either it should be specific to SSL only or the name changed to Security instead of SSL?  The class comment here only talks about SSL and not basic auth so that is also misleading.", "author": "jhanders34", "createdAt": "2020-12-01T10:53:59Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSSLOutInterceptor.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.jaxws23.client.security;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.xml.namespace.QName;\n+\n+import org.apache.cxf.common.util.PropertyUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.configuration.jsse.TLSClientParameters;\n+import org.apache.cxf.interceptor.Fault;\n+import org.apache.cxf.message.Message;\n+import org.apache.cxf.phase.AbstractPhaseInterceptor;\n+import org.apache.cxf.transport.Conduit;\n+import org.apache.cxf.transport.http.HTTPConduit;\n+import org.apache.cxf.transports.http.configuration.HTTPClientPolicy;\n+import org.apache.cxf.ws.addressing.EndpointReferenceType;\n+\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.ws.jaxws.metadata.ConfigProperties;\n+import com.ibm.ws.jaxws.metadata.PortComponentRefInfo;\n+import com.ibm.ws.jaxws.metadata.WebServiceRefInfo;\n+import com.ibm.ws.jaxws.security.JaxWsSecurityConfigurationService;\n+import com.ibm.wsspi.kernel.service.utils.AtomicServiceReference;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.interceptor.Fault;\n+import org.apache.cxf.message.Message;\n+import org.apache.cxf.phase.AbstractPhaseInterceptor;\n+import org.apache.cxf.phase.Phase;\n+import org.apache.cxf.service.model.EndpointInfo;\n+import org.apache.cxf.transport.Conduit;\n+import org.apache.cxf.transport.http.HTTPConduit;\n+import org.apache.cxf.transport.http.HTTPConduitConfigurer;\n+import org.osgi.service.cm.ConfigurationException;\n+import org.osgi.service.cm.ManagedServiceFactory;\n+\n+import com.ibm.websphere.ras.ProtectedString;\n+import com.ibm.websphere.ras.Tr;\n+import com.ibm.websphere.ras.TraceComponent;\n+import com.ibm.websphere.ras.annotation.Sensitive;\n+import com.ibm.ws.jaxws.JaxWsConstants;\n+import com.ibm.ws.jaxws.metadata.ConfigProperties;\n+import com.ibm.ws.jaxws.metadata.PortComponentRefInfo;\n+import com.ibm.ws.jaxws.metadata.WebServiceRefInfo;\n+import com.ibm.ws.jaxws.security.JaxWsSecurityConfigurationService;\n+\n+/**\n+ * Used to set the SSL config on the Client side conduit. This removes the need to modify the\n+ * HttpConduit directly through an extended LibertyHttpConduit \n+ */\n+public class LibertyJaxWsClientSSLOutInterceptor extends AbstractPhaseInterceptor<Message> {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSSLOutInterceptor.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSecurityOutInterceptor.java\nsimilarity index 97%\nrename from dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSSLOutInterceptor.java\nrename to dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSecurityOutInterceptor.java\nindex 89f3e921c8..0905ebbf6c 100644\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSSLOutInterceptor.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws23/client/security/LibertyJaxWsClientSecurityOutInterceptor.java\n\n@@ -67,9 +67,9 @@ import com.ibm.ws.jaxws.security.JaxWsSecurityConfigurationService;\n  * Used to set the SSL config on the Client side conduit. This removes the need to modify the\n  * HttpConduit directly through an extended LibertyHttpConduit \n  */\n-public class LibertyJaxWsClientSSLOutInterceptor extends AbstractPhaseInterceptor<Message> {\n+public class LibertyJaxWsClientSecurityOutInterceptor extends AbstractPhaseInterceptor<Message> {\n \n-    private static final TraceComponent tc = Tr.register(LibertyJaxWsClientSSLOutInterceptor.class);\n+    private static final TraceComponent tc = Tr.register(LibertyJaxWsClientSecurityOutInterceptor.class);\n \n     private static final QName CXF_TRANSPORT_URI_RESOLVER_QNAME = new QName(\"http://cxf.apache.org\", \"TransportURIResolver\");\n     private static final AtomicReference<AtomicServiceReference<JaxWsSecurityConfigurationService>> securityConfigSR = new AtomicReference<AtomicServiceReference<JaxWsSecurityConfigurationService>>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMDg4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533330885", "bodyText": "If methodDispatcher is null then we should skip this entire logic.  No reason to loop through a for loop just to do nothing in it if methodDispatcher is null.", "author": "jhanders34", "createdAt": "2020-12-01T11:16:33Z", "path": "dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBJaxWsWebEndpoint.java", "diffHunk": "@@ -116,20 +115,31 @@ public void init(ServletConfig servletConfig) throws ServletException {\n             inInterceptors.add(ejbPreInvokeInterceptor);\n             outInterceptors.add(new EJBPostInvokeInterceptor());\n         } else {\n-            Service service = serviceFactory.getService();\n+\n+            if (service == null) {\n+                service = serviceFactory.getService();\n+            }\n+\n             org.apache.cxf.service.model.EndpointInfo cxfEndpointInfo = service.getEndpointInfo(endpointInfo.getWsdlPort());\n-            //MethodDispatcher methodDispatcher = (MethodDispatcher) service.get(MethodDispatcher.class.getName());\n-            JAXWSMethodDispatcher methodDispatcher = (JAXWSMethodDispatcher) service.get(JAXWSMethodDispatcher.class.getName());\n+\n+            JAXWSMethodDispatcher methodDispatcher = (JAXWSMethodDispatcher) service.get(MethodDispatcher.class.getName());\n             List<Method> methods = new ArrayList<Method>(cxfEndpointInfo.getBinding().getOperations().size());\n-            for (BindingOperationInfo bindingOperationInfo : cxfEndpointInfo.getBinding().getOperations()) {\n-                Method method = methodDispatcher.getMethod(bindingOperationInfo);\n-                if (method != null) {\n-                    methods.add(method);\n-                } else {\n-                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                        Tr.debug(tc, \"Unable to get method for binding operation info \" + bindingOperationInfo.getName());\n+            if (cxfEndpointInfo.getBinding().getOperations() != null) {\n+                for (BindingOperationInfo bindingOperationInfo : cxfEndpointInfo.getBinding().getOperations()) {\n+                    if (methodDispatcher != null && bindingOperationInfo != null) {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBJaxWsWebEndpoint.java b/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBJaxWsWebEndpoint.java\ndeleted file mode 100644\nindex 1b8b646b0a..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBJaxWsWebEndpoint.java\n+++ /dev/null\n\n@@ -1,187 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.jaxws.ejb;\n-\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletException;\n-import javax.xml.ws.Binding;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.binding.soap.SoapMessage;\n-import org.apache.cxf.interceptor.Interceptor;\n-import org.apache.cxf.jaxws.JAXWSMethodDispatcher;\n-import org.apache.cxf.jaxws.handler.logical.LogicalHandlerInInterceptor;\n-import org.apache.cxf.jaxws.handler.soap.SOAPHandlerInterceptor;\n-import org.apache.cxf.jaxws.support.JaxWsEndpointImpl;\n-import org.apache.cxf.message.Message;\n-import org.apache.cxf.service.Service;\n-import org.apache.cxf.service.invoker.Invoker;\n-import org.apache.cxf.service.invoker.MethodDispatcher;\n-import org.apache.cxf.service.model.BindingOperationInfo;\n-import org.apache.cxf.transport.http.AbstractHTTPDestination;\n-\n-import com.ibm.websphere.csi.J2EEName;\n-import com.ibm.websphere.ras.Tr;\n-import com.ibm.websphere.ras.TraceComponent;\n-import com.ibm.ws.ejbcontainer.osgi.EJBContainer;\n-import com.ibm.ws.jaxws.endpoint.AbstractJaxWsWebEndpoint;\n-import com.ibm.ws.jaxws.endpoint.JaxWsPublisherContext;\n-import com.ibm.ws.jaxws.metadata.EndpointInfo;\n-import com.ibm.ws.jaxws.support.LibertyJaxWsImplementorInfo;\n-import com.ibm.ws.jaxws.support.LibertyJaxWsServerFactoryBean;\n-import com.ibm.ws.jaxws.support.LibertyJaxWsServiceFactoryBean;\n-\n-/**\n- * JaxWsWebEndpoint for an EJB based Web service endpoint\n- */\n-@SuppressWarnings(\"deprecation\")\n-public class EJBJaxWsWebEndpoint extends AbstractJaxWsWebEndpoint {\n-\n-    private static final TraceComponent tc = Tr.register(EJBJaxWsWebEndpoint.class);\n-\n-    private final EJBContainer ejbContainer;\n-\n-    private final JaxWsPublisherContext publisherContext;\n-\n-    private LibertyJaxWsServerFactoryBean jaxWsServerFactory;\n-\n-    public EJBJaxWsWebEndpoint(EndpointInfo endpointInfo, JaxWsPublisherContext context, EJBContainer ejbContainer) {\n-        super(endpointInfo, context.getModuleMetaData());\n-        this.ejbContainer = ejbContainer;\n-        this.publisherContext = context;\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void init(ServletConfig servletConfig) throws ServletException {\n-        super.init(servletConfig);\n-\n-        Class<?> implBeanClass;\n-        LibertyJaxWsImplementorInfo implInfo = null;\n-        try {\n-            implBeanClass = jaxWsModuleMetaData.getModuleInfo().getClassLoader().loadClass(endpointInfo.getImplBeanClassName());\n-            implInfo = new LibertyJaxWsImplementorInfo(implBeanClass, endpointInfo, publisherContext);\n-        } catch (ClassNotFoundException e) {\n-            throw new ServletException(e);\n-        }\n-\n-        Bus serverBus = jaxWsModuleMetaData.getServerMetaData().getServerBus();\n-\n-        LibertyJaxWsServiceFactoryBean serviceFactory = new LibertyJaxWsServiceFactoryBean(implInfo, publisherContext);\n-        jaxWsServerFactory = new LibertyJaxWsServerFactoryBean(serviceFactory);\n-\n-        Invoker ejbMethodInvoker = new EJBMethodInvoker();\n-\n-        serviceFactory.setBus(serverBus);\n-        serviceFactory.setInvoker(ejbMethodInvoker);\n-        serviceFactory.setFeatures(jaxWsServerFactory.getFeatures());\n-        Service service = serviceFactory.create();\n-\n-        jaxWsServerFactory.setBus(serverBus);\n-        jaxWsServerFactory.setAddress(endpointInfo.getAddress(0));\n-        jaxWsServerFactory.setStart(false);\n-        jaxWsServerFactory.setServiceBean(implBeanClass);\n-        jaxWsServerFactory.setInvoker(ejbMethodInvoker);\n-\n-        server = jaxWsServerFactory.create();\n-\n-        //Config the server side properties\n-        configureEndpointInfoProperties(endpointInfo, server.getEndpoint().getEndpointInfo());\n-\n-        List<Interceptor<? extends Message>> inInterceptors = server.getEndpoint().getInInterceptors();\n-        List<Interceptor<? extends Message>> outInterceptors = server.getEndpoint().getOutInterceptors();\n-\n-        //Initialize EJBMethodInvoker\n-        J2EEName j2EEName = jaxWsModuleMetaData.getServerMetaData().getEndpointJ2EEName(endpointInfo.getPortLink());\n-        if (implInfo.isWebServiceProvider()) {\n-            //add ejb pre-invoke interceptor\n-            EJBPreInvokeInterceptor ejbPreInvokeInterceptor = new EJBPreInvokeInterceptor(j2EEName, implBeanClass, ejbContainer, null);\n-            ejbPreInvokeInterceptor.setEjbJaxWsWebEndpoint(this);\n-\n-            inInterceptors.add(ejbPreInvokeInterceptor);\n-            outInterceptors.add(new EJBPostInvokeInterceptor());\n-        } else {\n-\n-            if (service == null) {\n-                service = serviceFactory.getService();\n-            }\n-\n-            org.apache.cxf.service.model.EndpointInfo cxfEndpointInfo = service.getEndpointInfo(endpointInfo.getWsdlPort());\n-\n-            JAXWSMethodDispatcher methodDispatcher = (JAXWSMethodDispatcher) service.get(MethodDispatcher.class.getName());\n-            List<Method> methods = new ArrayList<Method>(cxfEndpointInfo.getBinding().getOperations().size());\n-            if (cxfEndpointInfo.getBinding().getOperations() != null) {\n-                for (BindingOperationInfo bindingOperationInfo : cxfEndpointInfo.getBinding().getOperations()) {\n-                    if (methodDispatcher != null && bindingOperationInfo != null) {\n-                        Method method = methodDispatcher.getMethod(bindingOperationInfo);\n-\n-                        if (method != null) {\n-                            methods.add(method);\n-                            methodDispatcher.bind(bindingOperationInfo.getOperationInfo(), method);\n-                        } else {\n-                            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                                Tr.debug(tc, \"Unable to get method for binding operation info \" + bindingOperationInfo.getName());\n-                            }\n-                        }\n-                    }\n-                }\n-\n-            }\n-            //add ejb pre-invoke interceptor\n-            EJBPreInvokeInterceptor ejbPreInvokeInterceptor = new EJBPreInvokeInterceptor(j2EEName, implBeanClass, ejbContainer, methods);\n-            ejbPreInvokeInterceptor.setEjbJaxWsWebEndpoint(this);\n-\n-            inInterceptors.add(ejbPreInvokeInterceptor);\n-\n-            outInterceptors.add(new EJBPostInvokeInterceptor());\n-        }\n-\n-        // Delay the handler creation in EJBPreInvokeInterceptor, so not like POJOJaxWsWebEndpoint create handler here.\n-\n-        // Customize WSDL Get Interceptor.\n-        customizeWSDLGetInterceptor(implBeanClass);\n-        customizeLoggingInOutIntercetptor(endpointInfo);\n-\n-        server.start();\n-\n-        this.destination = (AbstractHTTPDestination) server.getDestination();\n-\n-    }\n-\n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public void destroy() {\n-        super.destroy();\n-    }\n-\n-    public void initializeHandlers(SoapMessage message) {\n-        // Get binding instanc\n-        Binding binding = ((JaxWsEndpointImpl) server.getEndpoint()).getJaxwsBinding();\n-        // Bind handlers to server\n-        binding.setHandlerChain(jaxWsServerFactory.createHandlers(endpointInfo, jaxWsModuleMetaData.getJaxWsInstanceManager()));\n-\n-        // this method is called from EJBPreInvokeInterceptor, and only called when the first time invoke the ejb based web service.\n-        // because we just do the setHandlerChain, so the handler interceptor is not added to the interceptors chain of the first invoke.\n-        for (Interceptor<? extends Message> iterceptor : server.getEndpoint().getInInterceptors()) {\n-            if (iterceptor instanceof SOAPHandlerInterceptor || iterceptor instanceof LogicalHandlerInInterceptor) {\n-                message.getInterceptorChain().add(iterceptor);\n-            }\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMjk0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533332946", "bodyText": "Why would ejbContainer be null?  If it can be null here, couldn't it be null in the if as well?\nThis same logic does not exist in the 2.2 version of the code.  If it can be null, the logic should be there as well.", "author": "jhanders34", "createdAt": "2020-12-01T11:20:18Z", "path": "dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java", "diffHunk": "@@ -91,8 +90,10 @@ public void handleMessage(SoapMessage message) throws Fault {\n                 endpointManager = ejbContainer.createWebServiceEndpointManager(j2EEName, Provider.class);\n                 targetMethod = getProviderMethod(implClass);\n             } else {\n-                endpointManager = ejbContainer.createWebServiceEndpointManager(j2EEName, methods);\n-                targetMethod = getTargetMethod(implClass, message);\n+                if (ejbContainer != null) {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxNDMyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533514321", "bodyText": "This was some debugging logic I added that I didn't remove. Thanks for catching it.", "author": "neuwerk", "createdAt": "2020-12-01T15:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzMjk0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java b/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java\ndeleted file mode 100644\nindex 5c830427a2..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java\n+++ /dev/null\n\n@@ -1,253 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.jaxws.ejb;\n-\n-import java.lang.reflect.Method;\n-import java.rmi.RemoteException;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Collection;\n-import java.util.List;\n-\n-import javax.xml.namespace.QName;\n-import javax.xml.soap.SOAPBody;\n-import javax.xml.soap.SOAPException;\n-import javax.xml.soap.SOAPMessage;\n-import javax.xml.ws.Provider;\n-import javax.xml.ws.WebServiceProvider;\n-import javax.xml.ws.handler.MessageContext.Scope;\n-\n-import org.apache.cxf.binding.soap.SoapMessage;\n-import org.apache.cxf.binding.soap.saaj.SAAJUtils;\n-import org.apache.cxf.interceptor.Fault;\n-import org.apache.cxf.jaxws.context.WrappedMessageContext;\n-import org.apache.cxf.jaxws.handler.soap.SOAPMessageContextImpl;\n-import org.apache.cxf.message.Exchange;\n-import org.apache.cxf.message.Message;\n-import org.apache.cxf.phase.AbstractPhaseInterceptor;\n-import org.apache.cxf.phase.Phase;\n-import org.apache.cxf.service.Service;\n-import org.apache.cxf.service.invoker.MethodDispatcher;\n-import org.apache.cxf.service.model.BindingOperationInfo;\n-import org.apache.cxf.service.model.OperationInfo;\n-import org.apache.cxf.service.model.ServiceModelUtil;\n-\n-import com.ibm.ejs.container.EJBConfigurationException;\n-import com.ibm.websphere.csi.J2EEName;\n-import com.ibm.websphere.ras.Tr;\n-import com.ibm.websphere.ras.TraceComponent;\n-import com.ibm.ws.ejbcontainer.osgi.EJBContainer;\n-import com.ibm.ws.jaxws.ejb.internal.JaxWsEJBConstants;\n-import com.ibm.wsspi.ejbcontainer.WSEJBEndpointManager;\n-\n-/**\n- *\n- */\n-public class EJBPreInvokeInterceptor extends AbstractPhaseInterceptor<SoapMessage> {\n-\n-    private final Class<?> implClass;\n-\n-    private final J2EEName j2EEName;\n-\n-    private final EJBContainer ejbContainer;\n-\n-    private final Method[] methods;\n-\n-    private EJBJaxWsWebEndpoint ejbJaxWsWebEndpoint;\n-\n-    private volatile boolean handlerChainInitializationRequired = true;\n-\n-    private final Object handlerInitializationLock = new Object() {\n-    };\n-\n-    private static final TraceComponent tc = Tr.register(EJBPreInvokeInterceptor.class);\n-\n-    public EJBPreInvokeInterceptor(J2EEName j2EEName, Class<?> implClass, EJBContainer ejbContainer, List<Method> methods) {\n-        super(Phase.PRE_PROTOCOL_FRONTEND);\n-\n-        this.implClass = implClass;\n-        this.j2EEName = j2EEName;\n-        this.ejbContainer = ejbContainer;\n-        this.methods = methods == null ? null : methods.toArray(new Method[0]);\n-    }\n-\n-    @Override\n-    public void handleMessage(SoapMessage message) throws Fault {\n-        Exchange exchange = message.getExchange();\n-\n-        WSEJBEndpointManager endpointManager = null;\n-        Method targetMethod = null;\n-        try {\n-            if (implClass.isAnnotationPresent(WebServiceProvider.class)) {\n-                endpointManager = ejbContainer.createWebServiceEndpointManager(j2EEName, Provider.class);\n-                targetMethod = getProviderMethod(implClass);\n-            } else {\n-                if (ejbContainer != null) {\n-                    endpointManager = ejbContainer.createWebServiceEndpointManager(j2EEName, methods);\n-                    targetMethod = getTargetMethod(implClass, message);\n-                }\n-            }\n-\n-            if (targetMethod == null) {\n-                throw new IllegalStateException(\"Invocation target method should not be null.\");\n-            }\n-        } catch (EJBConfigurationException e) {\n-            throw new IllegalStateException(e);\n-        }\n-\n-        //ejb pre-invoke\n-        Object instance = null;\n-        WrappedMessageContext ctx = new WrappedMessageContext(message, Scope.APPLICATION);\n-        try {\n-            instance = endpointManager.ejbPreInvoke(targetMethod, ctx);\n-\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Execute ejbPreInvoke successfully in EJBPreInvokeInterceptor handleMessage: \", instance);\n-            }\n-\n-            //While creating the handler instances, the ReferenceContext from the host EJB Bean is required for injecting the resources\n-            //in the handlers. But, by default, EJB Bean is lazy initialized, if we create the handlers in the initialization of the router servlet,\n-            //the target EJB bean may not be initialized, so the injection event will not be published, and then no chance to set the RefereceContext\n-            //TODO Need a better way for handling this\n-            if (handlerChainInitializationRequired) {\n-                synchronized (handlerInitializationLock) {\n-                    if (handlerChainInitializationRequired) {\n-                        ejbJaxWsWebEndpoint.initializeHandlers(message);\n-                        handlerChainInitializationRequired = false;\n-                    }\n-                }\n-            }\n-\n-            // save the instance in exchange so that the EJBMethodInvoker could retrieve.\n-            exchange.put(JaxWsEJBConstants.EJB_INSTANCE, instance);\n-        } catch (RemoteException e) {\n-            throw new IllegalStateException(e);\n-        } finally {\n-            // make sure we always set this if ejbPreInvoke was at least attempted\n-            exchange.put(JaxWsEJBConstants.WS_EJB_ENDPOINT_MANAGER, endpointManager);\n-        }\n-    }\n-\n-    @Override\n-    public void handleFault(SoapMessage message) {\n-        try {\n-            Exchange exchange = message.getExchange();\n-\n-            // retrieve the ejb endpoint manager\n-            WSEJBEndpointManager endpointManager = (WSEJBEndpointManager) exchange.get(JaxWsEJBConstants.WS_EJB_ENDPOINT_MANAGER);\n-\n-            if (endpointManager != null) {\n-                endpointManager.ejbPostInvoke();\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Execute ejbPostInvoke successfully in EJBPreInvokeInterceptor handleFault\");\n-                }\n-            }\n-        } catch (Exception e) {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Exception occurred when attempting ejbPostInvoke: \" + e.getMessage());\n-            }\n-            // throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    protected Method getProviderMethod(final Class<?> providerClass) {\n-        Method providerMethod = null;\n-        Method[] methods = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n-            @Override\n-            public Method[] run() {\n-                return providerClass.getMethods();\n-            }\n-        });\n-\n-        if (methods != null) {\n-            for (Method method : methods) {\n-                if (method.getName().equals(\"invoke\")) {\n-                    providerMethod = method;\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return providerMethod;\n-    }\n-\n-    private Method getTargetMethod(Class<?> implClass, SoapMessage message) {\n-        setupBindingOperationInfo(message);\n-        BindingOperationInfo bop = message.getExchange().getBindingOperationInfo();\n-        if (bop == null) {\n-            return null;\n-        }\n-        return getMethod(message, bop);\n-    }\n-\n-    private void setupBindingOperationInfo(SoapMessage message) {\n-        Exchange exch = message.getExchange();\n-        if (exch.get(BindingOperationInfo.class) == null) {\n-            //need to know the operation to determine if oneway\n-            QName opName = getOpQName(message);\n-            if (opName == null) {\n-                return;\n-            }\n-            BindingOperationInfo bop = ServiceModelUtil.getOperationForWrapperElement(exch, opName, false);\n-            if (bop == null) {\n-                bop = ServiceModelUtil.getOperation(exch, opName);\n-            }\n-            if (bop != null) {\n-                exch.put(BindingOperationInfo.class, bop);\n-                exch.put(OperationInfo.class, bop.getOperationInfo());\n-                if (bop.getOutput() == null) {\n-                    exch.setOneWay(true);\n-                }\n-            }\n-        }\n-    }\n-\n-    private QName getOpQName(SoapMessage message) {\n-        SOAPMessageContextImpl sm = new SOAPMessageContextImpl(message);\n-        try {\n-            SOAPMessage msg = sm.getMessage();\n-            if (msg == null) {\n-                return null;\n-            }\n-            SOAPBody body = SAAJUtils.getBody(msg);\n-            if (body == null) {\n-                return null;\n-            }\n-            org.w3c.dom.Node nd = body.getFirstChild();\n-            while (nd != null && !(nd instanceof org.w3c.dom.Element)) {\n-                nd = nd.getNextSibling();\n-            }\n-            if (nd != null) {\n-                return new QName(nd.getNamespaceURI(), nd.getLocalName());\n-            }\n-            //Fix for CTS Defect 174209\n-            Collection<BindingOperationInfo> boi = message.getExchange().getEndpoint().getEndpointInfo().getBinding().getOperations();\n-            if (boi.size() > 0) {\n-                return boi.iterator().next().getName();\n-            }\n-        } catch (SOAPException e) {\n-            //ignore, nothing we can do\n-        }\n-        return null;\n-    }\n-\n-    private Method getMethod(Message message, BindingOperationInfo operation) {\n-        MethodDispatcher md = (MethodDispatcher) message.getExchange().get(Service.class).get(MethodDispatcher.class.getName());\n-        return md.getMethod(operation);\n-    }\n-\n-    /**\n-     * @param ejbJaxWsWebEndpoint the ejbJaxWsWebEndpoint to set\n-     */\n-    public void setEjbJaxWsWebEndpoint(EJBJaxWsWebEndpoint ejbJaxWsWebEndpoint) {\n-        this.ejbJaxWsWebEndpoint = ejbJaxWsWebEndpoint;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNjMzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533336335", "bodyText": "The isAnnotationPresent can be cached during the constructor instead of having to calculate it each time that handleMessage is called.  Not sure if the annotation service should be used instead of calling it directly.\nIf you change it in 2.3, you should also look at changing it in 2.2 as well.", "author": "jhanders34", "createdAt": "2020-12-01T11:26:14Z", "path": "dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java", "diffHunk": "@@ -77,7 +77,6 @@ public EJBPreInvokeInterceptor(J2EEName j2EEName, Class<?> implClass, EJBContain\n         this.j2EEName = j2EEName;\n         this.ejbContainer = ejbContainer;\n         this.methods = methods == null ? null : methods.toArray(new Method[0]);", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzUxNzkyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533517923", "bodyText": "Oh, nice suggestion. I'm going to open an issue for both, if that's good with you?", "author": "neuwerk", "createdAt": "2020-12-01T15:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNjMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzU5ODIwMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533598202", "bodyText": "Why open an issue for something that can be done in 15 seconds?", "author": "jhanders34", "createdAt": "2020-12-01T17:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMzNjMzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java b/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java\ndeleted file mode 100644\nindex 5c830427a2..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.ejb/src/com/ibm/ws/jaxws/ejb/EJBPreInvokeInterceptor.java\n+++ /dev/null\n\n@@ -1,253 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.jaxws.ejb;\n-\n-import java.lang.reflect.Method;\n-import java.rmi.RemoteException;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.Collection;\n-import java.util.List;\n-\n-import javax.xml.namespace.QName;\n-import javax.xml.soap.SOAPBody;\n-import javax.xml.soap.SOAPException;\n-import javax.xml.soap.SOAPMessage;\n-import javax.xml.ws.Provider;\n-import javax.xml.ws.WebServiceProvider;\n-import javax.xml.ws.handler.MessageContext.Scope;\n-\n-import org.apache.cxf.binding.soap.SoapMessage;\n-import org.apache.cxf.binding.soap.saaj.SAAJUtils;\n-import org.apache.cxf.interceptor.Fault;\n-import org.apache.cxf.jaxws.context.WrappedMessageContext;\n-import org.apache.cxf.jaxws.handler.soap.SOAPMessageContextImpl;\n-import org.apache.cxf.message.Exchange;\n-import org.apache.cxf.message.Message;\n-import org.apache.cxf.phase.AbstractPhaseInterceptor;\n-import org.apache.cxf.phase.Phase;\n-import org.apache.cxf.service.Service;\n-import org.apache.cxf.service.invoker.MethodDispatcher;\n-import org.apache.cxf.service.model.BindingOperationInfo;\n-import org.apache.cxf.service.model.OperationInfo;\n-import org.apache.cxf.service.model.ServiceModelUtil;\n-\n-import com.ibm.ejs.container.EJBConfigurationException;\n-import com.ibm.websphere.csi.J2EEName;\n-import com.ibm.websphere.ras.Tr;\n-import com.ibm.websphere.ras.TraceComponent;\n-import com.ibm.ws.ejbcontainer.osgi.EJBContainer;\n-import com.ibm.ws.jaxws.ejb.internal.JaxWsEJBConstants;\n-import com.ibm.wsspi.ejbcontainer.WSEJBEndpointManager;\n-\n-/**\n- *\n- */\n-public class EJBPreInvokeInterceptor extends AbstractPhaseInterceptor<SoapMessage> {\n-\n-    private final Class<?> implClass;\n-\n-    private final J2EEName j2EEName;\n-\n-    private final EJBContainer ejbContainer;\n-\n-    private final Method[] methods;\n-\n-    private EJBJaxWsWebEndpoint ejbJaxWsWebEndpoint;\n-\n-    private volatile boolean handlerChainInitializationRequired = true;\n-\n-    private final Object handlerInitializationLock = new Object() {\n-    };\n-\n-    private static final TraceComponent tc = Tr.register(EJBPreInvokeInterceptor.class);\n-\n-    public EJBPreInvokeInterceptor(J2EEName j2EEName, Class<?> implClass, EJBContainer ejbContainer, List<Method> methods) {\n-        super(Phase.PRE_PROTOCOL_FRONTEND);\n-\n-        this.implClass = implClass;\n-        this.j2EEName = j2EEName;\n-        this.ejbContainer = ejbContainer;\n-        this.methods = methods == null ? null : methods.toArray(new Method[0]);\n-    }\n-\n-    @Override\n-    public void handleMessage(SoapMessage message) throws Fault {\n-        Exchange exchange = message.getExchange();\n-\n-        WSEJBEndpointManager endpointManager = null;\n-        Method targetMethod = null;\n-        try {\n-            if (implClass.isAnnotationPresent(WebServiceProvider.class)) {\n-                endpointManager = ejbContainer.createWebServiceEndpointManager(j2EEName, Provider.class);\n-                targetMethod = getProviderMethod(implClass);\n-            } else {\n-                if (ejbContainer != null) {\n-                    endpointManager = ejbContainer.createWebServiceEndpointManager(j2EEName, methods);\n-                    targetMethod = getTargetMethod(implClass, message);\n-                }\n-            }\n-\n-            if (targetMethod == null) {\n-                throw new IllegalStateException(\"Invocation target method should not be null.\");\n-            }\n-        } catch (EJBConfigurationException e) {\n-            throw new IllegalStateException(e);\n-        }\n-\n-        //ejb pre-invoke\n-        Object instance = null;\n-        WrappedMessageContext ctx = new WrappedMessageContext(message, Scope.APPLICATION);\n-        try {\n-            instance = endpointManager.ejbPreInvoke(targetMethod, ctx);\n-\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Execute ejbPreInvoke successfully in EJBPreInvokeInterceptor handleMessage: \", instance);\n-            }\n-\n-            //While creating the handler instances, the ReferenceContext from the host EJB Bean is required for injecting the resources\n-            //in the handlers. But, by default, EJB Bean is lazy initialized, if we create the handlers in the initialization of the router servlet,\n-            //the target EJB bean may not be initialized, so the injection event will not be published, and then no chance to set the RefereceContext\n-            //TODO Need a better way for handling this\n-            if (handlerChainInitializationRequired) {\n-                synchronized (handlerInitializationLock) {\n-                    if (handlerChainInitializationRequired) {\n-                        ejbJaxWsWebEndpoint.initializeHandlers(message);\n-                        handlerChainInitializationRequired = false;\n-                    }\n-                }\n-            }\n-\n-            // save the instance in exchange so that the EJBMethodInvoker could retrieve.\n-            exchange.put(JaxWsEJBConstants.EJB_INSTANCE, instance);\n-        } catch (RemoteException e) {\n-            throw new IllegalStateException(e);\n-        } finally {\n-            // make sure we always set this if ejbPreInvoke was at least attempted\n-            exchange.put(JaxWsEJBConstants.WS_EJB_ENDPOINT_MANAGER, endpointManager);\n-        }\n-    }\n-\n-    @Override\n-    public void handleFault(SoapMessage message) {\n-        try {\n-            Exchange exchange = message.getExchange();\n-\n-            // retrieve the ejb endpoint manager\n-            WSEJBEndpointManager endpointManager = (WSEJBEndpointManager) exchange.get(JaxWsEJBConstants.WS_EJB_ENDPOINT_MANAGER);\n-\n-            if (endpointManager != null) {\n-                endpointManager.ejbPostInvoke();\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Execute ejbPostInvoke successfully in EJBPreInvokeInterceptor handleFault\");\n-                }\n-            }\n-        } catch (Exception e) {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Exception occurred when attempting ejbPostInvoke: \" + e.getMessage());\n-            }\n-            // throw new IllegalStateException(e);\n-        }\n-    }\n-\n-    protected Method getProviderMethod(final Class<?> providerClass) {\n-        Method providerMethod = null;\n-        Method[] methods = AccessController.doPrivileged(new PrivilegedAction<Method[]>() {\n-            @Override\n-            public Method[] run() {\n-                return providerClass.getMethods();\n-            }\n-        });\n-\n-        if (methods != null) {\n-            for (Method method : methods) {\n-                if (method.getName().equals(\"invoke\")) {\n-                    providerMethod = method;\n-                    break;\n-                }\n-            }\n-        }\n-\n-        return providerMethod;\n-    }\n-\n-    private Method getTargetMethod(Class<?> implClass, SoapMessage message) {\n-        setupBindingOperationInfo(message);\n-        BindingOperationInfo bop = message.getExchange().getBindingOperationInfo();\n-        if (bop == null) {\n-            return null;\n-        }\n-        return getMethod(message, bop);\n-    }\n-\n-    private void setupBindingOperationInfo(SoapMessage message) {\n-        Exchange exch = message.getExchange();\n-        if (exch.get(BindingOperationInfo.class) == null) {\n-            //need to know the operation to determine if oneway\n-            QName opName = getOpQName(message);\n-            if (opName == null) {\n-                return;\n-            }\n-            BindingOperationInfo bop = ServiceModelUtil.getOperationForWrapperElement(exch, opName, false);\n-            if (bop == null) {\n-                bop = ServiceModelUtil.getOperation(exch, opName);\n-            }\n-            if (bop != null) {\n-                exch.put(BindingOperationInfo.class, bop);\n-                exch.put(OperationInfo.class, bop.getOperationInfo());\n-                if (bop.getOutput() == null) {\n-                    exch.setOneWay(true);\n-                }\n-            }\n-        }\n-    }\n-\n-    private QName getOpQName(SoapMessage message) {\n-        SOAPMessageContextImpl sm = new SOAPMessageContextImpl(message);\n-        try {\n-            SOAPMessage msg = sm.getMessage();\n-            if (msg == null) {\n-                return null;\n-            }\n-            SOAPBody body = SAAJUtils.getBody(msg);\n-            if (body == null) {\n-                return null;\n-            }\n-            org.w3c.dom.Node nd = body.getFirstChild();\n-            while (nd != null && !(nd instanceof org.w3c.dom.Element)) {\n-                nd = nd.getNextSibling();\n-            }\n-            if (nd != null) {\n-                return new QName(nd.getNamespaceURI(), nd.getLocalName());\n-            }\n-            //Fix for CTS Defect 174209\n-            Collection<BindingOperationInfo> boi = message.getExchange().getEndpoint().getEndpointInfo().getBinding().getOperations();\n-            if (boi.size() > 0) {\n-                return boi.iterator().next().getName();\n-            }\n-        } catch (SOAPException e) {\n-            //ignore, nothing we can do\n-        }\n-        return null;\n-    }\n-\n-    private Method getMethod(Message message, BindingOperationInfo operation) {\n-        MethodDispatcher md = (MethodDispatcher) message.getExchange().get(Service.class).get(MethodDispatcher.class.getName());\n-        return md.getMethod(operation);\n-    }\n-\n-    /**\n-     * @param ejbJaxWsWebEndpoint the ejbJaxWsWebEndpoint to set\n-     */\n-    public void setEjbJaxWsWebEndpoint(EJBJaxWsWebEndpoint ejbJaxWsWebEndpoint) {\n-        this.ejbJaxWsWebEndpoint = ejbJaxWsWebEndpoint;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MTQwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533351400", "bodyText": "This is different than 2.2.  Should this be updated in the 2.2 version as well.  Like I said if the code is the same between the two might as well just have one copy.", "author": "jhanders34", "createdAt": "2020-12-01T11:53:07Z", "path": "dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/JaxWsHttpServletRequestAdapter.java", "diffHunk": "@@ -41,7 +42,7 @@\n  * as in EJB based Web Services, the EJB invocation context is built very earlier in one intercepter, which may cause issue for those methods requiring\n  * Web Component Context MetaData\n  */\n-public class JaxWsHttpServletRequestAdapter implements HttpServletRequest {\n+public class JaxWsHttpServletRequestAdapter extends HttpServletRequestWrapper implements HttpServletRequest {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM3MTQyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535371420", "bodyText": "So you didn't carry this over to the 2.2 version.  So it isn't needed?", "author": "jhanders34", "createdAt": "2020-12-03T16:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MTQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNzYwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535427606", "bodyText": "This was an attempt to mimic what the jaxrs-2.1 is doing with more updated version of the spec. Since this change wasn't needed in the first place, I've removed it along with all the other duplicate code in the ...jaxws.2.3.webcontainer.", "author": "neuwerk", "createdAt": "2020-12-03T17:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MTQwMA=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/JaxWsHttpServletRequestAdapter.java b/dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/JaxWsHttpServletRequestAdapter.java\ndeleted file mode 100644\nindex dff4b20ade..0000000000\n--- a/dev/com.ibm.ws.jaxws.2.3.webcontainer/src/com/ibm/ws/jaxws23/webcontainer/JaxWsHttpServletRequestAdapter.java\n+++ /dev/null\n\n@@ -1,1049 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.jaxws23.webcontainer;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.UnsupportedEncodingException;\n-import java.security.Principal;\n-import java.util.Collection;\n-import java.util.Enumeration;\n-import java.util.Locale;\n-import java.util.Map;\n-\n-import javax.servlet.AsyncContext;\n-import javax.servlet.DispatcherType;\n-import javax.servlet.RequestDispatcher;\n-import javax.servlet.ServletContext;\n-import javax.servlet.ServletException;\n-import javax.servlet.ServletInputStream;\n-import javax.servlet.ServletRequest;\n-import javax.servlet.ServletResponse;\n-import javax.servlet.http.Cookie;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletRequestWrapper;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.Part;\n-\n-import com.ibm.ws.runtime.metadata.ComponentMetaData;\n-import com.ibm.wsspi.webcontainer.collaborator.IWebAppNameSpaceCollaborator;\n-\n-/**\n- * JaxWsHttpServletRequestAdapter is used to recover the Web Component Context MetaData while invoking the methods from request instance,\n- * as in EJB based Web Services, the EJB invocation context is built very earlier in one intercepter, which may cause issue for those methods requiring\n- * Web Component Context MetaData\n- */\n-public class JaxWsHttpServletRequestAdapter extends HttpServletRequestWrapper implements HttpServletRequest {\n-\n-    private final IWebAppNameSpaceCollaborator collaborator;\n-\n-    private final ComponentMetaData componentMetaData;\n-\n-    private final HttpServletRequest request;\n-\n-    /**\n-     * @param request\n-     */\n-    public JaxWsHttpServletRequestAdapter(HttpServletRequest request, IWebAppNameSpaceCollaborator collaborator, ComponentMetaData componentMetaData) {\n-        super(request);\n-        this.collaborator = collaborator;\n-        this.componentMetaData = componentMetaData;\n-        this.request = request;\n-    }\n-\n-    @Override\n-    public String getRemoteUser() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRemoteUser();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    @Override\n-    public Principal getUserPrincipal() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getUserPrincipal();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getAsyncContext()\n-     */\n-    @Override\n-    public AsyncContext getAsyncContext() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getAsyncContext();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getAttribute(java.lang.String)\n-     */\n-    @Override\n-    public Object getAttribute(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getAttribute(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getAttributeNames()\n-     */\n-    @Override\n-    public Enumeration<String> getAttributeNames() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getAttributeNames();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getCharacterEncoding()\n-     */\n-    @Override\n-    public String getCharacterEncoding() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getCharacterEncoding();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getContentLength()\n-     */\n-    @Override\n-    public int getContentLength() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getContentLength();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getContentType()\n-     */\n-    @Override\n-    public String getContentType() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getContentType();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getDispatcherType()\n-     */\n-    @Override\n-    public DispatcherType getDispatcherType() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getDispatcherType();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getInputStream()\n-     */\n-    @Override\n-    public ServletInputStream getInputStream() throws IOException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getInputStream();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getLocalAddr()\n-     */\n-    @Override\n-    public String getLocalAddr() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getLocalAddr();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getLocalName()\n-     */\n-    @Override\n-    public String getLocalName() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getLocalName();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getLocalPort()\n-     */\n-    @Override\n-    public int getLocalPort() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getLocalPort();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getLocale()\n-     */\n-    @Override\n-    public Locale getLocale() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getLocale();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getLocales()\n-     */\n-    @Override\n-    public Enumeration<Locale> getLocales() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getLocales();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getParameter(java.lang.String)\n-     */\n-    @Override\n-    public String getParameter(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getParameter(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getParameterMap()\n-     */\n-    @Override\n-    public Map<String, String[]> getParameterMap() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getParameterMap();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getParameterNames()\n-     */\n-    @Override\n-    public Enumeration<String> getParameterNames() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getParameterNames();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getParameterValues(java.lang.String)\n-     */\n-    @Override\n-    public String[] getParameterValues(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getParameterValues(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getProtocol()\n-     */\n-    @Override\n-    public String getProtocol() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getProtocol();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getReader()\n-     */\n-    @Override\n-    public BufferedReader getReader() throws IOException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getReader();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getRealPath(java.lang.String)\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public String getRealPath(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRealPath(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getRemoteAddr()\n-     */\n-    @Override\n-    public String getRemoteAddr() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRemoteAddr();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getRemoteHost()\n-     */\n-    @Override\n-    public String getRemoteHost() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRemoteHost();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getRemotePort()\n-     */\n-    @Override\n-    public int getRemotePort() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRemotePort();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getRequestDispatcher(java.lang.String)\n-     */\n-    @Override\n-    public RequestDispatcher getRequestDispatcher(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRequestDispatcher(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getScheme()\n-     */\n-    @Override\n-    public String getScheme() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getScheme();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getServerName()\n-     */\n-    @Override\n-    public String getServerName() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getServerName();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getServerPort()\n-     */\n-    @Override\n-    public int getServerPort() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getServerPort();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#getServletContext()\n-     */\n-    @Override\n-    public ServletContext getServletContext() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getServletContext();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#isAsyncStarted()\n-     */\n-    @Override\n-    public boolean isAsyncStarted() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isAsyncStarted();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#isAsyncSupported()\n-     */\n-    @Override\n-    public boolean isAsyncSupported() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isAsyncSupported();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#isSecure()\n-     */\n-    @Override\n-    public boolean isSecure() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isSecure();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#removeAttribute(java.lang.String)\n-     */\n-    @Override\n-    public void removeAttribute(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            request.removeAttribute(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#setAttribute(java.lang.String, java.lang.Object)\n-     */\n-    @Override\n-    public void setAttribute(String arg0, Object arg1) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            request.setAttribute(arg0, arg1);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#setCharacterEncoding(java.lang.String)\n-     */\n-    @Override\n-    public void setCharacterEncoding(String arg0) throws UnsupportedEncodingException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            request.setCharacterEncoding(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#startAsync()\n-     */\n-    @Override\n-    public AsyncContext startAsync() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.startAsync();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.ServletRequest#startAsync(javax.servlet.ServletRequest, javax.servlet.ServletResponse)\n-     */\n-    @Override\n-    public AsyncContext startAsync(ServletRequest arg0, ServletResponse arg1) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.startAsync(arg0, arg1);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#authenticate(javax.servlet.http.HttpServletResponse)\n-     */\n-    @Override\n-    public boolean authenticate(HttpServletResponse arg0) throws IOException, ServletException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.authenticate(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getAuthType()\n-     */\n-    @Override\n-    public String getAuthType() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getAuthType();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getContextPath()\n-     */\n-    @Override\n-    public String getContextPath() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getContextPath();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getCookies()\n-     */\n-    @Override\n-    public Cookie[] getCookies() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getCookies();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getDateHeader(java.lang.String)\n-     */\n-    @Override\n-    public long getDateHeader(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getDateHeader(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getHeader(java.lang.String)\n-     */\n-    @Override\n-    public String getHeader(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getHeader(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getHeaderNames()\n-     */\n-    @Override\n-    public Enumeration<String> getHeaderNames() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getHeaderNames();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getHeaders(java.lang.String)\n-     */\n-    @Override\n-    public Enumeration<String> getHeaders(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getHeaders(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getIntHeader(java.lang.String)\n-     */\n-    @Override\n-    public int getIntHeader(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getIntHeader(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getMethod()\n-     */\n-    @Override\n-    public String getMethod() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getMethod();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getPart(java.lang.String)\n-     */\n-    @Override\n-    public Part getPart(String arg0) throws IOException, ServletException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getPart(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getParts()\n-     */\n-    @Override\n-    public Collection<Part> getParts() throws IOException, ServletException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getParts();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getPathInfo()\n-     */\n-    @Override\n-    public String getPathInfo() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getPathInfo();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getPathTranslated()\n-     */\n-    @Override\n-    public String getPathTranslated() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getPathTranslated();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getQueryString()\n-     */\n-    @Override\n-    public String getQueryString() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getQueryString();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getRequestURI()\n-     */\n-    @Override\n-    public String getRequestURI() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRequestURI();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getRequestURL()\n-     */\n-    @Override\n-    public StringBuffer getRequestURL() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRequestURL();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getRequestedSessionId()\n-     */\n-    @Override\n-    public String getRequestedSessionId() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getRequestedSessionId();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getServletPath()\n-     */\n-    @Override\n-    public String getServletPath() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getServletPath();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getSession()\n-     */\n-    @Override\n-    public HttpSession getSession() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getSession();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#getSession(boolean)\n-     */\n-    @Override\n-    public HttpSession getSession(boolean arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.getSession(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#isRequestedSessionIdFromCookie()\n-     */\n-    @Override\n-    public boolean isRequestedSessionIdFromCookie() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isRequestedSessionIdFromCookie();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#isRequestedSessionIdFromURL()\n-     */\n-    @Override\n-    public boolean isRequestedSessionIdFromURL() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isRequestedSessionIdFromURL();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#isRequestedSessionIdFromUrl()\n-     */\n-    @SuppressWarnings(\"deprecation\")\n-    @Override\n-    public boolean isRequestedSessionIdFromUrl() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isRequestedSessionIdFromUrl();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#isRequestedSessionIdValid()\n-     */\n-    @Override\n-    public boolean isRequestedSessionIdValid() {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isRequestedSessionIdValid();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#isUserInRole(java.lang.String)\n-     */\n-    @Override\n-    public boolean isUserInRole(String arg0) {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            return request.isUserInRole(arg0);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#login(java.lang.String, java.lang.String)\n-     */\n-    @Override\n-    public void login(String arg0, String arg1) throws ServletException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            request.login(arg0, arg1);\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-\n-    }\n-\n-    /*\n-     * (non-Javadoc)\n-     *\n-     * @see javax.servlet.http.HttpServletRequest#logout()\n-     */\n-    @Override\n-    public void logout() throws ServletException {\n-        try {\n-            collaborator.preInvoke(componentMetaData);\n-            request.logout();\n-        } finally {\n-            collaborator.postInvoke();\n-        }\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1NjM3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533356370", "bodyText": "I did not find any server.xml files that have jaxwstest-2.2 and jsp-2.2, so it seems unnecessary to have the removeFeature calls for them.", "author": "jhanders34", "createdAt": "2020-12-01T12:01:28Z", "path": "dev/com.ibm.ws.jaxws.cdi_fat/fat/src/com/ibm/ws/jaxws/cdi/FATSuite.java", "diffHunk": "@@ -10,17 +10,30 @@\n  *******************************************************************************/\n package com.ibm.ws.jaxws.cdi;\n \n+import org.junit.ClassRule;\n import org.junit.runner.RunWith;\n import org.junit.runners.Suite;\n import org.junit.runners.Suite.SuiteClasses;\n \n import componenttest.custom.junit.runner.AlwaysPassesTest;\n+import componenttest.rules.repeater.FeatureReplacementAction;\n+import componenttest.rules.repeater.RepeatTests;\n \n @RunWith(Suite.class)\n @SuiteClasses({\n                 AlwaysPassesTest.class,\n                 BasicTest.class,\n })\n public class FATSuite {\n+    @ClassRule\n+    public static RepeatTests r = RepeatTests.withoutModification()\n+                    .andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\")\n+                                    .addFeature(\"cdi-2.0\")\n+                                    .removeFeature(\"cdi-1.2\")\n+                                    .removeFeature(\"jaxws-2.2\")\n+                                    .removeFeature(\"jsp-2.2\")\n+                                    .removeFeature(\"servlet-3.1\")\n+                                    .removeFeature(\"jaxwstest-2.2\")", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNjA4Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535426086", "bodyText": "removed", "author": "neuwerk", "createdAt": "2020-12-03T17:13:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1NjM3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0ODMyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535448320", "bodyText": "One of the server.xml files in the project has servlet-3.1.  You removed that one as well.  Any reason why?", "author": "jhanders34", "createdAt": "2020-12-03T17:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1NjM3MA=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.cdi_fat/fat/src/com/ibm/ws/jaxws/cdi/FATSuite.java b/dev/com.ibm.ws.jaxws.cdi_fat/fat/src/com/ibm/ws/jaxws/cdi/FATSuite.java\nindex f11d912c3f..3d7e924599 100755\n--- a/dev/com.ibm.ws.jaxws.cdi_fat/fat/src/com/ibm/ws/jaxws/cdi/FATSuite.java\n+++ b/dev/com.ibm.ws.jaxws.cdi_fat/fat/src/com/ibm/ws/jaxws/cdi/FATSuite.java\n\n@@ -31,9 +31,7 @@ public class FATSuite {\n                                     .addFeature(\"cdi-2.0\")\n                                     .removeFeature(\"cdi-1.2\")\n                                     .removeFeature(\"jaxws-2.2\")\n-                                    .removeFeature(\"jsp-2.2\")\n                                     .removeFeature(\"servlet-3.1\")\n-                                    .removeFeature(\"jaxwstest-2.2\")\n                                     .withID(\"jaxws-2.3\"));\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2OTQyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533369429", "bodyText": "jsp-2.2, servlet-3.1 and jaxwstest-2.2 are not necessary since server.xml files don't use them in this fat project.", "author": "jhanders34", "createdAt": "2020-12-01T12:24:58Z", "path": "dev/com.ibm.ws.jaxws.ejb_fat/fat/src/com/ibm/ws/jaxws/ejb/suite/FATSuite.java", "diffHunk": "@@ -42,4 +46,7 @@\n                 EJBWSInterceptorTest.class\n })\n public class FATSuite {\n+    @ClassRule\n+    public static RepeatTests r = RepeatTests.withoutModification().andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\").removeFeature(\"jaxws-2.2\").removeFeature(\"jsp-2.2\").removeFeature(\"servlet-3.1\").removeFeature(\"jaxwstest-2.2\").withID(\"jaxws-2.3\"));", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNTIyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535425221", "bodyText": "Removed", "author": "neuwerk", "createdAt": "2020-12-03T17:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2OTQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.ejb_fat/fat/src/com/ibm/ws/jaxws/ejb/suite/FATSuite.java b/dev/com.ibm.ws.jaxws.ejb_fat/fat/src/com/ibm/ws/jaxws/ejb/suite/FATSuite.java\nindex 829533470d..913c14121e 100644\n--- a/dev/com.ibm.ws.jaxws.ejb_fat/fat/src/com/ibm/ws/jaxws/ejb/suite/FATSuite.java\n+++ b/dev/com.ibm.ws.jaxws.ejb_fat/fat/src/com/ibm/ws/jaxws/ejb/suite/FATSuite.java\n\n@@ -47,6 +47,6 @@ import componenttest.rules.repeater.RepeatTests;\n })\n public class FATSuite {\n     @ClassRule\n-    public static RepeatTests r = RepeatTests.withoutModification().andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\").removeFeature(\"jaxws-2.2\").removeFeature(\"jsp-2.2\").removeFeature(\"servlet-3.1\").removeFeature(\"jaxwstest-2.2\").withID(\"jaxws-2.3\"));\n+    public static RepeatTests r = RepeatTests.withoutModification().andWith(new FeatureReplacementAction().addFeature(\"jaxws-2.3\").removeFeature(\"jaxws-2.2\").withID(\"jaxws-2.3\"));\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NjYxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533376610", "bodyText": "No Liberty change comments in this class.  What did you change from the vanilla CXF version?", "author": "jhanders34", "createdAt": "2020-12-01T12:38:05Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/JaxwsClientCallback.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.jaxws;\n+\n+import java.util.Map;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import javax.xml.ws.AsyncHandler;\n+import javax.xml.ws.Response;\n+\n+import org.apache.cxf.endpoint.ClientCallback;\n+", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyMDk3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535420970", "bodyText": "Removed this file", "author": "neuwerk", "createdAt": "2020-12-03T17:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NjYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/JaxwsClientCallback.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/JaxwsClientCallback.java\ndeleted file mode 100644\nindex 8f1ed9c22b..0000000000\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/JaxwsClientCallback.java\n+++ /dev/null\n\n@@ -1,135 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.jaxws;\n-\n-import java.util.Map;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n-\n-import javax.xml.ws.AsyncHandler;\n-import javax.xml.ws.Response;\n-\n-import org.apache.cxf.endpoint.ClientCallback;\n-\n-class JaxwsClientCallback<T> extends ClientCallback {\n-    final AsyncHandler<T> handler;\n-    final Object proxy;\n-\n-    JaxwsClientCallback(final AsyncHandler<T> handler, Object p) {\n-        this.handler = handler;\n-        this.proxy = p;\n-    }\n-    public void handleResponse(Map<String, Object> ctx, Object[] res) {\n-        context = ctx;\n-        \n-        // The handler has to be called *before* future completes\n-        if (handler != null) {\n-            handler.handleResponse(new Response<T>() {\n-                protected boolean cancelled;\n-                \n-                public Map<String, Object> getContext() {\n-                    return context;\n-                }\n-\n-                public boolean cancel(boolean mayInterruptIfRunning) {\n-                    cancelled = true;\n-                    return true;\n-                }\n-\n-                @SuppressWarnings(\"unchecked\")\n-                public T get() throws InterruptedException, ExecutionException {\n-                    return (T)res[0];\n-                }\n-\n-                @SuppressWarnings(\"unchecked\")\n-                public T get(long timeout, TimeUnit unit) throws InterruptedException,\n-                    ExecutionException, TimeoutException {\n-                    return (T)res[0];\n-                }\n-\n-                public boolean isCancelled() {\n-                    return cancelled;\n-                }\n-\n-                public boolean isDone() {\n-                    return true;\n-                }\n-\n-            });\n-        }\n-        \n-        delegate.complete(res);\n-        \n-        synchronized (this) {\n-            notifyAll();\n-        }\n-    }\n-\n-    @Override\n-    public void handleException(Map<String, Object> ctx, final Throwable ex) {\n-        context = ctx;\n-        \n-        if (handler != null) {\n-            handler.handleResponse(new Response<T>() {\n-                protected boolean cancelled;\n-\n-                public Map<String, Object> getContext() {\n-                    return context;\n-                }\n-\n-                public boolean cancel(boolean mayInterruptIfRunning) {\n-                    cancelled = true;\n-                    return true;\n-                }\n-\n-                public T get() throws InterruptedException, ExecutionException {\n-                    throw new ExecutionException(ex);\n-                }\n-\n-                public T get(long timeout, TimeUnit unit)\n-                    throws InterruptedException, ExecutionException, TimeoutException {\n-\n-                    throw new ExecutionException(ex);\n-                }\n-\n-                public boolean isCancelled() {\n-                    return cancelled;\n-                }\n-\n-                public boolean isDone() {\n-                    return true;\n-                }\n-\n-            });\n-        }\n-\n-        // The handler has to be called *before* future completes\n-        delegate.completeExceptionally(mapThrowable(ex));\n-        \n-        synchronized (this) {\n-            notifyAll();\n-        }\n-    }\n-    \n-    protected Throwable mapThrowable(Throwable t) {\n-        return t;\n-    }\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NzAzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533377035", "bodyText": "No Liberty change comments in this class. What did you change from the vanilla CXF version?", "author": "jhanders34", "createdAt": "2020-12-01T12:38:55Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/ServiceImpl.java", "diffHunk": "@@ -0,0 +1,772 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.jaxws;\n+\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.concurrent.Executor;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.jws.WebService;\n+import javax.wsdl.Definition;\n+import javax.wsdl.Port;\n+import javax.wsdl.extensions.ExtensibilityElement;\n+import javax.wsdl.extensions.http.HTTPAddress;\n+import javax.wsdl.extensions.soap.SOAPAddress;\n+import javax.wsdl.extensions.soap12.SOAP12Address;\n+import javax.wsdl.extensions.soap12.SOAP12Binding;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.namespace.QName;\n+import javax.xml.ws.Dispatch;\n+import javax.xml.ws.EndpointReference;\n+import javax.xml.ws.Service.Mode;\n+import javax.xml.ws.WebServiceException;\n+import javax.xml.ws.WebServiceFeature;\n+import javax.xml.ws.handler.Handler;\n+import javax.xml.ws.handler.HandlerResolver;\n+import javax.xml.ws.soap.SOAPBinding;\n+import javax.xml.ws.spi.ServiceDelegate;\n+\n+import org.apache.cxf.Bus;\n+import org.apache.cxf.BusException;\n+import org.apache.cxf.BusFactory;\n+import org.apache.cxf.binding.BindingFactoryManager;\n+import org.apache.cxf.binding.soap.wsdl.extensions.SoapAddress;\n+import org.apache.cxf.binding.soap.wsdl.extensions.SoapBinding;\n+import org.apache.cxf.common.i18n.Message;\n+import org.apache.cxf.common.i18n.UncheckedException;\n+import org.apache.cxf.common.logging.LogUtils;\n+import org.apache.cxf.common.util.PackageUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.configuration.Configurer;\n+import org.apache.cxf.databinding.DataBinding;\n+import org.apache.cxf.databinding.source.SourceDataBinding;\n+import org.apache.cxf.endpoint.Client;\n+import org.apache.cxf.endpoint.ClientImpl;\n+import org.apache.cxf.endpoint.EndpointException;\n+import org.apache.cxf.endpoint.ServiceContractResolverRegistry;\n+import org.apache.cxf.feature.Feature;\n+import org.apache.cxf.frontend.ClientProxy;\n+import org.apache.cxf.helpers.CastUtils;\n+import org.apache.cxf.interceptor.AbstractBasicInterceptorProvider;\n+import org.apache.cxf.jaxb.JAXBDataBinding;\n+import org.apache.cxf.jaxws.binding.soap.JaxWsSoapBindingConfiguration;\n+import org.apache.cxf.jaxws.handler.HandlerResolverImpl;\n+import org.apache.cxf.jaxws.handler.PortInfoImpl;\n+import org.apache.cxf.jaxws.spi.ProviderImpl;\n+import org.apache.cxf.jaxws.support.BindingID;\n+import org.apache.cxf.jaxws.support.DummyImpl;\n+import org.apache.cxf.jaxws.support.JaxWsClientEndpointImpl;\n+import org.apache.cxf.jaxws.support.JaxWsEndpointImpl;\n+import org.apache.cxf.jaxws.support.JaxWsServiceFactoryBean;\n+import org.apache.cxf.service.Service;\n+import org.apache.cxf.service.factory.AbstractServiceFactoryBean;\n+import org.apache.cxf.service.factory.ServiceConstructionException;\n+import org.apache.cxf.service.model.BindingInfo;\n+import org.apache.cxf.service.model.BindingOperationInfo;\n+import org.apache.cxf.service.model.EndpointInfo;\n+import org.apache.cxf.service.model.ServiceInfo;\n+import org.apache.cxf.service.model.ServiceModelUtil;\n+import org.apache.cxf.transport.DestinationFactory;\n+import org.apache.cxf.transport.DestinationFactoryManager;\n+import org.apache.cxf.ws.addressing.EndpointReferenceType;\n+import org.apache.cxf.ws.addressing.EndpointReferenceUtils;\n+import org.apache.cxf.wsdl.WSDLManager;\n+import org.apache.cxf.wsdl.http.AddressType;\n+import org.apache.cxf.wsdl.service.factory.ReflectionServiceFactoryBean;\n+import org.apache.cxf.wsdl11.WSDLServiceFactory;\n+", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/ServiceImpl.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/ServiceImpl.java\nindex 74ae7d6d2f..95f333b373 100644\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/ServiceImpl.java\n+++ b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/ServiceImpl.java\n\n@@ -433,7 +433,7 @@ public class ServiceImpl extends ServiceDelegate {\n         LOG.log(Level.FINE, \"endpoint reference:\", epr);\n         LOG.log(Level.FINE, \"endpoint interface:\", serviceEndpointInterface);\n \n-        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n+        final JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n         JaxWsClientFactoryBean clientFac = (JaxWsClientFactoryBean) proxyFac.getClientFactoryBean();\n         JaxWsServiceFactoryBean serviceFactory = (JaxWsServiceFactoryBean) proxyFac.getServiceFactory();\n         List<WebServiceFeature> f = getAllFeatures(features);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NzIwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533377200", "bodyText": "No Liberty change comments in this class. What did you change from the vanilla CXF version?", "author": "jhanders34", "createdAt": "2020-12-01T12:39:12Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.jaxws.handler.soap;\n+\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Set;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.soap.Node;\n+import javax.xml.soap.SOAPBody;\n+import javax.xml.soap.SOAPElement;\n+import javax.xml.soap.SOAPException;\n+import javax.xml.soap.SOAPHeader;\n+import javax.xml.soap.SOAPMessage;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.ws.Binding;\n+import javax.xml.ws.handler.Handler;\n+import javax.xml.ws.handler.MessageContext;\n+import javax.xml.ws.handler.soap.SOAPHandler;\n+import javax.xml.ws.handler.soap.SOAPMessageContext;\n+\n+import org.apache.cxf.binding.soap.HeaderUtil;\n+import org.apache.cxf.binding.soap.SoapMessage;\n+import org.apache.cxf.binding.soap.interceptor.AbstractSoapInterceptor;\n+import org.apache.cxf.binding.soap.interceptor.SoapInterceptor;\n+import org.apache.cxf.binding.soap.interceptor.SoapPreProtocolOutInterceptor;\n+import org.apache.cxf.binding.soap.saaj.SAAJInInterceptor;\n+import org.apache.cxf.binding.soap.saaj.SAAJOutInterceptor;\n+import org.apache.cxf.binding.soap.saaj.SAAJUtils;\n+import org.apache.cxf.endpoint.Endpoint;\n+import org.apache.cxf.helpers.CastUtils;\n+import org.apache.cxf.interceptor.Fault;\n+import org.apache.cxf.interceptor.Interceptor;\n+import org.apache.cxf.interceptor.InterceptorChain;\n+import org.apache.cxf.interceptor.OutgoingChainInterceptor;\n+import org.apache.cxf.jaxws.handler.AbstractProtocolHandlerInterceptor;\n+import org.apache.cxf.jaxws.handler.HandlerChainInvoker;\n+import org.apache.cxf.message.Exchange;\n+import org.apache.cxf.message.Message;\n+import org.apache.cxf.message.MessageImpl;\n+import org.apache.cxf.phase.Phase;\n+import org.apache.cxf.staxutils.StaxUtils;\n+import org.apache.cxf.transport.MessageObserver;\n+import org.apache.cxf.ws.addressing.Names;\n+", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyMDc5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535420799", "bodyText": "Added a comment at top of the class about this being one of those classes that needs to be recompiled without change", "author": "neuwerk", "createdAt": "2020-12-03T17:07:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3NzIwMA=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java\nindex 3c27e097aa..a239d568a9 100644\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java\n+++ b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxws.3.2/src/org/apache/cxf/jaxws/handler/soap/SOAPHandlerInterceptor.java\n\n@@ -67,6 +67,7 @@ import org.apache.cxf.staxutils.StaxUtils;\n import org.apache.cxf.transport.MessageObserver;\n import org.apache.cxf.ws.addressing.Names;\n \n+//No Liberty Change: jaxws-2.3 requires recompiling this class\n public class SOAPHandlerInterceptor extends\n         AbstractProtocolHandlerInterceptor<SoapMessage> implements\n         SoapInterceptor {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3OTQxNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533379417", "bodyText": "No Liberty change comments in this class. What did you change from the vanilla CXF version?", "author": "jhanders34", "createdAt": "2020-12-01T12:43:09Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/interceptor/DocLiteralInInterceptor.java", "diffHunk": "@@ -0,0 +1,360 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.wsdl.interceptors;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.logging.Logger;\n+\n+import javax.xml.namespace.QName;\n+import javax.xml.stream.XMLStreamConstants;\n+import javax.xml.stream.XMLStreamReader;\n+\n+import org.apache.cxf.common.logging.LogUtils;\n+import org.apache.cxf.databinding.DataReader;\n+import org.apache.cxf.endpoint.Endpoint;\n+import org.apache.cxf.interceptor.AbstractInDatabindingInterceptor;\n+import org.apache.cxf.interceptor.Fault;\n+import org.apache.cxf.message.Exchange;\n+import org.apache.cxf.message.Message;\n+import org.apache.cxf.message.MessageContentsList;\n+import org.apache.cxf.message.MessageUtils;\n+import org.apache.cxf.phase.Phase;\n+import org.apache.cxf.service.Service;\n+import org.apache.cxf.service.model.BindingMessageInfo;\n+import org.apache.cxf.service.model.BindingOperationInfo;\n+import org.apache.cxf.service.model.MessageInfo;\n+import org.apache.cxf.service.model.MessagePartInfo;\n+import org.apache.cxf.service.model.OperationInfo;\n+import org.apache.cxf.service.model.ServiceInfo;\n+import org.apache.cxf.service.model.ServiceModelUtil;\n+import org.apache.cxf.staxutils.DepthXMLStreamReader;\n+import org.apache.cxf.staxutils.StaxUtils;\n+import org.apache.ws.commons.schema.XmlSchemaElement;\n+import org.apache.ws.commons.schema.constants.Constants;\n+", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQxOTcyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535419724", "bodyText": "Removed this file", "author": "neuwerk", "createdAt": "2020-12-03T17:05:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3OTQxNw=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/interceptor/DocLiteralInInterceptor.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/interceptor/DocLiteralInInterceptor.java\ndeleted file mode 100644\nindex 2cc3a3033e..0000000000\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/interceptor/DocLiteralInInterceptor.java\n+++ /dev/null\n\n@@ -1,360 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.wsdl.interceptors;\n-\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.logging.Logger;\n-\n-import javax.xml.namespace.QName;\n-import javax.xml.stream.XMLStreamConstants;\n-import javax.xml.stream.XMLStreamReader;\n-\n-import org.apache.cxf.common.logging.LogUtils;\n-import org.apache.cxf.databinding.DataReader;\n-import org.apache.cxf.endpoint.Endpoint;\n-import org.apache.cxf.interceptor.AbstractInDatabindingInterceptor;\n-import org.apache.cxf.interceptor.Fault;\n-import org.apache.cxf.message.Exchange;\n-import org.apache.cxf.message.Message;\n-import org.apache.cxf.message.MessageContentsList;\n-import org.apache.cxf.message.MessageUtils;\n-import org.apache.cxf.phase.Phase;\n-import org.apache.cxf.service.Service;\n-import org.apache.cxf.service.model.BindingMessageInfo;\n-import org.apache.cxf.service.model.BindingOperationInfo;\n-import org.apache.cxf.service.model.MessageInfo;\n-import org.apache.cxf.service.model.MessagePartInfo;\n-import org.apache.cxf.service.model.OperationInfo;\n-import org.apache.cxf.service.model.ServiceInfo;\n-import org.apache.cxf.service.model.ServiceModelUtil;\n-import org.apache.cxf.staxutils.DepthXMLStreamReader;\n-import org.apache.cxf.staxutils.StaxUtils;\n-import org.apache.ws.commons.schema.XmlSchemaElement;\n-import org.apache.ws.commons.schema.constants.Constants;\n-\n-public class DocLiteralInInterceptor extends AbstractInDatabindingInterceptor {\n-    public static final String KEEP_PARAMETERS_WRAPPER = DocLiteralInInterceptor.class.getName()\n-        + \".DocLiteralInInterceptor.keep-parameters-wrapper\";\n-\n-    private static final Logger LOG = LogUtils.getL7dLogger(DocLiteralInInterceptor.class);\n-\n-    public DocLiteralInInterceptor() {\n-        super(Phase.UNMARSHAL);\n-    }\n-\n-    public void handleMessage(Message message) {\n-        if (isGET(message) && message.getContent(List.class) != null) {\n-            LOG.fine(\"DocLiteralInInterceptor skipped in HTTP GET method\");\n-            return;\n-        }\n-\n-        DepthXMLStreamReader xmlReader = getXMLStreamReader(message);\n-        MessageContentsList parameters = new MessageContentsList();\n-\n-        Exchange exchange = message.getExchange();\n-        BindingOperationInfo bop = exchange.getBindingOperationInfo();\n-\n-        boolean client = isRequestor(message);\n-\n-        //if body is empty and we have BindingOperationInfo, we do not need to match\n-        //operation anymore, just return\n-        if (bop != null && !StaxUtils.toNextElement(xmlReader)) {\n-            // body may be empty for partial response to decoupled request\n-            return;\n-        }\n-\n-        Service service = ServiceModelUtil.getService(message.getExchange());\n-        bop = getBindingOperationInfo(xmlReader, exchange, bop, client);\n-        boolean forceDocLitBare = false;\n-        if (bop != null && bop.getBinding() != null) {\n-            forceDocLitBare = Boolean.TRUE.equals(bop.getBinding().getService().getProperty(\"soap.force.doclit.bare\"));\n-        }\n-        DataReader<XMLStreamReader> dr = getDataReader(message);\n-\n-        try {\n-            if (!forceDocLitBare && bop != null && bop.isUnwrappedCapable()) {\n-                ServiceInfo si = bop.getBinding().getService();\n-                // Wrapped case\n-                MessageInfo msgInfo = setMessage(message, bop, client, si);\n-                setDataReaderValidation(service, message, dr);\n-\n-                // Determine if we should keep the parameters wrapper\n-                if (shouldWrapParameters(msgInfo, message)) {\n-                    QName startQName = xmlReader.getName();\n-                    MessagePartInfo mpi = msgInfo.getFirstMessagePart();\n-                    if (!mpi.getConcreteName().equals(startQName)) {\n-                        throw new Fault(\"UNEXPECTED_WRAPPER_ELEMENT\", LOG, null, startQName,\n-                                        mpi.getConcreteName());\n-                    }\n-                    Object wrappedObject = dr.read(mpi, xmlReader);\n-                    parameters.put(mpi, wrappedObject);\n-                } else {\n-                    // Unwrap each part individually if we don't have a wrapper\n-\n-                    bop = bop.getUnwrappedOperation();\n-\n-                    msgInfo = setMessage(message, bop, client, si);\n-                    List<MessagePartInfo> messageParts = msgInfo.getMessageParts();\n-                    Iterator<MessagePartInfo> itr = messageParts.iterator();\n-\n-                    // advance just past the wrapped element so we don't get\n-                    // stuck\n-                    if (xmlReader.getEventType() == XMLStreamConstants.START_ELEMENT) {\n-                        StaxUtils.nextEvent(xmlReader);\n-                    }\n-\n-                    // loop through each child element\n-                    getPara(xmlReader, dr, parameters, itr, message);\n-                }\n-\n-            } else {\n-                //Bare style\n-                BindingMessageInfo msgInfo = null;\n-\n-\n-                Endpoint ep = exchange.getEndpoint();\n-                ServiceInfo si = ep.getEndpointInfo().getService();\n-                if (bop != null) { //for xml binding or client side\n-                    if (client) {\n-                        msgInfo = bop.getOutput();\n-                    } else {\n-                        msgInfo = bop.getInput();\n-                        if (bop.getOutput() == null) {\n-                            exchange.setOneWay(true);\n-                        }\n-                    }\n-                    if (msgInfo == null) {\n-                        return;\n-                    }\n-                    setMessage(message, bop, client, si, msgInfo.getMessageInfo());\n-                }\n-\n-                Collection<OperationInfo> operations = null;\n-                operations = new ArrayList<>();\n-                operations.addAll(si.getInterface().getOperations());\n-\n-                if (xmlReader == null || !StaxUtils.toNextElement(xmlReader)) {\n-                    // empty input\n-                    getBindingOperationForEmptyBody(operations, ep, exchange);\n-                    return;\n-                }\n-\n-                setDataReaderValidation(service, message, dr);\n-\n-                int paramNum = 0;\n-\n-                do {\n-                    QName elName = xmlReader.getName();\n-                    Object o = null;\n-\n-                    MessagePartInfo p;\n-                    if (!client && msgInfo != null && msgInfo.getMessageParts() != null\n-                        && msgInfo.getMessageParts().isEmpty()) {\n-                        //no input messagePartInfo\n-                        return;\n-                    }\n-\n-                    if (msgInfo != null && msgInfo.getMessageParts() != null\n-                        && msgInfo.getMessageParts().size() > 0) {\n-                        if (msgInfo.getMessageParts().size() > paramNum) {\n-                            p = msgInfo.getMessageParts().get(paramNum);\n-                        } else {\n-                            p = null;\n-                        }\n-                    } else {\n-                        p = findMessagePart(exchange, operations, elName, client, paramNum, message);\n-                    }\n-\n-                    if (!forceDocLitBare) {\n-                        //Make sure the elName found on the wire is actually OK for\n-                        //the purpose we need it\n-                        validatePart(p, elName, message);\n-                    }\n-\n-                    o = dr.read(p, xmlReader);\n-                    if (forceDocLitBare && parameters.isEmpty()) {\n-                        // webservice provider does not need to ensure size\n-                        parameters.add(o);\n-                    } else {\n-                        parameters.put(p, o);\n-                    }\n-\n-                    paramNum++;\n-                    if (message.getContent(XMLStreamReader.class) == null || o == xmlReader) {\n-                        xmlReader = null;\n-                    }\n-                } while (xmlReader != null && StaxUtils.toNextElement(xmlReader));\n-\n-            }\n-\n-            message.setContent(List.class, parameters);\n-        } catch (Fault f) {\n-            if (!isRequestor(message)) {\n-                f.setFaultCode(Fault.FAULT_CODE_CLIENT);\n-            }\n-            throw f;\n-        }\n-    }\n-\n-    private void getBindingOperationForEmptyBody(Collection<OperationInfo> operations, Endpoint ep, Exchange exchange) {\n-        // TO DO : check duplicate operation with no input and also check if the action matches\n-        for (OperationInfo op : operations) {\n-            MessageInfo bmsg = op.getInput();\n-            int bPartsNum = bmsg.getMessagePartsNumber();\n-            if (bPartsNum == 0\n-                || (bPartsNum == 1\n-                    && Constants.XSD_ANYTYPE.equals(bmsg.getFirstMessagePart().getTypeQName()))) {\n-                BindingOperationInfo boi = ep.getEndpointInfo().getBinding().getOperation(op);\n-                exchange.put(BindingOperationInfo.class, boi);\n-                exchange.setOneWay(op.isOneWay());\n-            }\n-        }\n-    }\n-\n-    private BindingOperationInfo getBindingOperationInfo(DepthXMLStreamReader xmlReader, Exchange exchange,\n-                                                         BindingOperationInfo bop, boolean client) {\n-        //bop might be a unwrapped, wrap it back so that we can get correct info\n-        if (bop != null && bop.isUnwrapped()) {\n-            bop = bop.getWrappedOperation();\n-        }\n-\n-        if (bop == null) {\n-            QName startQName = xmlReader == null\n-                ? new QName(\"http://cxf.apache.org/jaxws/provider\", \"invoke\")\n-                : xmlReader.getName();\n-            bop = getBindingOperationInfo(exchange, startQName, client);\n-        }\n-        return bop;\n-    }\n-\n-    private void validatePart(MessagePartInfo p, QName elName, Message m) {\n-        if (p == null) {\n-            throw new Fault(new org.apache.cxf.common.i18n.Message(\"NO_PART_FOUND\", LOG, elName),\n-                            Fault.FAULT_CODE_CLIENT);\n-\n-        }\n-\n-        boolean synth = false;\n-        if (p.getMessageInfo() != null && p.getMessageInfo().getOperation() != null) {\n-            OperationInfo op = p.getMessageInfo().getOperation();\n-            Boolean b = (Boolean)op.getProperty(\"operation.is.synthetic\");\n-            if (b != null) {\n-                synth = b;\n-            }\n-        }\n-\n-        if (MessageUtils.getContextualBoolean(m, \"soap.no.validate.parts\", false)) {\n-            // something like a Provider service or similar that is forcing a\n-            // doc/lit/bare on an endpoint that may not really be doc/lit/bare.\n-            // we need to just let these through per spec so the endpoint\n-            // can process it\n-            synth = true;\n-        }\n-        if (synth) {\n-            return;\n-        }\n-        if (p.isElement()) {\n-            if (p.getConcreteName() != null\n-                && !elName.equals(p.getConcreteName())\n-                && !synth) {\n-                throw new Fault(\"UNEXPECTED_ELEMENT\", LOG, null, elName,\n-                                p.getConcreteName());\n-            }\n-        } else {\n-            if (!(elName.equals(p.getName()) || elName.equals(p.getConcreteName()))\n-                && !synth) {\n-                throw new Fault(\"UNEXPECTED_ELEMENT\", LOG, null, elName,\n-                                p.getConcreteName());\n-            }\n-        }\n-    }\n-\n-    private void getPara(DepthXMLStreamReader xmlReader,\n-                         DataReader<XMLStreamReader> dr,\n-                         MessageContentsList parameters,\n-                         Iterator<MessagePartInfo> itr,\n-                         Message message) {\n-\n-        boolean hasNext = true;\n-        while (itr.hasNext()) {\n-            MessagePartInfo part = itr.next();\n-            if (hasNext) {\n-                hasNext = StaxUtils.toNextElement(xmlReader);\n-            }\n-            Object obj = null;\n-            if (hasNext) {\n-                QName rname = xmlReader.getName();\n-                while (part != null\n-                    && !rname.equals(part.getConcreteName())) {\n-                    if (part.getXmlSchema() instanceof XmlSchemaElement) {\n-                        //TODO - should check minOccurs=0 and throw validation exception\n-                        //thing if the part needs to be here\n-                        parameters.put(part, null);\n-                    }\n-\n-                    if (itr.hasNext()) {\n-                        part = itr.next();\n-                    } else {\n-                        part = null;\n-                    }\n-                }\n-                if (part == null) {\n-                    return;\n-                }\n-                if (rname.equals(part.getConcreteName())) {\n-                    obj = dr.read(part, xmlReader);\n-                }\n-            }\n-            parameters.put(part, obj);\n-        }\n-    }\n-\n-\n-    private MessageInfo setMessage(Message message, BindingOperationInfo operation,\n-                                   boolean requestor, ServiceInfo si) {\n-        MessageInfo msgInfo = getMessageInfo(message, operation, requestor);\n-        return setMessage(message, operation, requestor, si, msgInfo);\n-    }\n-\n-\n-    protected BindingOperationInfo getBindingOperationInfo(Exchange exchange, QName name,\n-                                                           boolean client) {\n-        BindingOperationInfo bop = ServiceModelUtil.getOperationForWrapperElement(exchange, name, client);\n-        if (bop == null) {\n-            bop = super.getBindingOperationInfo(exchange, name, client);\n-        }\n-\n-        if (bop != null) {\n-            exchange.put(BindingOperationInfo.class, bop);\n-        }\n-        return bop;\n-    }\n-\n-    protected boolean shouldWrapParameters(MessageInfo msgInfo, Message message) {\n-        Object keepParametersWrapperFlag = message.get(KEEP_PARAMETERS_WRAPPER);\n-        if (keepParametersWrapperFlag == null) {\n-            return msgInfo.getFirstMessagePart().getTypeClass() != null;\n-        }\n-        return Boolean.parseBoolean(keepParametersWrapperFlag.toString());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3OTY4OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r533379689", "bodyText": "No Liberty change comments in this class. What did you change from the vanilla CXF version?", "author": "jhanders34", "createdAt": "2020-12-01T12:43:35Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/service/factory/ReflectionServiceFactoryBean.java", "diffHunk": "@@ -0,0 +1,2626 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.cxf.wsdl.service.factory;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.GenericArrayType;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Type;\n+import java.lang.reflect.TypeVariable;\n+import java.net.MalformedURLException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Executor;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.wsdl.Operation;\n+import javax.xml.bind.annotation.XmlAttachmentRef;\n+import javax.xml.bind.annotation.XmlElementWrapper;\n+import javax.xml.bind.annotation.XmlList;\n+import javax.xml.bind.annotation.XmlMimeType;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+import javax.xml.namespace.QName;\n+\n+import org.w3c.dom.DOMError;\n+import org.w3c.dom.DOMErrorHandler;\n+\n+import org.apache.cxf.BusException;\n+import org.apache.cxf.annotations.EvaluateAllEndpoints;\n+import org.apache.cxf.binding.BindingFactoryManager;\n+import org.apache.cxf.catalog.CatalogXmlSchemaURIResolver;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils;\n+import org.apache.cxf.common.i18n.Message;\n+import org.apache.cxf.common.logging.LogUtils;\n+import org.apache.cxf.common.util.StringUtils;\n+import org.apache.cxf.common.util.SystemPropertyAction;\n+import org.apache.cxf.common.xmlschema.SchemaCollection;\n+import org.apache.cxf.common.xmlschema.XmlSchemaUtils;\n+import org.apache.cxf.databinding.DataBinding;\n+import org.apache.cxf.databinding.source.mime.MimeAttribute;\n+import org.apache.cxf.databinding.source.mime.MimeSerializer;\n+import org.apache.cxf.endpoint.Endpoint;\n+import org.apache.cxf.endpoint.EndpointException;\n+import org.apache.cxf.endpoint.EndpointImpl;\n+import org.apache.cxf.endpoint.ServiceContractResolverRegistry;\n+import org.apache.cxf.feature.Feature;\n+import org.apache.cxf.helpers.CastUtils;\n+import org.apache.cxf.interceptor.Fault;\n+import org.apache.cxf.interceptor.FaultOutInterceptor;\n+import org.apache.cxf.message.Exchange;\n+import org.apache.cxf.resource.ResourceManager;\n+import org.apache.cxf.service.Service;\n+import org.apache.cxf.service.ServiceImpl;\n+import org.apache.cxf.service.ServiceModelSchemaValidator;\n+import org.apache.cxf.service.factory.FactoryBeanListener;\n+import org.apache.cxf.service.factory.FactoryBeanListener.Event;\n+import org.apache.cxf.service.factory.ServiceConstructionException;\n+import org.apache.cxf.service.factory.SimpleMethodDispatcher;\n+import org.apache.cxf.service.invoker.FactoryInvoker;\n+import org.apache.cxf.service.invoker.Invoker;\n+import org.apache.cxf.service.invoker.MethodDispatcher;\n+import org.apache.cxf.service.invoker.SingletonFactory;\n+import org.apache.cxf.service.model.AbstractMessageContainer;\n+import org.apache.cxf.service.model.BindingInfo;\n+import org.apache.cxf.service.model.BindingOperationInfo;\n+import org.apache.cxf.service.model.EndpointInfo;\n+import org.apache.cxf.service.model.FaultInfo;\n+import org.apache.cxf.service.model.InterfaceInfo;\n+import org.apache.cxf.service.model.MessageInfo;\n+import org.apache.cxf.service.model.MessagePartInfo;\n+import org.apache.cxf.service.model.OperationInfo;\n+import org.apache.cxf.service.model.SchemaInfo;\n+import org.apache.cxf.service.model.ServiceInfo;\n+import org.apache.cxf.service.model.UnwrappedOperationInfo;\n+import org.apache.cxf.wsdl.WSDLConstants;\n+import org.apache.cxf.wsdl11.WSDLServiceBuilder;\n+import org.apache.cxf.wsdl11.WSDLServiceFactory;\n+import org.apache.ws.commons.schema.XmlSchema;\n+import org.apache.ws.commons.schema.XmlSchemaComplexType;\n+import org.apache.ws.commons.schema.XmlSchemaElement;\n+import org.apache.ws.commons.schema.XmlSchemaExternal;\n+import org.apache.ws.commons.schema.XmlSchemaForm;\n+import org.apache.ws.commons.schema.XmlSchemaImport;\n+import org.apache.ws.commons.schema.XmlSchemaSequence;\n+import org.apache.ws.commons.schema.XmlSchemaType;\n+import org.apache.ws.commons.schema.constants.Constants;\n+import org.apache.ws.commons.schema.utils.NamespaceMap;\n+\n+\n+\n+/**\n+ * Introspects a class and builds a {@link Service} from it. If a WSDL URL is\n+ * specified, a Service model will be directly from the WSDL and then metadata\n+ * will be filled in from the service class. If no WSDL URL is specified, the\n+ * Service will be constructed directly from the class structure.\n+ */\n+//CHECKSTYLE:OFF:NCSS    -   This class is just huge and complex\n+public class ReflectionServiceFactoryBean extends org.apache.cxf.service.factory.AbstractServiceFactoryBean {", "originalCommit": "a6acc20fd1ba794ff76daa387c092f02af53f57d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQxOTQxOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535419418", "bodyText": "Removed this file", "author": "neuwerk", "createdAt": "2020-12-03T17:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM3OTY4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/service/factory/ReflectionServiceFactoryBean.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/service/factory/ReflectionServiceFactoryBean.java\ndeleted file mode 100644\nindex d68c6934b0..0000000000\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.wsdl.3.2/src/org/apache/cxf/wsdl/service/factory/ReflectionServiceFactoryBean.java\n+++ /dev/null\n\n@@ -1,2626 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package org.apache.cxf.wsdl.service.factory;\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Array;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.GenericArrayType;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.ParameterizedType;\n-import java.lang.reflect.Proxy;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.net.MalformedURLException;\n-import java.net.URI;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.Executor;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n-\n-import javax.wsdl.Operation;\n-import javax.xml.bind.annotation.XmlAttachmentRef;\n-import javax.xml.bind.annotation.XmlElementWrapper;\n-import javax.xml.bind.annotation.XmlList;\n-import javax.xml.bind.annotation.XmlMimeType;\n-import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n-import javax.xml.namespace.QName;\n-\n-import org.w3c.dom.DOMError;\n-import org.w3c.dom.DOMErrorHandler;\n-\n-import org.apache.cxf.BusException;\n-import org.apache.cxf.annotations.EvaluateAllEndpoints;\n-import org.apache.cxf.binding.BindingFactoryManager;\n-import org.apache.cxf.catalog.CatalogXmlSchemaURIResolver;\n-import org.apache.cxf.common.classloader.ClassLoaderUtils;\n-import org.apache.cxf.common.i18n.Message;\n-import org.apache.cxf.common.logging.LogUtils;\n-import org.apache.cxf.common.util.StringUtils;\n-import org.apache.cxf.common.util.SystemPropertyAction;\n-import org.apache.cxf.common.xmlschema.SchemaCollection;\n-import org.apache.cxf.common.xmlschema.XmlSchemaUtils;\n-import org.apache.cxf.databinding.DataBinding;\n-import org.apache.cxf.databinding.source.mime.MimeAttribute;\n-import org.apache.cxf.databinding.source.mime.MimeSerializer;\n-import org.apache.cxf.endpoint.Endpoint;\n-import org.apache.cxf.endpoint.EndpointException;\n-import org.apache.cxf.endpoint.EndpointImpl;\n-import org.apache.cxf.endpoint.ServiceContractResolverRegistry;\n-import org.apache.cxf.feature.Feature;\n-import org.apache.cxf.helpers.CastUtils;\n-import org.apache.cxf.interceptor.Fault;\n-import org.apache.cxf.interceptor.FaultOutInterceptor;\n-import org.apache.cxf.message.Exchange;\n-import org.apache.cxf.resource.ResourceManager;\n-import org.apache.cxf.service.Service;\n-import org.apache.cxf.service.ServiceImpl;\n-import org.apache.cxf.service.ServiceModelSchemaValidator;\n-import org.apache.cxf.service.factory.FactoryBeanListener;\n-import org.apache.cxf.service.factory.FactoryBeanListener.Event;\n-import org.apache.cxf.service.factory.ServiceConstructionException;\n-import org.apache.cxf.service.factory.SimpleMethodDispatcher;\n-import org.apache.cxf.service.invoker.FactoryInvoker;\n-import org.apache.cxf.service.invoker.Invoker;\n-import org.apache.cxf.service.invoker.MethodDispatcher;\n-import org.apache.cxf.service.invoker.SingletonFactory;\n-import org.apache.cxf.service.model.AbstractMessageContainer;\n-import org.apache.cxf.service.model.BindingInfo;\n-import org.apache.cxf.service.model.BindingOperationInfo;\n-import org.apache.cxf.service.model.EndpointInfo;\n-import org.apache.cxf.service.model.FaultInfo;\n-import org.apache.cxf.service.model.InterfaceInfo;\n-import org.apache.cxf.service.model.MessageInfo;\n-import org.apache.cxf.service.model.MessagePartInfo;\n-import org.apache.cxf.service.model.OperationInfo;\n-import org.apache.cxf.service.model.SchemaInfo;\n-import org.apache.cxf.service.model.ServiceInfo;\n-import org.apache.cxf.service.model.UnwrappedOperationInfo;\n-import org.apache.cxf.wsdl.WSDLConstants;\n-import org.apache.cxf.wsdl11.WSDLServiceBuilder;\n-import org.apache.cxf.wsdl11.WSDLServiceFactory;\n-import org.apache.ws.commons.schema.XmlSchema;\n-import org.apache.ws.commons.schema.XmlSchemaComplexType;\n-import org.apache.ws.commons.schema.XmlSchemaElement;\n-import org.apache.ws.commons.schema.XmlSchemaExternal;\n-import org.apache.ws.commons.schema.XmlSchemaForm;\n-import org.apache.ws.commons.schema.XmlSchemaImport;\n-import org.apache.ws.commons.schema.XmlSchemaSequence;\n-import org.apache.ws.commons.schema.XmlSchemaType;\n-import org.apache.ws.commons.schema.constants.Constants;\n-import org.apache.ws.commons.schema.utils.NamespaceMap;\n-\n-\n-\n-/**\n- * Introspects a class and builds a {@link Service} from it. If a WSDL URL is\n- * specified, a Service model will be directly from the WSDL and then metadata\n- * will be filled in from the service class. If no WSDL URL is specified, the\n- * Service will be constructed directly from the class structure.\n- */\n-//CHECKSTYLE:OFF:NCSS    -   This class is just huge and complex\n-public class ReflectionServiceFactoryBean extends org.apache.cxf.service.factory.AbstractServiceFactoryBean {\n-\n-    public static final String ENDPOINT_CLASS = \"endpoint.class\";\n-    public static final String GENERIC_TYPE = \"generic.type\";\n-    public static final String RAW_CLASS = \"rawclass\";\n-    public static final String WRAPPERGEN_NEEDED = \"wrapper.gen.needed\";\n-    public static final String EXTRA_CLASS = \"extra.class\";\n-    public static final String MODE_OUT = \"messagepart.mode.out\";\n-    public static final String MODE_INOUT = \"messagepart.mode.inout\";\n-    public static final String HOLDER = \"messagepart.isholder\";\n-    public static final String HEADER = \"messagepart.isheader\";\n-    public static final String ELEMENT_NAME = \"messagepart.elementName\";\n-    public static final String METHOD = \"operation.method\";\n-    public static final String FORCE_TYPES = \"operation.force.types\";\n-    public static final String METHOD_PARAM_ANNOTATIONS = \"method.parameters.annotations\";\n-    public static final String METHOD_ANNOTATIONS = \"method.return.annotations\";\n-    public static final String PARAM_ANNOTATION = \"parameter.annotations\";\n-    private static final Logger LOG = LogUtils.getL7dLogger(ReflectionServiceFactoryBean.class);\n-    private static final boolean DO_VALIDATE = SystemPropertyAction.getProperty(\"cxf.validateServiceSchemas\", \"false\")\n-            .equals(\"true\");\n-\n-    private static Class<? extends DataBinding> defaultDatabindingClass;\n-\n-    protected String wsdlURL;\n-\n-    protected Class<?> serviceClass;\n-    protected ParameterizedType serviceType;\n-    protected Map<Type, Map<String, Class<?>>> parameterizedTypes;\n-\n-    protected final Map<String, String> schemaLocationMapping = new HashMap<>();\n-\n-    private List<AbstractServiceConfiguration> serviceConfigurations =\n-        new ArrayList<>();\n-    private QName serviceName;\n-    private Invoker invoker;\n-    private Executor executor;\n-    private List<String> ignoredClasses = new ArrayList<>(Arrays.asList(\n-            \"java.lang.Object\",\n-            \"java.lang.Throwable\",\n-            \"org.omg.CORBA_2_3.portable.ObjectImpl\",\n-            \"org.omg.CORBA.portable.ObjectImpl\",\n-            \"javax.ejb.EJBObject\",\n-            \"javax.rmi.CORBA.Stub\"\n-        ));\n-    private List<Method> ignoredMethods = new ArrayList<>();\n-    private MethodDispatcher methodDispatcher = new SimpleMethodDispatcher();\n-    private Boolean wrappedStyle;\n-    private Map<String, Object> properties;\n-    private QName endpointName;\n-    private boolean populateFromClass;\n-    private boolean anonymousWrappers;\n-    private boolean qualifiedSchemas = true;\n-    private boolean validate;\n-\n-    private List<Feature> features;\n-\n-    private Map<Method, Boolean> wrappedCache = new HashMap<>();\n-    private Map<Method, Boolean> isRpcCache = new HashMap<>();\n-    private String styleCache;\n-    private Boolean defWrappedCache;\n-\n-    public ReflectionServiceFactoryBean() {\n-        getServiceConfigurations().add(0, new DefaultServiceConfiguration());\n-    }\n-\n-    protected DataBinding createDefaultDataBinding() {\n-        Object obj = null;\n-        Class<? extends DataBinding> cls = null;\n-\n-        if (getServiceClass() != null) {\n-            org.apache.cxf.annotations.DataBinding db\n-                = getServiceClass().getAnnotation(org.apache.cxf.annotations.DataBinding.class);\n-            if (db != null) {\n-                try {\n-                    if (!StringUtils.isEmpty(db.ref())) {\n-                        return getBus().getExtension(ResourceManager.class).resolveResource(db.ref(),\n-                                                                                            db.value());\n-                    }\n-                    cls = db.value();\n-                } catch (Exception e) {\n-                    LOG.log(Level.WARNING, \"Could not create databinding \"\n-                            + db.value().getName(), e);\n-                }\n-            }\n-        }\n-        if (cls == null && getBus() != null) {\n-            obj = getBus().getProperty(DataBinding.class.getName());\n-        }\n-        try {\n-            if (obj == null && cls == null) {\n-                cls = getJAXBClass();\n-            }\n-            if (obj instanceof String) {\n-                cls = ClassLoaderUtils.loadClass(obj.toString(), getClass(), DataBinding.class);\n-            } else if (obj instanceof Class) {\n-                cls = ((Class<?>)obj).asSubclass(DataBinding.class);\n-            }\n-            try {\n-                return cls.getConstructor(Boolean.TYPE, Map.class)\n-                    .newInstance(this.isQualifyWrapperSchema(), this.getProperties());\n-            } catch (NoSuchMethodException nsme) {\n-                //ignore, use the no-arg constructor\n-            }\n-            return cls.newInstance();\n-        } catch (Exception e) {\n-            throw new ServiceConstructionException(e);\n-        }\n-    }\n-    private static synchronized Class<? extends DataBinding> getJAXBClass() throws ClassNotFoundException {\n-        if (defaultDatabindingClass == null) {\n-            defaultDatabindingClass = ClassLoaderUtils.loadClass(\"org.apache.cxf.jaxb.JAXBDataBinding\",\n-                                                                 ReflectionServiceFactoryBean.class,\n-                                                                 DataBinding.class);\n-        }\n-        return defaultDatabindingClass;\n-    }\n-\n-\n-\n-    public void reset() {\n-        if (!dataBindingSet) {\n-            setDataBinding(null);\n-        }\n-        setService(null);\n-    }\n-\n-    @Override\n-    public synchronized Service create() {\n-        reset();\n-        sendEvent(Event.START_CREATE);\n-        initializeServiceConfigurations();\n-\n-        initializeServiceModel();\n-\n-        initializeDefaultInterceptors();\n-\n-        if (invoker != null) {\n-            getService().setInvoker(getInvoker());\n-        } else {\n-            getService().setInvoker(createInvoker());\n-        }\n-\n-        if (getExecutor() != null) {\n-            getService().setExecutor(getExecutor());\n-        }\n-        if (getDataBinding() != null) {\n-            getService().setDataBinding(getDataBinding());\n-        }\n-\n-        getService().put(MethodDispatcher.class.getName(), getMethodDispatcher());\n-        createEndpoints();\n-\n-        fillInSchemaCrossreferences();\n-\n-        Service serv = getService();\n-        sendEvent(Event.END_CREATE, serv);\n-        return serv;\n-    }\n-\n-\n-\n-\n-    /**\n-     * Code elsewhere in this function will fill in the name of the type of an\n-     * element but not the reference to the type. This function fills in the\n-     * type references. This does not set the type reference for elements that\n-     * are declared as refs to other elements. It is a giant pain to find them,\n-     * since they are not (generally) root elements and the code would have to\n-     * traverse all the types to find all of them. Users should look them up\n-     * through the collection, that's what it is for.\n-     */\n-    private void fillInSchemaCrossreferences() {\n-        Service service = getService();\n-        for (ServiceInfo serviceInfo : service.getServiceInfos()) {\n-            SchemaCollection schemaCollection = serviceInfo.getXmlSchemaCollection();\n-\n-            // First pass, fill in any types for which we have a name but no\n-            // type.\n-            for (SchemaInfo schemaInfo : serviceInfo.getSchemas()) {\n-                Map<QName, XmlSchemaElement> elementsTable = schemaInfo.getSchema().getElements();\n-                for (XmlSchemaElement element : elementsTable.values()) {\n-                    if (element.getSchemaType() == null) {\n-                        QName typeName = element.getSchemaTypeName();\n-                        if (typeName != null) {\n-                            XmlSchemaType type = schemaCollection.getTypeByQName(typeName);\n-                            if (type == null) {\n-                                Message message = new Message(\"REFERENCE_TO_UNDEFINED_TYPE\", LOG, element\n-                                    .getQName(), typeName, service.getName());\n-                                LOG.severe(message.toString());\n-                            } else {\n-                                element.setSchemaType(type);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-            }\n-        }\n-    }\n-\n-    protected void createEndpoints() {\n-        Service service = getService();\n-\n-        BindingFactoryManager bfm = getBus().getExtension(BindingFactoryManager.class);\n-\n-        for (ServiceInfo inf : service.getServiceInfos()) {\n-            for (EndpointInfo ei : inf.getEndpoints()) {\n-\n-                for (BindingOperationInfo boi : ei.getBinding().getOperations()) {\n-                    updateBindingOperation(boi);\n-                }\n-                try {\n-                    bfm.getBindingFactory(ei.getBinding().getBindingId());\n-                } catch (BusException e1) {\n-                    continue;\n-                }\n-\n-                try {\n-                    Endpoint ep = createEndpoint(ei);\n-\n-                    service.getEndpoints().put(ei.getName(), ep);\n-                } catch (EndpointException e) {\n-                    throw new ServiceConstructionException(e);\n-                }\n-            }\n-        }\n-    }\n-\n-    public void updateBindingOperation(BindingOperationInfo boi) {\n-        Method m = getMethodDispatcher().getMethod(boi);\n-        sendEvent(FactoryBeanListener.Event.BINDING_OPERATION_CREATED, boi.getBinding(), boi, m);\n-    }\n-\n-    public Endpoint createEndpoint(EndpointInfo ei) throws EndpointException {\n-        Endpoint ep = new EndpointImpl(getBus(), getService(), ei);\n-        sendEvent(Event.ENDPOINT_CREATED, ei, ep, getServiceClass());\n-        return ep;\n-    }\n-\n-    protected void initializeServiceConfigurations() {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            c.setServiceFactory(this);\n-        }\n-    }\n-\n-    protected void setServiceProperties() {\n-        MethodDispatcher md = getMethodDispatcher();\n-        getService().put(MethodDispatcher.class.getName(), md);\n-        for (Class<?> c : md.getClass().getInterfaces()) {\n-            getService().put(c.getName(), md);\n-        }\n-        if (properties != null) {\n-            getService().putAll(properties);\n-        }\n-    }\n-\n-    protected void buildServiceFromWSDL(String url) {\n-        sendEvent(Event.CREATE_FROM_WSDL, url);\n-\n-        if (LOG.isLoggable(Level.INFO)) {\n-            LOG.info(\"Creating Service \" + getServiceQName() + \" from WSDL: \" + url);\n-        }\n-        populateFromClass = false;\n-        WSDLServiceFactory factory = new WSDLServiceFactory(getBus(), url, getServiceQName());\n-        boolean setEPName = true;\n-        if (features != null) {\n-            for (Feature f : features) {\n-                if (f.getClass().isAnnotationPresent(EvaluateAllEndpoints.class)) {\n-                    setEPName = false;\n-                }\n-            }\n-        }\n-        if (setEPName) {\n-            // CXF will only evaluate this endpoint\n-            factory.setEndpointName(getEndpointName(false));\n-        }\n-        sendEvent(Event.WSDL_LOADED, factory.getDefinition());\n-        setService(factory.create());\n-        setServiceProperties();\n-\n-        sendEvent(Event.SERVICE_SET, getService());\n-\n-        EndpointInfo epInfo = getEndpointInfo();\n-        if (epInfo != null) {\n-            serviceConfigurations.add(new WSDLBasedServiceConfiguration(getEndpointInfo().getBinding()));\n-        }\n-\n-        initializeWSDLOperations();\n-\n-        Set<Class<?>> cls = getExtraClass();\n-        if (cls != null && !cls.isEmpty()) {\n-            for (ServiceInfo si : getService().getServiceInfos()) {\n-                si.setProperty(EXTRA_CLASS, cls);\n-            }\n-        }\n-        initializeDataBindings();\n-    }\n-\n-    protected void buildServiceFromClass() {\n-        Object o = getBus().getProperty(\"requireExplicitContractLocation\");\n-        if (o != null\n-            && (\"true\".equals(o) || Boolean.TRUE.equals(o))) {\n-            throw new ServiceConstructionException(new Message(\"NO_WSDL_PROVIDED\", LOG,\n-                                                               getServiceClass().getName()));\n-        }\n-        if (LOG.isLoggable(Level.INFO)) {\n-            LOG.info(\"Creating Service \" + getServiceQName() + \" from class \" + getServiceClass().getName());\n-        }\n-        populateFromClass = true;\n-\n-        if (Proxy.isProxyClass(this.getServiceClass())) {\n-            LOG.log(Level.WARNING, \"USING_PROXY_FOR_SERVICE\", getServiceClass());\n-        }\n-\n-        sendEvent(Event.CREATE_FROM_CLASS, getServiceClass());\n-\n-        ServiceInfo serviceInfo = new ServiceInfo();\n-        SchemaCollection col = serviceInfo.getXmlSchemaCollection();\n-        col.getXmlSchemaCollection().setSchemaResolver(new CatalogXmlSchemaURIResolver(this.getBus()));\n-        col.getExtReg().registerSerializer(MimeAttribute.class, new MimeSerializer());\n-\n-        ServiceImpl service = new ServiceImpl(serviceInfo);\n-        setService(service);\n-        setServiceProperties();\n-\n-        serviceInfo.setName(getServiceQName());\n-        serviceInfo.setTargetNamespace(serviceInfo.getName().getNamespaceURI());\n-\n-        sendEvent(Event.SERVICE_SET, getService());\n-\n-        createInterface(serviceInfo);\n-\n-\n-        Set<?> wrapperClasses = this.getExtraClass();\n-        for (ServiceInfo si : getService().getServiceInfos()) {\n-            if (wrapperClasses != null && !wrapperClasses.isEmpty()) {\n-                si.setProperty(EXTRA_CLASS, wrapperClasses);\n-            }\n-        }\n-        initializeDataBindings();\n-\n-        boolean isWrapped = isWrapped() || hasWrappedMethods(serviceInfo.getInterface());\n-        if (isWrapped) {\n-            initializeWrappedSchema(serviceInfo);\n-        }\n-\n-        for (OperationInfo opInfo : serviceInfo.getInterface().getOperations()) {\n-            Method m = (Method)opInfo.getProperty(METHOD);\n-            if (!isWrapped(m) && !isRPC(m) && opInfo.getInput() != null) {\n-                createBareMessage(serviceInfo, opInfo, false);\n-            }\n-\n-            if (!isWrapped(m) && !isRPC(m) && opInfo.getOutput() != null) {\n-                createBareMessage(serviceInfo, opInfo, true);\n-            }\n-\n-            if (opInfo.hasFaults()) {\n-                // check to make sure the faults are elements\n-                for (FaultInfo fault : opInfo.getFaults()) {\n-                    QName qn = (QName)fault.getProperty(\"elementName\");\n-                    MessagePartInfo part = fault.getFirstMessagePart();\n-                    if (!part.isElement()) {\n-                        part.setElement(true);\n-                        part.setElementQName(qn);\n-                        checkForElement(serviceInfo, part);\n-                    }\n-                }\n-            }\n-        }\n-        if (LOG.isLoggable(Level.FINE) || isValidate()) {\n-            ServiceModelSchemaValidator validator = new ServiceModelSchemaValidator(serviceInfo);\n-            validator.walk();\n-            String validationComplaints = validator.getComplaints();\n-            if (!\"\".equals(validationComplaints)) {\n-                if (isValidate()) {\n-                    LOG.warning(validationComplaints);\n-                } else {\n-                    LOG.fine(validationComplaints);\n-                }\n-            }\n-        }\n-    }\n-    public boolean hasWrappedMethods(InterfaceInfo interfaceInfo) {\n-        for (OperationInfo opInfo : interfaceInfo.getOperations()) {\n-            if (opInfo.isUnwrappedCapable()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    protected boolean isFromWsdl() {\n-        return !populateFromClass && !StringUtils.isEmpty(getWsdlURL());\n-    }\n-\n-    protected void initializeServiceModel() {\n-        if (isFromWsdl()) {\n-            buildServiceFromWSDL(getWsdlURL());\n-        } else if (getServiceClass() != null) {\n-            buildServiceFromClass();\n-        } else {\n-            throw new ServiceConstructionException(new Message(\"NO_WSDL_NO_SERVICE_CLASS_PROVIDED\", LOG, getWsdlURL()));\n-        }\n-\n-        if (isValidate()) {\n-            validateServiceModel();\n-        }\n-    }\n-\n-    public void validateServiceModel() {\n-\n-        for (ServiceInfo si : getService().getServiceInfos()) {\n-            validateSchemas(si.getXmlSchemaCollection());\n-\n-            for (OperationInfo opInfo : si.getInterface().getOperations()) {\n-                for (MessagePartInfo mpi : opInfo.getInput().getMessageParts()) {\n-                    assert mpi.getXmlSchema() != null;\n-                    if (mpi.isElement()) {\n-                        assert mpi.getXmlSchema() instanceof XmlSchemaElement;\n-                    } else {\n-                        assert !(mpi.getXmlSchema() instanceof XmlSchemaElement);\n-                    }\n-                }\n-                if (opInfo.hasOutput()) {\n-                    for (MessagePartInfo mpi : opInfo.getOutput().getMessageParts()) {\n-                        assert mpi.getXmlSchema() != null;\n-                        if (mpi.isElement()) {\n-                            assert mpi.getXmlSchema() instanceof XmlSchemaElement;\n-                        } else {\n-                            assert !(mpi.getXmlSchema() instanceof XmlSchemaElement);\n-                        }\n-                    }\n-                }\n-                if (opInfo.isUnwrappedCapable()) {\n-                    opInfo = opInfo.getUnwrappedOperation();\n-                    for (MessagePartInfo mpi : opInfo.getInput().getMessageParts()) {\n-                        assert mpi.getXmlSchema() != null;\n-                        if (mpi.isElement()) {\n-                            assert mpi.getXmlSchema() instanceof XmlSchemaElement;\n-                        } else {\n-                            assert !(mpi.getXmlSchema() instanceof XmlSchemaElement);\n-                        }\n-                    }\n-                    if (opInfo.hasOutput()) {\n-                        for (MessagePartInfo mpi : opInfo.getOutput().getMessageParts()) {\n-                            assert mpi.getXmlSchema() != null;\n-                            if (mpi.isElement()) {\n-                                assert mpi.getXmlSchema() instanceof XmlSchemaElement;\n-                            } else {\n-                                assert !(mpi.getXmlSchema() instanceof XmlSchemaElement);\n-                            }\n-                        }\n-                    }\n-                }\n-                if (opInfo.hasFaults()) {\n-                    // check to make sure the faults are elements\n-                    for (FaultInfo fault : opInfo.getFaults()) {\n-                        MessagePartInfo mpi = fault.getFirstMessagePart();\n-                        assert mpi != null;\n-                        assert mpi.getXmlSchema() != null;\n-                        assert mpi.isElement();\n-                        assert mpi.getXmlSchema() instanceof XmlSchemaElement;\n-                    }\n-                }\n-\n-            }\n-        }\n-    }\n-\n-    private void validateSchemas(SchemaCollection xmlSchemaCollection) {\n-        final StringBuilder errorBuilder = new StringBuilder();\n-        XercesXsdValidationImpl v = new XercesXsdValidationImpl();\n-        v.validateSchemas(xmlSchemaCollection.getXmlSchemaCollection(), new DOMErrorHandler() {\n-            public boolean handleError(DOMError error) {\n-                errorBuilder.append(error.getMessage());\n-                LOG.warning(error.getMessage());\n-                return true;\n-            }\n-        });\n-        if (errorBuilder.length() > 0) {\n-            throw new ServiceConstructionException(new Message(\"XSD_VALIDATION_ERROR\", LOG,\n-                                                               errorBuilder.toString()));\n-        }\n-    }\n-\n-    public boolean isPopulateFromClass() {\n-        return populateFromClass;\n-    }\n-\n-    public void setPopulateFromClass(boolean fomClass) {\n-        this.populateFromClass = fomClass;\n-    }\n-\n-    protected InterfaceInfo getInterfaceInfo() {\n-        if (getEndpointInfo() != null) {\n-            return getEndpointInfo().getInterface();\n-        }\n-        QName qn = this.getInterfaceName();\n-        for (ServiceInfo si : getService().getServiceInfos()) {\n-            if (qn.equals(si.getInterface().getName())) {\n-                return si.getInterface();\n-            }\n-        }\n-        throw new ServiceConstructionException(new Message(\"COULD_NOT_FIND_PORTTYPE\", LOG, qn));\n-    }\n-\n-    protected void initializeWSDLOperations() {\n-        List<OperationInfo> removes = new ArrayList<>();\n-        Method[] methods = serviceClass.getMethods();\n-        Arrays.sort(methods, new MethodComparator());\n-\n-        InterfaceInfo intf = getInterfaceInfo();\n-\n-        Map<QName, Method> validMethods = new HashMap<>();\n-        for (Method m : methods) {\n-            if (isValidMethod(m)) {\n-                QName opName = getOperationName(intf, m);\n-                validMethods.put(opName, m);\n-            }\n-        }\n-\n-        for (OperationInfo o : intf.getOperations()) {\n-            Method selected = null;\n-            for (Map.Entry<QName, Method> m : validMethods.entrySet()) {\n-                QName opName = m.getKey();\n-\n-                if (o.getName().getNamespaceURI().equals(opName.getNamespaceURI())\n-                    && isMatchOperation(o.getName().getLocalPart(), opName.getLocalPart())) {\n-                    selected = m.getValue();\n-                    break;\n-                }\n-            }\n-\n-            if (selected == null) {\n-                LOG.log(Level.WARNING, \"NO_METHOD_FOR_OP\", o.getName());\n-                removes.add(o);\n-            } else {\n-                initializeWSDLOperation(intf, o, selected);\n-            }\n-        }\n-        for (OperationInfo op : removes) {\n-            intf.removeOperation(op);\n-        }\n-\n-        // Some of the operations may have switched from unwrapped to wrapped.\n-        // Update the bindings.\n-        for (ServiceInfo service : getService().getServiceInfos()) {\n-            for (BindingInfo bi : service.getBindings()) {\n-                List<BindingOperationInfo> biremoves = new ArrayList<>();\n-                for (BindingOperationInfo binfo : bi.getOperations()) {\n-                    if (removes.contains(binfo.getOperationInfo())) {\n-                        biremoves.add(binfo);\n-                    } else {\n-                        binfo.updateUnwrappedOperation();\n-                    }\n-                }\n-                for (BindingOperationInfo binfo : biremoves) {\n-                    bi.removeOperation(binfo);\n-                }\n-            }\n-        }\n-        sendEvent(Event.INTERFACE_CREATED, intf, getServiceClass());\n-    }\n-\n-    protected void initializeWSDLOperation(InterfaceInfo intf, OperationInfo o, Method method) {\n-        // rpc out-message-part-info class mapping\n-        Operation op = (Operation)o.getProperty(WSDLServiceBuilder.WSDL_OPERATION);\n-\n-        if (initializeClassInfo(o, method, op == null ? null\n-            : CastUtils.cast(op.getParameterOrdering(), String.class))) {\n-            bindOperation(o, method);\n-            o.setProperty(ReflectionServiceFactoryBean.METHOD, method);\n-            sendEvent(Event.INTERFACE_OPERATION_BOUND, o, method);\n-        } else {\n-            LOG.log(Level.WARNING, \"NO_METHOD_FOR_OP\", o.getName());\n-        }\n-    }\n-\n-    /**\n-     * set the holder generic type info into message part info\n-     *\n-     * @param o\n-     * @param method\n-     */\n-    protected boolean initializeClassInfo(OperationInfo o, Method method, List<String> paramOrder) {\n-        OperationInfo origOp = o;\n-        if (isWrapped(method)) {\n-            if (o.getUnwrappedOperation() == null) {\n-                //the \"normal\" algorithm didn't allow for unwrapping,\n-                //but the annotations say unwrap this.   We'll need to\n-                //make it.\n-                WSDLServiceBuilder.checkForWrapped(o, true);\n-            }\n-            if (o.getUnwrappedOperation() != null) {\n-                if (o.hasInput()) {\n-                    MessageInfo input = o.getInput();\n-                    MessagePartInfo part = input.getFirstMessagePart();\n-                    part.setTypeClass(getRequestWrapper(method));\n-                    part.setProperty(\"REQUEST.WRAPPER.CLASSNAME\", getRequestWrapperClassName(method));\n-                    part.setIndex(0);\n-                }\n-\n-                if (o.hasOutput()) {\n-                    MessageInfo input = o.getOutput();\n-                    MessagePartInfo part = input.getFirstMessagePart();\n-                    part.setTypeClass(getResponseWrapper(method));\n-                    part.setProperty(\"RESPONSE.WRAPPER.CLASSNAME\", getResponseWrapperClassName(method));\n-                    part.setIndex(0);\n-                }\n-                setFaultClassInfo(o, method);\n-                o = o.getUnwrappedOperation();\n-            } else {\n-                LOG.warning(new Message(\"COULD_NOT_UNWRAP\", LOG, o.getName(), method).toString());\n-                setFaultClassInfo(o, method);\n-            }\n-        } else if (o.isUnwrappedCapable()) {\n-            // remove the unwrapped operation because it will break the\n-            // the WrapperClassOutInterceptor, and in general makes\n-            // life more confusing\n-            o.setUnwrappedOperation(null);\n-\n-            setFaultClassInfo(o, method);\n-        }\n-        o.setProperty(METHOD_PARAM_ANNOTATIONS, method.getParameterAnnotations());\n-        o.setProperty(METHOD_ANNOTATIONS, method.getAnnotations());\n-        //Set all out of band indexes to MAX_VALUE, anything left at MAX_VALUE after this is unmapped\n-        for (MessagePartInfo mpi : o.getInput().getOutOfBandParts()) {\n-            mpi.setIndex(Integer.MAX_VALUE);\n-        }\n-        if (o.hasOutput()) {\n-            for (MessagePartInfo mpi : o.getOutput().getOutOfBandParts()) {\n-                mpi.setIndex(Integer.MAX_VALUE);\n-            }\n-        }\n-        Class<?>[] paramTypes = method.getParameterTypes();\n-        Type[] genericTypes = method.getGenericParameterTypes();\n-        for (int i = 0; i < paramTypes.length; i++) {\n-            if (Exchange.class.equals(paramTypes[i])) {\n-                continue;\n-            }\n-            Class<?> paramType = paramTypes[i];\n-            Type genericType = genericTypes[i];\n-            if (!initializeParameter(o, method, i, paramType, genericType)) {\n-                return false;\n-            }\n-        }\n-        setIndexes(o.getInput());\n-        sendEvent(Event.OPERATIONINFO_IN_MESSAGE_SET, origOp, method, origOp.getInput());\n-        // Initialize return type\n-        if (o.hasOutput()\n-            && !initializeParameter(o, method, -1, method.getReturnType(), method.getGenericReturnType())) {\n-            return false;\n-        }\n-        if (o.hasOutput()) {\n-            setIndexes(o.getOutput());\n-        }\n-        if (origOp.hasOutput()) {\n-            sendEvent(Event.OPERATIONINFO_OUT_MESSAGE_SET, origOp, method, origOp.getOutput());\n-        }\n-\n-        setFaultClassInfo(o, method);\n-        return true;\n-    }\n-    private void setIndexes(MessageInfo m) {\n-        int max = -1;\n-        for (MessagePartInfo mpi : m.getMessageParts()) {\n-            if (mpi.getIndex() > max && mpi.getIndex() != Integer.MAX_VALUE) {\n-                max = mpi.getIndex();\n-            }\n-        }\n-        for (MessagePartInfo mpi : m.getMessageParts()) {\n-            if (mpi.getIndex() == Integer.MAX_VALUE) {\n-                max++;\n-                mpi.setIndex(max);\n-            }\n-        }\n-    }\n-    private boolean initializeParameter(OperationInfo o, Method method, int i,\n-                                     Class<?> paramType, Type genericType) {\n-        boolean isIn = isInParam(method, i);\n-        boolean isOut = isOutParam(method, i);\n-        boolean isHeader = isHeader(method, i);\n-        Annotation[] paraAnnos = null;\n-        if (i != -1 && o.getProperty(METHOD_PARAM_ANNOTATIONS) != null) {\n-            Annotation[][] anns = (Annotation[][])o.getProperty(METHOD_PARAM_ANNOTATIONS);\n-            paraAnnos = anns[i];\n-        } else if (i == -1 && o.getProperty(METHOD_ANNOTATIONS) != null) {\n-            paraAnnos = (Annotation[])o.getProperty(METHOD_ANNOTATIONS);\n-        }\n-\n-        MessagePartInfo part = null;\n-        if (isIn && !isOut) {\n-            QName name = getInPartName(o, method, i);\n-            part = o.getInput().getMessagePart(name);\n-            if (part == null && isFromWsdl()) {\n-                part = o.getInput().getMessagePartByIndex(i);\n-            }\n-            if (part == null && isHeader && o.isUnwrapped()) {\n-                part = ((UnwrappedOperationInfo)o).getWrappedOperation().getInput().getMessagePart(name);\n-                boolean add = true;\n-                if (part == null) {\n-                    QName name2 = this.getInParameterName(o, method, i);\n-                    part = o.getInput().getMessagePart(name2);\n-                    if (part != null) {\n-                        add = false;\n-                        name = name2;\n-                    }\n-                }\n-                if (part != null) {\n-                    //header part in wsdl, need to get this mapped in to the unwrapped form\n-                    if (paraAnnos != null) {\n-                        part.setProperty(PARAM_ANNOTATION, paraAnnos);\n-                    }\n-                    if (add) {\n-                        MessagePartInfo inf = o.getInput().addMessagePart(part.getName());\n-                        inf.setTypeQName(part.getTypeQName());\n-                        inf.setElement(part.isElement());\n-                        inf.setElementQName(part.getElementQName());\n-                        inf.setConcreteName(part.getConcreteName());\n-                        inf.setXmlSchema(part.getXmlSchema());\n-                        part = inf;\n-                        if (paraAnnos != null) {\n-                            part.setProperty(PARAM_ANNOTATION, paraAnnos);\n-                        }\n-                    }\n-                    part.setProperty(HEADER, Boolean.TRUE);\n-                }\n-            }\n-            if (part == null) {\n-                return false;\n-            }\n-            initializeParameter(part, paramType, genericType);\n-\n-            part.setIndex(i);\n-        } else if (!isIn && isOut) {\n-            QName name = getOutPartName(o, method, i);\n-            part = o.getOutput().getMessagePart(name);\n-            if (part == null && isFromWsdl()) {\n-                part = o.getOutput().getMessagePartByIndex(i + 1);\n-            }\n-            if (part == null) {\n-                return false;\n-            }\n-            part.setProperty(ReflectionServiceFactoryBean.MODE_OUT, Boolean.TRUE);\n-            initializeParameter(part, paramType, genericType);\n-            part.setIndex(i + 1);\n-        } else if (isIn && isOut) {\n-            QName name = getInPartName(o, method, i);\n-            part = o.getInput().getMessagePart(name);\n-            if (part == null && isHeader && o.isUnwrapped()) {\n-                QName name2 = this.getInParameterName(o, method, i);\n-                part = o.getInput().getMessagePart(name2);\n-                if (part != null) {\n-                    name = name2;\n-                }\n-            }\n-            if (part == null && this.isFromWsdl()) {\n-                part = o.getInput().getMessagePartByIndex(i);\n-            }\n-            if (part == null) {\n-                return false;\n-            }\n-            part.setProperty(ReflectionServiceFactoryBean.MODE_INOUT, Boolean.TRUE);\n-            initializeParameter(part, paramType, genericType);\n-            part.setIndex(i);\n-\n-            QName inName = part.getConcreteName();\n-            part = o.getOutput().getMessagePart(name);\n-\n-            if (part == null) {\n-                part = o.getOutput().getMessagePart(inName);\n-            }\n-            if (part == null && isHeader && o.isUnwrapped()) {\n-                part = o.getUnwrappedOperation().getOutput().getMessagePart(name);\n-                if (part == null) {\n-                    part = o.getUnwrappedOperation().getOutput().getMessagePart(inName);\n-                }\n-            }\n-\n-            if (part == null) {\n-                return false;\n-            }\n-            part.setProperty(ReflectionServiceFactoryBean.MODE_INOUT, Boolean.TRUE);\n-            initializeParameter(part, paramType, genericType);\n-            part.setIndex(i + 1);\n-        }\n-        if (paraAnnos != null && part != null) {\n-            part.setProperty(PARAM_ANNOTATION, paraAnnos);\n-        }\n-\n-        return true;\n-    }\n-    private void setFaultClassInfo(OperationInfo o, Method selected) {\n-        Class<?>[] types = selected.getExceptionTypes();\n-        Map<FaultInfo, List<MessagePartInfo>> mpiMap = null;\n-        if (types.length > 0) {\n-            //early iterate over FaultInfo before cycling on exception types\n-            //as fi.getMessageParts() is very time-consuming due to elements\n-            //copy in ArrayList constructor\n-            mpiMap = new HashMap<>();\n-            for (FaultInfo fi : o.getFaults()) {\n-                mpiMap.put(fi, fi.getMessageParts());\n-            }\n-        }\n-\n-        for (int i = 0; i < types.length; i++) {\n-            Class<?> exClass = types[i];\n-            Class<?> beanClass = getBeanClass(exClass);\n-            if (beanClass == null) {\n-                continue;\n-            }\n-\n-            QName name = getFaultName(o.getInterface(), o, exClass, beanClass);\n-\n-            for (Entry<FaultInfo, List<MessagePartInfo>> entry : mpiMap.entrySet()) {\n-                FaultInfo fi = entry.getKey();\n-                List<MessagePartInfo> mpis = entry.getValue();\n-                if (mpis.size() != 1) {\n-                    Message message = new Message(\"NO_FAULT_PART\", LOG, fi.getFaultName());\n-                    LOG.log(Level.WARNING, message.toString());\n-                }\n-                for (MessagePartInfo mpi : mpis) {\n-                    String ns = null;\n-                    if (mpi.isElement()) {\n-                        ns = mpi.getElementQName().getNamespaceURI();\n-                    } else {\n-                        ns = mpi.getTypeQName().getNamespaceURI();\n-                    }\n-                    if (mpi.getConcreteName().getLocalPart().equals(name.getLocalPart())\n-                        && name.getNamespaceURI().equals(ns)) {\n-                        fi.setProperty(Class.class.getName(), exClass);\n-                        mpi.setTypeClass(beanClass);\n-                        sendEvent(Event.OPERATIONINFO_FAULT, o, exClass, fi);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    protected Invoker createInvoker() {\n-        Class<?> cls = getServiceClass();\n-        if (cls.isInterface()) {\n-            return null;\n-        }\n-        return new FactoryInvoker(new SingletonFactory(getServiceClass()));\n-    }\n-\n-    protected ServiceInfo createServiceInfo(InterfaceInfo intf) {\n-        ServiceInfo svcInfo = new ServiceInfo();\n-        svcInfo.setInterface(intf);\n-\n-        return svcInfo;\n-    }\n-\n-    protected InterfaceInfo createInterface(ServiceInfo serviceInfo) {\n-        QName intfName = getInterfaceName();\n-        InterfaceInfo intf = new InterfaceInfo(serviceInfo, intfName);\n-\n-        Method[] methods = getServiceClass().getMethods();\n-\n-        // The BP profile states we can't have operations of the same name\n-        // so we have to append numbers to the name. Different JVMs sort methods\n-        // differently.\n-        // We need to keep them ordered so if we have overloaded methods, the\n-        // wsdl is generated the same every time across JVMs and across\n-        // client/servers.\n-        Arrays.sort(methods, new MethodComparator());\n-\n-        for (Method m : methods) {\n-            if (isValidMethod(m)) {\n-                createOperation(serviceInfo, intf, m);\n-            }\n-        }\n-        sendEvent(Event.INTERFACE_CREATED, intf, getServiceClass());\n-        return intf;\n-    }\n-\n-    protected OperationInfo createOperation(ServiceInfo serviceInfo, InterfaceInfo intf, Method m) {\n-        OperationInfo op = intf.addOperation(getOperationName(intf, m));\n-        op.setProperty(m.getClass().getName(), m);\n-        op.setProperty(\"action\", getAction(op, m));\n-        final Annotation[] annotations = m.getAnnotations();\n-        final Annotation[][] parAnnotations = m.getParameterAnnotations();\n-        op.setProperty(METHOD_ANNOTATIONS, annotations);\n-        op.setProperty(METHOD_PARAM_ANNOTATIONS, parAnnotations);\n-\n-        boolean isrpc = isRPC(m);\n-        if (!isrpc && isWrapped(m)) {\n-            UnwrappedOperationInfo uOp = new UnwrappedOperationInfo(op);\n-            uOp.setProperty(METHOD_ANNOTATIONS, annotations);\n-            uOp.setProperty(METHOD_PARAM_ANNOTATIONS, parAnnotations);\n-            op.setUnwrappedOperation(uOp);\n-\n-            createMessageParts(intf, uOp, m);\n-\n-            if (uOp.hasInput()) {\n-                MessageInfo msg = new MessageInfo(op, MessageInfo.Type.INPUT, uOp.getInput().getName());\n-                op.setInput(uOp.getInputName(), msg);\n-\n-                createInputWrappedMessageParts(uOp, m, msg);\n-\n-                for (MessagePartInfo p : uOp.getInput().getMessageParts()) {\n-                    p.setConcreteName(p.getName());\n-                }\n-            }\n-\n-            if (uOp.hasOutput()) {\n-\n-                QName name = uOp.getOutput().getName();\n-                MessageInfo msg = new MessageInfo(op, MessageInfo.Type.OUTPUT, name);\n-                op.setOutput(uOp.getOutputName(), msg);\n-\n-                createOutputWrappedMessageParts(uOp, m, msg);\n-\n-                for (MessagePartInfo p : uOp.getOutput().getMessageParts()) {\n-                    p.setConcreteName(p.getName());\n-                }\n-            }\n-        } else {\n-            if (isrpc) {\n-                op.setProperty(FORCE_TYPES, Boolean.TRUE);\n-            }\n-            createMessageParts(intf, op, m);\n-        }\n-\n-        bindOperation(op, m);\n-\n-        sendEvent(Event.INTERFACE_OPERATION_BOUND, op, m);\n-        return op;\n-    }\n-\n-    protected void bindOperation(OperationInfo op, Method m) {\n-        getMethodDispatcher().bind(op, m);\n-    }\n-\n-    protected void initializeWrappedSchema(ServiceInfo serviceInfo) {\n-        for (OperationInfo op : serviceInfo.getInterface().getOperations()) {\n-            if (op.getUnwrappedOperation() != null) {\n-                if (op.hasInput()) {\n-                    MessagePartInfo fmpi = op.getInput().getFirstMessagePart();\n-                    if (fmpi.getTypeClass() == null) {\n-\n-                        QName wrapperBeanName = fmpi.getElementQName();\n-                        XmlSchemaElement e = null;\n-                        for (SchemaInfo s : serviceInfo.getSchemas()) {\n-                            e = s.getElementByQName(wrapperBeanName);\n-                            if (e != null) {\n-                                fmpi.setXmlSchema(e);\n-                                break;\n-                            }\n-                        }\n-                        if (e == null) {\n-                            createWrappedSchema(serviceInfo, op.getInput(), op.getUnwrappedOperation()\n-                                .getInput(), wrapperBeanName);\n-                        }\n-                    }\n-\n-                    for (MessagePartInfo mpi : op.getInput().getMessageParts()) {\n-                        if (Boolean.TRUE.equals(mpi.getProperty(HEADER))) {\n-                            QName qn = (QName)mpi.getProperty(ELEMENT_NAME);\n-                            mpi.setElement(true);\n-                            mpi.setElementQName(qn);\n-\n-                            checkForElement(serviceInfo, mpi);\n-                        }\n-                    }\n-\n-                }\n-                if (op.hasOutput()) {\n-                    MessagePartInfo fmpi = op.getOutput().getFirstMessagePart();\n-                    if (fmpi.getTypeClass() == null) {\n-\n-                        QName wrapperBeanName = fmpi.getElementQName();\n-                        XmlSchemaElement e = null;\n-                        for (SchemaInfo s : serviceInfo.getSchemas()) {\n-                            e = s.getElementByQName(wrapperBeanName);\n-                            if (e != null) {\n-                                break;\n-                            }\n-                        }\n-                        if (e == null) {\n-                            createWrappedSchema(serviceInfo, op.getOutput(), op.getUnwrappedOperation()\n-                                .getOutput(), wrapperBeanName);\n-                        }\n-                    }\n-                    for (MessagePartInfo mpi : op.getOutput().getMessageParts()) {\n-                        if (Boolean.TRUE.equals(mpi.getProperty(HEADER))) {\n-                            QName qn = (QName)mpi.getProperty(ELEMENT_NAME);\n-                            mpi.setElement(true);\n-                            mpi.setElementQName(qn);\n-\n-                            checkForElement(serviceInfo, mpi);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    protected void checkForElement(ServiceInfo serviceInfo, MessagePartInfo mpi) {\n-        SchemaInfo si = getOrCreateSchema(serviceInfo, mpi.getElementQName().getNamespaceURI(),\n-                                          getQualifyWrapperSchema());\n-        XmlSchemaElement e = si.getSchema().getElementByName(mpi.getElementQName().getLocalPart());\n-        if (e != null) {\n-            mpi.setXmlSchema(e);\n-            return;\n-        }\n-        XmlSchema schema = si.getSchema();\n-        si.setElement(null); //cached element is now invalid\n-\n-        XmlSchemaElement el = new XmlSchemaElement(schema, true);\n-        el.setName(mpi.getElementQName().getLocalPart());\n-        el.setNillable(true);\n-\n-        XmlSchemaType tp = (XmlSchemaType)mpi.getXmlSchema();\n-        if (tp == null) {\n-            throw new ServiceConstructionException(new Message(\"INTRACTABLE_PART\", LOG,\n-                                                               mpi.getName(),\n-                                                               mpi.getMessageInfo().getName()));\n-        }\n-        el.setSchemaTypeName(tp.getQName());\n-        mpi.setXmlSchema(el);\n-    }\n-\n-    public boolean getAnonymousWrapperTypes() {\n-        return anonymousWrappers;\n-    }\n-\n-    public boolean isAnonymousWrapperTypes() {\n-        return anonymousWrappers;\n-    }\n-\n-    public void setAnonymousWrapperTypes(boolean b) {\n-        anonymousWrappers = b;\n-    }\n-\n-    public final boolean getQualifyWrapperSchema() {\n-        return qualifiedSchemas;\n-    }\n-\n-    public boolean isQualifyWrapperSchema() {\n-        return qualifiedSchemas;\n-    }\n-\n-    public void setQualifyWrapperSchema(boolean b) {\n-        qualifiedSchemas = b;\n-    }\n-\n-    protected void createWrappedSchema(ServiceInfo serviceInfo, AbstractMessageContainer wrappedMessage,\n-                                       AbstractMessageContainer unwrappedMessage, QName wrapperBeanName) {\n-        SchemaInfo schemaInfo = getOrCreateSchema(serviceInfo, wrapperBeanName.getNamespaceURI(),\n-                                                  getQualifyWrapperSchema());\n-\n-        createWrappedMessageSchema(serviceInfo, wrappedMessage, unwrappedMessage, schemaInfo,\n-                                   wrapperBeanName);\n-    }\n-\n-    protected void createBareMessage(ServiceInfo serviceInfo, OperationInfo opInfo, boolean isOut) {\n-\n-        MessageInfo message = isOut ? opInfo.getOutput() : opInfo.getInput();\n-\n-        final List<MessagePartInfo> messageParts = message.getMessageParts();\n-        if (messageParts.isEmpty()) {\n-            return;\n-        }\n-\n-        Method method = (Method)opInfo.getProperty(METHOD);\n-        int paraNumber = 0;\n-        for (MessagePartInfo mpi : messageParts) {\n-            SchemaInfo schemaInfo = null;\n-            XmlSchema schema = null;\n-\n-            QName qname = (QName)mpi.getProperty(ELEMENT_NAME);\n-            if (messageParts.size() == 1 && qname == null) {\n-                qname = !isOut ? getInParameterName(opInfo, method, -1)\n-                        : getOutParameterName(opInfo, method, -1);\n-\n-                if (qname.getLocalPart().startsWith(\"arg\") || qname.getLocalPart().startsWith(\"return\")) {\n-                    qname = isOut\n-                        ? new QName(qname.getNamespaceURI(), method.getName() + \"Response\") : new QName(qname\n-                            .getNamespaceURI(), method.getName());\n-                }\n-            } else if (isOut && messageParts.size() > 1 && qname == null) {\n-                while (!isOutParam(method, paraNumber)) {\n-                    paraNumber++;\n-                }\n-                qname = getOutParameterName(opInfo, method, paraNumber);\n-            } else if (qname == null) {\n-                qname = getInParameterName(opInfo, method, paraNumber);\n-            }\n-\n-            for (SchemaInfo s : serviceInfo.getSchemas()) {\n-                if (s.getNamespaceURI().equals(qname.getNamespaceURI())) {\n-                    schemaInfo = s;\n-                    break;\n-                }\n-            }\n-\n-            if (schemaInfo == null) {\n-                schemaInfo = getOrCreateSchema(serviceInfo, qname.getNamespaceURI(), true);\n-                schema = schemaInfo.getSchema();\n-            } else {\n-                schema = schemaInfo.getSchema();\n-                if (schema != null && schema.getElementByName(qname) != null) {\n-                    mpi.setElement(true);\n-                    mpi.setElementQName(qname);\n-                    mpi.setXmlSchema(schema.getElementByName(qname));\n-                    paraNumber++;\n-                    continue;\n-                }\n-            }\n-\n-            schemaInfo.setElement(null); //cached element is now invalid\n-            XmlSchemaElement el = new XmlSchemaElement(schema, true);\n-            el.setName(qname.getLocalPart());\n-            el.setNillable(true);\n-\n-            if (mpi.isElement()) {\n-                XmlSchemaElement oldEl = (XmlSchemaElement)mpi.getXmlSchema();\n-                if (null != oldEl && !oldEl.getQName().equals(qname)) {\n-                    el.setSchemaTypeName(oldEl.getSchemaTypeName());\n-                    el.setSchemaType(oldEl.getSchemaType());\n-                    if (oldEl.getSchemaTypeName() != null) {\n-                        addImport(schema, oldEl.getSchemaTypeName().getNamespaceURI());\n-                    }\n-                }\n-                mpi.setElement(true);\n-                mpi.setXmlSchema(el);\n-                mpi.setElementQName(qname);\n-                mpi.setConcreteName(qname);\n-                continue;\n-            }\n-            if (null == mpi.getTypeQName() && mpi.getXmlSchema() == null) {\n-                throw new ServiceConstructionException(new Message(\"UNMAPPABLE_PORT_TYPE\", LOG,\n-                                                                   method.getDeclaringClass().getName(),\n-                                                                   method.getName(),\n-                                                                   mpi.getName()));\n-            }\n-            if (mpi.getTypeQName() != null) {\n-                el.setSchemaTypeName(mpi.getTypeQName());\n-            } else {\n-                el.setSchemaType((XmlSchemaType)mpi.getXmlSchema());\n-            }\n-            mpi.setXmlSchema(el);\n-            mpi.setConcreteName(qname);\n-            if (mpi.getTypeQName() != null) {\n-                addImport(schema, mpi.getTypeQName().getNamespaceURI());\n-            }\n-\n-            mpi.setElement(true);\n-            mpi.setElementQName(qname);\n-            paraNumber++;\n-        }\n-    }\n-\n-    private void addImport(XmlSchema schema, String ns) {\n-        if (!ns.equals(schema.getTargetNamespace())\n-            && !ns.equals(WSDLConstants.NS_SCHEMA_XSD)\n-            && !isExistImport(schema, ns)) {\n-            XmlSchemaImport is = new XmlSchemaImport(schema);\n-            is.setNamespace(ns);\n-            if (this.schemaLocationMapping.get(ns) != null) {\n-                is.setSchemaLocation(this.schemaLocationMapping.get(ns));\n-            }\n-            if (!schema.getItems().contains(is)) {\n-                schema.getItems().add(is);\n-            }\n-        }\n-    }\n-\n-    private boolean isExistImport(XmlSchema schema, String ns) {\n-        boolean isExist = false;\n-\n-        for (XmlSchemaExternal ext : schema.getExternals()) {\n-            if (ext instanceof XmlSchemaImport) {\n-                XmlSchemaImport xsImport = (XmlSchemaImport)ext;\n-                if (xsImport.getNamespace().equals(ns)) {\n-                    isExist = true;\n-                    break;\n-                }\n-            }\n-        }\n-        return isExist;\n-\n-    }\n-\n-    private XmlSchemaElement getExistingSchemaElement(XmlSchema schema, QName qn) {\n-        return schema.getElements().get(qn);\n-    }\n-\n-    private boolean isExistSchemaElement(XmlSchema schema, QName qn) {\n-        return getExistingSchemaElement(schema, qn) != null;\n-    }\n-\n-    private void createWrappedMessageSchema(ServiceInfo serviceInfo, AbstractMessageContainer wrappedMessage,\n-                                            AbstractMessageContainer unwrappedMessage, SchemaInfo info,\n-                                            QName wrapperName) {\n-\n-        XmlSchema schema = info.getSchema();\n-        info.setElement(null); // the cached schema will be no good\n-        XmlSchemaElement el = new XmlSchemaElement(schema, true);\n-        el.setName(wrapperName.getLocalPart());\n-\n-        wrappedMessage.getFirstMessagePart().setXmlSchema(el);\n-\n-        boolean anonymousType = isAnonymousWrapperTypes();\n-        XmlSchemaComplexType ct = new XmlSchemaComplexType(schema,\n-                /*CXF-6783: don't create anonymous top-level types*/!anonymousType);\n-\n-        if (!anonymousType) {\n-            ct.setName(wrapperName.getLocalPart());\n-            el.setSchemaTypeName(wrapperName);\n-        }\n-        el.setSchemaType(ct);\n-\n-        XmlSchemaSequence seq = new XmlSchemaSequence();\n-        ct.setParticle(seq);\n-\n-        for (MessagePartInfo mpi : unwrappedMessage.getMessageParts()) {\n-            el = new XmlSchemaElement(schema, Boolean.TRUE.equals(mpi.getProperty(HEADER)));\n-            Map<Class<?>, Boolean> jaxbAnnoMap = getJaxbAnnoMap(mpi);\n-            if (mpi.isElement()) {\n-                addImport(schema, mpi.getElementQName().getNamespaceURI());\n-                XmlSchemaUtils.setElementRefName(el, mpi.getElementQName());\n-            } else {\n-                // We hope that we can't have parts that different only in namespace.\n-                el.setName(mpi.getName().getLocalPart());\n-                if (mpi.getTypeQName() != null && !jaxbAnnoMap.containsKey(XmlList.class)) {\n-                    el.setSchemaTypeName(mpi.getTypeQName());\n-                    addImport(schema, mpi.getTypeQName().getNamespaceURI());\n-                }\n-\n-                el.setSchemaType((XmlSchemaType)mpi.getXmlSchema());\n-\n-                if (schema.getElementFormDefault().equals(XmlSchemaForm.UNQUALIFIED)) {\n-                    mpi.setConcreteName(new QName(null, mpi.getName().getLocalPart()));\n-                } else {\n-                    mpi.setConcreteName(mpi.getName());\n-                }\n-            }\n-            if (!Boolean.TRUE.equals(mpi.getProperty(HEADER))) {\n-                boolean wasType = !mpi.isElement();\n-                if (wasType) {\n-                    QName concreteName = mpi.getConcreteName();\n-                    mpi.setElement(true);\n-                    mpi.setElementQName(el.getQName());\n-                    mpi.setConcreteName(concreteName);\n-                }\n-\n-                addMimeType(el, getMethodParameterAnnotations(mpi));\n-                Annotation[] methodAnnotations = getMethodAnnotations(mpi);\n-                if (methodAnnotations != null) {\n-                    addMimeType(el, methodAnnotations);\n-                }\n-\n-                long min = getWrapperPartMinOccurs(mpi);\n-                long max = getWrapperPartMaxOccurs(mpi);\n-                boolean nillable = isWrapperPartNillable(mpi);\n-                Boolean qualified = isWrapperPartQualified(mpi);\n-                if (qualified == null) {\n-                    qualified = this.isQualifyWrapperSchema();\n-                }\n-                if (qualified\n-                    && StringUtils.isEmpty(mpi.getConcreteName().getNamespaceURI())) {\n-                    QName newName = new QName(wrapperName.getNamespaceURI(),\n-                                              mpi.getConcreteName().getLocalPart());\n-                    mpi.setElement(true);\n-                    mpi.setElementQName(newName);\n-                    mpi.setConcreteName(newName);\n-                    el.setName(newName.getLocalPart());\n-                    el.setForm(XmlSchemaForm.QUALIFIED);\n-                }\n-\n-                if (Collection.class.isAssignableFrom(mpi.getTypeClass())\n-                           && mpi.getTypeClass().isInterface()) {\n-                    Type type = (Type)mpi.getProperty(GENERIC_TYPE);\n-\n-                    if (!(type instanceof java.lang.reflect.ParameterizedType)\n-                        && el.getSchemaTypeName() == null && el.getSchemaType() == null) {\n-                        max = Long.MAX_VALUE;\n-                        el.setSchemaTypeName(Constants.XSD_ANYTYPE);\n-                    }\n-                }\n-                el.setMinOccurs(min);\n-                el.setMaxOccurs(max);\n-                if (nillable) {\n-                    el.setNillable(nillable);\n-                }\n-                seq.getItems().add(el);\n-                mpi.setXmlSchema(el);\n-            }\n-            if (Boolean.TRUE.equals(mpi.getProperty(HEADER))) {\n-                QName qn = (QName)mpi.getProperty(ELEMENT_NAME);\n-                el.setName(qn.getLocalPart());\n-\n-                SchemaInfo headerSchemaInfo = getOrCreateSchema(serviceInfo, qn.getNamespaceURI(),\n-                                                                getQualifyWrapperSchema());\n-                if (!isExistSchemaElement(headerSchemaInfo.getSchema(), qn)) {\n-                    headerSchemaInfo.getSchema().getItems().add(el);\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    private Annotation[] getMethodParameterAnnotations(final MessagePartInfo mpi) {\n-        Annotation[][] paramAnno = (Annotation[][])mpi.getProperty(METHOD_PARAM_ANNOTATIONS);\n-        int index = mpi.getIndex();\n-        if (paramAnno != null && index < paramAnno.length && index >= 0) {\n-            return paramAnno[index];\n-        }\n-        return null;\n-    }\n-\n-    private Annotation[] getMethodAnnotations(final MessagePartInfo mpi) {\n-        return (Annotation[])mpi.getProperty(METHOD_ANNOTATIONS);\n-    }\n-\n-    private void addMimeType(final XmlSchemaElement element, final Annotation[] annotations) {\n-        if (annotations != null) {\n-            for (Annotation annotation : annotations) {\n-                if (annotation instanceof XmlMimeType) {\n-                    MimeAttribute attr = new MimeAttribute();\n-                    attr.setValue(((XmlMimeType)annotation).value());\n-                    element.addMetaInfo(MimeAttribute.MIME_QNAME, attr);\n-                }\n-            }\n-        }\n-    }\n-\n-    private Map<Class<?>, Boolean> getJaxbAnnoMap(MessagePartInfo mpi) {\n-        Map<Class<?>, Boolean> map = new ConcurrentHashMap<>(4, 0.75f, 1);\n-        Annotation[] anns = getMethodParameterAnnotations(mpi);\n-\n-        if (anns != null) {\n-            for (Annotation anno : anns) {\n-                if (anno instanceof XmlList) {\n-                    map.put(XmlList.class, true);\n-                }\n-                if (anno instanceof XmlAttachmentRef) {\n-                    map.put(XmlAttachmentRef.class, true);\n-                }\n-                if (anno instanceof XmlJavaTypeAdapter) {\n-                    map.put(XmlJavaTypeAdapter.class, true);\n-                }\n-                if (anno instanceof XmlElementWrapper) {\n-                    map.put(XmlElementWrapper.class, true);\n-                }\n-            }\n-        }\n-        return map;\n-    }\n-\n-    private SchemaInfo getOrCreateSchema(ServiceInfo serviceInfo, String namespaceURI, boolean qualified) {\n-        for (SchemaInfo s : serviceInfo.getSchemas()) {\n-            if (s.getNamespaceURI().equals(namespaceURI)) {\n-                return s;\n-            }\n-        }\n-\n-        SchemaInfo schemaInfo = new SchemaInfo(namespaceURI);\n-        SchemaCollection col = serviceInfo.getXmlSchemaCollection();\n-        XmlSchema schema = col.getSchemaByTargetNamespace(namespaceURI);\n-\n-        if (schema != null) {\n-            schemaInfo.setSchema(schema);\n-            serviceInfo.addSchema(schemaInfo);\n-            return schemaInfo;\n-        }\n-\n-        schema = col.newXmlSchemaInCollection(namespaceURI);\n-        if (qualified) {\n-            schema.setElementFormDefault(XmlSchemaForm.QUALIFIED);\n-        }\n-        schemaInfo.setSchema(schema);\n-\n-        Map<String, String> explicitNamespaceMappings = this.getDataBinding().getDeclaredNamespaceMappings();\n-        if (explicitNamespaceMappings == null) {\n-            explicitNamespaceMappings = Collections.emptyMap();\n-        }\n-        NamespaceMap nsMap = new NamespaceMap();\n-        for (Map.Entry<String, String> mapping : explicitNamespaceMappings.entrySet()) {\n-            nsMap.add(mapping.getValue(), mapping.getKey());\n-        }\n-\n-        if (!explicitNamespaceMappings.containsKey(WSDLConstants.NS_SCHEMA_XSD)) {\n-            nsMap.add(WSDLConstants.NP_SCHEMA_XSD, WSDLConstants.NS_SCHEMA_XSD);\n-        }\n-        if (!explicitNamespaceMappings.containsKey(serviceInfo.getTargetNamespace())) {\n-            nsMap.add(WSDLConstants.CONVENTIONAL_TNS_PREFIX, serviceInfo.getTargetNamespace());\n-        }\n-        schema.setNamespaceContext(nsMap);\n-        serviceInfo.addSchema(schemaInfo);\n-        return schemaInfo;\n-    }\n-    // CHECKSTYLE:OFF\n-    protected void createMessageParts(InterfaceInfo intf, OperationInfo op, Method method) {\n-        final Class<?>[] paramClasses = method.getParameterTypes();\n-        // Setup the input message\n-        op.setProperty(METHOD, method);\n-        MessageInfo inMsg = op.createMessage(this.getInputMessageName(op, method), MessageInfo.Type.INPUT);\n-        op.setInput(inMsg.getName().getLocalPart(), inMsg);\n-        final Annotation[][] parAnnotations = method.getParameterAnnotations();\n-        final Type[] genParTypes = method.getGenericParameterTypes();\n-        for (int j = 0; j < paramClasses.length; j++) {\n-            if (Exchange.class.equals(paramClasses[j])) {\n-                continue;\n-            }\n-            if (isInParam(method, j)) {\n-                QName q = getInParameterName(op, method, j);\n-                QName partName = getInPartName(op, method, j);\n-                if (!isRPC(method) && !isWrapped(method)\n-                    && inMsg.getMessagePartsMap().containsKey(partName)) {\n-                    LOG.log(Level.WARNING, \"INVALID_BARE_METHOD\", getServiceClass() + \".\" + method.getName());\n-                    partName = new QName(partName.getNamespaceURI(), partName.getLocalPart() + j);\n-                    q = new QName(q.getNamespaceURI(), q.getLocalPart() + j);\n-                }\n-                MessagePartInfo part = inMsg.addMessagePart(partName);\n-\n-                if (isHolder(paramClasses[j], genParTypes[j]) && !isInOutParam(method, j)) {\n-                    LOG.log(Level.WARNING, \"INVALID_WEBPARAM_MODE\", getServiceClass().getName() + \".\"\n-                                                                    + method.getName());\n-                }\n-                initializeParameter(part, paramClasses[j], genParTypes[j]);\n-                part.setProperty(METHOD_PARAM_ANNOTATIONS, parAnnotations);\n-                part.setProperty(PARAM_ANNOTATION, parAnnotations[j]);\n-                if (!getJaxbAnnoMap(part).isEmpty()) {\n-                    op.setProperty(WRAPPERGEN_NEEDED, true);\n-                }\n-                if (!isWrapped(method) && !isRPC(method)) {\n-                    part.setProperty(ELEMENT_NAME, q);\n-                }\n-\n-                if (isHeader(method, j)) {\n-                    part.setProperty(HEADER, Boolean.TRUE);\n-                    if (isRPC(method) || !isWrapped(method)) {\n-                        part.setElementQName(q);\n-                    } else {\n-                        part.setProperty(ELEMENT_NAME, q);\n-                    }\n-                }\n-                part.setIndex(j);\n-            }\n-        }\n-        sendEvent(Event.OPERATIONINFO_IN_MESSAGE_SET, op, method, inMsg);\n-\n-        boolean hasOut = hasOutMessage(method);\n-        if (hasOut) {\n-            // Setup the output message\n-            MessageInfo outMsg = op.createMessage(createOutputMessageName(op, method),\n-                                                  MessageInfo.Type.OUTPUT);\n-            op.setOutput(outMsg.getName().getLocalPart(), outMsg);\n-            final Class<?> returnType = method.getReturnType();\n-            if (!returnType.isAssignableFrom(void.class)) {\n-                final QName q = getOutPartName(op, method, -1);\n-                final QName q2 = getOutParameterName(op, method, -1);\n-                MessagePartInfo part = outMsg.addMessagePart(q);\n-                initializeParameter(part, method.getReturnType(), method.getGenericReturnType());\n-                if (!isRPC(method) && !isWrapped(method)) {\n-                    part.setProperty(ELEMENT_NAME, q2);\n-                }\n-                final Annotation[] annotations = method.getAnnotations();\n-                part.setProperty(METHOD_ANNOTATIONS, annotations);\n-                part.setProperty(PARAM_ANNOTATION, annotations);\n-                if (isHeader(method, -1)) {\n-                    part.setProperty(HEADER, Boolean.TRUE);\n-                    if (isRPC(method) || !isWrapped(method)) {\n-                        part.setElementQName(q2);\n-                    } else {\n-                        part.setProperty(ELEMENT_NAME, q2);\n-                    }\n-                }\n-\n-                part.setIndex(0);\n-            }\n-\n-            for (int j = 0; j < paramClasses.length; j++) {\n-                if (Exchange.class.equals(paramClasses[j])) {\n-                    continue;\n-                }\n-                if (isOutParam(method, j)) {\n-                    if (outMsg == null) {\n-                        outMsg = op.createMessage(createOutputMessageName(op, method),\n-                                                  MessageInfo.Type.OUTPUT);\n-                    }\n-                    QName q = getOutPartName(op, method, j);\n-                    QName q2 = getOutParameterName(op, method, j);\n-\n-                    if (isInParam(method, j)) {\n-                        MessagePartInfo mpi = op.getInput().getMessagePartByIndex(j);\n-                        q = mpi.getName();\n-                        q2 = (QName)mpi.getProperty(ELEMENT_NAME);\n-                        if (q2 == null) {\n-                            q2 = mpi.getElementQName();\n-                        }\n-                    }\n-\n-                    MessagePartInfo part = outMsg.addMessagePart(q);\n-                    part.setProperty(METHOD_PARAM_ANNOTATIONS, parAnnotations);\n-                    part.setProperty(PARAM_ANNOTATION, parAnnotations[j]);\n-                    initializeParameter(part, paramClasses[j], genParTypes[j]);\n-                    part.setIndex(j + 1);\n-\n-                    if (!isRPC(method) && !isWrapped(method)) {\n-                        part.setProperty(ELEMENT_NAME, q2);\n-                    }\n-\n-                    if (isInParam(method, j)) {\n-                        part.setProperty(MODE_INOUT, Boolean.TRUE);\n-                    }\n-                    if (isHeader(method, j)) {\n-                        part.setProperty(HEADER, Boolean.TRUE);\n-                        if (isRPC(method) || !isWrapped(method)) {\n-                            part.setElementQName(q2);\n-                        } else {\n-                            part.setProperty(ELEMENT_NAME, q2);\n-                        }\n-                    }\n-                }\n-            }\n-            sendEvent(Event.OPERATIONINFO_OUT_MESSAGE_SET, op, method, outMsg);\n-        }\n-\n-        //setting the parameterOrder that\n-        //allows preservation of method signatures\n-        //when doing java->wsdl->java\n-        setParameterOrder(method, paramClasses, op);\n-\n-        if (hasOut) {\n-            // Faults are only valid if not a one-way operation\n-            initializeFaults(intf, op, method);\n-        }\n-    }\n-\n-    private void setParameterOrder(Method method, Class<?>[] paramClasses, OperationInfo op) {\n-        if (isRPC(method) || !isWrapped(method)) {\n-            List<String> paramOrdering = new LinkedList<>();\n-            boolean hasOut = false;\n-            for (int j = 0; j < paramClasses.length; j++) {\n-                if (Exchange.class.equals(paramClasses[j])) {\n-                    continue;\n-                }\n-                if (isInParam(method, j)) {\n-                    paramOrdering.add(getInPartName(op, method, j).getLocalPart());\n-                    if (isOutParam(method, j)) {\n-                        hasOut = true;\n-                    }\n-                } else if (isOutParam(method, j)) {\n-                    hasOut = true;\n-                    paramOrdering.add(getOutPartName(op, method, j).getLocalPart());\n-                }\n-            }\n-            if (!paramOrdering.isEmpty() && hasOut) {\n-                op.setParameterOrdering(paramOrdering);\n-            }\n-        }\n-    }\n-\n-\n-    protected void createInputWrappedMessageParts(OperationInfo op, Method method, MessageInfo inMsg) {\n-        String partName = null;\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            partName = c.getRequestWrapperPartName(op, method);\n-            if (partName != null) {\n-                break;\n-            }\n-        }\n-        if (partName == null) {\n-            partName = \"parameters\";\n-        }\n-        MessagePartInfo part = inMsg.addMessagePart(partName);\n-        part.setElement(true);\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getRequestWrapperName(op, method);\n-            if (q != null) {\n-                part.setElementQName(q);\n-            }\n-        }\n-        if (part.getElementQName() == null) {\n-            part.setElementQName(inMsg.getName());\n-        } else if (!part.getElementQName().equals(op.getInput().getName())) {\n-            op.getInput().setName(part.getElementQName());\n-        }\n-        if (getRequestWrapper(method) != null) {\n-            part.setTypeClass(this.getRequestWrapper(method));\n-        } else if (getRequestWrapperClassName(method) != null) {\n-            part.setProperty(\"REQUEST.WRAPPER.CLASSNAME\", getRequestWrapperClassName(method));\n-        }\n-\n-        int partIdx = 0;\n-        int maxIdx = 0;\n-        for (MessagePartInfo mpart : op.getInput().getMessageParts()) {\n-            if (Boolean.TRUE.equals(mpart.getProperty(HEADER))) {\n-                int idx = mpart.getIndex();\n-                inMsg.addMessagePart(mpart);\n-                mpart.setIndex(idx);\n-\n-                //make sure the header part and the wrapper part don't share the\n-                //same index.   We can move the wrapper part around a bit\n-                //if need be\n-                if (maxIdx < idx) {\n-                    maxIdx = idx;\n-                }\n-                if (idx == partIdx) {\n-                    maxIdx++;\n-                    partIdx = maxIdx;\n-                }\n-            }\n-        }\n-        part.setIndex(partIdx);\n-\n-    }\n-\n-    protected void createOutputWrappedMessageParts(OperationInfo op, Method method, MessageInfo outMsg) {\n-        String partName = null;\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            partName = c.getResponseWrapperPartName(op, method);\n-            if (partName != null) {\n-                break;\n-            }\n-        }\n-        for (MessagePartInfo mpart : op.getOutput().getMessageParts()) {\n-            if (Boolean.TRUE.equals(mpart.getProperty(HEADER))) {\n-                partName = \"result\";\n-                break;\n-            }\n-        }\n-\n-        if (partName == null) {\n-            partName = \"parameters\";\n-        }\n-\n-        MessagePartInfo part = outMsg.addMessagePart(partName);\n-        part.setElement(true);\n-        part.setIndex(0);\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getResponseWrapperName(op, method);\n-            if (q != null) {\n-                part.setElementQName(q);\n-                break;\n-            }\n-        }\n-\n-        if (part.getElementQName() == null) {\n-            part.setElementQName(outMsg.getName());\n-        } else if (!part.getElementQName().equals(op.getOutput().getName())) {\n-            op.getOutput().setName(part.getElementQName());\n-        }\n-\n-        if (this.getResponseWrapper(method) != null) {\n-            part.setTypeClass(this.getResponseWrapper(method));\n-        } else if (getResponseWrapperClassName(method) != null) {\n-            part.setProperty(\"RESPONSE.WRAPPER.CLASSNAME\", getResponseWrapperClassName(method));\n-        }\n-\n-        for (MessagePartInfo mpart : op.getOutput().getMessageParts()) {\n-            if (Boolean.TRUE.equals(mpart.getProperty(HEADER))) {\n-                int idx = mpart.getIndex();\n-                outMsg.addMessagePart(mpart);\n-                mpart.setIndex(idx);\n-            }\n-        }\n-    }\n-\n-    private static Class<?> createArrayClass(GenericArrayType atp) {\n-        Type tp = atp.getGenericComponentType();\n-        Class<?> rawClass = null;\n-        if (tp instanceof Class) {\n-            rawClass = (Class<?>)tp;\n-        } else if (tp instanceof GenericArrayType) {\n-            rawClass = createArrayClass((GenericArrayType)tp);\n-        } else if (tp instanceof ParameterizedType) {\n-            rawClass = (Class<?>)((ParameterizedType)tp).getRawType();\n-            if (List.class.isAssignableFrom(rawClass)) {\n-                rawClass = getClass(tp);\n-                rawClass = Array.newInstance(rawClass, 0).getClass();\n-            }\n-        }\n-        return Array.newInstance(rawClass, 0).getClass();\n-    }\n-\n-    private static Class<?> getClass(Type paramType) {\n-        Class<?> rawClass = null;\n-        if (paramType instanceof Class) {\n-            rawClass = (Class<?>)paramType;\n-        } else if (paramType instanceof GenericArrayType) {\n-            rawClass = createArrayClass((GenericArrayType)paramType);\n-        } else if (paramType instanceof ParameterizedType) {\n-            rawClass = (Class<?>)((ParameterizedType)paramType).getRawType();\n-        }\n-        return rawClass;\n-    }\n-\n-\n-    protected void initializeParameter(MessagePartInfo part, Class<?> rawClass, Type type) {\n-        if (isHolder(rawClass, type)) {\n-            Type c = getHolderType(rawClass, type);\n-            if (c != null) {\n-                type = c;\n-                rawClass = getClass(type);\n-            }\n-        }\n-        if (type instanceof TypeVariable) {\n-            if (parameterizedTypes == null) {\n-                processParameterizedTypes();\n-            }\n-            TypeVariable<?> var = (TypeVariable<?>)type;\n-            final Object gd = var.getGenericDeclaration();\n-            Map<String, Class<?>> mp = parameterizedTypes.get(gd);\n-            if (mp != null) {\n-                Class<?> c = parameterizedTypes.get(gd).get(var.getName());\n-                if (c != null) {\n-                    rawClass = c;\n-                    type = c;\n-                    part.getMessageInfo().setProperty(\"parameterized\", Boolean.TRUE);\n-                }\n-            }\n-        }\n-        part.setProperty(GENERIC_TYPE, type);\n-        // if rawClass is List<String>, it will be converted to array\n-        // and set it to type class\n-        if (Collection.class.isAssignableFrom(rawClass)) {\n-            part.setProperty(RAW_CLASS, rawClass);\n-        }\n-        part.setTypeClass(rawClass);\n-\n-        if (part.getMessageInfo().getOperation().isUnwrapped()\n-            && Boolean.TRUE.equals(part.getProperty(HEADER))) {\n-            //header from the unwrapped operation, make sure the type is set for the\n-            //approriate header in the wrapped operation\n-            OperationInfo o = ((UnwrappedOperationInfo)part.getMessageInfo().getOperation())\n-                .getWrappedOperation();\n-\n-            if (Boolean.TRUE.equals(part.getProperty(ReflectionServiceFactoryBean.MODE_OUT))\n-                || Boolean.TRUE.equals(part.getProperty(ReflectionServiceFactoryBean.MODE_INOUT))) {\n-                MessagePartInfo mpi = o.getOutput().getMessagePart(part.getName());\n-                if (mpi != null) {\n-                    mpi.setTypeClass(rawClass);\n-                    mpi.setProperty(GENERIC_TYPE, type);\n-                    if (Collection.class.isAssignableFrom(rawClass)) {\n-                        mpi.setProperty(RAW_CLASS, type);\n-                    }\n-                }\n-            }\n-            if (!Boolean.TRUE.equals(part.getProperty(ReflectionServiceFactoryBean.MODE_OUT))) {\n-                MessagePartInfo mpi = o.getInput().getMessagePart(part.getName());\n-                if (mpi != null) {\n-                    mpi.setTypeClass(rawClass);\n-                    mpi.setProperty(GENERIC_TYPE, type);\n-                    if (Collection.class.isAssignableFrom(rawClass)) {\n-                        mpi.setProperty(RAW_CLASS, type);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-\n-    public QName getServiceQName() {\n-        return getServiceQName(true);\n-    }\n-    public QName getServiceQName(boolean lookup) {\n-        if (serviceName == null && lookup) {\n-            serviceName = new QName(getServiceNamespace(), getServiceName());\n-        }\n-\n-        return serviceName;\n-    }\n-\n-    public QName getEndpointName() {\n-        return getEndpointName(true);\n-    }\n-    public QName getEndpointName(boolean lookup) {\n-        if (endpointName != null || !lookup) {\n-            return endpointName;\n-        }\n-\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName name = c.getEndpointName();\n-            if (name != null) {\n-                endpointName = name;\n-                return name;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    public EndpointInfo getEndpointInfo() {\n-        return getService().getEndpointInfo(getEndpointName());\n-    }\n-\n-    public void setEndpointName(QName en) {\n-        this.endpointName = en;\n-    }\n-\n-    protected String getServiceName() {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            String name = c.getServiceName();\n-            if (name != null) {\n-                return name;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected String getServiceNamespace() {\n-        if (serviceName != null) {\n-            return serviceName.getNamespaceURI();\n-        }\n-\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            String name = c.getServiceNamespace();\n-            if (name != null) {\n-                return name;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    public QName getInterfaceName() {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName name = c.getInterfaceName();\n-            if (name != null) {\n-                return name;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected boolean isValidMethod(final Method method) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isOperation(method);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    public boolean isHolder(Class<?> cls, Type type) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isHolder(cls, type);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public Type getHolderType(Class<?> cls, Type type) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Type b = c.getHolderType(cls, type);\n-            if (b != null) {\n-                return b;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected boolean isWrapped(final Method method) {\n-        Boolean b = wrappedCache.get(method);\n-        if (b == null) {\n-            if (isRPC(method)) {\n-                wrappedCache.put(method, Boolean.FALSE);\n-                return false;\n-            }\n-\n-            for (AbstractServiceConfiguration c : serviceConfigurations) {\n-                b = c.isWrapped(method);\n-                if (b != null) {\n-                    wrappedCache.put(method, b);\n-                    return b.booleanValue();\n-                }\n-            }\n-\n-            wrappedCache.put(method, Boolean.TRUE);\n-            return true;\n-        }\n-        return b;\n-    }\n-\n-    protected boolean isMatchOperation(String methodNameInClass, String methodNameInWsdl) {\n-        // checks to make sure the operation names match ignoring the case of the first character\n-        boolean ret = false;\n-        String initOfMethodInClass = methodNameInClass.substring(0, 1);\n-        String initOfMethodInWsdl = methodNameInWsdl.substring(0, 1);\n-        if (initOfMethodInClass.equalsIgnoreCase(initOfMethodInWsdl)\n-            && methodNameInClass.substring(1, methodNameInClass.length())\n-                .equals(methodNameInWsdl.substring(1, methodNameInWsdl.length()))) {\n-            ret = true;\n-        }\n-        return ret;\n-    }\n-\n-    protected boolean isOutParam(Method method, int j) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isOutParam(method, j);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    protected boolean isInParam(Method method, int j) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isInParam(method, j);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    protected boolean isInOutParam(Method method, int j) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isInOutParam(method, j);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    protected QName getInputMessageName(final OperationInfo op, final Method method) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getInputMessageName(op, method);\n-            if (q != null) {\n-                return q;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected QName createOutputMessageName(final OperationInfo op, final Method method) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getOutputMessageName(op, method);\n-            if (q != null) {\n-                return q;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected boolean hasOutMessage(Method m) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.hasOutMessage(m);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    protected void initializeFaults(final InterfaceInfo service,\n-                                    final OperationInfo op, final Method method) {\n-        // Set up the fault messages\n-        final Class<?>[] exceptionClasses = method.getExceptionTypes();\n-        for (int i = 0; i < exceptionClasses.length; i++) {\n-            Class<?> exClazz = exceptionClasses[i];\n-\n-            // Ignore XFireFaults because they don't need to be declared\n-            if (Fault.class.isAssignableFrom(exClazz)\n-                || exClazz.equals(RuntimeException.class) || exClazz.equals(Throwable.class)) {\n-                continue;\n-            }\n-\n-            addFault(service, op, exClazz);\n-        }\n-    }\n-\n-    protected void initializeDefaultInterceptors() {\n-        super.initializeDefaultInterceptors();\n-\n-        initializeFaultInterceptors();\n-    }\n-\n-    protected void initializeFaultInterceptors() {\n-        getService().getOutFaultInterceptors().add(new FaultOutInterceptor());\n-    }\n-\n-    protected FaultInfo addFault(final InterfaceInfo service, final OperationInfo op,\n-                                 Class<?> exClass) {\n-        Class<?> beanClass = getBeanClass(exClass);\n-        if (beanClass == null) {\n-            return null;\n-        }\n-        String faultMsgName = null;\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            faultMsgName = c.getFaultMessageName(op, exClass, beanClass);\n-            if (faultMsgName != null) {\n-                break;\n-            }\n-        }\n-        if (faultMsgName == null) {\n-            faultMsgName = exClass.getSimpleName();\n-        }\n-\n-        QName faultName = getFaultName(service, op, exClass, beanClass);\n-        FaultInfo fi = op.addFault(new QName(op.getName().getNamespaceURI(), faultMsgName),\n-                                   new QName(op.getName().getNamespaceURI(), faultMsgName));\n-        fi.setProperty(Class.class.getName(), exClass);\n-        fi.setProperty(\"elementName\", faultName);\n-        MessagePartInfo mpi = fi.addMessagePart(new QName(faultName.getNamespaceURI(),\n-                                                          exClass.getSimpleName()));\n-        mpi.setElementQName(faultName);\n-        mpi.setTypeClass(beanClass);\n-        sendEvent(Event.OPERATIONINFO_FAULT, op, exClass, fi);\n-        return fi;\n-    }\n-\n-    protected void createFaultForException(Class<?> exClass, FaultInfo fi) {\n-        Field[] fields = exClass.getDeclaredFields();\n-        for (Field field : fields) {\n-            MessagePartInfo mpi = fi\n-                .addMessagePart(new QName(fi.getName().getNamespaceURI(), field.getName()));\n-            mpi.setProperty(Class.class.getName(), field.getType());\n-        }\n-\n-        MessagePartInfo mpi = fi.addMessagePart(new QName(fi.getName().getNamespaceURI(), \"message\"));\n-        mpi.setProperty(Class.class.getName(), String.class);\n-    }\n-\n-    protected Class<?> getBeanClass(Class<?> exClass) {\n-        if (java.rmi.RemoteException.class.isAssignableFrom(exClass)) {\n-            return null;\n-        }\n-\n-        if (FaultOutInterceptor.FaultInfoException.class.isAssignableFrom(exClass)) {\n-            try {\n-                Method m = exClass.getMethod(\"getFaultInfo\");\n-                return m.getReturnType();\n-            } catch (SecurityException | NoSuchMethodException e) {\n-                throw new ServiceConstructionException(e);\n-            }\n-        }\n-\n-        return exClass;\n-    }\n-\n-    protected QName getFaultName(InterfaceInfo service, OperationInfo o,\n-                                 Class<?> exClass, Class<?> beanClass) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getFaultName(service, o, exClass, beanClass);\n-            if (q != null) {\n-                return q;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected String getAction(OperationInfo op, Method method) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            String s = c.getAction(op, method);\n-            if (s != null) {\n-                return s;\n-            }\n-        }\n-        return \"\";\n-    }\n-\n-    public boolean isHeader(Method method, int j) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isHeader(method, j);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /**\n-     * Creates a name for the operation from the method name. If an operation\n-     * with that name already exists, a name is create by appending an integer\n-     * to the end. I.e. if there is already two methods named\n-     * <code>doSomething</code>, the first one will have an operation name of\n-     * \"doSomething\" and the second \"doSomething1\".\n-     *\n-     * @param service\n-     * @param method\n-     */\n-    protected QName getOperationName(InterfaceInfo service, Method method) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName s = c.getOperationName(service, method);\n-            if (s != null) {\n-                return s;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected boolean isAsync(final Method method) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isAsync(method);\n-            if (b != null) {\n-                return b.booleanValue();\n-            }\n-        }\n-        return true;\n-    }\n-\n-    protected QName getInPartName(final OperationInfo op, final Method method, final int paramNumber) {\n-        if (paramNumber == -1) {\n-            return null;\n-        }\n-\n-        if (isWrapped(method) && !isHeader(method, paramNumber)) {\n-            return getInParameterName(op, method, paramNumber);\n-        }\n-\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getInPartName(op, method, paramNumber);\n-            if (q != null) {\n-                return q;\n-            }\n-\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected QName getInParameterName(final OperationInfo op, final Method method, final int paramNumber) {\n-        if (paramNumber == -1) {\n-            return null;\n-        }\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getInParameterName(op, method, paramNumber);\n-            if (q != null) {\n-                return q;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected QName getOutParameterName(final OperationInfo op, final Method method, final int paramNumber) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getOutParameterName(op, method, paramNumber);\n-            if (q != null) {\n-                return q;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected QName getOutPartName(final OperationInfo op, final Method method, final int paramNumber) {\n-        if (isWrapped(method)) {\n-            return getOutParameterName(op, method, paramNumber);\n-        }\n-\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            QName q = c.getOutPartName(op, method, paramNumber);\n-            if (q != null) {\n-                return q;\n-            }\n-        }\n-        throw new IllegalStateException(\"ServiceConfiguration must provide a value!\");\n-    }\n-\n-    protected Class<?> getResponseWrapper(Method selected) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Class<?> cls = c.getResponseWrapper(selected);\n-            if (cls != null) {\n-                return cls;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected String getResponseWrapperClassName(Method selected) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            String cls = c.getResponseWrapperClassName(selected);\n-            if (cls != null) {\n-                return cls;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected Class<?> getRequestWrapper(Method selected) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Class<?> cls = c.getRequestWrapper(selected);\n-            if (cls != null) {\n-                return cls;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    protected String getRequestWrapperClassName(Method selected) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            String cls = c.getRequestWrapperClassName(selected);\n-            if (cls != null) {\n-                return cls;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public Boolean isWrapperPartQualified(MessagePartInfo mpi) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isWrapperPartQualified(mpi);\n-            if (b != null) {\n-                return b;\n-            }\n-        }\n-        return null;\n-    }\n-    public boolean isWrapperPartNillable(MessagePartInfo mpi) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Boolean b = c.isWrapperPartNillable(mpi);\n-            if (b != null) {\n-                return b;\n-            }\n-        }\n-        return false;\n-    }\n-    public long getWrapperPartMaxOccurs(MessagePartInfo mpi) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Long b = c.getWrapperPartMaxOccurs(mpi);\n-            if (b != null) {\n-                return b;\n-            }\n-        }\n-        return 1;\n-    }\n-    public long getWrapperPartMinOccurs(MessagePartInfo mpi) {\n-        for (AbstractServiceConfiguration c : serviceConfigurations) {\n-            Long b = c.getWrapperPartMinOccurs(mpi);\n-            if (b != null) {\n-                return b;\n-            }\n-        }\n-        return 1;\n-    }\n-\n-    public MethodDispatcher getMethodDispatcher() {\n-        return methodDispatcher;\n-    }\n-    protected void setMethodDispatcher(MethodDispatcher m) {\n-        methodDispatcher = m;\n-    }\n-\n-    public List<AbstractServiceConfiguration> getConfigurations() {\n-        return serviceConfigurations;\n-    }\n-\n-    public void setConfigurations(List<AbstractServiceConfiguration> configurations) {\n-        this.serviceConfigurations = configurations;\n-    }\n-\n-    public Class<?> getServiceClass() {\n-        return serviceClass;\n-    }\n-    private void processParameterizedTypes() {\n-        parameterizedTypes = new HashMap<>();\n-        if (serviceClass.isInterface()) {\n-            processTypes(serviceClass, serviceType);\n-        } else {\n-            final Class<?>[] interfaces = serviceClass.getInterfaces();\n-            final Type[] genericInterfaces = serviceClass.getGenericInterfaces();\n-            for (int x = 0; x < interfaces.length; x++) {\n-                processTypes(interfaces[x], genericInterfaces[x]);\n-            }\n-            processTypes(serviceClass.getSuperclass(), serviceClass.getGenericSuperclass());\n-        }\n-    }\n-    protected void processTypes(Class<?> sc, Type tp) {\n-        if (tp instanceof ParameterizedType) {\n-            ParameterizedType ptp = (ParameterizedType)tp;\n-            Type c = ptp.getRawType();\n-            Map<String, Class<?>> m = new HashMap<>();\n-            parameterizedTypes.put(c, m);\n-            final Type[] ptpActualTypeArgs = ptp.getActualTypeArguments();\n-            final TypeVariable<?>[] scTypeArgs = sc.getTypeParameters();\n-            for (int x = 0; x < ptpActualTypeArgs.length; x++) {\n-                Type t = ptpActualTypeArgs[x];\n-                TypeVariable<?> tv = scTypeArgs[x];\n-                if (t instanceof Class) {\n-                    m.put(tv.getName(), (Class<?>)t);\n-                }\n-            }\n-        }\n-    }\n-    public void setServiceType(ParameterizedType servicetype) {\n-        serviceType = servicetype;\n-    }\n-    public void setServiceClass(Class<?> serviceClass) {\n-        this.serviceClass = serviceClass;\n-        checkServiceClassAnnotations(serviceClass);\n-    }\n-    protected void checkServiceClassAnnotations(Class<?> sc) {\n-        Annotation[] anns = serviceClass.getAnnotations();\n-        if (anns != null) {\n-            for (Annotation ann : anns) {\n-                String pkg = ann.annotationType().getPackage().getName();\n-                if (\"javax.xml.ws\".equals(pkg)\n-                    || \"javax.jws\".equals(pkg)) {\n-\n-                    LOG.log(Level.WARNING, \"JAXWS_ANNOTATION_FOUND\", serviceClass.getName());\n-                    return;\n-                }\n-            }\n-        }\n-        for (Method m : serviceClass.getMethods()) {\n-            anns = m.getAnnotations();\n-            if (anns != null) {\n-                for (Annotation ann : anns) {\n-                    String pkg = ann.annotationType().getPackage().getName();\n-                    if (\"javax.xml.ws\".equals(pkg)\n-                        || \"javax.jws\".equals(pkg)) {\n-\n-                        LOG.log(Level.WARNING, \"JAXWS_ANNOTATION_FOUND\", serviceClass.getName());\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public String getWsdlURL() {\n-        if (wsdlURL == null) {\n-            for (AbstractServiceConfiguration c : serviceConfigurations) {\n-                wsdlURL = c.getWsdlURL();\n-                if (wsdlURL != null) {\n-                    break;\n-                }\n-            }\n-            if (null == wsdlURL && getBus() != null) {\n-                ServiceContractResolverRegistry registry = getBus()\n-                    .getExtension(ServiceContractResolverRegistry.class);\n-                if (null != registry) {\n-                    URI uri = registry.getContractLocation(this.getServiceQName());\n-                    if (null != uri) {\n-                        try {\n-                            wsdlURL = uri.toURL().toString();\n-                        } catch (MalformedURLException e) {\n-                            LOG.log(Level.FINE, \"resolve qname failed\", this.getServiceQName());\n-                        }\n-                    }\n-                }\n-            }\n-            if (wsdlURL != null) {\n-                // create a unique string so if its an interned string (like\n-                // from an annotation), caches will clear\n-                wsdlURL = new String(wsdlURL);\n-            }\n-        }\n-\n-        return wsdlURL;\n-    }\n-\n-    public void setWsdlURL(String wsdlURL) {\n-        // create a unique string so if its an interned string (like\n-        // from an annotation), caches will clear\n-        this.wsdlURL = new String(wsdlURL);\n-    }\n-\n-    public void setWsdlURL(URL wsdlURL) {\n-        setWsdlURL(wsdlURL.toString());\n-    }\n-\n-    public List<AbstractServiceConfiguration> getServiceConfigurations() {\n-        return serviceConfigurations;\n-    }\n-\n-    public void setServiceConfigurations(List<AbstractServiceConfiguration> serviceConfigurations) {\n-        this.serviceConfigurations = serviceConfigurations;\n-    }\n-\n-    public void setServiceName(QName serviceName) {\n-        this.serviceName = serviceName;\n-    }\n-\n-    public Invoker getInvoker() {\n-        return invoker;\n-    }\n-\n-    public void setInvoker(Invoker invoker) {\n-        this.invoker = invoker;\n-    }\n-\n-    public Executor getExecutor() {\n-        return executor;\n-    }\n-\n-    public void setExecutor(Executor executor) {\n-        this.executor = executor;\n-    }\n-\n-    public List<String> getIgnoredClasses() {\n-        return ignoredClasses;\n-    }\n-\n-    public void setIgnoredClasses(List<String> ignoredClasses) {\n-        this.ignoredClasses = ignoredClasses;\n-    }\n-\n-    protected Set<Class<?>> getExtraClass() {\n-        return null;\n-    }\n-\n-    public boolean isWrapped() {\n-        if (this.wrappedStyle != null) {\n-            defWrappedCache = wrappedStyle;\n-        }\n-        if (this.defWrappedCache == null) {\n-            for (AbstractServiceConfiguration c : serviceConfigurations) {\n-                defWrappedCache = c.isWrapped();\n-                if (defWrappedCache != null) {\n-                    return defWrappedCache;\n-                }\n-            }\n-            defWrappedCache = Boolean.TRUE;\n-        }\n-        return defWrappedCache;\n-    }\n-\n-    public String getStyle() {\n-        if (styleCache == null) {\n-            for (AbstractServiceConfiguration c : serviceConfigurations) {\n-                styleCache = c.getStyle();\n-                if (styleCache != null) {\n-                    return styleCache;\n-                }\n-            }\n-            styleCache = \"document\";\n-        }\n-        return styleCache;\n-    }\n-\n-    public boolean isRPC(Method method) {\n-        Boolean b = isRpcCache.get(method);\n-        if (b == null) {\n-            for (AbstractServiceConfiguration c : serviceConfigurations) {\n-                b = c.isRPC(method);\n-                if (b != null) {\n-                    isRpcCache.put(method, b);\n-                    return b.booleanValue();\n-                }\n-            }\n-            b = \"rpc\".equals(getStyle());\n-            isRpcCache.put(method, b);\n-        }\n-        return b;\n-    }\n-\n-    public void setWrapped(boolean style) {\n-        this.wrappedStyle = style;\n-    }\n-\n-    /**\n-     * Returns non-null if wrapped mode was explicitely disabled or enabled.\n-     */\n-    public Boolean getWrapped() {\n-        return this.wrappedStyle;\n-    }\n-\n-    public Map<String, Object> getProperties() {\n-        return properties;\n-    }\n-\n-    public void setProperties(Map<String, Object> properties) {\n-        this.properties = properties;\n-    }\n-\n-    public List<Method> getIgnoredMethods() {\n-        return ignoredMethods;\n-    }\n-\n-    public void setIgnoredMethods(List<Method> ignoredMethods) {\n-        this.ignoredMethods = ignoredMethods;\n-    }\n-\n-    public List<Feature> getFeatures() {\n-        return features;\n-    }\n-\n-    public void setFeatures(List<? extends Feature> features2) {\n-        this.features = CastUtils.cast(features2);\n-    }\n-\n-    private boolean isValidate() {\n-        return validate || DO_VALIDATE;\n-    }\n-\n-    /**\n-     * If 'validate' is true, this class will validate the service. It will report problems\n-     * with the service model and the XML schema for the service.\n-     * @param validate\n-     */\n-    public void setValidate(boolean validate) {\n-        this.validate = validate;\n-    }\n-\n-    public void setSchemaLocations(List<String> schemaLocations) {\n-        this.schemaLocations = schemaLocations;\n-    }\n-}\n"}}, {"oid": "16a88ef8099870fb3887e2d8ef7708e612bd24f2", "url": "https://github.com/OpenLiberty/open-liberty/commit/16a88ef8099870fb3887e2d8ef7708e612bd24f2", "message": "Code Review Changes", "committedDate": "2020-12-03T09:18:10Z", "type": "forcePushed"}, {"oid": "37d25f2714cff4b328891a449e17266aa2edf824", "url": "https://github.com/OpenLiberty/open-liberty/commit/37d25f2714cff4b328891a449e17266aa2edf824", "message": "Code Review Changes\n\nfix merge problems\n\nFix missing artifact from merge", "committedDate": "2020-12-03T09:50:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTIyOTEwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/14963#discussion_r535229103", "bodyText": "This logic doesn't work.  You will get an NPE if clientMetaData is null.", "author": "jhanders34", "createdAt": "2020-12-03T13:31:38Z", "path": "dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java", "diffHunk": "@@ -73,31 +73,25 @@ public ServiceDelegate createServiceDelegate(URL url, QName qname,\n             throw new IllegalStateException(e);\n         }\n         \n-        Bus bus = null;\n+\n+        final Bus bus;\n         JaxWsClientMetaData clientMetaData = JaxWsMetaDataManager.getJaxWsClientMetaData();\n-        if (clientMetaData != null) {\n+        boolean hasClientBus = (clientMetaData.getClientBus() != null);", "originalCommit": "37d25f2714cff4b328891a449e17266aa2edf824", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "930439119c42755db35c506cc6ae242021a2462b", "chunk": "diff --git a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java\nindex 181ad40ecd..93fccba2ca 100755\n--- a/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java\n+++ b/dev/com.ibm.ws.jaxws.2.3.common/src/com/ibm/ws/jaxws/client/LibertyProviderImpl.java\n\n@@ -76,9 +76,16 @@ public class LibertyProviderImpl extends ProviderImpl {\n \n         final Bus bus;\n         JaxWsClientMetaData clientMetaData = JaxWsMetaDataManager.getJaxWsClientMetaData();\n-        boolean hasClientBus = (clientMetaData.getClientBus() != null);\n-        if (clientMetaData != null && hasClientBus) { \n-            bus = clientMetaData.getClientBus();\n+        if(clientMetaData != null) {\n+            boolean hasClientBus = (clientMetaData.getClientBus() != null);\n+            if (hasClientBus) { \n+                bus = clientMetaData.getClientBus();\n+            } else {\n+                bus = BusFactory.getThreadDefaultBus();\n+                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                    Tr.debug(tc, \"No client  bus is found, the thread context default bus \" + bus.getId() + \" is used\");\n+                }\n+            }\n         } else {\n             bus = BusFactory.getThreadDefaultBus();\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n"}}, {"oid": "930439119c42755db35c506cc6ae242021a2462b", "url": "https://github.com/OpenLiberty/open-liberty/commit/930439119c42755db35c506cc6ae242021a2462b", "message": "Code Review Changes\n\nfix merge problems\n\nFix missing artifact from merge\n\nMore code review changes to refactor jaxws-2.3\n\nReadd eecomptabile", "committedDate": "2020-12-03T21:16:05Z", "type": "forcePushed"}, {"oid": "6a928ddd5d9622e484cc21ab05a5ae2c0ebf3a98", "url": "https://github.com/OpenLiberty/open-liberty/commit/6a928ddd5d9622e484cc21ab05a5ae2c0ebf3a98", "message": "remove autoprovisioning on jaxws-2.3\n\nReadd jaxb-2.3 changes", "committedDate": "2020-12-03T22:47:02Z", "type": "forcePushed"}, {"oid": "9abf6a20245cd2d9b23da2eda5569cc61734b93c", "url": "https://github.com/OpenLiberty/open-liberty/commit/9abf6a20245cd2d9b23da2eda5569cc61734b93c", "message": "Code Review Changes\n\nfix merge problems\n\nFix missing artifact from merge\n\nMore code review changes to refactor jaxws-2.3\n\nReadd eecomptabile\n\nremove autoprovisioning on jaxws-2.3\n\nReadd jaxb-2.3 changes\n\nFat test fixes", "committedDate": "2020-12-04T08:14:27Z", "type": "forcePushed"}, {"oid": "49820a9e33ec2681714c1a6948934639fade187d", "url": "https://github.com/OpenLiberty/open-liberty/commit/49820a9e33ec2681714c1a6948934639fade187d", "message": "Update jaxws.2.3.common to implement missing methods", "committedDate": "2020-12-04T19:59:32Z", "type": "commit"}, {"oid": "9e409d66d259bbabccb31b0811408c7eb2351b66", "url": "https://github.com/OpenLiberty/open-liberty/commit/9e409d66d259bbabccb31b0811408c7eb2351b66", "message": "Changes to support CXF jaxws-2.3 runtime updates\n\nWIP: fat changes for PB run\n\nUndo changes to jaxws.common by bad merge\n\nRevert \"Undo changes to jaxws.common by bad merge\"\n\nThis reverts commit 7331953aa59a9edd7eed6aa79ef2ca5bd41c3a44.\n\nRevert \"Update jaxws.2.3.common to implement missing methods\"\n\nThis reverts commit b083587f1bb1c3c408a17d4164d2961a3f720dfd.\n\nRevert \"WIP: fat changes for PB run\"\n\nThis reverts commit 3dc167ac029ff4b18b5219fd188d834e549d8e49.\n\nRevert \"Revert \"WIP: fat changes for PB run\"\"\n\nThis reverts commit 310fc06d4f435c45e9165af7ed6d35ddb851865f.", "committedDate": "2020-12-04T19:59:33Z", "type": "commit"}, {"oid": "1c548f5af67c48b09684a37ad9daf16ef1ddf764", "url": "https://github.com/OpenLiberty/open-liberty/commit/1c548f5af67c48b09684a37ad9daf16ef1ddf764", "message": "add wsat\n\njaxws-2.3 runtime and FAT updates\n\nmerge fixing\n\nadditional jaxws-2.3 code clean up changes\n\nAdd jaxws-2.3 changes for code review and more test fixes", "committedDate": "2020-12-04T19:59:36Z", "type": "commit"}, {"oid": "79d6222c9a42e081d8cb9d6943f6354c4accab41", "url": "https://github.com/OpenLiberty/open-liberty/commit/79d6222c9a42e081d8cb9d6943f6354c4accab41", "message": "Update CXF versions to match CXF Core to fix failures in multiple jaxrs and jaxws buckets\n\nMore code review comments\n\nMore code review comments\n\nremove wrong version change\n\nremove wrong version change\n\nMore code review changes\n\nUdno bnd.overrides typo\n\nDiable instrumentation to prevent unncessary FFDCs from being generating by custom JAX-RS execptions", "committedDate": "2020-12-04T19:59:37Z", "type": "commit"}, {"oid": "526a86baefbab145dfeab4ea411f84917a0fef72", "url": "https://github.com/OpenLiberty/open-liberty/commit/526a86baefbab145dfeab4ea411f84917a0fef72", "message": "Code Review Changes\n\nfix merge problems\n\nFix missing artifact from merge\n\nMore code review changes to refactor jaxws-2.3\n\nReadd eecomptabile\n\nremove autoprovisioning on jaxws-2.3\n\nReadd jaxb-2.3 changes\n\nFat test fixes", "committedDate": "2020-12-04T19:59:39Z", "type": "commit"}, {"oid": "5719b538682d41b29d0bb769f6021c07156b588f", "url": "https://github.com/OpenLiberty/open-liberty/commit/5719b538682d41b29d0bb769f6021c07156b588f", "message": "Fix test repeat actions\n\nadd missing forServers", "committedDate": "2020-12-04T19:59:43Z", "type": "commit"}, {"oid": "5719b538682d41b29d0bb769f6021c07156b588f", "url": "https://github.com/OpenLiberty/open-liberty/commit/5719b538682d41b29d0bb769f6021c07156b588f", "message": "Fix test repeat actions\n\nadd missing forServers", "committedDate": "2020-12-04T19:59:43Z", "type": "forcePushed"}]}