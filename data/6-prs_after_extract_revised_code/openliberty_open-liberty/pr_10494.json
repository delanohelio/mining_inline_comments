{"pr_number": 10494, "pr_title": "Expose Producer and ConsumerRecord", "pr_createdAt": "2020-01-20T18:12:45Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/10494", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwNjU2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369006560", "bodyText": "I don't really like putting this logic in what's meant to be a thin wrapper layer.\nI get that if we want to handle Kafka classes directly, then we can only do so so in the adaptor layer, but maybe we could separate the functionality for turning a value into a ProducerRecord from the simple wrapping logic.", "author": "Azquelt", "createdAt": "2020-01-21T13:43:19Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/KafkaProducerImpl.java", "diffHunk": "@@ -21,22 +21,40 @@\n /**\n  *\n  */\n-public class KafkaProducerImpl<K, V> extends AbstractKafkaAdapter<org.apache.kafka.clients.producer.KafkaProducer<K, V>> implements KafkaProducer<K, V> {\n+public class KafkaProducerImpl<K, V, T> extends AbstractKafkaAdapter<org.apache.kafka.clients.producer.KafkaProducer<K, T>> implements KafkaProducer<K, V> {\n \n     private static final String CLAZZ = KafkaProducerImpl.class.getName();\n     private static final Logger LOGGER = Logger.getLogger(CLAZZ);\n \n     public KafkaProducerImpl(Map<String, Object> producerConfig) {\n-        super(new org.apache.kafka.clients.producer.KafkaProducer<K, V>(producerConfig));\n+        super(new org.apache.kafka.clients.producer.KafkaProducer<K, T>(producerConfig));\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void send(String topic, V value, Callback callback) {\n+    public void send(String configuredTopic, V value, Callback callback, boolean useProducerRecordTopic) {\n         if (LOGGER.isLoggable(Level.FINEST)) {\n-            LOGGER.logp(Level.FINEST, CLAZZ, \"send\", \"Topic: {0}, Value: {1}\", new String[] { topic, value.toString() });\n+            LOGGER.logp(Level.FINEST, CLAZZ, \"send\", \"Configured Topic: {0}, Value: {1}, Use ProducerRecord topic: {2}\",\n+                        new String[] { configuredTopic, value.toString(), Boolean.toString(useProducerRecordTopic) });\n+        }\n+\n+        org.apache.kafka.clients.producer.ProducerRecord<K, T> delegateRecord;\n+\n+        if (value instanceof org.apache.kafka.clients.producer.ProducerRecord) {\n+            org.apache.kafka.clients.producer.ProducerRecord<K, T> userProducerRecord = (org.apache.kafka.clients.producer.ProducerRecord<K, T>) value;\n+            org.apache.kafka.common.header.Headers headers = userProducerRecord.headers();\n+            K key = userProducerRecord.key();\n+            Integer partition = userProducerRecord.partition();\n+            Long timestamp = userProducerRecord.timestamp();\n+            String userTopic = userProducerRecord.topic();\n+            T userValue = userProducerRecord.value();\n+\n+            String topic = useProducerRecordTopic ? userTopic : configuredTopic;\n+\n+            delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(topic, partition, timestamp, key, userValue, headers);\n+        } else {\n+            delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(configuredTopic, (T) value);\n         }\n-        org.apache.kafka.clients.producer.ProducerRecord<K, V> delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(topic, value);\n ", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDQ3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372870477", "bodyText": "A ProducerRecord is now constructed through the factory so the send method now mirrors the original API again.", "author": "tevans78", "createdAt": "2020-01-30T10:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwNjU2MA=="}], "type": "inlineReview", "revised_code": {"commit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/KafkaProducerImpl.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/KafkaProducerImpl.java\nindex a2fd77a8e0..beca371d93 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/KafkaProducerImpl.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/KafkaProducerImpl.java\n\n@@ -25,36 +25,25 @@ public class KafkaProducerImpl<K, V, T> extends AbstractKafkaAdapter<org.apache.\n \n     private static final String CLAZZ = KafkaProducerImpl.class.getName();\n     private static final Logger LOGGER = Logger.getLogger(CLAZZ);\n+    private final boolean allowKafkaProducerRecord;\n \n-    public KafkaProducerImpl(Map<String, Object> producerConfig) {\n+    public KafkaProducerImpl(Map<String, Object> producerConfig, boolean allowKafkaProducerRecord) {\n         super(new org.apache.kafka.clients.producer.KafkaProducer<K, T>(producerConfig));\n+        this.allowKafkaProducerRecord = allowKafkaProducerRecord;//TODO remove beta guard before GA\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void send(String configuredTopic, V value, Callback callback, boolean useProducerRecordTopic) {\n+    public void send(String configuredTopic, String channelName, V value, Callback callback) {\n         if (LOGGER.isLoggable(Level.FINEST)) {\n-            LOGGER.logp(Level.FINEST, CLAZZ, \"send\", \"Configured Topic: {0}, Value: {1}, Use ProducerRecord topic: {2}\",\n-                        new String[] { configuredTopic, value.toString(), Boolean.toString(useProducerRecordTopic) });\n+            LOGGER.logp(Level.FINEST, CLAZZ, \"send\", \"Configured Topic: {0}, Channel Name: {1}, Value: {2}\",\n+                        new String[] { configuredTopic, channelName, value.toString() });\n         }\n \n-        org.apache.kafka.clients.producer.ProducerRecord<K, T> delegateRecord;\n-\n-        if (value instanceof org.apache.kafka.clients.producer.ProducerRecord) {\n-            org.apache.kafka.clients.producer.ProducerRecord<K, T> userProducerRecord = (org.apache.kafka.clients.producer.ProducerRecord<K, T>) value;\n-            org.apache.kafka.common.header.Headers headers = userProducerRecord.headers();\n-            K key = userProducerRecord.key();\n-            Integer partition = userProducerRecord.partition();\n-            Long timestamp = userProducerRecord.timestamp();\n-            String userTopic = userProducerRecord.topic();\n-            T userValue = userProducerRecord.value();\n-\n-            String topic = useProducerRecordTopic ? userTopic : configuredTopic;\n-\n-            delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(topic, partition, timestamp, key, userValue, headers);\n-        } else {\n-            delegateRecord = new org.apache.kafka.clients.producer.ProducerRecord<>(configuredTopic, (T) value);\n-        }\n+        org.apache.kafka.clients.producer.ProducerRecord<K, T> delegateRecord = (org.apache.kafka.clients.producer.ProducerRecord<K, T>) ProducerRecordFactory.newDelegateProducerRecord(configuredTopic,\n+                                                                                                                                                                                         channelName,\n+                                                                                                                                                                                         value,\n+                                                                                                                                                                                         this.allowKafkaProducerRecord);//TODO remove beta guard before GA\n \n         org.apache.kafka.clients.producer.Callback delegateCallback = (m, e) -> {\n             org.apache.kafka.clients.producer.RecordMetadata delegateRecordMetadata = m;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369008429", "bodyText": "If we go ahead with something using this approach, we should make sure the special value makes sense to the user configuring the application.\nI think something like this would make more sense:\nmp.reactive.messaging.outgoing.foobar.topic=APPLICATION_PROVIDED", "author": "Azquelt", "createdAt": "2020-01-21T13:47:04Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java", "diffHunk": "@@ -26,6 +26,10 @@\n     //The producer or consumer topic\n     public static final String TOPIC = \"topic\";\n \n+    //If the topic is set to this value then when the message payload is a ProducerRecord,\n+    //use the topic set in the ProducerRecord rather than the one set in MP Config\n+    public static final String USE_PRODUCER_RECORD_TOPIC = \"USE_PRODUCER_RECORD_TOPIC\";", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MTg2MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371251860", "bodyText": "Decided that we don't need this special config property value", "author": "tevans78", "createdAt": "2020-01-27T13:55:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAwODQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java\nindex 0e24e76c4a..0033d89d77 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java\n\n@@ -26,10 +26,6 @@ public class KafkaConnectorConstants {\n     //The producer or consumer topic\n     public static final String TOPIC = \"topic\";\n \n-    //If the topic is set to this value then when the message payload is a ProducerRecord,\n-    //use the topic set in the ProducerRecord rather than the one set in MP Config\n-    public static final String USE_PRODUCER_RECORD_TOPIC = \"USE_PRODUCER_RECORD_TOPIC\";\n-\n     //The limit on on the number of un-acknowledged messages\n     public static final String UNACKED_LIMIT = \"unacked.limit\";\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMDYwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369010607", "bodyText": "It's not valid for ack to be null (Trying to follow it through, I think ack will be passed as the second argument to Message.of(payload, ack) which doesn't permit null)", "author": "Azquelt", "createdAt": "2020-01-21T13:51:06Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaInput.java", "diffHunk": "@@ -140,12 +145,18 @@ public KafkaInput(KafkaAdapterFactory kafkaAdapterFactory, KafkaConsumer<K, V> k\n     }\n \n     private Message<V> wrapInMessage(ConsumerRecord<K, V> record) {\n+        Message<V> message = null;\n         try {\n-            return Message.of(record.value(), this.ackTracker.trackRecord(record));\n+            Supplier<CompletionStage<Void>> ack = null;\n+            if (this.ackTracker != null) {\n+                ack = this.ackTracker.trackRecord(record);\n+            }\n+            message = this.kafkaAdapterFactory.newIncomingKafkaMessage(record, ack);", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5MDE2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371190163", "bodyText": "Reading it through again, it doesn't go to Message.of(), you have your own Message implementation which accepts null as the ack argument.", "author": "Azquelt", "createdAt": "2020-01-27T11:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMDYwNw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMTkyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369011928", "bodyText": "I'd prefer either setting the key on the original message, or generating the key completely in the processor method.", "author": "Azquelt", "createdAt": "2020-01-21T13:53:33Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import javax.servlet.annotation.WebServlet;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.junit.Test;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n+\n+@WebServlet(\"/kafkaMessageTest\")\n+public class KafkaMessageServlet extends AbstractKafkaTestServlet {\n+\n+    @Test\n+    public void testKafkaMessage() {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(KafkaMessageBean.CHANNEL_IN);\n+        String value = \"hello\";\n+        writer.sendMessage(value);\n+\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(KafkaMessageBean.CHANNEL_OUT);\n+        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(2));\n+\n+        assertEquals(1, records.size());\n+\n+        ConsumerRecord<String, String> record = records.get(0);\n+        assertEquals(\"OUT_null\", record.key()); //original key defaults to null", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MjI4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371252284", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-27T13:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMTkyOA=="}], "type": "inlineReview", "revised_code": {"commit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\nsimilarity index 53%\nrename from dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java\nrename to dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\nindex e7e064246b..145dbf27db 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\n\n@@ -11,38 +11,47 @@\n package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n import java.time.Duration;\n import java.util.List;\n \n-import javax.servlet.annotation.WebServlet;\n-\n import org.apache.kafka.clients.consumer.ConsumerRecord;\n-import org.junit.Test;\n \n import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n \n-@WebServlet(\"/kafkaMessageTest\")\n-public class KafkaMessageServlet extends AbstractKafkaTestServlet {\n+public class AbstractTopicServlet extends AbstractKafkaTestServlet {\n \n-    @Test\n-    public void testKafkaMessage() {\n-        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(KafkaMessageBean.CHANNEL_IN);\n-        String value = \"hello\";\n+    public void testTopic(String topicIn, String expectedTopicOut, String unexpectedTopicOut, String keyOut, String valueOut) {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(topicIn);\n+        String value = \"hello\"; //this value doesn't matter\n         writer.sendMessage(value);\n \n-        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(KafkaMessageBean.CHANNEL_OUT);\n-        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(2));\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(expectedTopicOut);\n+        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+        if (records.size() != 1) {\n+            reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+            records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n \n-        assertEquals(1, records.size());\n+            if (records.size() == 1) {\n+                fail(\"Message was sent to wrong topic: \" + unexpectedTopicOut);\n+            } else {\n+                fail(\"Message not found on any topic\");\n+            }\n+        }\n \n         ConsumerRecord<String, String> record = records.get(0);\n-        assertEquals(\"OUT_null\", record.key()); //original key defaults to null\n+        assertEquals(keyOut, record.key());\n+        assertEquals(valueOut, record.value());\n+        assertEquals(expectedTopicOut, record.topic());\n+\n+        reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+        records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n \n-        String expectedValue = new StringBuilder(value).reverse().toString(); //value is reversed\n-        assertEquals(expectedValue, record.value());\n+        assertEquals(\"Message may have been sent to more than one topic???\", 0, records.size());\n     }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMjcyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r369012724", "bodyText": "Should we also test that nothing is received on CHANNEL_ALT?", "author": "Azquelt", "createdAt": "2020-01-21T13:54:58Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import javax.servlet.annotation.WebServlet;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.junit.Test;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n+\n+@WebServlet(\"/kafkaMessageTest\")\n+public class KafkaMessageServlet extends AbstractKafkaTestServlet {\n+\n+    @Test\n+    public void testKafkaMessage() {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(KafkaMessageBean.CHANNEL_IN);\n+        String value = \"hello\";\n+        writer.sendMessage(value);\n+\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(KafkaMessageBean.CHANNEL_OUT);", "originalCommit": "57fca8ce421d3626c190caa11c18608840334336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MjAwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371252006", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-27T13:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTAxMjcyNA=="}], "type": "inlineReview", "revised_code": {"commit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\nsimilarity index 53%\nrename from dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java\nrename to dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\nindex e7e064246b..145dbf27db 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/KafkaMessageServlet.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\n\n@@ -11,38 +11,47 @@\n package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n \n import java.time.Duration;\n import java.util.List;\n \n-import javax.servlet.annotation.WebServlet;\n-\n import org.apache.kafka.clients.consumer.ConsumerRecord;\n-import org.junit.Test;\n \n import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n \n-@WebServlet(\"/kafkaMessageTest\")\n-public class KafkaMessageServlet extends AbstractKafkaTestServlet {\n+public class AbstractTopicServlet extends AbstractKafkaTestServlet {\n \n-    @Test\n-    public void testKafkaMessage() {\n-        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(KafkaMessageBean.CHANNEL_IN);\n-        String value = \"hello\";\n+    public void testTopic(String topicIn, String expectedTopicOut, String unexpectedTopicOut, String keyOut, String valueOut) {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(topicIn);\n+        String value = \"hello\"; //this value doesn't matter\n         writer.sendMessage(value);\n \n-        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(KafkaMessageBean.CHANNEL_OUT);\n-        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(2));\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(expectedTopicOut);\n+        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+        if (records.size() != 1) {\n+            reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+            records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n \n-        assertEquals(1, records.size());\n+            if (records.size() == 1) {\n+                fail(\"Message was sent to wrong topic: \" + unexpectedTopicOut);\n+            } else {\n+                fail(\"Message not found on any topic\");\n+            }\n+        }\n \n         ConsumerRecord<String, String> record = records.get(0);\n-        assertEquals(\"OUT_null\", record.key()); //original key defaults to null\n+        assertEquals(keyOut, record.key());\n+        assertEquals(valueOut, record.value());\n+        assertEquals(expectedTopicOut, record.topic());\n+\n+        reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+        records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n \n-        String expectedValue = new StringBuilder(value).reverse().toString(); //value is reversed\n-        assertEquals(expectedValue, record.value());\n+        assertEquals(\"Message may have been sent to more than one topic???\", 0, records.size());\n     }\n \n }\n"}}, {"oid": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "url": "https://github.com/OpenLiberty/open-liberty/commit/ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "message": "Expose Producer and ConsumerRecord", "committedDate": "2020-01-24T16:05:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2MDc1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r370760756", "bodyText": "a) true what?\nb) What requires not checking that the correct number of records were fetched?", "author": "Azquelt", "createdAt": "2020-01-24T17:48:39Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java", "diffHunk": "@@ -50,6 +50,10 @@ public ExtendedKafkaReader(KafkaConsumer<K, V> kafkaConsumer, String topic) {\n      * @return the list of records received\n      */\n     public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout) {\n+        return waitForRecords(count, timeout, true);", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTIwMDYyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371200623", "bodyText": "We discussed this further, see comment below", "author": "Azquelt", "createdAt": "2020-01-27T11:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2MDc1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDY4OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372870688", "bodyText": "Removed the boolean and renamed the methods", "author": "tevans78", "createdAt": "2020-01-30T10:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc2MDc1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/KafkaReader.java\nsimilarity index 65%\nrename from dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java\nrename to dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/KafkaReader.java\nindex cf8c8a9c94..635cba5a11 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/KafkaReader.java\n\n@@ -49,24 +65,23 @@ public class ExtendedKafkaReader<K, V> implements AutoCloseable {\n      * @param timeout the amount of time to wait for the expected number of records to be received\n      * @return the list of records received\n      */\n-    public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout) {\n-        return waitForRecords(count, timeout, true);\n+    public List<ConsumerRecord<K, V>> assertReadRecords(int count, Duration timeout) {\n+        List<ConsumerRecord<K, V>> records = readRecords(count, timeout);\n+        assertThat(\"Wrong number of records fetched from kafka\", records, hasSize(count));\n+        return records;\n     }\n \n-    public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout, boolean assertNumberOfRecords) {\n+    public List<ConsumerRecord<K, V>> readRecords(int maxRecords, Duration timeout) {\n         ArrayList<ConsumerRecord<K, V>> result = new ArrayList<>();\n         Duration remaining = timeout;\n         long startTime = System.nanoTime();\n-        while (!remaining.isNegative() && result.size() < count) {\n+        while (!remaining.isNegative() && result.size() < maxRecords) {\n             for (ConsumerRecord<K, V> record : kafkaConsumer.poll(remaining)) {\n                 result.add(record);\n             }\n             Duration elapsed = Duration.ofNanos(System.nanoTime() - startTime);\n             remaining = timeout.minus(elapsed);\n         }\n-        if (assertNumberOfRecords) {\n-            assertThat(\"Wrong number of records fetched from kafka\", result, hasSize(count));\n-        }\n         return result;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4Nzg4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371187884", "bodyText": "Instead of passing beta guard booleans around, can we put a static somewhere in the interface bundle?", "author": "Azquelt", "createdAt": "2020-01-27T11:26:42Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaAdapterFactory.java", "diffHunk": "@@ -29,7 +33,7 @@\n     private static final Class<?>[] KAFKA_CONSUMER_ARG_TYPES = { Map.class };\n \n     private static final String KAFKA_PRODUCER_IMPL = \"com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl.KafkaProducerImpl\";\n-    private static final Class<?>[] KAFKA_PRODUCER_ARG_TYPES = { Map.class };\n+    private static final Class<?>[] KAFKA_PRODUCER_ARG_TYPES = { Map.class, boolean.class }; //TODO remove beta guard before GA", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MDg3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372870871", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4Nzg4NA=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaAdapterFactory.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaAdapterFactory.java\nindex b634c576ba..0c85772410 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaAdapterFactory.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaAdapterFactory.java\n\n@@ -33,7 +33,7 @@ public abstract class KafkaAdapterFactory {\n     private static final Class<?>[] KAFKA_CONSUMER_ARG_TYPES = { Map.class };\n \n     private static final String KAFKA_PRODUCER_IMPL = \"com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl.KafkaProducerImpl\";\n-    private static final Class<?>[] KAFKA_PRODUCER_ARG_TYPES = { Map.class, boolean.class }; //TODO remove beta guard before GA\n+    private static final Class<?>[] KAFKA_PRODUCER_ARG_TYPES = { Map.class };\n \n     private static final String TOPIC_PARTITION_IMPL = \"com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl.TopicPartitionImpl\";\n     private static final Class<?>[] TOPIC_PARTITION_ARG_TYPES = { String.class, int.class };\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODMyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371188325", "bodyText": "This method in particular needs doc because it's not a simple passthrough.", "author": "Azquelt", "createdAt": "2020-01-27T11:27:40Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaProducer.java", "diffHunk": "@@ -18,10 +18,12 @@\n public interface KafkaProducer<K, V> extends KafkaAdapter {\n \n     /**\n-     * @param record\n+     * @param topic\n+     * @param channelName\n+     * @param value\n      * @param callback\n      */\n-    void send(String topic, V value, Callback callback);\n+    void send(String topic, String channelName, V value, Callback callback);", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTAyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871021", "bodyText": "it is back to being passthrough", "author": "tevans78", "createdAt": "2020-01-30T10:31:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaProducer.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaProducer.java\nindex 4bc4819e35..638f3dc644 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaProducer.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/KafkaProducer.java\n\n@@ -18,12 +18,10 @@ import java.time.Duration;\n public interface KafkaProducer<K, V> extends KafkaAdapter {\n \n     /**\n-     * @param topic\n-     * @param channelName\n-     * @param value\n+     * @param producerRecord\n      * @param callback\n      */\n-    void send(String topic, String channelName, V value, Callback callback);\n+    void send(ProducerRecord<K, V> producerRecord, Callback callback);\n \n     void close(Duration timeout);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODUwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371188504", "bodyText": "Remove if this is the only change :)", "author": "Azquelt", "createdAt": "2020-01-27T11:28:03Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019 IBM Corporation and others.\n+ * Copyright (c) 2019, 2020 IBM Corporation and others.", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTA4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871081", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE4ODUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java\nindex 0033d89d77..ebc55fafd3 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka/src/com/ibm/ws/microprofile/reactive/messaging/kafka/KafkaConnectorConstants.java\n\n@@ -1,5 +1,5 @@\n /*******************************************************************************\n- * Copyright (c) 2019, 2020 IBM Corporation and others.\n+ * Copyright (c) 2019 IBM Corporation and others.\n  * All rights reserved. This program and the accompanying materials\n  * are made available under the terms of the Eclipse Public License v1.0\n  * which accompanies this distribution, and is available at\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5Mzk3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371193976", "bodyText": "Can we have two separate methods instead of a boolean argument.\nMaybe\nreadRecords(int maxCount, Duration timeout);\n\nand\nassertReadRecords(int count, Duration timeout)", "author": "Azquelt", "createdAt": "2020-01-27T11:41:44Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java", "diffHunk": "@@ -50,6 +50,10 @@ public ExtendedKafkaReader(KafkaConsumer<K, V> kafkaConsumer, String topic) {\n      * @return the list of records received\n      */\n     public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout) {\n+        return waitForRecords(count, timeout, true);\n+    }\n+\n+    public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout, boolean assertNumberOfRecords) {", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTE1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871155", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5Mzk3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/KafkaReader.java\nsimilarity index 65%\nrename from dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java\nrename to dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/KafkaReader.java\nindex cf8c8a9c94..635cba5a11 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/ExtendedKafkaReader.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/framework/KafkaReader.java\n\n@@ -49,24 +65,23 @@ public class ExtendedKafkaReader<K, V> implements AutoCloseable {\n      * @param timeout the amount of time to wait for the expected number of records to be received\n      * @return the list of records received\n      */\n-    public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout) {\n-        return waitForRecords(count, timeout, true);\n+    public List<ConsumerRecord<K, V>> assertReadRecords(int count, Duration timeout) {\n+        List<ConsumerRecord<K, V>> records = readRecords(count, timeout);\n+        assertThat(\"Wrong number of records fetched from kafka\", records, hasSize(count));\n+        return records;\n     }\n \n-    public List<ConsumerRecord<K, V>> waitForRecords(int count, Duration timeout, boolean assertNumberOfRecords) {\n+    public List<ConsumerRecord<K, V>> readRecords(int maxRecords, Duration timeout) {\n         ArrayList<ConsumerRecord<K, V>> result = new ArrayList<>();\n         Duration remaining = timeout;\n         long startTime = System.nanoTime();\n-        while (!remaining.isNegative() && result.size() < count) {\n+        while (!remaining.isNegative() && result.size() < maxRecords) {\n             for (ConsumerRecord<K, V> record : kafkaConsumer.poll(remaining)) {\n                 result.add(record);\n             }\n             Duration elapsed = Duration.ofNanos(System.nanoTime() - startTime);\n             remaining = timeout.minus(elapsed);\n         }\n-        if (assertNumberOfRecords) {\n-            assertThat(\"Wrong number of records fetched from kafka\", result, hasSize(count));\n-        }\n         return result;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NTgxNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371195815", "bodyText": "Simplify this method.", "author": "Azquelt", "createdAt": "2020-01-27T11:46:28Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.time.Duration;\n+import java.util.List;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n+\n+public class AbstractTopicServlet extends AbstractKafkaTestServlet {\n+\n+    public void testTopic(String topicIn, String expectedTopicOut, String unexpectedTopicOut, String keyOut, String valueOut) {\n+        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(topicIn);\n+        String value = \"hello\"; //this value doesn't matter\n+        writer.sendMessage(value);\n+\n+        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(expectedTopicOut);\n+        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+        if (records.size() != 1) {\n+            reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+            records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+            if (records.size() == 1) {\n+                fail(\"Message was sent to wrong topic: \" + unexpectedTopicOut);\n+            } else {\n+                fail(\"Message not found on any topic\");\n+            }\n+        }\n+\n+        ConsumerRecord<String, String> record = records.get(0);\n+        assertEquals(keyOut, record.key());\n+        assertEquals(valueOut, record.value());\n+        assertEquals(expectedTopicOut, record.topic());\n+\n+        reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+        records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n+\n+        assertEquals(\"Message may have been sent to more than one topic???\", 0, records.size());\n+    }", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTIzNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871235", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NTgxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\ndeleted file mode 100644\nindex 145dbf27db..0000000000\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/AbstractTopicServlet.java\n+++ /dev/null\n\n@@ -1,57 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2020 IBM Corporation and others.\n- * All rights reserved. This program and the accompanying materials\n- * are made available under the terms of the Eclipse Public License v1.0\n- * which accompanies this distribution, and is available at\n- * http://www.eclipse.org/legal/epl-v10.html\n- *\n- * Contributors:\n- *     IBM Corporation - initial API and implementation\n- *******************************************************************************/\n-package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n-\n-import java.time.Duration;\n-import java.util.List;\n-\n-import org.apache.kafka.clients.consumer.ConsumerRecord;\n-\n-import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n-import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaReader;\n-import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.SimpleKafkaWriter;\n-\n-public class AbstractTopicServlet extends AbstractKafkaTestServlet {\n-\n-    public void testTopic(String topicIn, String expectedTopicOut, String unexpectedTopicOut, String keyOut, String valueOut) {\n-        SimpleKafkaWriter<String> writer = kafkaTestClient.writerFor(topicIn);\n-        String value = \"hello\"; //this value doesn't matter\n-        writer.sendMessage(value);\n-\n-        SimpleKafkaReader<String> reader = kafkaTestClient.readerFor(expectedTopicOut);\n-        List<ConsumerRecord<String, String>> records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n-\n-        if (records.size() != 1) {\n-            reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n-            records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n-\n-            if (records.size() == 1) {\n-                fail(\"Message was sent to wrong topic: \" + unexpectedTopicOut);\n-            } else {\n-                fail(\"Message not found on any topic\");\n-            }\n-        }\n-\n-        ConsumerRecord<String, String> record = records.get(0);\n-        assertEquals(keyOut, record.key());\n-        assertEquals(valueOut, record.value());\n-        assertEquals(expectedTopicOut, record.topic());\n-\n-        reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n-        records = reader.waitForRecords(1, Duration.ofSeconds(1), false);\n-\n-        assertEquals(\"Message may have been sent to more than one topic???\", 0, records.size());\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NjExNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371196114", "bodyText": "Should be able to check this now.", "author": "Azquelt", "createdAt": "2020-01-27T11:47:13Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/ConsumerRecordBean.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.common.header.Header;\n+import org.eclipse.microprofile.reactive.messaging.Incoming;\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+import org.eclipse.microprofile.reactive.messaging.Outgoing;\n+\n+@ApplicationScoped\n+public class ConsumerRecordBean {\n+\n+    public static final String CHANNEL_IN = \"consumer-record-in\";\n+    public static final String CHANNEL_OUT = \"consumer-record-out\";\n+    public static final String GROUP_ID = \"consumer-record-app-group\";\n+\n+    public static final String TOPIC = CHANNEL_IN;\n+    public static final String KEY = \"test_key\";\n+    public static final String VALUE = \"hello\";\n+    //public static final int PARTITION = 9;\n+    public static final long TIMESTAMP = 100L;\n+    public static final int NUM_HEADERS = 5;\n+    public static final String HEADER_KEY_PREFIX = \"headerKey\";\n+    public static final String HEADER_VALUE_PREFIX = \"headerKey\";\n+    public static final String PASS = \"PASS\";\n+\n+    @Incoming(CHANNEL_IN)\n+    @Outgoing(CHANNEL_OUT)\n+    public Message<String> checkConsumerRecord(Message<String> in) throws UnsupportedEncodingException {\n+\n+        @SuppressWarnings(\"unchecked\")\n+        ConsumerRecord<String, String> consumerRecord = in.unwrap(ConsumerRecord.class);\n+\n+        String incomingKey = consumerRecord.key();\n+        String incomingValue = consumerRecord.value();\n+        String incomingTopic = consumerRecord.topic();\n+        //int incomingPartition = consumerRecord.partition();", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTQ0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871448", "bodyText": "Not done! But it is harder and I want to do it separately.", "author": "tevans78", "createdAt": "2020-01-30T10:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5NjExNA=="}], "type": "inlineReview", "revised_code": {"commit": "5586b731457b538be19d15ff14388b7af2172cb0", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/ConsumerRecordBean.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/ConsumerRecordBean.java\nindex a749a5e42f..3f7055cd49 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/ConsumerRecordBean.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/ConsumerRecordBean.java\n\n@@ -30,7 +30,7 @@ public class ConsumerRecordBean {\n     public static final String TOPIC = CHANNEL_IN;\n     public static final String KEY = \"test_key\";\n     public static final String VALUE = \"hello\";\n-    //public static final int PARTITION = 9;\n+    public static final int PARTITION = 9;\n     public static final long TIMESTAMP = 100L;\n     public static final int NUM_HEADERS = 5;\n     public static final String HEADER_KEY_PREFIX = \"headerKey\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5ODU1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r371198550", "bodyText": "It's hard to read what this is doing. Can we remove the abstract class, even if that means duplicating the test code?", "author": "Azquelt", "createdAt": "2020-01-27T11:53:11Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/UseConfiguredTopicServlet.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n+\n+import javax.servlet.annotation.WebServlet;\n+\n+import org.junit.Test;\n+\n+@WebServlet(\"/useConfiguredTopicTest\")\n+public class UseConfiguredTopicServlet extends AbstractTopicServlet {\n+\n+    @Test\n+    public void testConfiguredTopic() {\n+        testTopic(ConfiguredTopicBean.CHANNEL_IN, ConfiguredTopicBean.CONFIGURED_TOPIC, ConfiguredTopicBean.PRODUCER_RECORD_TOPIC, ConfiguredTopicBean.PRODUCER_RECORD_KEY,\n+                  ConfiguredTopicBean.PRODUCER_RECORD_VALUE);\n+    }", "originalCommit": "ec20b98173e1357935d61fa3b6ef8f7afc37e2cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3MTU1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372871550", "bodyText": "Done", "author": "tevans78", "createdAt": "2020-01-30T10:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTE5ODU1MA=="}], "type": "inlineReview", "revised_code": {"commit": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/UseConfiguredTopicServlet.java b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/UseConfiguredTopicServlet.java\nindex a2cf73aff0..6a8031ca3b 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/UseConfiguredTopicServlet.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging_fat/fat/src/com/ibm/ws/microprofile/reactive/messaging/fat/kafka/message/UseConfiguredTopicServlet.java\n\n@@ -10,17 +10,58 @@\n  *******************************************************************************/\n package com.ibm.ws.microprofile.reactive.messaging.fat.kafka.message;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.util.List;\n+\n import javax.servlet.annotation.WebServlet;\n \n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n import org.junit.Test;\n \n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.common.KafkaTestConstants;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.AbstractKafkaTestServlet;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.KafkaReader;\n+import com.ibm.ws.microprofile.reactive.messaging.fat.kafka.framework.KafkaWriter;\n+\n @WebServlet(\"/useConfiguredTopicTest\")\n-public class UseConfiguredTopicServlet extends AbstractTopicServlet {\n+public class UseConfiguredTopicServlet extends AbstractKafkaTestServlet {\n \n     @Test\n     public void testConfiguredTopic() {\n-        testTopic(ConfiguredTopicBean.CHANNEL_IN, ConfiguredTopicBean.CONFIGURED_TOPIC, ConfiguredTopicBean.PRODUCER_RECORD_TOPIC, ConfiguredTopicBean.PRODUCER_RECORD_KEY,\n-                  ConfiguredTopicBean.PRODUCER_RECORD_VALUE);\n+        String topicIn = ConfiguredTopicBean.CHANNEL_IN;\n+        String expectedTopicOut = ConfiguredTopicBean.CONFIGURED_TOPIC;\n+        String unexpectedTopicOut = ConfiguredTopicBean.PRODUCER_RECORD_TOPIC;\n+        String keyOut = ConfiguredTopicBean.PRODUCER_RECORD_KEY;\n+        String valueOut = ConfiguredTopicBean.PRODUCER_RECORD_VALUE;\n+\n+        KafkaWriter<String, String> writer = kafkaTestClient.writerFor(topicIn);\n+        String value = \"hello\"; //this value doesn't matter\n+        writer.sendMessage(value);\n+\n+        KafkaReader<String, String> reader = kafkaTestClient.readerFor(expectedTopicOut);\n+        List<ConsumerRecord<String, String>> expectedRecords = reader.readRecords(1, KafkaTestConstants.DEFAULT_KAFKA_TIMEOUT);\n+\n+        reader = kafkaTestClient.readerFor(unexpectedTopicOut);\n+        List<ConsumerRecord<String, String>> unexpectedRecords = reader.readRecords(1, KafkaTestConstants.EXPECTED_FAILURE_KAFKA_TIMEOUT);\n+\n+        if (expectedRecords.size() == 1) {\n+            if (unexpectedRecords.size() != 0) {\n+                fail(\"Message may have been sent to more than one topic???\");\n+            } else {\n+                ConsumerRecord<String, String> record = expectedRecords.get(0);\n+                assertEquals(keyOut, record.key());\n+                assertEquals(valueOut, record.value());\n+                assertEquals(expectedTopicOut, record.topic());\n+            }\n+        } else {\n+            if (unexpectedRecords.size() == 0) {\n+                fail(\"Message not found on any topic\");\n+            } else {\n+                fail(\"Message was sent to wrong topic: \" + unexpectedTopicOut);\n+            }\n+        }\n     }\n \n }\n"}}, {"oid": "4b7820d0549ae3d98766fdd3e99601ad8728d280", "url": "https://github.com/OpenLiberty/open-liberty/commit/4b7820d0549ae3d98766fdd3e99601ad8728d280", "message": "Refactor KafkaReader and KafkaWriter", "committedDate": "2020-01-28T18:13:11Z", "type": "forcePushed"}, {"oid": "f7ac08ee1d5e0c07afb040f6b482389bed6952d2", "url": "https://github.com/OpenLiberty/open-liberty/commit/f7ac08ee1d5e0c07afb040f6b482389bed6952d2", "message": "dependabot update", "committedDate": "2020-01-29T11:55:23Z", "type": "forcePushed"}, {"oid": "e76a10f140b618fa9d486b6f6aaef7ca568e2fdf", "url": "https://github.com/OpenLiberty/open-liberty/commit/e76a10f140b618fa9d486b6f6aaef7ca568e2fdf", "message": "dependabot update", "committedDate": "2020-01-29T11:59:03Z", "type": "forcePushed"}, {"oid": "5f66f823f12fd5d579df5f6e61a23b04af23d149", "url": "https://github.com/OpenLiberty/open-liberty/commit/5f66f823f12fd5d579df5f6e61a23b04af23d149", "message": "dependabot update", "committedDate": "2020-01-29T11:59:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg4NzQyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372887424", "bodyText": "Exception messages need NLS before final release.", "author": "Azquelt", "createdAt": "2020-01-30T11:07:02Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/IncomingKafkaMessage.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.Supplier;\n+\n+import org.eclipse.microprofile.reactive.messaging.Message;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.BetaUtils;\n+import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.ConsumerRecord;\n+\n+/**\n+ *\n+ */\n+public class IncomingKafkaMessage<T> implements Message<T> {\n+\n+    private final ConsumerRecord<?, T> consumerRecord;\n+    private final Supplier<CompletionStage<Void>> ack;\n+\n+    public IncomingKafkaMessage(ConsumerRecord<?, T> consumerRecord, Supplier<CompletionStage<Void>> ack) {\n+        this.consumerRecord = consumerRecord;\n+        this.ack = ack;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getPayload() {\n+        return this.consumerRecord.value();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public CompletionStage<Void> ack() {\n+        if (this.ack != null) {\n+            return this.ack.get();\n+        } else {\n+            return CompletableFuture.completedFuture(null);\n+        }\n+    }\n+\n+    @Override\n+    public <C> C unwrap(Class<C> unwrapType) {\n+        if (unwrapType == null) {\n+            throw new IllegalArgumentException(\"The target class must not be `null`\");\n+        }\n+        if (BetaUtils.USE_KAFKA_PRODUCER_RECORD) { //TODO remove guard before GA\n+            if (org.apache.kafka.clients.consumer.ConsumerRecord.class.equals(unwrapType)) {\n+                return unwrapType.cast(this.consumerRecord.getDelegate());\n+            }\n+        }\n+        try {\n+            return unwrapType.cast(this);\n+        } catch (ClassCastException e) {\n+            throw new IllegalArgumentException(\"Cannot unwrap an instance of \" + this.getClass().getName()\n+                                               + \" to \" + unwrapType.getName(), e);", "originalCommit": "5f66f823f12fd5d579df5f6e61a23b04af23d149", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "73e228406ffea758a7541ca0059d3e2cdc4a9c34", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/IncomingKafkaMessage.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/IncomingKafkaMessage.java\nindex af5673de00..df512fab92 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/IncomingKafkaMessage.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/IncomingKafkaMessage.java\n\n@@ -16,7 +16,6 @@ import java.util.function.Supplier;\n \n import org.eclipse.microprofile.reactive.messaging.Message;\n \n-import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.BetaUtils;\n import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.ConsumerRecord;\n \n /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwODQxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372908419", "bodyText": "Technically, the type variables don't match up here.\nYou can pass in a ProducerRecord<String, String> as the value (i.e. V = ProducerRecord<String, String>) and you'll get back a ProducerRecord<String, String> (i.e. V = String).\nIt might be clearer to make value an Object to acknowledge that there's no type safety here. It might even make sense to return ProducerRecord<?, ?> if we don't actually need to know K and V.", "author": "Azquelt", "createdAt": "2020-01-30T11:57:40Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.BetaUtils;\n+\n+public class ProducerRecordFactory {\n+\n+    private static final String CLAZZ = ProducerRecordFactory.class.getName();\n+    private static final Logger LOGGER = Logger.getLogger(CLAZZ);\n+\n+    public static <K, V> org.apache.kafka.clients.producer.ProducerRecord<K, V> newDelegateProducerRecord(String configuredTopic, String channelName, V value) {", "originalCommit": "5f66f823f12fd5d579df5f6e61a23b04af23d149", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxMDI5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r372910294", "bodyText": "yeah, also a good point", "author": "tevans78", "createdAt": "2020-01-30T12:01:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwODQxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "73e228406ffea758a7541ca0059d3e2cdc4a9c34", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java\nindex a2f0199ee1..0f35674832 100644\n--- a/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java\n+++ b/dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java\n\n@@ -13,14 +13,13 @@ package com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n \n-import com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.BetaUtils;\n-\n public class ProducerRecordFactory {\n \n     private static final String CLAZZ = ProducerRecordFactory.class.getName();\n     private static final Logger LOGGER = Logger.getLogger(CLAZZ);\n \n-    public static <K, V> org.apache.kafka.clients.producer.ProducerRecord<K, V> newDelegateProducerRecord(String configuredTopic, String channelName, V value) {\n+    public static <K, V> org.apache.kafka.clients.producer.ProducerRecord<K, V> newDelegateProducerRecord(String configuredTopic, String channelName, V value,\n+                                                                                                          boolean allowKafkaProducerRecord) {//TODO remove beta guard before GA\n         if (LOGGER.isLoggable(Level.FINEST)) {\n             LOGGER.logp(Level.FINEST, CLAZZ, \"newDelegateProducerRecord\", \"Configured Topic: {0}, Channel Name: {1}, Value: {2}\",\n                         new String[] { configuredTopic, channelName, value.toString() });\n"}}, {"oid": "73e228406ffea758a7541ca0059d3e2cdc4a9c34", "url": "https://github.com/OpenLiberty/open-liberty/commit/73e228406ffea758a7541ca0059d3e2cdc4a9c34", "message": "Expose Producer and ConsumerRecord", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "f4c23bd228e1da55b9d8d86ca0050347096d7ae1", "url": "https://github.com/OpenLiberty/open-liberty/commit/f4c23bd228e1da55b9d8d86ca0050347096d7ae1", "message": "Kafka Producer Record - review updates 1", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "8fb2735635b256b54ca474f85802b2254299f528", "url": "https://github.com/OpenLiberty/open-liberty/commit/8fb2735635b256b54ca474f85802b2254299f528", "message": "Refactor KafkaReader and KafkaWriter", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "82030408bb5552e80e85dbd7c254c08a50c15674", "url": "https://github.com/OpenLiberty/open-liberty/commit/82030408bb5552e80e85dbd7c254c08a50c15674", "message": "Clarify test assertions, javadoc and tweak timeouts", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "5586b731457b538be19d15ff14388b7af2172cb0", "url": "https://github.com/OpenLiberty/open-liberty/commit/5586b731457b538be19d15ff14388b7af2172cb0", "message": "Final review updates", "committedDate": "2020-01-30T17:16:19Z", "type": "commit"}, {"oid": "5586b731457b538be19d15ff14388b7af2172cb0", "url": "https://github.com/OpenLiberty/open-liberty/commit/5586b731457b538be19d15ff14388b7af2172cb0", "message": "Final review updates", "committedDate": "2020-01-30T17:16:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA5MTU2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/10494#discussion_r373091569", "bodyText": "if (configuredTopic == null || configuredTopic.equals(userProducerRecord.topic())) { might be clearer here", "author": "Azquelt", "createdAt": "2020-01-30T17:34:43Z", "path": "dev/com.ibm.ws.microprofile.reactive.messaging.kafka.adapter.impl/src/com/ibm/ws/microprofile/reactive/messaging/kafka/adapter/impl/ProducerRecordFactory.java", "diffHunk": "@@ -61,4 +61,39 @@\n \n         return delegateRecord;\n     }\n+\n+    /**\n+     * Extract a suitable delegate ProducerRecord from a user provided one.\n+     * It will be a brand new ProducerRecord if the configuredTopic does not match the one in the user ProducerRecord.\n+     * If the topic is the same then this method will just return the user's ProducerRecord as-is\n+     *\n+     * @param <K> key type\n+     * @param <V> value type\n+     * @param configuredTopic The configured topic\n+     * @param userProducerRecord The user's producer record\n+     * @return\n+     */\n+    public static <K, V> org.apache.kafka.clients.producer.ProducerRecord<K, V> extractUserProducerRecord(String configuredTopic,\n+                                                                                                          org.apache.kafka.clients.producer.ProducerRecord<K, V> userProducerRecord) {\n+\n+        org.apache.kafka.clients.producer.ProducerRecord<K, V> delegateRecord;\n+\n+        String userTopic = userProducerRecord.topic();\n+\n+        //if a topic was not configured, use the one in the user provided ProducerRecord\n+        String topic = configuredTopic == null ? userTopic : configuredTopic;\n+        if (topic.contentEquals(userTopic)) {", "originalCommit": "5586b731457b538be19d15ff14388b7af2172cb0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}