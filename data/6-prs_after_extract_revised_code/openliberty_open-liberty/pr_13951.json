{"pr_number": 13951, "pr_title": "Revert open-liberty specific changes to CXF's MessageImpl object", "pr_createdAt": "2020-09-15T18:14:30Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/13951", "timeline": [{"oid": "00cbe90314cbbc6730ae6db68bd4cb4d667644e5", "url": "https://github.com/OpenLiberty/open-liberty/commit/00cbe90314cbbc6730ae6db68bd4cb4d667644e5", "message": "Merge jaxws.2.3.common\n\nupdate jaxws-2.3 to expose APIs to APP classpath\n\nRevert \"Initial check in of MessageImpl refactoring\"\n\nThis reverts commit f9cdd9d131c2b75cd3739583c266dcb0e5140e62.\n\nFix issues caused by revert\n\nadd addition change required", "committedDate": "2020-09-15T18:21:28Z", "type": "forcePushed"}, {"oid": "9d578ff2dff56c3d3139870c5476c6c986d96c3e", "url": "https://github.com/OpenLiberty/open-liberty/commit/9d578ff2dff56c3d3139870c5476c6c986d96c3e", "message": "Merge revert of 11560\n\nupdate jaxws-2.3 to expose APIs to APP classpath\n\nRevert \"Initial check in of MessageImpl refactoring\"\n\nThis reverts commit f9cdd9d131c2b75cd3739583c266dcb0e5140e62.\n\nFix issues caused by revert\n\nadd addition change required\n\nundo local merge issue", "committedDate": "2020-09-15T18:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzk1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490407950", "bodyText": "Can we delete this overlay file?  I think you are reverting the only Liberty-specific changes in the file.", "author": "andymc12", "createdAt": "2020-09-17T16:44:19Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/message/MessageUtils.java", "diffHunk": "@@ -101,9 +101,7 @@ public static FaultMode getFaultMode(Message message) {\n      */\n     public static boolean isRequestor(Message message) {\n         if (message != null) {\n-            //Liberty code change start\n-            Boolean requestor = (Boolean)((MessageImpl) message).getRequestorRole();\n-            //Liberty code change end", "originalCommit": "dd70c727e661f983c1d39531aacba7c185d494c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4MzE4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490583184", "bodyText": "@andymc12 turns out LibertyAuthFilter calls MessageUtils.getTargetMethod(Message m, Supplier exceptionSupplier) which on comparing to CXF's master branch is an Liberty specific change. I'm going to re-add MessageUtils for now, let me know if you'd prefer a different solution.", "author": "neuwerk", "createdAt": "2020-09-17T21:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzk1MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNDA5NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490414095", "bodyText": "I don't think this variable is ever used in our overlay of this file.  I think we can delete this line.", "author": "andymc12", "createdAt": "2020-09-17T16:53:42Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java", "diffHunk": "@@ -65,6 +65,7 @@ public ChainInitiationObserver(Endpoint endpoint, Bus bus) {\n     @Override\n     public void onMessage(Message m) {\n         Bus origBus = BusFactory.getAndSetThreadDefaultBus(bus);\n+        ClassLoaderHolder origLoader = null;", "originalCommit": "dd70c727e661f983c1d39531aacba7c185d494c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java b/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java\nindex 151faf617b..9da22872bc 100644\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java\n+++ b/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java\n\n@@ -65,7 +64,7 @@ public class ChainInitiationObserver implements MessageObserver {\n     @Override\n     public void onMessage(Message m) {\n         Bus origBus = BusFactory.getAndSetThreadDefaultBus(bus);\n-        ClassLoaderHolder origLoader = null;\n+\n         try {\n             //no need reset TCClassloader as already set to bus\n //            if (loader != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjg3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490416874", "bodyText": "I think we can delete this overlay file too.", "author": "andymc12", "createdAt": "2020-09-17T16:58:14Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/ext/MessageContextImpl.java", "diffHunk": "@@ -87,7 +87,7 @@ public Object get(Object key) {\n         if (keyValue.equals(\"WRITE-\" + Message.ATTACHMENTS)) {\n             // Liberty Change Start - #5049\n             if (m.getExchange().getOutMessage() != null) {\n-                return ((MessageImpl) m.getExchange().getOutMessage()).getAttachments();\n+                return m.getExchange().getOutMessage().get(Message.ATTACHMENTS);", "originalCommit": "dd70c727e661f983c1d39531aacba7c185d494c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjEzODAxMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r492138011", "bodyText": "Andy this file had changes in it before PR #11560.  Were those already in the latest CXF and the overlay was just not removed when updating to a new version of CXF previously?", "author": "jhanders34", "createdAt": "2020-09-21T15:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjg3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg0OTAyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r492849021", "bodyText": "@andymc12 Jared and I discussed the PRs that introduced changes to MessageContextImpl that would be backed out by deleting this file. There was one NPE check introduced by #5486 that isn't in CXF 3.3.X, but the tests, introduced by that PR, ran and passed. Do you know if it's safe to back out that change as well?", "author": "neuwerk", "createdAt": "2020-09-22T15:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNjg3NA=="}], "type": "inlineReview", "revised_code": {"commit": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/ext/MessageContextImpl.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/ext/MessageContextImpl.java\ndeleted file mode 100644\nindex eedb669fce..0000000000\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/ext/MessageContextImpl.java\n+++ /dev/null\n\n@@ -1,321 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxrs.ext;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.reflect.Type;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-\n-import javax.servlet.ServletConfig;\n-import javax.servlet.ServletContext;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletResponse;\n-import javax.ws.rs.WebApplicationException;\n-import javax.ws.rs.core.HttpHeaders;\n-import javax.ws.rs.core.MediaType;\n-import javax.ws.rs.core.MultivaluedMap;\n-import javax.ws.rs.core.Request;\n-import javax.ws.rs.core.SecurityContext;\n-import javax.ws.rs.core.UriInfo;\n-import javax.ws.rs.ext.ContextResolver;\n-import javax.ws.rs.ext.Providers;\n-\n-import org.apache.cxf.attachment.AttachmentDeserializer;\n-import org.apache.cxf.attachment.AttachmentImpl;\n-import org.apache.cxf.attachment.AttachmentUtil;\n-import org.apache.cxf.attachment.HeaderSizeExceededException;\n-import org.apache.cxf.endpoint.Endpoint;\n-import org.apache.cxf.helpers.CastUtils;\n-import org.apache.cxf.interceptor.AttachmentOutInterceptor;\n-import org.apache.cxf.io.CacheSizeExceededException;\n-import org.apache.cxf.jaxrs.ext.multipart.Attachment;\n-import org.apache.cxf.jaxrs.ext.multipart.MultipartBody;\n-import org.apache.cxf.jaxrs.impl.MetadataMap;\n-import org.apache.cxf.jaxrs.impl.ProvidersImpl;\n-import org.apache.cxf.jaxrs.interceptor.AttachmentInputInterceptor;\n-import org.apache.cxf.jaxrs.interceptor.AttachmentOutputInterceptor;\n-import org.apache.cxf.jaxrs.utils.ExceptionUtils;\n-import org.apache.cxf.jaxrs.utils.JAXRSUtils;\n-import org.apache.cxf.message.Exchange;\n-import org.apache.cxf.message.ExchangeImpl;\n-import org.apache.cxf.message.Message;\n-import org.apache.cxf.message.MessageImpl;\n-import org.apache.cxf.message.MessageUtils;\n-\n-public class MessageContextImpl implements MessageContext {\n-\n-    private Message m;\n-    public MessageContextImpl(Message m) {\n-        this.m = m;\n-    }\n-\n-    public Object get(Object key) {\n-        String keyValue = key.toString();\n-        if (MultipartBody.INBOUND_MESSAGE_ATTACHMENTS.equals(keyValue)\n-            || (MultipartBody.INBOUND_MESSAGE_ATTACHMENTS + \".embedded\").equals(keyValue)) {\n-            try {\n-                return createAttachments(key.toString());\n-            } catch (CacheSizeExceededException e) {\n-                m.getExchange().put(\"cxf.io.cacheinput\", Boolean.FALSE);\n-                throw new WebApplicationException(e, 413);\n-            } catch (HeaderSizeExceededException e) {\n-                throw new WebApplicationException(e, 413);\n-            }\n-        }\n-        if (keyValue.equals(\"WRITE-\" + Message.ATTACHMENTS)) {\n-            // Liberty Change Start - #5049\n-            if (m.getExchange().getOutMessage() != null) {\n-                return m.getExchange().getOutMessage().get(Message.ATTACHMENTS);\n-            }\n-            // Liberty Change End\n-        }\n-\n-        Message currentMessage = getCurrentMessage();\n-        Object value = currentMessage.get(key);\n-        if (value == null) {\n-            if (Message.class.getName().equals(key)) {\n-                return currentMessage;\n-            }\n-            Exchange exchange = currentMessage.getExchange();\n-            if (exchange != null) {\n-                Message otherMessage = exchange.getInMessage() == currentMessage\n-                    ? exchange.getOutMessage() : exchange.getInMessage();\n-                if (otherMessage != null) {\n-                    value = otherMessage.get(key);\n-                }\n-                if (value == null) {\n-                    value = m.getExchange().get(key);\n-                }\n-            }\n-        }\n-        return value;\n-    }\n-\n-    private Message getCurrentMessage() {\n-        Message currentMessage = JAXRSUtils.getCurrentMessage();\n-        if (currentMessage == null) {\n-            currentMessage = m;\n-        }\n-        return currentMessage;\n-    }\n-\n-    public <T> T getContent(Class<T> format) {\n-        if (MessageUtils.isRequestor(m) && m.getExchange().getInMessage() != null) {\n-            Message inMessage = m.getExchange().getInMessage();\n-            return inMessage.getContent(format);\n-        }\n-        return m.getContent(format);\n-    }\n-\n-    public Object getContextualProperty(Object key) {\n-        Object value = m.getContextualProperty(key.toString());\n-        if (value == null && key.getClass() == Class.class) {\n-            return m.getExchange().get((Class<?>)key);\n-        }\n-        return value;\n-    }\n-\n-    public <T> T getContext(Class<T> contextClass) {\n-        return getContext(contextClass, contextClass);\n-    }\n-\n-    protected <T> T getContext(Type genericType, Class<T> clazz) {\n-        return JAXRSUtils.createContextValue(m, genericType, clazz);\n-    }\n-\n-    public <T, E> T getResolver(Class<T> resolverClazz, Class<E> resolveClazz) {\n-        if (ContextResolver.class == resolverClazz) {\n-            return resolverClazz.cast(getContext(resolveClazz, ContextResolver.class));\n-        }\n-        return null;\n-    }\n-\n-    public Request getRequest() {\n-        return getContext(Request.class);\n-    }\n-\n-    public HttpHeaders getHttpHeaders() {\n-        return getContext(HttpHeaders.class);\n-    }\n-\n-    public Providers getProviders() {\n-        return getContext(Providers.class);\n-    }\n-\n-    public SecurityContext getSecurityContext() {\n-        return getContext(SecurityContext.class);\n-    }\n-\n-    public UriInfo getUriInfo() {\n-        return getContext(UriInfo.class);\n-    }\n-\n-    public HttpServletRequest getHttpServletRequest() {\n-        try {\n-            return getContext(HttpServletRequest.class);\n-        } catch (Throwable t) {\n-            return null;\n-        }\n-    }\n-\n-    public HttpServletResponse getHttpServletResponse() {\n-        return getContext(HttpServletResponse.class);\n-    }\n-\n-    public ServletConfig getServletConfig() {\n-        return getContext(ServletConfig.class);\n-    }\n-\n-    public ServletContext getServletContext() {\n-        return getContext(ServletContext.class);\n-    }\n-\n-    public void put(Object key, Object value) {\n-        if (MultipartBody.OUTBOUND_MESSAGE_ATTACHMENTS.equals(key.toString())) {\n-            convertToAttachments(value);\n-        }\n-        Message currentMessage = getCurrentMessage();\n-        currentMessage.put(key.toString(), value);\n-        currentMessage.getExchange().put(key.toString(), value);\n-\n-    }\n-\n-    private void convertToAttachments(Object value) {\n-        List<?> handlers = (List<?>)value;\n-        List<org.apache.cxf.message.Attachment> atts =\n-            new ArrayList<>();\n-\n-        for (int i = 1; i < handlers.size(); i++) {\n-            Attachment handler = (Attachment)handlers.get(i);\n-            AttachmentImpl att = new AttachmentImpl(handler.getContentId(), handler.getDataHandler());\n-            for (String key : handler.getHeaders().keySet()) {\n-                att.setHeader(key, handler.getHeader(key));\n-            }\n-            att.setXOP(false);\n-            atts.add(att);\n-        }\n-        Message outMessage = getOutMessage();\n-        outMessage.setAttachments(atts);\n-        outMessage.put(AttachmentOutInterceptor.WRITE_ATTACHMENTS, \"true\");\n-        Attachment root = (Attachment)handlers.get(0);\n-\n-        String rootContentType = root.getContentType().toString();\n-        MultivaluedMap<String, String> rootHeaders = new MetadataMap<>(root.getHeaders());\n-        if (!AttachmentUtil.isMtomEnabled(outMessage)) {\n-            rootHeaders.putSingle(Message.CONTENT_TYPE, rootContentType);\n-        }\n-\n-        String messageContentType = outMessage.get(Message.CONTENT_TYPE).toString();\n-        int index = messageContentType.indexOf(\";type\");\n-        if (index > 0) {\n-            messageContentType = messageContentType.substring(0, index).trim();\n-        }\n-        AttachmentOutputInterceptor attInterceptor =\n-            new AttachmentOutputInterceptor(messageContentType, rootHeaders);\n-\n-        outMessage.put(Message.CONTENT_TYPE, rootContentType);\n-        Map<String, List<String>> allHeaders =\n-            CastUtils.cast((Map<?, ?>)outMessage.get(Message.PROTOCOL_HEADERS));\n-        if (allHeaders != null) {\n-            allHeaders.remove(Message.CONTENT_TYPE);\n-        }\n-        attInterceptor.handleMessage(outMessage);\n-    }\n-\n-    private Message getOutMessage() {\n-\n-        Message message = m.getExchange().getOutMessage();\n-        if (message == null) {\n-            Endpoint ep = m.getExchange().getEndpoint();\n-            message = new org.apache.cxf.message.MessageImpl();\n-            message.setExchange(m.getExchange());\n-            message = ep.getBinding().createMessage(message);\n-            m.getExchange().setOutMessage(message);\n-        }\n-\n-        return message;\n-    }\n-\n-    private MultipartBody createAttachments(String propertyName) {\n-        Message inMessage = m.getExchange().getInMessage();\n-        boolean embeddedAttachment = inMessage.get(\"org.apache.cxf.multipart.embedded\") != null;\n-\n-        Object o = inMessage.get(propertyName);\n-        if (o != null) {\n-            return (MultipartBody)o;\n-        }\n-\n-        if (embeddedAttachment) {\n-            inMessage = new MessageImpl();\n-            inMessage.setExchange(new ExchangeImpl());\n-            inMessage.put(AttachmentDeserializer.ATTACHMENT_DIRECTORY,\n-                m.getExchange().getInMessage().get(AttachmentDeserializer.ATTACHMENT_DIRECTORY));\n-            inMessage.put(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD,\n-                m.getExchange().getInMessage().get(AttachmentDeserializer.ATTACHMENT_MEMORY_THRESHOLD));\n-            inMessage.put(AttachmentDeserializer.ATTACHMENT_MAX_SIZE,\n-                m.getExchange().getInMessage().get(AttachmentDeserializer.ATTACHMENT_MAX_SIZE));\n-            inMessage.put(AttachmentDeserializer.ATTACHMENT_MAX_HEADER_SIZE,\n-                m.getExchange().getInMessage().get(AttachmentDeserializer.ATTACHMENT_MAX_HEADER_SIZE));\n-            inMessage.setContent(InputStream.class,\n-                m.getExchange().getInMessage().get(\"org.apache.cxf.multipart.embedded.input\"));\n-            inMessage.put(Message.CONTENT_TYPE,\n-                m.getExchange().getInMessage().get(\"org.apache.cxf.multipart.embedded.ctype\").toString());\n-        }\n-\n-\n-        new AttachmentInputInterceptor().handleMessage(inMessage);\n-\n-        List<Attachment> newAttachments = new LinkedList<>();\n-        try {\n-            Map<String, List<String>> headers\n-                = CastUtils.cast((Map<?, ?>)inMessage.get(AttachmentDeserializer.ATTACHMENT_PART_HEADERS));\n-\n-            Attachment first = new Attachment(AttachmentUtil.createAttachment(\n-                                     inMessage.getContent(InputStream.class),\n-                                     headers),\n-                                     new ProvidersImpl(inMessage));\n-            newAttachments.add(first);\n-        } catch (IOException ex) {\n-            throw ExceptionUtils.toInternalServerErrorException(ex, null);\n-        }\n-\n-\n-        Collection<org.apache.cxf.message.Attachment> childAttachments = inMessage.getAttachments();\n-        if (childAttachments == null) {\n-            childAttachments = Collections.emptyList();\n-        }\n-        childAttachments.size();\n-        for (org.apache.cxf.message.Attachment a : childAttachments) {\n-            newAttachments.add(new Attachment(a, new ProvidersImpl(inMessage)));\n-        }\n-        MediaType mt = embeddedAttachment\n-            ? (MediaType)inMessage.get(\"org.apache.cxf.multipart.embedded.ctype\")\n-            : getHttpHeaders().getMediaType();\n-        MultipartBody body = new MultipartBody(newAttachments, mt, false);\n-        inMessage.put(propertyName, body);\n-        return body;\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ5NTgyNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490495826", "bodyText": "We can't delete this file (yet) because we still need the public MessageImpl(int isize, float factor) constructor - though I plan to contribute that back to the CXF community as soon as possible.", "author": "andymc12", "createdAt": "2020-09-17T19:16:33Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/message/MessageImpl.java", "diffHunk": "@@ -68,116 +43,13 @@\n     private Object[] contents = new Object[20];\n     private int index;\n \n-    //Liberty code change start\n-    private static int contentType = 0;\n-    private static int protoHeaders = 1;\n-    private static int queryString = 2;\n-    private static int httpRequest = 3;\n-    private static int httpResponse = 4;\n-    private static int pathToMatchSlash = 5;\n-    private static int httpRequestMethod = 6;\n-    private static int interceptorProviders = 7;\n-    private static int templateParameters = 8;\n-    private static int accept = 9;\n-    private static int continuationProvider = 10;\n-    private static int destination = 11;\n-    private static int opStack = 12;\n-    private static int wsdlDescription = 13;\n-    private static int wsdlInterface = 14;\n-    private static int wsdlOperation = 15;\n-    private static int wsdlPort = 16;\n-    private static int wsdlService = 17;\n-    private static int requestUrl = 18;\n-    private static int requestUri = 19;\n-    private static int pathInfo = 20;\n-    private static int basePath = 21;\n-    private static int fixedParamOrder = 22;\n-    private static int inInterceptors = 23;\n-    private static int outInterceptors = 24;\n-    private static int responseCode = 25;\n-    private static int attachments = 26;\n-    private static int encoding = 27;\n-    private static int httpContext = 28;\n-    private static int httpConfig = 29;\n-    private static int httpContextMatchStrategy = 30;\n-    private static int httpBasePath = 31;\n-    private static int asyncPostDispatch = 32;\n-    private static int securityContext = 33;\n-    private static int authorizationPolicy = 34;\n-    private static int certConstraints = 35;\n-    private static int serviceRedirection = 36;\n-    private static int httpServletResponse = 37;\n-    private static int resourceMethod = 38;\n-    private static int oneWayRequest = 39;\n-    private static int asyncResponse = 40;\n-    private static int threadContextSwitched = 41;\n-    private static int cacheInputProperty = 42;\n-    private static int previousMessage = 43;\n-    private static int responseHeadersCopied = 44;\n-    private static int sseEventSink = 45;\n-    private static int requestorRole = 46;\n-    private static int partialResponse = 47;\n-    private static int emptyPartialResponse = 48;\n-    private static int endpointAddress = 49;\n-    private static int inboundMessage = 50;\n-    private static int TOTAL = 51;\n-    private Object[] propertyValues = new Object[TOTAL];\n-    \n-    private static final String REQUEST_PATH_TO_MATCH_SLASH = \"path_to_match_slash\";\n-    private static final String TEMPLATE_PARAMETERS = \"jaxrs.template.parameters\";\n-    private static final String CONTINUATION_PROVIDER = ContinuationProvider.class.getName();\n-    private static final String DESTINATION = Destination.class.getName();\n-    private static final String OP_RES_INFO_STACK = \"org.apache.cxf.jaxrs.model.OperationResourceInfoStack\";\n-    private static final String HTTP_BASE_PATH = \"http.base.path\";\n-    private static final String SECURITY_CONTEXT = SecurityContext.class.getName();\n-    private static final String AUTHORIZATION_POLICY = AuthorizationPolicy.class.getName();\n-    private static final String CERT_CONSTRAINTS = CertConstraints.class.getName();\n-    private static final String HTTP_SERVLET_RESPONSE = HttpServletResponse.class.getName();\n-    private static final String RESOURCE_METHOD = \"org.apache.cxf.resource.method\";\n-    private static final String ASYNC_RESPONSE = \"javax.ws.rs.container.AsyncResponse\";\n-    private static final String SSE_EVENT_SINK = \"javax.ws.rs.sse.SseEventSink\";\n-    private static final Map<String, Integer> KEYMAP;\n-    private static final String[] propertyNames = { CONTENT_TYPE, PROTOCOL_HEADERS, QUERY_STRING, AbstractHTTPDestination.HTTP_REQUEST,\n-                    AbstractHTTPDestination.HTTP_RESPONSE, REQUEST_PATH_TO_MATCH_SLASH, HTTP_REQUEST_METHOD, INTERCEPTOR_PROVIDERS,\n-                    TEMPLATE_PARAMETERS, ACCEPT_CONTENT_TYPE, CONTINUATION_PROVIDER, DESTINATION, OP_RES_INFO_STACK, WSDL_DESCRIPTION,\n-                    WSDL_INTERFACE, WSDL_OPERATION, WSDL_PORT, WSDL_SERVICE, REQUEST_URL, REQUEST_URI, PATH_INFO, BASE_PATH,\n-                    FIXED_PARAMETER_ORDER, IN_INTERCEPTORS, OUT_INTERCEPTORS, RESPONSE_CODE, ATTACHMENTS, ENCODING,\n-                    AbstractHTTPDestination.HTTP_CONTEXT, AbstractHTTPDestination.HTTP_CONFIG, AbstractHTTPDestination.HTTP_CONTEXT_MATCH_STRATEGY,\n-                    HTTP_BASE_PATH, ASYNC_POST_RESPONSE_DISPATCH, SECURITY_CONTEXT, AUTHORIZATION_POLICY, CERT_CONSTRAINTS,\n-                    AbstractHTTPDestination.SERVICE_REDIRECTION, HTTP_SERVLET_RESPONSE, RESOURCE_METHOD, ONE_WAY_REQUEST, ASYNC_RESPONSE,\n-                    THREAD_CONTEXT_SWITCHED, OutgoingChainInterceptor.CACHE_INPUT_PROPERTY, PhaseInterceptorChain.PREVIOUS_MESSAGE,\n-                    AbstractHTTPDestination.RESPONSE_HEADERS_COPIED, SSE_EVENT_SINK, REQUESTOR_ROLE, PARTIAL_RESPONSE_MESSAGE,\n-                    EMPTY_PARTIAL_RESPONSE_MESSAGE, ENDPOINT_ADDRESS, INBOUND_MESSAGE };\n-\n-    private static final Object NOT_FOUND = new Object();\n-    private static final Integer KEY_NOT_FOUND = Integer.valueOf(-1);\n-\n-    private Collection<Object> values = null;\n-    private Set<String> keySet = null;\n-    private Set<Map.Entry<String, Object>> entrySet = null;\n-    private static final Object[] NOT_SET_ARRAY = new Object[TOTAL];\n-    static {\n-        Map<String, Integer> keymap = new HashMap<String, Integer>(TOTAL);\n-        for (int i = 0; i < TOTAL; i++) {\n-            keymap.put(propertyNames[i], i);\n-            NOT_SET_ARRAY[i] = NOT_FOUND;\n-        }\n-        KEYMAP = Collections.unmodifiableMap(keymap);\n-    }\n-    //Liberty code change end\n-\n     // Liberty change - used to avoid resize\n     public MessageImpl(int isize, float factor) {", "originalCommit": "dd70c727e661f983c1d39531aacba7c185d494c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUwNTM1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490505357", "bodyText": "We can delete this overlay file - the only other changes to it have been made in CXF (and only really apply if we have the file in our source tree anyway).", "author": "andymc12", "createdAt": "2020-09-17T19:28:01Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.service.description.3.2/src/org/apache/cxf/jaxrs/model/wadl/WadlGenerator.java", "diffHunk": "@@ -219,9 +219,7 @@ public void filter(ContainerRequestContext context) {\n     }\n \n     protected void doFilter(ContainerRequestContext context, Message m) {\n-        //Liberty code change start\n-        if (!\"GET\".equals(((MessageImpl) m).getHttpRequestMethod())) {\n-            //Liberty code change end\n+        if (!\"GET\".equals(m.get(Message.HTTP_REQUEST_METHOD))) {", "originalCommit": "dd70c727e661f983c1d39531aacba7c185d494c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.service.description.3.2/src/org/apache/cxf/jaxrs/model/wadl/WadlGenerator.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.service.description.3.2/src/org/apache/cxf/jaxrs/model/wadl/WadlGenerator.java\ndeleted file mode 100644\nindex e5601b5c70..0000000000\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.service.description.3.2/src/org/apache/cxf/jaxrs/model/wadl/WadlGenerator.java\n+++ /dev/null\n\n@@ -1,2331 +0,0 @@\n-/**\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements. See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership. The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at\n- *\n- * http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.cxf.jaxrs.model.wadl;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.StringReader;\n-import java.io.StringWriter;\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.lang.reflect.Type;\n-import java.lang.reflect.TypeVariable;\n-import java.net.URI;\n-import java.net.URL;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.IdentityHashMap;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.logging.Logger;\n-\n-import javax.servlet.ServletRequest;\n-import javax.ws.rs.BeanParam;\n-import javax.ws.rs.DefaultValue;\n-import javax.ws.rs.Encoded;\n-import javax.ws.rs.FormParam;\n-import javax.ws.rs.HeaderParam;\n-import javax.ws.rs.MatrixParam;\n-import javax.ws.rs.PathParam;\n-import javax.ws.rs.QueryParam;\n-import javax.ws.rs.container.AsyncResponse;\n-import javax.ws.rs.container.ContainerRequestContext;\n-import javax.ws.rs.container.ContainerRequestFilter;\n-import javax.ws.rs.core.HttpHeaders;\n-import javax.ws.rs.core.MediaType;\n-import javax.ws.rs.core.MultivaluedMap;\n-import javax.ws.rs.core.Response;\n-import javax.ws.rs.core.UriBuilder;\n-import javax.ws.rs.core.UriInfo;\n-import javax.ws.rs.ext.MessageBodyWriter;\n-import javax.xml.bind.JAXBContext;\n-import javax.xml.bind.annotation.XmlRootElement;\n-import javax.xml.bind.annotation.XmlSeeAlso;\n-import javax.xml.bind.annotation.XmlType;\n-import javax.xml.datatype.XMLGregorianCalendar;\n-import javax.xml.namespace.QName;\n-import javax.xml.parsers.ParserConfigurationException;\n-import javax.xml.stream.XMLStreamException;\n-import javax.xml.stream.XMLStreamWriter;\n-import javax.xml.transform.Source;\n-import javax.xml.transform.Transformer;\n-import javax.xml.transform.TransformerFactory;\n-import javax.xml.transform.dom.DOMResult;\n-import javax.xml.transform.dom.DOMSource;\n-import javax.xml.transform.stream.StreamResult;\n-import javax.xml.transform.stream.StreamSource;\n-\n-import org.w3c.dom.Document;\n-import org.w3c.dom.Element;\n-import org.w3c.dom.Node;\n-import org.w3c.dom.ProcessingInstruction;\n-\n-import org.apache.cxf.Bus;\n-import org.apache.cxf.BusFactory;\n-import org.apache.cxf.common.jaxb.JAXBBeanInfo;\n-import org.apache.cxf.common.jaxb.JAXBContextProxy;\n-import org.apache.cxf.common.jaxb.JAXBUtils;\n-import org.apache.cxf.common.logging.LogUtils;\n-import org.apache.cxf.common.util.PackageUtils;\n-import org.apache.cxf.common.util.PropertyUtils;\n-import org.apache.cxf.common.util.StringUtils;\n-import org.apache.cxf.common.util.XmlSchemaPrimitiveUtils;\n-import org.apache.cxf.common.xmlschema.SchemaCollection;\n-import org.apache.cxf.endpoint.Endpoint;\n-import org.apache.cxf.helpers.CastUtils;\n-import org.apache.cxf.helpers.DOMUtils;\n-import org.apache.cxf.helpers.IOUtils;\n-import org.apache.cxf.jaxrs.JAXRSServiceImpl;\n-import org.apache.cxf.jaxrs.ext.Oneway;\n-import org.apache.cxf.jaxrs.ext.ResponseStatus;\n-import org.apache.cxf.jaxrs.ext.multipart.Multipart;\n-import org.apache.cxf.jaxrs.ext.xml.XMLName;\n-import org.apache.cxf.jaxrs.ext.xml.XMLSource;\n-import org.apache.cxf.jaxrs.impl.HttpHeadersImpl;\n-import org.apache.cxf.jaxrs.impl.MetadataMap;\n-import org.apache.cxf.jaxrs.model.ClassResourceInfo;\n-import org.apache.cxf.jaxrs.model.OperationResourceInfo;\n-import org.apache.cxf.jaxrs.model.Parameter;\n-import org.apache.cxf.jaxrs.model.ParameterType;\n-import org.apache.cxf.jaxrs.model.ResourceTypes;\n-import org.apache.cxf.jaxrs.model.URITemplate;\n-import org.apache.cxf.jaxrs.model.doc.DocumentationProvider;\n-import org.apache.cxf.jaxrs.model.doc.JavaDocProvider;\n-import org.apache.cxf.jaxrs.provider.ServerProviderFactory;\n-import org.apache.cxf.jaxrs.utils.AnnotationUtils;\n-import org.apache.cxf.jaxrs.utils.ExceptionUtils;\n-import org.apache.cxf.jaxrs.utils.InjectionUtils;\n-import org.apache.cxf.jaxrs.utils.JAXRSUtils;\n-import org.apache.cxf.jaxrs.utils.ResourceUtils;\n-import org.apache.cxf.jaxrs.utils.schemas.SchemaHandler;\n-import org.apache.cxf.message.Message;\n-import org.apache.cxf.message.MessageImpl;\n-import org.apache.cxf.service.model.EndpointInfo;\n-import org.apache.cxf.staxutils.DelegatingXMLStreamWriter;\n-import org.apache.cxf.staxutils.StaxUtils;\n-import org.apache.ws.commons.schema.XmlSchema;\n-import org.apache.ws.commons.schema.constants.Constants;\n-\n-public class WadlGenerator implements ContainerRequestFilter {\n-\n-    public static final String WADL_QUERY = \"_wadl\";\n-    public static final MediaType WADL_TYPE = JAXRSUtils.toMediaType(\"application/vnd.sun.wadl+xml\");\n-    public static final String WADL_NS = \"http://wadl.dev.java.net/2009/02\";\n-    public static final String DEFAULT_WADL_SCHEMA_LOC = \"http://www.w3.org/Submission/wadl/wadl.xsd\";\n-\n-    private static final Logger LOG = LogUtils.getL7dLogger(WadlGenerator.class);\n-    private static final String CONVERT_WADL_RESOURCES_TO_DOM = \"convert.wadl.resources.to.dom\";\n-    private static final String XLS_NS = \"http://www.w3.org/1999/XSL/Transform\";\n-    private static final String JAXB_DEFAULT_NAMESPACE = \"##default\";\n-    private static final String JAXB_DEFAULT_NAME = \"##default\";\n-    private static final String CLASSPATH_PREFIX = \"classpath:\";\n-    private static final String DEFAULT_NS_PREFIX = \"prefix\";\n-    private static final Map<ParameterType, Class<? extends Annotation>> PARAMETER_TYPE_MAP;\n-    static {\n-        PARAMETER_TYPE_MAP = new HashMap<>();\n-        PARAMETER_TYPE_MAP.put(ParameterType.FORM, FormParam.class);\n-        PARAMETER_TYPE_MAP.put(ParameterType.QUERY, QueryParam.class);\n-        PARAMETER_TYPE_MAP.put(ParameterType.HEADER, HeaderParam.class);\n-        PARAMETER_TYPE_MAP.put(ParameterType.PATH, PathParam.class);\n-        PARAMETER_TYPE_MAP.put(ParameterType.MATRIX, MatrixParam.class);\n-    }\n-\n-    private String wadlNamespace;\n-\n-    private boolean singleResourceMultipleMethods = true;\n-    private boolean useSingleSlashResource;\n-    private boolean ignoreForwardSlash;\n-    private boolean linkAnyMediaTypeToXmlSchema;\n-    private boolean useJaxbContextForQnames = true;\n-    private boolean supportCollections = true;\n-    private boolean supportJaxbXmlType = true;\n-    private boolean supportJaxbSubstitutions = true;\n-    private boolean ignoreOverloadedMethods;\n-    private boolean checkAbsolutePathSlash;\n-    private boolean keepRelativeDocLinks;\n-    private boolean usePathParamsToCompareOperations = true;\n-    private boolean incrementNamespacePrefix = true;\n-\n-    private boolean ignoreMessageWriters = true;\n-    private boolean ignoreRequests;\n-    private boolean convertResourcesToDOM = true;\n-    private String wadlSchemaLocation;\n-    private List<String> externalSchemasCache;\n-    private List<URI> externalSchemaLinks;\n-    private Map<String, List<String>> externalQnamesMap;\n-\n-    private final ConcurrentHashMap<String, String> docLocationMap = new ConcurrentHashMap<>();\n-\n-    private ElementQNameResolver resolver;\n-    private List<String> privateAddresses;\n-    private List<String> allowList; // Liberty change\n-    private String applicationTitle;\n-    private String nsPrefix = DEFAULT_NS_PREFIX;\n-    private MediaType defaultWadlResponseMediaType = MediaType.APPLICATION_XML_TYPE;\n-    private final MediaType defaultRepMediaType = MediaType.WILDCARD_TYPE;\n-    private String stylesheetReference;\n-    private boolean applyStylesheetLocally;\n-    private Bus bus;\n-    private final List<DocumentationProvider> docProviders = new LinkedList<>();\n-    private ResourceIdGenerator idGenerator;\n-    private Map<String, Object> jaxbContextProperties;\n-\n-    public WadlGenerator() {\n-    }\n-\n-    public WadlGenerator(Bus bus) {\n-        this.bus = bus;\n-        this.bus.setProperty(\"wadl.service.description.available\", \"true\");\n-    }\n-\n-    @Override\n-    public void filter(ContainerRequestContext context) {\n-        Message m = JAXRSUtils.getCurrentMessage();\n-        if (m == null) {\n-            return;\n-        }\n-        doFilter(context, m);\n-    }\n-\n-    protected void doFilter(ContainerRequestContext context, Message m) {\n-        if (!\"GET\".equals(m.get(Message.HTTP_REQUEST_METHOD))) {\n-            return;\n-        }\n-\n-        UriInfo ui = context.getUriInfo();\n-        if (!ui.getQueryParameters().containsKey(WADL_QUERY)) {\n-            if (stylesheetReference != null || !docLocationMap.isEmpty()) {\n-                String path = ui.getPath(false);\n-                if (path.startsWith(\"/\") && path.length() > 0) {\n-                    path = path.substring(1);\n-                }\n-                if (stylesheetReference != null && path.endsWith(\".xsl\")\n-                    || docLocationMap.containsKey(path)) {\n-                    context.abortWith(getExistingResource(m, ui, path));\n-                }\n-            }\n-            return;\n-        }\n-\n-        if (ignoreRequests) {\n-            context.abortWith(Response.status(404).build());\n-            return;\n-        }\n-\n-        if (allowList != null && !allowList.isEmpty()) { //Liberty change\n-            ServletRequest servletRequest = (ServletRequest)m.getContextualProperty(\n-                \"HTTP.REQUEST\");\n-            String remoteAddress = null;\n-            if (servletRequest != null) {\n-                remoteAddress = servletRequest.getRemoteAddr();\n-            } else {\n-                remoteAddress = \"\";\n-            }\n-            boolean foundMatch = false;\n-            for (String addr : allowList) { //Liberty change\n-                if (addr.equals(remoteAddress)) {\n-                    foundMatch = true;\n-                    break;\n-                }\n-            }\n-            if (!foundMatch) {\n-                context.abortWith(Response.status(404).build());\n-                return;\n-            }\n-        }\n-\n-        HttpHeaders headers = new HttpHeadersImpl(m);\n-        List<MediaType> accepts = headers.getAcceptableMediaTypes();\n-        MediaType type = accepts.contains(WADL_TYPE) ? WADL_TYPE : accepts\n-            .contains(MediaType.APPLICATION_JSON_TYPE) ? MediaType.APPLICATION_JSON_TYPE\n-                : defaultWadlResponseMediaType;\n-\n-        Response response = getExistingWadl(m, ui, type);\n-        if (response != null) {\n-            context.abortWith(response);\n-            return;\n-        }\n-\n-        boolean isJson = isJson(type);\n-\n-        StringBuilder sbMain = generateWADL(getBaseURI(m, ui), getResourcesList(m, ui), isJson, m, ui);\n-\n-        m.getExchange().put(JAXRSUtils.IGNORE_MESSAGE_WRITERS, !isJson && ignoreMessageWriters);\n-        Response r = Response.ok().type(type).entity(createResponseEntity(m, ui, sbMain.toString(), isJson)).build();\n-        context.abortWith(r);\n-    }\n-    private boolean isJson(MediaType mt) {\n-        return mt == MediaType.APPLICATION_JSON_TYPE;\n-    }\n-    private String getStylesheetInstructionData(String baseURI) {\n-        String theStylesheetReference = stylesheetReference;\n-        if (!keepRelativeDocLinks) {\n-            theStylesheetReference = UriBuilder.fromUri(baseURI)\n-                .path(theStylesheetReference).build().toString();\n-        }\n-        return \"type=\\\"text/xsl\\\" href=\\\"\" + theStylesheetReference + \"\\\"\";\n-    }\n-    public StringBuilder generateWADL(String baseURI,\n-                                       List<ClassResourceInfo> cris,\n-                                       boolean isJson,\n-                                       Message m,\n-                                       UriInfo ui) {\n-        StringBuilder sbMain = new StringBuilder(64);\n-        if (!isJson && stylesheetReference != null && !applyStylesheetLocally) {\n-            sbMain.append(\"<?xml-stylesheet \").append(getStylesheetInstructionData(baseURI)).append(\"?>\");\n-        }\n-        sbMain.append(\"<application\");\n-        if (!isJson) {\n-            sbMain.append(\" xmlns=\\\"\").append(getNamespace()).append(\"\\\" xmlns:xs=\\\"\")\n-                .append(Constants.URI_2001_SCHEMA_XSD).append('\"');\n-        }\n-        StringBuilder sbGrammars = new StringBuilder(32);\n-        sbGrammars.append(\"<grammars>\");\n-\n-        StringBuilder sbResources = new StringBuilder(64);\n-        sbResources.append(\"<resources base=\\\"\").append(baseURI).append(\"\\\">\");\n-\n-\n-        MessageBodyWriter<?> jaxbWriter = (m != null && useJaxbContextForQnames)\n-            ? ServerProviderFactory.getInstance(m).getDefaultJaxbWriter() : null;\n-        ResourceTypes resourceTypes = ResourceUtils.getAllRequestResponseTypes(cris,\n-                                                                               useJaxbContextForQnames,\n-                                                                               jaxbWriter);\n-        checkXmlSeeAlso(resourceTypes);\n-        Set<Class<?>> allTypes = resourceTypes.getAllTypes().keySet();\n-\n-\n-        JAXBContext jaxbContext = null;\n-        if (useJaxbContextForQnames && !allTypes.isEmpty()) {\n-            jaxbContext = org.apache.cxf.jaxrs.utils.JAXBUtils\n-                    .createJaxbContext(new HashSet<>(allTypes), null, jaxbContextProperties);\n-            if (jaxbContext == null) {\n-                LOG.warning(\"JAXB Context is null: possibly due to one of input classes being not accepted\");\n-            }\n-        }\n-\n-        SchemaWriter schemaWriter = createSchemaWriter(resourceTypes, jaxbContext, ui);\n-        ElementQNameResolver qnameResolver = schemaWriter == null\n-            ? null : createElementQNameResolver(jaxbContext);\n-\n-        Map<Class<?>, QName> clsMap = new IdentityHashMap<>();\n-        Set<ClassResourceInfo> visitedResources = new LinkedHashSet<>();\n-        for (ClassResourceInfo cri : cris) {\n-            startResourceTag(sbResources, cri, cri.getURITemplate().getValue());\n-\n-            Annotation description = AnnotationUtils.getClassAnnotation(cri.getServiceClass(), Description.class);\n-            if (description == null) {\n-                description = AnnotationUtils.getClassAnnotation(cri.getServiceClass(), Descriptions.class);\n-            }\n-            if (description != null) {\n-                handleDocs(new Annotation[] {description}, sbResources, DocTarget.RESOURCE, true, isJson);\n-            } else {\n-                handleClassJavaDocs(cri, sbResources);\n-            }\n-            handleResource(sbResources, allTypes, qnameResolver, clsMap, cri, visitedResources, isJson);\n-            sbResources.append(\"</resource>\");\n-        }\n-        sbResources.append(\"</resources>\");\n-\n-        handleGrammars(sbMain, sbGrammars, schemaWriter, clsMap);\n-\n-        sbGrammars.append(\"</grammars>\");\n-        sbMain.append('>');\n-        handleApplicationDocs(sbMain);\n-        sbMain.append(sbGrammars.toString());\n-        sbMain.append(sbResources.toString());\n-        sbMain.append(\"</application>\");\n-        return sbMain;\n-    }\n-\n-    private Object createResponseEntity(Message m, UriInfo ui, String entity, boolean isJson) {\n-        try {\n-            if (!isJson) {\n-                if (stylesheetReference != null && applyStylesheetLocally) {\n-                    return transformLocally(m, ui, new StreamSource(new StringReader(entity)));\n-                }\n-                return entity;\n-            }\n-            return StaxUtils.read(new StringReader(entity));\n-        } catch (Exception ex) {\n-            throw ExceptionUtils.toInternalServerErrorException(ex, null);\n-        }\n-    }\n-\n-    protected String getBaseURI(Message m, UriInfo ui) {\n-        EndpointInfo ei = m.getExchange().getEndpoint().getEndpointInfo();\n-        String publishedEndpointUrl = (String)ei.getProperty(\"publishedEndpointUrl\");\n-        if (publishedEndpointUrl == null) {\n-            return ui.getBaseUri().toString();\n-        }\n-        return publishedEndpointUrl;\n-    }\n-\n-    protected void handleGrammars(StringBuilder sbApp, StringBuilder sbGrammars, SchemaWriter writer,\n-                                  Map<Class<?>, QName> clsMap) {\n-        if (writer == null) {\n-            return;\n-        }\n-\n-        Map<String, String> map = new HashMap<>();\n-        for (QName qname : clsMap.values()) {\n-            map.put(qname.getPrefix(), qname.getNamespaceURI());\n-        }\n-        for (Map.Entry<String, String> entry : map.entrySet()) {\n-            sbApp.append(\" xmlns:\").append(entry.getKey()).append(\"=\\\"\").append(entry.getValue())\n-                .append('\"');\n-        }\n-\n-        if (wadlSchemaLocation != null) {\n-            sbApp.append(\" xmlns:xsi=\\\"\").append(Constants.URI_2001_SCHEMA_XSI).append('\"');\n-            sbApp.append(\" xsi:schemaLocation=\\\"\")\n-                 .append(getNamespace()).append(' ').append(wadlSchemaLocation)\n-                 .append('\"');\n-        }\n-\n-        writer.write(sbGrammars);\n-    }\n-\n-    protected void handleResource(StringBuilder sb, Set<Class<?>> jaxbTypes,\n-                                  ElementQNameResolver qnameResolver, Map<Class<?>, QName> clsMap,\n-                                  ClassResourceInfo cri, Set<ClassResourceInfo> visitedResources,\n-                                  boolean isJson) {\n-        visitedResources.add(cri);\n-        Map<Parameter, Object> classParams = getClassParameters(cri);\n-\n-        List<OperationResourceInfo> sortedOps = sortOperationsByPath(cri.getMethodDispatcher()\n-            .getOperationResourceInfos());\n-\n-        boolean resourceTagOpened = false;\n-        for (int i = 0; i < sortedOps.size(); i++) {\n-            OperationResourceInfo ori = sortedOps.get(i);\n-            if (i > 0 && ignoreOverloadedMethods\n-                && ori.getMethodToInvoke().getName().equals(sortedOps.get(i - 1).getMethodToInvoke().getName())) {\n-                continue;\n-            }\n-            if (ori.getHttpMethod() == null) {\n-                Class<?> cls = getMethod(ori).getReturnType();\n-                ClassResourceInfo subcri = cri.findResource(cls, cls);\n-                if (subcri != null && !visitedResources.contains(subcri)) {\n-                    startResourceTag(sb, subcri, ori.getURITemplate().getValue());\n-                    handleDocs(subcri.getServiceClass().getAnnotations(), sb, DocTarget.RESOURCE, true,\n-                               isJson);\n-                    handlePathAndMatrixParams(sb, ori, isJson);\n-                    handleResource(sb, jaxbTypes, qnameResolver, clsMap, subcri, visitedResources, isJson);\n-                    sb.append(\"</resource>\");\n-                } else {\n-                    handleDynamicSubresource(sb, jaxbTypes, qnameResolver, clsMap, ori, subcri, isJson);\n-                }\n-                continue;\n-            }\n-            OperationResourceInfo nextOp = i + 1 < sortedOps.size() ? sortedOps.get(i + 1) : null;\n-            resourceTagOpened = handleOperation(sb, jaxbTypes, qnameResolver, clsMap, ori, classParams,\n-                                                nextOp, resourceTagOpened, isJson, i);\n-        }\n-    }\n-\n-    private Map<Parameter, Object> getClassParameters(ClassResourceInfo cri) {\n-        Map<Parameter, Object> classParams = new LinkedHashMap<>();\n-        List<Method> paramMethods = cri.getParameterMethods();\n-        for (Method m : paramMethods) {\n-            classParams.put(ResourceUtils.getParameter(0, m.getAnnotations(), m.getParameterTypes()[0]), m);\n-        }\n-        List<Field> fieldParams = cri.getParameterFields();\n-        for (Field f : fieldParams) {\n-            classParams.put(ResourceUtils.getParameter(0, f.getAnnotations(), f.getType()), f);\n-        }\n-        return classParams;\n-    }\n-\n-    protected void startResourceTag(StringBuilder sb, ClassResourceInfo cri, String path) {\n-        sb.append(\"<resource path=\\\"\").append(getPath(path)).append('\"');\n-        if (idGenerator != null) {\n-            String id = idGenerator.getClassResourceId(cri);\n-            sb.append(\" id=\\\"\").append(id).append('\"');\n-        }\n-        sb.append('>');\n-    }\n-\n-    protected String getPath(String path) {\n-        String thePath;\n-        if (ignoreForwardSlash && path.startsWith(\"/\") && path.length() > 0) {\n-            thePath = path.substring(1);\n-        } else {\n-            thePath = path;\n-        }\n-\n-        return xmlEncodeIfNeeded(thePath);\n-    }\n-\n-    private void checkXmlSeeAlso(ResourceTypes resourceTypes) {\n-        if (!this.useJaxbContextForQnames) {\n-            return;\n-        }\n-        List<Class<?>> extraClasses = new LinkedList<>();\n-        for (Class<?> cls : resourceTypes.getAllTypes().keySet()) {\n-            if (!isXmlRoot(cls) || Modifier.isAbstract(cls.getModifiers())) {\n-                XmlSeeAlso seeAlsoAnn = cls.getAnnotation(XmlSeeAlso.class);\n-                if (seeAlsoAnn != null) {\n-                    List<Class<?>> seeAlsoList = CastUtils.cast(Arrays.asList(seeAlsoAnn.value()));\n-                    if (this.supportJaxbSubstitutions) {\n-                        for (Class<?> seeAlsoCls : seeAlsoList) {\n-                            resourceTypes.getSubstitutions().put(seeAlsoCls, cls);\n-                        }\n-                    }\n-                    extraClasses.addAll(seeAlsoList);\n-                }\n-            }\n-        }\n-        for (Class<?> cls : extraClasses) {\n-            resourceTypes.getAllTypes().put(cls, cls);\n-        }\n-    }\n-\n-    private String xmlEncodeIfNeeded(String value) {\n-\n-        StringBuilder builder = new StringBuilder(value.length());\n-        boolean change = false;\n-        for (int x = 0; x < value.length(); x++) {\n-            char ch = value.charAt(x);\n-            String ap = null;\n-            switch (ch) {\n-            case '\\\"':\n-                ap = \"&quot;\";\n-                break;\n-            case '\\'':\n-                ap = \"&apos;\";\n-                break;\n-            case '<':\n-                ap = \"&lt;\";\n-                break;\n-            case '>':\n-                ap = \"&gt;\";\n-                break;\n-            case '&':\n-                ap = \"&amp;\";\n-                break;\n-            default:\n-                ap = null;\n-            }\n-            if (ap != null) {\n-                change = true;\n-                builder.append(ap);\n-            } else {\n-                builder.append(ch);\n-            }\n-        }\n-        return change ? builder.toString() : value;\n-    }\n-\n-    protected void startMethodTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"<method name=\\\"\").append(ori.getHttpMethod()).append('\"');\n-        if (idGenerator != null) {\n-            String id = idGenerator.getMethodResourceId(ori);\n-            sb.append(\" id=\\\"\").append(id).append('\"');\n-        }\n-        sb.append('>');\n-    }\n-    protected void endMethodTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"</method>\");\n-    }\n-    protected void startMethodRequestTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"<request>\");\n-    }\n-    protected void startMethodResponseTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"<response\");\n-    }\n-    protected void endMethodRequestTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"</request>\");\n-    }\n-    protected void endMethodResponseTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"</response>\");\n-    }\n-    protected void startResourceTag(StringBuilder sb, OperationResourceInfo ori, String path) {\n-        sb.append(\"<resource path=\\\"\").append(path).append(\"\\\">\");\n-    }\n-    protected void endResourceTag(StringBuilder sb, OperationResourceInfo ori) {\n-        sb.append(\"</resource>\");\n-    }\n-\n-    // CHECKSTYLE:OFF\n-    protected boolean handleOperation(StringBuilder sb, Set<Class<?>> jaxbTypes, //NOPMD\n-                                      ElementQNameResolver qnameResolver, Map<Class<?>, QName> clsMap,\n-                                      OperationResourceInfo ori, Map<Parameter, Object> classParams,\n-                                      OperationResourceInfo nextOp, boolean resourceTagOpened,\n-                                      boolean isJson, int index) {\n-        Annotation[] anns = getMethod(ori).getAnnotations();\n-        // CHECKSTYLE:ON\n-        boolean samePathOperationFollows = singleResourceMultipleMethods && compareOperations(ori, nextOp);\n-\n-        String path = ori.getURITemplate().getValue();\n-        if (!resourceTagOpened && openResource(path)) {\n-            resourceTagOpened = true;\n-            URITemplate template = ori.getClassResourceInfo().getURITemplate();\n-            if (template != null) {\n-                String parentPath = template.getValue();\n-                if (parentPath.endsWith(\"/\") && path.startsWith(\"/\") && path.length() > 1) {\n-                    path = path.substring(1);\n-                }\n-            }\n-            startResourceTag(sb, ori, getPath(path));\n-            handleDocs(anns, sb, DocTarget.RESOURCE, false, isJson);\n-            handlePathAndMatrixClassParams(ori, sb, classParams, isJson);\n-            handlePathAndMatrixParams(sb, ori, isJson);\n-        } else if (index == 0) {\n-            handlePathAndMatrixClassParams(ori, sb, classParams, isJson);\n-            handlePathAndMatrixParams(sb, ori, isJson);\n-        }\n-\n-        startMethodTag(sb, ori);\n-        if (!handleDocs(anns, sb, DocTarget.METHOD, true, isJson)) {\n-            handleOperJavaDocs(ori, sb);\n-        }\n-        int numOfParams = getMethod(ori).getParameterTypes().length;\n-        if ((numOfParams > 1 || numOfParams == 1 && !ori.isAsync()) || !classParams.isEmpty()) {\n-\n-            startMethodRequestTag(sb, ori);\n-            handleDocs(anns, sb, DocTarget.REQUEST, false, isJson);\n-\n-            boolean isForm = isFormRequest(ori);\n-\n-            doHandleClassParams(ori, sb, classParams, isJson, ParameterType.QUERY, ParameterType.HEADER);\n-            doHandleJaxrsBeanParamClassParams(ori, sb, classParams, isJson,\n-                                              ParameterType.QUERY, ParameterType.HEADER);\n-            for (Parameter p : ori.getParameters()) {\n-                if (isForm && p.getType() == ParameterType.REQUEST_BODY) {\n-                    continue;\n-                }\n-                handleParameter(sb, jaxbTypes, qnameResolver, clsMap, ori, p, isJson);\n-            }\n-            if (isForm) {\n-                handleFormRepresentation(sb, jaxbTypes, qnameResolver, clsMap, ori, getFormClass(ori), isJson);\n-            }\n-            endMethodRequestTag(sb, ori);\n-        }\n-        startMethodResponseTag(sb, ori);\n-        Class<?> returnType = getMethod(ori).getReturnType();\n-        boolean isVoid = void.class == returnType && !ori.isAsync();\n-        ResponseStatus responseStatus = getMethod(ori).getAnnotation(ResponseStatus.class);\n-        if (responseStatus != null) {\n-            setResponseStatus(sb, responseStatus.value());\n-        } else if (isVoid) {\n-            boolean oneway = getMethod(ori).getAnnotation(Oneway.class) != null;\n-            setResponseStatus(sb, oneway ? Response.Status.ACCEPTED : Response.Status.NO_CONTENT);\n-        }\n-        sb.append('>');\n-        handleDocs(anns, sb, DocTarget.RESPONSE, false, isJson);\n-        if (!isVoid) {\n-            handleRepresentation(sb, jaxbTypes, qnameResolver, clsMap, ori, returnType, isJson, false);\n-        }\n-        endMethodResponseTag(sb, ori);\n-\n-        endMethodTag(sb, ori);\n-\n-        if (resourceTagOpened && !samePathOperationFollows) {\n-            endResourceTag(sb, ori);\n-            resourceTagOpened = false;\n-        }\n-        return resourceTagOpened;\n-    }\n-\n-    private void setResponseStatus(StringBuilder sb, Response.Status... statuses) {\n-        sb.append(\" status=\\\"\");\n-        for (int i = 0; i < statuses.length; i++) {\n-            if (i > 0) {\n-                sb.append(' ');\n-            }\n-            sb.append(statuses[i].getStatusCode());\n-        }\n-        sb.append('\"');\n-\n-    }\n-\n-    protected boolean compareOperations(OperationResourceInfo ori1, OperationResourceInfo ori2) {\n-        if (ori1 == null || ori2 == null\n-            || !ori1.getURITemplate().getValue().equals(ori2.getURITemplate().getValue())\n-            || ori1.getHttpMethod() != null && ori2.getHttpMethod() == null || ori2.getHttpMethod() != null\n-            && ori1.getHttpMethod() == null) {\n-            return false;\n-        }\n-        if (usePathParamsToCompareOperations) {\n-            int ori1PathParams = 0;\n-            int ori1MatrixParams = 0;\n-            for (Parameter p : ori1.getParameters()) {\n-                if (p.getType() == ParameterType.PATH) {\n-                    ori1PathParams++;\n-                } else if (p.getType() == ParameterType.MATRIX) {\n-                    ori1MatrixParams++;\n-                }\n-            }\n-\n-            int ori2PathParams = 0;\n-            int ori2MatrixParams = 0;\n-            for (Parameter p : ori2.getParameters()) {\n-                if (p.getType() == ParameterType.PATH) {\n-                    ori2PathParams++;\n-                } else if (p.getType() == ParameterType.MATRIX) {\n-                    ori2MatrixParams++;\n-                }\n-            }\n-\n-            return ori1PathParams == ori2PathParams && ori1MatrixParams == ori2MatrixParams;\n-        }\n-        return true;\n-    }\n-\n-    private boolean openResource(String path) {\n-        if (\"/\".equals(path)) {\n-            return useSingleSlashResource;\n-        }\n-        return true;\n-    }\n-\n-    protected void handleDynamicSubresource(StringBuilder sb, Set<Class<?>> jaxbTypes,\n-                                            ElementQNameResolver qnameResolver, Map<Class<?>, QName> clsMap,\n-                                            OperationResourceInfo ori, ClassResourceInfo subcri,\n-                                            boolean isJson) {\n-        if (!isJson) {\n-            if (subcri != null) {\n-                sb.append(\"<!-- Recursive subresource -->\");\n-            } else {\n-                sb.append(\"<!-- Dynamic subresource -->\");\n-            }\n-        }\n-        startResourceTag(sb, subcri, ori.getURITemplate().getValue());\n-        handlePathAndMatrixParams(sb, ori, isJson);\n-        sb.append(\"</resource>\");\n-    }\n-\n-    protected void handlePathAndMatrixClassParams(OperationResourceInfo ori,\n-                                                  StringBuilder sb,\n-                                                  Map<Parameter, Object> params,\n-                                                  boolean isJson) {\n-        doHandleClassParams(ori, sb, params, isJson, ParameterType.PATH);\n-        doHandleClassParams(ori, sb, params, isJson, ParameterType.MATRIX);\n-        doHandleJaxrsBeanParamClassParams(ori, sb, params, isJson, ParameterType.PATH, ParameterType.MATRIX);\n-    }\n-\n-    protected void doHandleClassParams(OperationResourceInfo ori,\n-                                       StringBuilder sb,\n-                                       Map<Parameter, Object> params,\n-                                       boolean isJson,\n-                                       ParameterType... pType) {\n-        Set<ParameterType> pTypes = new LinkedHashSet<>(Arrays.asList(pType));\n-        for (Map.Entry<Parameter, Object> entry : params.entrySet()) {\n-            Parameter pm = entry.getKey();\n-            Object obj = entry.getValue();\n-            if (pTypes.contains(pm.getType())) {\n-                Class<?> cls = obj instanceof Method ? ((Method)obj).getParameterTypes()[0] : ((Field)obj)\n-                    .getType();\n-                Type type = obj instanceof Method\n-                    ? ((Method)obj).getGenericParameterTypes()[0] : ((Field)obj).getGenericType();\n-                Annotation[] ann = obj instanceof Method\n-                    ? ((Method)obj).getParameterAnnotations()[0] : ((Field)obj).getAnnotations();\n-                doWriteParam(ori, sb, pm, cls, type, pm.getName(), ann, isJson);\n-            }\n-        }\n-    }\n-    protected void doHandleJaxrsBeanParamClassParams(OperationResourceInfo ori,\n-                                       StringBuilder sb,\n-                                       Map<Parameter, Object> params,\n-                                       boolean isJson,\n-                                       ParameterType... pType) {\n-        for (Map.Entry<Parameter, Object> entry : params.entrySet()) {\n-            Parameter pm = entry.getKey();\n-            Object obj = entry.getValue();\n-            if (pm.getType() == ParameterType.BEAN) {\n-                Class<?> cls = obj instanceof Method ? ((Method)obj).getParameterTypes()[0] : ((Field)obj)\n-                    .getType();\n-                doWriteJaxrsBeanParam(sb, ori, cls, isJson, pType);\n-            }\n-        }\n-    }\n-\n-    protected void handlePathAndMatrixParams(StringBuilder sb, OperationResourceInfo ori, boolean isJson) {\n-        handleParams(sb, ori, ParameterType.PATH, isJson);\n-        handleParams(sb, ori, ParameterType.MATRIX, isJson);\n-        doWriteJaxrsBeanParams(sb, ori, isJson, ParameterType.PATH, ParameterType.MATRIX);\n-    }\n-\n-    protected void handleParameter(StringBuilder sb, Set<Class<?>> jaxbTypes,\n-                                   ElementQNameResolver qnameResolver, Map<Class<?>, QName> clsMap,\n-                                   OperationResourceInfo ori, Parameter pm, boolean isJson) {\n-        Class<?> cls = getMethod(ori).getParameterTypes()[pm.getIndex()];\n-        if (pm.getType() == ParameterType.REQUEST_BODY && cls != AsyncResponse.class) {\n-            handleRepresentation(sb, jaxbTypes, qnameResolver, clsMap, ori, cls, isJson, true);\n-            return;\n-        }\n-        if (pm.getType() == ParameterType.PATH || pm.getType() == ParameterType.MATRIX) {\n-            return;\n-        }\n-        if (pm.getType() == ParameterType.HEADER || pm.getType() == ParameterType.QUERY) {\n-            writeParam(sb, pm, ori, isJson);\n-            return;\n-\n-        }\n-        if (pm.getType() == ParameterType.BEAN) {\n-            doWriteJaxrsBeanParams(sb, ori, isJson, ParameterType.HEADER, ParameterType.QUERY);\n-        }\n-\n-    }\n-\n-    protected void handleParams(StringBuilder sb, OperationResourceInfo ori, ParameterType type,\n-                                boolean isJson) {\n-        for (Parameter pm : ori.getParameters()) {\n-            if (pm.getType() == type) {\n-                writeParam(sb, pm, ori, isJson);\n-            }\n-        }\n-    }\n-\n-    private Annotation[] getBodyAnnotations(OperationResourceInfo ori, boolean inbound) {\n-        Method opMethod = getMethod(ori);\n-        if (inbound) {\n-            for (Parameter pm : ori.getParameters()) {\n-                if (pm.getType() == ParameterType.REQUEST_BODY) {\n-                    return opMethod.getParameterAnnotations()[pm.getIndex()];\n-                }\n-            }\n-            return new Annotation[] {};\n-        }\n-        return opMethod.getDeclaredAnnotations();\n-    }\n-\n-    private void writeParam(StringBuilder sb, Parameter pm, OperationResourceInfo ori, boolean isJson) {\n-        Method method = getMethod(ori);\n-        Class<?> type = method.getParameterTypes()[pm.getIndex()];\n-        if (!\"\".equals(pm.getName())) {\n-            doWriteParam(ori,\n-                         sb,\n-                         pm,\n-                         type,\n-                         method.getGenericParameterTypes()[pm.getIndex()],\n-                         pm.getName(),\n-                         method.getParameterAnnotations()[pm.getIndex()],\n-                         isJson);\n-        } else {\n-            List<Class<?>> parentBeanClasses = new LinkedList<>();\n-            parentBeanClasses.add(type);\n-            doWriteBeanParam(ori, sb, type, pm, null, parentBeanClasses, isJson);\n-            parentBeanClasses.remove(type);\n-        }\n-    }\n-    private void doWriteJaxrsBeanParams(StringBuilder sb,\n-                                       OperationResourceInfo ori,\n-                                       boolean isJson,\n-                                       ParameterType ...parameterTypes) {\n-        for (Parameter p : ori.getParameters()) {\n-            if (p.getType() == ParameterType.BEAN) {\n-                Method method = getMethod(ori);\n-                Class<?> type = method.getParameterTypes()[p.getIndex()];\n-                doWriteJaxrsBeanParam(sb, ori, type, isJson, parameterTypes);\n-            }\n-        }\n-    }\n-\n-    private void doWriteJaxrsBeanParam(StringBuilder sb,\n-                                       OperationResourceInfo ori,\n-                                       Class<?> beanType,\n-                                       boolean isJson,\n-                                       ParameterType ...parameterTypes) {\n-        for (Method m : beanType.getMethods()) {\n-            if (m.getName().startsWith(\"set\")) {\n-                String propertyName = StringUtils.uncapitalize(m.getName().substring(3));\n-                Field f = InjectionUtils.getDeclaredField(beanType, propertyName);\n-\n-                for (ParameterType parameterType : parameterTypes) {\n-                    Class<? extends Annotation> annClass = getAnnotationFromParamType(parameterType);\n-                    Annotation annotation = m.getAnnotation(annClass);\n-                    if (annotation != null) {\n-                        Parameter pm = new Parameter(parameterType, propertyName);\n-                        pm.setEncoded(m.getAnnotation(Encoded.class) != null);\n-                        DefaultValue dv = m.getAnnotation(DefaultValue.class);\n-                        if (dv != null) {\n-                            pm.setDefaultValue(dv.value());\n-                        }\n-                        doWriteParam(ori,\n-                                     sb,\n-                                     pm,\n-                                     m.getParameterTypes()[0],\n-                                     m.getGenericParameterTypes()[0],\n-                                     propertyName,\n-                                     new Annotation[]{},\n-                                     isJson);\n-                    } else if (f != null) {\n-                        annotation = f.getAnnotation(annClass);\n-                        if (annotation != null) {\n-                            Parameter pm = new Parameter(parameterType, propertyName);\n-                            pm.setEncoded(f.getAnnotation(Encoded.class) != null);\n-                            DefaultValue dv = f.getAnnotation(DefaultValue.class);\n-                            if (dv != null) {\n-                                pm.setDefaultValue(dv.value());\n-                            }\n-                            doWriteParam(ori,\n-                                         sb,\n-                                         pm,\n-                                         f.getType(),\n-                                         f.getGenericType(),\n-                                         propertyName,\n-                                         new Annotation[]{},\n-                                         isJson);\n-                        }\n-\n-                    }\n-                }\n-                if (m.getAnnotation(BeanParam.class) != null) {\n-                    doWriteJaxrsBeanParam(sb, ori, m.getParameterTypes()[0], isJson, parameterTypes);\n-                } else if (f != null && f.getAnnotation(BeanParam.class) != null) {\n-                    doWriteJaxrsBeanParam(sb, ori, f.getType(), isJson, parameterTypes);\n-                }\n-            }\n-        }\n-    }\n-\n-    private Class<? extends Annotation> getAnnotationFromParamType(ParameterType pt) {\n-        return PARAMETER_TYPE_MAP.get(pt);\n-    }\n-\n-    private void doWriteBeanParam(OperationResourceInfo ori,\n-                                  StringBuilder sb,\n-                                  Class<?> type,\n-                                  Parameter pm,\n-                                  String parentName,\n-                                  List<Class<?>> parentBeanClasses,\n-                                  boolean isJson) {\n-        Map<Parameter, Class<?>> pms = InjectionUtils.getParametersFromBeanClass(type, pm.getType(), true);\n-        for (Map.Entry<Parameter, Class<?>> entry : pms.entrySet()) {\n-            String name = entry.getKey().getName();\n-            if (parentName != null) {\n-                name = parentName + \".\" + name;\n-            }\n-            Class<?> paramCls = entry.getValue();\n-            boolean isPrimitive = InjectionUtils.isPrimitive(paramCls) || paramCls.isEnum();\n-            if (isPrimitive\n-                || Date.class.isAssignableFrom(paramCls)\n-                || XMLGregorianCalendar.class.isAssignableFrom(paramCls)\n-                || InjectionUtils.isSupportedCollectionOrArray(paramCls)) {\n-                doWriteParam(ori, sb, entry.getKey(), paramCls, paramCls, name, new Annotation[] {}, isJson);\n-            } else if (!parentBeanClasses.contains(paramCls)) {\n-                parentBeanClasses.add(paramCls);\n-                doWriteBeanParam(ori, sb, paramCls, entry.getKey(), name, parentBeanClasses, isJson);\n-                parentBeanClasses.remove(paramCls);\n-            }\n-        }\n-    }\n-    //CHECKSTYLE:OFF\n-    protected void doWriteParam(OperationResourceInfo ori,\n-                                StringBuilder sb,\n-                                Parameter pm,\n-                                Class<?> type,\n-                                Type genericType,\n-                                String paramName,\n-                                Annotation[] anns,\n-                                boolean isJson) {\n-      //CHECKSTYLE:ON\n-        ParameterType pType = pm.getType();\n-        boolean isForm = isFormParameter(pm, type, anns);\n-        if (paramName == null && isForm) {\n-            Multipart m = AnnotationUtils.getAnnotation(anns, Multipart.class);\n-            if (m != null) {\n-                paramName = m.value();\n-            }\n-        }\n-        sb.append(\"<param name=\\\"\").append(paramName).append(\"\\\" \");\n-        String style = ParameterType.PATH == pType ? \"template\" : isForm\n-            ? \"query\" : ParameterType.REQUEST_BODY == pType ? \"plain\" : pType.toString().toLowerCase();\n-        sb.append(\"style=\\\"\").append(style).append('\"');\n-        if (pm.getDefaultValue() != null) {\n-            sb.append(\" default=\\\"\").append(xmlEncodeIfNeeded(pm.getDefaultValue()))\n-                .append('\"');\n-        }\n-        if (InjectionUtils.isSupportedCollectionOrArray(type)) {\n-            type = InjectionUtils.getActualType(genericType);\n-            sb.append(\" repeating=\\\"true\\\"\");\n-        }\n-\n-        String value = XmlSchemaPrimitiveUtils.getSchemaRepresentation(type);\n-        if (value == null) {\n-            if (type.isEnum()) {\n-                value = \"xs:string\";\n-            } else if (type == InputStream.class) {\n-                value = \"xs:anyType\";\n-            }\n-        }\n-        if (value != null) {\n-            if (isJson) {\n-                value = value.substring(3);\n-            }\n-            sb.append(\" type=\\\"\").append(value).append('\"');\n-        }\n-        if (type.isEnum()) {\n-            sb.append('>');\n-            handleDocs(anns, sb, DocTarget.PARAM, true, isJson);\n-            setEnumOptions(sb, type);\n-            sb.append(\"</param>\");\n-        } else {\n-            addDocsAndCloseElement(ori, pm.getIndex(), sb, anns, \"param\", DocTarget.PARAM, true, isJson);\n-        }\n-    }\n-\n-    private void setEnumOptions(StringBuilder sb, Class<?> enumClass) {\n-        try {\n-            Method m = enumClass.getMethod(\"values\", new Class<?>[] {});\n-            Object[] values = (Object[])m.invoke(null, new Object[] {});\n-            m = enumClass.getMethod(\"toString\", new Class<?>[] {});\n-            for (Object o : values) {\n-                String str = (String)m.invoke(o, new Object[] {});\n-                sb.append(\"<option value=\\\"\").append(str).append(\"\\\"/>\");\n-            }\n-\n-        } catch (Throwable ex) {\n-            // ignore\n-        }\n-    }\n-    //CHECKSTYLE:OFF\n-    private void addDocsAndCloseElement(OperationResourceInfo ori,\n-                                        int paramIndex,\n-                                        StringBuilder sb,\n-                                        Annotation[] anns,\n-                                        String elementName,\n-                                        String category,\n-                                        boolean allowDefault,\n-                                        boolean isJson) {\n-    //CHECKSTYLE:ON\n-        boolean docAnnAvailable = isDocAvailable(anns);\n-        if (docAnnAvailable || (ori != null && !docProviders.isEmpty())) {\n-            sb.append('>');\n-            if (docAnnAvailable) {\n-                handleDocs(anns, sb, category, allowDefault, isJson);\n-            } else if (DocTarget.RETURN.equals(category)) {\n-                handleOperResponseJavaDocs(ori, sb);\n-            } else if (DocTarget.PARAM.equals(category)) {\n-                handleOperParamJavaDocs(ori, paramIndex, sb);\n-            }\n-            sb.append(\"</\").append(elementName).append('>');\n-        } else {\n-            sb.append(\"/>\");\n-        }\n-    }\n-\n-    private boolean isDocAvailable(Annotation[] anns) {\n-        return AnnotationUtils.getAnnotation(anns, Description.class) != null\n-               || AnnotationUtils.getAnnotation(anns, Descriptions.class) != null;\n-    }\n-\n-    // TODO: Collapse multiple parameters into a holder\n-    // CHECKSTYLE:OFF\n-    protected void handleRepresentation(StringBuilder sb, Set<Class<?>> jaxbTypes,\n-                                        ElementQNameResolver qnameResolver, Map<Class<?>, QName> clsMap,\n-                                        OperationResourceInfo ori, Class<?> type, boolean isJson,\n-                                        boolean inbound) {\n-        // CHECKSTYLE:ON\n-        List<MediaType> types = inbound ? ori.getConsumeTypes() : ori.getProduceTypes();\n-        if (MultivaluedMap.class.isAssignableFrom(type)) {\n-            types = Collections.singletonList(MediaType.APPLICATION_FORM_URLENCODED_TYPE);\n-        } else if (isWildcard(types)) {\n-            types = Collections.singletonList(defaultRepMediaType);\n-        }\n-\n-        Method opMethod = getMethod(ori);\n-        boolean isPrimitive = InjectionUtils.isPrimitive(type) && !ori.isAsync();\n-        for (MediaType mt : types) {\n-\n-            sb.append(\"<representation\");\n-            sb.append(\" mediaType=\\\"\").append(JAXRSUtils.mediaTypeToString(mt)).append('\"');\n-            if (isJson && !mt.getSubtype().contains(\"json\")) {\n-                sb.append(\"/>\");\n-                continue;\n-            }\n-\n-            boolean allowDefault = true;\n-            String docCategory;\n-            Annotation[] anns;\n-            int inParamIndex = -1;\n-            Type genericType;\n-            if (inbound) {\n-                inParamIndex = getRequestBodyParam(ori).getIndex();\n-                anns = opMethod.getParameterAnnotations()[inParamIndex];\n-                if (!isDocAvailable(anns)) {\n-                    anns = opMethod.getAnnotations();\n-                }\n-                docCategory = DocTarget.PARAM;\n-                genericType = opMethod.getGenericParameterTypes()[inParamIndex];\n-            } else {\n-                anns = opMethod.getAnnotations();\n-                docCategory = DocTarget.RETURN;\n-                allowDefault = false;\n-                genericType = opMethod.getGenericReturnType();\n-            }\n-            if (isPrimitive) {\n-                sb.append('>');\n-                Parameter p = inbound ? getRequestBodyParam(ori) : new Parameter(ParameterType.REQUEST_BODY,\n-                                                                                 0, \"result\");\n-                doWriteParam(ori, sb, p, type, type, p.getName() == null ? \"request\" : p.getName(), anns, isJson);\n-                sb.append(\"</representation>\");\n-            } else {\n-                boolean isCollection = InjectionUtils.isSupportedCollectionOrArray(type);\n-                Class<?> theActualType;\n-                if (isCollection) {\n-                    theActualType = InjectionUtils.getActualType(genericType);\n-                } else {\n-                    theActualType = ResourceUtils.getActualJaxbType(type, opMethod, inbound);\n-                }\n-                if (theActualType == Object.class && !(genericType instanceof Class)\n-                    || genericType instanceof TypeVariable) {\n-                    Type theType = InjectionUtils.processGenericTypeIfNeeded(\n-                        ori.getClassResourceInfo().getServiceClass(), Object.class, genericType);\n-                    theActualType = InjectionUtils.getActualType(theType);\n-                }\n-                if (isJson) {\n-                    sb.append(\" element=\\\"\").append(theActualType.getSimpleName()).append('\"');\n-                } else if (qnameResolver != null\n-                           && (linkAnyMediaTypeToXmlSchema || mt.getSubtype().contains(\"xml\"))\n-                           && jaxbTypes.contains(theActualType)) {\n-                    generateQName(sb, qnameResolver, clsMap, theActualType, isCollection,\n-                                  getBodyAnnotations(ori, inbound));\n-                }\n-                addDocsAndCloseElement(ori, inParamIndex, sb, anns, \"representation\",\n-                                       docCategory, allowDefault, isJson);\n-            }\n-        }\n-\n-    }\n-\n-    private Parameter getRequestBodyParam(OperationResourceInfo ori) {\n-        for (Parameter p : ori.getParameters()) {\n-            if (p.getType() == ParameterType.REQUEST_BODY) {\n-                return p;\n-            }\n-        }\n-        throw new IllegalStateException();\n-    }\n-\n-    private boolean isWildcard(List<MediaType> types) {\n-        return types.size() == 1 && types.get(0).equals(MediaType.WILDCARD_TYPE);\n-    }\n-\n-    private void handleFormRepresentation(StringBuilder sb, Set<Class<?>> jaxbTypes,\n-                                          ElementQNameResolver qnameResolver, Map<Class<?>, QName> clsMap,\n-                                          OperationResourceInfo ori, Class<?> type, boolean isJson) {\n-        if (type != null) {\n-            handleRepresentation(sb, jaxbTypes, qnameResolver, clsMap, ori, type, false, true);\n-        } else {\n-            List<MediaType> types = ori.getConsumeTypes();\n-            MediaType formType = isWildcard(types) ? MediaType.APPLICATION_FORM_URLENCODED_TYPE : types\n-                .get(0);\n-            sb.append(\"<representation\");\n-            sb.append(\" mediaType=\\\"\").append(formType).append('\"');\n-            if (isJson) {\n-                sb.append(\"/>\");\n-            } else {\n-                sb.append('>');\n-                List<Parameter> params = ori.getParameters();\n-                for (int i = 0; i < params.size(); i++) {\n-                    if (isFormParameter(params.get(i), getMethod(ori).getParameterTypes()[i], getMethod(ori)\n-                        .getParameterAnnotations()[i])) {\n-                        writeParam(sb, params.get(i), ori, isJson);\n-                    }\n-                }\n-                sb.append(\"</representation>\");\n-            }\n-        }\n-    }\n-\n-    protected List<OperationResourceInfo> sortOperationsByPath(Set<OperationResourceInfo> ops) {\n-        List<OperationResourceInfo> opsWithSamePath = new LinkedList<>(ops);\n-        Collections.sort(opsWithSamePath, new Comparator<OperationResourceInfo>() {\n-\n-            @Override\n-            public int compare(OperationResourceInfo op1, OperationResourceInfo op2) {\n-                boolean sub1 = op1.getHttpMethod() == null;\n-                boolean sub2 = op2.getHttpMethod() == null;\n-                if (sub1 && !sub2) {\n-                    return 1;\n-                } else if (!sub1 && sub2) {\n-                    return -1;\n-                }\n-                URITemplate ut1 = op1.getURITemplate();\n-                URITemplate ut2 = op2.getURITemplate();\n-                int result = ut1.getValue().compareTo(ut2.getValue());\n-                if (result == 0 && !(sub1 && sub2)) {\n-                    result = op1.getHttpMethod().compareTo(op2.getHttpMethod());\n-                }\n-                if (result == 0 && ignoreOverloadedMethods\n-                    && op1.getMethodToInvoke().getName().equals(op2.getMethodToInvoke().getName())) {\n-                    Integer paramLen1 = op1.getMethodToInvoke().getParameterTypes().length;\n-                    Integer paramLen2 = op2.getMethodToInvoke().getParameterTypes().length;\n-                    result = paramLen1.compareTo(paramLen2) * -1;\n-                }\n-                return result;\n-            }\n-\n-        });\n-        return opsWithSamePath;\n-    }\n-\n-    public List<ClassResourceInfo> getResourcesList(Message m, UriInfo ui) {\n-        final String slash = \"/\";\n-        String path = ui.getPath();\n-        if (!path.startsWith(slash)) {\n-            path = slash + path;\n-        }\n-        List<ClassResourceInfo> all = ((JAXRSServiceImpl)m.getExchange().getService())\n-            .getClassResourceInfos();\n-        boolean absolutePathSlashOn = checkAbsolutePathSlash && ui.getAbsolutePath().getPath().endsWith(slash);\n-        if (slash.equals(path) && !absolutePathSlashOn) {\n-            return all;\n-        }\n-        List<ClassResourceInfo> cris = new LinkedList<>();\n-        for (ClassResourceInfo cri : all) {\n-            MultivaluedMap<String, String> map = new MetadataMap<>();\n-            if (cri.getURITemplate().match(path, map)\n-                && slash.equals(map.getFirst(URITemplate.FINAL_MATCH_GROUP))) {\n-                cris.add(cri);\n-            }\n-        }\n-        return cris;\n-    }\n-\n-    // TODO: deal with caching later on\n-    public Response getExistingWadl(Message m, UriInfo ui, MediaType mt) {\n-        Endpoint ep = m.getExchange().getEndpoint();\n-        if (ep != null) {\n-            String loc = (String)ep.get(JAXRSUtils.DOC_LOCATION);\n-            if (loc != null) {\n-                try {\n-                    InputStream is = ResourceUtils.getResourceStream(loc, (Bus)ep.get(Bus.class.getName()));\n-                    if (is != null) {\n-                        Object contextProp = m.getContextualProperty(CONVERT_WADL_RESOURCES_TO_DOM);\n-                        boolean doConvertResourcesToDOM = contextProp == null\n-                            ? convertResourcesToDOM : PropertyUtils.isTrue(contextProp);\n-                        if (!doConvertResourcesToDOM || isJson(mt)) {\n-                            return Response.ok(is, mt).build();\n-                        }\n-                        Document wadlDoc = StaxUtils.read(is);\n-                        Element appEl = wadlDoc.getDocumentElement();\n-\n-                        List<Element> grammarEls = DOMUtils.getChildrenWithName(appEl, WadlGenerator.WADL_NS,\n-                                                                                \"grammars\");\n-                        if (grammarEls.size() == 1) {\n-                            handleExistingDocRefs(DOMUtils.getChildrenWithName(grammarEls.get(0),\n-                                                                               WadlGenerator.WADL_NS,\n-                                                                               \"include\"), \"href\", loc, \"\",\n-                                                  m, ui);\n-                        }\n-\n-                        List<Element> resourcesEls = DOMUtils.getChildrenWithName(appEl,\n-                                                                                  WadlGenerator.WADL_NS,\n-                                                                                  \"resources\");\n-                        if (resourcesEls.size() == 1) {\n-                            DOMUtils.setAttribute(resourcesEls.get(0), \"base\", getBaseURI(m, ui));\n-\n-                            List<Element> resourceEls = DOMUtils.getChildrenWithName(resourcesEls.get(0),\n-                                                                                     WadlGenerator.WADL_NS,\n-                                                                                     \"resource\");\n-                            handleExistingDocRefs(resourceEls, \"type\", loc, \"\", m, ui);\n-                            return finalizeExistingWadlResponse(wadlDoc, m, ui, mt);\n-                        }\n-\n-                    }\n-                } catch (Exception ex) {\n-                    throw ExceptionUtils.toInternalServerErrorException(ex, null);\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-    private Response finalizeExistingWadlResponse(Document wadlDoc, Message m, UriInfo ui, MediaType mt)\n-        throws Exception {\n-        Object entity;\n-        if (stylesheetReference != null) {\n-            if (!applyStylesheetLocally) {\n-                ProcessingInstruction pi = wadlDoc.createProcessingInstruction(\"xml-stylesheet\",\n-                                              getStylesheetInstructionData(getBaseURI(m, ui)));\n-                wadlDoc.insertBefore(pi, wadlDoc.getDocumentElement());\n-                entity = copyDOMToString(wadlDoc);\n-            } else {\n-                entity = transformLocally(m, ui, new DOMSource(wadlDoc));\n-            }\n-        } else {\n-            entity = new DOMSource(wadlDoc);\n-        }\n-        return Response.ok(entity, mt).build();\n-\n-    }\n-    private String copyDOMToString(Document wadlDoc) throws Exception {\n-        DOMSource domSource = new DOMSource(wadlDoc);\n-        // temporary workaround\n-        StringWriter stringWriter = new StringWriter();\n-        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n-        transformerFactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n-        Transformer transformer = transformerFactory.newTransformer();\n-        transformer.transform(domSource, new StreamResult(stringWriter));\n-        return stringWriter.toString();\n-    }\n-    private String transformLocally(Message m, UriInfo ui, Source source) throws Exception {\n-        InputStream is = ResourceUtils.getResourceStream(stylesheetReference, m.getExchange().getBus());\n-        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n-        transformerFactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n-        Transformer t = transformerFactory.newTemplates(new StreamSource(is)).newTransformer();\n-        t.setParameter(\"base.path\", m.get(\"http.base.path\"));\n-        StringWriter stringWriter = new StringWriter();\n-        t.transform(source, new StreamResult(stringWriter));\n-        return stringWriter.toString();\n-    }\n-\n-\n-    // TODO: deal with caching later on\n-    public Response getExistingResource(Message m, UriInfo ui, String href) {\n-        try {\n-            String loc = docLocationMap.get(href);\n-            if (loc != null) {\n-                int fragmentIndex = loc.lastIndexOf('#');\n-                if (fragmentIndex != -1) {\n-                    loc = loc.substring(0, fragmentIndex);\n-                }\n-                InputStream is = ResourceUtils.getResourceStream(loc, m.getExchange().getBus());\n-                if (is != null) {\n-                    Element docEl = StaxUtils.read(is).getDocumentElement();\n-                    if (href.endsWith(\".xsl\")) {\n-                        List<Element> xslImports = DOMUtils.getChildrenWithName(docEl, XLS_NS, \"import\");\n-                        handleExistingDocRefs(xslImports, \"href\", loc, href, m, ui);\n-                        List<Element> xslIncludes = DOMUtils.getChildrenWithName(docEl, XLS_NS, \"include\");\n-                        handleExistingDocRefs(xslIncludes, \"href\", loc, href, m, ui);\n-                    } else {\n-                        if (fragmentIndex != -1) {\n-                            List<Element> grammarEls = DOMUtils.getChildrenWithName(docEl, WADL_NS, \"grammars\");\n-                            if (grammarEls.size() == 1) {\n-                                handleExistingDocRefs(DOMUtils.getChildrenWithName(grammarEls.get(0), WADL_NS,\n-                                                                                   \"include\"), \"href\", loc, href,\n-                                                      m, ui);\n-                            }\n-                        } else {\n-                            handleExistingDocRefs(DOMUtils.getChildrenWithName(docEl,\n-                                                                               Constants.URI_2001_SCHEMA_XSD,\n-                                                                               \"import\"), \"schemaLocation\", loc,\n-                                                  href, m, ui);\n-                            handleExistingDocRefs(DOMUtils.getChildrenWithName(docEl,\n-                                                                               Constants.URI_2001_SCHEMA_XSD,\n-                                                                               \"include\"), \"schemaLocation\", loc,\n-                                                  href, m, ui);\n-                        }\n-                    }\n-\n-                    return Response.ok().type(MediaType.APPLICATION_XML_TYPE).entity(new DOMSource(docEl))\n-                        .build();\n-                }\n-            } else if (stylesheetReference != null && href.endsWith(\".xsl\")) {\n-                InputStream is = ResourceUtils.getResourceStream(href, m.getExchange().getBus());\n-                return Response.ok().type(MediaType.APPLICATION_XML_TYPE).entity(is).build();\n-            }\n-\n-        } catch (Exception ex) {\n-            throw ExceptionUtils.toBadRequestException(null, null);\n-        }\n-        return null;\n-    }\n-\n-    private void handleExistingDocRefs(List<Element> elements, String attrName, String parentDocLoc,\n-                                       String parentRef, Message m, UriInfo ui) {\n-        if (keepRelativeDocLinks) {\n-            return;\n-        }\n-        int index = parentDocLoc.lastIndexOf('/');\n-        parentDocLoc = index == -1 ? parentDocLoc : parentDocLoc.substring(0, index + 1);\n-\n-        index = parentRef.lastIndexOf('/');\n-        parentRef = index == -1 ? \"\" : parentRef.substring(0, index + 1);\n-\n-        for (Element element : elements) {\n-            String href = element.getAttribute(attrName);\n-            String originalRef = href;\n-            if (!StringUtils.isEmpty(href) && !href.startsWith(\"#\")) {\n-                int fragmentIndex = href.lastIndexOf('#');\n-                String fragment = null;\n-                if (fragmentIndex != -1) {\n-                    fragment = href.substring(fragmentIndex + 1);\n-                    href = href.substring(0, fragmentIndex);\n-                }\n-\n-                String actualRef = parentRef + href;\n-                docLocationMap.put(actualRef, parentDocLoc + originalRef);\n-                UriBuilder ub = UriBuilder.fromUri(getBaseURI(m, ui)).path(actualRef).fragment(fragment);\n-                URI schemaURI = ub.build();\n-                DOMUtils.setAttribute(element, attrName, schemaURI.toString());\n-            }\n-        }\n-    }\n-\n-    private void generateQName(StringBuilder sb, ElementQNameResolver qnameResolver,\n-                               Map<Class<?>, QName> clsMap, Class<?> type, boolean isCollection,\n-                               Annotation[] annotations) {\n-        if (!isCollection) {\n-            QName typeQName = clsMap.get(type);\n-            if (typeQName != null) {\n-                writeQName(sb, typeQName);\n-                return;\n-            }\n-        }\n-\n-        QName qname = qnameResolver.resolve(type, annotations, Collections.unmodifiableMap(clsMap));\n-\n-        if (qname != null) {\n-            if (!isCollection) {\n-                writeQName(sb, qname);\n-                clsMap.put(type, qname);\n-            } else {\n-                XMLName name = AnnotationUtils.getAnnotation(annotations, XMLName.class);\n-                String localPart;\n-                if (name != null) {\n-                    localPart = JAXRSUtils.convertStringToQName(name.value()).getLocalPart();\n-                } else {\n-                    localPart = qname.getLocalPart() + \"s\";\n-                }\n-                QName collectionName = new QName(qname.getNamespaceURI(), localPart, qname.getPrefix());\n-                writeQName(sb, collectionName);\n-            }\n-        }\n-    }\n-\n-    private void writeQName(StringBuilder sb, QName qname) {\n-        sb.append(\" element=\\\"\").append(qname.getPrefix()).append(':').append(qname.getLocalPart()).append('\"');\n-    }\n-\n-    private boolean isXmlRoot(Class<?> cls) {\n-        return cls.getAnnotation(XmlRootElement.class) != null;\n-    }\n-\n-    private SchemaCollection getSchemaCollection(ResourceTypes resourceTypes, JAXBContext context) {\n-        if (context == null) {\n-            return null;\n-        }\n-        SchemaCollection xmlSchemaCollection = new SchemaCollection();\n-        Collection<DOMSource> schemas = new HashSet<>();\n-        List<String> targetNamespaces = new ArrayList<>();\n-        try {\n-            for (DOMResult r : JAXBUtils.generateJaxbSchemas(context, CastUtils.cast(Collections.emptyMap(),\n-                                                                                     String.class,\n-                                                                                     DOMResult.class))) {\n-                Document doc = (Document)r.getNode();\n-                ElementQNameResolver theResolver = createElementQNameResolver(context);\n-                String tns = doc.getDocumentElement().getAttribute(\"targetNamespace\");\n-\n-                String tnsPrefix = doc.getDocumentElement().lookupPrefix(tns);\n-                if (tnsPrefix == null) {\n-                    String tnsDecl =\n-                        doc.getDocumentElement().getAttribute(\"xmlns:tns\");\n-                    tnsPrefix = tnsDecl != null && tnsDecl.equals(tns) ? \"tns:\" : \"\";\n-                } else {\n-                    tnsPrefix += \":\";\n-                }\n-\n-                if (supportJaxbXmlType) {\n-                    for (Class<?> cls : resourceTypes.getAllTypes().keySet()) {\n-                        if (isXmlRoot(cls)) {\n-                            continue;\n-                        }\n-                        XmlType root = cls.getAnnotation(XmlType.class);\n-                        if (root != null) {\n-                            QName typeName = theResolver.resolve(cls, new Annotation[] {},\n-                                                           Collections.<Class<?>, QName> emptyMap());\n-                            if (typeName != null && tns.equals(typeName.getNamespaceURI())) {\n-                                QName elementName = resourceTypes.getXmlNameMap().get(cls);\n-                                if (elementName == null) {\n-                                    elementName = typeName;\n-                                }\n-                                Element newElement = doc\n-                                    .createElementNS(Constants.URI_2001_SCHEMA_XSD, \"xs:element\");\n-                                newElement.setAttribute(\"name\", elementName.getLocalPart());\n-                                newElement.setAttribute(\"type\", tnsPrefix + typeName.getLocalPart());\n-\n-                                if (Modifier.isAbstract(cls.getModifiers())\n-                                    && resourceTypes.getSubstitutions().values().contains(cls)) {\n-                                    newElement.setAttribute(\"abstract\", \"true\");\n-                                }\n-\n-                                doc.getDocumentElement().appendChild(newElement);\n-                            }\n-                        }\n-                    }\n-                    if (supportJaxbSubstitutions) {\n-                        for (Map.Entry<Class<?>, Class<?>> entry : resourceTypes.getSubstitutions().entrySet()) {\n-                            QName typeName = theResolver.resolve(entry.getKey(), new Annotation[] {},\n-                                                                 Collections.<Class<?>, QName> emptyMap());\n-                            for (Element element : DOMUtils.findAllElementsByTagNameNS(doc.getDocumentElement(),\n-                                                                                       Constants.URI_2001_SCHEMA_XSD,\n-                                                                                       \"element\")) {\n-                                if (element.getAttribute(\"name\").equals(typeName.getLocalPart())) {\n-                                    QName groupName = theResolver.resolve(entry.getValue(), new Annotation[] {},\n-                                                                         Collections.<Class<?>, QName> emptyMap());\n-                                    if (groupName != null) {\n-                                        element.setAttribute(\"substitutionGroup\", tnsPrefix + groupName.getLocalPart());\n-                                    }\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if (supportCollections && !resourceTypes.getCollectionMap().isEmpty()) {\n-                    for (Map.Entry<Class<?>, QName> entry : resourceTypes.getCollectionMap().entrySet()) {\n-                        QName colQName = entry.getValue();\n-                        if (colQName == null) {\n-                            colQName = theResolver.resolve(entry.getKey(), new Annotation[] {},\n-                                                Collections.<Class<?>, QName> emptyMap());\n-                            if (colQName != null) {\n-                                colQName = new QName(colQName.getNamespaceURI(),\n-                                                     colQName.getLocalPart() + \"s\",\n-                                                     colQName.getPrefix());\n-                            }\n-                        }\n-                        if (colQName == null) {\n-                            continue;\n-                        }\n-                        if (tns.equals(colQName.getNamespaceURI())) {\n-                            QName typeName = theResolver.resolve(entry.getKey(), new Annotation[] {},\n-                                                                 Collections.<Class<?>, QName> emptyMap());\n-                            if (typeName != null) {\n-                                Element newElement = doc\n-                                    .createElementNS(Constants.URI_2001_SCHEMA_XSD, \"xs:element\");\n-                                newElement.setAttribute(\"name\", colQName.getLocalPart());\n-                                Element ctElement = doc.createElementNS(Constants.URI_2001_SCHEMA_XSD,\n-                                                                        \"xs:complexType\");\n-                                newElement.appendChild(ctElement);\n-                                Element seqElement = doc\n-                                    .createElementNS(Constants.URI_2001_SCHEMA_XSD, \"xs:sequence\");\n-                                ctElement.appendChild(seqElement);\n-                                Element xsElement = doc.createElementNS(Constants.URI_2001_SCHEMA_XSD,\n-                                                                        \"xs:element\");\n-                                seqElement.appendChild(xsElement);\n-                                xsElement.setAttribute(\"ref\", tnsPrefix + typeName.getLocalPart());\n-                                xsElement.setAttribute(\"minOccurs\", \"0\");\n-                                xsElement.setAttribute(\"maxOccurs\", \"unbounded\");\n-\n-                                doc.getDocumentElement().appendChild(newElement);\n-                            }\n-                        }\n-                    }\n-                }\n-                DOMSource source = new DOMSource(doc, r.getSystemId());\n-                schemas.add(source);\n-                if (!StringUtils.isEmpty(tns)) {\n-                    targetNamespaces.add(tns);\n-                }\n-            }\n-        } catch (IOException e) {\n-            LOG.fine(\"No schema can be generated\");\n-            return null;\n-        }\n-\n-        boolean hackAroundEmptyNamespaceIssue = false;\n-        for (DOMSource r : schemas) {\n-            hackAroundEmptyNamespaceIssue = addSchemaDocument(xmlSchemaCollection, targetNamespaces,\n-                                                              (Document)r.getNode(), r.getSystemId(),\n-                                                              hackAroundEmptyNamespaceIssue);\n-        }\n-        return xmlSchemaCollection;\n-    }\n-\n-    private QName getJaxbQName(String name, String namespace, Class<?> type, Map<Class<?>, QName> clsMap) {\n-        QName qname = getQNameFromParts(name, namespace, type, clsMap);\n-        if (qname != null) {\n-            return qname;\n-        }\n-        String ns = JAXBUtils.getPackageNamespace(type);\n-        if (ns != null) {\n-            return getQNameFromParts(name, ns, type, clsMap);\n-        }\n-        return null;\n-\n-    }\n-\n-    private QName getJaxbQName(JAXBContextProxy jaxbProxy, Class<?> type, Map<Class<?>, QName> clsMap) {\n-        XmlRootElement root = type.getAnnotation(XmlRootElement.class);\n-        if (root != null) {\n-            return getJaxbQName(root.name(), root.namespace(), type, clsMap);\n-        }\n-\n-        try {\n-            JAXBBeanInfo jaxbInfo = jaxbProxy == null ? null : JAXBUtils.getBeanInfo(jaxbProxy, type);\n-            if (jaxbInfo == null) {\n-                return null;\n-            }\n-            Object instance = type.newInstance();\n-            return getQNameFromParts(jaxbInfo.getElementLocalName(instance),\n-                                     jaxbInfo.getElementNamespaceURI(instance), type, clsMap);\n-        } catch (Exception ex) {\n-            // ignore\n-        }\n-        return null;\n-    }\n-\n-    private String getPrefix(String ns, Map<Class<?>, QName> clsMap) {\n-        String prefix = null;\n-        int index = 0;\n-        for (QName name : clsMap.values()) {\n-            String currentPrefix = name.getPrefix();\n-            if (currentPrefix.startsWith(nsPrefix)) {\n-                int currentIndex = currentPrefix.equals(nsPrefix) ? 0\n-                    : Integer.parseInt(currentPrefix.substring(nsPrefix.length()));\n-                if (currentIndex > index) {\n-                    index = currentIndex;\n-                }\n-            }\n-            if (name.getNamespaceURI().equals(ns)) {\n-                prefix = currentPrefix;\n-                break;\n-            }\n-        }\n-        if (StringUtils.isEmpty(prefix)) {\n-            prefix = index == 0 && !incrementNamespacePrefix ? nsPrefix : nsPrefix + (index + 1);\n-        }\n-        return prefix;\n-    }\n-\n-    private boolean isFormRequest(OperationResourceInfo ori) {\n-        for (Parameter p : ori.getParameters()) {\n-            if (p.getType() == ParameterType.FORM\n-                || p.getType() == ParameterType.REQUEST_BODY\n-                && (getMethod(ori).getParameterTypes()[p.getIndex()] == MultivaluedMap.class || AnnotationUtils\n-                    .getAnnotation(getMethod(ori).getParameterAnnotations()[p.getIndex()], Multipart.class) != null)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private Class<?> getFormClass(OperationResourceInfo ori) {\n-        List<Parameter> params = ori.getParameters();\n-        for (int i = 0; i < params.size(); i++) {\n-            if (isFormParameter(params.get(i), getMethod(ori).getParameterTypes()[i], getMethod(ori)\n-                .getParameterAnnotations()[i])) {\n-                return null;\n-            }\n-        }\n-        return MultivaluedMap.class;\n-    }\n-\n-    private boolean isFormParameter(Parameter pm, Class<?> type, Annotation[] anns) {\n-        return ParameterType.FORM == pm.getType() || ParameterType.REQUEST_BODY == pm.getType()\n-               && AnnotationUtils.getAnnotation(anns, Multipart.class) != null\n-               && (InjectionUtils.isPrimitive(type) || type == InputStream.class);\n-    }\n-\n-    // TODO : can we reuse this block with JAXBBinding somehow ?\n-    public boolean addSchemaDocument(SchemaCollection col, List<String> tnsList, Document d, String systemId,\n-                                     boolean hackAroundEmptyNamespaceIssue) {\n-        String ns = d.getDocumentElement().getAttribute(\"targetNamespace\");\n-\n-        if (StringUtils.isEmpty(ns)) {\n-            if (DOMUtils.getFirstElement(d.getDocumentElement()) == null) {\n-                hackAroundEmptyNamespaceIssue = true;\n-                return hackAroundEmptyNamespaceIssue;\n-            }\n-            // create a copy of the dom so we\n-            // can modify it.\n-            d = copy(d);\n-            ns = tnsList.isEmpty() ? \"\" : tnsList.get(0);\n-            d.getDocumentElement().setAttribute(\"targetNamespace\", ns);\n-        }\n-\n-        if (hackAroundEmptyNamespaceIssue) {\n-            d = doEmptyNamespaceHack(d);\n-        }\n-\n-        Node n = d.getDocumentElement().getFirstChild();\n-        while (n != null) {\n-            if (n instanceof Element) {\n-                Element e = (Element)n;\n-                if (\"import\".equals(e.getLocalName())) {\n-                    e.removeAttribute(\"schemaLocation\");\n-                }\n-            }\n-            n = n.getNextSibling();\n-        }\n-\n-        synchronized (d) {\n-            col.read(d, systemId);\n-        }\n-        return hackAroundEmptyNamespaceIssue;\n-    }\n-\n-    private Document doEmptyNamespaceHack(Document d) {\n-        boolean hasStuffToRemove = false;\n-        Element el = DOMUtils.getFirstElement(d.getDocumentElement());\n-        while (el != null) {\n-            if (\"import\".equals(el.getLocalName()) && StringUtils.isEmpty(el.getAttribute(\"targetNamespace\"))) {\n-                hasStuffToRemove = true;\n-                break;\n-            }\n-            el = DOMUtils.getNextElement(el);\n-        }\n-        if (hasStuffToRemove) {\n-            // create a copy of the dom so we\n-            // can modify it.\n-            d = copy(d);\n-            el = DOMUtils.getFirstElement(d.getDocumentElement());\n-            while (el != null) {\n-                if (\"import\".equals(el.getLocalName())\n-                    && StringUtils.isEmpty(el.getAttribute(\"targetNamespace\"))) {\n-                    d.getDocumentElement().removeChild(el);\n-                    el = DOMUtils.getFirstElement(d.getDocumentElement());\n-                } else {\n-                    el = DOMUtils.getNextElement(el);\n-                }\n-            }\n-        }\n-\n-        return d;\n-    }\n-\n-    private Document copy(Document doc) {\n-        try {\n-            return StaxUtils.copy(doc);\n-        } catch (XMLStreamException | ParserConfigurationException e) {\n-            // ignore\n-        }\n-        return doc;\n-    }\n-\n-    private QName getQNameFromParts(String name, String namespace, Class<?> type, Map<Class<?>, QName> clsMap) {\n-        if (namespace == null || JAXB_DEFAULT_NAMESPACE.equals(namespace) || namespace.length() == 0) {\n-            return null;\n-        }\n-        if (name == null || name.length() == 0) {\n-            return null;\n-        }\n-        if (JAXB_DEFAULT_NAME.equals(name)) {\n-            name = StringUtils.uncapitalize(type.getSimpleName());\n-        }\n-        String prefix = getPrefix(namespace, clsMap);\n-        return new QName(namespace, name, prefix);\n-    }\n-\n-    public void setIgnoreMessageWriters(boolean ignoreMessageWriters) {\n-        this.ignoreMessageWriters = ignoreMessageWriters;\n-    }\n-\n-    private void handleApplicationDocs(StringBuilder sbApp) {\n-        if (applicationTitle != null) {\n-            sbApp.append(\"<doc title=\\\"\").append(xmlEncodeIfNeeded(applicationTitle)).append(\"\\\"/>\");\n-        }\n-    }\n-\n-    protected void handleClassJavaDocs(ClassResourceInfo cri, StringBuilder sb) {\n-        for (DocumentationProvider docProvider : docProviders) {\n-            addProvidedDocs(sb, docProvider.getClassDoc(cri));\n-        }\n-    }\n-\n-    protected void handleOperJavaDocs(OperationResourceInfo ori, StringBuilder sb) {\n-        for (DocumentationProvider docProvider : docProviders) {\n-            addProvidedDocs(sb, docProvider.getMethodDoc(ori));\n-        }\n-    }\n-\n-    protected void handleOperResponseJavaDocs(OperationResourceInfo ori, StringBuilder sb) {\n-        for (DocumentationProvider docProvider : docProviders) {\n-            addProvidedDocs(sb, docProvider.getMethodResponseDoc(ori));\n-        }\n-    }\n-\n-    protected void handleOperParamJavaDocs(OperationResourceInfo ori,\n-                                           int paramIndex,\n-                                           StringBuilder sb) {\n-        for (DocumentationProvider docProvider : docProviders) {\n-            addProvidedDocs(sb, docProvider.getMethodParameterDoc(ori, paramIndex));\n-        }\n-    }\n-\n-    private void addProvidedDocs(StringBuilder sb, String text) {\n-        if (!StringUtils.isEmpty(text)) {\n-            sb.append(\"<doc>\");\n-            sb.append(xmlEncodeIfNeeded(text));\n-            sb.append(\"</doc>\");\n-        }\n-    }\n-\n-    protected boolean handleDocs(Annotation[] anns,\n-                              StringBuilder sb,\n-                              String category,\n-                              boolean allowDefault,\n-                              boolean isJson) {\n-        boolean found = false;\n-        for (Annotation a : anns) {\n-            if (a.annotationType() == Descriptions.class) {\n-                Descriptions ds = (Descriptions)a;\n-                return handleDocs(ds.value(), sb, category, allowDefault, isJson);\n-            }\n-            if (a.annotationType() == Description.class) {\n-                Description d = (Description)a;\n-                if (d.target().length() == 0 && !allowDefault || d.target().length() > 0\n-                    && !d.target().equals(category)) {\n-                    continue;\n-                }\n-\n-                sb.append(\"<doc\");\n-                if (!isJson && d.lang().length() > 0) {\n-                    sb.append(\" xml:lang=\\\"\").append(d.lang()).append('\"');\n-                }\n-                if (d.title().length() > 0) {\n-                    sb.append(\" title=\\\"\").append(xmlEncodeIfNeeded(d.title())).append('\"');\n-                }\n-                sb.append('>');\n-                if (d.value().length() > 0) {\n-                    sb.append(xmlEncodeIfNeeded(d.value()));\n-                } else if (d.docuri().length() > 0) {\n-                    InputStream is;\n-                    if (d.docuri().startsWith(CLASSPATH_PREFIX)) {\n-                        String path = d.docuri().substring(CLASSPATH_PREFIX.length());\n-                        is = ResourceUtils.getClasspathResourceStream(path, SchemaHandler.class,\n-                            bus == null ? BusFactory.getDefaultBus() : bus);\n-                        if (is != null) {\n-                            try {\n-                                sb.append(IOUtils.toString(is));\n-                            } catch (IOException ex) {\n-                                // ignore\n-                            }\n-                        }\n-                    }\n-                }\n-                sb.append(\"</doc>\");\n-                found = true;\n-            }\n-        }\n-        return found;\n-    }\n-\n-    private String getNamespace() {\n-        return wadlNamespace != null ? wadlNamespace : WADL_NS;\n-    }\n-\n-    public void setWadlNamespace(String namespace) {\n-        this.wadlNamespace = namespace;\n-    }\n-\n-    public void setSingleResourceMultipleMethods(boolean singleResourceMultipleMethods) {\n-        this.singleResourceMultipleMethods = singleResourceMultipleMethods;\n-    }\n-\n-    public void setUseSingleSlashResource(boolean useSingleSlashResource) {\n-        this.useSingleSlashResource = useSingleSlashResource;\n-    }\n-\n-    @Deprecated\n-    public void setLinkJsonToXmlSchema(boolean link) {\n-        setLinkAnyMediaTypeToXmlSchema(link);\n-    }\n-    public void setLinkAnyMediaTypeToXmlSchema(boolean link) {\n-        linkAnyMediaTypeToXmlSchema = link;\n-    }\n-\n-    public void setSchemaLocations(List<String> locations) {\n-        externalQnamesMap = new HashMap<>();\n-        externalSchemasCache = new ArrayList<>(locations.size());\n-        for (int i = 0; i < locations.size(); i++) {\n-            String loc = locations.get(i);\n-            try {\n-                loadSchemasIntoCache(loc);\n-            } catch (Exception ex) {\n-                LOG.warning(\"No schema resource \" + loc + \" can be loaded : \" + ex.getMessage());\n-                externalSchemasCache = null;\n-                externalQnamesMap = null;\n-                return;\n-            }\n-        }\n-    }\n-\n-    private void loadSchemasIntoCache(String loc) throws Exception {\n-        InputStream is = ResourceUtils.getResourceStream(loc,\n-            bus == null ? BusFactory.getDefaultBus() : bus);\n-        if (is == null) {\n-            return;\n-        }\n-        try (ByteArrayInputStream bis = IOUtils.loadIntoBAIS(is)) {\n-            XMLSource source = new XMLSource(bis);\n-            source.setBuffering();\n-            String targetNs = source.getValue(\"/*/@targetNamespace\");\n-\n-            Map<String, String> nsMap = Collections.singletonMap(\"xs\", Constants.URI_2001_SCHEMA_XSD);\n-            String[] elementNames = source.getValues(\"/*/xs:element/@name\", nsMap);\n-            externalQnamesMap.put(targetNs, Arrays.asList(elementNames));\n-            String schemaValue = source.getNode(\"/xs:schema\", nsMap, String.class);\n-            externalSchemasCache.add(schemaValue);\n-        }\n-    }\n-\n-    public void setUseJaxbContextForQnames(boolean checkJaxbOnly) {\n-        this.useJaxbContextForQnames = checkJaxbOnly;\n-    }\n-\n-    protected ElementQNameResolver createElementQNameResolver(JAXBContext context) {\n-        if (resolver != null) {\n-            return resolver;\n-        }\n-        if (useJaxbContextForQnames) {\n-            if (context != null) {\n-                JAXBContextProxy proxy = JAXBUtils.createJAXBContextProxy(context);\n-                return new JaxbContextQNameResolver(proxy);\n-            }\n-            return null;\n-        } else if (externalQnamesMap != null) {\n-            return new SchemaQNameResolver(externalQnamesMap);\n-        } else {\n-            return new XMLNameQNameResolver();\n-        }\n-    }\n-\n-    protected SchemaWriter createSchemaWriter(ResourceTypes resourceTypes, JAXBContext context, UriInfo ui) {\n-        // if neither externalSchemaLinks nor externalSchemasCache is set\n-        // then JAXBContext will be used to generate the schema\n-        if (externalSchemaLinks != null && externalSchemasCache == null) {\n-            return new ExternalSchemaWriter(externalSchemaLinks, ui);\n-        } else if (externalSchemasCache != null) {\n-            return new StringSchemaWriter(externalSchemasCache, externalSchemaLinks, ui);\n-        } else {\n-            SchemaCollection coll = getSchemaCollection(resourceTypes, context);\n-            if (coll != null) {\n-                return new SchemaCollectionWriter(coll);\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public void setExternalLinks(List<String> externalLinks) {\n-        externalSchemaLinks = new LinkedList<>();\n-        for (String s : externalLinks) {\n-            try {\n-                String href = s;\n-                if (href.startsWith(\"classpath:\")) {\n-                    int index = href.lastIndexOf('/');\n-                    href = index == -1 ? href.substring(9) : href.substring(index + 1);\n-                    docLocationMap.put(href, s);\n-                }\n-                externalSchemaLinks.add(URI.create(href));\n-            } catch (Exception ex) {\n-                LOG.warning(\"Not a valid URI : \" + s);\n-                externalSchemaLinks = null;\n-                break;\n-            }\n-        }\n-    }\n-\n-    protected interface SchemaWriter {\n-        void write(StringBuilder sb);\n-    }\n-\n-    private class StringSchemaWriter implements SchemaWriter {\n-\n-        private final List<String> theSchemas;\n-\n-        StringSchemaWriter(List<String> schemas, List<URI> links, UriInfo ui) {\n-            this.theSchemas = new LinkedList<>();\n-            // we'll need to do the proper schema caching eventually\n-            for (String s : schemas) {\n-                XMLSource source = new XMLSource(new ByteArrayInputStream(s.getBytes()));\n-                source.setBuffering();\n-                Map<String, String> locs = getLocationsMap(source, \"import\", links, ui);\n-                locs.putAll(getLocationsMap(source, \"include\", links, ui));\n-                String actualSchema = !locs.isEmpty() ? transformSchema(s, locs) : s;\n-                theSchemas.add(actualSchema);\n-            }\n-        }\n-\n-        private Map<String, String> getLocationsMap(XMLSource source, String elementName, List<URI> links,\n-                                                    UriInfo ui) {\n-            Map<String, String> nsMap = Collections.singletonMap(\"xs\", Constants.URI_2001_SCHEMA_XSD);\n-            String[] locations = source.getValues(\"/*/xs:\" + elementName + \"/@schemaLocation\", nsMap);\n-\n-            Map<String, String> locs = new HashMap<>();\n-            if (locations == null) {\n-                return locs;\n-            }\n-\n-            for (String loc : locations) {\n-                try {\n-                    URI uri = URI.create(loc);\n-                    if (!uri.isAbsolute()) {\n-                        if (links != null) {\n-                            for (URI overwriteURI : links) {\n-                                if (overwriteURI.toString().endsWith(loc)) {\n-                                    if (overwriteURI.isAbsolute()) {\n-                                        locs.put(loc, overwriteURI.toString());\n-                                    } else {\n-                                        locs.put(loc, ui.getBaseUriBuilder().path(overwriteURI.toString())\n-                                            .build().toString());\n-                                    }\n-                                    break;\n-                                }\n-                            }\n-                        }\n-                        if (!locs.containsKey(loc)) {\n-                            locs.put(loc, ui.getBaseUriBuilder().path(loc).build().toString());\n-                        }\n-                    }\n-                } catch (Exception ex) {\n-                    // continue\n-                }\n-            }\n-            return locs;\n-        }\n-\n-        private String transformSchema(String schema, Map<String, String> locs) {\n-            ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-            SchemaConverter sc = new SchemaConverter(StaxUtils.createXMLStreamWriter(bos), locs);\n-            try {\n-                StaxUtils.copy(new StreamSource(new StringReader(schema)), sc);\n-                sc.flush();\n-                sc.close();\n-                return bos.toString();\n-            } catch (Exception ex) {\n-                return schema;\n-            }\n-\n-        }\n-\n-        @Override\n-        public void write(StringBuilder sb) {\n-            for (String s : theSchemas) {\n-                sb.append(s);\n-            }\n-        }\n-    }\n-\n-    private class SchemaCollectionWriter implements SchemaWriter {\n-\n-        private final SchemaCollection coll;\n-\n-        SchemaCollectionWriter(SchemaCollection coll) {\n-            this.coll = coll;\n-        }\n-\n-        @Override\n-        public void write(StringBuilder sb) {\n-            for (XmlSchema xs : coll.getXmlSchemas()) {\n-                if (xs.getItems().isEmpty() || Constants.URI_2001_SCHEMA_XSD.equals(xs.getTargetNamespace())) {\n-                    continue;\n-                }\n-                StringWriter writer = new StringWriter();\n-                xs.write(writer);\n-                sb.append(writer.toString());\n-            }\n-        }\n-    }\n-\n-    private class ExternalSchemaWriter implements SchemaWriter {\n-\n-        private final List<URI> links;\n-        private final UriInfo uriInfo;\n-\n-        ExternalSchemaWriter(List<URI> links, UriInfo ui) {\n-            this.links = links;\n-            this.uriInfo = ui;\n-        }\n-\n-        @Override\n-        public void write(StringBuilder sb) {\n-            for (URI link : links) {\n-                try {\n-                    URI value = link.isAbsolute() ? link : uriInfo.getBaseUriBuilder().path(link.toString()).build();\n-                    sb.append(\"<include href=\\\"\").append(value.toString()).append(\"\\\"/>\");\n-                } catch (Exception ex) {\n-                    LOG.warning(\"WADL grammar section will be incomplete, this link is not a valid URI : \"\n-                                + link.toString());\n-                }\n-            }\n-        }\n-    }\n-\n-    private class JaxbContextQNameResolver implements ElementQNameResolver {\n-\n-        private final JAXBContextProxy proxy;\n-\n-        JaxbContextQNameResolver(JAXBContextProxy proxy) {\n-            this.proxy = proxy;\n-        }\n-\n-        @Override\n-        public QName resolve(Class<?> type, Annotation[] annotations, Map<Class<?>, QName> clsMap) {\n-            QName qname = WadlGenerator.this.getJaxbQName(proxy, type, clsMap);\n-            if (qname == null && supportJaxbXmlType) {\n-                XmlType root = type.getAnnotation(XmlType.class);\n-                if (root != null) {\n-                    XMLName name = AnnotationUtils.getAnnotation(annotations, XMLName.class);\n-                    if (name == null) {\n-                        qname = getJaxbQName(root.name(), root.namespace(), type, clsMap);\n-                    } else {\n-                        QName tempQName = JAXRSUtils.convertStringToQName(name.value());\n-                        qname = new QName(tempQName.getNamespaceURI(),\n-                                          tempQName.getLocalPart(),\n-                                          getPrefix(tempQName.getNamespaceURI(), clsMap));\n-                    }\n-                }\n-            }\n-            return qname;\n-        }\n-\n-    }\n-\n-    private class XMLNameQNameResolver implements ElementQNameResolver {\n-\n-        @Override\n-        public QName resolve(Class<?> type, Annotation[] annotations, Map<Class<?>, QName> clsMap) {\n-            XMLName name = AnnotationUtils.getAnnotation(annotations, XMLName.class);\n-            if (name == null) {\n-                name = type.getAnnotation(XMLName.class);\n-            }\n-            if (name != null) {\n-                QName qname = DOMUtils.convertStringToQName(name.value(), name.prefix());\n-                if (qname.getPrefix().length() > 0) {\n-                    return qname;\n-                }\n-                return getQNameFromParts(qname.getLocalPart(), qname.getNamespaceURI(), type, clsMap);\n-            }\n-            return null;\n-        }\n-\n-    }\n-\n-    private class SchemaQNameResolver implements ElementQNameResolver {\n-        private final Map<String, List<String>> map;\n-\n-        SchemaQNameResolver(Map<String, List<String>> map) {\n-            this.map = map;\n-        }\n-\n-        @Override\n-        public QName resolve(Class<?> type, Annotation[] annotations, Map<Class<?>, QName> clsMap) {\n-            String name = type.getSimpleName();\n-            for (Map.Entry<String, List<String>> entry : map.entrySet()) {\n-                String elementName = null;\n-                if (entry.getValue().contains(name)) {\n-                    elementName = name;\n-                } else if (entry.getValue().contains(name.toLowerCase())) {\n-                    elementName = name.toLowerCase();\n-                }\n-                if (elementName != null) {\n-                    return getQNameFromParts(elementName, entry.getKey(), type, clsMap);\n-                }\n-            }\n-            return null;\n-        }\n-\n-    }\n-\n-    public void setResolver(ElementQNameResolver resolver) {\n-        this.resolver = resolver;\n-    }\n-\n-    public void setPrivateAddresses(List<String> privateAddresses) {\n-        this.privateAddresses = privateAddresses;\n-    }\n-\n-    public List<String> getPrivateAddresses() {\n-        return privateAddresses;\n-    }\n-\n-\n-    public void setAddResourceAndMethodIds(boolean addResourceAndMethodIds) {\n-        ResourceIdGenerator idGen = addResourceAndMethodIds ? new ResourceIdGeneratorImpl() : null;\n-        setResourceIdGenerator(idGen);\n-    }\n-    public void setResourceIdGenerator(ResourceIdGenerator idGen) {\n-        this.idGenerator = idGen;\n-    }\n-\n-    private Method getMethod(OperationResourceInfo ori) {\n-        Method annMethod = ori.getAnnotatedMethod();\n-        return annMethod != null ? annMethod : ori.getMethodToInvoke();\n-    }\n-\n-    public void setApplicationTitle(String applicationTitle) {\n-        this.applicationTitle = applicationTitle;\n-    }\n-\n-    public void setNamespacePrefix(String prefix) {\n-        this.nsPrefix = prefix;\n-    }\n-\n-    public void setIgnoreForwardSlash(boolean ignoreForwardSlash) {\n-        this.ignoreForwardSlash = ignoreForwardSlash;\n-    }\n-\n-    public void setIgnoreRequests(boolean ignoreRequests) {\n-        this.ignoreRequests = ignoreRequests;\n-    }\n-\n-    public void setSupportCollections(boolean support) {\n-        this.supportCollections = support;\n-    }\n-\n-    /**\n-     * Set the default WADL response media type.\n-     * For example, a browser may display WADL better if Content-Type\n-     * is set to application/xml which is a default response content type.\n-     * Users may set it to application/vnd.sun.wadl+xml or other type.\n-     * @param mt WADL response media type\n-     */\n-    public void setDefaultMediaType(String mt) {\n-        this.defaultWadlResponseMediaType = JAXRSUtils.toMediaType(mt);\n-    }\n-\n-    /**\n-     * Set the default representation media type to be used\n-     * if JAX-RS Produces or Consumes annotation is missing.\n-     * Wild-card media type is used by default in such cases.\n-     * @param mt the default representation media type\n-     */\n-    public void setDefaultRepresentationMediaType(String mt) {\n-        this.defaultWadlResponseMediaType = JAXRSUtils.toMediaType(mt);\n-    }\n-\n-    public void setSupportJaxbXmlType(boolean supportJaxbXmlType) {\n-        this.supportJaxbXmlType = supportJaxbXmlType;\n-    }\n-\n-    public void setSupportJaxbSubstitutions(boolean supportJaxbSubstitutions) {\n-        this.supportJaxbSubstitutions = supportJaxbSubstitutions;\n-    }\n-\n-    public void setCheckAbsolutePathSlash(boolean checkAbsolutePathSlash) {\n-        this.checkAbsolutePathSlash = checkAbsolutePathSlash;\n-    }\n-\n-    public void setJavaDocPath(String path) throws Exception {\n-        setDocumentationProvider(new JavaDocProvider(bus == null ? BusFactory.getDefaultBus() : bus, path));\n-    }\n-\n-    public void setJavaDocPaths(String... paths) throws Exception {\n-        setDocumentationProvider(new JavaDocProvider(bus == null ? BusFactory.getDefaultBus() : bus, paths));\n-    }\n-\n-    public void setJavaDocURLs(final URL[] javaDocURLs) {\n-        setDocumentationProvider(new JavaDocProvider(javaDocURLs));\n-    }\n-\n-    public void setDocumentationProvider(DocumentationProvider p) {\n-        docProviders.add(p);\n-    }\n-    public void setDocumentationProvider(List<DocumentationProvider> ps) {\n-        docProviders.addAll(ps);\n-    }\n-    public void setStylesheetReference(String stylesheetReference) {\n-        this.stylesheetReference = stylesheetReference;\n-    }\n-    public void setWadlSchemaLocation(String loc) {\n-        this.wadlSchemaLocation = loc;\n-    }\n-    public void setIncludeDefaultWadlSchemaLocation(boolean inc) {\n-        if (inc) {\n-            setWadlSchemaLocation(DEFAULT_WADL_SCHEMA_LOC);\n-        }\n-    }\n-\n-    public void setIgnoreOverloadedMethods(boolean ignore) {\n-        this.ignoreOverloadedMethods = ignore;\n-    }\n-\n-    public void setKeepRelativeDocLinks(boolean keepRelativeDocLinks) {\n-        this.keepRelativeDocLinks = keepRelativeDocLinks;\n-    }\n-\n-    public void setApplyStylesheetLocally(boolean applyStylesheetLocally) {\n-        this.applyStylesheetLocally = applyStylesheetLocally;\n-    }\n-\n-    public void setUsePathParamsToCompareOperations(boolean usePathParamsToCompareOperations) {\n-        this.usePathParamsToCompareOperations = usePathParamsToCompareOperations;\n-    }\n-\n-    public void setConvertResourcesToDOM(boolean convertResourcesToDOM) {\n-        this.convertResourcesToDOM = convertResourcesToDOM;\n-    }\n-\n-    public void setIncrementNamespacePrefix(boolean incrementNamespacePrefix) {\n-        this.incrementNamespacePrefix = incrementNamespacePrefix;\n-    }\n-    public void setJaxbContextProperties(Map<String, Object> jaxbContextProperties) {\n-        this.jaxbContextProperties = jaxbContextProperties;\n-    }\n-\n-\n-    public List<String> getAllowList() {  //Liberty change\n-        return allowList;\n-    }\n-\n-    public void setAllowList(List<String> allowList) { //Liberty change\n-        this.allowList = allowList;\n-    }\n-\n-    private static class SchemaConverter extends DelegatingXMLStreamWriter {\n-        private static final String SCHEMA_LOCATION = \"schemaLocation\";\n-        private final Map<String, String> locsMap;\n-\n-        SchemaConverter(XMLStreamWriter writer, Map<String, String> locsMap) {\n-            super(writer);\n-            this.locsMap = locsMap;\n-        }\n-\n-        @Override\n-        public void writeAttribute(String local, String value) throws XMLStreamException {\n-            if (SCHEMA_LOCATION.equals(local) && locsMap.containsKey(value)) {\n-                value = locsMap.get(value);\n-            }\n-            super.writeAttribute(local, value);\n-        }\n-    }\n-\n-\n-    private class ResourceIdGeneratorImpl implements ResourceIdGenerator {\n-\n-        @Override\n-        public String getClassResourceId(ClassResourceInfo cri) {\n-            Class<?> serviceClass = cri != null ? cri.getServiceClass() : Object.class;\n-            QName jaxbQname = null;\n-            if (useJaxbContextForQnames) {\n-                jaxbQname = getJaxbQName(null, serviceClass, new HashMap<Class<?>, QName>(0));\n-            }\n-            String pName = jaxbQname == null ? PackageUtils.getPackageName(serviceClass) : null;\n-            String localName = jaxbQname == null ? serviceClass.getSimpleName() : jaxbQname.getLocalPart();\n-            String nsName = jaxbQname == null ? pName + \".\" : \"\";\n-            return nsName + localName;\n-        }\n-\n-        @Override\n-        public String getMethodResourceId(OperationResourceInfo ori) {\n-            return getMethod(ori).getName();\n-        }\n-\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDM4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490584381", "bodyText": "I don't see where this import is used.  Maybe Eclipse added it incorrectly?", "author": "andymc12", "createdAt": "2020-09-17T21:55:50Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java", "diffHunk": "@@ -28,6 +28,7 @@\n import org.apache.cxf.Bus;\n import org.apache.cxf.BusFactory;\n import org.apache.cxf.binding.Binding;\n+import org.apache.cxf.common.classloader.ClassLoaderUtils.ClassLoaderHolder;", "originalCommit": "9137155bddf6d233f87b69e01debd763b4f00078", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java b/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java\nindex 3b24df211b..9da22872bc 100644\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java\n+++ b/dev/com.ibm.ws.org.apache.cxf.cxf.core.3.2/src/org/apache/cxf/transport/ChainInitiationObserver.java\n\n@@ -28,7 +28,6 @@ import javax.xml.namespace.QName;\n import org.apache.cxf.Bus;\n import org.apache.cxf.BusFactory;\n import org.apache.cxf.binding.Binding;\n-import org.apache.cxf.common.classloader.ClassLoaderUtils.ClassLoaderHolder;\n import org.apache.cxf.endpoint.Endpoint;\n import org.apache.cxf.helpers.CastUtils;\n import org.apache.cxf.interceptor.Interceptor;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NDY1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490584657", "bodyText": "another inadvertent import? I don't see any reference to ti JAXBUtils", "author": "andymc12", "createdAt": "2020-09-17T21:56:34Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/utils/ResourceUtils.java", "diffHunk": "@@ -76,6 +76,7 @@\n import org.apache.cxf.BusFactory;\n import org.apache.cxf.common.classloader.ClassLoaderUtils;\n import org.apache.cxf.common.i18n.BundleUtils;\n+import org.apache.cxf.common.jaxb.JAXBUtils;", "originalCommit": "9137155bddf6d233f87b69e01debd763b4f00078", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/utils/ResourceUtils.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/utils/ResourceUtils.java\nindex c0cd9e7c0b..5dd9a3b189 100644\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/utils/ResourceUtils.java\n+++ b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.frontend.jaxrs.3.2/src/org/apache/cxf/jaxrs/utils/ResourceUtils.java\n\n@@ -76,7 +76,6 @@ import org.apache.cxf.Bus;\n import org.apache.cxf.BusFactory;\n import org.apache.cxf.common.classloader.ClassLoaderUtils;\n import org.apache.cxf.common.i18n.BundleUtils;\n-import org.apache.cxf.common.jaxb.JAXBUtils;\n import org.apache.cxf.common.logging.LogUtils;\n import org.apache.cxf.common.util.ReflectionUtil;\n import org.apache.cxf.common.util.StringUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDU4NzEyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13951#discussion_r490587124", "bodyText": "for this change, I'd probably leave the String uri... line, so something like:\nString uri = currentURI.toString();\nmessage.put(Message.ENDPOINT_ADDRESS, uri);\nmessage.put(Message.REQUEST_URI, uri);\n\nthat way, we're only calling uri.toString() once.", "author": "andymc12", "createdAt": "2020-09-17T22:02:34Z", "path": "dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.client.3.2/src/org/apache/cxf/jaxrs/client/AbstractClient.java", "diffHunk": "@@ -931,29 +931,25 @@ protected void setConfiguration(ClientConfiguration config) {\n     // invocation thus it is also important to have baseURI and currentURI\n     // synched up with the latest endpoint address, after a successful proxy\n     // or web client invocation has returned\n-    protected void prepareConduitSelector(Message m, URI currentURI, boolean proxy) {\n+    protected void prepareConduitSelector(Message message, URI currentURI, boolean proxy) {\n         try {\n-            cfg.prepareConduitSelector(m);\n+            cfg.prepareConduitSelector(message);\n \n         } catch (Fault ex) {\n             LOG.warning(\"Failure to prepare a message from conduit selector\");\n         }\n-        //Liberty code change start\n-        MessageImpl message = (MessageImpl) m;\n         message.getExchange().put(ConduitSelector.class, cfg.getConduitSelector());\n         message.getExchange().put(Service.class, cfg.getConduitSelector().getEndpoint().getService());\n \n-        String address = (String)message.getEndpointAddress();\n+        String address = (String)message.get(Message.ENDPOINT_ADDRESS);\n         // custom conduits may override the initial/current address\n         if (address.startsWith(HTTP_SCHEME) && !address.equals(currentURI.toString())) {\n             URI baseAddress = URI.create(address);\n             currentURI = calculateNewRequestURI(baseAddress, currentURI, proxy);\n-            String uri = currentURI.toString();\n-            message.setEndpointAddress(uri);\n-            message.setRequestUri(uri);\n+            message.put(Message.ENDPOINT_ADDRESS, currentURI.toString());\n+            message.put(Message.REQUEST_URI, currentURI.toString());", "originalCommit": "9137155bddf6d233f87b69e01debd763b4f00078", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "chunk": "diff --git a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.client.3.2/src/org/apache/cxf/jaxrs/client/AbstractClient.java b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.client.3.2/src/org/apache/cxf/jaxrs/client/AbstractClient.java\nindex 8cf0f32de9..812f8a20ba 100644\n--- a/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.client.3.2/src/org/apache/cxf/jaxrs/client/AbstractClient.java\n+++ b/dev/com.ibm.ws.org.apache.cxf.cxf.rt.rs.client.3.2/src/org/apache/cxf/jaxrs/client/AbstractClient.java\n\n@@ -946,8 +946,9 @@ public abstract class AbstractClient implements Client {\n         if (address.startsWith(HTTP_SCHEME) && !address.equals(currentURI.toString())) {\n             URI baseAddress = URI.create(address);\n             currentURI = calculateNewRequestURI(baseAddress, currentURI, proxy);\n-            message.put(Message.ENDPOINT_ADDRESS, currentURI.toString());\n-            message.put(Message.REQUEST_URI, currentURI.toString());\n+            String uri = currentURI.toString();\n+            message.put(Message.ENDPOINT_ADDRESS, uri);\n+            message.put(Message.REQUEST_URI, uri);\n         }\n         message.put(Message.BASE_PATH, getBaseURI().toString());\n     }\n"}}, {"oid": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "url": "https://github.com/OpenLiberty/open-liberty/commit/0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "message": "Merge revert of 11560\n\nupdate jaxws-2.3 to expose APIs to APP classpath\n\nRevert \"Initial check in of MessageImpl refactoring\"\n\nThis reverts commit f9cdd9d131c2b75cd3739583c266dcb0e5140e62.\n\nFix issues caused by revert\n\nadd addition change required\n\nundo local merge issue\n\nRevert MessageImplTest\n\nMinimize Liberty speciifc overrides of CXF\n\nMore codereview edits to CXF\n\nFinish code review changes to CXF", "committedDate": "2020-09-18T13:07:01Z", "type": "commit"}, {"oid": "0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "url": "https://github.com/OpenLiberty/open-liberty/commit/0fc79bad88c6faec3b60b5b128156d9b85db1bd2", "message": "Merge revert of 11560\n\nupdate jaxws-2.3 to expose APIs to APP classpath\n\nRevert \"Initial check in of MessageImpl refactoring\"\n\nThis reverts commit f9cdd9d131c2b75cd3739583c266dcb0e5140e62.\n\nFix issues caused by revert\n\nadd addition change required\n\nundo local merge issue\n\nRevert MessageImplTest\n\nMinimize Liberty speciifc overrides of CXF\n\nMore codereview edits to CXF\n\nFinish code review changes to CXF", "committedDate": "2020-09-18T13:07:01Z", "type": "forcePushed"}, {"oid": "0d5c1d0a4cb59a3e859d22d0d6ed6b1454c87020", "url": "https://github.com/OpenLiberty/open-liberty/commit/0d5c1d0a4cb59a3e859d22d0d6ed6b1454c87020", "message": "Readd NPE check", "committedDate": "2020-09-23T00:56:03Z", "type": "commit"}]}