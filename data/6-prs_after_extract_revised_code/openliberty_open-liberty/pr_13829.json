{"pr_number": 13829, "pr_title": "Implicit Converter Cache", "pr_createdAt": "2020-09-08T16:47:42Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/13829", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486513357", "bodyText": "I have concerns that the synchronizedMap will become a bottleneck.  Should you consider a ConcurrentHashmap?  Of course we can measure to see if it becomes a bottleneck if you want to wait for that before making a decision.", "author": "jhanders34", "createdAt": "2020-09-10T17:28:34Z", "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n+        this(converterType, getImplicitFunction(converterType));\n+    }\n+\n+    @Trivial\n+    public ImplicitConverter(Class<?> converterType, Function<String, ?> implicitFunction) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n+        this.implicitFunction = implicitFunction;\n+    }\n+\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n+        implicitFunction = getConstructorFunction(converterType);\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"constructor\");\n+            }\n         }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getParseFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"valueOf\");\n+            }\n         }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n+        if (implicitFunction == null) {\n             throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"parse\");\n             }\n         }\n+        return implicitFunction;\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n+    protected static <X> Function<String, X> getConstructorFunction(Class<X> reflectionClass) {\n+        Function<String, X> implicitFunction = null;\n         try {\n-            ctor = reflectionClass.getConstructor(String.class);\n+            Constructor<X> ctor = reflectionClass.getConstructor(String.class);\n+            implicitFunction = wrapConstructor(reflectionClass, ctor);\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return ctor;\n+\n+        return implicitFunction;\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+    protected static Function<String, ?> getValueOfFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"valueOf\", String.class);\n+    }\n \n-        return method;\n+    @Trivial\n+    protected static Function<String, ?> getParseFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"parse\", CharSequence.class);\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n+    protected static Function<String, ?> getFunction(Class<?> reflectionClass, String methodName, Class<?>... paramTypes) {\n+        Function<String, ?> implicitFunction = null;\n         try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n+            Method method = reflectionClass.getMethod(methodName, paramTypes);\n             if ((method.getModifiers() & Modifier.STATIC) == 0) {\n                 method = null;\n             } else if (!reflectionClass.equals(method.getReturnType())) {\n                 method = null;\n             }\n+\n+            if (method != null) {\n+                implicitFunction = wrapMethod(reflectionClass, method);\n+            }\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return method;\n+        return implicitFunction;\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapMethod(Class<X> reflectionClass, Method method) {\n+        return new MethodFunction<X>(reflectionClass, method);\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapConstructor(Class<X> reflectionClass, Constructor<X> ctor) {\n+        return new ConstructorFunction<X>(reflectionClass, ctor);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-                if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new ConversionException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new ConversionException(e);\n-            }\n-        }\n-        return converted;\n+        return this.implicitFunction.apply(value);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public String toString() {\n         return \"Implicit Converter for type \" + getType();\n     }\n+\n+    protected static class ConstructorFunction<X> implements Function<String, X> {\n+        private final static Map<Class<?>, Constructor<?>> constructorCache = Collections.synchronizedMap(new WeakHashMap<>());", "originalCommit": "c2e036eec97ed60c54ad13e72029a5158b852580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxNzMwNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486517305", "bodyText": "Why do we need this cache at all?  Isn't the cache in the manager sufficient?", "author": "jhanders34", "createdAt": "2020-09-10T17:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0ODY2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486648664", "bodyText": "I guess this comment is more important in the Manager if we don't keep the constructor / method ones.", "author": "jhanders34", "createdAt": "2020-09-10T21:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg3NjQ3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486876476", "bodyText": "I don't think there is such a thing as a ConcurrentWeakHashMap??\nYou told me that if the ImplicitConverter had a reference to the Constructor or Methods then the WeakHashMap cache in the Manager would not be enough. The Method would hold a reference to the Class and the WeakReference in the cache would never get removed?", "author": "tevans78", "createdAt": "2020-09-11T08:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MDk0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r487190940", "bodyText": "There is not a ConcurrentWeakHashMap.  You can easily use a ConcurrentHashMap with a WeakReference impl key.  I showed examples of how to do that via slack earlier.\nRight now I see you look up ever time and didn't have a reference to the Method / Constructor in the function which is what I thought it was doing because that would make sense.  Instead I would suggest that the Function have a WeakReference to the Method / Constructor and you just do a get on the WeakReference to get the Method / Constructor instead of using yet another WeakHashMap which wouldn't work anyway because the value is the Constructor / Method which will keep a hard reference on the Class.  The only way to use the WeakHashMap would be to create a WeakReference on the Constructor / Method to use it as the value so it is best just to not use the WeakHashMap.", "author": "jhanders34", "createdAt": "2020-09-11T17:35:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjc2ODE1Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r532768153", "bodyText": "The WeakHashMap stuff was too hard to make work efficiently. So I gave up on the static caches and went with a simple cache on the Config12ConversionManager. This is scoped by the Config itself so when the application is stopped, the Config is removed and this cache will go too.", "author": "tevans78", "createdAt": "2020-11-30T17:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxMzM1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0571aee48ed225c10ccc532d022b16b8695d1af2", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\nindex 1653f619c1..3d9efadfd2 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n\n@@ -11,29 +11,23 @@\n package com.ibm.ws.microprofile.config12.converters;\n \n import java.lang.ref.WeakReference;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-import java.util.function.Function;\n+import java.lang.reflect.Executable;\n \n import com.ibm.websphere.ras.Tr;\n import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.websphere.ras.annotation.Trivial;\n-import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n-import com.ibm.ws.microprofile.config.converters.BuiltInConverter;\n+import com.ibm.ws.microprofile.config.converters.PriorityConverter;\n+import com.ibm.ws.microprofile.config.interfaces.ConfigConstants;\n import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n \n /**\n  *\n  */\n-public class ImplicitConverter extends BuiltInConverter {\n+public class ImplicitConverter extends PriorityConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private final Function<String, ?> implicitFunction;\n+    private WeakFunction<?> weakFunction;\n+    private final WeakReference<Class<?>> classRef;\n \n     /**\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxNDEwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486514108", "bodyText": "This will still leak.  The WeakReference on a WeakHashMap is on the key.  The problem is that the value is a Constructor or Method.  Both of those Object types will also have a reference to the Class which will keep it from being garbage collected.", "author": "jhanders34", "createdAt": "2020-09-10T17:29:49Z", "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n+        this(converterType, getImplicitFunction(converterType));\n+    }\n+\n+    @Trivial\n+    public ImplicitConverter(Class<?> converterType, Function<String, ?> implicitFunction) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n+        this.implicitFunction = implicitFunction;\n+    }\n+\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n+        implicitFunction = getConstructorFunction(converterType);\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"constructor\");\n+            }\n         }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getParseFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"valueOf\");\n+            }\n         }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n+        if (implicitFunction == null) {\n             throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"parse\");\n             }\n         }\n+        return implicitFunction;\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n+    protected static <X> Function<String, X> getConstructorFunction(Class<X> reflectionClass) {\n+        Function<String, X> implicitFunction = null;\n         try {\n-            ctor = reflectionClass.getConstructor(String.class);\n+            Constructor<X> ctor = reflectionClass.getConstructor(String.class);\n+            implicitFunction = wrapConstructor(reflectionClass, ctor);\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return ctor;\n+\n+        return implicitFunction;\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+    protected static Function<String, ?> getValueOfFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"valueOf\", String.class);\n+    }\n \n-        return method;\n+    @Trivial\n+    protected static Function<String, ?> getParseFunction(Class<?> reflectionClass) {\n+        return getFunction(reflectionClass, \"parse\", CharSequence.class);\n     }\n \n     @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n+    protected static Function<String, ?> getFunction(Class<?> reflectionClass, String methodName, Class<?>... paramTypes) {\n+        Function<String, ?> implicitFunction = null;\n         try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n+            Method method = reflectionClass.getMethod(methodName, paramTypes);\n             if ((method.getModifiers() & Modifier.STATIC) == 0) {\n                 method = null;\n             } else if (!reflectionClass.equals(method.getReturnType())) {\n                 method = null;\n             }\n+\n+            if (method != null) {\n+                implicitFunction = wrapMethod(reflectionClass, method);\n+            }\n         } catch (NoSuchMethodException e) {\n             //No FFDC\n         }\n-        return method;\n+        return implicitFunction;\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapMethod(Class<X> reflectionClass, Method method) {\n+        return new MethodFunction<X>(reflectionClass, method);\n+    }\n+\n+    @Trivial\n+    protected static <X> Function<String, X> wrapConstructor(Class<X> reflectionClass, Constructor<X> ctor) {\n+        return new ConstructorFunction<X>(reflectionClass, ctor);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-                if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new ConversionException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new ConversionException(e);\n-            }\n-        }\n-        return converted;\n+        return this.implicitFunction.apply(value);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public String toString() {\n         return \"Implicit Converter for type \" + getType();\n     }\n+\n+    protected static class ConstructorFunction<X> implements Function<String, X> {\n+        private final static Map<Class<?>, Constructor<?>> constructorCache = Collections.synchronizedMap(new WeakHashMap<>());\n+        private final WeakReference<Class<?>> classRef;\n+\n+        protected ConstructorFunction(Class<X> conversionType, Constructor<X> ctor) {\n+            constructorCache.put(conversionType, ctor);", "originalCommit": "c2e036eec97ed60c54ad13e72029a5158b852580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg3ODE5Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486878192", "bodyText": "hmmm yep, fair point ... any suggestions?", "author": "tevans78", "createdAt": "2020-09-11T08:59:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxNDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MTI1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r487191259", "bodyText": "I answered in the review comment above.  Hopefully it will be sufficient.", "author": "jhanders34", "createdAt": "2020-09-11T17:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjUxNDEwOA=="}], "type": "inlineReview", "revised_code": {"commit": "0571aee48ed225c10ccc532d022b16b8695d1af2", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\nindex 1653f619c1..3d9efadfd2 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n\n@@ -11,29 +11,23 @@\n package com.ibm.ws.microprofile.config12.converters;\n \n import java.lang.ref.WeakReference;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-import java.util.function.Function;\n+import java.lang.reflect.Executable;\n \n import com.ibm.websphere.ras.Tr;\n import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.websphere.ras.annotation.Trivial;\n-import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n-import com.ibm.ws.microprofile.config.converters.BuiltInConverter;\n+import com.ibm.ws.microprofile.config.converters.PriorityConverter;\n+import com.ibm.ws.microprofile.config.interfaces.ConfigConstants;\n import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n \n /**\n  *\n  */\n-public class ImplicitConverter extends BuiltInConverter {\n+public class ImplicitConverter extends PriorityConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private final Function<String, ?> implicitFunction;\n+    private WeakFunction<?> weakFunction;\n+    private final WeakReference<Class<?>> classRef;\n \n     /**\n      *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3MDQxNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486570415", "bodyText": "Since you are not using Tr.formatMessage, the {0}  and {1} substitutions will not be used.  You might as well remove them to avoid the ugliness in trace.", "author": "jhanders34", "createdAt": "2020-09-10T19:02:16Z", "path": "dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java", "diffHunk": "@@ -43,138 +44,47 @@\n      * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n      * </ul>\n      *\n-     *\n      * @param converterType The class to convert using\n      */\n-    public Config13ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n+    @Trivial\n+    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n+        Function<String, ?> implicitFunction = null;\n \n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.ctor = getConstructor(converterType);\n-                if (this.ctor == null) {\n-                    this.parseMethod = getParse(converterType);\n-                }\n+        implicitFunction = getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = getValueOfFunction(converterType);\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"of\");", "originalCommit": "c2e036eec97ed60c54ad13e72029a5158b852580", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0571aee48ed225c10ccc532d022b16b8695d1af2", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\nindex 3ab3ba477b..dfa084c59f 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\n\n@@ -47,26 +50,26 @@ public class Config13ImplicitConverter extends ImplicitConverter {\n      * @param converterType The class to convert using\n      */\n     @Trivial\n-    private static Function<String, ?> getImplicitFunction(Class<?> converterType) {\n-        Function<String, ?> implicitFunction = null;\n+    private static WeakFunction<?> getImplicitFunction(Class<?> converterType) {\n+        WeakFunction<?> implicitFunction = null;\n \n-        implicitFunction = getOfMethod(converterType);\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n         if (implicitFunction == null) {\n-            implicitFunction = getValueOfFunction(converterType);\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                 Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"of\");\n             }\n         }\n         if (implicitFunction == null) {\n-            implicitFunction = getConstructorFunction(converterType);\n+            implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                 Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"valueOf\");\n             }\n         }\n         if (implicitFunction == null) {\n-            implicitFunction = getParseFunction(converterType);\n+            implicitFunction = MethodFunction.getParseFunction(converterType);\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                 Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, \"constructor\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486616159", "bodyText": "I assume some of these base classes like BuiltinConverter and ImplicitConverter could move to the common bundle at some point?", "author": "jhanders34", "createdAt": "2020-09-10T20:32:06Z", "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -28,117 +33,196 @@\n public class ImplicitConverter extends BuiltInConverter {", "originalCommit": "c2e036eec97ed60c54ad13e72029a5158b852580", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg4MTI4NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486881284", "bodyText": "Do you mean io.openliberty.microprofile.config.internal.common? That is for the common classes between our original impl and the SmallyRye impl. These changes don't affect the SmallRye impl.", "author": "tevans78", "createdAt": "2020-09-11T09:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg4Mjc5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r486882791", "bodyText": "I don't remember why that bundle is separate from io.openliberty.microprofile.config.internal.serverxml", "author": "tevans78", "createdAt": "2020-09-11T09:04:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "0571aee48ed225c10ccc532d022b16b8695d1af2", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\nindex 1653f619c1..3d9efadfd2 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n\n@@ -11,29 +11,23 @@\n package com.ibm.ws.microprofile.config12.converters;\n \n import java.lang.ref.WeakReference;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.Collections;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-import java.util.function.Function;\n+import java.lang.reflect.Executable;\n \n import com.ibm.websphere.ras.Tr;\n import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.websphere.ras.annotation.Trivial;\n-import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n-import com.ibm.ws.microprofile.config.converters.BuiltInConverter;\n+import com.ibm.ws.microprofile.config.converters.PriorityConverter;\n+import com.ibm.ws.microprofile.config.interfaces.ConfigConstants;\n import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n \n /**\n  *\n  */\n-public class ImplicitConverter extends BuiltInConverter {\n+public class ImplicitConverter extends PriorityConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private final Function<String, ?> implicitFunction;\n+    private WeakFunction<?> weakFunction;\n+    private final WeakReference<Class<?>> classRef;\n \n     /**\n      *\n"}}, {"oid": "0571aee48ed225c10ccc532d022b16b8695d1af2", "url": "https://github.com/OpenLiberty/open-liberty/commit/0571aee48ed225c10ccc532d022b16b8695d1af2", "message": "Implicit Converter Cache", "committedDate": "2020-11-25T19:06:47Z", "type": "forcePushed"}, {"oid": "3f4da57b9095ff5c672a5ab04862727d9411f4fd", "url": "https://github.com/OpenLiberty/open-liberty/commit/3f4da57b9095ff5c672a5ab04862727d9411f4fd", "message": "Implicit Converter Cache", "committedDate": "2020-11-30T16:19:36Z", "type": "forcePushed"}, {"oid": "7aa0b6ebb4cfb262dd581116f78c601ff532388b", "url": "https://github.com/OpenLiberty/open-liberty/commit/7aa0b6ebb4cfb262dd581116f78c601ff532388b", "message": "Implicit Converter Cache", "committedDate": "2020-11-30T17:01:51Z", "type": "forcePushed"}, {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "url": "https://github.com/OpenLiberty/open-liberty/commit/13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "message": "Implicit Converter Cache", "committedDate": "2020-11-30T17:18:49Z", "type": "commit"}, {"oid": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "url": "https://github.com/OpenLiberty/open-liberty/commit/13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "message": "Implicit Converter Cache", "committedDate": "2020-11-30T17:18:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5OTgwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535399806", "bodyText": "There's nothing unchecked to suppress", "author": "Azquelt", "createdAt": "2020-12-03T16:45:42Z", "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ConstructorFunction.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.config12.converters;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.function.Function;\n+\n+import com.ibm.websphere.ras.annotation.Trivial;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n+\n+public class ConstructorFunction<X> implements Function<String, X> {\n+    private final Constructor<X> constructor;\n+\n+    public ConstructorFunction(Constructor<X> constructor) {\n+        this.constructor = constructor;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MzAwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r536093007", "bodyText": "removed", "author": "tevans78", "createdAt": "2020-12-04T13:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5OTgwNg=="}], "type": "inlineReview", "revised_code": {"commit": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ConstructorFunction.java b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ConstructorFunction.java\nindex a8f5532bed..5a9be86ebd 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ConstructorFunction.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ConstructorFunction.java\n\n@@ -26,8 +26,8 @@ public class ConstructorFunction<X> implements Function<String, X> {\n     }\n \n     /** {@inheritDoc} */\n-    @SuppressWarnings(\"unchecked\")\n     @Override\n+    @FFDCIgnore(InvocationTargetException.class)\n     public X apply(String value) {\n         X converted = null;\n         if (value != null) { //if the value is null then we always return null\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwODkzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535408930", "bodyText": "I really don't like these multiply nested if blocks with the debug messages separated from the case that it relates to.\nIf you want to avoid early returns, I'd suggest\n        Function<String, X> implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n\n        if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n        }\n\n        if (implicitFunction == null) {\n            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n\n            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n            }\n        }\n\n        if (implicitFunction == null) {\n            implicitFunction = MethodFunction.getParseFunction(converterType);\n\n            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n            }\n        }\n\n        if (implicitFunction == null) {\n            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n        }\n\n        return implicitFunction;", "author": "Azquelt", "createdAt": "2020-12-03T16:55:04Z", "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java", "diffHunk": "@@ -10,130 +10,65 @@\n  *******************************************************************************/\n package com.ibm.ws.microprofile.config12.converters;\n \n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n+import java.util.function.Function;\n \n import com.ibm.websphere.ras.Tr;\n import com.ibm.websphere.ras.TraceComponent;\n import com.ibm.websphere.ras.annotation.Trivial;\n-import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n import com.ibm.ws.microprofile.config.converters.BuiltInConverter;\n-import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n \n /**\n  *\n  */\n public class ImplicitConverter extends BuiltInConverter {\n \n     private static final TraceComponent tc = Tr.register(ImplicitConverter.class);\n-    private Method valueOfMethod;\n-    private final Constructor<?> ctor;\n-    private Method parseMethod;\n+    private final Function<String, ?> implicitFunction;\n \n-    @Trivial\n     /**\n      *\n      * @param converterType The class to convert using\n      */\n+    @Trivial\n     public ImplicitConverter(Class<?> converterType) {\n         super(converterType);\n-        this.ctor = getConstructor(converterType);\n-        if (this.ctor == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-        }\n-        if (this.ctor == null && this.valueOfMethod == null) {\n-            this.parseMethod = getParse(converterType);\n-        }\n-\n-        if (this.ctor == null && this.valueOfMethod == null && this.parseMethod == null) {\n-            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n-            }\n-        }\n+        this.implicitFunction = getImplicitFunction(converterType);\n     }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n     @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n-        try {\n-            ctor = reflectionClass.getConstructor(String.class);\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-        return ctor;\n-    }\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n \n-        return method;\n-    }\n+            if (implicitFunction == null) {\n+                implicitFunction = MethodFunction.getParseFunction(converterType);\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n+                if (implicitFunction == null) {\n+                    throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+                } else {\n+                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n+                    }\n+                }\n+            } else {\n+                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n+                }\n+            }\n+        } else {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n             }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n         }\n-        return method;\n+        return implicitFunction;", "originalCommit": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzODg5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535438897", "bodyText": "That certainly looks better but I will do it in a follow up.", "author": "tevans78", "createdAt": "2020-12-03T17:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwODkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MzI2MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r536093261", "bodyText": "done in 2nd commit", "author": "tevans78", "createdAt": "2020-12-04T13:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQwODkzMA=="}], "type": "inlineReview", "revised_code": {"commit": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\nindex 833744dd44..bc36f4b5b4 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/ImplicitConverter.java\n\n@@ -35,33 +35,45 @@ public class ImplicitConverter extends BuiltInConverter {\n         this.implicitFunction = getImplicitFunction(converterType);\n     }\n \n+    /**\n+     * <p>If no explicit Converter and no built-in Converter could be found for a certain type,\n+     * the {@code Config} provides an <em>Implicit Converter</em>, if</p>\n+     * <ul>\n+     * <li>The target type {@code T} has a public Constructor with a String parameter, or</li>\n+     * <li>the target type {@code T} has a {@code public static T valueOf(String)} method, or</li>\n+     * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n+     * </ul>\n+     *\n+     * @param converterType The class to convert using\n+     */\n     @Trivial\n     protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n         Function<String, X> implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n \n+        if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n+        }\n+\n         if (implicitFunction == null) {\n             implicitFunction = MethodFunction.getValueOfFunction(converterType);\n \n-            if (implicitFunction == null) {\n-                implicitFunction = MethodFunction.getParseFunction(converterType);\n-\n-                if (implicitFunction == null) {\n-                    throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n-                } else {\n-                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n-                    }\n-                }\n-            } else {\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n-                }\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n             }\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n+        }\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getParseFunction(converterType);\n+\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n             }\n         }\n+\n+        if (implicitFunction == null) {\n+            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+        }\n+\n         return implicitFunction;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNzg5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535427891", "bodyText": "Should this have @FFDCIgnore since we're throwing the exception up to the user anyway?\nAn exception here presumably means they had a method or constructor to create an object from a String, but calling it threw an exception?", "author": "Azquelt", "createdAt": "2020-12-03T17:15:48Z", "path": "dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/MethodFunction.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.microprofile.config12.converters;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.function.Function;\n+\n+import com.ibm.websphere.ras.annotation.Trivial;\n+import com.ibm.ws.ffdc.annotation.FFDCIgnore;\n+import com.ibm.ws.microprofile.config.interfaces.ConversionException;\n+\n+public class MethodFunction<X> implements Function<String, X> {\n+    private final Method method;\n+\n+    protected MethodFunction(Method method) {\n+        this.method = method;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public X apply(String value) {\n+        X converted = null;\n+        if (value != null) { //if the value is null then we always return null\n+            try {\n+                converted = (X) method.invoke(null, value);\n+            } catch (InvocationTargetException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof IllegalArgumentException) {\n+                    throw (IllegalArgumentException) cause;\n+                } else {\n+                    throw new ConversionException(cause);\n+                }\n+            } catch (IllegalAccessException e) {\n+                throw new ConversionException(e);\n+            }\n+        }\n+        return converted;\n+    }", "originalCommit": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0NDAyNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535444027", "bodyText": "We should probably ignore InvocationTargetException but still FFDC for IllegalAccessException", "author": "tevans78", "createdAt": "2020-12-03T17:38:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNzg5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MzY5MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r536093690", "bodyText": "done", "author": "tevans78", "createdAt": "2020-12-04T13:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyNzg5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/MethodFunction.java b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/MethodFunction.java\nindex 49fc5c22ca..8ec8df5fb4 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/MethodFunction.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.2/src/com/ibm/ws/microprofile/config12/converters/MethodFunction.java\n\n@@ -29,6 +29,7 @@ public class MethodFunction<X> implements Function<String, X> {\n     /** {@inheritDoc} */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n+    @FFDCIgnore(InvocationTargetException.class)\n     public X apply(String value) {\n         X converted = null;\n         if (value != null) { //if the value is null then we always return null\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTQ5NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535429495", "bodyText": "Don't much like these nested ifs either.", "author": "Azquelt", "createdAt": "2020-12-03T17:18:06Z", "path": "dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java", "diffHunk": "@@ -43,138 +42,60 @@\n      * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n      * </ul>\n      *\n-     *\n      * @param converterType The class to convert using\n      */\n-    public Config13ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n-\n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.ctor = getConstructor(converterType);\n-                if (this.ctor == null) {\n-                    this.parseMethod = getParse(converterType);\n+    @Override\n+    @Trivial\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = null;\n+\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n+            if (implicitFunction == null) {\n+                implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+                if (implicitFunction == null) {\n+                    implicitFunction = MethodFunction.getParseFunction(converterType);\n+                    if (implicitFunction == null) {\n+                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+                    } else {\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                            Tr.debug(tc, Tr.formatMessage(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\"));\n+                        }\n+                    }", "originalCommit": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MzU1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r536093551", "bodyText": "done", "author": "tevans78", "createdAt": "2020-12-04T13:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQyOTQ5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\nindex fbb32e6d44..10fe53b183 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\n\n@@ -50,40 +51,40 @@ public class Config13ImplicitConverter extends ImplicitConverter {\n         Function<String, X> implicitFunction = null;\n \n         implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n+        }\n+\n         if (implicitFunction == null) {\n             implicitFunction = MethodFunction.getValueOfFunction(converterType);\n-            if (implicitFunction == null) {\n-                implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n-                if (implicitFunction == null) {\n-                    implicitFunction = MethodFunction.getParseFunction(converterType);\n-                    if (implicitFunction == null) {\n-                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n-                    } else {\n-                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                            Tr.debug(tc, Tr.formatMessage(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\"));\n-                        }\n-                    }\n-                } else {\n-                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n-                    }\n-                }\n-            } else {\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n-                }\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n+            }\n+        }\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n             }\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n+        }\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getParseFunction(converterType);\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n             }\n         }\n+        if (implicitFunction == null) {\n+            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+        }\n \n         return implicitFunction;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n+    @FFDCIgnore(ConversionException.class)\n     public Object convert(String value) {\n         try {\n             return super.convert(value);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMDUwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535430508", "bodyText": "Should this method have @FFDCIgnore? At the moment we would get an FFDC from the MethodFunction and then another one here. We shouldn't need both, right?", "author": "Azquelt", "createdAt": "2020-12-03T17:19:37Z", "path": "dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java", "diffHunk": "@@ -43,138 +42,60 @@\n      * <li>the target type {@code T} has a {@code public static T parse(CharSequence)} method</li>\n      * </ul>\n      *\n-     *\n      * @param converterType The class to convert using\n      */\n-    public Config13ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n-\n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.ctor = getConstructor(converterType);\n-                if (this.ctor == null) {\n-                    this.parseMethod = getParse(converterType);\n+    @Override\n+    @Trivial\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = null;\n+\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n+            if (implicitFunction == null) {\n+                implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+                if (implicitFunction == null) {\n+                    implicitFunction = MethodFunction.getParseFunction(converterType);\n+                    if (implicitFunction == null) {\n+                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+                    } else {\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                            Tr.debug(tc, Tr.formatMessage(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\"));\n+                        }\n+                    }\n+                } else {\n+                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n+                    }\n+                }\n+            } else {\n+                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n                 }\n             }\n-        }\n-\n-        if (this.ofMethod == null && this.valueOfMethod == null && this.ctor == null && this.parseMethod == null) {\n-            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n         } else {\n             if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                if (this.ofMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ofMethod);\n-                } else if (this.valueOfMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.valueOfMethod);\n-                } else if (this.ctor != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.ctor);\n-                } else if (this.parseMethod != null) {\n-                    Tr.debug(tc, \"Automatic converter for {0} using {1}\", converterType, this.parseMethod);\n-                }\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n             }\n         }\n-    }\n \n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static <M> Constructor<M> getConstructor(Class<M> reflectionClass) {\n-        Constructor<M> ctor = null;\n-        try {\n-            ctor = reflectionClass.getConstructor(String.class);\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-        return ctor;\n-    }\n-\n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"of\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-\n-        return method;\n-    }\n-\n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getValueOfMethod(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"valueOf\", String.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-\n-        return method;\n-    }\n-\n-    @FFDCIgnore(NoSuchMethodException.class)\n-    @Trivial\n-    private static Method getParse(Class<?> reflectionClass) {\n-        Method method = null;\n-        try {\n-            method = reflectionClass.getMethod(\"parse\", CharSequence.class);\n-            if ((method.getModifiers() & Modifier.STATIC) == 0) {\n-                method = null;\n-            } else if (!reflectionClass.equals(method.getReturnType())) {\n-                method = null;\n-            }\n-        } catch (NoSuchMethodException e) {\n-            //No FFDC\n-        }\n-        return method;\n+        return implicitFunction;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public Object convert(String value) {\n-        Object converted = null;\n-        if (value != null) { //if the value is null then we always return null\n-            try {\n-\n-                if (this.ofMethod != null) {\n-                    converted = this.ofMethod.invoke(null, value);\n-                } else if (this.valueOfMethod != null) {\n-                    converted = this.valueOfMethod.invoke(null, value);\n-                } else if (this.ctor != null) {\n-                    converted = this.ctor.newInstance(value);\n-                } else if (this.parseMethod != null) {\n-                    converted = this.parseMethod.invoke(null, value);\n-                }\n-            } catch (InvocationTargetException e) {\n-                Throwable cause = e.getCause();\n-                if (cause instanceof IllegalArgumentException) {\n-                    throw (IllegalArgumentException) cause;\n-                } else {\n-                    throw new IllegalArgumentException(cause);\n-                }\n-            } catch (IllegalAccessException | InstantiationException e) {\n-                throw new IllegalArgumentException(e);\n+        try {\n+            return super.convert(value);\n+        } catch (ConversionException e) { //The Config 1.3 spec clarified that the convert method should throw IllegalArgumentException\n+                                          //if the value cannot be converted to the specified type\n+            Throwable cause = e.getCause();\n+            if (cause instanceof IllegalArgumentException) {\n+                throw (IllegalArgumentException) cause;\n+            } else {\n+                throw new IllegalArgumentException(cause);\n             }\n         }", "originalCommit": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ0NTgwNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535445805", "bodyText": "Should probably ignore this one ... FFDCs should occur at the point of first failure; this is just re-wrapping the exception, it doesn't add anything to FFDC here.", "author": "tevans78", "createdAt": "2020-12-03T17:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMDUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MzQ3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r536093470", "bodyText": "done", "author": "tevans78", "createdAt": "2020-12-04T13:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMDUwOA=="}], "type": "inlineReview", "revised_code": {"commit": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\nindex fbb32e6d44..10fe53b183 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.3/src/com/ibm/ws/microprofile/config13/converters/Config13ImplicitConverter.java\n\n@@ -50,40 +51,40 @@ public class Config13ImplicitConverter extends ImplicitConverter {\n         Function<String, X> implicitFunction = null;\n \n         implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n+        }\n+\n         if (implicitFunction == null) {\n             implicitFunction = MethodFunction.getValueOfFunction(converterType);\n-            if (implicitFunction == null) {\n-                implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n-                if (implicitFunction == null) {\n-                    implicitFunction = MethodFunction.getParseFunction(converterType);\n-                    if (implicitFunction == null) {\n-                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n-                    } else {\n-                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                            Tr.debug(tc, Tr.formatMessage(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\"));\n-                        }\n-                    }\n-                } else {\n-                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n-                    }\n-                }\n-            } else {\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n-                }\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n+            }\n+        }\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n             }\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n+        }\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getParseFunction(converterType);\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n             }\n         }\n+        if (implicitFunction == null) {\n+            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+        }\n \n         return implicitFunction;\n     }\n \n     /** {@inheritDoc} */\n     @Override\n+    @FFDCIgnore(ConversionException.class)\n     public Object convert(String value) {\n         try {\n             return super.convert(value);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMTk5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r535431996", "bodyText": "More nested ifs", "author": "Azquelt", "createdAt": "2020-12-03T17:21:46Z", "path": "dev/com.ibm.ws.microprofile.config.1.4/src/com/ibm/ws/microprofile/config14/converters/Config14ImplicitConverter.java", "diffHunk": "@@ -46,135 +44,41 @@\n      *\n      * @param converterType The class to convert using\n      */\n-    public Config14ImplicitConverter(Class<?> converterType) {\n-        super(converterType);\n-\n-        this.ofMethod = getOfMethod(converterType);\n-        if (this.ofMethod == null) {\n-            this.valueOfMethod = getValueOfMethod(converterType);\n-            if (this.valueOfMethod == null) {\n-                this.parseMethod = getParse(converterType);\n-                if (this.parseMethod == null) {\n-                    this.ctor = getConstructor(converterType);\n+    @Override\n+    @Trivial\n+    protected <X> Function<String, X> getImplicitFunction(Class<X> converterType) {\n+        Function<String, X> implicitFunction = null;\n+\n+        implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getValueOfFunction(converterType);\n+            if (implicitFunction == null) {\n+                implicitFunction = MethodFunction.getParseFunction(converterType);\n+                if (implicitFunction == null) {\n+                    implicitFunction = ConstructorFunction.getConstructorFunction(converterType);", "originalCommit": "13e4fcf74ef40868c9ec54b38a36c0e7930bdeaf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MzM0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13829#discussion_r536093348", "bodyText": "done", "author": "tevans78", "createdAt": "2020-12-04T13:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQzMTk5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "chunk": "diff --git a/dev/com.ibm.ws.microprofile.config.1.4/src/com/ibm/ws/microprofile/config14/converters/Config14ImplicitConverter.java b/dev/com.ibm.ws.microprofile.config.1.4/src/com/ibm/ws/microprofile/config14/converters/Config14ImplicitConverter.java\nindex bddd6dba14..b801bda3b2 100644\n--- a/dev/com.ibm.ws.microprofile.config.1.4/src/com/ibm/ws/microprofile/config14/converters/Config14ImplicitConverter.java\n+++ b/dev/com.ibm.ws.microprofile.config.1.4/src/com/ibm/ws/microprofile/config14/converters/Config14ImplicitConverter.java\n\n@@ -50,35 +50,35 @@ public class Config14ImplicitConverter extends Config13ImplicitConverter {\n         Function<String, X> implicitFunction = null;\n \n         implicitFunction = MethodFunction.getOfMethod(converterType);\n+        if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n+        }\n+\n         if (implicitFunction == null) {\n             implicitFunction = MethodFunction.getValueOfFunction(converterType);\n-            if (implicitFunction == null) {\n-                implicitFunction = MethodFunction.getParseFunction(converterType);\n-                if (implicitFunction == null) {\n-                    implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n-                    if (implicitFunction == null) {\n-                        throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n-                    } else {\n-                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                            Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n-                        }\n-                    }\n-                } else {\n-                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                        Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n-                    }\n-                }\n-            } else {\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n-                }\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"valueOf\\\"\");\n+            }\n+\n+        }\n+        if (implicitFunction == null) {\n+            implicitFunction = MethodFunction.getParseFunction(converterType);\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"parse\\\"\");\n             }\n-        } else {\n-            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"of\\\"\");\n+        }\n+\n+        if (implicitFunction == null) {\n+            implicitFunction = ConstructorFunction.getConstructorFunction(converterType);\n+            if (implicitFunction != null && TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Automatic converter for \" + converterType + \" using \\\"constructor\\\"\");\n             }\n         }\n \n+        if (implicitFunction == null) {\n+            throw new IllegalArgumentException(Tr.formatMessage(tc, \"implicit.string.constructor.method.not.found.CWMCG0017E\", converterType));\n+        }\n+\n         return implicitFunction;\n     }\n }\n"}}, {"oid": "00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "url": "https://github.com/OpenLiberty/open-liberty/commit/00af5b5a5f4f3fb67a35cab7d1eca5dcc058437e", "message": "Update FFDCIgnore and some debug processing", "committedDate": "2020-12-04T13:15:30Z", "type": "commit"}]}