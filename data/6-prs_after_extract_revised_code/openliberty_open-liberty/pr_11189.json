{"pr_number": 11189, "pr_title": "Add custom access log fields to JSON logs and logstashCollector", "pr_createdAt": "2020-03-04T20:15:26Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/11189", "timeline": [{"oid": "65f3a1753e413c4e3ab7e48fe970343dbc1a8f86", "url": "https://github.com/OpenLiberty/open-liberty/commit/65f3a1753e413c4e3ab7e48fe970343dbc1a8f86", "message": "Clean up and add omit capability", "committedDate": "2020-03-04T20:40:01Z", "type": "forcePushed"}, {"oid": "2126edc08539c179011f0aba1ce326d32ffa01e2", "url": "https://github.com/OpenLiberty/open-liberty/commit/2126edc08539c179011f0aba1ce326d32ffa01e2", "message": "Clean up and add omit capability", "committedDate": "2020-03-04T20:42:27Z", "type": "forcePushed"}, {"oid": "cde81ec8e477afdd090b8b73ea77cb21fbe43572", "url": "https://github.com/OpenLiberty/open-liberty/commit/cde81ec8e477afdd090b8b73ea77cb21fbe43572", "message": "Implement new design and change setting name", "committedDate": "2020-03-10T18:25:22Z", "type": "forcePushed"}, {"oid": "5c504c7a2f024e941d2364bf528d7387715c0885", "url": "https://github.com/OpenLiberty/open-liberty/commit/5c504c7a2f024e941d2364bf528d7387715c0885", "message": "Implement new design and change setting name", "committedDate": "2020-03-10T18:40:09Z", "type": "forcePushed"}, {"oid": "5aaa034c0a981b438ae059d4b759aad89ebde527", "url": "https://github.com/OpenLiberty/open-liberty/commit/5aaa034c0a981b438ae059d4b759aad89ebde527", "message": "Implement new design and change setting name", "committedDate": "2020-03-11T20:41:40Z", "type": "forcePushed"}, {"oid": "e0023e5ef467ba3cb982d26076bd68e6b284fad4", "url": "https://github.com/OpenLiberty/open-liberty/commit/e0023e5ef467ba3cb982d26076bd68e6b284fad4", "message": "Implement new design and change setting name", "committedDate": "2020-03-12T17:36:21Z", "type": "forcePushed"}, {"oid": "de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "url": "https://github.com/OpenLiberty/open-liberty/commit/de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "message": "Add more gets to prevent passing extra params", "committedDate": "2020-03-13T20:57:26Z", "type": "forcePushed"}, {"oid": "fd8ebb593a6acad375d21692f8fc59cb519b720c", "url": "https://github.com/OpenLiberty/open-liberty/commit/fd8ebb593a6acad375d21692f8fc59cb519b720c", "message": "Implement new design and change setting name\n\nAdd more gets to prevent passing extra params", "committedDate": "2020-03-17T17:48:15Z", "type": "forcePushed"}, {"oid": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "url": "https://github.com/OpenLiberty/open-liberty/commit/32c6cffaf51988e90f24a76d864edd4ef0573fc7", "message": "Implement new design and change setting name\n\nAdd more gets to prevent passing extra params", "committedDate": "2020-03-19T14:08:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyNTQ0OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r393225448", "bodyText": "Change to getBytesSent()", "author": "Yushan-Lin", "createdAt": "2020-03-16T18:19:17Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,29 +242,104 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {\n+            return getLongValue(9);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getLongValue(9);\n     }\n \n     public int getResponseCode() {\n-        return getIntValue(10);\n+        try {\n+            return getIntValue(10);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getIntValue(10);\n     }\n \n     public long getElapsedTime() {\n-        return getLongValue(11);\n+        try {\n+            return getLongValue(11);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getLongValue(11);\n     }\n \n     public long getDatetime() {\n-        return getLongValue(12);\n+        try {\n+            return getLongValue(12);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n+        //return getLongValue(12);\n     }\n \n     public String getSequence() {\n         return getStringValue(13);\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n+    // LG-265\n+    public String getRemoteIP() {\n+        return getStringValue(14);\n+    }\n+\n+    public String getBytesReceivedFormatted() {", "originalCommit": "de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd8ebb593a6acad375d21692f8fc59cb519b720c", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 45b2a392d8..3900c25e5b 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -248,7 +341,6 @@ public class AccessLogData extends GenericData {\n             // Do nothing, the field hasn't been set in the logFormat\n         }\n         return -1;\n-        //return getLongValue(9);\n     }\n \n     public int getResponseCode() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyNjMxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r393226319", "bodyText": "change to IBM_BYTESSENT = \"ibm_bytesSent\"\nchange to BYTESSENT = \"bytesSent\"", "author": "Yushan-Lin", "createdAt": "2020-03-16T18:20:52Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java", "diffHunk": "@@ -76,6 +76,25 @@\n     public static final String RESPONSECODE = \"responseCode\";\n     public static final String IBM_ELAPSEDTIME = \"ibm_elapsedTime\";\n     public static final String ELAPSEDTIME = \"elapsedTime\";\n+    // LG-265 new fields\n+    public static final String IBM_REMOTEIP = \"ibm_remoteIP\";\n+    public static final String REMOTEIP = \"remoteIP\";\n+    public static final String IBM_BYTESRECEIVEDFORMATTED = \"ibm_bytesReceivedFormatted\";\n+    public static final String BYTESRECEIVEDFORMATTED = \"bytesReceivedFormatted\";", "originalCommit": "de149c80f0ed15162bf4a7a17e18faf5d4b7abe6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "fd8ebb593a6acad375d21692f8fc59cb519b720c", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java\nindex 1202bac039..58775cfeaf 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java\n\n@@ -79,8 +79,8 @@ public class LogFieldConstants {\n     // LG-265 new fields\n     public static final String IBM_REMOTEIP = \"ibm_remoteIP\";\n     public static final String REMOTEIP = \"remoteIP\";\n-    public static final String IBM_BYTESRECEIVEDFORMATTED = \"ibm_bytesReceivedFormatted\";\n-    public static final String BYTESRECEIVEDFORMATTED = \"bytesReceivedFormatted\";\n+    public static final String IBM_BYTESSENT = \"ibm_bytesSent\";\n+    public static final String BYTESSENT = \"bytesSent\";\n     public static final String IBM_COOKIE = \"ibm_cookie\";\n     public static final String COOKIE = \"cookie\";\n     public static final String IBM_REQUESTELAPSEDTIME = \"ibm_requestElapsedTime\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE5NjE5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395196191", "bodyText": "should have a null check if formatSpecifiers != null", "author": "Yushan-Lin", "createdAt": "2020-03-19T17:25:11Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -221,42 +228,185 @@ private static String jsonifyAccess(String wlpUserDir,\n         AccessLogData accessLogData = (AccessLogData) event;\n \n         StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n+        List<String> formatSpecifiers;\n+\n+        if (AccessLogData.isCustomAccessLogToJSONEnabledCollector.equals(\"logFormat\")) {\n+            formatSpecifiers = accessLogData.getFormatSpecifierList();\n+            for (String s : formatSpecifiers) {", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "43ca8f890ee538a9c8644cc70e3b072a5ecb0b07", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\nindex 00107b602e..c73c128402 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n\n@@ -228,146 +227,133 @@ public class CollectorJsonUtils {\n         AccessLogData accessLogData = (AccessLogData) event;\n \n         StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n-        List<String> formatSpecifiers;\n+        boolean[] formatSpecifiers = accessLogData.getFormatSpecifierList();\n \n         if (AccessLogData.isCustomAccessLogToJSONEnabledCollector.equals(\"logFormat\")) {\n-            formatSpecifiers = accessLogData.getFormatSpecifierList();\n-            for (String s : formatSpecifiers) {\n-                switch (s) {\n-                    case \"%U\":\n-                        if (accessLogData.getUriPath() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false);\n-                    case \"%m\":\n-                        // %m\n-                        if (accessLogData.getRequestMethod() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false);\n-                        // %q\n-                    case \"%q\":\n-                        if (accessLogData.getQueryString() != null) {\n-                            String jsonQueryString = accessLogData.getQueryString();\n-                            if (jsonQueryString != null) {\n-                                try {\n-                                    jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-                                } catch (UnsupportedEncodingException e) {\n-                                    // ignore, use the original value;\n-                                }\n-\n-                            }\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getQueryStringKey(), jsonQueryString, false, true, false, false, false);\n-                        }\n-                    case \"%A\":\n-                        // %A\n-                        if (accessLogData.getRequestHost() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHostKey(), accessLogData.getRequestHost(), false, true, false, false, false);\n-                    case \"%p\":\n-                        // %p\n-                        if (accessLogData.getRequestPort() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestPortKey(), accessLogData.getRequestPort(), false, true, false, false, false);\n-                    case \"%h\":\n-                        // %h\n-                        if (accessLogData.getRemoteHost() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteHostKey(), accessLogData.getRemoteHost(), false, true, false, false, false);\n-                    case \"%H\":\n-                        // %H\n-                        if (accessLogData.getRequestProtocol() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestProtocolKey(), accessLogData.getRequestProtocol(), false, true, false, false, false);\n-                    case \"%B\":\n-                        // %B\n-                        if (accessLogData.getBytesReceived() > -1)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getBytesReceivedKey(), Long.toString(accessLogData.getBytesReceived()), false, true, false, false,\n-                                                           true);\n-                    case \"%s\":\n-                        // %s\n-                        if (accessLogData.getResponseCode() > -1)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getResponseCodeKey(), Integer.toString(accessLogData.getResponseCode()), false, true, false, false,\n-                                                           true);\n-                    case \"%{R}W\":\n-                        // %{R}W\n-                        if (accessLogData.getElapsedTime() > -1)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getElapsedTimeKey(), Long.toString(accessLogData.getElapsedTime()), false, true, false, false, true);\n-                    case \"%a\":\n-                        // %a\n-                        if (accessLogData.getRemoteIP() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteIPKey(), accessLogData.getRemoteIP(), false, true, false,\n-                                                           !(sb.length() > 1), false);\n-                    case \"%b\":\n-                        // %b\n-                        if (accessLogData.getBytesSent() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getBytesSentKey(), accessLogData.getBytesSent(),\n-                                                           false, true, false, !(sb.length() > 1), false);\n-                    case \"%C\":\n-                        // %C\n-                        ArrayList<KeyValuePair> cookies = null;\n-                        KeyValuePairList kvplCookies = accessLogData.getCookies();\n-                        if (kvplCookies != null) {\n-                            cookies = kvplCookies.getList();\n-                            for (KeyValuePair k : cookies) {\n-                                CollectorJsonHelpers.addToJSON(sb, accessLogData.getCookieKey(k), k.getStringValue(),\n-                                                               true, true, false, !(sb.length() > 1), false);\n-                            }\n-                        }\n-                    case \"%D\":\n-                        // %D\n-                        if (accessLogData.getRequestElapsedTime() > 0)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestElapsedTimeKey(), Long.toString(accessLogData.getRequestElapsedTime()),\n-                                                           false, true, false, !(sb.length() > 1), true);\n-                    case \"%i\":\n-                        // %i\n-                        ArrayList<KeyValuePair> requestHeaders = null;\n-                        KeyValuePairList kvplRequestHeaders = accessLogData.getRequestHeaders();\n-                        if (kvplRequestHeaders != null) {\n-                            requestHeaders = kvplRequestHeaders.getList();\n-                            for (KeyValuePair k : requestHeaders) {\n-                                CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHeaderKey(k), k.getStringValue(),\n-                                                               true, true, false, !(sb.length() > 1), false);\n-                            }\n-                        }\n-                    case \"%o\":\n-                        // %o\n-                        ArrayList<KeyValuePair> responseHeaders = null;\n-                        KeyValuePairList kvplResponseHeaders = accessLogData.getResponseHeaders();\n-                        if (kvplResponseHeaders != null) {\n-                            responseHeaders = kvplResponseHeaders.getList();\n-                            for (KeyValuePair k : responseHeaders) {\n-                                CollectorJsonHelpers.addToJSON(sb, accessLogData.getResponseHeaderKey(k), k.getStringValue(),\n-                                                               true, true, false, !(sb.length() > 1), false);\n-                            }\n-                        }\n-                    case \"%r\":\n-                        // %r\n-                        if (accessLogData.getRequestFirstLine() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestFirstLineKey(), accessLogData.getRequestFirstLine(),\n-                                                           false, true, false, !(sb.length() > 1), false);\n-                    case \"%t\":\n-                        // %t\n-                        if (accessLogData.getRequestStartTime() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestStartTimeKey(), accessLogData.getRequestStartTime(),\n-                                                           false, true, false, !(sb.length() > 1), false);\n-                    case \"%{t}W\":\n-                        // %{t}W\n-                        if (accessLogData.getAccessLogDatetime() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getAccessLogDatetimeKey(), accessLogData.getAccessLogDatetime(),\n-                                                           false, true, false, !(sb.length() > 1), false);\n-                    case \"%u\":\n-                        // %u\n-                        if (accessLogData.getRemoteUser() != null && !accessLogData.getRemoteUser().equals(\"\"))\n-                            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteUserKey(), accessLogData.getRemoteUser(), false, true,\n-                                                           false, !(sb.length() > 1), false);\n+            // %U\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false, formatSpecifiers[1]);\n+\n+            // %m\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false, formatSpecifiers[2]);\n+            // %q\n+\n+            if (accessLogData.getQueryString() != null) {\n+                String jsonQueryString = accessLogData.getQueryString();\n+                if (jsonQueryString != null) {\n+                    try {\n+                        jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n+                    } catch (UnsupportedEncodingException e) {\n+                        // ignore, use the original value;\n+                    }\n+\n+                }\n+                CollectorJsonHelpers.addToJSON(sb, accessLogData.getQueryStringKey(), jsonQueryString, false, true, false, false, false, formatSpecifiers[3]);\n+            }\n+\n+            // %A\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHostKey(), accessLogData.getRequestHost(), false, true, false, false, false, formatSpecifiers[4]);\n+\n+            // %p\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestPortKey(), accessLogData.getRequestPort(), false, true, false, false, false, formatSpecifiers[5]);\n+\n+            // %h\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteHostKey(), accessLogData.getRemoteHost(), false, true, false, false, false, formatSpecifiers[6]);\n+\n+            // %H\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestProtocolKey(), accessLogData.getRequestProtocol(), false, true, false, false, false,\n+                                           formatSpecifiers[8]);\n+\n+            // %B\n+            if (accessLogData.getBytesReceived() > -1)\n+                CollectorJsonHelpers.addToJSON(sb, accessLogData.getBytesReceivedKey(), Long.toString(accessLogData.getBytesReceived()), false, true, false, false,\n+                                               true, formatSpecifiers[9]);\n+\n+            // %s\n+            if (accessLogData.getResponseCode() > -1)\n+                CollectorJsonHelpers.addToJSON(sb, accessLogData.getResponseCodeKey(), Integer.toString(accessLogData.getResponseCode()), false, true, false, false,\n+                                               true, formatSpecifiers[10]);\n+\n+            // %{R}W\n+            if (accessLogData.getElapsedTime() > -1)\n+                CollectorJsonHelpers.addToJSON(sb, accessLogData.getElapsedTimeKey(), Long.toString(accessLogData.getElapsedTime()), false, true, false, false, true,\n+                                               formatSpecifiers[11]);\n+\n+            // %a\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteIPKey(), accessLogData.getRemoteIP(), false, true, false,\n+                                           !(sb.length() > 1), false, formatSpecifiers[14]);\n+\n+            // %b\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getBytesSentKey(), accessLogData.getBytesSent(),\n+                                           false, true, false, !(sb.length() > 1), false, formatSpecifiers[15]);\n+\n+            // %C\n+            ArrayList<KeyValuePair> cookies = null;\n+            KeyValuePairList kvplCookies = accessLogData.getCookies();\n+            if (kvplCookies != null) {\n+                cookies = kvplCookies.getList();\n+                for (KeyValuePair k : cookies) {\n+                    CollectorJsonHelpers.addToJSON(sb, accessLogData.getCookieKey(k), k.getStringValue(),\n+                                                   true, true, false, !(sb.length() > 1), false, formatSpecifiers[16]);\n                 }\n-                // not part of logformat\n-                String userAgent = accessLogData.getUserAgent();\n+            }\n \n-                if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n-                    userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+            // %D\n+            if (accessLogData.getRequestElapsedTime() > 0)\n+                CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestElapsedTimeKey(), Long.toString(accessLogData.getRequestElapsedTime()),\n+                                               false, true, false, !(sb.length() > 1), true, formatSpecifiers[17]);\n+\n+            // %i\n+            ArrayList<KeyValuePair> requestHeaders = null;\n+            KeyValuePairList kvplRequestHeaders = accessLogData.getRequestHeaders();\n+            if (kvplRequestHeaders != null) {\n+                requestHeaders = kvplRequestHeaders.getList();\n+                for (KeyValuePair k : requestHeaders) {\n+                    CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHeaderKey(k), k.getStringValue(),\n+                                                   true, true, false, !(sb.length() > 1), false, formatSpecifiers[18]);\n                 }\n-                CollectorJsonHelpers.addToJSON(sb, accessLogData.getUserAgentKey(), userAgent, false, false, false, false, false);\n-                // not part of logformat\n-                String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-                CollectorJsonHelpers.addToJSON(sb, accessLogData.getDatetimeKey(), datetime, false, true, false, false, false);\n+            }\n \n-                // not part of logformat\n-                CollectorJsonHelpers.addToJSON(sb, accessLogData.getSequenceKey(), accessLogData.getSequence(), false, true, false, false, false);\n+            // %o\n+            ArrayList<KeyValuePair> responseHeaders = null;\n+            KeyValuePairList kvplResponseHeaders = accessLogData.getResponseHeaders();\n+            if (kvplResponseHeaders != null) {\n+                responseHeaders = kvplResponseHeaders.getList();\n+                for (KeyValuePair k : responseHeaders) {\n+                    CollectorJsonHelpers.addToJSON(sb, accessLogData.getResponseHeaderKey(k), k.getStringValue(),\n+                                                   true, true, false, !(sb.length() > 1), false, formatSpecifiers[19]);\n+                }\n             }\n+\n+            // %r\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestFirstLineKey(), accessLogData.getRequestFirstLine(),\n+                                           false, true, false, !(sb.length() > 1), false, formatSpecifiers[20]);\n+\n+            // %t\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestStartTimeKey(), accessLogData.getRequestStartTime(),\n+                                           false, true, false, !(sb.length() > 1), false, formatSpecifiers[21]);\n+\n+            // %{t}W\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getAccessLogDatetimeKey(), accessLogData.getAccessLogDatetime(),\n+                                           false, true, false, !(sb.length() > 1), false, formatSpecifiers[22]);\n+\n+            // %u\n+            if (accessLogData.getRemoteUser() != null && !accessLogData.getRemoteUser().equals(\"\"))\n+                CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteUserKey(), accessLogData.getRemoteUser(), false, true,\n+                                               false, !(sb.length() > 1), false, formatSpecifiers[23]);\n+\n+            // not part of logformat\n+            String userAgent = accessLogData.getUserAgent();\n+\n+            if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n+                userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+            }\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getUserAgentKey(), userAgent, false, false, false, false, false);\n+            // not part of logformat\n+            String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getDatetimeKey(), datetime, false, true, false, false, false);\n+\n+            // not part of logformat\n+            CollectorJsonHelpers.addToJSON(sb, accessLogData.getSequenceKey(), accessLogData.getSequence(), false, true, false, false, false);\n         } else {\n             CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false);\n             CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIwMTY5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395201698", "bodyText": "check formatSpecifiers != null", "author": "Yushan-Lin", "createdAt": "2020-03-19T17:33:19Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java", "diffHunk": "@@ -210,56 +211,219 @@ public static String jsonifyAccess(String wlpUserDir, String serverName, String\n         Boolean isFirstField = true;\n         StringBuilder sb = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n \n+        List<String> formatSpecifiers;\n+\n         if (sb.length() > 1)\n             isFirstField = false;\n+        // LG-265\n+        if (AccessLogData.isCustomAccessLogToJSONEnabled.equals(\"logFormat\")) {\n+            formatSpecifiers = accessLogData.getFormatSpecifierList();\n+            for (String s : formatSpecifiers) {", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "43ca8f890ee538a9c8644cc70e3b072a5ecb0b07", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\nindex b6e6ddef11..229bcce4b7 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\n\n@@ -211,170 +210,157 @@ public class CollectorJsonUtils_JSON {\n         Boolean isFirstField = true;\n         StringBuilder sb = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n \n-        List<String> formatSpecifiers;\n+        boolean[] formatSpecifiers = accessLogData.getFormatSpecifierList();\n \n         if (sb.length() > 1)\n             isFirstField = false;\n         // LG-265\n+        // This will be changed later with PR#11220\n         if (AccessLogData.isCustomAccessLogToJSONEnabled.equals(\"logFormat\")) {\n-            formatSpecifiers = accessLogData.getFormatSpecifierList();\n-            for (String s : formatSpecifiers) {\n-                switch (s) {\n-                    case \"%U\":\n-                        if (accessLogData.getUriPath() != null)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getUriPathKeyJSON(), accessLogData.getUriPath(), false, true, false,\n-                                                                            isFirstField, false);\n-                    case \"%m\":\n-                        if (accessLogData.getRequestMethod() != null)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestMethodKeyJSON(), accessLogData.getRequestMethod(), false, true,\n-                                                                            false, isFirstField, false);\n-\n-                    case \"%A\":\n-                        // %A\n-                        if (accessLogData.getRequestHost() != null)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestHostKeyJSON(), accessLogData.getRequestHost(), false, true, false,\n-                                                                            isFirstField, false);\n-                    case \"%p\":\n-                        // %p\n-                        if (accessLogData.getRequestPort() != null)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestPortKeyJSON(), accessLogData.getRequestPort(), false, true, false,\n-                                                                            isFirstField, false);\n-                    case \"%h\":\n-                        // %h\n-                        if (accessLogData.getRemoteHost() != null)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRemoteHostKeyJSON(), accessLogData.getRemoteHost(), false, true, false,\n-                                                                            isFirstField, false);\n-                    case \"%H\":\n-                        // %H\n-                        if (accessLogData.getRequestProtocol() != null)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestProtocolKeyJSON(), accessLogData.getRequestProtocol(), false,\n-                                                                            true, false, isFirstField, false);\n-                    case \"%B\":\n-                        // %B\n-                        if (accessLogData.getBytesReceived() > -1)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getBytesReceivedKeyJSON(), Long.toString(accessLogData.getBytesReceived()),\n-                                                                            false, true, false, isFirstField, true);\n-                    case \"%s\":\n-                        // %s\n-                        if (accessLogData.getResponseCode() > -1)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getResponseCodeKeyJSON(), Integer.toString(accessLogData.getResponseCode()),\n-                                                                            false, true, false, isFirstField, true);\n-                    case \"%{R}W\":\n-                        // %{R}W\n-                        if (accessLogData.getElapsedTime() > -1)\n-                            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getElapsedTimeKeyJSON(), Long.toString(accessLogData.getElapsedTime()), false,\n-                                                                            true, false, isFirstField, true);\n-                    case \"%a\":\n-                        // %a\n-                        if (accessLogData.getRemoteIP() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRemoteIPKeyJSON(), accessLogData.getRemoteIP(), false, true, false,\n-                                                           !(sb.length() > 1),\n-                                                           false);\n-                    case \"%b\":\n-                        // %b\n-                        if (accessLogData.getBytesSent() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getBytesSentKeyJSON(), accessLogData.getBytesSent(),\n-                                                           false, true, false,\n-                                                           !(sb.length() > 1),\n-                                                           false);\n-                    case \"%C\":\n-                        // %C\n-                        ArrayList<KeyValuePair> cookies = null;\n-                        KeyValuePairList kvplCookies = accessLogData.getCookies();\n-                        if (kvplCookies != null) {\n-                            cookies = kvplCookies.getList();\n-                            for (KeyValuePair k : cookies) {\n-                                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getCookieKeyJSON(k), k.getStringValue(), true, true, false, !(sb.length() > 1),\n-                                                               false);\n-                            }\n-                        }\n-                    case \"%D\":\n-                        // %D\n-                        if (accessLogData.getRequestElapsedTime() > 0)\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestElapsedTimeKeyJSON(), Long.toString(accessLogData.getRequestElapsedTime()), false,\n-                                                           true, false,\n-                                                           !(sb.length() > 1),\n-                                                           true);\n-                    case \"%i\":\n-                        // %i\n-                        ArrayList<KeyValuePair> requestHeaders = null;\n-                        KeyValuePairList kvplRequestHeaders = accessLogData.getRequestHeaders();\n-                        if (kvplRequestHeaders != null) {\n-                            requestHeaders = kvplRequestHeaders.getList();\n-                            for (KeyValuePair k : requestHeaders) {\n-                                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestHeaderKeyJSON(k), k.getStringValue(), true, true, false, !(sb.length() > 1),\n-                                                               false);\n-                            }\n-                        }\n-                    case \"%o\":\n-                        // %o\n-                        ArrayList<KeyValuePair> responseHeaders = null;\n-                        KeyValuePairList kvplResponseHeaders = accessLogData.getResponseHeaders();\n-                        if (kvplResponseHeaders != null) {\n-                            responseHeaders = kvplResponseHeaders.getList();\n-                            for (KeyValuePair k : responseHeaders) {\n-                                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getResponseHeaderKeyJSON(k), k.getStringValue(), true, true, false, !(sb.length() > 1), false);\n-                            }\n-                        }\n-                    case \"%r\":\n-                        // %r\n-                        if (accessLogData.getRequestFirstLine() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestFirstLineKeyJSON(), accessLogData.getRequestFirstLine(), false,\n-                                                           true, false,\n-                                                           !(sb.length() > 1),\n-                                                           false);\n-                    case \"%t\":\n-                        // %t\n-                        if (accessLogData.getRequestStartTime() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestStartTimeKeyJSON(), accessLogData.getRequestStartTime(), false,\n-                                                           true, false,\n-                                                           !(sb.length() > 1),\n-                                                           false);\n-                    case \"%{t}W\":\n-                        // %{t}W\n-                        if (accessLogData.getAccessLogDatetime() != null)\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getAccessLogDatetimeKeyJSON(), accessLogData.getAccessLogDatetime(),\n-                                                           false,\n-                                                           true,\n-                                                           false,\n-                                                           !(sb.length() > 1),\n-                                                           false);\n-                    case \"%u\":\n-                        // %u\n-                        if (accessLogData.getRemoteUser() != null && !accessLogData.getRemoteUser().equals(\"\"))\n-                            CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRemoteUserKeyJSON(), accessLogData.getRemoteUser(), false, true, false,\n-                                                           !(sb.length() > 1),\n-                                                           false);\n+            if (accessLogData.getUriPath() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getUriPathKeyJSON(), accessLogData.getUriPath(), false, true, false, isFirstField, false,\n+                                                                formatSpecifiers[1]);\n+\n+            if (accessLogData.getRequestMethod() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestMethodKeyJSON(), accessLogData.getRequestMethod(), false, true,\n+                                                                false, isFirstField, false, formatSpecifiers[2]);\n+\n+            if (accessLogData.getUriPath() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getUriPathKeyJSON(), accessLogData.getUriPath(), false, true, false,\n+                                                                isFirstField, false, formatSpecifiers[3]);\n+            if (accessLogData.getRequestMethod() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestMethodKeyJSON(), accessLogData.getRequestMethod(), false, true,\n+                                                                false, isFirstField, false, formatSpecifiers[4]);\n+\n+            // %A\n+            if (accessLogData.getRequestHost() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestHostKeyJSON(), accessLogData.getRequestHost(), false, true, false,\n+                                                                isFirstField, false, formatSpecifiers[5]);\n+            // %p\n+            if (accessLogData.getRequestPort() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestPortKeyJSON(), accessLogData.getRequestPort(), false, true, false,\n+                                                                isFirstField, false, formatSpecifiers[6]);\n+            // %h\n+            if (accessLogData.getRemoteHost() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRemoteHostKeyJSON(), accessLogData.getRemoteHost(), false, true, false,\n+                                                                isFirstField, false, formatSpecifiers[8]);\n+            // %H\n+            if (accessLogData.getRequestProtocol() != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestProtocolKeyJSON(), accessLogData.getRequestProtocol(), false,\n+                                                                true, false, isFirstField, false, formatSpecifiers[9]);\n+            // %B\n+            if (accessLogData.getBytesReceived() > -1)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getBytesReceivedKeyJSON(), Long.toString(accessLogData.getBytesReceived()),\n+                                                                false, true, false, isFirstField, true, formatSpecifiers[10]);\n+            // %s\n+            if (accessLogData.getResponseCode() > -1)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getResponseCodeKeyJSON(), Integer.toString(accessLogData.getResponseCode()),\n+                                                                false, true, false, isFirstField, true, formatSpecifiers[11]);\n+            // %{R}W\n+            if (accessLogData.getElapsedTime() > -1)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getElapsedTimeKeyJSON(), Long.toString(accessLogData.getElapsedTime()), false,\n+                                                                true, false, isFirstField, true, formatSpecifiers[12]);\n+            // %a\n+            if (accessLogData.getRemoteIP() != null)\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRemoteIPKeyJSON(), accessLogData.getRemoteIP(), false, true, false,\n+                                               !(sb.length() > 1),\n+                                               false, formatSpecifiers[14]);\n+            // %b\n+            if (accessLogData.getBytesSent() != null)\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getBytesSentKeyJSON(), accessLogData.getBytesSent(),\n+                                               false, true, false,\n+                                               !(sb.length() > 1),\n+                                               false, formatSpecifiers[15]);\n+            // %C\n+            ArrayList<KeyValuePair> cookies = null;\n+            KeyValuePairList kvplCookies = accessLogData.getCookies();\n+            if (kvplCookies != null) {\n+                cookies = kvplCookies.getList();\n+                for (KeyValuePair k : cookies) {\n+                    CollectorJsonHelpers.addToJSON(sb, AccessLogData.getCookieKeyJSON(k), k.getStringValue(), true, true, false, !(sb.length() > 1),\n+                                                   false, formatSpecifiers[16]);\n                 }\n-                // not logformat\n-                String userAgent = accessLogData.getUserAgent();\n-\n-                if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n-                    userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+            }\n+            // %D\n+            if (accessLogData.getRequestElapsedTime() > 0)\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestElapsedTimeKeyJSON(), Long.toString(accessLogData.getRequestElapsedTime()), false,\n+                                               true, false,\n+                                               !(sb.length() > 1),\n+                                               true, formatSpecifiers[17]);\n+            // %i\n+            ArrayList<KeyValuePair> requestHeaders = null;\n+            KeyValuePairList kvplRequestHeaders = accessLogData.getRequestHeaders();\n+            if (kvplRequestHeaders != null) {\n+                requestHeaders = kvplRequestHeaders.getList();\n+                for (KeyValuePair k : requestHeaders) {\n+                    CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestHeaderKeyJSON(k), k.getStringValue(), true, true, false, !(sb.length() > 1),\n+                                                   false, formatSpecifiers[18]);\n                 }\n-                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getUserAgentKeyJSON(), userAgent, false, false, false, isFirstField,\n-                                                                false);\n-                // not logformat\n-                String jsonQueryString = accessLogData.getQueryString();\n-                if (jsonQueryString != null) {\n-                    try {\n-                        jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-                        isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getQueryStringKeyJSON(), jsonQueryString, false, true, false,\n-                                                                        isFirstField, false);\n-                    } catch (UnsupportedEncodingException e) {\n-                        // ignore, use the original value;\n-                    }\n+            }\n+            // %o\n+            ArrayList<KeyValuePair> responseHeaders = null;\n+            KeyValuePairList kvplResponseHeaders = accessLogData.getResponseHeaders();\n+            if (kvplResponseHeaders != null) {\n+                responseHeaders = kvplResponseHeaders.getList();\n+                for (KeyValuePair k : responseHeaders) {\n+                    CollectorJsonHelpers.addToJSON(sb, AccessLogData.getResponseHeaderKeyJSON(k), k.getStringValue(), true, true, false, !(sb.length() > 1), false,\n+                                                   formatSpecifiers[19]);\n+                }\n+            }\n+            // %r\n+            if (accessLogData.getRequestFirstLine() != null)\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestFirstLineKeyJSON(), accessLogData.getRequestFirstLine(), false,\n+                                               true, false,\n+                                               !(sb.length() > 1),\n+                                               false, formatSpecifiers[20]);\n+            // %t\n+            if (accessLogData.getRequestStartTime() != null)\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRequestStartTimeKeyJSON(), accessLogData.getRequestStartTime(), false,\n+                                               true, false,\n+                                               !(sb.length() > 1),\n+                                               false, formatSpecifiers[21]);\n+            // %{t}W\n+            if (accessLogData.getAccessLogDatetime() != null)\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getAccessLogDatetimeKeyJSON(), accessLogData.getAccessLogDatetime(),\n+                                               false,\n+                                               true,\n+                                               false,\n+                                               !(sb.length() > 1),\n+                                               false, formatSpecifiers[22]);\n+            // %u\n+            if (accessLogData.getRemoteUser() != null && !accessLogData.getRemoteUser().equals(\"\"))\n+                CollectorJsonHelpers.addToJSON(sb, AccessLogData.getRemoteUserKeyJSON(), accessLogData.getRemoteUser(), false, true, false,\n+                                               !(sb.length() > 1),\n+                                               false, formatSpecifiers[23]);\n+            // not logformat\n+            String userAgent = accessLogData.getUserAgent();\n+\n+            if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n+                userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+            }\n+            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getUserAgentKeyJSON(), userAgent, false, false, false, isFirstField,\n+                                                            false);\n+            // not logformat\n+            String jsonQueryString = accessLogData.getQueryString();\n+            if (jsonQueryString != null) {\n+                try {\n+                    jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n+                    isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getQueryStringKeyJSON(), jsonQueryString, false, true, false,\n+                                                                    isFirstField, false);\n+                } catch (UnsupportedEncodingException e) {\n+                    // ignore, use the original value;\n                 }\n-                // not logformat\n-                String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-                if (datetime != null)\n-                    isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getDatetimeKeyJSON(), datetime, false, true, false, isFirstField, false);\n-\n-                // not logformat\n-                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getSequenceKeyJSON(), accessLogData.getSequence(), false, true, false,\n-                                                                isFirstField,\n-                                                                false);\n             }\n+            // not logformat\n+            String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n+            if (datetime != null)\n+                isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getDatetimeKeyJSON(), datetime, false, true, false, isFirstField, false);\n+\n+            // not logformat\n+            isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getSequenceKeyJSON(), accessLogData.getSequence(), false, true, false,\n+                                                            isFirstField,\n+                                                            false);\n+\n         } else {\n             isFirstField &= !CollectorJsonHelpers.addToJSON(sb, AccessLogData.getUriPathKeyJSON(), accessLogData.getUriPath(), false, true, false,\n                                                             isFirstField, false);\n"}}, {"oid": "43ca8f890ee538a9c8644cc70e3b072a5ecb0b07", "url": "https://github.com/OpenLiberty/open-liberty/commit/43ca8f890ee538a9c8644cc70e3b072a5ecb0b07", "message": "Fix bugs + clean up", "committedDate": "2020-03-19T21:24:01Z", "type": "forcePushed"}, {"oid": "ac9491be68a294634dcf67bed6af3fadaade6685", "url": "https://github.com/OpenLiberty/open-liberty/commit/ac9491be68a294634dcf67bed6af3fadaade6685", "message": "Fix bugs + clean up", "committedDate": "2020-03-20T16:43:04Z", "type": "forcePushed"}, {"oid": "610abea3c428614f923d79a4e25dad4c9fbe2439", "url": "https://github.com/OpenLiberty/open-liberty/commit/610abea3c428614f923d79a4e25dad4c9fbe2439", "message": "Fix bugs + clean up", "committedDate": "2020-03-20T21:07:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIyNzUwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395227501", "bodyText": "not sure this is right place to put this.  should be alongside messageFormat / consoleFormat / jsonFieldMappings", "author": "donbourne", "createdAt": "2020-03-19T18:15:27Z", "path": "dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java", "diffHunk": "@@ -63,6 +63,7 @@\n     private static final String TAG_LIST_KEY = \"tag\";\n     private static final String MAX_FIELD_KEY = \"maxFieldLength\";\n     private static final String MAX_EVENTS_KEY = \"maxEvents\";\n+    private static final String ENABLE_CUSTOM_ACCESS_LOG_FIELDS_KEY = \"jsonAccessLogFields\";", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java b/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java\nindex 1ae0ebf499..76b338231b 100644\n--- a/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java\n+++ b/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java\n\n@@ -63,7 +63,6 @@ public abstract class Collector implements Handler, Formatter {\n     private static final String TAG_LIST_KEY = \"tag\";\n     private static final String MAX_FIELD_KEY = \"maxFieldLength\";\n     private static final String MAX_EVENTS_KEY = \"maxEvents\";\n-    private static final String ENABLE_CUSTOM_ACCESS_LOG_FIELDS_KEY = \"jsonAccessLogFields\";\n \n     protected static final String EXECUTOR_SERVICE = \"executorService\";\n     protected final AtomicServiceReference<ExecutorService> executorServiceRef = new AtomicServiceReference<ExecutorService>(EXECUTOR_SERVICE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI0Njc2Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395246762", "bodyText": "This seems a bit out of place given the Collector is for general use by all event types.", "author": "donbourne", "createdAt": "2020-03-19T18:48:49Z", "path": "dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java", "diffHunk": "@@ -209,6 +210,7 @@ private void configure(Map<String, Object> configuration) throws IOException {\n      * 3) Status, whether it is enabled or not\n      * 4) Tags associated with the config\n      * 5) maxEvents associated with the config, to throttle events\n+     * 6) Whether custom access log fields will be sent", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java b/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java\nindex 1ae0ebf499..76b338231b 100644\n--- a/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java\n+++ b/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/Collector.java\n\n@@ -210,7 +209,6 @@ public abstract class Collector implements Handler, Formatter {\n      * 3) Status, whether it is enabled or not\n      * 4) Tags associated with the config\n      * 5) maxEvents associated with the config, to throttle events\n-     * 6) Whether custom access log fields will be sent\n      */\n     private List<TaskConfig> parseConfig(Map<String, Object> config) {\n         List<TaskConfig> result = new ArrayList<TaskConfig>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI1MjMwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395252304", "bodyText": "jsonAccessLogFields seems out of place here as this is used for formatting any kind of event.", "author": "donbourne", "createdAt": "2020-03-19T18:58:12Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/Formatter.java", "diffHunk": "@@ -18,4 +18,6 @@\n      * by target.\n      */\n     public abstract Object formatEvent(String source, String location, Object event, String[] tags, int maxFieldLength);\n+\n+    public abstract Object formatEvent(String source, String location, Object event, String[] tags, int maxFieldLength, String jsonAccessLogFields);", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/Formatter.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/Formatter.java\nindex 7d9a9b8f53..61aae97409 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/Formatter.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/Formatter.java\n\n@@ -19,5 +19,4 @@ public interface Formatter {\n      */\n     public abstract Object formatEvent(String source, String location, Object event, String[] tags, int maxFieldLength);\n \n-    public abstract Object formatEvent(String source, String location, Object event, String[] tags, int maxFieldLength, String jsonAccessLogFields);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4MDE3NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395880175", "bodyText": "again, seems incorrect to make TaskImpl (which handles all kinds of events) deal with access log field settings.", "author": "donbourne", "createdAt": "2020-03-20T20:42:07Z", "path": "dev/com.ibm.ws.collector/src/com/ibm/ws/collector/internal/TaskImpl.java", "diffHunk": "@@ -118,7 +118,8 @@ public void start() {\n     private void processEvent(Object event) {\n         long startTime = System.nanoTime();\n \n-        Object formattedEvent = formatter.formatEvent(config.getSourceName(), config.getLocation(), event, config.getTags(), config.getMaxFieldLength());\n+        Object formattedEvent = formatter.formatEvent(config.getSourceName(), config.getLocation(), event, config.getTags(), config.getMaxFieldLength(),\n+                                                      config.getjsonAccessLogFields());", "originalCommit": "32c6cffaf51988e90f24a76d864edd4ef0573fc7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/internal/TaskImpl.java b/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/internal/TaskImpl.java\nindex e8a64f1de6..30ead07db7 100644\n--- a/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/internal/TaskImpl.java\n+++ b/dev/com.ibm.ws.collector/src/com/ibm/ws/collector/internal/TaskImpl.java\n\n@@ -118,8 +118,7 @@ public class TaskImpl extends Task implements Runnable {\n     private void processEvent(Object event) {\n         long startTime = System.nanoTime();\n \n-        Object formattedEvent = formatter.formatEvent(config.getSourceName(), config.getLocation(), event, config.getTags(), config.getMaxFieldLength(),\n-                                                      config.getjsonAccessLogFields());\n+        Object formattedEvent = formatter.formatEvent(config.getSourceName(), config.getLocation(), event, config.getTags(), config.getMaxFieldLength());\n         if (formattedEvent != null)\n             eventsBuffer.add(formattedEvent);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTY5Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395889696", "bodyText": "may be more helpful to call these the non-default access log fields and change the label above to be the default access log fields", "author": "donbourne", "createdAt": "2020-03-20T21:06:18Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java", "diffHunk": "@@ -76,6 +76,25 @@\n     public static final String RESPONSECODE = \"responseCode\";\n     public static final String IBM_ELAPSEDTIME = \"ibm_elapsedTime\";\n     public static final String ELAPSEDTIME = \"elapsedTime\";\n+    // LG-265 new fields", "originalCommit": "ac9491be68a294634dcf67bed6af3fadaade6685", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java\nindex 58775cfeaf..e468015bab 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/LogFieldConstants.java\n\n@@ -76,7 +76,7 @@ public class LogFieldConstants {\n     public static final String RESPONSECODE = \"responseCode\";\n     public static final String IBM_ELAPSEDTIME = \"ibm_elapsedTime\";\n     public static final String ELAPSEDTIME = \"elapsedTime\";\n-    // LG-265 new fields\n+    // Non-default access log fields\n     public static final String IBM_REMOTEIP = \"ibm_remoteIP\";\n     public static final String REMOTEIP = \"remoteIP\";\n     public static final String IBM_BYTESSENT = \"ibm_bytesSent\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5MTkwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395891906", "bodyText": "what if user just wants one header?  seems too general to just check for %i", "author": "donbourne", "createdAt": "2020-03-20T21:12:23Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -82,64 +110,233 @@ private void setPair(int index, long l) {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(long l) {\n-        setPair(0, l);\n+    public void setRequestStartTime(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%t\")) {\n+            setRequestStartTime(s);\n+            this.formatSpecifiers[0] = true;\n+        }\n+    }\n+\n+    public void setRequestStartTime(String s) {\n+        setPair(0, s);\n+    }\n+\n+    public void setUriPath(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%U\")) {\n+            setUriPath(s);\n+            this.formatSpecifiers[1] = true;\n+        }\n     }\n \n     public void setUriPath(String s) {\n         setPair(1, s);\n     }\n \n+    public void setRequestMethod(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%m\")) {\n+            setRequestMethod(s);\n+            this.formatSpecifiers[2] = true;\n+        }\n+    }\n+\n     public void setRequestMethod(String s) {\n         setPair(2, s);\n     }\n \n+    public void setQueryString(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%q\")) {\n+            setQueryString(s);\n+            this.formatSpecifiers[3] = true;\n+        }\n+    }\n+\n     public void setQueryString(String s) {\n         setPair(3, s);\n     }\n \n+    public void setRequestHost(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%A\")) {\n+            setRequestHost(s);\n+            this.formatSpecifiers[4] = true;\n+        }\n+    }\n+\n     public void setRequestHost(String s) {\n         setPair(4, s);\n     }\n \n+    public void setRequestPort(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%p\")) {\n+            setRequestPort(s);\n+            this.formatSpecifiers[5] = true;\n+        }\n+    }\n+\n     public void setRequestPort(String s) {\n         setPair(5, s);\n     }\n \n+    public void setRemoteHost(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%h\")) {\n+            setRemoteHost(s);\n+            this.formatSpecifiers[6] = true;\n+        }\n+    }\n+\n     public void setRemoteHost(String s) {\n         setPair(6, s);\n     }\n \n+    public void setUserAgent(String s, ArrayList<String> formatSpecifiers) {\n+        if (formatSpecifiers.contains(\"%i\")) {", "originalCommit": "610abea3c428614f923d79a4e25dad4c9fbe2439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 9308136ddf..5ae1c933af 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -110,134 +136,50 @@ public class AccessLogData extends GenericData {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%t\")) {\n-            setRequestStartTime(s);\n-            this.formatSpecifiers[0] = true;\n-        }\n-    }\n-\n     public void setRequestStartTime(String s) {\n         setPair(0, s);\n     }\n \n-    public void setUriPath(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%U\")) {\n-            setUriPath(s);\n-            this.formatSpecifiers[1] = true;\n-        }\n-    }\n-\n     public void setUriPath(String s) {\n         setPair(1, s);\n     }\n \n-    public void setRequestMethod(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%m\")) {\n-            setRequestMethod(s);\n-            this.formatSpecifiers[2] = true;\n-        }\n-    }\n-\n     public void setRequestMethod(String s) {\n         setPair(2, s);\n     }\n \n-    public void setQueryString(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%q\")) {\n-            setQueryString(s);\n-            this.formatSpecifiers[3] = true;\n-        }\n-    }\n-\n     public void setQueryString(String s) {\n         setPair(3, s);\n     }\n \n-    public void setRequestHost(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%A\")) {\n-            setRequestHost(s);\n-            this.formatSpecifiers[4] = true;\n-        }\n-    }\n-\n     public void setRequestHost(String s) {\n         setPair(4, s);\n     }\n \n-    public void setRequestPort(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%p\")) {\n-            setRequestPort(s);\n-            this.formatSpecifiers[5] = true;\n-        }\n-    }\n-\n     public void setRequestPort(String s) {\n         setPair(5, s);\n     }\n \n-    public void setRemoteHost(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%h\")) {\n-            setRemoteHost(s);\n-            this.formatSpecifiers[6] = true;\n-        }\n-    }\n-\n     public void setRemoteHost(String s) {\n         setPair(6, s);\n     }\n \n-    public void setUserAgent(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%i\")) {\n-            setUserAgent(s);\n-            this.formatSpecifiers[7] = true;\n-        }\n-    }\n-\n     public void setUserAgent(String s) {\n         setPair(7, s);\n     }\n \n-    public void setRequestProtocol(String s, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%H\")) {\n-            setRequestProtocol(s);\n-            this.formatSpecifiers[8] = true;\n-        }\n-    }\n-\n     public void setRequestProtocol(String s) {\n         setPair(8, s);\n     }\n \n-    public void setBytesReceived(long l, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%B\")) {\n-            setBytesReceived(l);\n-            this.formatSpecifiers[9] = true;\n-        }\n-    }\n-\n     public void setBytesReceived(long l) {\n         setPair(9, l);\n     }\n \n-    public void setResponseCode(int i, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%s\")) {\n-            setResponseCode(i);\n-            this.formatSpecifiers[10] = true;\n-        }\n-    }\n-\n     public void setResponseCode(int i) {\n         setPair(10, i);\n     }\n \n-    public void setElapsedTime(long l, ArrayList<String> formatSpecifiers) {\n-        if (formatSpecifiers.contains(\"%{R}W\")) {\n-            setElapsedTime(l);\n-            this.formatSpecifiers[11] = true;\n-        }\n-    }\n-\n     public void setElapsedTime(long l) {\n         setPair(11, l);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNTQ0Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r395915443", "bodyText": "possible concern -- if this method, and other like it, follow the exception path often it will cause performance degradation.  eg. if it can happen on multiple fields in every request.", "author": "donbourne", "createdAt": "2020-03-20T22:24:08Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,25 +372,90 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {", "originalCommit": "610abea3c428614f923d79a4e25dad4c9fbe2439", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTY0Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219647", "bodyText": "With the new design, we should not be running into any exceptions, so I'm removing the try/catch. (If we do run into an exception, it means we made a mistake elsewhere, likely AccessLogSource.)", "author": "jennifer-c", "createdAt": "2020-04-30T18:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxNTQ0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 9308136ddf..5ae1c933af 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -456,265 +355,123 @@ public class AccessLogData extends GenericData {\n         return (KeyValuePairList) getPairs()[index];\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n-    }\n-\n-    public String getUriPathKey() {\n-        return NAMES[1];\n-    }\n-\n-    public String getRequestMethodKey() {\n-        return NAMES[2];\n-    }\n-\n-    public String getQueryStringKey() {\n-        return NAMES[3];\n-    }\n-\n-    public String getRequestHostKey() {\n-        return NAMES[4];\n-    }\n-\n-    public String getRequestPortKey() {\n-        return NAMES[5];\n-    }\n-\n-    public String getRemoteHostKey() {\n-        return NAMES[6];\n-    }\n-\n-    public String getUserAgentKey() {\n-        return NAMES[7];\n-    }\n-\n-    public String getRequestProtocolKey() {\n-        return NAMES[8];\n-    }\n-\n-    public String getBytesReceivedKey() {\n-        return NAMES[9];\n+    public static String getRequestStartTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[0];\n     }\n \n-    public String getResponseCodeKey() {\n-        return NAMES[10];\n+    public static String getUriPathKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[1];\n     }\n \n-    public String getElapsedTimeKey() {\n-        return NAMES[11];\n+    public static String getRequestMethodKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[2];\n     }\n \n-    public String getDatetimeKey() {\n-        return NAMES[12];\n+    public static String getQueryStringKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[3];\n     }\n \n-    public String getSequenceKey() {\n-        return NAMES[13];\n+    public static String getRequestHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[4];\n     }\n \n-    // LG 265\n-    public String getRemoteIPKey() {\n-        return NAMES[14];\n+    public static String getRequestPortKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[5];\n     }\n \n-    public String getBytesSentKey() {\n-        return NAMES[15];\n+    public static String getRemoteHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[6];\n     }\n \n-    public String getCookieKey(KeyValuePair kvp) {\n-        return NAMES[16] + \"_\" + kvp.getKey();\n+    public static String getUserAgentKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[7];\n     }\n \n-    public String getRequestElapsedTimeKey() {\n-        return NAMES[17];\n+    public static String getRequestProtocolKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[8];\n     }\n \n-    public String getRequestHeaderKey(KeyValuePair kvp) {\n-        return NAMES[18] + \"_\" + kvp.getKey();\n+    public static String getBytesReceivedKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[9];\n     }\n \n-    public String getResponseHeaderKey(KeyValuePair kvp) {\n-        return NAMES[19] + \"_\" + kvp.getKey();\n+    public static String getResponseCodeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[10];\n     }\n \n-    public String getRequestFirstLineKey() {\n-        return NAMES[20];\n+    public static String getElapsedTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[11];\n     }\n \n-    public String getAccessLogDatetimeKey() {\n-        return NAMES[21];\n+    public static String getDatetimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[12];\n     }\n \n-    public String getRemoteUserKey() {\n-        return NAMES[22];\n+    public static String getSequenceKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[13];\n     }\n-    // LG 265\n \n-    public String getRequestStartTimeKey1_1() {\n-        return NAMES1_1[0];\n+    public static String getHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[14];\n     }\n \n-    public String getUriPathKey1_1() {\n-        return NAMES1_1[1];\n+    public static String getUserDirKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[15];\n     }\n \n-    public String getRequestMethodKey1_1() {\n-        return NAMES1_1[2];\n+    public static String getServerNameKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[16];\n     }\n \n-    public String getQueryStringKey1_1() {\n-        return NAMES1_1[3];\n+    public static String getTypeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[17];\n     }\n \n-    public String getRequestHostKey1_1() {\n-        return NAMES1_1[4];\n+    public static String getRemoteIPKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[18];\n     }\n \n-    public String getRequestPortKey1_1() {\n-        return NAMES1_1[5];\n+    public static String getBytesSentKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[19];\n     }\n \n-    public String getRemoteHostKey1_1() {\n-        return NAMES1_1[6];\n-    }\n-\n-    public String getUserAgentKey1_1() {\n-        return NAMES1_1[7];\n-    }\n-\n-    public String getRequestProtocolKey1_1() {\n-        return NAMES1_1[8];\n-    }\n-\n-    public String getBytesReceivedKey1_1() {\n-        return NAMES1_1[9];\n-    }\n-\n-    public String getResponseCodeKey1_1() {\n-        return NAMES1_1[10];\n-    }\n-\n-    public String getElapsedTimeKey1_1() {\n-        return NAMES1_1[11];\n-    }\n-\n-    public String getDatetimeKey1_1() {\n-        return NAMES1_1[12];\n-    }\n-\n-    public String getSequenceKey1_1() {\n-        return NAMES1_1[13];\n-    }\n-\n-    //name aliases\n-\n-    public static String getRequestStartTimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[0];\n-    }\n-\n-    public static String getUriPathKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[1];\n-    }\n-\n-    public static String getRequestMethodKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[2];\n-    }\n-\n-    public static String getQueryStringKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[3];\n-    }\n-\n-    public static String getRequestHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[4];\n-    }\n-\n-    public static String getRequestPortKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[5];\n-    }\n-\n-    public static String getRemoteHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[6];\n-    }\n-\n-    public static String getUserAgentKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[9];\n-    }\n-\n-    public static String getResponseCodeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[11];\n-    }\n-\n-    public static String getDatetimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[12];\n-    }\n-\n-    public static String getSequenceKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[13];\n-    }\n-\n-    public static String getHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[14];\n-    }\n-\n-    public static String getUserDirKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[15];\n-    }\n-\n-    public static String getServerNameKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[16];\n-    }\n-\n-    public static String getTypeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[17];\n-    }\n-\n-    // LG-265\n-    public static String getRemoteIPKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[18];\n-    }\n-\n-    public static String getBytesSentKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[19];\n-    }\n-\n-    public static String getCookieKeyJSON(KeyValuePair kvp) {\n-        return jsonLoggingNameAliases.aliases[20] + \"_\" + kvp.getKey();\n+    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+        String cookieName = kvp.getKey();\n+        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+            return cookieMap.get(cookieName);\n+        }\n+        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();\n     }\n \n-    public static String getRequestElapsedTimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[21];\n+    public static String getRequestElapsedTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[21];\n     }\n \n-    public static String getRequestHeaderKeyJSON(KeyValuePair kvp) {\n-        return jsonLoggingNameAliases.aliases[22] + \"_\" + kvp.getKey();\n+    public static String getRequestHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+        String requestHeader = kvp.getKey();\n+        if (requestHeaderMap.containsKey(requestHeader) && format.equals(\"JSON\")) {\n+            return requestHeaderMap.get(requestHeader);\n+        }\n+        return nameAliases[format.getValue()].aliases[22] + \"_\" + kvp.getKey();\n     }\n \n-    public static String getResponseHeaderKeyJSON(KeyValuePair kvp) {\n-        return jsonLoggingNameAliases.aliases[23] + \"_\" + kvp.getKey();\n+    public static String getResponseHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+        String responseHeader = kvp.getKey();\n+        if (responseHeaderMap.containsKey(responseHeader) && format.equals(\"JSON\")) {\n+            return responseHeaderMap.get(responseHeader);\n+        }\n+        return nameAliases[format.getValue()].aliases[23] + \"_\" + kvp.getKey();\n     }\n \n-    public static String getRequestFirstLineKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[24];\n+    public static String getRequestFirstLineKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[24];\n     }\n \n-    public static String getAccessLogDatetimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[25];\n+    public static String getAccessLogDatetimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[25];\n     }\n \n-    public static String getRemoteUserKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[26];\n+    public static String getRemoteUserKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[26];\n     }\n-    // END LG-265\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjAxODg1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r396018859", "bodyText": "not sure you need a whole method for this.  could just use:\nrequestMethod = (request == null) ? null : request.getMethod();\n\n(and similarly for next 3 lines)", "author": "donbourne", "createdAt": "2020-03-21T18:56:29Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java", "diffHunk": "@@ -31,10 +31,10 @@ public boolean set(StringBuilder accessLogEntry,\n         String requestVersion = null;\n \n         if (request != null) {\n-            requestMethod = request.getMethod();\n-            requestURI = request.getRequestURI();\n-            requestQueryString = request.getQueryString();\n-            requestVersion = request.getVersion();\n+            requestMethod = getRequestMethod(response, request, data);", "originalCommit": "610abea3c428614f923d79a4e25dad4c9fbe2439", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\nindex 2f9cb6a7c0..5681e82ba4 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\n\n@@ -31,10 +31,10 @@ public class AccessLogFirstLine extends AccessLogData {\n         String requestVersion = null;\n \n         if (request != null) {\n-            requestMethod = getRequestMethod(response, request, data);\n-            requestURI = getRequestURI(response, request, data);\n-            requestQueryString = getRequestQueryString(response, request, data);\n-            requestVersion = getRequestVersion(response, request, data);\n+            requestMethod = (request == null) ? null : request.getMethod();\n+            requestURI = (request == null) ? null : request.getRequestURI();\n+            requestQueryString = (request == null) ? null : request.getQueryString();\n+            requestVersion = (request == null) ? null : request.getVersion();\n         }\n \n         logSafe(accessLogEntry, requestMethod);\n"}}, {"oid": "a15e6c9bc0d03a379798c502ac1d3768f5cefdbe", "url": "https://github.com/OpenLiberty/open-liberty/commit/a15e6c9bc0d03a379798c502ac1d3768f5cefdbe", "message": "Fix bugs + clean up", "committedDate": "2020-04-20T15:16:13Z", "type": "forcePushed"}, {"oid": "c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "url": "https://github.com/OpenLiberty/open-liberty/commit/c85b0ca2f5599c634c4ac82685d5b1f15530a80d", "message": "Merge branch 'accessLogFormatToJSONSetterFormatters' into accessLogFormatToJSON", "committedDate": "2020-04-20T16:11:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE2ODY0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413168640", "bodyText": "add a comment here to indicate what the 4 formatters are for", "author": "donbourne", "createdAt": "2020-04-22T17:18:09Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -53,21 +64,64 @@\n                                             LogFieldConstants.RESPONSECODE,\n                                             LogFieldConstants.ELAPSEDTIME,\n                                             LogFieldConstants.DATETIME,\n-                                            LogFieldConstants.SEQUENCE\n+                                            LogFieldConstants.SEQUENCE,\n+                                            LogFieldConstants.HOSTNAME,\n+                                            LogFieldConstants.WLPUSERDIR,\n+                                            LogFieldConstants.SERVERNAME,\n+                                            LogFieldConstants.TYPE,\n+                                            LogFieldConstants.REMOTEIP,\n+                                            LogFieldConstants.BYTESSENT,\n+                                            LogFieldConstants.COOKIE,\n+                                            LogFieldConstants.REQUESTELAPSEDTIME,\n+                                            LogFieldConstants.REQUESTHEADER,\n+                                            LogFieldConstants.RESPONSEHEADER,\n+                                            LogFieldConstants.REQUESTFIRSTLINE,\n+                                            LogFieldConstants.ACCESSLOGDATETIME,\n+                                            LogFieldConstants.REMOTEUSERID\n     };\n \n+    // For renaming/omitting fields\n+    private static Map<String, String> cookieMap = new HashMap<>();\n+    private static Map<String, String> requestHeaderMap = new HashMap<>();\n+    private static Map<String, String> responseHeaderMap = new HashMap<>();\n+\n     private static NameAliases jsonLoggingNameAliases = new NameAliases(NAMES1_1);\n+    private static NameAliases jsonLoggingNameAliasesLogstash = new NameAliases(NAMES);\n+\n+    private static NameAliases[] nameAliases = { jsonLoggingNameAliases, jsonLoggingNameAliasesLogstash };\n+\n+    public AccessLogDataFormatter[] formatters = new AccessLogDataFormatter[4];", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -80,6 +80,9 @@ public class AccessLogData extends GenericData {\n                                             LogFieldConstants.REMOTEUSERID\n     };\n \n+    public static final short KEYS_JSON = 0;\n+    public static final short KEYS_LOGSTASH = 1;\n+\n     // For renaming/omitting fields\n     private static Map<String, String> cookieMap = new HashMap<>();\n     private static Map<String, String> requestHeaderMap = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE4MDY1NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413180655", "bodyText": "The FormatSpecifier seems overkill and is causing extra method calls.  Suggest we switch to some constants in this file....\nstatic final short KEYS_JSON=0;\nstatic final short KEYS_LOGSTASH=0;", "author": "donbourne", "createdAt": "2020-04-22T17:34:23Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,208 +271,207 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {\n+            return getLongValue(9);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public int getResponseCode() {\n-        return getIntValue(10);\n+        try {\n+            return getIntValue(10);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getElapsedTime() {\n-        return getLongValue(11);\n+        try {\n+            return getLongValue(11);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getDatetime() {\n-        return getLongValue(12);\n+        try {\n+            return getLongValue(12);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public String getSequence() {\n         return getStringValue(13);\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n-    }\n-\n-    public String getUriPathKey() {\n-        return NAMES[1];\n-    }\n-\n-    public String getRequestMethodKey() {\n-        return NAMES[2];\n-    }\n-\n-    public String getQueryStringKey() {\n-        return NAMES[3];\n-    }\n-\n-    public String getRequestHostKey() {\n-        return NAMES[4];\n+    public String getRemoteIP() {\n+        return getStringValue(14);\n     }\n \n-    public String getRequestPortKey() {\n-        return NAMES[5];\n+    public String getBytesSent() {\n+        return getStringValue(15);\n     }\n \n-    public String getRemoteHostKey() {\n-        return NAMES[6];\n+    public KeyValuePairList getCookies() {\n+        return getValues(16);\n     }\n \n-    public String getUserAgentKey() {\n-        return NAMES[7];\n+    public long getRequestElapsedTime() {\n+        try {\n+            return getLongValue(17);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n-    public String getRequestProtocolKey() {\n-        return NAMES[8];\n+    public KeyValuePairList getRequestHeaders() {\n+        return getValues(18);\n     }\n \n-    public String getBytesReceivedKey() {\n-        return NAMES[9];\n+    public KeyValuePairList getResponseHeaders() {\n+        return getValues(19);\n     }\n \n-    public String getResponseCodeKey() {\n-        return NAMES[10];\n+    public String getRequestFirstLine() {\n+        return getStringValue(20);\n     }\n \n-    public String getElapsedTimeKey() {\n-        return NAMES[11];\n+    public String getAccessLogDatetime() {\n+        return getStringValue(21);\n     }\n \n-    public String getDatetimeKey() {\n-        return NAMES[12];\n+    public String getRemoteUser() {\n+        return getStringValue(22);\n     }\n \n-    public String getSequenceKey() {\n-        return NAMES[13];\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n-    public String getRequestStartTimeKey1_1() {\n-        return NAMES1_1[0];\n+    public static String getRequestStartTimeKey(FormatSpecifier format) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -136,342 +141,117 @@ public class AccessLogData extends GenericData {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+         // We only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field\n+        if (cookieMap.containsKey(cookieName) && (format == KEYS_JSON)) {\n             return cookieMap.get(cookieName);\n         }\n-        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[20] + \"_\" + cookieName;\n     }\n \n-    public static String getRequestElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[21];\n-    }\n-\n-    public static String getRequestHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getRequestHeaderKey(int format, KeyValuePair kvp) {\n         String requestHeader = kvp.getKey();\n-        if (requestHeaderMap.containsKey(requestHeader) && format.equals(\"JSON\")) {\n+        if (requestHeaderMap.containsKey(requestHeader) && (format == KEYS_JSON)) {\n             return requestHeaderMap.get(requestHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[22] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[22] + \"_\" + requestHeader;\n     }\n \n-    public static String getResponseHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getResponseHeaderKey(int format, KeyValuePair kvp) {\n         String responseHeader = kvp.getKey();\n-        if (responseHeaderMap.containsKey(responseHeader) && format.equals(\"JSON\")) {\n+        if (responseHeaderMap.containsKey(responseHeader) && (format == KEYS_JSON)) {\n             return responseHeaderMap.get(responseHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[23] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[23] + \"_\" + responseHeader;\n     }\n \n-    public static String getRequestFirstLineKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[24];\n-    }\n-\n-    public static String getAccessLogDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[25];\n-    }\n-\n-    public static String getRemoteUserKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[26];\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5MTM5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413191399", "bodyText": "use cookieName here", "author": "donbourne", "createdAt": "2020-04-22T17:49:35Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -175,208 +271,207 @@ public String getRequestProtocol() {\n     }\n \n     public long getBytesReceived() {\n-        return getLongValue(9);\n+        try {\n+            return getLongValue(9);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public int getResponseCode() {\n-        return getIntValue(10);\n+        try {\n+            return getIntValue(10);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getElapsedTime() {\n-        return getLongValue(11);\n+        try {\n+            return getLongValue(11);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public long getDatetime() {\n-        return getLongValue(12);\n+        try {\n+            return getLongValue(12);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n     public String getSequence() {\n         return getStringValue(13);\n     }\n \n-    public String getRequestStartTimeKey() {\n-        return NAMES[0];\n-    }\n-\n-    public String getUriPathKey() {\n-        return NAMES[1];\n-    }\n-\n-    public String getRequestMethodKey() {\n-        return NAMES[2];\n-    }\n-\n-    public String getQueryStringKey() {\n-        return NAMES[3];\n-    }\n-\n-    public String getRequestHostKey() {\n-        return NAMES[4];\n+    public String getRemoteIP() {\n+        return getStringValue(14);\n     }\n \n-    public String getRequestPortKey() {\n-        return NAMES[5];\n+    public String getBytesSent() {\n+        return getStringValue(15);\n     }\n \n-    public String getRemoteHostKey() {\n-        return NAMES[6];\n+    public KeyValuePairList getCookies() {\n+        return getValues(16);\n     }\n \n-    public String getUserAgentKey() {\n-        return NAMES[7];\n+    public long getRequestElapsedTime() {\n+        try {\n+            return getLongValue(17);\n+        } catch (Exception e) {\n+            // Do nothing, the field hasn't been set in the logFormat\n+        }\n+        return -1;\n     }\n \n-    public String getRequestProtocolKey() {\n-        return NAMES[8];\n+    public KeyValuePairList getRequestHeaders() {\n+        return getValues(18);\n     }\n \n-    public String getBytesReceivedKey() {\n-        return NAMES[9];\n+    public KeyValuePairList getResponseHeaders() {\n+        return getValues(19);\n     }\n \n-    public String getResponseCodeKey() {\n-        return NAMES[10];\n+    public String getRequestFirstLine() {\n+        return getStringValue(20);\n     }\n \n-    public String getElapsedTimeKey() {\n-        return NAMES[11];\n+    public String getAccessLogDatetime() {\n+        return getStringValue(21);\n     }\n \n-    public String getDatetimeKey() {\n-        return NAMES[12];\n+    public String getRemoteUser() {\n+        return getStringValue(22);\n     }\n \n-    public String getSequenceKey() {\n-        return NAMES[13];\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n-    public String getRequestStartTimeKey1_1() {\n-        return NAMES1_1[0];\n+    public static String getRequestStartTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[0];\n     }\n \n-    public String getUriPathKey1_1() {\n-        return NAMES1_1[1];\n+    public static String getUriPathKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[1];\n     }\n \n-    public String getRequestMethodKey1_1() {\n-        return NAMES1_1[2];\n+    public static String getRequestMethodKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[2];\n     }\n \n-    public String getQueryStringKey1_1() {\n-        return NAMES1_1[3];\n+    public static String getQueryStringKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[3];\n     }\n \n-    public String getRequestHostKey1_1() {\n-        return NAMES1_1[4];\n+    public static String getRequestHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[4];\n     }\n \n-    public String getRequestPortKey1_1() {\n-        return NAMES1_1[5];\n+    public static String getRequestPortKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[5];\n     }\n \n-    public String getRemoteHostKey1_1() {\n-        return NAMES1_1[6];\n+    public static String getRemoteHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[6];\n     }\n \n-    public String getUserAgentKey1_1() {\n-        return NAMES1_1[7];\n+    public static String getUserAgentKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[7];\n     }\n \n-    public String getRequestProtocolKey1_1() {\n-        return NAMES1_1[8];\n+    public static String getRequestProtocolKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[8];\n     }\n \n-    public String getBytesReceivedKey1_1() {\n-        return NAMES1_1[9];\n+    public static String getBytesReceivedKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[9];\n     }\n \n-    public String getResponseCodeKey1_1() {\n-        return NAMES1_1[10];\n+    public static String getResponseCodeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[10];\n     }\n \n-    public String getElapsedTimeKey1_1() {\n-        return NAMES1_1[11];\n+    public static String getElapsedTimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[11];\n     }\n \n-    public String getDatetimeKey1_1() {\n-        return NAMES1_1[12];\n+    public static String getDatetimeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[12];\n     }\n \n-    public String getSequenceKey1_1() {\n-        return NAMES1_1[13];\n+    public static String getSequenceKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[13];\n     }\n \n-    //name aliases\n-    public static String getRequestStartTimeKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[0];\n+    public static String getHostKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[14];\n     }\n \n-    public static String getUriPathKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[1];\n+    public static String getUserDirKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[15];\n     }\n \n-    public static String getRequestMethodKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[2];\n+    public static String getServerNameKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[16];\n     }\n \n-    public static String getQueryStringKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[3];\n+    public static String getTypeKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[17];\n     }\n \n-    public static String getRequestHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[4];\n+    public static String getRemoteIPKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[18];\n     }\n \n-    public static String getRequestPortKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[5];\n+    public static String getBytesSentKey(FormatSpecifier format) {\n+        return nameAliases[format.getValue()].aliases[19];\n     }\n \n-    public static String getRemoteHostKeyJSON() {\n-        return jsonLoggingNameAliases.aliases[6];\n+    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+        String cookieName = kvp.getKey();\n+        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+            return cookieMap.get(cookieName);\n+        }\n+        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -136,342 +141,117 @@ public class AccessLogData extends GenericData {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+         // We only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field\n+        if (cookieMap.containsKey(cookieName) && (format == KEYS_JSON)) {\n             return cookieMap.get(cookieName);\n         }\n-        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[20] + \"_\" + cookieName;\n     }\n \n-    public static String getRequestElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[21];\n-    }\n-\n-    public static String getRequestHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getRequestHeaderKey(int format, KeyValuePair kvp) {\n         String requestHeader = kvp.getKey();\n-        if (requestHeaderMap.containsKey(requestHeader) && format.equals(\"JSON\")) {\n+        if (requestHeaderMap.containsKey(requestHeader) && (format == KEYS_JSON)) {\n             return requestHeaderMap.get(requestHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[22] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[22] + \"_\" + requestHeader;\n     }\n \n-    public static String getResponseHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getResponseHeaderKey(int format, KeyValuePair kvp) {\n         String responseHeader = kvp.getKey();\n-        if (responseHeaderMap.containsKey(responseHeader) && format.equals(\"JSON\")) {\n+        if (responseHeaderMap.containsKey(responseHeader) && (format == KEYS_JSON)) {\n             return responseHeaderMap.get(responseHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[23] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[23] + \"_\" + responseHeader;\n     }\n \n-    public static String getRequestFirstLineKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[24];\n-    }\n-\n-    public static String getAccessLogDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[25];\n-    }\n-\n-    public static String getRemoteUserKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[26];\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzE5NTE5NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413195195", "bodyText": "may not be safe to call clear - set to a new empty Map instead", "author": "donbourne", "createdAt": "2020-04-22T17:54:55Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -53,21 +64,64 @@\n                                             LogFieldConstants.RESPONSECODE,\n                                             LogFieldConstants.ELAPSEDTIME,\n                                             LogFieldConstants.DATETIME,\n-                                            LogFieldConstants.SEQUENCE\n+                                            LogFieldConstants.SEQUENCE,\n+                                            LogFieldConstants.HOSTNAME,\n+                                            LogFieldConstants.WLPUSERDIR,\n+                                            LogFieldConstants.SERVERNAME,\n+                                            LogFieldConstants.TYPE,\n+                                            LogFieldConstants.REMOTEIP,\n+                                            LogFieldConstants.BYTESSENT,\n+                                            LogFieldConstants.COOKIE,\n+                                            LogFieldConstants.REQUESTELAPSEDTIME,\n+                                            LogFieldConstants.REQUESTHEADER,\n+                                            LogFieldConstants.RESPONSEHEADER,\n+                                            LogFieldConstants.REQUESTFIRSTLINE,\n+                                            LogFieldConstants.ACCESSLOGDATETIME,\n+                                            LogFieldConstants.REMOTEUSERID\n     };\n \n+    // For renaming/omitting fields\n+    private static Map<String, String> cookieMap = new HashMap<>();\n+    private static Map<String, String> requestHeaderMap = new HashMap<>();\n+    private static Map<String, String> responseHeaderMap = new HashMap<>();\n+\n     private static NameAliases jsonLoggingNameAliases = new NameAliases(NAMES1_1);\n+    private static NameAliases jsonLoggingNameAliasesLogstash = new NameAliases(NAMES);\n+\n+    private static NameAliases[] nameAliases = { jsonLoggingNameAliases, jsonLoggingNameAliasesLogstash };\n+\n+    public AccessLogDataFormatter[] formatters = new AccessLogDataFormatter[4];\n+    KeyValuePairList kvplCookies = new KeyValuePairList(\"cookies\");\n+    KeyValuePairList kvplRequestHeaders = new KeyValuePairList(\"requestHeaders\");\n+    KeyValuePairList kvplResponseHeaders = new KeyValuePairList(\"responseHeaders\");\n+\n+    public static void populateDataMaps(Map<String, String> cookies, Map<String, String> requestHeaders, Map<String, String> responseHeaders) {\n+        cookieMap = cookies;\n+        requestHeaderMap = requestHeaders;\n+        responseHeaderMap = responseHeaders;\n+    }\n+\n+    public void addFormatters(AccessLogDataFormatter[] formatters) {\n+        this.formatters = formatters;\n+    }\n+\n+    public AccessLogDataFormatter[] getFormatters() {\n+        return this.formatters;\n+    }\n \n     public static void newJsonLoggingNameAliases(Map<String, String> newAliases) {\n         jsonLoggingNameAliases.newAliases(newAliases);\n     }\n \n     public static void resetJsonLoggingNameAliases() {\n         jsonLoggingNameAliases.resetAliases();\n+        cookieMap.clear();\n+        requestHeaderMap.clear();\n+        responseHeaderMap.clear();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -80,6 +80,9 @@ public class AccessLogData extends GenericData {\n                                             LogFieldConstants.REMOTEUSERID\n     };\n \n+    public static final short KEYS_JSON = 0;\n+    public static final short KEYS_LOGSTASH = 1;\n+\n     // For renaming/omitting fields\n     private static Map<String, String> cookieMap = new HashMap<>();\n     private static Map<String, String> requestHeaderMap = new HashMap<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDU5MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413350591", "bodyText": "why change from long to String?", "author": "donbourne", "createdAt": "2020-04-22T21:36:48Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -82,8 +136,8 @@ private void setPair(int index, long l) {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(long l) {\n-        setPair(0, l);\n+    public void setRequestStartTime(String s) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTQ1Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219457", "bodyText": "This was an old piece of code that was never called. This has been updated to be a String value (see Slide 21 on the UFO).", "author": "jennifer-c", "createdAt": "2020-04-30T18:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDU5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -136,342 +141,117 @@ public class AccessLogData extends GenericData {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+         // We only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field\n+        if (cookieMap.containsKey(cookieName) && (format == KEYS_JSON)) {\n             return cookieMap.get(cookieName);\n         }\n-        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[20] + \"_\" + cookieName;\n     }\n \n-    public static String getRequestElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[21];\n-    }\n-\n-    public static String getRequestHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getRequestHeaderKey(int format, KeyValuePair kvp) {\n         String requestHeader = kvp.getKey();\n-        if (requestHeaderMap.containsKey(requestHeader) && format.equals(\"JSON\")) {\n+        if (requestHeaderMap.containsKey(requestHeader) && (format == KEYS_JSON)) {\n             return requestHeaderMap.get(requestHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[22] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[22] + \"_\" + requestHeader;\n     }\n \n-    public static String getResponseHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getResponseHeaderKey(int format, KeyValuePair kvp) {\n         String responseHeader = kvp.getKey();\n-        if (responseHeaderMap.containsKey(responseHeader) && format.equals(\"JSON\")) {\n+        if (responseHeaderMap.containsKey(responseHeader) && (format == KEYS_JSON)) {\n             return responseHeaderMap.get(responseHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[23] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[23] + \"_\" + responseHeader;\n     }\n \n-    public static String getRequestFirstLineKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[24];\n-    }\n-\n-    public static String getAccessLogDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[25];\n-    }\n-\n-    public static String getRemoteUserKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[26];\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDk5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413350998", "bodyText": "why change from long to String?", "author": "donbourne", "createdAt": "2020-04-22T21:37:37Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -130,16 +184,58 @@ public void setElapsedTime(long l) {\n         setPair(11, l);\n     }\n \n+    // Datetime also not part of logFormat\n     public void setDatetime(long l) {\n         setPair(12, l);\n     }\n \n+    // Sequence also not part of logFormat\n     public void setSequence(String s) {\n         setPair(13, s);\n     }\n \n-    public long getRequestStartTime() {\n-        return getLongValue(0);\n+    // New optional access log fields\n+    public void setRemoteIP(String s) {\n+        setPair(14, s);\n+    }\n+\n+    public void setBytesSent(String s) {\n+        setPair(15, s);\n+    }\n+\n+    public void setCookies(String name, String value) {\n+        kvplCookies.addKeyValuePair(name, value);\n+        setPair(16, kvplCookies);\n+    }\n+\n+    public void setRequestElapsedTime(long l) {\n+        setPair(17, l);\n+    }\n+\n+    public void setRequestHeader(String name, String value) {\n+        kvplRequestHeaders.addKeyValuePair(name, value);\n+        setPair(18, kvplRequestHeaders);\n+    }\n+\n+    public void setResponseHeader(String name, String value) {\n+        kvplResponseHeaders.addKeyValuePair(name, value);\n+        setPair(19, kvplResponseHeaders);\n+    }\n+\n+    public void setRequestFirstLine(String s) {\n+        setPair(20, s);\n+    }\n+\n+    public void setAccessLogDatetime(String s) {\n+        setPair(21, s);\n+    }\n+\n+    public void setRemoteUser(String s) {\n+        setPair(22, s);\n+    }\n+\n+    public String getRequestStartTime() {\n+        return getStringValue(0);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTUwNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219504", "bodyText": "see reply above", "author": "jennifer-c", "createdAt": "2020-04-30T18:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MDk5OA=="}], "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -136,342 +141,117 @@ public class AccessLogData extends GenericData {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+         // We only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field\n+        if (cookieMap.containsKey(cookieName) && (format == KEYS_JSON)) {\n             return cookieMap.get(cookieName);\n         }\n-        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[20] + \"_\" + cookieName;\n     }\n \n-    public static String getRequestElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[21];\n-    }\n-\n-    public static String getRequestHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getRequestHeaderKey(int format, KeyValuePair kvp) {\n         String requestHeader = kvp.getKey();\n-        if (requestHeaderMap.containsKey(requestHeader) && format.equals(\"JSON\")) {\n+        if (requestHeaderMap.containsKey(requestHeader) && (format == KEYS_JSON)) {\n             return requestHeaderMap.get(requestHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[22] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[22] + \"_\" + requestHeader;\n     }\n \n-    public static String getResponseHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getResponseHeaderKey(int format, KeyValuePair kvp) {\n         String responseHeader = kvp.getKey();\n-        if (responseHeaderMap.containsKey(responseHeader) && format.equals(\"JSON\")) {\n+        if (responseHeaderMap.containsKey(responseHeader) && (format == KEYS_JSON)) {\n             return responseHeaderMap.get(responseHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[23] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[23] + \"_\" + responseHeader;\n     }\n \n-    public static String getRequestFirstLineKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[24];\n-    }\n-\n-    public static String getAccessLogDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[25];\n-    }\n-\n-    public static String getRemoteUserKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[26];\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3MDA2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r413870066", "bodyText": "could you please take all of the one line methods in this class and reformat those to be one line each with no spaces between lines?  would help for readability and to spot patterns (and any inconsistencies).\n    ...\n    public void setRemoteIP(String s)  { setPair(14, s); }\n    public void setBytesSent(String s) { setPair(15, s); }\n    ...", "author": "donbourne", "createdAt": "2020-04-23T14:57:44Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -130,16 +184,58 @@ public void setElapsedTime(long l) {\n         setPair(11, l);\n     }\n \n+    // Datetime also not part of logFormat\n     public void setDatetime(long l) {\n         setPair(12, l);\n     }\n \n+    // Sequence also not part of logFormat\n     public void setSequence(String s) {\n         setPair(13, s);\n     }\n \n-    public long getRequestStartTime() {\n-        return getLongValue(0);\n+    // New optional access log fields\n+    public void setRemoteIP(String s) {\n+        setPair(14, s);\n+    }\n+\n+    public void setBytesSent(String s) {\n+        setPair(15, s);\n+    }", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 5ae1c933af..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -136,342 +141,117 @@ public class AccessLogData extends GenericData {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+         // We only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field\n+        if (cookieMap.containsKey(cookieName) && (format == KEYS_JSON)) {\n             return cookieMap.get(cookieName);\n         }\n-        return nameAliases[format.getValue()].aliases[20] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[20] + \"_\" + cookieName;\n     }\n \n-    public static String getRequestElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[21];\n-    }\n-\n-    public static String getRequestHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getRequestHeaderKey(int format, KeyValuePair kvp) {\n         String requestHeader = kvp.getKey();\n-        if (requestHeaderMap.containsKey(requestHeader) && format.equals(\"JSON\")) {\n+        if (requestHeaderMap.containsKey(requestHeader) && (format == KEYS_JSON)) {\n             return requestHeaderMap.get(requestHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[22] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[22] + \"_\" + requestHeader;\n     }\n \n-    public static String getResponseHeaderKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public static String getResponseHeaderKey(int format, KeyValuePair kvp) {\n         String responseHeader = kvp.getKey();\n-        if (responseHeaderMap.containsKey(responseHeader) && format.equals(\"JSON\")) {\n+        if (responseHeaderMap.containsKey(responseHeader) && (format == KEYS_JSON)) {\n             return responseHeaderMap.get(responseHeader);\n         }\n-        return nameAliases[format.getValue()].aliases[23] + \"_\" + kvp.getKey();\n+        return nameAliases[format].aliases[23] + \"_\" + responseHeader;\n     }\n \n-    public static String getRequestFirstLineKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[24];\n-    }\n-\n-    public static String getAccessLogDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[25];\n-    }\n-\n-    public static String getRemoteUserKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[26];\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMjcwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414032708", "bodyText": "this class would be easy to abuse in its current form due to thread safety issues.  suggest you create a Builder class inside this class.  Builder would have the add method, new Builder.build method would return the (immutable) AccessLogDataFormatter.", "author": "donbourne", "createdAt": "2020-04-23T18:36:59Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.data;\n+\n+import java.util.ArrayList;\n+\n+import com.ibm.ws.logging.data.JSONObject.JSONObjectBuilder;\n+\n+/**\n+ *\n+ */\n+public class AccessLogDataFormatter {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java\nindex c95674a77e..1fb6aac09e 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java\n\n@@ -14,31 +14,38 @@ import java.util.ArrayList;\n \n import com.ibm.ws.logging.data.JSONObject.JSONObjectBuilder;\n \n-/**\n- *\n- */\n public class AccessLogDataFormatter {\n \n     // list of actions to populate JSONObjectBuilder\n-    private final ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+    private ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+\n+    public static class AccessLogDataFormatterBuilder {\n+        private final ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+\n+        public AccessLogDataFormatterBuilder() {\n+        }\n \n-    public AccessLogDataFormatter() {\n+        public AccessLogDataFormatterBuilder add(JsonFieldAdder jsonFieldAdder) {\n+            this.jsonFieldAdders.add(jsonFieldAdder);\n+            return this;\n+        }\n \n+        public AccessLogDataFormatter build() {\n+            AccessLogDataFormatter formatter = new AccessLogDataFormatter(this);\n+            return formatter;\n+        }\n     }\n \n-    // adds another JsonFieldAdder to the list\n-    public AccessLogDataFormatter add(JsonFieldAdder jsonFieldAdder) {\n-        this.jsonFieldAdders.add(jsonFieldAdder);\n-        return this;\n+    private AccessLogDataFormatter(AccessLogDataFormatterBuilder builder) {\n+        this.jsonFieldAdders = builder.jsonFieldAdders;\n     }\n \n     // adds fields to JSONObjectBuilder by running all jsonFieldAdders\n-    public JSONObjectBuilder populate(JSONObjectBuilder j, AccessLogData a) {\n+    public JSONObjectBuilder populate(JSONObjectBuilder jsonObject, AccessLogData a) {\n         for (JsonFieldAdder jfa : jsonFieldAdders) {\n-            jfa.populate(j, a);\n+            jfa.populate(jsonObject, a);\n         }\n-        return j;\n+        return jsonObject;\n     }\n-    // each jsonFieldAdder formats a single field from AccessLogData as it adds it to the JSONObjectBuilder\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzMzc2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414033769", "bodyText": "see comment in AccessLogData -- suggest we get rid of this class and just use 2 constants instead.", "author": "donbourne", "createdAt": "2020-04-23T18:38:34Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/FormatSpecifier.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.data;\n+\n+/**\n+ *\n+ */\n+public enum FormatSpecifier {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/FormatSpecifier.java b/dev/com.ibm.ws.jpa_spec20_fat/test-applications/olgh10515/src/com/ibm/ws/jpa/olgh10515/model/SimpleEntityOLGH10515_.java\nsimilarity index 50%\nrename from dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/FormatSpecifier.java\nrename to dev/com.ibm.ws.jpa_spec20_fat/test-applications/olgh10515/src/com/ibm/ws/jpa/olgh10515/model/SimpleEntityOLGH10515_.java\nindex 1d9154efeb..b3e5e268e1 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/FormatSpecifier.java\n+++ b/dev/com.ibm.ws.jpa_spec20_fat/test-applications/olgh10515/src/com/ibm/ws/jpa/olgh10515/model/SimpleEntityOLGH10515_.java\n\n@@ -8,28 +8,15 @@\n  * Contributors:\n  *     IBM Corporation - initial API and implementation\n  *******************************************************************************/\n-package com.ibm.ws.logging.data;\n+package com.ibm.ws.jpa.olgh10515.model;\n \n-/**\n- *\n- */\n-public enum FormatSpecifier {\n-    JSON(0, \"JSON\"),\n-    LOGSTASH(1, \"LOGSTASH\");\n-\n-    private int value;\n-    private String name;\n-\n-    private FormatSpecifier(int value, String name) {\n-        this.value = value;\n-        this.name = name;\n-    }\n-\n-    public boolean equals(String s) {\n-        return name.equals(s);\n-    }\n+import javax.persistence.metamodel.MapAttribute;\n+import javax.persistence.metamodel.SingularAttribute;\n+import javax.persistence.metamodel.StaticMetamodel;\n \n-    public int getValue() {\n-        return value;\n-    }\n-}\n+@StaticMetamodel(SimpleEntityOLGH10515.class)\n+public class SimpleEntityOLGH10515_ {\n+    public static volatile SingularAttribute<SimpleEntityOLGH10515, String> id;\n+    public static volatile SingularAttribute<SimpleEntityOLGH10515, Integer> version;\n+    public static volatile MapAttribute<SimpleEntityOLGH10515, String, String> origin;\n+}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzNjEyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414036125", "bodyText": "This class name, inside the com.ibm.ws.logging.data package, doesn't indicate it relates to AccessLogData.  suggest you move this class inside AccessLogSource class since that's the only place it has any relevance.", "author": "donbourne", "createdAt": "2020-04-23T18:42:05Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/JsonFieldAdder.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.data;\n+\n+import com.ibm.ws.logging.data.JSONObject.JSONObjectBuilder;\n+\n+/**\n+ *\n+ */\n+public interface JsonFieldAdder {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIxOTIyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418219220", "bodyText": "I don't think it can be moved to AccessLogSource because AccessLogDataFormatter uses the populate method for the field adders. The http transport bundle (where AccessLogSource is located) is not visible to the logging bundle, so we would need to move both", "author": "jennifer-c", "createdAt": "2020-04-30T18:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzNjEyNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAzODU3OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414038579", "bodyText": "a bit unclear...suggest:\nIf value is logFormat, JSON logs will be formatted to include the fields specified in access logging's logFormat field", "author": "donbourne", "createdAt": "2020-04-23T18:46:07Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java", "diffHunk": "@@ -185,6 +186,9 @@\n     /** If true, format the date and time format for log entries in messages.log, trace.log, and FFDC files in ISO-8601 format. */\n     protected volatile boolean isoDateFormat = false;\n \n+    /** If logFormat, format JSON logs to match the logFormat for access logging */", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\nindex eb985d0d9e..317ff7bfbe 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\n\n@@ -186,7 +186,7 @@ public class BaseTraceService implements TrService {\n     /** If true, format the date and time format for log entries in messages.log, trace.log, and FFDC files in ISO-8601 format. */\n     protected volatile boolean isoDateFormat = false;\n \n-    /** If logFormat, format JSON logs to match the logFormat for access logging */\n+    /** If value is logFormat, JSON logs will be formatted to include the fields specified in http access logging's logFormat field */\n     protected volatile String jsonAccessLogFields = \"default\";\n \n     /** Writer sending messages to the messages.log file */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MTU4Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414151587", "bodyText": "suggest renaming these to make it clear they relate to access logs...\naccessLogCookiesMap, ...", "author": "donbourne", "createdAt": "2020-04-23T21:57:37Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java", "diffHunk": "@@ -493,6 +503,10 @@ public static void applyJsonFields(String value, Boolean omitJsonFields) {\n         Map<String, String> ffdcMap = new HashMap<>();\n         Map<String, String> accessLogMap = new HashMap<>();\n         Map<String, String> auditMap = new HashMap<>();\n+        // For access log data\n+        Map<String, String> cookiesMap = new HashMap<>();\n+        Map<String, String> requestHeaderMap = new HashMap<>();\n+        Map<String, String> responseHeaderMap = new HashMap<>();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\nindex eb985d0d9e..317ff7bfbe 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\n\n@@ -504,9 +507,9 @@ public class BaseTraceService implements TrService {\n         Map<String, String> accessLogMap = new HashMap<>();\n         Map<String, String> auditMap = new HashMap<>();\n         // For access log data\n-        Map<String, String> cookiesMap = new HashMap<>();\n-        Map<String, String> requestHeaderMap = new HashMap<>();\n-        Map<String, String> responseHeaderMap = new HashMap<>();\n+        Map<String, String> accessLogCookiesMap = new HashMap<>();\n+        Map<String, String> accessLogRequestHeaderMap = new HashMap<>();\n+        Map<String, String> accessLogResponseHeaderMap = new HashMap<>();\n \n         List<String> LogTraceList = Arrays.asList(LogTraceData.NAMES1_1);\n         List<String> FFDCList = Arrays.asList(FFDCData.NAMES1_1);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE1MjU4MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414152581", "bodyText": "seems like this might have problems if a cookie name has an underscore in it (same goes for request and response headers)", "author": "donbourne", "createdAt": "2020-04-23T21:59:47Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java", "diffHunk": "@@ -536,6 +550,19 @@ public static void applyJsonFields(String value, Boolean omitJsonFields) {\n                     traceMap.put(entry[0], entry[1]);\n                     valueFound = true;\n                 }\n+\n+                // headers and cookies are special because there can be multiple instances\n+                if (entry[0].contains(\"ibm_cookie_\")) {\n+                    cookiesMap.put(entry[0].substring(entry[0].lastIndexOf(\"_\") + 1), entry[1]);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\nindex eb985d0d9e..317ff7bfbe 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/BaseTraceService.java\n\n@@ -552,14 +555,15 @@ public class BaseTraceService implements TrService {\n                 }\n \n                 // headers and cookies are special because there can be multiple instances\n+                // only applicable to liberty_accesslog\n                 if (entry[0].contains(\"ibm_cookie_\")) {\n-                    cookiesMap.put(entry[0].substring(entry[0].lastIndexOf(\"_\") + 1), entry[1]);\n+                    accessLogCookiesMap.put(entry[0].substring(11), entry[1]);\n                     valueFound = true;\n                 } else if (entry[0].contains(\"ibm_requestHeader_\")) {\n-                    requestHeaderMap.put(entry[0].substring(entry[0].lastIndexOf(\"_\") + 1), entry[1]);\n+                    accessLogRequestHeaderMap.put(entry[0].substring(18), entry[1]);\n                     valueFound = true;\n                 } else if (entry[0].contains(\"ibm_responseHeader_\")) {\n-                    responseHeaderMap.put(entry[0].substring(entry[0].lastIndexOf(\"_\") + 1), entry[1]);\n+                    accessLogResponseHeaderMap.put(entry[0].substring(19), entry[1]);\n                     valueFound = true;\n                 }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MTg0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414641845", "bodyText": "you're very close to being able to merge this method and the method above... would be good to do that!", "author": "donbourne", "createdAt": "2020-04-24T14:57:28Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -385,24 +386,37 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n \n-        if (tempStartFields != null)\n-            jsonBuilder.addFields(tempStartFields);\n-        else {\n+        if (tempStartFields != null) {\n+            jsonBuilder.addPreformatted(tempStartFields);\n+        } else {\n             //@formatter:off\n-            jsonBuilder.addField(AccessLogData.getTypeKeyJSON(), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-            .addField(AccessLogData.getHostKeyJSON(), hostName, false, false)\n-            .addField(AccessLogData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(AccessLogData.getServerNameKeyJSON(), serverName, false, false);\n+            jsonBuilder.addField(AccessLogData.getTypeKey(fs), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(fs), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(fs), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(fs), serverName, false, false);\n             //@formatter:on\n             startAccessLogJsonFields = jsonBuilder.toString();\n         }\n         return jsonBuilder;\n     }\n \n+    protected static JSONObjectBuilder startAccessLogJsonFieldsLogstash(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex baec59f88f..924602913f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -386,37 +394,32 @@ public class CollectorJsonHelpers {\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n+        String tempStartFieldsLogstash = startAccessLogLogstashCollector;\n \n         if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n+            if (format == AccessLogData.KEYS_JSON)\n+                jsonBuilder.addPreformatted(tempStartFields);\n+        } else if (tempStartFieldsLogstash != null) {\n+            if (format == AccessLogData.KEYS_LOGSTASH)\n+                jsonBuilder.addPreformatted(tempStartFieldsLogstash);\n         } else {\n             //@formatter:off\n-            jsonBuilder.addField(AccessLogData.getTypeKey(fs), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-            .addField(AccessLogData.getHostKey(fs), hostName, false, false)\n-            .addField(AccessLogData.getUserDirKey(fs), wlpUserDir, false, true)\n-            .addField(AccessLogData.getServerNameKey(fs), serverName, false, false);\n+            jsonBuilder.addField(AccessLogData.getTypeKey(format), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(format), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(format), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(format), serverName, false, false);\n             //@formatter:on\n-            startAccessLogJsonFields = jsonBuilder.toString();\n+            if (format == AccessLogData.KEYS_JSON)\n+                startAccessLogJsonFields = jsonBuilder.toString();\n+            else if (format == AccessLogData.KEYS_LOGSTASH)\n+                startAccessLogLogstashCollector = jsonBuilder.toString();\n         }\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFieldsLogstash(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {\n-        JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-\n-        //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getTypeKey(fs), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-        .addField(AccessLogData.getHostKey(fs), hostName, false, false)\n-        .addField(AccessLogData.getUserDirKey(fs), wlpUserDir, false, true)\n-        .addField(AccessLogData.getServerNameKey(fs), serverName, false, false);\n-        //@formatter:on\n-\n-        return jsonBuilder;\n-    }\n-\n     protected static String formatMessage(String message, int maxLength) {\n         return (message.length() > maxLength && maxLength > 0) ? message.substring(0, maxLength) + \"...\" : message;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MjMyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414652321", "bodyText": "should only ever be running one formatter for one event.  need to pick the right one for each circumstance.", "author": "donbourne", "createdAt": "2020-04-24T15:11:20Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -217,52 +218,29 @@ private static String jsonifyAccess(String wlpUserDir,\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n \n-        StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n+        if (formatters[3] != null) {\n+            formatters[3].populate(jsonBuilder, accessLogData);\n         }\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getQueryStringKey(), jsonQueryString, false, true, false, false, false);\n \n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHostKey(), accessLogData.getRequestHost(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestPortKey(), accessLogData.getRequestPort(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteHostKey(), accessLogData.getRemoteHost(), false, true, false, false, false);\n-\n-        String userAgent = accessLogData.getUserAgent();\n-\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[2] != null) {\n+            formatters[2].populate(jsonBuilder, accessLogData);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\nindex 1f412bdc01..90a03cea9a 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n\n@@ -218,23 +217,17 @@ public class CollectorJsonUtils {\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, AccessLogData.KEYS_LOGSTASH);\n \n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n-        if (formatters[3] != null) {\n+        // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n+        if (formatters[3] != null)\n             formatters[3].populate(jsonBuilder, accessLogData);\n-        }\n-\n-        if (formatters[2] != null) {\n+        else if (formatters[2] != null)\n             formatters[2].populate(jsonBuilder, accessLogData);\n-        }\n-\n-        String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-        //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.LOGSTASH), datetime, false, true)\n-                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.LOGSTASH), accessLogData.getSequence(), false, true);\n-        //@formatter:on\n+        else\n+            throw new RuntimeException(\"There is no formatter available for this event.\");\n \n         if (tags != null) {\n             jsonBuilder.addPreformattedField(\"tags\", CollectorJsonHelpers.jsonifyTags(tags));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MDY2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414660668", "bodyText": "should only be using 1 formatter to format an event", "author": "donbourne", "createdAt": "2020-04-24T15:22:57Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java", "diffHunk": "@@ -106,43 +106,26 @@ private static String jsonifyFFDC(int maxFieldLength, String wlpUserDir,\n     public static String jsonifyAccess(String wlpUserDir, String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, FormatSpecifier.JSON);\n+\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n+\n+        if (formatters[1] != null) {\n+            formatters[1].populate(jsonBuilder, accessLogData);\n         }\n \n-        String userAgent = accessLogData.getUserAgent();\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH)\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[0] != null) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\nindex b6fbc6bdc7..69bef81311 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\n\n@@ -106,25 +105,23 @@ public class CollectorJsonUtils_JSON {\n     public static String jsonifyAccess(String wlpUserDir, String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, FormatSpecifier.JSON);\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, AccessLogData.KEYS_JSON);\n \n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n-        if (formatters[1] != null) {\n-            formatters[1].populate(jsonBuilder, accessLogData);\n-        }\n+//        formatters[0] = null;\n+//        formatters[1] = null;\n \n-        if (formatters[0] != null) {\n+        // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n+        if (formatters[1] != null)\n+            formatters[1].populate(jsonBuilder, accessLogData);\n+        else if (formatters[0] != null)\n             formatters[0].populate(jsonBuilder, accessLogData);\n-        }\n+        else\n+            throw new RuntimeException(\"There is no formatter available for this event.\");\n \n-        String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-        //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.JSON), datetime, false, true)\n-                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.JSON), accessLogData.getSequence(), false, true);\n-        //@formatter:on\n         if (tags != null) {\n-            jsonBuilder.addField(\"\\\"ibm_tags\\\":\", CollectorJsonHelpers.jsonifyTags(tags), false, false);\n+            jsonBuilder.addPreformattedField(\"ibm_tags\", CollectorJsonHelpers.jsonifyTags(tags));\n         }\n         return jsonBuilder.build().toString();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MDkzMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414660933", "bodyText": "seems like this should be done by the formatter", "author": "donbourne", "createdAt": "2020-04-24T15:23:17Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java", "diffHunk": "@@ -106,43 +106,26 @@ private static String jsonifyFFDC(int maxFieldLength, String wlpUserDir,\n     public static String jsonifyAccess(String wlpUserDir, String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, FormatSpecifier.JSON);\n+\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n+\n+        if (formatters[1] != null) {\n+            formatters[1].populate(jsonBuilder, accessLogData);\n         }\n \n-        String userAgent = accessLogData.getUserAgent();\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH)\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[0] != null) {\n+            formatters[0].populate(jsonBuilder, accessLogData);\n+        }\n \n         String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-\n         //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getUriPathKeyJSON(), accessLogData.getUriPath(), false, true)\n-        .addField(AccessLogData.getRequestMethodKeyJSON(), accessLogData.getRequestMethod(), false, true)\n-        .addField(AccessLogData.getQueryStringKeyJSON(), jsonQueryString, false, true)\n-        .addField(AccessLogData.getRequestHostKeyJSON(), accessLogData.getRequestHost(), false, true)\n-        .addField(AccessLogData.getRequestPortKeyJSON(), accessLogData.getRequestPort(), false, true)\n-        .addField(AccessLogData.getRemoteHostKeyJSON(), accessLogData.getRemoteHost(), false, true)\n-        .addField(AccessLogData.getUserAgentKeyJSON(), userAgent, false, false)\n-        .addField(AccessLogData.getRequestProtocolKeyJSON(), accessLogData.getRequestProtocol(), false, true)\n-        .addField(AccessLogData.getBytesReceivedKeyJSON(), accessLogData.getBytesReceived(), false)\n-        .addField(AccessLogData.getResponseCodeKeyJSON(), accessLogData.getResponseCode(), false)\n-        .addField(AccessLogData.getElapsedTimeKeyJSON(), accessLogData.getElapsedTime(), false)\n-        .addField(AccessLogData.getDatetimeKeyJSON(), datetime, false, true)\n-        .addField(AccessLogData.getSequenceKeyJSON(), accessLogData.getSequence(), false, true);\n+        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.JSON), datetime, false, true)\n+                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.JSON), accessLogData.getSequence(), false, true);\n         //@formatter:on", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\nindex b6fbc6bdc7..69bef81311 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils_JSON.java\n\n@@ -106,25 +105,23 @@ public class CollectorJsonUtils_JSON {\n     public static String jsonifyAccess(String wlpUserDir, String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, FormatSpecifier.JSON);\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, AccessLogData.KEYS_JSON);\n \n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n-        if (formatters[1] != null) {\n-            formatters[1].populate(jsonBuilder, accessLogData);\n-        }\n+//        formatters[0] = null;\n+//        formatters[1] = null;\n \n-        if (formatters[0] != null) {\n+        // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n+        if (formatters[1] != null)\n+            formatters[1].populate(jsonBuilder, accessLogData);\n+        else if (formatters[0] != null)\n             formatters[0].populate(jsonBuilder, accessLogData);\n-        }\n+        else\n+            throw new RuntimeException(\"There is no formatter available for this event.\");\n \n-        String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-        //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.JSON), datetime, false, true)\n-                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.JSON), accessLogData.getSequence(), false, true);\n-        //@formatter:on\n         if (tags != null) {\n-            jsonBuilder.addField(\"\\\"ibm_tags\\\":\", CollectorJsonHelpers.jsonifyTags(tags), false, false);\n+            jsonBuilder.addPreformattedField(\"ibm_tags\", CollectorJsonHelpers.jsonifyTags(tags));\n         }\n         return jsonBuilder.build().toString();\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2MjAwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414662001", "bodyText": "this seems like it should all be done as part of the formatters", "author": "donbourne", "createdAt": "2020-04-24T15:24:41Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -217,52 +218,29 @@ private static String jsonifyAccess(String wlpUserDir,\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n \n-        StringBuilder sb = CollectorJsonHelpers.startAccessLogJson(hostName, wlpUserDir, serverName);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getUriPathKey(), accessLogData.getUriPath(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestMethodKey(), accessLogData.getRequestMethod(), false, true, false, false, false);\n-\n-        String jsonQueryString = accessLogData.getQueryString();\n-        if (jsonQueryString != null) {\n-            try {\n-                jsonQueryString = URLDecoder.decode(jsonQueryString, LogFieldConstants.UTF_8);\n-            } catch (UnsupportedEncodingException e) {\n-                // ignore, use the original value;\n-            }\n+        AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n+        if (formatters[3] != null) {\n+            formatters[3].populate(jsonBuilder, accessLogData);\n         }\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getQueryStringKey(), jsonQueryString, false, true, false, false, false);\n \n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestHostKey(), accessLogData.getRequestHost(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestPortKey(), accessLogData.getRequestPort(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRemoteHostKey(), accessLogData.getRemoteHost(), false, true, false, false, false);\n-\n-        String userAgent = accessLogData.getUserAgent();\n-\n-        if (userAgent != null && userAgent.length() > MAX_USER_AGENT_LENGTH) {\n-            userAgent = userAgent.substring(0, MAX_USER_AGENT_LENGTH);\n+        if (formatters[2] != null) {\n+            formatters[2].populate(jsonBuilder, accessLogData);\n         }\n \n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getUserAgentKey(), userAgent, false, false, false, false, false);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getRequestProtocolKey(), accessLogData.getRequestProtocol(), false, true, false, false, false);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getBytesReceivedKey(), Long.toString(accessLogData.getBytesReceived()), false, true, false, false, true);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getResponseCodeKey(), Integer.toString(accessLogData.getResponseCode()), false, true, false, false, true);\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getElapsedTimeKey(), Long.toString(accessLogData.getElapsedTime()), false, true, false, false, true);\n-\n         String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getDatetimeKey(), datetime, false, true, false, false, false);\n-\n-        CollectorJsonHelpers.addToJSON(sb, accessLogData.getSequenceKey(), accessLogData.getSequence(), false, true, false, false, false);\n+        //@formatter:off\n+        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.LOGSTASH), datetime, false, true)\n+                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.LOGSTASH), accessLogData.getSequence(), false, true);\n+        //@formatter:on", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\nindex 1f412bdc01..90a03cea9a 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n\n@@ -218,23 +217,17 @@ public class CollectorJsonUtils {\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, AccessLogData.KEYS_LOGSTASH);\n \n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n-        if (formatters[3] != null) {\n+        // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n+        if (formatters[3] != null)\n             formatters[3].populate(jsonBuilder, accessLogData);\n-        }\n-\n-        if (formatters[2] != null) {\n+        else if (formatters[2] != null)\n             formatters[2].populate(jsonBuilder, accessLogData);\n-        }\n-\n-        String datetime = CollectorJsonHelpers.dateFormatTL.get().format(accessLogData.getDatetime());\n-        //@formatter:off\n-        jsonBuilder.addField(AccessLogData.getDatetimeKey(FormatSpecifier.LOGSTASH), datetime, false, true)\n-                   .addField(AccessLogData.getSequenceKey(FormatSpecifier.LOGSTASH), accessLogData.getSequence(), false, true);\n-        //@formatter:on\n+        else\n+            throw new RuntimeException(\"There is no formatter available for this event.\");\n \n         if (tags != null) {\n             jsonBuilder.addPreformattedField(\"tags\", CollectorJsonHelpers.jsonifyTags(tags));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2NjIwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414666206", "bodyText": "missing a constant for logFormat?", "author": "donbourne", "createdAt": "2020-04-24T15:30:17Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/LoggingConstants.java", "diffHunk": "@@ -56,6 +56,9 @@\n     //beta env var for omission of json fields\n     String ENV_WLP_LOGGING_OMIT_JSON_FIELD_MAPPINGS = \"WLP_LOGGING_OMIT_JSON_FIELD_MAPPINGS\";\n \n+    String ENV_WLP_LOGGING_JSON_ACCESS_LOG_FIELDS = \"WLP_LOGGING_JSON_ACCESS_LOG_FIELDS\";\n+    String DEFAULT_JSON_ACCESS_LOG_FIELDS = \"default\";", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODU3MjQ0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418572445", "bodyText": "I can add it, but not sure where we'd need to use it", "author": "jennifer-c", "createdAt": "2020-05-01T14:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY2NjIwNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY4MzM2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414683366", "bodyText": "goal of this token is to have the SAME value for time as is written into the access log file... can't get a new time value.", "author": "donbourne", "createdAt": "2020-04-24T15:54:28Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java", "diffHunk": "@@ -50,4 +49,15 @@ public boolean set(StringBuilder accessLogEntry,\n         return true;\n     }\n \n+    public static String getAccessLogCurrentTimeAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        StringBuilder accessLogCurrentTime = new StringBuilder();\n+        if (data == null) {\n+            accessLogCurrentTime.append(\"[\");\n+            accessLogCurrentTime.append(HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis())));", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\nindex d64f0ff3e1..b3a487943a 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\n\n@@ -50,14 +56,6 @@ public class AccessLogCurrentTime extends AccessLogData {\n     }\n \n     public static String getAccessLogCurrentTimeAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n-        StringBuilder accessLogCurrentTime = new StringBuilder();\n-        if (data == null) {\n-            accessLogCurrentTime.append(\"[\");\n-            accessLogCurrentTime.append(HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis())));\n-            accessLogCurrentTime.append(\"]\");\n-        } else {\n-            accessLogCurrentTime.append(\"%{\").append(data).append(\"}W\");\n-        }\n-        return accessLogCurrentTime.toString();\n+        return accessLogDatetime.get();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MDkyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414740924", "bodyText": "can't store this in a static variable -- requests arrive concurrently on multiple threads.", "author": "donbourne", "createdAt": "2020-04-24T17:25:44Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java", "diffHunk": "@@ -24,10 +24,26 @@ public AccessLogElapsedTime() {\n         // Millisecond accuracy, microsecond precision\n     }\n \n+    // Need some way to \"remember\" the elapsedTime value; the System.nanoTime - startTime\n+    static long currentTime = 0;", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\nindex 921d14791e..21e917695f 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\n\n@@ -18,25 +18,26 @@ import com.ibm.wsspi.http.channel.HttpResponseMessage;\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n+    // We're assuming that the methods below that use this elapsedTime will be called on the same thread\n+    private static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n+\n     public AccessLogElapsedTime() {\n         super(\"%D\");\n         // %D - Elapsed time, in milliseconds, of the request/response exchange\n         // Millisecond accuracy, microsecond precision\n     }\n \n-    // Need some way to \"remember\" the elapsedTime value; the System.nanoTime - startTime\n-    static long currentTime = 0;\n-\n     @Override\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request,\n                        Object data) {\n         long startTime = getStartTime(response, request, data);\n         if (startTime != 0) {\n-            currentTime = System.nanoTime();\n-            long elapsedTime = currentTime - startTime;\n-            accessLogEntry.append(TimeUnit.NANOSECONDS.toMicros(elapsedTime));\n+            long elapsedTimeInMicroseconds = TimeUnit.NANOSECONDS.toMicros(System.nanoTime() - startTime);\n+            elapsedTime.set(elapsedTimeInMicroseconds);\n+            accessLogEntry.append(elapsedTimeInMicroseconds);\n         } else {\n+            elapsedTime.set((long) -1);\n             accessLogEntry.append(\"-\");\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MzEzMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414743131", "bodyText": "line 33 already ensures request != null, so you don't need to check that in each line", "author": "donbourne", "createdAt": "2020-04-24T17:29:16Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java", "diffHunk": "@@ -31,10 +31,10 @@ public boolean set(StringBuilder accessLogEntry,\n         String requestVersion = null;\n \n         if (request != null) {\n-            requestMethod = request.getMethod();\n-            requestURI = request.getRequestURI();\n-            requestQueryString = request.getQueryString();\n-            requestVersion = request.getVersion();\n+            requestMethod = (request == null) ? null : request.getMethod();\n+            requestURI = (request == null) ? null : request.getRequestURI();\n+            requestQueryString = (request == null) ? null : request.getQueryString();\n+            requestVersion = (request == null) ? null : request.getVersion();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\nindex 5681e82ba4..64744d72e5 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\n\n@@ -31,10 +31,10 @@ public class AccessLogFirstLine extends AccessLogData {\n         String requestVersion = null;\n \n         if (request != null) {\n-            requestMethod = (request == null) ? null : request.getMethod();\n-            requestURI = (request == null) ? null : request.getRequestURI();\n-            requestQueryString = (request == null) ? null : request.getQueryString();\n-            requestVersion = (request == null) ? null : request.getVersion();\n+            requestMethod = request.getMethod();\n+            requestURI = request.getRequestURI();\n+            requestQueryString = request.getQueryString();\n+            requestVersion = request.getVersion();\n         }\n \n         logSafe(accessLogEntry, requestMethod);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0MzY3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414743677", "bodyText": "line 66 ensures request != null", "author": "donbourne", "createdAt": "2020-04-24T17:30:08Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java", "diffHunk": "@@ -51,4 +51,26 @@ public boolean set(StringBuilder accessLogEntry,\n \n         return true;\n     }\n+\n+    public static String getFirstLineAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        if (request != null) {\n+            StringBuilder sb = new StringBuilder();\n+            String requestMethod = (request == null) ? null : request.getMethod();\n+            String requestURI = (request == null) ? null : request.getRequestURI();\n+            String requestQueryString = (request == null) ? null : request.getQueryString();\n+            String requestVersion = (request == null) ? null : request.getVersion();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\nindex 5681e82ba4..64744d72e5 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogFirstLine.java\n\n@@ -55,10 +55,10 @@ public class AccessLogFirstLine extends AccessLogData {\n     public static String getFirstLineAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n         if (request != null) {\n             StringBuilder sb = new StringBuilder();\n-            String requestMethod = (request == null) ? null : request.getMethod();\n-            String requestURI = (request == null) ? null : request.getRequestURI();\n-            String requestQueryString = (request == null) ? null : request.getQueryString();\n-            String requestVersion = (request == null) ? null : request.getVersion();\n+            String requestMethod = request.getMethod();\n+            String requestURI = request.getRequestURI();\n+            String requestQueryString = request.getQueryString();\n+            String requestVersion = request.getVersion();\n             sb.append(requestMethod);\n             sb.append(\" \");\n             sb.append(requestURI);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc0ODM3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414748371", "bodyText": "for each of these com.ibm.ws.http.channel.internal.values should we should standardize on a set of methods?  it looks like we may have need for\n\nget the value for the access log\nget the value for the JSON log", "author": "donbourne", "createdAt": "2020-04-24T17:38:02Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogRemoteIP.java", "diffHunk": "@@ -27,6 +27,17 @@ public AccessLogRemoteIP() {\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request,\n                        Object data) {\n+        String hostIPAddress = getRemoteIP(response, request, data);\n+\n+        if (hostIPAddress != null) {\n+            accessLogEntry.append(hostIPAddress);\n+        } else {\n+            accessLogEntry.append(\"-\");\n+        }\n+        return true;\n+    }\n+\n+    public static String getRemoteIP(HttpResponseMessage response, HttpRequestMessage request, Object data) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MDUyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414770529", "bodyText": "want time to match between access log and json log", "author": "donbourne", "createdAt": "2020-04-24T18:14:39Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java", "diffHunk": "@@ -57,4 +57,17 @@ public static long getStartTime(HttpResponseMessage response, HttpRequestMessage\n         return startTime;\n     }\n \n+    public static String getStartTimeAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        StringBuilder requestStartTime = new StringBuilder();\n+        long startTime = getStartTime(response, request, data);\n+        if (startTime != 0) {\n+            Date startDate = new Date(startTime);\n+            requestStartTime.append(\"[\");\n+            requestStartTime.append(HttpDispatcher.getDateFormatter().getNCSATime(startDate));", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java\nindex 7f62672278..cd0277e7cf 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java\n\n@@ -57,17 +60,7 @@ public class AccessLogStartTime extends AccessLogData {\n         return startTime;\n     }\n \n-    public static String getStartTimeAsString(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n-        StringBuilder requestStartTime = new StringBuilder();\n-        long startTime = getStartTime(response, request, data);\n-        if (startTime != 0) {\n-            Date startDate = new Date(startTime);\n-            requestStartTime.append(\"[\");\n-            requestStartTime.append(HttpDispatcher.getDateFormatter().getNCSATime(startDate));\n-            requestStartTime.append(\"]\");\n-            return requestStartTime.toString();\n-        }\n-        // If we couldn't get the start time, just return null to not have the field show up in the JSON logs\n-        return null;\n+    public static String getStartTimeAsStringForJSON(HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        return startTimeFormatted.get();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc3MjE2Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414772166", "bodyText": "This appears to be part of our already published SPI -- can't change it", "author": "donbourne", "createdAt": "2020-04-24T18:17:28Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/wsspi/http/logging/AccessLogForwarder.java", "diffHunk": "@@ -10,9 +10,17 @@\n  *******************************************************************************/\n package com.ibm.wsspi.http.logging;\n \n+import com.ibm.ws.http.logging.internal.AccessLogger.FormatSegment;\n+\n /**\n  * The Access log forwarder is invoked after each http request.\n  */\n public interface AccessLogForwarder {\n-    public void process(AccessLogRecordData logData);\n+    /**\n+     *\n+     * @param logData\n+     * @param parsedFormat A parsed version of logFormat\n+     * @param formatString The original logFormat string\n+     */\n+    public void process(AccessLogRecordData logData, FormatSegment[] parsedFormat, String formatString);", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/wsspi/http/logging/AccessLogForwarder.java b/dev/com.ibm.ws.transport.http/src/com/ibm/wsspi/http/logging/AccessLogForwarder.java\nindex 237255a235..4c6429c38a 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/wsspi/http/logging/AccessLogForwarder.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/wsspi/http/logging/AccessLogForwarder.java\n\n@@ -10,8 +10,6 @@\n  *******************************************************************************/\n package com.ibm.wsspi.http.logging;\n \n-import com.ibm.ws.http.logging.internal.AccessLogger.FormatSegment;\n-\n /**\n  * The Access log forwarder is invoked after each http request.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyODMxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414828313", "bodyText": "would help to put \"config\" somewhere in these names to make that more obvious when reading the code", "author": "donbourne", "createdAt": "2020-04-24T19:58:43Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNDI4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414834282", "bodyText": "need a comment here to indicate what each of these 4 formatters represents", "author": "donbourne", "createdAt": "2020-04-24T20:10:12Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzNjA3MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414836070", "bodyText": "we probably need a ConcurrentHashMap<logFormat, SetterFormatter>.  that way, when a request comes in we can pick the SetterFormatter appropriate to the HTTP endpoint that is processing it.  that would technically be an very very tiny memory leak (since we have no way to clean it up) -- but it's too small to worry about.", "author": "donbourne", "createdAt": "2020-04-24T20:13:46Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MTI1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414841251", "bodyText": "include comments to show what you expect for the values of these fields", "author": "donbourne", "createdAt": "2020-04-24T20:23:54Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzE2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414843165", "bodyText": "add a comment to indicate that the returned setters should not be modified to avoid concurrency issues with other threads using the same setter list", "author": "donbourne", "createdAt": "2020-04-24T20:27:16Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+\n+        private SetterFormatter() {\n+            this.logFormat = \"\";\n+            this.loggingConfig = \"\";\n+            this.logstashConfig = \"\";\n+        }\n+\n+        void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n+            this.setters = setters;\n+            this.formatters = formatters;\n+        }\n+\n+        List<AccessLogDataFieldSetter> getSetters() {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0MzI3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414843271", "bodyText": "add a comment to indicate that the returned formatters should not be modified to avoid concurrency issues with other threads using the same formatter list", "author": "donbourne", "createdAt": "2020-04-24T20:27:31Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+\n+        private SetterFormatter() {\n+            this.logFormat = \"\";\n+            this.loggingConfig = \"\";\n+            this.logstashConfig = \"\";\n+        }\n+\n+        void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n+            this.setters = setters;\n+            this.formatters = formatters;\n+        }\n+\n+        List<AccessLogDataFieldSetter> getSetters() {\n+            return this.setters;\n+        }\n+\n+        AccessLogDataFormatter[] getFormatters() {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0Mzg3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414843872", "bodyText": "suggest you delete this method and instead require these strings on the constructor.  avoids having to worry about someone trying to mutate this class after it's created.", "author": "donbourne", "createdAt": "2020-04-24T20:28:42Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -34,6 +55,50 @@\n     private final String sourceName = \"com.ibm.ws.http.logging.source.accesslog\";\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n+    public static final int MAX_USER_AGENT_LENGTH = 2048;\n+    private SetterFormatter currentSF = new SetterFormatter();\n+    public String jsonAccessLogFields = \"\";\n+    public static String jsonAccessLogFieldsLogstash = \"\";\n+    public Map<String, Object> configuration;\n+\n+    private static class SetterFormatter {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+        List<AccessLogDataFieldSetter> setters;\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+\n+        private SetterFormatter() {\n+            this.logFormat = \"\";\n+            this.loggingConfig = \"\";\n+            this.logstashConfig = \"\";\n+        }\n+\n+        void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n+            this.setters = setters;\n+            this.formatters = formatters;\n+        }\n+\n+        List<AccessLogDataFieldSetter> getSetters() {\n+            return this.setters;\n+        }\n+\n+        AccessLogDataFormatter[] getFormatters() {\n+            return this.formatters;\n+        }\n+\n+        boolean checkConfigChange(String logFormat, String loggingConfig, String logstashConfig) {\n+            if (!logFormat.equals(this.logFormat) || !loggingConfig.equals(this.loggingConfig) || !logstashConfig.equals(this.logstashConfig))\n+                return true;\n+            return false;\n+        }\n+\n+        void setFullConfig(String logFormat, String loggingConfig, String logstashConfig) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -56,22 +59,75 @@ public class AccessLogSource implements Source {\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    public static String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n-    private static class SetterFormatter {\n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n-        List<AccessLogDataFieldSetter> setters;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode and equals\n+        @Override\n+        public int hashCode() {\n+            final int prime = 31;\n+            int result = 1;\n+            result = prime * result + getEnclosingInstance().hashCode();\n+            result = prime * result + ((logFormat == null) ? 0 : logFormat.hashCode());\n+            result = prime * result + ((loggingConfig == null) ? 0 : loggingConfig.hashCode());\n+            result = prime * result + ((logstashConfig == null) ? 0 : logstashConfig.hashCode());\n+            return result;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration other = (Configuration) obj;\n+            if (!getEnclosingInstance().equals(other.getEnclosingInstance()))\n+                return false;\n+            if (!other.getLogFormat().equals(this.logFormat) || !other.getLoggingConfig().equals(this.loggingConfig) || !other.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+\n+        private AccessLogSource getEnclosingInstance() {\n+            return AccessLogSource.this;\n+        }\n+    }\n+\n+    private static class SetterFormatter {\n+        // An object that contains the values of logFormat, JSON logging config, and logstash config\n+        Configuration config;\n+        // List of formatters for each type of logging format; null if not applicable to current configuration\n+        // { <default JSON logging>, <logFormat JSON logging>, <default logstashCollector>, <logFormat logstashCollector> }\n         AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        List<AccessLogDataFieldSetter> setters;\n \n-        private SetterFormatter() {\n-            this.logFormat = \"\";\n-            this.loggingConfig = \"\";\n-            this.logstashConfig = \"\";\n+        private SetterFormatter(Configuration config) {\n+            this.config = config;\n         }\n \n         void setSettersAndFormatters(List<AccessLogDataFieldSetter> setters, AccessLogDataFormatter[] formatters) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwNzM3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414907372", "bodyText": "make private?", "author": "donbourne", "createdAt": "2020-04-24T22:57:26Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -164,7 +210,7 @@ public class AccessLogSource implements Source {\n         accessLogHandler = null;\n     }\n \n-    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+    private static void addDefaultFields(Map<String, HashSet<Object>> map) {\n         String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n         for (String s : defaultFields) {\n             map.put(s, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwODc0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414908741", "bodyText": "make private?", "author": "donbourne", "createdAt": "2020-04-24T23:01:17Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -164,7 +210,7 @@ public class AccessLogSource implements Source {\n         accessLogHandler = null;\n     }\n \n-    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+    private static void addDefaultFields(Map<String, HashSet<Object>> map) {\n         String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n         for (String s : defaultFields) {\n             map.put(s, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMjEzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414912138", "bodyText": "put a comment above this line to call out why you are taking a copy of the reference (so that we don't forget in future)", "author": "donbourne", "createdAt": "2020-04-24T23:11:58Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {\n+\n+        ArrayList<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        for (String f : fields.keySet()) {\n+            switch (f) {\n+                //@formatter:off\n+                case \"%h\": fieldSetters.add((ald, alrd) -> ald.setRemoteHost(alrd.getRemoteAddress())); break;\n+                case \"%H\": fieldSetters.add((ald, alrd) -> ald.setRequestProtocol(alrd.getVersion())); break;\n+                case \"%A\": fieldSetters.add((ald, alrd) -> ald.setRequestHost(alrd.getLocalIP())); break;\n+                case \"%B\": fieldSetters.add((ald, alrd) -> ald.setBytesReceived(alrd.getBytesWritten())); break;\n+                case \"%m\": fieldSetters.add((ald, alrd) -> ald.setRequestMethod(alrd.getRequest().getMethod())); break;\n+                case \"%p\": fieldSetters.add((ald, alrd) -> ald.setRequestPort(alrd.getLocalPort())); break;\n+                case \"%q\": fieldSetters.add((ald, alrd) -> ald.setQueryString(alrd.getRequest().getQueryString())); break;\n+                case \"%{R}W\": fieldSetters.add((ald, alrd) -> ald.setElapsedTime(alrd.getElapsedTime())); break;\n+                case \"%s\": fieldSetters.add((ald, alrd) -> ald.setResponseCode(alrd.getResponse().getStatusCodeAsInt())); break;\n+                case \"%U\": fieldSetters.add((ald, alrd) -> ald.setUriPath(alrd.getRequest().getRequestURI())); break;\n+                // New - access log only fields\n+                case \"%a\": fieldSetters.add((ald, alrd) -> ald.setRemoteIP(AccessLogRemoteIP.getRemoteIP(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%b\": fieldSetters.add((ald, alrd) -> ald.setBytesSent(AccessLogResponseSize.getResponseSizeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%C\":\n+                    if (fields.get(\"%C\") == null) {\n+                        fieldSetters.add((ald, alrd) -> AccessLogRequestCookie.getAllCookies(alrd.getResponse(), alrd.getRequest(), null)\n+                                                        .forEach(c -> ald.setCookies(c.getName(), c.getValue())));\n+                    } else {\n+                        for (Object data : fields.get(\"%C\")) {\n+                            fieldSetters.add((ald, alrd) -> {\n+                                HttpCookie c = AccessLogRequestCookie.getCookie(alrd.getResponse(), alrd.getRequest(), data);\n+                                if (c != null)\n+                                    ald.setCookies(c.getName(), c.getValue());\n+                            });\n+                        }\n+                    } break;\n+                case \"%D\": fieldSetters.add((ald, alrd) -> ald.setRequestElapsedTime(AccessLogElapsedTime.getElapsedTime(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%i\":\n+                    for (Object data : fields.get(\"%i\")) {\n+                        if (data.equals(USER_AGENT_HEADER))\n+                            fieldSetters.add((ald, alrd) -> ald.setUserAgent(alrd.getRequest().getHeader(USER_AGENT_HEADER).asString()));\n+                        else if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setRequestHeader((String) data, AccessLogRequestHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%o\":\n+                    for (Object data : fields.get(\"%o\")) {\n+                        if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setResponseHeader((String) data, AccessLogResponseHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%r\": fieldSetters.add((ald, alrd) -> ald.setRequestFirstLine(AccessLogFirstLine.getFirstLineAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%t\": fieldSetters.add((ald, alrd) -> ald.setRequestStartTime(AccessLogStartTime.getStartTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%{t}W\": fieldSetters.add((ald, alrd) -> ald.setAccessLogDatetime(AccessLogCurrentTime.getAccessLogCurrentTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%u\": fieldSetters.add((ald, alrd) -> ald.setRemoteUser(AccessLogRemoteUser.getRemoteUser(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                //@formatter:on\n+            }\n+        }\n+        return fieldSetters;\n+    }\n+\n+    AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, FormatSpecifier format) {\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+        boolean isFirstCookie = true;\n+        boolean isFirstRequestHeader = true;\n+        boolean isFirstResponseHeader = true;\n+        for (FormatSegment s : parsedFormat) {\n+            if (s.log != null) {\n+                switch (s.log.getName()) {\n+                    // Original - default fields\n+                    //@formatter:off\n+                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n+                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n+                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    // New - access log only fields\n+                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%C\":\n+                        if (isFirstCookie) {\n+                            formatter.add(addCookiesField(format));\n+                            isFirstCookie = false;\n+                        } break;\n+                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%i\":\n+                        if (s.data.equals(USER_AGENT_HEADER)) {\n+                            formatter.add(addUserAgentField(format));\n+                        } else if (isFirstRequestHeader) {\n+                            formatter.add(addRequestHeaderField(format));\n+                            isFirstRequestHeader = false;\n+                        } break;\n+                    case \"%o\":\n+                        if (isFirstResponseHeader) {\n+                            formatter.add(addResponseHeaderField(format));\n+                            isFirstResponseHeader = false;\n+                        } break;\n+                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    //@formatter:on\n+                }\n+            }\n+        }\n+        return formatter;\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n+\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+\n+        formatter = new AccessLogDataFormatter();\n+        // %h\n+        formatter.add(addRemoteHostField(format));\n+        // %H\n+        formatter.add(addRequestProtocolField(format));\n+        // %A\n+        formatter.add(addRequestHostField(format));\n+        // %B\n+        formatter.add(addBytesReceivedField(format));\n+        // %m\n+        formatter.add(addRequestMethodField(format));\n+        // %p\n+        formatter.add(addRequestPortField(format));\n+        // %q\n+        formatter.add(addQueryStringField(format));\n+        // %{R}W\n+        formatter.add(addElapsedTimeField(format));\n+        // %s\n+        formatter.add(addResponseCodeField(format));\n+        // %U\n+        formatter.add(addUriPathField(format));\n+        // User agent\n+        formatter.add(addUserAgentField(format));\n+        return formatter;\n+    }\n+\n     private class AccessLogHandler implements AccessLogForwarder {\n \n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void process(AccessLogRecordData recordData) {\n-            HttpRequestMessage request = recordData.getRequest();\n-            HttpResponseMessage response = recordData.getResponse();\n-\n-            if (request != null) {\n-\n-                AccessLogData accessLogData = new AccessLogData();\n-\n-                long requestStartTimeVal = recordData.getStartTime();\n-                accessLogData.setRequestStartTime(requestStartTimeVal);\n-                accessLogData.setUriPath(request.getRequestURI());\n-                accessLogData.setRequestMethod(request.getMethod());\n-                accessLogData.setQueryString(request.getQueryString());\n-                accessLogData.setRequestHost(recordData.getLocalIP());\n-                accessLogData.setRequestPort(recordData.getLocalPort());\n-                accessLogData.setRemoteHost(recordData.getRemoteAddress());\n-                accessLogData.setUserAgent(request.getHeader(USER_AGENT_HEADER).asString());\n-                accessLogData.setRequestProtocol(request.getVersion());\n-                accessLogData.setBytesReceived(recordData.getBytesWritten());\n-                accessLogData.setResponseCode(response.getStatusCodeAsInt());\n-                accessLogData.setElapsedTime(recordData.getElapsedTime());\n-                accessLogData.setDatetime(recordData.getTimestamp());\n-\n-                String sequenceVal = requestStartTimeVal + \"_\" + String.format(\"%013X\", seq.incrementAndGet());\n-                accessLogData.setSequence(sequenceVal);\n-\n-                accessLogData.setSourceName(sourceName);\n-\n-                bufferMgr.add(accessLogData);\n-\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n+\n+        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n+            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n+                SetterFormatter newSF = new SetterFormatter();\n+                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+                AccessLogDataFormatter[] formatters = { null, null, null, null };\n+                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+                // Create the mapping of fields to add:{<format key> : <data value/null>}\n+                // Prevents duplicates\n+                initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n+\n+                // Create setter list\n+                fieldSetters = populateSetters(fieldsToAdd);\n+                // These fields are always added\n+                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+                if (jsonAccessLogFields.equals(\"default\")) {\n+                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n+                }\n+                if (jsonAccessLogFields.equals(\"logFormat\")) {\n+                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n                 }\n+                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n+                }\n+                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+                }\n+\n+                newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+                currentSF = newSF;\n+\n+            }\n+            SetterFormatter temp = currentSF;", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -164,7 +210,7 @@ public class AccessLogSource implements Source {\n         accessLogHandler = null;\n     }\n \n-    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+    private static void addDefaultFields(Map<String, HashSet<Object>> map) {\n         String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n         for (String s : defaultFields) {\n             map.put(s, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMjgzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414912830", "bodyText": "put everything inside this if block into another method for initializing the SetterFormatter.  Since most of the time this block is skipped it will make it easier in future to learn/understand the code.", "author": "donbourne", "createdAt": "2020-04-24T23:14:05Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {\n+\n+        ArrayList<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        for (String f : fields.keySet()) {\n+            switch (f) {\n+                //@formatter:off\n+                case \"%h\": fieldSetters.add((ald, alrd) -> ald.setRemoteHost(alrd.getRemoteAddress())); break;\n+                case \"%H\": fieldSetters.add((ald, alrd) -> ald.setRequestProtocol(alrd.getVersion())); break;\n+                case \"%A\": fieldSetters.add((ald, alrd) -> ald.setRequestHost(alrd.getLocalIP())); break;\n+                case \"%B\": fieldSetters.add((ald, alrd) -> ald.setBytesReceived(alrd.getBytesWritten())); break;\n+                case \"%m\": fieldSetters.add((ald, alrd) -> ald.setRequestMethod(alrd.getRequest().getMethod())); break;\n+                case \"%p\": fieldSetters.add((ald, alrd) -> ald.setRequestPort(alrd.getLocalPort())); break;\n+                case \"%q\": fieldSetters.add((ald, alrd) -> ald.setQueryString(alrd.getRequest().getQueryString())); break;\n+                case \"%{R}W\": fieldSetters.add((ald, alrd) -> ald.setElapsedTime(alrd.getElapsedTime())); break;\n+                case \"%s\": fieldSetters.add((ald, alrd) -> ald.setResponseCode(alrd.getResponse().getStatusCodeAsInt())); break;\n+                case \"%U\": fieldSetters.add((ald, alrd) -> ald.setUriPath(alrd.getRequest().getRequestURI())); break;\n+                // New - access log only fields\n+                case \"%a\": fieldSetters.add((ald, alrd) -> ald.setRemoteIP(AccessLogRemoteIP.getRemoteIP(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%b\": fieldSetters.add((ald, alrd) -> ald.setBytesSent(AccessLogResponseSize.getResponseSizeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%C\":\n+                    if (fields.get(\"%C\") == null) {\n+                        fieldSetters.add((ald, alrd) -> AccessLogRequestCookie.getAllCookies(alrd.getResponse(), alrd.getRequest(), null)\n+                                                        .forEach(c -> ald.setCookies(c.getName(), c.getValue())));\n+                    } else {\n+                        for (Object data : fields.get(\"%C\")) {\n+                            fieldSetters.add((ald, alrd) -> {\n+                                HttpCookie c = AccessLogRequestCookie.getCookie(alrd.getResponse(), alrd.getRequest(), data);\n+                                if (c != null)\n+                                    ald.setCookies(c.getName(), c.getValue());\n+                            });\n+                        }\n+                    } break;\n+                case \"%D\": fieldSetters.add((ald, alrd) -> ald.setRequestElapsedTime(AccessLogElapsedTime.getElapsedTime(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%i\":\n+                    for (Object data : fields.get(\"%i\")) {\n+                        if (data.equals(USER_AGENT_HEADER))\n+                            fieldSetters.add((ald, alrd) -> ald.setUserAgent(alrd.getRequest().getHeader(USER_AGENT_HEADER).asString()));\n+                        else if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setRequestHeader((String) data, AccessLogRequestHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%o\":\n+                    for (Object data : fields.get(\"%o\")) {\n+                        if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setResponseHeader((String) data, AccessLogResponseHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%r\": fieldSetters.add((ald, alrd) -> ald.setRequestFirstLine(AccessLogFirstLine.getFirstLineAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%t\": fieldSetters.add((ald, alrd) -> ald.setRequestStartTime(AccessLogStartTime.getStartTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%{t}W\": fieldSetters.add((ald, alrd) -> ald.setAccessLogDatetime(AccessLogCurrentTime.getAccessLogCurrentTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%u\": fieldSetters.add((ald, alrd) -> ald.setRemoteUser(AccessLogRemoteUser.getRemoteUser(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                //@formatter:on\n+            }\n+        }\n+        return fieldSetters;\n+    }\n+\n+    AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, FormatSpecifier format) {\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+        boolean isFirstCookie = true;\n+        boolean isFirstRequestHeader = true;\n+        boolean isFirstResponseHeader = true;\n+        for (FormatSegment s : parsedFormat) {\n+            if (s.log != null) {\n+                switch (s.log.getName()) {\n+                    // Original - default fields\n+                    //@formatter:off\n+                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n+                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n+                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    // New - access log only fields\n+                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%C\":\n+                        if (isFirstCookie) {\n+                            formatter.add(addCookiesField(format));\n+                            isFirstCookie = false;\n+                        } break;\n+                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%i\":\n+                        if (s.data.equals(USER_AGENT_HEADER)) {\n+                            formatter.add(addUserAgentField(format));\n+                        } else if (isFirstRequestHeader) {\n+                            formatter.add(addRequestHeaderField(format));\n+                            isFirstRequestHeader = false;\n+                        } break;\n+                    case \"%o\":\n+                        if (isFirstResponseHeader) {\n+                            formatter.add(addResponseHeaderField(format));\n+                            isFirstResponseHeader = false;\n+                        } break;\n+                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    //@formatter:on\n+                }\n+            }\n+        }\n+        return formatter;\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n+\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+\n+        formatter = new AccessLogDataFormatter();\n+        // %h\n+        formatter.add(addRemoteHostField(format));\n+        // %H\n+        formatter.add(addRequestProtocolField(format));\n+        // %A\n+        formatter.add(addRequestHostField(format));\n+        // %B\n+        formatter.add(addBytesReceivedField(format));\n+        // %m\n+        formatter.add(addRequestMethodField(format));\n+        // %p\n+        formatter.add(addRequestPortField(format));\n+        // %q\n+        formatter.add(addQueryStringField(format));\n+        // %{R}W\n+        formatter.add(addElapsedTimeField(format));\n+        // %s\n+        formatter.add(addResponseCodeField(format));\n+        // %U\n+        formatter.add(addUriPathField(format));\n+        // User agent\n+        formatter.add(addUserAgentField(format));\n+        return formatter;\n+    }\n+\n     private class AccessLogHandler implements AccessLogForwarder {\n \n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void process(AccessLogRecordData recordData) {\n-            HttpRequestMessage request = recordData.getRequest();\n-            HttpResponseMessage response = recordData.getResponse();\n-\n-            if (request != null) {\n-\n-                AccessLogData accessLogData = new AccessLogData();\n-\n-                long requestStartTimeVal = recordData.getStartTime();\n-                accessLogData.setRequestStartTime(requestStartTimeVal);\n-                accessLogData.setUriPath(request.getRequestURI());\n-                accessLogData.setRequestMethod(request.getMethod());\n-                accessLogData.setQueryString(request.getQueryString());\n-                accessLogData.setRequestHost(recordData.getLocalIP());\n-                accessLogData.setRequestPort(recordData.getLocalPort());\n-                accessLogData.setRemoteHost(recordData.getRemoteAddress());\n-                accessLogData.setUserAgent(request.getHeader(USER_AGENT_HEADER).asString());\n-                accessLogData.setRequestProtocol(request.getVersion());\n-                accessLogData.setBytesReceived(recordData.getBytesWritten());\n-                accessLogData.setResponseCode(response.getStatusCodeAsInt());\n-                accessLogData.setElapsedTime(recordData.getElapsedTime());\n-                accessLogData.setDatetime(recordData.getTimestamp());\n-\n-                String sequenceVal = requestStartTimeVal + \"_\" + String.format(\"%013X\", seq.incrementAndGet());\n-                accessLogData.setSequence(sequenceVal);\n-\n-                accessLogData.setSourceName(sourceName);\n-\n-                bufferMgr.add(accessLogData);\n-\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n+\n+        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n+            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n+                SetterFormatter newSF = new SetterFormatter();", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -164,7 +210,7 @@ public class AccessLogSource implements Source {\n         accessLogHandler = null;\n     }\n \n-    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+    private static void addDefaultFields(Map<String, HashSet<Object>> map) {\n         String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n         for (String s : defaultFields) {\n             map.put(s, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxMzQ2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414913469", "bodyText": "put a comment above here to indicate that these are the field formatters", "author": "donbourne", "createdAt": "2020-04-24T23:16:05Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -99,46 +164,384 @@ private void stopSource() {\n         accessLogHandler = null;\n     }\n \n+    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+        String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n+        for (String s : defaultFields) {\n+            map.put(s, null);\n+        }\n+        // User-Agent is a default field that is a specific request header\n+        HashSet<Object> data = new HashSet<Object>();\n+        data.add(\"User-Agent\");\n+        map.put(\"%i\", data);\n+    }\n+\n+    void initializeFieldMap(Map<String, HashSet<Object>> map, FormatSegment[] parsedFormat) {\n+        if (jsonAccessLogFields.equals(\"default\") || jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+            addDefaultFields(map);\n+        }\n+        if (jsonAccessLogFields.equals(\"logFormat\") || jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+            for (FormatSegment s : parsedFormat) {\n+                if (s.log != null) {\n+                    // cookies and headers will require data\n+                    if (s.data != null) {\n+                        HashSet<Object> data = new HashSet<Object>();\n+                        if (map.containsKey(s.log.getName())) {\n+                            data = map.get(s.log.getName());\n+                        }\n+                        data.add(s.data);\n+                        map.put(s.log.getName(), data);\n+                    } else {\n+                        map.put(s.log.getName(), null);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    ArrayList<AccessLogDataFieldSetter> populateSetters(Map<String, HashSet<Object>> fields) {\n+\n+        ArrayList<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        for (String f : fields.keySet()) {\n+            switch (f) {\n+                //@formatter:off\n+                case \"%h\": fieldSetters.add((ald, alrd) -> ald.setRemoteHost(alrd.getRemoteAddress())); break;\n+                case \"%H\": fieldSetters.add((ald, alrd) -> ald.setRequestProtocol(alrd.getVersion())); break;\n+                case \"%A\": fieldSetters.add((ald, alrd) -> ald.setRequestHost(alrd.getLocalIP())); break;\n+                case \"%B\": fieldSetters.add((ald, alrd) -> ald.setBytesReceived(alrd.getBytesWritten())); break;\n+                case \"%m\": fieldSetters.add((ald, alrd) -> ald.setRequestMethod(alrd.getRequest().getMethod())); break;\n+                case \"%p\": fieldSetters.add((ald, alrd) -> ald.setRequestPort(alrd.getLocalPort())); break;\n+                case \"%q\": fieldSetters.add((ald, alrd) -> ald.setQueryString(alrd.getRequest().getQueryString())); break;\n+                case \"%{R}W\": fieldSetters.add((ald, alrd) -> ald.setElapsedTime(alrd.getElapsedTime())); break;\n+                case \"%s\": fieldSetters.add((ald, alrd) -> ald.setResponseCode(alrd.getResponse().getStatusCodeAsInt())); break;\n+                case \"%U\": fieldSetters.add((ald, alrd) -> ald.setUriPath(alrd.getRequest().getRequestURI())); break;\n+                // New - access log only fields\n+                case \"%a\": fieldSetters.add((ald, alrd) -> ald.setRemoteIP(AccessLogRemoteIP.getRemoteIP(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%b\": fieldSetters.add((ald, alrd) -> ald.setBytesSent(AccessLogResponseSize.getResponseSizeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%C\":\n+                    if (fields.get(\"%C\") == null) {\n+                        fieldSetters.add((ald, alrd) -> AccessLogRequestCookie.getAllCookies(alrd.getResponse(), alrd.getRequest(), null)\n+                                                        .forEach(c -> ald.setCookies(c.getName(), c.getValue())));\n+                    } else {\n+                        for (Object data : fields.get(\"%C\")) {\n+                            fieldSetters.add((ald, alrd) -> {\n+                                HttpCookie c = AccessLogRequestCookie.getCookie(alrd.getResponse(), alrd.getRequest(), data);\n+                                if (c != null)\n+                                    ald.setCookies(c.getName(), c.getValue());\n+                            });\n+                        }\n+                    } break;\n+                case \"%D\": fieldSetters.add((ald, alrd) -> ald.setRequestElapsedTime(AccessLogElapsedTime.getElapsedTime(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%i\":\n+                    for (Object data : fields.get(\"%i\")) {\n+                        if (data.equals(USER_AGENT_HEADER))\n+                            fieldSetters.add((ald, alrd) -> ald.setUserAgent(alrd.getRequest().getHeader(USER_AGENT_HEADER).asString()));\n+                        else if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setRequestHeader((String) data, AccessLogRequestHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%o\":\n+                    for (Object data : fields.get(\"%o\")) {\n+                        if (data != null)\n+                            fieldSetters.add((ald, alrd) -> ald.setResponseHeader((String) data, AccessLogResponseHeaderValue.getHeaderValue(alrd.getResponse(), alrd.getRequest(), data)));\n+                    } break;\n+                case \"%r\": fieldSetters.add((ald, alrd) -> ald.setRequestFirstLine(AccessLogFirstLine.getFirstLineAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%t\": fieldSetters.add((ald, alrd) -> ald.setRequestStartTime(AccessLogStartTime.getStartTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%{t}W\": fieldSetters.add((ald, alrd) -> ald.setAccessLogDatetime(AccessLogCurrentTime.getAccessLogCurrentTimeAsString(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                case \"%u\": fieldSetters.add((ald, alrd) -> ald.setRemoteUser(AccessLogRemoteUser.getRemoteUser(alrd.getResponse(), alrd.getRequest(), null))); break;\n+                //@formatter:on\n+            }\n+        }\n+        return fieldSetters;\n+    }\n+\n+    AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, FormatSpecifier format) {\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+        boolean isFirstCookie = true;\n+        boolean isFirstRequestHeader = true;\n+        boolean isFirstResponseHeader = true;\n+        for (FormatSegment s : parsedFormat) {\n+            if (s.log != null) {\n+                switch (s.log.getName()) {\n+                    // Original - default fields\n+                    //@formatter:off\n+                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n+                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n+                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    // New - access log only fields\n+                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%C\":\n+                        if (isFirstCookie) {\n+                            formatter.add(addCookiesField(format));\n+                            isFirstCookie = false;\n+                        } break;\n+                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%i\":\n+                        if (s.data.equals(USER_AGENT_HEADER)) {\n+                            formatter.add(addUserAgentField(format));\n+                        } else if (isFirstRequestHeader) {\n+                            formatter.add(addRequestHeaderField(format));\n+                            isFirstRequestHeader = false;\n+                        } break;\n+                    case \"%o\":\n+                        if (isFirstResponseHeader) {\n+                            formatter.add(addResponseHeaderField(format));\n+                            isFirstResponseHeader = false;\n+                        } break;\n+                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    //@formatter:on\n+                }\n+            }\n+        }\n+        return formatter;\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n+\n+        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n+\n+        formatter = new AccessLogDataFormatter();\n+        // %h\n+        formatter.add(addRemoteHostField(format));\n+        // %H\n+        formatter.add(addRequestProtocolField(format));\n+        // %A\n+        formatter.add(addRequestHostField(format));\n+        // %B\n+        formatter.add(addBytesReceivedField(format));\n+        // %m\n+        formatter.add(addRequestMethodField(format));\n+        // %p\n+        formatter.add(addRequestPortField(format));\n+        // %q\n+        formatter.add(addQueryStringField(format));\n+        // %{R}W\n+        formatter.add(addElapsedTimeField(format));\n+        // %s\n+        formatter.add(addResponseCodeField(format));\n+        // %U\n+        formatter.add(addUriPathField(format));\n+        // User agent\n+        formatter.add(addUserAgentField(format));\n+        return formatter;\n+    }\n+\n     private class AccessLogHandler implements AccessLogForwarder {\n \n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-        public void process(AccessLogRecordData recordData) {\n-            HttpRequestMessage request = recordData.getRequest();\n-            HttpResponseMessage response = recordData.getResponse();\n-\n-            if (request != null) {\n-\n-                AccessLogData accessLogData = new AccessLogData();\n-\n-                long requestStartTimeVal = recordData.getStartTime();\n-                accessLogData.setRequestStartTime(requestStartTimeVal);\n-                accessLogData.setUriPath(request.getRequestURI());\n-                accessLogData.setRequestMethod(request.getMethod());\n-                accessLogData.setQueryString(request.getQueryString());\n-                accessLogData.setRequestHost(recordData.getLocalIP());\n-                accessLogData.setRequestPort(recordData.getLocalPort());\n-                accessLogData.setRemoteHost(recordData.getRemoteAddress());\n-                accessLogData.setUserAgent(request.getHeader(USER_AGENT_HEADER).asString());\n-                accessLogData.setRequestProtocol(request.getVersion());\n-                accessLogData.setBytesReceived(recordData.getBytesWritten());\n-                accessLogData.setResponseCode(response.getStatusCodeAsInt());\n-                accessLogData.setElapsedTime(recordData.getElapsedTime());\n-                accessLogData.setDatetime(recordData.getTimestamp());\n-\n-                String sequenceVal = requestStartTimeVal + \"_\" + String.format(\"%013X\", seq.incrementAndGet());\n-                accessLogData.setSequence(sequenceVal);\n-\n-                accessLogData.setSourceName(sourceName);\n-\n-                bufferMgr.add(accessLogData);\n-\n-                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-                    Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n+\n+        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n+            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n+                SetterFormatter newSF = new SetterFormatter();\n+                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+                AccessLogDataFormatter[] formatters = { null, null, null, null };\n+                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+                // Create the mapping of fields to add:{<format key> : <data value/null>}\n+                // Prevents duplicates\n+                initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n+\n+                // Create setter list\n+                fieldSetters = populateSetters(fieldsToAdd);\n+                // These fields are always added\n+                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+                if (jsonAccessLogFields.equals(\"default\")) {\n+                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n+                }\n+                if (jsonAccessLogFields.equals(\"logFormat\")) {\n+                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n                 }\n+                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n+                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n+                }\n+                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n+                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+                }\n+\n+                newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+                currentSF = newSF;\n+\n+            }\n+            SetterFormatter temp = currentSF;\n+            AccessLogData accessLogData = new AccessLogData();\n+            for (AccessLogDataFieldSetter s : temp.getSetters()) {\n+                s.add(accessLogData, recordData);\n+            }\n+\n+            accessLogData.addFormatters(temp.getFormatters());\n+            // collectorJSONUtils does the rest of the work from here\n+\n+            accessLogData.setSourceName(sourceName);\n+\n+            bufferMgr.add(accessLogData);\n+\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Added a event to buffer \" + accessLogData);\n             }\n         }\n     }\n+\n+    private static JsonFieldAdder addRemoteHostField(FormatSpecifier format) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex d356749c2e..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -164,7 +210,7 @@ public class AccessLogSource implements Source {\n         accessLogHandler = null;\n     }\n \n-    void addDefaultFields(Map<String, HashSet<Object>> map) {\n+    private static void addDefaultFields(Map<String, HashSet<Object>> map) {\n         String[] defaultFields = { \"%h\", \"%H\", \"%A\", \"%B\", \"%m\", \"%p\", \"%q\", \"%{R}W\", \"%s\", \"%U\" };\n         for (String s : defaultFields) {\n             map.put(s, null);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxOTUxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414919512", "bodyText": "a few other suggested tests\n\nchanging access log format while server is running\ndisabling access log while server is running\nenabling access log while server is running\n2 http endpoints, each with different access log format settings\na server with tokens in access log format that are invalid\na server with tokens in access log format that are repeated\n\nadd trace to the initialization of SetterFormatters and add a test to make sure that initialization only happens twice with 2 HTTP endpoints, each with different access log format settings", "author": "donbourne", "createdAt": "2020-04-24T23:36:49Z", "path": "dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.fat;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.impl.LibertyServerFactory;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class CustomAccessLogFieldsTest {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java b/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java\nindex 8410e2b616..ab7e2383fd 100644\n--- a/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java\n+++ b/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java\n\n@@ -143,13 +143,13 @@ public class CustomAccessLogFieldsTest {\n \n     @Test\n     public void testRenameAccessLogField() throws Exception {\n-        // rename header, cookie\n+        // rename header, cookie <-- doesnt work yet\n         // rename broadly\n     }\n \n     @Test\n     public void testOmitAccessLogField() throws Exception {\n-        // omit specific header, cookie\n+        // omit specific header, cookie <-- doesnt work yet\n         // omit broadly\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkyMjAwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r414922007", "bodyText": "need to also have checks to show that json only includes the expected fields (no unexpected fields)", "author": "donbourne", "createdAt": "2020-04-24T23:45:41Z", "path": "dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ *     IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.logging.fat;\n+\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.ProtocolException;\n+import java.net.URL;\n+import java.util.List;\n+\n+import org.junit.After;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import componenttest.annotation.Server;\n+import componenttest.custom.junit.runner.FATRunner;\n+import componenttest.topology.impl.LibertyServer;\n+import componenttest.topology.impl.LibertyServerFactory;\n+import componenttest.topology.utils.HttpUtils;\n+\n+/**\n+ *\n+ */\n+@RunWith(FATRunner.class)\n+public class CustomAccessLogFieldsTest {\n+    private static final String MESSAGE_LOG = \"logs/messages.log\";\n+\n+    @Server(\"CustomAccessLogFieldsEnv\")\n+    public static LibertyServer envServer;\n+\n+    @Server(\"CustomAccessLogFieldsBootstrap\")\n+    public static LibertyServer bootstrapServer;\n+\n+    @Server(\"CustomAccessLogFieldsXml\")\n+    public static LibertyServer xmlServer;\n+\n+    @Server(\"CustomAccessLogFieldsBadConfig\")\n+    public static LibertyServer badConfigServer;\n+\n+    private static final String SERVER_NAME_ENV = \"CustomAccessLogFieldsEnv\";\n+    private static final String SERVER_NAME_BOOTSTRAP = \"CustomAccessLogFieldsBootstrap\";\n+    private static final String SERVER_NAME_XML = \"CustomAccessLogFieldsXml\";\n+    private static final String SERVER_NAME_BAD_CONFIG = \"CustomAccessLogFieldsBadConfig\";\n+\n+    // variable naming convention?\n+    private final String[] newFields = { \"ibm_remoteIP\", \"ibm_bytesSent\", \"ibm_cookie\", \"ibm_requestElapsedTime\", \"ibm_requestHeader\",\n+                                         \"ibm_responseHeader\", \"ibm_requestFirstLine\", \"ibm_requestStartTime\", \"ibm_accessLogDatetime\", \"ibm_remoteUserID\" };\n+\n+    private static LibertyServer serverInUse; // hold on to the server currently used so cleanUp knows which server to stop\n+\n+    @BeforeClass\n+    public static void initialSetup() throws Exception {\n+        envServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_ENV);\n+        bootstrapServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_BOOTSTRAP);\n+        xmlServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_XML);\n+        badConfigServer = LibertyServerFactory.getLibertyServer(SERVER_NAME_BAD_CONFIG);\n+\n+        // Preserve the original server configuration\n+        envServer.saveServerConfiguration();\n+        bootstrapServer.saveServerConfiguration();\n+        xmlServer.saveServerConfiguration();\n+        badConfigServer.saveServerConfiguration();\n+    }\n+\n+    public void setUp(LibertyServer server) throws Exception {\n+        serverInUse = server;\n+        if (server != null && !server.isStarted()) {\n+            // Restore the original server configuration, before starting the server for each test case.\n+            server.restoreServerConfiguration();\n+            server.startServer();\n+        }\n+    }\n+\n+    @After\n+    public void cleanUp() throws Exception {\n+        if (serverInUse != null && serverInUse.isStarted()) {\n+            serverInUse.stopServer(\"com.ibm.ws.logging.fat.ffdc.servlet.FFDCServlet.doGet\", \"ArithmeticException\",\n+                                   \"CWWKG0081E\", \"CWWKG0083W\");\n+        }\n+    }\n+\n+    /*\n+     * This test sets the \"WLP_ENABLE_CUSTOM_ACCESS_LOG_FIELDS\" attribute in the server.env and verifies the property in the messages.log file.\n+     */\n+    @Test\n+    public void testAccessLogFieldNamesEnv() throws Exception {\n+        setUp(envServer);\n+        hitWebPage(\"\", \"\", envServer);\n+        List<String> lines = envServer.findStringsInFileInLibertyServerRoot(\"liberty_accesslog\", MESSAGE_LOG);\n+        System.out.println(lines.get(0));\n+\n+        assertTrue(\"There are fields missing in the output JSON log.\", areAllFieldsPresent(lines));\n+    }\n+\n+    /*\n+     * This test sets the \"WLP_ENABLE_CUSTOM_ACCESS_LOG_FIELDS\" attribute in the server.env and verifies the property in the messages.log file.\n+     */\n+    @Test\n+    public void testAccessLogFieldNamesBootstrap() throws Exception {\n+        setUp(bootstrapServer);\n+        hitWebPage(\"\", \"\", bootstrapServer);\n+        List<String> lines = bootstrapServer.findStringsInFileInLibertyServerRoot(\"liberty_accesslog\", MESSAGE_LOG);\n+        System.out.println(lines.get(0));\n+\n+        assertTrue(\"There are fields missing in the output JSON log.\", areAllFieldsPresent(lines));\n+    }\n+\n+    /*\n+     * This test sets the \"WLP_ENABLE_CUSTOM_ACCESS_LOG_FIELDS\" attribute in the server.env and verifies the property in the messages.log file.\n+     */\n+    @Test\n+    public void testAccessLogFieldNamesXml() throws Exception {\n+        setUp(xmlServer);\n+        hitWebPage(\"\", \"\", xmlServer);\n+        List<String> lines = xmlServer.findStringsInFileInLibertyServerRoot(\"liberty_accesslog\", MESSAGE_LOG);\n+        System.out.println(lines.get(0));\n+\n+        assertTrue(\"There are fields missing in the output JSON log.\", areAllFieldsPresent(lines));\n+    }\n+\n+    @Test\n+    public void testAccessLogFaultyConfig() throws Exception {\n+        // Should we have 3 tests to test each version? Can one test stop and start server 3x?\n+        setUp(badConfigServer);\n+        List<String> lines = badConfigServer.findStringsInFileInLibertyServerRoot(\"TRAS3012W\", MESSAGE_LOG);\n+\n+        assertNotNull(\"The error message was not sent with a bad configuration.\", lines);\n+    }\n+\n+    @Test\n+    public void testRenameAccessLogField() throws Exception {\n+        // rename header, cookie\n+        // rename broadly\n+    }\n+\n+    @Test\n+    public void testOmitAccessLogField() throws Exception {\n+        // omit specific header, cookie\n+        // omit broadly\n+    }\n+\n+    @Test\n+    public void testNullValuesDontPrintInJSON() throws Exception {\n+        // in the access log, it'll print `-` but in the JSON log it shouldn't print at all\n+        // test w/ header, cookie\n+    }\n+\n+    @Test\n+    public void testFieldsInAccessLogAreSameInJSON() throws Exception {\n+        // test that the fields in the access log print the same value in the JSON logs\n+    }\n+\n+    @Test\n+    public void testOnlyUnchangingField() throws Exception {\n+        // test that specifying `= logFormat` doesn't print out the original set of fields unless specified\n+        // %h %H %A %B %m %p %q %R{W} %s %U <- should not be printed out\n+    }\n+\n+    public boolean areAllFieldsPresent(List<String> lines) {", "originalCommit": "79c64cce36d3728074f3fe518dc7d603795883e3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java b/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java\nindex 8410e2b616..ab7e2383fd 100644\n--- a/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java\n+++ b/dev/com.ibm.ws.logging_fat/fat/src/com/ibm/ws/logging/fat/CustomAccessLogFieldsTest.java\n\n@@ -143,13 +143,13 @@ public class CustomAccessLogFieldsTest {\n \n     @Test\n     public void testRenameAccessLogField() throws Exception {\n-        // rename header, cookie\n+        // rename header, cookie <-- doesnt work yet\n         // rename broadly\n     }\n \n     @Test\n     public void testOmitAccessLogField() throws Exception {\n-        // omit specific header, cookie\n+        // omit specific header, cookie <-- doesnt work yet\n         // omit broadly\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcyMjUzMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418722530", "bodyText": "instead of not having the same optimization for logstashCollector, would be better to have a separate startAccessLogLogstashCollector string that would hold the cached starting fields for LC", "author": "donbourne", "createdAt": "2020-05-01T20:25:31Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -386,37 +385,26 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, FormatSpecifier fs) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n \n-        if (tempStartFields != null) {\n+        if (tempStartFields != null && format == AccessLogData.KEYS_JSON) {\n+            // Only applies for JSON fields, or else we'd print the wrong fields for Logstash Collector", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex c9889be46a..924602913f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -388,10 +397,14 @@ public class CollectorJsonHelpers {\n     protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n+        String tempStartFieldsLogstash = startAccessLogLogstashCollector;\n \n-        if (tempStartFields != null && format == AccessLogData.KEYS_JSON) {\n-            // Only applies for JSON fields, or else we'd print the wrong fields for Logstash Collector\n-            jsonBuilder.addPreformatted(tempStartFields);\n+        if (tempStartFields != null) {\n+            if (format == AccessLogData.KEYS_JSON)\n+                jsonBuilder.addPreformatted(tempStartFields);\n+        } else if (tempStartFieldsLogstash != null) {\n+            if (format == AccessLogData.KEYS_LOGSTASH)\n+                jsonBuilder.addPreformatted(tempStartFieldsLogstash);\n         } else {\n             //@formatter:off\n             jsonBuilder.addField(AccessLogData.getTypeKey(format), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0MTE0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418741145", "bodyText": "should probably have a final else condition on this that throws a RuntimeException indicating that there was no formatter for the event.  be sure to test that code path so that you know where this RuntimeException gets caught and doesn't break anything.", "author": "donbourne", "createdAt": "2020-05-01T21:15:19Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java", "diffHunk": "@@ -218,24 +217,17 @@ private static String jsonifyAccess(String wlpUserDir,\n                                         String serverName, String hostName, Object event, String[] tags) {\n \n         AccessLogData accessLogData = (AccessLogData) event;\n-        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFieldsLogstash(hostName, wlpUserDir, serverName, FormatSpecifier.LOGSTASH);\n+        JSONObjectBuilder jsonBuilder = CollectorJsonHelpers.startAccessLogJsonFields(hostName, wlpUserDir, serverName, AccessLogData.KEYS_LOGSTASH);\n \n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n+        // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n         if (formatters[3] != null) {\n             formatters[3].populate(jsonBuilder, accessLogData);\n-        }\n-\n-        if (formatters[2] != null) {\n+        } else if (formatters[2] != null) {", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\nindex 0a5331f6d0..90a03cea9a 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonUtils.java\n\n@@ -222,11 +222,12 @@ public class CollectorJsonUtils {\n         AccessLogDataFormatter[] formatters = accessLogData.getFormatters();\n \n         // Only one of these will not be null - there is only one formatter per event. If both are not null, we made a mistake earlier in AccessLogSource\n-        if (formatters[3] != null) {\n+        if (formatters[3] != null)\n             formatters[3].populate(jsonBuilder, accessLogData);\n-        } else if (formatters[2] != null) {\n+        else if (formatters[2] != null)\n             formatters[2].populate(jsonBuilder, accessLogData);\n-        }\n+        else\n+            throw new RuntimeException(\"There is no formatter available for this event.\");\n \n         if (tags != null) {\n             jsonBuilder.addPreformattedField(\"tags\", CollectorJsonHelpers.jsonifyTags(tags));\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0NDE0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r418744141", "bodyText": "A bit unclear...suggest...\nWe only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field", "author": "donbourne", "createdAt": "2020-05-01T21:23:47Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java", "diffHunk": "@@ -136,342 +141,116 @@ private void setPair(int index, long l) {\n         setPair(index, NAMES1_1[index], l);\n     }\n \n-    public void setRequestStartTime(String s) {\n-        setPair(0, s);\n-    }\n-\n-    public void setUriPath(String s) {\n-        setPair(1, s);\n-    }\n-\n-    public void setRequestMethod(String s) {\n-        setPair(2, s);\n-    }\n-\n-    public void setQueryString(String s) {\n-        setPair(3, s);\n-    }\n-\n-    public void setRequestHost(String s) {\n-        setPair(4, s);\n-    }\n-\n-    public void setRequestPort(String s) {\n-        setPair(5, s);\n-    }\n-\n-    public void setRemoteHost(String s) {\n-        setPair(6, s);\n-    }\n-\n-    public void setUserAgent(String s) {\n-        setPair(7, s);\n-    }\n-\n-    public void setRequestProtocol(String s) {\n-        setPair(8, s);\n-    }\n-\n-    public void setBytesReceived(long l) {\n-        setPair(9, l);\n-    }\n-\n-    public void setResponseCode(int i) {\n-        setPair(10, i);\n-    }\n-\n-    public void setElapsedTime(long l) {\n-        setPair(11, l);\n-    }\n-\n-    // Datetime also not part of logFormat\n-    public void setDatetime(long l) {\n-        setPair(12, l);\n-    }\n-\n-    // Sequence also not part of logFormat\n-    public void setSequence(String s) {\n-        setPair(13, s);\n+    private KeyValuePairList getValues(int index) {\n+        return (KeyValuePairList) getPairs()[index];\n     }\n \n+    // @formatter:off\n+    public void setRequestStartTime(String s)  { setPair(0, s); }\n+    public void setUriPath(String s)           { setPair(1, s); }\n+    public void setRequestMethod(String s)     { setPair(2, s); }\n+    public void setQueryString(String s)       { setPair(3, s); }\n+    public void setRequestHost(String s)       { setPair(4, s); }\n+    public void setRequestPort(String s)       { setPair(5, s); }\n+    public void setRemoteHost(String s)        { setPair(6, s); }\n+    public void setUserAgent(String s)         { setPair(7, s); }\n+    public void setRequestProtocol(String s)   { setPair(8, s); }\n+    public void setBytesReceived(long l)       { setPair(9, l); }\n+    public void setResponseCode(int i)         { setPair(10, i); }\n+    public void setElapsedTime(long l)         { setPair(11, l); }\n+    public void setDatetime(long l)            { setPair(12, l); }\n+    public void setSequence(String s)          { setPair(13, s); }\n     // New optional access log fields\n-    public void setRemoteIP(String s) {\n-        setPair(14, s);\n-    }\n-\n-    public void setBytesSent(String s) {\n-        setPair(15, s);\n-    }\n-\n+    public void setRemoteIP(String s)          { setPair(14, s); }\n+    public void setBytesSent(String s)         { setPair(15, s); }\n+    public void setRequestElapsedTime(long l)  { setPair(17, l); }\n+    public void setRequestFirstLine(String s)  { setPair(20, s); }\n+    public void setAccessLogDatetime(String s) { setPair(21, s); }\n+    public void setRemoteUser(String s)        { setPair(22, s); }\n     public void setCookies(String name, String value) {\n         kvplCookies.addKeyValuePair(name, value);\n         setPair(16, kvplCookies);\n     }\n-\n-    public void setRequestElapsedTime(long l) {\n-        setPair(17, l);\n-    }\n-\n     public void setRequestHeader(String name, String value) {\n         kvplRequestHeaders.addKeyValuePair(name, value);\n         setPair(18, kvplRequestHeaders);\n     }\n-\n     public void setResponseHeader(String name, String value) {\n         kvplResponseHeaders.addKeyValuePair(name, value);\n         setPair(19, kvplResponseHeaders);\n     }\n \n-    public void setRequestFirstLine(String s) {\n-        setPair(20, s);\n-    }\n-\n-    public void setAccessLogDatetime(String s) {\n-        setPair(21, s);\n-    }\n-\n-    public void setRemoteUser(String s) {\n-        setPair(22, s);\n-    }\n-\n-    public String getRequestStartTime() {\n-        return getStringValue(0);\n-    }\n-\n-    public String getUriPath() {\n-        return getStringValue(1);\n-    }\n-\n-    public String getRequestMethod() {\n-        return getStringValue(2);\n-    }\n-\n-    public String getQueryString() {\n-        return getStringValue(3);\n-    }\n-\n-    public String getRequestHost() {\n-        return getStringValue(4);\n-    }\n-\n-    public String getRequestPort() {\n-        return getStringValue(5);\n-    }\n-\n-    public String getRemoteHost() {\n-        return getStringValue(6);\n-    }\n-\n-    public String getUserAgent() {\n-        return getStringValue(7);\n-    }\n-\n-    public String getRequestProtocol() {\n-        return getStringValue(8);\n-    }\n-\n-    public long getBytesReceived() {\n-        try {\n-            return getLongValue(9);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public int getResponseCode() {\n-        try {\n-            return getIntValue(10);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getElapsedTime() {\n-        try {\n-            return getLongValue(11);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public long getDatetime() {\n-        try {\n-            return getLongValue(12);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public String getSequence() {\n-        return getStringValue(13);\n-    }\n-\n-    public String getRemoteIP() {\n-        return getStringValue(14);\n-    }\n-\n-    public String getBytesSent() {\n-        return getStringValue(15);\n-    }\n-\n-    public KeyValuePairList getCookies() {\n-        return getValues(16);\n-    }\n-\n-    public long getRequestElapsedTime() {\n-        try {\n-            return getLongValue(17);\n-        } catch (Exception e) {\n-            // Do nothing, the field hasn't been set in the logFormat\n-        }\n-        return -1;\n-    }\n-\n-    public KeyValuePairList getRequestHeaders() {\n-        return getValues(18);\n-    }\n-\n-    public KeyValuePairList getResponseHeaders() {\n-        return getValues(19);\n-    }\n-\n-    public String getRequestFirstLine() {\n-        return getStringValue(20);\n-    }\n-\n-    public String getAccessLogDatetime() {\n-        return getStringValue(21);\n-    }\n-\n-    public String getRemoteUser() {\n-        return getStringValue(22);\n-    }\n-\n-    private KeyValuePairList getValues(int index) {\n-        return (KeyValuePairList) getPairs()[index];\n-    }\n-\n-    public static String getRequestStartTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[0];\n-    }\n-\n-    public static String getUriPathKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[1];\n-    }\n-\n-    public static String getRequestMethodKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[2];\n-    }\n-\n-    public static String getQueryStringKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[3];\n-    }\n-\n-    public static String getRequestHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[4];\n-    }\n-\n-    public static String getRequestPortKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[5];\n-    }\n-\n-    public static String getRemoteHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[6];\n-    }\n-\n-    public static String getUserAgentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[7];\n-    }\n-\n-    public static String getRequestProtocolKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[8];\n-    }\n-\n-    public static String getBytesReceivedKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[9];\n-    }\n-\n-    public static String getResponseCodeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[10];\n-    }\n-\n-    public static String getElapsedTimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[11];\n-    }\n-\n-    public static String getDatetimeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[12];\n-    }\n-\n-    public static String getSequenceKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[13];\n-    }\n-\n-    public static String getHostKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[14];\n-    }\n-\n-    public static String getUserDirKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[15];\n-    }\n-\n-    public static String getServerNameKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[16];\n-    }\n-\n-    public static String getTypeKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[17];\n-    }\n-\n-    public static String getRemoteIPKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[18];\n-    }\n-\n-    public static String getBytesSentKey(FormatSpecifier format) {\n-        return nameAliases[format.getValue()].aliases[19];\n-    }\n-\n-    public static String getCookieKey(FormatSpecifier format, KeyValuePair kvp) {\n+    public String getRequestStartTime()          { return getStringValue(0); }\n+    public String getUriPath()                   { return getStringValue(1); }\n+    public String getRequestMethod()             { return getStringValue(2); }\n+    public String getQueryString()               { return getStringValue(3); }\n+    public String getRequestHost()               { return getStringValue(4); }\n+    public String getRequestPort()               { return getStringValue(5); }\n+    public String getRemoteHost()                { return getStringValue(6); }\n+    public String getUserAgent()                 { return getStringValue(7); }\n+    public String getRequestProtocol()           { return getStringValue(8); }\n+    public long getBytesReceived()               { return getLongValue(9); }\n+    public int getResponseCode()                 { return getIntValue(10); }\n+    public long getElapsedTime()                 { return getLongValue(11); }\n+    public long getDatetime()                    { return getLongValue(12); }\n+    public String getSequence()                  { return getStringValue(13); }\n+    public String getRemoteIP()                  { return getStringValue(14); }\n+    public String getBytesSent()                 { return getStringValue(15); }\n+    public KeyValuePairList getCookies()         { return getValues(16); }\n+    public long getRequestElapsedTime()          { return getLongValue(17); }\n+    public KeyValuePairList getRequestHeaders()  { return getValues(18); }\n+    public KeyValuePairList getResponseHeaders() { return getValues(19); }\n+    public String getRequestFirstLine()          { return getStringValue(20); }\n+    public String getAccessLogDatetime()         { return getStringValue(21); }\n+    public String getRemoteUser()                { return getStringValue(22); }\n+\n+    public static String getRequestStartTimeKey(int format)   { return nameAliases[format].aliases[0]; }\n+    public static String getUriPathKey(int format)            { return nameAliases[format].aliases[1]; }\n+    public static String getRequestMethodKey(int format)      { return nameAliases[format].aliases[2]; }\n+    public static String getQueryStringKey(int format)        { return nameAliases[format].aliases[3]; }\n+    public static String getRequestHostKey(int format)        { return nameAliases[format].aliases[4]; }\n+    public static String getRequestPortKey(int format)        { return nameAliases[format].aliases[5]; }\n+    public static String getRemoteHostKey(int format)         { return nameAliases[format].aliases[6]; }\n+    public static String getUserAgentKey(int format)          { return nameAliases[format].aliases[7]; }\n+    public static String getRequestProtocolKey(int format)    { return nameAliases[format].aliases[8]; }\n+    public static String getBytesReceivedKey(int format)      { return nameAliases[format].aliases[9]; }\n+    public static String getResponseCodeKey(int format)       { return nameAliases[format].aliases[10]; }\n+    public static String getElapsedTimeKey(int format)        { return nameAliases[format].aliases[11]; }\n+    public static String getDatetimeKey(int format)           { return nameAliases[format].aliases[12]; }\n+    public static String getSequenceKey(int format)           { return nameAliases[format].aliases[13]; }\n+    public static String getHostKey(int format)               { return nameAliases[format].aliases[14]; }\n+    public static String getUserDirKey(int format)            { return nameAliases[format].aliases[15]; }\n+    public static String getServerNameKey(int format)         { return nameAliases[format].aliases[16]; }\n+    public static String getTypeKey(int format)               { return nameAliases[format].aliases[17]; }\n+    public static String getRemoteIPKey(int format)           { return nameAliases[format].aliases[18]; }\n+    public static String getBytesSentKey(int format)          { return nameAliases[format].aliases[19]; }\n+    public static String getRequestElapsedTimeKey(int format) { return nameAliases[format].aliases[21]; }\n+    public static String getRequestFirstLineKey(int format)   { return nameAliases[format].aliases[24]; }\n+    public static String getAccessLogDatetimeKey(int format)  { return nameAliases[format].aliases[25]; }\n+    public static String getRemoteUserKey(int format)         { return nameAliases[format].aliases[26]; }\n+\n+    public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        if (cookieMap.containsKey(cookieName) && format.equals(\"JSON\")) {\n+        // We can only rename for JSON and not logstash collector, so check that it's JSON before renaming field", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\nindex 393b3f0f18..142d500831 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogData.java\n\n@@ -231,7 +231,7 @@ public class AccessLogData extends GenericData {\n \n     public static String getCookieKey(int format, KeyValuePair kvp) {\n         String cookieName = kvp.getKey();\n-        // We can only rename for JSON and not logstash collector, so check that it's JSON before renaming field\n+         // We only support renaming JSON fields, not logstashCollector fields - so check that it's JSON before renaming field\n         if (cookieMap.containsKey(cookieName) && (format == KEYS_JSON)) {\n             return cookieMap.get(cookieName);\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNjg4Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419136882", "bodyText": "compute \"[\" + currentTime + \"]\" once and use it in both cases above", "author": "donbourne", "createdAt": "2020-05-03T17:51:54Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java", "diffHunk": "@@ -38,9 +40,12 @@ public Object init(String rawToken) {\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request, Object data) {\n         if (data == null) {\n+            String currentTime = HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis()));\n             accessLogEntry.append(\"[\");\n-            accessLogEntry.append(HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis())));\n+            accessLogEntry.append(currentTime);\n             accessLogEntry.append(\"]\");\n+            accessLogDatetime.set(\"[\" + currentTime + \"]\");\n+", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\nindex c0c5cf9bd0..b3a487943a 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\n\n@@ -39,12 +40,12 @@ public class AccessLogCurrentTime extends AccessLogData {\n     @Override\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request, Object data) {\n+        // Should we just use \"getAccessLogCurrentTimeAsString\"? Will performance be impacted?\n         if (data == null) {\n             String currentTime = HttpDispatcher.getDateFormatter().getNCSATime(new Date(System.currentTimeMillis()));\n-            accessLogEntry.append(\"[\");\n-            accessLogEntry.append(currentTime);\n-            accessLogEntry.append(\"]\");\n-            accessLogDatetime.set(\"[\" + currentTime + \"]\");\n+            String currentTimeFormatted = \"[\" + currentTime + \"]\";\n+            accessLogEntry.append(currentTimeFormatted);\n+            accessLogDatetime.set(currentTimeFormatted);\n \n         } else {\n             // just print out what was there\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTEzNzI4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419137285", "bodyText": "add a comment above this line to state your assumption that the methods below that use this datetime will be called on the same thread", "author": "donbourne", "createdAt": "2020-05-03T17:55:54Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java", "diffHunk": "@@ -18,6 +18,8 @@\n \n public class AccessLogCurrentTime extends AccessLogData {\n \n+    public static ThreadLocal<String> accessLogDatetime = new ThreadLocal<>();", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\nindex c0c5cf9bd0..b3a487943a 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogCurrentTime.java\n\n@@ -18,7 +18,8 @@ import com.ibm.wsspi.http.channel.HttpResponseMessage;\n \n public class AccessLogCurrentTime extends AccessLogData {\n \n-    public static ThreadLocal<String> accessLogDatetime = new ThreadLocal<>();\n+    // We're assuming that the methods below that use this datetime will be called on the same thread\n+    private static ThreadLocal<String> accessLogDatetime = new ThreadLocal<>();\n \n     public AccessLogCurrentTime() {\n         super(\"%{t}W\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTEwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151109", "bodyText": "should probably make this private", "author": "donbourne", "createdAt": "2020-05-03T19:51:41Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java", "diffHunk": "@@ -18,25 +18,26 @@\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n+    public static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\nindex 8842c6cb7c..21e917695f 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\n\n@@ -18,7 +18,8 @@ import com.ibm.wsspi.http.channel.HttpResponseMessage;\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n-    public static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n+    // We're assuming that the methods below that use this elapsedTime will be called on the same thread\n+    private static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n \n     public AccessLogElapsedTime() {\n         super(\"%D\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTMxMg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151312", "bodyText": "could just put elapsedTime.set here (seems a bit odd to add the class name)", "author": "donbourne", "createdAt": "2020-05-03T19:53:16Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java", "diffHunk": "@@ -18,25 +18,26 @@\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n+    public static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n+\n     public AccessLogElapsedTime() {\n         super(\"%D\");\n         // %D - Elapsed time, in milliseconds, of the request/response exchange\n         // Millisecond accuracy, microsecond precision\n     }\n \n-    // Need some way to \"remember\" the elapsedTime value; the System.nanoTime - startTime\n-    static long currentTime = 0;\n-\n     @Override\n     public boolean set(StringBuilder accessLogEntry,\n                        HttpResponseMessage response, HttpRequestMessage request,\n                        Object data) {\n         long startTime = getStartTime(response, request, data);\n         if (startTime != 0) {\n-            currentTime = System.nanoTime();\n-            long elapsedTime = currentTime - startTime;\n-            accessLogEntry.append(TimeUnit.NANOSECONDS.toMicros(elapsedTime));\n+            long elapsedTime = System.nanoTime() - startTime;\n+            long elapsedTimeInMicroseconds = TimeUnit.NANOSECONDS.toMicros(elapsedTime);\n+            AccessLogElapsedTime.elapsedTime.set(elapsedTimeInMicroseconds);", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\nindex 8842c6cb7c..21e917695f 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogElapsedTime.java\n\n@@ -18,7 +18,8 @@ import com.ibm.wsspi.http.channel.HttpResponseMessage;\n \n public class AccessLogElapsedTime extends AccessLogData {\n \n-    public static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n+    // We're assuming that the methods below that use this elapsedTime will be called on the same thread\n+    private static ThreadLocal<Long> elapsedTime = new ThreadLocal<>();\n \n     public AccessLogElapsedTime() {\n         super(\"%D\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTQ5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151494", "bodyText": "compute \"[\" + formattedDate + \"]\" once and reuse it.", "author": "donbourne", "createdAt": "2020-05-03T19:54:31Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java", "diffHunk": "@@ -33,9 +34,11 @@ public boolean set(StringBuilder accessLogEntry,\n \n         if (startTime != 0) {\n             Date startDate = new Date(startTime);\n+            String formattedDate = HttpDispatcher.getDateFormatter().getNCSATime(startDate);\n             accessLogEntry.append(\"[\");\n-            accessLogEntry.append(HttpDispatcher.getDateFormatter().getNCSATime(startDate));\n+            accessLogEntry.append(formattedDate);\n             accessLogEntry.append(\"]\");\n+            startTimeFormatted.set(\"[\" + formattedDate + \"]\");", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java\nindex febbc1d53b..cd0277e7cf 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/channel/internal/values/AccessLogStartTime.java\n\n@@ -34,11 +36,9 @@ public class AccessLogStartTime extends AccessLogData {\n \n         if (startTime != 0) {\n             Date startDate = new Date(startTime);\n-            String formattedDate = HttpDispatcher.getDateFormatter().getNCSATime(startDate);\n-            accessLogEntry.append(\"[\");\n+            String formattedDate = \"[\" + HttpDispatcher.getDateFormatter().getNCSATime(startDate) + \"]\";\n             accessLogEntry.append(formattedDate);\n-            accessLogEntry.append(\"]\");\n-            startTimeFormatted.set(\"[\" + formattedDate + \"]\");\n+            startTimeFormatted.set(formattedDate);\n         } else {\n             accessLogEntry.append(\"-\");\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE1MTgyMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419151820", "bodyText": "rename to just delegate -- it's clear from the context what it's a delegate for", "author": "donbourne", "createdAt": "2020-05-03T19:57:11Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/internal/AccessLogRecordDataExt.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 IBM Corporation and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *\n+ * Contributors:\n+ * IBM Corporation - initial API and implementation\n+ *******************************************************************************/\n+package com.ibm.ws.http.logging.internal;\n+\n+import com.ibm.ws.http.logging.internal.AccessLogger.FormatSegment;\n+import com.ibm.wsspi.http.channel.HttpRequestMessage;\n+import com.ibm.wsspi.http.channel.HttpResponseMessage;\n+import com.ibm.wsspi.http.logging.AccessLogRecordData;\n+\n+/**\n+ *\n+ */\n+public class AccessLogRecordDataExt implements AccessLogRecordData {\n+\n+    AccessLogRecordData delegateRecordData;", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/internal/AccessLogRecordDataExt.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/internal/AccessLogRecordDataExt.java\nindex be3c7bca9c..4851cf4870 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/internal/AccessLogRecordDataExt.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/internal/AccessLogRecordDataExt.java\n\n@@ -20,12 +20,12 @@ import com.ibm.wsspi.http.logging.AccessLogRecordData;\n  */\n public class AccessLogRecordDataExt implements AccessLogRecordData {\n \n-    AccessLogRecordData delegateRecordData;\n+    AccessLogRecordData delegate;\n     FormatSegment[] parsedFormat;\n     String formatString;\n \n     AccessLogRecordDataExt(AccessLogRecordData alrd, FormatSegment[] parsedFormat, String formatString) {\n-        this.delegateRecordData = alrd;\n+        this.delegate = alrd;\n         this.parsedFormat = parsedFormat;\n         this.formatString = formatString;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MjA2Mw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419162063", "bodyText": "suggest you take a look at https://stackoverflow.com/questions/16377926/how-to-write-hashcode-method-for-a-particular-class -- that mentions Eclipse IDE has a way to generate your hashcode method for you.", "author": "donbourne", "createdAt": "2020-05-03T21:22:13Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -56,33 +59,82 @@\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n+    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode\n+        @Override\n+        public int hashCode() {\n+            int hash;\n+            hash = logFormat.hashCode() * loggingConfig.hashCode() * logstashConfig.hashCode();", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -60,15 +60,17 @@ public class AccessLogSource implements Source {\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n     Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n-    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n-    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsConfig = \"\";\n     public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n     // A representation of the current configuration; to be used in the setterFormatterMap\n     private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n \n         private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MjUxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419162513", "bodyText": "Might make sense to use the Configuration class here instead of having the same 3 fields in SetterFormatter", "author": "donbourne", "createdAt": "2020-05-03T21:25:53Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -56,33 +59,82 @@\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n+    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n+    // A representation of the current configuration; to be used in the setterFormatterMap\n+    private class Configuration {\n+        String logFormat;\n+        String loggingConfig;\n+        String logstashConfig;\n+\n+        private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n+            this.logFormat = logFormat;\n+            this.loggingConfig = loggingConfig;\n+            this.logstashConfig = logstashConfig;\n+        }\n+\n+        //@formatter:off\n+        String getLogFormat()      { return this.logFormat; }\n+        String getLoggingConfig()  { return this.loggingConfig; }\n+        String getLogstashConfig() { return this.logstashConfig; }\n+        //@formatter:on\n+\n+        // We need to put this object into a HashMap, so we're overriding hashCode\n+        @Override\n+        public int hashCode() {\n+            int hash;\n+            hash = logFormat.hashCode() * loggingConfig.hashCode() * logstashConfig.hashCode();\n+            return hash;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj)\n+                return true;\n+            if (obj == null)\n+                return false;\n+            if (getClass() != obj.getClass())\n+                return false;\n+            Configuration config = (Configuration) obj;\n+            if (!config.getLogFormat().equals(this.logFormat) || !config.getLoggingConfig().equals(this.loggingConfig) || !config.getLogstashConfig().equals(this.logstashConfig))\n+                return false;\n+            return true;\n+        }\n+    }\n+\n     private static class SetterFormatter {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -60,15 +60,17 @@ public class AccessLogSource implements Source {\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n     Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n-    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n-    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsConfig = \"\";\n     public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n     // A representation of the current configuration; to be used in the setterFormatterMap\n     private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n \n         private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MzM3OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419163378", "bodyText": "more efficient if, instead of using containsKey(config) followed by get(config) that you just do get(config) followed by checking the response for null.", "author": "donbourne", "createdAt": "2020-05-03T21:33:23Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -263,180 +309,188 @@ AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, Fo\n                 switch (s.log.getName()) {\n                     // Original - default fields\n                     //@formatter:off\n-                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n-                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n-                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n-                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n-                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n-                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n-                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n-                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n-                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n-                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    case \"%h\": builder.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": builder.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": builder.add(addRequestHostField    (format)); break;\n+                    case \"%B\": builder.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": builder.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": builder.add(addRequestPortField    (format)); break;\n+                    case \"%q\": builder.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": builder.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": builder.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": builder.add(addUriPathField        (format)); break;\n                     // New - access log only fields\n-                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n-                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%a\": builder.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": builder.add(addBytesSentField      (format)); break;\n                     case \"%C\":\n                         if (isFirstCookie) {\n-                            formatter.add(addCookiesField(format));\n+                            builder.add(addCookiesField(format));\n                             isFirstCookie = false;\n                         } break;\n-                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n                         if (s.data.equals(USER_AGENT_HEADER)) {\n-                            formatter.add(addUserAgentField(format));\n+                            builder.add(addUserAgentField(format));\n                         } else if (isFirstRequestHeader) {\n-                            formatter.add(addRequestHeaderField(format));\n+                            builder.add(addRequestHeaderField(format));\n                             isFirstRequestHeader = false;\n                         } break;\n                     case \"%o\":\n                         if (isFirstResponseHeader) {\n-                            formatter.add(addResponseHeaderField(format));\n+                            builder.add(addResponseHeaderField(format));\n                             isFirstResponseHeader = false;\n                         } break;\n-                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n-                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n-                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n-                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    case \"%r\": builder.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": builder.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": builder.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": builder.add(addRemoteUserField          (format)); break;\n                     //@formatter:on\n                 }\n             }\n         }\n-        return formatter;\n-\n-    }\n-\n-    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n-\n-        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n-\n-        formatter = new AccessLogDataFormatter();\n-        // %h\n-        formatter.add(addRemoteHostField(format));\n-        // %H\n-        formatter.add(addRequestProtocolField(format));\n-        // %A\n-        formatter.add(addRequestHostField(format));\n-        // %B\n-        formatter.add(addBytesReceivedField(format));\n-        // %m\n-        formatter.add(addRequestMethodField(format));\n-        // %p\n-        formatter.add(addRequestPortField(format));\n-        // %q\n-        formatter.add(addQueryStringField(format));\n-        // %{R}W\n-        formatter.add(addElapsedTimeField(format));\n-        // %s\n-        formatter.add(addResponseCodeField(format));\n-        // %U\n-        formatter.add(addUriPathField(format));\n-        // User agent\n-        formatter.add(addUserAgentField(format));\n-        return formatter;\n+        //@formatter:off\n+        builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n+               .add(addSequenceField(format)); // Datetime, present in all access logs\n+        //@formatter:on\n+        return new AccessLogDataFormatter(builder);\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+\n+        // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n+        //@formatter:off\n+        AccessLogDataFormatterBuilder builder = new AccessLogDataFormatterBuilder();\n+        builder.add(addRemoteHostField(format))  // %h\n+        .add(addRequestProtocolField  (format))  // %H\n+        .add(addRequestHostField      (format))  // %A\n+        .add(addBytesReceivedField    (format))  // %B\n+        .add(addRequestMethodField    (format))  // %m\n+        .add(addRequestPortField      (format))  // %p\n+        .add(addQueryStringField      (format))  // %q\n+        .add(addElapsedTimeField      (format))  // %{R}W\n+        .add(addResponseCodeField     (format))  // %s\n+        .add(addUriPathField          (format))  // %U\n+        .add(addUserAgentField        (format))  // User agent\n+        .add(addDatetimeField         (format))  // Datetime, present in all access logs\n+        .add(addSequenceField         (format)); // Sequence, present in all access logs\n+\n+        return new AccessLogDataFormatter(builder);\n+        //@formatter:on\n+    }\n+\n+    private void initializeSetterFormatter(String formatString, String jsonAccessLogFieldsConfig, String jsonAccessLogFieldsLogstashConfig, FormatSegment[] parsedFormat,\n+                                           AtomicLong seq) {\n+        SetterFormatter newSF = new SetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+        List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+        // Create the mapping of fields to add:{<format key> : <data value/null>}\n+        // Prevents duplicates\n+        initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+        // Create setter list\n+        fieldSetters = populateSetters(fieldsToAdd);\n+        // These fields are always added\n+        fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+        fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+        if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n+            formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n+        } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n+            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+        }\n+\n+        if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n+            formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n+        } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n+            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+        }\n+        newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+        currentSF = newSF;\n     }\n \n     private class AccessLogHandler implements AccessLogForwarder {\n-\n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-\n-        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n-            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n-            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n-                SetterFormatter newSF = new SetterFormatter();\n-                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n-                AccessLogDataFormatter[] formatters = { null, null, null, null };\n-                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n-\n-                // Create the mapping of fields to add:{<format key> : <data value/null>}\n-                // Prevents duplicates\n-                initializeFieldMap(fieldsToAdd, parsedFormat);\n-\n-                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n-\n-                // Create setter list\n-                fieldSetters = populateSetters(fieldsToAdd);\n-                // These fields are always added\n-                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n-                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n-\n-                if (jsonAccessLogFields.equals(\"default\")) {\n-                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFields.equals(\"logFormat\")) {\n-                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n-                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n-                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+        public void process(AccessLogRecordData recordData) {\n+            // The logFormat, as a string: e.g. \"%a %b %C\"\n+            String formatString = ((AccessLogRecordDataExt) recordData).getFormatString();\n+            // A parsed version of the logFormat\n+            FormatSegment[] parsedFormat = ((AccessLogRecordDataExt) recordData).getParsedFormat();\n+            jsonAccessLogFieldsConfig = AccessLogConfig.jsonAccessLogFieldsConfig;\n+\n+            Configuration config = new Configuration(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig))\n+                if (setterFormatterMap.containsKey(config)) {", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -352,11 +352,11 @@ public class AccessLogSource implements Source {\n         builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n                .add(addSequenceField(format)); // Datetime, present in all access logs\n         //@formatter:on\n-        return new AccessLogDataFormatter(builder);\n \n+        return builder.build();\n     }\n \n-    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+    private static AccessLogDataFormatter populateDefaultFormatters(int format) {\n \n         // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n         //@formatter:off\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2MzUzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419163538", "bodyText": "change this method to be static and just return the SetterFormatter it creates.  rename to createSetterFormatter", "author": "donbourne", "createdAt": "2020-05-03T21:34:30Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -263,180 +309,188 @@ AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, Fo\n                 switch (s.log.getName()) {\n                     // Original - default fields\n                     //@formatter:off\n-                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n-                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n-                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n-                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n-                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n-                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n-                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n-                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n-                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n-                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    case \"%h\": builder.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": builder.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": builder.add(addRequestHostField    (format)); break;\n+                    case \"%B\": builder.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": builder.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": builder.add(addRequestPortField    (format)); break;\n+                    case \"%q\": builder.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": builder.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": builder.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": builder.add(addUriPathField        (format)); break;\n                     // New - access log only fields\n-                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n-                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%a\": builder.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": builder.add(addBytesSentField      (format)); break;\n                     case \"%C\":\n                         if (isFirstCookie) {\n-                            formatter.add(addCookiesField(format));\n+                            builder.add(addCookiesField(format));\n                             isFirstCookie = false;\n                         } break;\n-                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n                         if (s.data.equals(USER_AGENT_HEADER)) {\n-                            formatter.add(addUserAgentField(format));\n+                            builder.add(addUserAgentField(format));\n                         } else if (isFirstRequestHeader) {\n-                            formatter.add(addRequestHeaderField(format));\n+                            builder.add(addRequestHeaderField(format));\n                             isFirstRequestHeader = false;\n                         } break;\n                     case \"%o\":\n                         if (isFirstResponseHeader) {\n-                            formatter.add(addResponseHeaderField(format));\n+                            builder.add(addResponseHeaderField(format));\n                             isFirstResponseHeader = false;\n                         } break;\n-                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n-                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n-                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n-                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    case \"%r\": builder.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": builder.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": builder.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": builder.add(addRemoteUserField          (format)); break;\n                     //@formatter:on\n                 }\n             }\n         }\n-        return formatter;\n-\n-    }\n-\n-    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n-\n-        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n-\n-        formatter = new AccessLogDataFormatter();\n-        // %h\n-        formatter.add(addRemoteHostField(format));\n-        // %H\n-        formatter.add(addRequestProtocolField(format));\n-        // %A\n-        formatter.add(addRequestHostField(format));\n-        // %B\n-        formatter.add(addBytesReceivedField(format));\n-        // %m\n-        formatter.add(addRequestMethodField(format));\n-        // %p\n-        formatter.add(addRequestPortField(format));\n-        // %q\n-        formatter.add(addQueryStringField(format));\n-        // %{R}W\n-        formatter.add(addElapsedTimeField(format));\n-        // %s\n-        formatter.add(addResponseCodeField(format));\n-        // %U\n-        formatter.add(addUriPathField(format));\n-        // User agent\n-        formatter.add(addUserAgentField(format));\n-        return formatter;\n+        //@formatter:off\n+        builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n+               .add(addSequenceField(format)); // Datetime, present in all access logs\n+        //@formatter:on\n+        return new AccessLogDataFormatter(builder);\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+\n+        // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n+        //@formatter:off\n+        AccessLogDataFormatterBuilder builder = new AccessLogDataFormatterBuilder();\n+        builder.add(addRemoteHostField(format))  // %h\n+        .add(addRequestProtocolField  (format))  // %H\n+        .add(addRequestHostField      (format))  // %A\n+        .add(addBytesReceivedField    (format))  // %B\n+        .add(addRequestMethodField    (format))  // %m\n+        .add(addRequestPortField      (format))  // %p\n+        .add(addQueryStringField      (format))  // %q\n+        .add(addElapsedTimeField      (format))  // %{R}W\n+        .add(addResponseCodeField     (format))  // %s\n+        .add(addUriPathField          (format))  // %U\n+        .add(addUserAgentField        (format))  // User agent\n+        .add(addDatetimeField         (format))  // Datetime, present in all access logs\n+        .add(addSequenceField         (format)); // Sequence, present in all access logs\n+\n+        return new AccessLogDataFormatter(builder);\n+        //@formatter:on\n+    }\n+\n+    private void initializeSetterFormatter(String formatString, String jsonAccessLogFieldsConfig, String jsonAccessLogFieldsLogstashConfig, FormatSegment[] parsedFormat,\n+                                           AtomicLong seq) {\n+        SetterFormatter newSF = new SetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+        List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+        // Create the mapping of fields to add:{<format key> : <data value/null>}\n+        // Prevents duplicates\n+        initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+        // Create setter list\n+        fieldSetters = populateSetters(fieldsToAdd);\n+        // These fields are always added\n+        fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+        fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+        if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n+            formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n+        } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n+            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+        }\n+\n+        if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n+            formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n+        } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n+            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+        }\n+        newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+        currentSF = newSF;\n     }\n \n     private class AccessLogHandler implements AccessLogForwarder {\n-\n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-\n-        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n-            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n-            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n-                SetterFormatter newSF = new SetterFormatter();\n-                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n-                AccessLogDataFormatter[] formatters = { null, null, null, null };\n-                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n-\n-                // Create the mapping of fields to add:{<format key> : <data value/null>}\n-                // Prevents duplicates\n-                initializeFieldMap(fieldsToAdd, parsedFormat);\n-\n-                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n-\n-                // Create setter list\n-                fieldSetters = populateSetters(fieldsToAdd);\n-                // These fields are always added\n-                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n-                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n-\n-                if (jsonAccessLogFields.equals(\"default\")) {\n-                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFields.equals(\"logFormat\")) {\n-                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n-                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n-                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+        public void process(AccessLogRecordData recordData) {\n+            // The logFormat, as a string: e.g. \"%a %b %C\"\n+            String formatString = ((AccessLogRecordDataExt) recordData).getFormatString();\n+            // A parsed version of the logFormat\n+            FormatSegment[] parsedFormat = ((AccessLogRecordDataExt) recordData).getParsedFormat();\n+            jsonAccessLogFieldsConfig = AccessLogConfig.jsonAccessLogFieldsConfig;\n+\n+            Configuration config = new Configuration(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig))\n+                if (setterFormatterMap.containsKey(config)) {\n+                    // If we've created a setterFormatter in the past for this configuration, we'll use it instead of making a new one\n+                    currentSF = setterFormatterMap.get(config);\n+                } else {\n+                    initializeSetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig, parsedFormat, seq);", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -352,11 +352,11 @@ public class AccessLogSource implements Source {\n         builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n                .add(addSequenceField(format)); // Datetime, present in all access logs\n         //@formatter:on\n-        return new AccessLogDataFormatter(builder);\n \n+        return builder.build();\n     }\n \n-    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+    private static AccessLogDataFormatter populateDefaultFormatters(int format) {\n \n         // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n         //@formatter:off\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NDI5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419164298", "bodyText": "not sure I get why we have a checkConfigChange method -- wouldn't the detection of a new config just be that there's no SetterFormatter in the map when requested with a given key?", "author": "donbourne", "createdAt": "2020-05-03T21:40:19Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -92,12 +144,6 @@ boolean checkConfigChange(String logFormat, String loggingConfig, String logstas\n                 return true;\n             return false;\n         }", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -138,12 +144,6 @@ public class AccessLogSource implements Source {\n         AccessLogDataFormatter[] getFormatters() {\n             return this.formatters;\n         }\n-\n-        boolean checkConfigChange(String logFormat, String loggingConfig, String logstashConfig) {\n-            if (!logFormat.equals(this.logFormat) || !loggingConfig.equals(this.loggingConfig) || !logstashConfig.equals(this.logstashConfig))\n-                return true;\n-            return false;\n-        }\n     }\n \n     private BufferManager bufferMgr = null;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NDc1MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419164750", "bodyText": "I think you probably should get rid of currentSF altogether, as well as checkConfigChange.  At this point in the code you could just look up the appropriate SF using the config.", "author": "donbourne", "createdAt": "2020-05-03T21:44:21Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -263,180 +309,188 @@ AccessLogDataFormatter populateCustomFormatters(FormatSegment[] parsedFormat, Fo\n                 switch (s.log.getName()) {\n                     // Original - default fields\n                     //@formatter:off\n-                    case \"%h\": formatter.add(addRemoteHostField     (format)); break;\n-                    case \"%H\": formatter.add(addRequestProtocolField(format)); break;\n-                    case \"%A\": formatter.add(addRequestHostField    (format)); break;\n-                    case \"%B\": formatter.add(addBytesReceivedField  (format)); break;\n-                    case \"%m\": formatter.add(addRequestMethodField  (format)); break;\n-                    case \"%p\": formatter.add(addRequestPortField    (format)); break;\n-                    case \"%q\": formatter.add(addQueryStringField    (format)); break;\n-                    case \"%{R}W\": formatter.add(addElapsedTimeField (format)); break;\n-                    case \"%s\": formatter.add(addResponseCodeField   (format)); break;\n-                    case \"%U\": formatter.add(addUriPathField        (format)); break;\n+                    case \"%h\": builder.add(addRemoteHostField     (format)); break;\n+                    case \"%H\": builder.add(addRequestProtocolField(format)); break;\n+                    case \"%A\": builder.add(addRequestHostField    (format)); break;\n+                    case \"%B\": builder.add(addBytesReceivedField  (format)); break;\n+                    case \"%m\": builder.add(addRequestMethodField  (format)); break;\n+                    case \"%p\": builder.add(addRequestPortField    (format)); break;\n+                    case \"%q\": builder.add(addQueryStringField    (format)); break;\n+                    case \"%{R}W\": builder.add(addElapsedTimeField (format)); break;\n+                    case \"%s\": builder.add(addResponseCodeField   (format)); break;\n+                    case \"%U\": builder.add(addUriPathField        (format)); break;\n                     // New - access log only fields\n-                    case \"%a\": formatter.add(addRemoteIPField       (format)); break;\n-                    case \"%b\": formatter.add(addBytesSentField      (format)); break;\n+                    case \"%a\": builder.add(addRemoteIPField       (format)); break;\n+                    case \"%b\": builder.add(addBytesSentField      (format)); break;\n                     case \"%C\":\n                         if (isFirstCookie) {\n-                            formatter.add(addCookiesField(format));\n+                            builder.add(addCookiesField(format));\n                             isFirstCookie = false;\n                         } break;\n-                    case \"%D\": formatter.add(addRequestElapsedTimeField(format)); break;\n+                    case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n                         if (s.data.equals(USER_AGENT_HEADER)) {\n-                            formatter.add(addUserAgentField(format));\n+                            builder.add(addUserAgentField(format));\n                         } else if (isFirstRequestHeader) {\n-                            formatter.add(addRequestHeaderField(format));\n+                            builder.add(addRequestHeaderField(format));\n                             isFirstRequestHeader = false;\n                         } break;\n                     case \"%o\":\n                         if (isFirstResponseHeader) {\n-                            formatter.add(addResponseHeaderField(format));\n+                            builder.add(addResponseHeaderField(format));\n                             isFirstResponseHeader = false;\n                         } break;\n-                    case \"%r\": formatter.add(addRequestFirstLineField    (format)); break;\n-                    case \"%t\": formatter.add(addRequestStartTimeField    (format)); break;\n-                    case \"%{t}W\": formatter.add(addAccessLogDatetimeField(format)); break;\n-                    case \"%u\": formatter.add(addRemoteUserField          (format)); break;\n+                    case \"%r\": builder.add(addRequestFirstLineField    (format)); break;\n+                    case \"%t\": builder.add(addRequestStartTimeField    (format)); break;\n+                    case \"%{t}W\": builder.add(addAccessLogDatetimeField(format)); break;\n+                    case \"%u\": builder.add(addRemoteUserField          (format)); break;\n                     //@formatter:on\n                 }\n             }\n         }\n-        return formatter;\n-\n-    }\n-\n-    private AccessLogDataFormatter populateDefaultFormatters(FormatSpecifier format) {\n-\n-        AccessLogDataFormatter formatter = new AccessLogDataFormatter();\n-\n-        formatter = new AccessLogDataFormatter();\n-        // %h\n-        formatter.add(addRemoteHostField(format));\n-        // %H\n-        formatter.add(addRequestProtocolField(format));\n-        // %A\n-        formatter.add(addRequestHostField(format));\n-        // %B\n-        formatter.add(addBytesReceivedField(format));\n-        // %m\n-        formatter.add(addRequestMethodField(format));\n-        // %p\n-        formatter.add(addRequestPortField(format));\n-        // %q\n-        formatter.add(addQueryStringField(format));\n-        // %{R}W\n-        formatter.add(addElapsedTimeField(format));\n-        // %s\n-        formatter.add(addResponseCodeField(format));\n-        // %U\n-        formatter.add(addUriPathField(format));\n-        // User agent\n-        formatter.add(addUserAgentField(format));\n-        return formatter;\n+        //@formatter:off\n+        builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n+               .add(addSequenceField(format)); // Datetime, present in all access logs\n+        //@formatter:on\n+        return new AccessLogDataFormatter(builder);\n+\n+    }\n+\n+    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+\n+        // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n+        //@formatter:off\n+        AccessLogDataFormatterBuilder builder = new AccessLogDataFormatterBuilder();\n+        builder.add(addRemoteHostField(format))  // %h\n+        .add(addRequestProtocolField  (format))  // %H\n+        .add(addRequestHostField      (format))  // %A\n+        .add(addBytesReceivedField    (format))  // %B\n+        .add(addRequestMethodField    (format))  // %m\n+        .add(addRequestPortField      (format))  // %p\n+        .add(addQueryStringField      (format))  // %q\n+        .add(addElapsedTimeField      (format))  // %{R}W\n+        .add(addResponseCodeField     (format))  // %s\n+        .add(addUriPathField          (format))  // %U\n+        .add(addUserAgentField        (format))  // User agent\n+        .add(addDatetimeField         (format))  // Datetime, present in all access logs\n+        .add(addSequenceField         (format)); // Sequence, present in all access logs\n+\n+        return new AccessLogDataFormatter(builder);\n+        //@formatter:on\n+    }\n+\n+    private void initializeSetterFormatter(String formatString, String jsonAccessLogFieldsConfig, String jsonAccessLogFieldsLogstashConfig, FormatSegment[] parsedFormat,\n+                                           AtomicLong seq) {\n+        SetterFormatter newSF = new SetterFormatter(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+        List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n+        AccessLogDataFormatter[] formatters = { null, null, null, null };\n+        Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n+\n+        // Create the mapping of fields to add:{<format key> : <data value/null>}\n+        // Prevents duplicates\n+        initializeFieldMap(fieldsToAdd, parsedFormat);\n+\n+        // Create setter list\n+        fieldSetters = populateSetters(fieldsToAdd);\n+        // These fields are always added\n+        fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n+        fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n+\n+        if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n+            formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n+        } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n+            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+        }\n+\n+        if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n+            formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n+        } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n+            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+        }\n+        newSF.setSettersAndFormatters(fieldSetters, formatters);\n+\n+        currentSF = newSF;\n     }\n \n     private class AccessLogHandler implements AccessLogForwarder {\n-\n         private final AtomicLong seq = new AtomicLong();\n \n         /** {@inheritDoc} */\n         @Override\n-\n-        public void process(AccessLogRecordData recordData, FormatSegment[] parsedFormat, String formatString) {\n-            jsonAccessLogFields = AccessLogConfig.jsonAccessLogFields;\n-            if (currentSF.checkConfigChange(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash)) {\n-                SetterFormatter newSF = new SetterFormatter();\n-                List<AccessLogDataFieldSetter> fieldSetters = new ArrayList<AccessLogDataFieldSetter>();\n-                AccessLogDataFormatter[] formatters = { null, null, null, null };\n-                Map<String, HashSet<Object>> fieldsToAdd = new HashMap<String, HashSet<Object>>();\n-\n-                // Create the mapping of fields to add:{<format key> : <data value/null>}\n-                // Prevents duplicates\n-                initializeFieldMap(fieldsToAdd, parsedFormat);\n-\n-                newSF.setFullConfig(formatString, jsonAccessLogFields, jsonAccessLogFieldsLogstash);\n-\n-                // Create setter list\n-                fieldSetters = populateSetters(fieldsToAdd);\n-                // These fields are always added\n-                fieldSetters.add((ald, alrd) -> ald.setSequence(alrd.getStartTime() + \"_\" + String.format(\"%013X\", seq.incrementAndGet())));\n-                fieldSetters.add((ald, alrd) -> ald.setDatetime(alrd.getTimestamp()));\n-\n-                if (jsonAccessLogFields.equals(\"default\")) {\n-                    formatters[0] = populateDefaultFormatters(FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFields.equals(\"logFormat\")) {\n-                    formatters[1] = populateCustomFormatters(parsedFormat, FormatSpecifier.JSON);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"default\")) {\n-                    formatters[2] = populateDefaultFormatters(FormatSpecifier.LOGSTASH);\n-                }\n-                if (jsonAccessLogFieldsLogstash.equals(\"logFormat\")) {\n-                    formatters[3] = populateCustomFormatters(parsedFormat, FormatSpecifier.LOGSTASH);\n+        public void process(AccessLogRecordData recordData) {\n+            // The logFormat, as a string: e.g. \"%a %b %C\"\n+            String formatString = ((AccessLogRecordDataExt) recordData).getFormatString();\n+            // A parsed version of the logFormat\n+            FormatSegment[] parsedFormat = ((AccessLogRecordDataExt) recordData).getParsedFormat();\n+            jsonAccessLogFieldsConfig = AccessLogConfig.jsonAccessLogFieldsConfig;\n+\n+            Configuration config = new Configuration(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig);\n+\n+            if (currentSF.checkConfigChange(formatString, jsonAccessLogFieldsConfig, jsonAccessLogFieldsLogstashConfig))", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -352,11 +352,11 @@ public class AccessLogSource implements Source {\n         builder.add(addDatetimeField(format))  // Sequence, present in all access logs\n                .add(addSequenceField(format)); // Datetime, present in all access logs\n         //@formatter:on\n-        return new AccessLogDataFormatter(builder);\n \n+        return builder.build();\n     }\n \n-    private AccessLogDataFormatter populateDefaultFormatters(int format) {\n+    private static AccessLogDataFormatter populateDefaultFormatters(int format) {\n \n         // Note: @formatter is Eclipse's formatter - does not relate to the AccessLogDataFormatter\n         //@formatter:off\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419165490", "bodyText": "make private", "author": "donbourne", "createdAt": "2020-05-03T21:50:56Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java", "diffHunk": "@@ -20,25 +20,36 @@\n public class AccessLogDataFormatter {\n \n     // list of actions to populate JSONObjectBuilder\n-    private final ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+    private ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n \n-    public AccessLogDataFormatter() {\n+    public static class AccessLogDataFormatterBuilder {\n+        private final ArrayList<JsonFieldAdder> jsonFieldAdders = new ArrayList<JsonFieldAdder>();\n+\n+        public AccessLogDataFormatterBuilder() {\n+        }\n+\n+        public AccessLogDataFormatterBuilder add(JsonFieldAdder jsonFieldAdder) {\n+            this.jsonFieldAdders.add(jsonFieldAdder);\n+            return this;\n+        }\n+\n+        public AccessLogDataFormatter build() {\n+            AccessLogDataFormatter formatter = new AccessLogDataFormatter(this);\n+            return formatter;\n+        }\n \n     }\n \n-    // adds another JsonFieldAdder to the list\n-    public AccessLogDataFormatter add(JsonFieldAdder jsonFieldAdder) {\n-        this.jsonFieldAdders.add(jsonFieldAdder);\n-        return this;\n+    public AccessLogDataFormatter(AccessLogDataFormatterBuilder builder) {", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxMzkyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419713929", "bodyText": "If it's private then AccessLogSource can't access it since it's in http transport. It needs to be public, or else we'd have to make our list of formatters into a list of formatterBuilders, I think", "author": "jennifer-c", "createdAt": "2020-05-04T20:39:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5MjMxNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420092314", "bodyText": "I think you should be able to call AccessLogDataFormatter aldf = accessLogDataFormatterBuilder.build(); , no?", "author": "donbourne", "createdAt": "2020-05-05T13:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA5NjMyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420096328", "bodyText": "yep, you're right, I don't know why I wasn't using that to begin with!", "author": "jennifer-c", "createdAt": "2020-05-05T13:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTQ5MA=="}], "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java\nindex f828364d28..1fb6aac09e 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/data/AccessLogDataFormatter.java\n\n@@ -14,9 +14,6 @@ import java.util.ArrayList;\n \n import com.ibm.ws.logging.data.JSONObject.JSONObjectBuilder;\n \n-/**\n- *\n- */\n public class AccessLogDataFormatter {\n \n     // list of actions to populate JSONObjectBuilder\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE2NTYyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r419165623", "bodyText": "don't think you need currentSF...see below", "author": "donbourne", "createdAt": "2020-05-03T21:52:00Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -56,33 +59,82 @@\n     private final String location = \"memory\";\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n-    private SetterFormatter currentSF = new SetterFormatter();\n-    public String jsonAccessLogFields = \"\";\n-    public static String jsonAccessLogFieldsLogstash = \"\";\n+    Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n+    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");", "originalCommit": "b75242154ea3ae8ee380be5507985af230c5dc1b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6275e39afeed15b28845f273de44927dce2c7195", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 8ed3d57b16..c7646df129 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -60,15 +60,17 @@ public class AccessLogSource implements Source {\n     private static String USER_AGENT_HEADER = \"User-Agent\";\n     public static final int MAX_USER_AGENT_LENGTH = 2048;\n     Map<Configuration, SetterFormatter> setterFormatterMap = new ConcurrentHashMap<Configuration, SetterFormatter>();\n-    private SetterFormatter currentSF = new SetterFormatter(\"\", \"\", \"\");\n-    public String jsonAccessLogFieldsConfig = \"\";\n+    public static String jsonAccessLogFieldsConfig = \"\";\n     public static String jsonAccessLogFieldsLogstashConfig = \"\";\n     public Map<String, Object> configuration;\n \n     // A representation of the current configuration; to be used in the setterFormatterMap\n     private class Configuration {\n+        // The HTTP access logging logFormat value, e.g. \"%a %b\"\n         String logFormat;\n+        // The jsonAccessLogFields configuration value for JSON logging, default or logFormat\n         String loggingConfig;\n+        // The jsonAccessLogFields configuration value for Logstash Collector, default or logFormat\n         String logstashConfig;\n \n         private Configuration(String logFormat, String loggingConfig, String logstashConfig) {\n"}}, {"oid": "6275e39afeed15b28845f273de44927dce2c7195", "url": "https://github.com/OpenLiberty/open-liberty/commit/6275e39afeed15b28845f273de44927dce2c7195", "message": "Address comments", "committedDate": "2020-05-05T15:36:42Z", "type": "forcePushed"}, {"oid": "288fe72db71bf525c0222db7bcea4a6f66cfa4b1", "url": "https://github.com/OpenLiberty/open-liberty/commit/288fe72db71bf525c0222db7bcea4a6f66cfa4b1", "message": "Address comments", "committedDate": "2020-05-05T16:25:17Z", "type": "forcePushed"}, {"oid": "5a63baa5199a1e0591a690616b81f4fc4201169d", "url": "https://github.com/OpenLiberty/open-liberty/commit/5a63baa5199a1e0591a690616b81f4fc4201169d", "message": "Address comments", "committedDate": "2020-05-05T18:07:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4MTQzMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420381433", "bodyText": "it's possible for tempStartFields to be non-null but to be building an event for logstashCollector.  Suggest you just have one \"tempStartFields\" which gets set to either startAccessLogJsonFields or startAccessLogLogstashCollector depending on the value of format.", "author": "donbourne", "createdAt": "2020-05-05T20:20:09Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -385,20 +386,28 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAccessLogJsonFields;\n+        String tempStartFieldsLogstash = startAccessLogLogstashCollector;\n \n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n+        if (tempStartFields != null) {\n+            if (format == AccessLogData.KEYS_JSON)\n+                jsonBuilder.addPreformatted(tempStartFields);\n+        } else if (tempStartFieldsLogstash != null) {\n+            if (format == AccessLogData.KEYS_LOGSTASH)\n+                jsonBuilder.addPreformatted(tempStartFieldsLogstash);", "originalCommit": "5a63baa5199a1e0591a690616b81f4fc4201169d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ff624082c4810c563aa7ec8715b3372eec6f5821", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex 0d22894eb2..8872b86611 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -388,15 +388,14 @@ public class CollectorJsonHelpers {\n \n     protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAccessLogJsonFields;\n-        String tempStartFieldsLogstash = startAccessLogLogstashCollector;\n+        String tempStartFields = null;\n+        if (format == AccessLogData.KEYS_JSON)\n+            tempStartFields = startAccessLogJsonFields;\n+        else if (format == AccessLogData.KEYS_LOGSTASH)\n+            tempStartFields = startAccessLogLogstashCollector;\n \n         if (tempStartFields != null) {\n-            if (format == AccessLogData.KEYS_JSON)\n-                jsonBuilder.addPreformatted(tempStartFields);\n-        } else if (tempStartFieldsLogstash != null) {\n-            if (format == AccessLogData.KEYS_LOGSTASH)\n-                jsonBuilder.addPreformatted(tempStartFieldsLogstash);\n+            jsonBuilder.addPreformatted(tempStartFields);\n         } else {\n             //@formatter:off\n             jsonBuilder.addField(AccessLogData.getTypeKey(format), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTQxMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420385410", "bodyText": "is this used anymore?", "author": "donbourne", "createdAt": "2020-05-05T20:27:43Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -86,7 +87,7 @@ protected static String getEventType(String source, String location) {\n             return \"\";\n     }\n \n-    protected static ThreadLocal<BurstDateFormat> dateFormatTL = new ThreadLocal<BurstDateFormat>() {\n+    public static ThreadLocal<BurstDateFormat> dateFormatTL = new ThreadLocal<BurstDateFormat>() {", "originalCommit": "5a63baa5199a1e0591a690616b81f4fc4201169d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg5MTg4NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r420891885", "bodyText": "Yes, it's used by all the other jsonify methods (jsonifyAudit, jsonifyFFDC, etc) - also, AccessLogSource now also uses it (hence the change from protected->public) since I moved the datetime field into the list of formatters: https://github.com/OpenLiberty/open-liberty/pull/11189/files#diff-83645dd44864a951f486a50cbd6b6e27R375\n(per this review comment #11189 (comment))", "author": "jennifer-c", "createdAt": "2020-05-06T15:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM4NTQxMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "ff624082c4810c563aa7ec8715b3372eec6f5821", "url": "https://github.com/OpenLiberty/open-liberty/commit/ff624082c4810c563aa7ec8715b3372eec6f5821", "message": "Add tests", "committedDate": "2020-05-09T13:09:25Z", "type": "forcePushed"}, {"oid": "581d3b427ff6fa0679b0e36cb91191d37ce1cf65", "url": "https://github.com/OpenLiberty/open-liberty/commit/581d3b427ff6fa0679b0e36cb91191d37ce1cf65", "message": "Fix timing issue in test, add multiple endpoints test", "committedDate": "2020-05-12T16:21:13Z", "type": "forcePushed"}, {"oid": "df43bbbf91302fb9be7fa40b6f75e179b1f479c7", "url": "https://github.com/OpenLiberty/open-liberty/commit/df43bbbf91302fb9be7fa40b6f75e179b1f479c7", "message": "Fix timing issue in test, add multiple endpoints test", "committedDate": "2020-05-13T16:04:07Z", "type": "forcePushed"}, {"oid": "696efda2d9b18781eaab4fcc717edba9464c0e20", "url": "https://github.com/OpenLiberty/open-liberty/commit/696efda2d9b18781eaab4fcc717edba9464c0e20", "message": "Fix timing issue in test, add multiple endpoints test", "committedDate": "2020-05-13T19:27:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ3MzY0NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r429473645", "bodyText": "this isn't thread safe.  if one thread updates the config after another thread reaches line 406 you could have problem.  could we set startAccessLogJsonFields (and possibly the other similar fields) in the updateFieldMappings method?", "author": "donbourne", "createdAt": "2020-05-22T22:03:25Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -385,20 +386,27 @@ protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String w\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAccessLogJsonFields;\n+        String tempStartFields = null;\n+        if (format == AccessLogData.KEYS_JSON)\n+            tempStartFields = startAccessLogJsonFields;\n+        else if (format == AccessLogData.KEYS_LOGSTASH)\n+            tempStartFields = startAccessLogLogstashCollector;\n \n-        if (tempStartFields != null)\n+        if (tempStartFields != null) {\n             jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n+        } else {\n             //@formatter:off\n-            jsonBuilder.addField(AccessLogData.getTypeKeyJSON(), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-            .addField(AccessLogData.getHostKeyJSON(), hostName, false, false)\n-            .addField(AccessLogData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(AccessLogData.getServerNameKeyJSON(), serverName, false, false);\n+            jsonBuilder.addField(AccessLogData.getTypeKey(format), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(format), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(format), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(format), serverName, false, false);\n             //@formatter:on\n-            startAccessLogJsonFields = jsonBuilder.toString();\n+            if (format == AccessLogData.KEYS_JSON)", "originalCommit": "f2bb83b5d0d848cba27f5858a99b664d94511a3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex 8872b86611..ee90a38f6a 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -375,13 +414,8 @@ public class CollectorJsonHelpers {\n         if (tempStartFields != null)\n             jsonBuilder.addPreformatted(tempStartFields);\n         else {\n-            //@formatter:off\n-            jsonBuilder.addField(FFDCData.getTypeKeyJSON(), CollectorConstants.FFDC_EVENT_TYPE, false, false)\n-            .addField(FFDCData.getHostKeyJSON(), hostName, false, false)\n-            .addField(FFDCData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(FFDCData.getServerNameKeyJSON(), serverName, false, false);\n-            //@formatter:on\n-            startFFDCJsonFields = jsonBuilder.toString();\n+            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n+            // Should something be returned or have an exception thrown here?\n         }\n         return jsonBuilder;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5OTIyOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r429999229", "bodyText": "as discussed in slack, can avoid need to have removeDuplicates by changing initializeSetterFormatter to use fieldsToAdd (which already only contains unique values) instead of parsedFormat in calls to populateCustomFormattters", "author": "donbourne", "createdAt": "2020-05-25T15:51:30Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -409,7 +409,21 @@ private void initializeSetterFormatter(String formatString, String jsonAccessLog\n         }\n         newSF.setSettersAndFormatters(fieldSetters, formatters);\n \n-        currentSF = newSF;\n+        return newSF;\n+    }\n+\n+    private void removeDuplicates(FormatSegment[] parsedFormat) {", "originalCommit": "f2bb83b5d0d848cba27f5858a99b664d94511a3b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\nindex 0cc2e8a4f7..b1db9e875c 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java\n\n@@ -399,33 +416,19 @@ public class AccessLogSource implements Source {\n         if (jsonAccessLogFieldsConfig.equals(\"default\")) {\n             formatters[0] = populateDefaultFormatters(AccessLogData.KEYS_JSON);\n         } else if (jsonAccessLogFieldsConfig.equals(\"logFormat\")) {\n-            formatters[1] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_JSON);\n+            formatters[1] = populateCustomFormatters(fieldsToAddJson, AccessLogData.KEYS_JSON);\n         }\n \n         if (jsonAccessLogFieldsLogstashConfig.equals(\"default\")) {\n             formatters[2] = populateDefaultFormatters(AccessLogData.KEYS_LOGSTASH);\n         } else if (jsonAccessLogFieldsLogstashConfig.equals(\"logFormat\")) {\n-            formatters[3] = populateCustomFormatters(parsedFormat, AccessLogData.KEYS_LOGSTASH);\n+            formatters[3] = populateCustomFormatters(fieldsToAddLogstash, AccessLogData.KEYS_LOGSTASH);\n         }\n         newSF.setSettersAndFormatters(fieldSetters, formatters);\n \n         return newSF;\n     }\n \n-    private void removeDuplicates(FormatSegment[] parsedFormat) {\n-        Set<String> fieldName = new HashSet<String>();\n-        for (FormatSegment fs : parsedFormat) {\n-            if (fs.log != null) {\n-                String format = fs.log.getName(); // e.g. will look like \"%i\", \"%a\"\n-                if (format.equals(\"%i\") || format.equals(\"%o\") || format.equals(\"%C\"))\n-                    break;\n-                if (!fieldName.add(format))\n-                    // Making it null will remove the duplicate print without messing around with the array dimensions\n-                    fs.log = null;\n-            }\n-        }\n-    }\n-\n     private class AccessLogHandler implements AccessLogForwarder {\n         private final AtomicLong seq = new AtomicLong();\n \n"}}, {"oid": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "url": "https://github.com/OpenLiberty/open-liberty/commit/71397c7743fc6bfbe78493b7d7c8102c706c938d", "message": "always call updateFieldMappings after server config update", "committedDate": "2020-05-28T03:04:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0OTM3Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431849377", "bodyText": "looks good - maybe just turn formatter off at start of this method and turn it on at end since you need it repeatedly", "author": "donbourne", "createdAt": "2020-05-28T13:49:35Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -195,11 +198,57 @@ protected static void jsonEscape3(StringBuilder sb, String s) {\n     }\n \n     public static void updateFieldMappings() {\n-        startMessageJsonFields = null;\n-        startTraceJsonFields = null;\n-        startAccessLogJsonFields = null;\n-        startAuditJsonFields = null;\n-        startFFDCJsonFields = null;\n+        JSONObjectBuilder jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n+        .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n+        .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n+        .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n+        //@formatter:on\n+        startMessageJsonFields = jsonBuilder.toString();\n+\n+        jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(AuditData.getTypeKeyJSON(), CollectorConstants.AUDIT_LOG_EVENT_TYPE, false, false)\n+        .addField(AuditData.getHostKeyJSON(), hostName, false, false)\n+        .addField(AuditData.getUserDirKeyJSON(), wlpUserDir, false, true)\n+        .addField(AuditData.getServerNameKeyJSON(), serverName, false, false);\n+\n+        //@formatter:on\n+        startAuditJsonFields = jsonBuilder.toString();\n+\n+        jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(LogTraceData.getTypeKeyJSON(false), CollectorConstants.TRACE_LOG_EVENT_TYPE, false, false)\n+        .addField(LogTraceData.getHostKeyJSON(false), hostName, false, false)\n+        .addField(LogTraceData.getUserDirKeyJSON(false), wlpUserDir, false, true)\n+        .addField(LogTraceData.getServerNameKeyJSON(false), serverName, false, false);\n+        //@formatter:on\n+        startTraceJsonFields = jsonBuilder.toString();\n+\n+        // We should initialize both the regular JSON logging and LogstashCollector variants\n+        for (int i = 0; i < 2; i++) {\n+            jsonBuilder = new JSONObjectBuilder();\n+            //@formatter:off\n+            jsonBuilder.addField(AccessLogData.getTypeKey(i), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n+            .addField(AccessLogData.getHostKey(i), hostName, false, false)\n+            .addField(AccessLogData.getUserDirKey(i), wlpUserDir, false, true)\n+            .addField(AccessLogData.getServerNameKey(i), serverName, false, false);\n+            //@formatter:on\n+            if (i == AccessLogData.KEYS_JSON)\n+                startAccessLogJsonFields = jsonBuilder.toString();\n+            else if (i == AccessLogData.KEYS_LOGSTASH)\n+                startAccessLogLogstashCollector = jsonBuilder.toString();\n+        }\n+\n+        jsonBuilder = new JSONObjectBuilder();\n+        //@formatter:off\n+        jsonBuilder.addField(FFDCData.getTypeKeyJSON(), CollectorConstants.FFDC_EVENT_TYPE, false, false)\n+        .addField(FFDCData.getHostKeyJSON(), hostName, false, false)\n+        .addField(FFDCData.getUserDirKeyJSON(), wlpUserDir, false, true)\n+        .addField(FFDCData.getServerNameKeyJSON(), serverName, false, false);\n+        //@formatter:on", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex ee90a38f6a..b852b6b79f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -198,43 +210,35 @@ public class CollectorJsonHelpers {\n     }\n \n     public static void updateFieldMappings() {\n-        JSONObjectBuilder jsonBuilder = new JSONObjectBuilder();\n         //@formatter:off\n+        JSONObjectBuilder jsonBuilder = new JSONObjectBuilder();\n         jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n-        .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n-        .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n-        .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n-        //@formatter:on\n+                   .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n+                   .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n+                   .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n         startMessageJsonFields = jsonBuilder.toString();\n \n         jsonBuilder = new JSONObjectBuilder();\n-        //@formatter:off\n         jsonBuilder.addField(AuditData.getTypeKeyJSON(), CollectorConstants.AUDIT_LOG_EVENT_TYPE, false, false)\n-        .addField(AuditData.getHostKeyJSON(), hostName, false, false)\n-        .addField(AuditData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-        .addField(AuditData.getServerNameKeyJSON(), serverName, false, false);\n-\n-        //@formatter:on\n+                   .addField(AuditData.getHostKeyJSON(), hostName, false, false)\n+                   .addField(AuditData.getUserDirKeyJSON(), wlpUserDir, false, true)\n+                   .addField(AuditData.getServerNameKeyJSON(), serverName, false, false);\n         startAuditJsonFields = jsonBuilder.toString();\n \n         jsonBuilder = new JSONObjectBuilder();\n-        //@formatter:off\n         jsonBuilder.addField(LogTraceData.getTypeKeyJSON(false), CollectorConstants.TRACE_LOG_EVENT_TYPE, false, false)\n-        .addField(LogTraceData.getHostKeyJSON(false), hostName, false, false)\n-        .addField(LogTraceData.getUserDirKeyJSON(false), wlpUserDir, false, true)\n-        .addField(LogTraceData.getServerNameKeyJSON(false), serverName, false, false);\n-        //@formatter:on\n+                   .addField(LogTraceData.getHostKeyJSON(false), hostName, false, false)\n+                   .addField(LogTraceData.getUserDirKeyJSON(false), wlpUserDir, false, true)\n+                   .addField(LogTraceData.getServerNameKeyJSON(false), serverName, false, false);\n         startTraceJsonFields = jsonBuilder.toString();\n \n         // We should initialize both the regular JSON logging and LogstashCollector variants\n         for (int i = 0; i < 2; i++) {\n             jsonBuilder = new JSONObjectBuilder();\n-            //@formatter:off\n             jsonBuilder.addField(AccessLogData.getTypeKey(i), CollectorConstants.ACCESS_LOG_EVENT_TYPE, false, false)\n-            .addField(AccessLogData.getHostKey(i), hostName, false, false)\n-            .addField(AccessLogData.getUserDirKey(i), wlpUserDir, false, true)\n-            .addField(AccessLogData.getServerNameKey(i), serverName, false, false);\n-            //@formatter:on\n+                       .addField(AccessLogData.getHostKey(i), hostName, false, false)\n+                       .addField(AccessLogData.getUserDirKey(i), wlpUserDir, false, true)\n+                       .addField(AccessLogData.getServerNameKey(i), serverName, false, false);\n             if (i == AccessLogData.KEYS_JSON)\n                 startAccessLogJsonFields = jsonBuilder.toString();\n             else if (i == AccessLogData.KEYS_LOGSTASH)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1OTEwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431859103", "bodyText": "can probably just simplify this method assuming startAuditJsonFields is never null.", "author": "donbourne", "createdAt": "2020-05-28T14:02:32Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -321,13 +370,8 @@ protected static JSONObjectBuilder startAuditJsonFields(String hostName, String\n         if (tempStartFields != null) {\n             jsonBuilder.addPreformatted(tempStartFields);\n         } else {\n-            //@formatter:off\n-            jsonBuilder.addField(AuditData.getTypeKeyJSON(), CollectorConstants.AUDIT_LOG_EVENT_TYPE, false, false)\n-            .addField(AuditData.getHostKeyJSON(), hostName, false, false)\n-            .addField(AuditData.getUserDirKeyJSON(), wlpUserDir, false, true)\n-            .addField(AuditData.getServerNameKeyJSON(), serverName, false, false);\n-            //@formatter:on\n-            startAuditJsonFields = jsonBuilder.toString();\n+            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n+            // Should something be returned or have an exception thrown here?", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex ee90a38f6a..b852b6b79f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -363,77 +366,41 @@ public class CollectorJsonHelpers {\n         return sb;\n     }\n \n-    protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAuditJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAuditJsonFields;\n-\n-        if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        } else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming startAuditJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startAuditJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startMessageJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startMessageJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startMessageJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            //@formatter:off\n-            jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n-            .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n-            .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n-            .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n-            //@formatter:on\n-            startMessageJsonFields = jsonBuilder.toString();\n-        }\n+        // We're assuming startMessageJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startMessageJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startTraceJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startTraceJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startTraceJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming startTraceJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startTraceJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startFFDCJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startFFDCJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming startFFDCJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startFFDCJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = null;\n+        // We're assuming startAccessLogJsonFields and startAccessLogLogstashCollector will never be null - i.e. updateFieldMappings is always called before this method is called\n         if (format == AccessLogData.KEYS_JSON)\n-            tempStartFields = startAccessLogJsonFields;\n+            jsonBuilder.addPreformatted(startAccessLogJsonFields);\n         else if (format == AccessLogData.KEYS_LOGSTASH)\n-            tempStartFields = startAccessLogLogstashCollector;\n-\n-        if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        } else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+            jsonBuilder.addPreformatted(startAccessLogLogstashCollector);\n         return jsonBuilder;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MDQ0MA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431860440", "bodyText": "I think you skipped startMessageJsonFields method?", "author": "donbourne", "createdAt": "2020-05-28T14:04:24Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -357,13 +401,8 @@ protected static JSONObjectBuilder startTraceJsonFields(String hostName, String\n         if (tempStartFields != null)\n             jsonBuilder.addPreformatted(tempStartFields);\n         else {\n-            //@formatter:off\n-            jsonBuilder.addField(LogTraceData.getTypeKeyJSON(false), CollectorConstants.TRACE_LOG_EVENT_TYPE, false, false)\n-            .addField(LogTraceData.getHostKeyJSON(false), hostName, false, false)\n-            .addField(LogTraceData.getUserDirKeyJSON(false), wlpUserDir, false, true)\n-            .addField(LogTraceData.getServerNameKeyJSON(false), serverName, false, false);\n-            //@formatter:on\n-            startTraceJsonFields = jsonBuilder.toString();\n+            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex ee90a38f6a..b852b6b79f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -363,77 +366,41 @@ public class CollectorJsonHelpers {\n         return sb;\n     }\n \n-    protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAuditJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAuditJsonFields;\n-\n-        if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        } else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming startAuditJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startAuditJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startMessageJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startMessageJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startMessageJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            //@formatter:off\n-            jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n-            .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n-            .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n-            .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n-            //@formatter:on\n-            startMessageJsonFields = jsonBuilder.toString();\n-        }\n+        // We're assuming startMessageJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startMessageJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startTraceJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startTraceJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startTraceJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming startTraceJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startTraceJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startFFDCJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startFFDCJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming startFFDCJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startFFDCJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = null;\n+        // We're assuming startAccessLogJsonFields and startAccessLogLogstashCollector will never be null - i.e. updateFieldMappings is always called before this method is called\n         if (format == AccessLogData.KEYS_JSON)\n-            tempStartFields = startAccessLogJsonFields;\n+            jsonBuilder.addPreformatted(startAccessLogJsonFields);\n         else if (format == AccessLogData.KEYS_LOGSTASH)\n-            tempStartFields = startAccessLogLogstashCollector;\n-\n-        if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        } else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+            jsonBuilder.addPreformatted(startAccessLogLogstashCollector);\n         return jsonBuilder;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk5MDAwOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r431990008", "bodyText": "add/use setter methods on CollectorJsonHelpers for these", "author": "donbourne", "createdAt": "2020-05-28T17:04:04Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/JsonLogHandler.java", "diffHunk": "@@ -103,6 +104,10 @@ public String run() throws UnknownHostException {\n             serverHostName = containerHost;\n         }\n \n+        CollectorJsonHelpers.hostName = serverHostName;\n+        CollectorJsonHelpers.serverName = wlpServerName;\n+        CollectorJsonHelpers.wlpUserDir = wlpUserDir;", "originalCommit": "71397c7743fc6bfbe78493b7d7c8102c706c938d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/JsonLogHandler.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/JsonLogHandler.java\nindex d60c46fd4e..2ccc42921d 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/JsonLogHandler.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/internal/impl/JsonLogHandler.java\n\n@@ -104,9 +104,9 @@ public abstract class JsonLogHandler implements SynchronousHandler, Formatter {\n             serverHostName = containerHost;\n         }\n \n-        CollectorJsonHelpers.hostName = serverHostName;\n-        CollectorJsonHelpers.serverName = wlpServerName;\n-        CollectorJsonHelpers.wlpUserDir = wlpUserDir;\n+        CollectorJsonHelpers.setHostName(serverHostName);\n+        CollectorJsonHelpers.setServerName(wlpServerName);\n+        CollectorJsonHelpers.setWlpUserDir(wlpUserDir);\n \n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3OTc5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r432079799", "bodyText": "tempStartFields isn't adding any value here.  could just do...\n        JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n        // We're assuming startMessageJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n        jsonBuilder.addPreformatted(startMessageJsonFields);", "author": "donbourne", "createdAt": "2020-05-28T19:47:39Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -366,57 +369,32 @@ protected static StringBuilder startAuditJson(String hostName, String wlpUserDir\n     protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startAuditJsonFields;\n-\n-        if (tempStartFields != null) {\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        } else {\n-            // This case should never happen because we initialize the field at the beginning of server startup, but what if something goes wrong?\n-            // Should something be returned or have an exception thrown here?\n-        }\n+        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(tempStartFields);\n         return jsonBuilder;\n     }\n \n     protected static JSONObjectBuilder startMessageJsonFields(String hostName, String wlpUserDir, String serverName) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         String tempStartFields = startMessageJsonFields;\n-\n-        if (tempStartFields != null)\n-            jsonBuilder.addPreformatted(tempStartFields);\n-        else {\n-            //@formatter:off\n-            jsonBuilder.addField(LogTraceData.getTypeKeyJSON(true), CollectorConstants.MESSAGES_LOG_EVENT_TYPE, false, false)\n-            .addField(LogTraceData.getHostKeyJSON(true), hostName, false, false)\n-            .addField(LogTraceData.getUserDirKeyJSON(true), wlpUserDir, false, true)\n-            .addField(LogTraceData.getServerNameKeyJSON(true), serverName, false, false);\n-            //@formatter:on\n-            startMessageJsonFields = jsonBuilder.toString();\n-        }\n+        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(tempStartFields);", "originalCommit": "c18473601b73fc97b73624d5ae8e940228ed5983", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex dfbe71704e..b852b6b79f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -366,48 +366,41 @@ public class CollectorJsonHelpers {\n         return sb;\n     }\n \n-    protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAuditJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAuditJsonFields;\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+        // We're assuming startAuditJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startAuditJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startMessageJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startMessageJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startMessageJsonFields;\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+        // We're assuming startMessageJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startMessageJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startTraceJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startTraceJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startTraceJsonFields;\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+        // We're assuming startTraceJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startTraceJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startFFDCJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startFFDCJsonFields;\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+        // We're assuming startFFDCJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n+        jsonBuilder.addPreformatted(startFFDCJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = null;\n+        // We're assuming startAccessLogJsonFields and startAccessLogLogstashCollector will never be null - i.e. updateFieldMappings is always called before this method is called\n         if (format == AccessLogData.KEYS_JSON)\n-            tempStartFields = startAccessLogJsonFields;\n+            jsonBuilder.addPreformatted(startAccessLogJsonFields);\n         else if (format == AccessLogData.KEYS_LOGSTASH)\n-            tempStartFields = startAccessLogLogstashCollector;\n-\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+            jsonBuilder.addPreformatted(startAccessLogLogstashCollector);\n         return jsonBuilder;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ5MzAxNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r432493016", "bodyText": "just noticed... you don't need hostName / wlpUserDir / serverName in the signature of these methods anymore", "author": "donbourne", "createdAt": "2020-05-29T13:46:21Z", "path": "dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java", "diffHunk": "@@ -368,46 +368,39 @@ protected static StringBuilder startAuditJson(String hostName, String wlpUserDir\n \n     protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n-        String tempStartFields = startAuditJsonFields;\n-        // We're assuming tempStartFields will never be null - i.e. updateFieldMappings is always called before this method is called\n-        jsonBuilder.addPreformatted(tempStartFields);\n+        // We're assuming startAuditJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called", "originalCommit": "073d0cbc671c86655635f6137e6eafb601a1efc2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "chunk": "diff --git a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\nindex 7d9c23e811..b852b6b79f 100644\n--- a/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n+++ b/dev/com.ibm.ws.logging/src/com/ibm/ws/logging/collector/CollectorJsonHelpers.java\n\n@@ -366,35 +366,35 @@ public class CollectorJsonHelpers {\n         return sb;\n     }\n \n-    protected static JSONObjectBuilder startAuditJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startAuditJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         // We're assuming startAuditJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n         jsonBuilder.addPreformatted(startAuditJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startMessageJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startMessageJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         // We're assuming startMessageJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n         jsonBuilder.addPreformatted(startMessageJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startTraceJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startTraceJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         // We're assuming startTraceJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n         jsonBuilder.addPreformatted(startTraceJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startFFDCJsonFields(String hostName, String wlpUserDir, String serverName) {\n+    protected static JSONObjectBuilder startFFDCJsonFields() {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         // We're assuming startFFDCJsonFields will never be null - i.e. updateFieldMappings is always called before this method is called\n         jsonBuilder.addPreformatted(startFFDCJsonFields);\n         return jsonBuilder;\n     }\n \n-    protected static JSONObjectBuilder startAccessLogJsonFields(String hostName, String wlpUserDir, String serverName, int format) {\n+    protected static JSONObjectBuilder startAccessLogJsonFields(int format) {\n         JSONObjectBuilder jsonBuilder = new JSONObject.JSONObjectBuilder();\n         // We're assuming startAccessLogJsonFields and startAccessLogLogstashCollector will never be null - i.e. updateFieldMappings is always called before this method is called\n         if (format == AccessLogData.KEYS_JSON)\n"}}, {"oid": "0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "url": "https://github.com/OpenLiberty/open-liberty/commit/0c5eae9bc5746c41ccf17bb64a5471b3bd1c4fc6", "message": "Fix up formatting, simplify the startXXXJsonFields methods, add setters\n\nRemove tempStartFields var\n\nFinal code clean up + fix copyright dates", "committedDate": "2020-05-29T19:16:47Z", "type": "forcePushed"}, {"oid": "5073bf8f330d6fa63e317e750dfdacfaa7dd2fdc", "url": "https://github.com/OpenLiberty/open-liberty/commit/5073bf8f330d6fa63e317e750dfdacfaa7dd2fdc", "message": "Remove case sensitivity for headers, add warning for not providing header name, add null check to prevent NPE to continue after logging warning msg", "committedDate": "2020-06-03T14:38:28Z", "type": "forcePushed"}, {"oid": "87364c2c5fa17af829eb27d0f603b0cc59a7e2bb", "url": "https://github.com/OpenLiberty/open-liberty/commit/87364c2c5fa17af829eb27d0f603b0cc59a7e2bb", "message": "Remove case sensitivity for headers, add warning for not providing header name, add null check to prevent NPE to continue after logging warning msg", "committedDate": "2020-06-03T14:45:40Z", "type": "forcePushed"}, {"oid": "e5102690e0b9f53c46b8e7ac991e95ea2ee3c05b", "url": "https://github.com/OpenLiberty/open-liberty/commit/e5102690e0b9f53c46b8e7ac991e95ea2ee3c05b", "message": "Working basic impl\n\nCondense populateFormatters into two instead of four\n\nMove static var out of AccessLogData, fix configuration checkers\n\nAdd ability to rename/omit specific cookie/header fields\n\nAdd omit cookies/headers functionality and fix field name inconsistency\n\nFix wrong server name and user dir fields being printed in JSON logs\n\nAddress comments\n\nAddress comments\n\nAddress comment\n\ntemporarily disable access log tests to build\n\nFix duplicate fields being printed", "committedDate": "2020-06-04T17:15:38Z", "type": "commit"}, {"oid": "ca22a09aa411d60eda24fb914ad6e96e61c8b48f", "url": "https://github.com/OpenLiberty/open-liberty/commit/ca22a09aa411d60eda24fb914ad6e96e61c8b48f", "message": "Add FAT tests for new jsonAccessLogFields property", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "f129c9daf5c5664835b9d15e20cbde1c7e7aa76f", "url": "https://github.com/OpenLiberty/open-liberty/commit/f129c9daf5c5664835b9d15e20cbde1c7e7aa76f", "message": "Decouple logstashCollector feature from http, fix duplicate headers/cookie bug, address test bugs\n\nFix timing issue in test, add multiple endpoints test\n\nClose BufferedReader and add connection logs\n\nAdd lower timeout threshold for waits in assertNull", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "e5f7c804fbf2f5bc850be045a30132b0e97b3af0", "url": "https://github.com/OpenLiberty/open-liberty/commit/e5f7c804fbf2f5bc850be045a30132b0e97b3af0", "message": "Address thread safety issue with cached start fields, use better method to remove duplicate tokens\n\nRemove removeDuplicates() method, replace with better method that splits tokens into a HashMap while removing duplicates\n\nalways call updateFieldMappings after server config update\n\nFix the startMessageJsonFields method to match the other similar methods", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "ba2bb35585461096406a8a79b2ed07f34cead4a9", "url": "https://github.com/OpenLiberty/open-liberty/commit/ba2bb35585461096406a8a79b2ed07f34cead4a9", "message": "Fix up formatting, simplify the startXXXJsonFields methods, add setters\n\nRemove tempStartFields var\n\nFinal code clean up + fix copyright dates", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"oid": "08dbaa2d5a39ffe9ee6fdc66bce56b833b4af254", "url": "https://github.com/OpenLiberty/open-liberty/commit/08dbaa2d5a39ffe9ee6fdc66bce56b833b4af254", "message": "Remove case sensitivity for headers, add warning for not providing header name, add null check to prevent NPE to continue after logging warning msg", "committedDate": "2020-06-04T17:15:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTEyNA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r435589124", "bodyText": "does this check need to ignore case?", "author": "donbourne", "createdAt": "2020-06-04T22:34:29Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/AccessLogSource.java", "diffHunk": "@@ -344,13 +349,16 @@ private static AccessLogDataFormatter populateCustomFormatters(Map<String, HashS\n                     case \"%C\": builder.add(addCookiesField           (format)); break;\n                     case \"%D\": builder.add(addRequestElapsedTimeField(format)); break;\n                     case \"%i\":\n-                        if (fields.get(\"%i\").contains(\"User-Agent\")) {\n+                        // Error message was printed earlier in populateSetters(), so we just break in this case\n+                        if (fields.get(\"%i\") == null) {\n+                            break;\n+                        }\n+                        if (fields.get(\"%i\").contains(USER_AGENT_HEADER)) {", "originalCommit": "b2087279bd49dc1a876c188d730ef5c98d0ebdb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzNjI2OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r435636268", "bodyText": "nope, the method that lowercases the header names is called before this method (and the USER_AGENT_HEADER var is all lowercase)", "author": "jennifer-c", "createdAt": "2020-06-05T01:03:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU4OTEyNA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5MjY5OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11189#discussion_r435592699", "bodyText": "should just be able to add this info to the Tr.register call in AccessLogSource.java", "author": "donbourne", "createdAt": "2020-06-04T22:44:49Z", "path": "dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/package-info.java", "diffHunk": "@@ -11,5 +11,8 @@\n /**\n  * @version 1.0.16\n  */\n+@TraceOptions(traceGroup = \"logging\", messageBundle = \"com.ibm.ws.logging.internal.resources.LoggingMessages\")", "originalCommit": "b2087279bd49dc1a876c188d730ef5c98d0ebdb9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "chunk": "diff --git a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/package-info.java b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/package-info.java\nindex b7409cc8f4..65a4fe4a52 100644\n--- a/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/package-info.java\n+++ b/dev/com.ibm.ws.transport.http/src/com/ibm/ws/http/logging/source/package-info.java\n\n@@ -11,8 +11,5 @@\n /**\n  * @version 1.0.16\n  */\n-@TraceOptions(traceGroup = \"logging\", messageBundle = \"com.ibm.ws.logging.internal.resources.LoggingMessages\")\n @org.osgi.annotation.versioning.Version(\"1.0.16\")\n-package com.ibm.ws.http.logging.source;\n-\n-import com.ibm.websphere.ras.annotation.TraceOptions;\n+package com.ibm.ws.http.logging.source;\n\\ No newline at end of file\n"}}, {"oid": "5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "url": "https://github.com/OpenLiberty/open-liberty/commit/5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "message": "Change bytesSent field to long instead of String, fix warning messages", "committedDate": "2020-06-05T01:01:50Z", "type": "commit"}, {"oid": "5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "url": "https://github.com/OpenLiberty/open-liberty/commit/5153d71148a4a5d7dd0aa4e8a3d9ba8fdda33c12", "message": "Change bytesSent field to long instead of String, fix warning messages", "committedDate": "2020-06-05T01:01:50Z", "type": "forcePushed"}, {"oid": "f723f426ff85d66b8470fcd8defbe355031f7346", "url": "https://github.com/OpenLiberty/open-liberty/commit/f723f426ff85d66b8470fcd8defbe355031f7346", "message": "Edit TRAS3012W warning message", "committedDate": "2020-06-09T14:28:05Z", "type": "forcePushed"}, {"oid": "7d00d9d6065478d5e94a50540e3008f7555900d7", "url": "https://github.com/OpenLiberty/open-liberty/commit/7d00d9d6065478d5e94a50540e3008f7555900d7", "message": "Edit TRAS3012W warning message, move applyJsonFields method call\n\nMove applyJsonFields method call to after creating handlers\n\nFix message", "committedDate": "2020-06-09T22:05:41Z", "type": "forcePushed"}, {"oid": "b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "url": "https://github.com/OpenLiberty/open-liberty/commit/b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "message": "Edit TRAS3012W warning message, move applyJsonFields method call\n\nMove applyJsonFields method call to after creating handlers\n\nFix message", "committedDate": "2020-06-09T22:07:23Z", "type": "commit"}, {"oid": "b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "url": "https://github.com/OpenLiberty/open-liberty/commit/b0fe9e279dac8b0d8cfe3ef610719d537dab656a", "message": "Edit TRAS3012W warning message, move applyJsonFields method call\n\nMove applyJsonFields method call to after creating handlers\n\nFix message", "committedDate": "2020-06-09T22:07:23Z", "type": "forcePushed"}]}