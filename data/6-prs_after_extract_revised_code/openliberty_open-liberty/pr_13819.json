{"pr_number": 13819, "pr_title": "13818 expirer", "pr_createdAt": "2020-09-08T10:55:34Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/13819", "timeline": [{"oid": "3b7ca2c55aae600db002142cb416ef97bc79dd86", "url": "https://github.com/OpenLiberty/open-liberty/commit/3b7ca2c55aae600db002142cb416ef97bc79dd86", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-08T13:35:05Z", "type": "forcePushed"}, {"oid": "841a51d86f7416dad0cc539918d5aafeb2022bbd", "url": "https://github.com/OpenLiberty/open-liberty/commit/841a51d86f7416dad0cc539918d5aafeb2022bbd", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-08T13:55:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk1NTIwMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13819#discussion_r484955201", "bodyText": "expirey = expiry", "author": "dhaggart", "createdAt": "2020-09-08T14:16:05Z", "path": "dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java", "diffHunk": "@@ -11,151 +11,153 @@\n  *******************************************************************************/\n \n import java.util.Comparator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n import com.ibm.websphere.ras.TraceComponent;\n-import com.ibm.ws.sib.msgstore.gbs.GBSTree;\n-import com.ibm.ws.sib.msgstore.gbs.GBSTree.Iterator;\n+\n import com.ibm.ws.sib.msgstore.MessageStoreConstants;\n import com.ibm.ws.sib.utils.ras.SibTr;\n \n /**\n  * Provides an index for ExpirableReferences by wrapping the underlying tree\n- * indexing mechanism. The operations are modelled on those of java.util.Treemap\n- * but will be implemented by the use of a Generalised Binary Tree algorithm.\n+ * indexing mechanism.\n  */\n public class ExpiryIndex\n {\n     private static TraceComponent tc = SibTr.register(ExpiryIndex.class,\n                                                       MessageStoreConstants.MSG_GROUP,\n                                                       MessageStoreConstants.MSG_BUNDLE);\n \n-    private GBSTree tree = null;\n-    private Iterator iterator = null;\n-    private int size = 0;\n-\n+    private final ConcurrentSkipListSet<ExpirableReference> tree;\n+    \n     /**\n-     * Constructor to create an empty expiry index.\n+     * Create an empty expiry index.\n      */\n-    public ExpiryIndex()\n-    {\n+    public ExpiryIndex() {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"<init>\");\n \n-        // Create new GBS tree with K-factor=2 and NodeWidth=10\n-        tree = new GBSTree(2, 10, new ExpiryComparator(), new ExpiryComparator());\n-\n-        iterator = tree.iterator();\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\");\n+        tree = new ConcurrentSkipListSet<ExpirableReference>(new ExpiryComparator());\n+        \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\", new Object[] {tree});\n     }\n \n     /**\n      * Add an ExpirableReference to the expiry index.\n      * @param expirable an ExpirableReference.\n-     * @return true if the object was added to the index successfully.\n+     * @return true if the ExpirableReference was not already in the set of ExpirableReferences.\n      */\n-    public boolean put(ExpirableReference expirable)\n-    {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"put\", \"ObjId=\" + expirable.getID() + \" ET=\" + expirable.getExpiryTime());\n-\n-        boolean reply = tree.insert(expirable);\n-        if (reply)\n-        {\n-            size++;\n-        }\n+    public boolean put(ExpirableReference expirable) {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"put\", \"ObjecId=\" + expirable.getID() + \" ExpiryTime=\" + expirable.getExpiryTime());\n \n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"put\", \"reply=\" + reply);\n-        return reply;\n+        boolean added = tree.add(expirable);\n+        \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"put\", \"added=\" + added);\n+        return added;\n     }\n \n     /**\n-     * Remove an ExpirableReference from the expiry index. This method\n-     * removes the object referenced by the preceding call to next().\n-     * @return true if the object was removed from the index successfully.\n+     * @return the first ExpirableReference in the expiry index, this is the next ExpirableReference to expire.\n+     * @throws NoSuchElementException if the index is empty.\n      */\n-    public boolean remove()\n-    {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"remove\");\n-\n-        boolean reply = iterator.remove();\n+    public ExpirableReference first() throws NoSuchElementException {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"first\");\n \n-        if (reply)\n-        {\n-            size--;\n-        }\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \"reply=\" + reply);\n-        return reply;\n+        ExpirableReference first = tree.first();\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"first\", first);\n+        return first;\n     }\n \n     /**\n-     * Remove a specific ExpirableReference from the expiry index. This method\n-     * removes the object directly from the tree and does not use the iterator.\n-     * It does not therefore require a prior call to next().\n-     * @param expirable the ExpirableReference to be removed.\n-     * @return true if the object was removed from the index successfully.\n+     * Remove an ExpirableReference from this ExpiryIndex.\n+     *\n+     * @param expirableReference the ExpirableReference to be removed.\n+     * @return true if the ExpirableReference was removed from the index.\n+     */\n+    /**\n+     * @param expirableReference\n+     * @return\n      */\n-    public boolean remove(ExpirableReference expirable)\n+    public boolean remove(ExpirableReference expirableReference)\n     {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"remove\", (expirable == null ? \"null\" : \"ObjId=\" + expirable.getID() + \" ET=\" + expirable.getExpiryTime()));\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"remove\", (expirableReference == null ? \"null\" : \"ObjectId=\" + expirableReference.getID() + \" ExpiryTime=\" + expirableReference.getExpiryTime()));\n \n-        boolean reply = tree.delete(expirable);\n-        if (reply)\n-        {\n-            size--;\n+        if (expirableReference == null) {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \" expirableReference=null\");\n+            return false; \n         }\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \"reply=\" + reply);\n-        return reply;\n+        \n+        boolean removed = tree.remove(expirableReference);\n+                \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \"removed=\" + removed);\n+        return removed;\n     }\n \n     /**\n-     * Re-create the iterator so that a subsequent call to next() will\n-     * start at the beginning of the index.\n+     * Scan all of the ExpirableReferences in the index. If the weak reference is null or if the item indicates \n+     * that it has gone from the store, then remove the expirableReferece from the index.         \n      */\n-    public void resetIterator()\n-    {\n-        iterator.reset();\n-        return;\n+    //TODO Need a custom Consumer containing cleaned!\n+    long cleaned = 0;\n+    Object cleanLock = new Object();\n+    public long clean() {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"clean\", \"isEmpty=\"+tree.isEmpty());\n+    \n+        synchronized (cleanLock) {\n+            cleaned = 0;\n+            tree.forEach (new Consumer<ExpirableReference>() {\n+\n+                @Override\n+                public void accept(ExpirableReference expirableReference) {\n+                    Expirable expirable = (Expirable) expirableReference.get();\n+                    if (expirable == null || !(expirable.expirableIsInStore())) {\n+                        boolean removed = tree.remove(expirableReference);      \n+                        if (removed) cleaned++;\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(tc,\"Removed (cleaned) removed=\"+removed+\" ExpiryTime=\"+ expirableReference.getExpiryTime()+ \" objectId=\"+ expirableReference.getID());\n+                    }\n+\n+                }});\n+        }   \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"clean\", \"isEmpty=\"+tree.isEmpty());\n+        return cleaned;        \n     }\n-\n+    \n     /**\n-     * Return the number of objects in the tree\n-     * @return the number of objects\n+     * Returns {@code true} if there are no ExpirableReferences in the index\n+     * @return {@code true} if this tree contains no ExpirableReferences\n      */\n-    public int size()\n-    {\n-        return size;\n+    public boolean isEmpty() {\n+        return tree.isEmpty();\n     }\n-\n+    \n     /**\n-     * Return the next expiry reference from the expiry index via the iterator.\n-     * @return the expirable reference, or null if there are no more\n-     * items in the index.\n+     * Return the number of ExpirableReferences in the tree.\n+     * \n+     * @return the number of ExpirableReferences\n      */\n-    public ExpirableReference next()\n-    {\n-        return(ExpirableReference) iterator.next();\n+    public int size() {\n+        return tree.size();\n     }\n \n     /**\n-     * This class provides a comparator to be used by the GBS tree algorithms. It\n-     * compares the expiry time and (if necessary) the object IDs of two objects.\n-     * The same comparator is used for inserts, deletes and searches.\n+     * The comparator to be used by the ConcurrentSkipListset of ExpirableReferences.\n      */\n-    private static class ExpiryComparator implements Comparator\n-    {\n+    private static class ExpiryComparator implements Comparator<ExpirableReference> {\n         /**\n-         * Compare two objects and return a value representing their respective\n-         * collating sequence. This uses 'expiry time' as the primary key and 'object ID'\n-         * as the secondary key.\n-         * @param o1 the first object.\n-         * @param o2 the second object.\n-         * @return zero if the objects are equal, -1 if o1 is less than o2, else 1.\n+         * Compare the expiry times of ExpirableReferences, \n+         * in the case of equal times compare the IDs of two ExpirableReferences.\n+         * This allows insertion of ExpirableRefrences with identical expiry times and presents \n+         * the set ordered by expiry time with soonest times first.\n+         * \n+         * @param ref1 the first ExpirableReference.\n+         * @param ref2 the second ExpirableReference.\n+         * @return zero if the ExpirableReferences are equal, -1 if ref1 has a earlier expiry time than ref2 or the expirey times are equal and ref1.Id is less than ref2.Id,", "originalCommit": "841a51d86f7416dad0cc539918d5aafeb2022bbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a2ac2b5a821cb7512dd3244e195241ca28960", "chunk": "diff --git a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java\nindex fe5d2d0085..bbd07ac514 100644\n--- a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java\n+++ b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java\n\n@@ -13,7 +13,6 @@ package com.ibm.ws.sib.msgstore.expiry;\n import java.util.Comparator;\n import java.util.NoSuchElementException;\n import java.util.concurrent.ConcurrentSkipListSet;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Consumer;\n \n import com.ibm.websphere.ras.TraceComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk1NTc1OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13819#discussion_r484955759", "bodyText": "Do you not want to remove trailing whitespace on all lines?", "author": "dhaggart", "createdAt": "2020-09-08T14:16:55Z", "path": "dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java", "diffHunk": "@@ -11,151 +11,153 @@\n  *******************************************************************************/\n \n import java.util.Comparator;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.ConcurrentSkipListSet;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n import com.ibm.websphere.ras.TraceComponent;\n-import com.ibm.ws.sib.msgstore.gbs.GBSTree;\n-import com.ibm.ws.sib.msgstore.gbs.GBSTree.Iterator;\n+\n import com.ibm.ws.sib.msgstore.MessageStoreConstants;\n import com.ibm.ws.sib.utils.ras.SibTr;\n \n /**\n  * Provides an index for ExpirableReferences by wrapping the underlying tree\n- * indexing mechanism. The operations are modelled on those of java.util.Treemap\n- * but will be implemented by the use of a Generalised Binary Tree algorithm.\n+ * indexing mechanism.\n  */\n public class ExpiryIndex\n {\n     private static TraceComponent tc = SibTr.register(ExpiryIndex.class,\n                                                       MessageStoreConstants.MSG_GROUP,\n                                                       MessageStoreConstants.MSG_BUNDLE);\n \n-    private GBSTree tree = null;\n-    private Iterator iterator = null;\n-    private int size = 0;\n-\n+    private final ConcurrentSkipListSet<ExpirableReference> tree;\n+    \n     /**\n-     * Constructor to create an empty expiry index.\n+     * Create an empty expiry index.\n      */\n-    public ExpiryIndex()\n-    {\n+    public ExpiryIndex() {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"<init>\");\n \n-        // Create new GBS tree with K-factor=2 and NodeWidth=10\n-        tree = new GBSTree(2, 10, new ExpiryComparator(), new ExpiryComparator());\n-\n-        iterator = tree.iterator();\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\");\n+        tree = new ConcurrentSkipListSet<ExpirableReference>(new ExpiryComparator());\n+        \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\", new Object[] {tree});\n     }\n \n     /**\n      * Add an ExpirableReference to the expiry index.\n      * @param expirable an ExpirableReference.\n-     * @return true if the object was added to the index successfully.\n+     * @return true if the ExpirableReference was not already in the set of ExpirableReferences.\n      */\n-    public boolean put(ExpirableReference expirable)\n-    {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"put\", \"ObjId=\" + expirable.getID() + \" ET=\" + expirable.getExpiryTime());\n-\n-        boolean reply = tree.insert(expirable);\n-        if (reply)\n-        {\n-            size++;\n-        }\n+    public boolean put(ExpirableReference expirable) {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"put\", \"ObjecId=\" + expirable.getID() + \" ExpiryTime=\" + expirable.getExpiryTime());\n \n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"put\", \"reply=\" + reply);\n-        return reply;\n+        boolean added = tree.add(expirable);\n+        \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"put\", \"added=\" + added);\n+        return added;\n     }\n \n     /**\n-     * Remove an ExpirableReference from the expiry index. This method\n-     * removes the object referenced by the preceding call to next().\n-     * @return true if the object was removed from the index successfully.\n+     * @return the first ExpirableReference in the expiry index, this is the next ExpirableReference to expire.\n+     * @throws NoSuchElementException if the index is empty.\n      */\n-    public boolean remove()\n-    {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"remove\");\n-\n-        boolean reply = iterator.remove();\n+    public ExpirableReference first() throws NoSuchElementException {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"first\");\n \n-        if (reply)\n-        {\n-            size--;\n-        }\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \"reply=\" + reply);\n-        return reply;\n+        ExpirableReference first = tree.first();\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"first\", first);\n+        return first;\n     }\n \n     /**\n-     * Remove a specific ExpirableReference from the expiry index. This method\n-     * removes the object directly from the tree and does not use the iterator.\n-     * It does not therefore require a prior call to next().\n-     * @param expirable the ExpirableReference to be removed.\n-     * @return true if the object was removed from the index successfully.\n+     * Remove an ExpirableReference from this ExpiryIndex.\n+     *\n+     * @param expirableReference the ExpirableReference to be removed.\n+     * @return true if the ExpirableReference was removed from the index.\n+     */\n+    /**\n+     * @param expirableReference\n+     * @return\n      */\n-    public boolean remove(ExpirableReference expirable)\n+    public boolean remove(ExpirableReference expirableReference)\n     {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"remove\", (expirable == null ? \"null\" : \"ObjId=\" + expirable.getID() + \" ET=\" + expirable.getExpiryTime()));\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"remove\", (expirableReference == null ? \"null\" : \"ObjectId=\" + expirableReference.getID() + \" ExpiryTime=\" + expirableReference.getExpiryTime()));\n \n-        boolean reply = tree.delete(expirable);\n-        if (reply)\n-        {\n-            size--;\n+        if (expirableReference == null) {\n+            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \" expirableReference=null\");\n+            return false; \n         }\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \"reply=\" + reply);\n-        return reply;\n+        \n+        boolean removed = tree.remove(expirableReference);\n+                \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"remove\", \"removed=\" + removed);\n+        return removed;\n     }\n \n     /**\n-     * Re-create the iterator so that a subsequent call to next() will\n-     * start at the beginning of the index.\n+     * Scan all of the ExpirableReferences in the index. If the weak reference is null or if the item indicates \n+     * that it has gone from the store, then remove the expirableReferece from the index.         \n      */\n-    public void resetIterator()\n-    {\n-        iterator.reset();\n-        return;\n+    //TODO Need a custom Consumer containing cleaned!\n+    long cleaned = 0;\n+    Object cleanLock = new Object();\n+    public long clean() {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"clean\", \"isEmpty=\"+tree.isEmpty());\n+    \n+        synchronized (cleanLock) {\n+            cleaned = 0;\n+            tree.forEach (new Consumer<ExpirableReference>() {\n+\n+                @Override\n+                public void accept(ExpirableReference expirableReference) {\n+                    Expirable expirable = (Expirable) expirableReference.get();\n+                    if (expirable == null || !(expirable.expirableIsInStore())) {\n+                        boolean removed = tree.remove(expirableReference);      \n+                        if (removed) cleaned++;\n+                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(tc,\"Removed (cleaned) removed=\"+removed+\" ExpiryTime=\"+ expirableReference.getExpiryTime()+ \" objectId=\"+ expirableReference.getID());\n+                    }\n+\n+                }});\n+        }   \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"clean\", \"isEmpty=\"+tree.isEmpty());\n+        return cleaned;        \n     }\n-\n+    \n     /**\n-     * Return the number of objects in the tree\n-     * @return the number of objects\n+     * Returns {@code true} if there are no ExpirableReferences in the index\n+     * @return {@code true} if this tree contains no ExpirableReferences\n      */\n-    public int size()\n-    {\n-        return size;\n+    public boolean isEmpty() {\n+        return tree.isEmpty();\n     }\n-\n+    ", "originalCommit": "841a51d86f7416dad0cc539918d5aafeb2022bbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a2ac2b5a821cb7512dd3244e195241ca28960", "chunk": "diff --git a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java\nindex fe5d2d0085..bbd07ac514 100644\n--- a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java\n+++ b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/ExpiryIndex.java\n\n@@ -13,7 +13,6 @@ package com.ibm.ws.sib.msgstore.expiry;\n import java.util.Comparator;\n import java.util.NoSuchElementException;\n import java.util.concurrent.ConcurrentSkipListSet;\n-import java.util.concurrent.atomic.AtomicInteger;\n import java.util.function.Consumer;\n \n import com.ibm.websphere.ras.TraceComponent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5NDUwMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13819#discussion_r484994503", "bodyText": "Should this AtomicBoolean be final?", "author": "joe-chacko", "createdAt": "2020-09-08T15:06:11Z", "path": "dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java", "diffHunk": "@@ -48,24 +52,20 @@\n     private final static int MAX_DIAG_LOG = 30;\n     private final static int MAX_CONSECUTIVE_FAILURES = 3;\n \n-    // Defect 560281.1\n-    // Use an inner class specific to this class for locking.\n-    private final static class ExpirerLock {}\n-\n-    private final ExpirerLock lockObject = new ExpirerLock();\n-    \n-    // all these updated and read (if required) while holding lockObject\n-    private ExpiryIndex expiryIndex = null;\n-    private Alarm expiryAlarm = null; // The alarm which triggers an index scan\n-    private boolean runEnabled = false; // Allow the alarms to be scheduled\n-    private boolean addEnabled = true; // Allow expirables to be added to the index\n-    private boolean alarmScheduled = false;\n-    private boolean alarming = false;\n+    // The set of Expirables maintained in expiry order, soonest to latest.\n+    private final ExpiryIndex expiryIndex = new ExpiryIndex();\n+   \n+    // The alarm which will perform the next ExpiryIndex scan and its read write lock.\n+    private Alarm expiryAlarm = null;\n+    // Only allow the alarms to be added and scheduled once the Expirer has been started.\n+    private AtomicBoolean started = new AtomicBoolean(false);", "originalCommit": "841a51d86f7416dad0cc539918d5aafeb2022bbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a2ac2b5a821cb7512dd3244e195241ca28960", "chunk": "diff --git a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java\nindex c369259eea..aca9075588 100644\n--- a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java\n+++ b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java\n\n@@ -39,12 +38,12 @@ import com.ibm.ws.sib.utils.ras.SibTr;\n  * Provides an expiry daemon (the Expirer) which maintains an index of\n  * expirable items and handles their demise. The Expirer periodically scans\n  * the expiry index for items which have passed their sell-by date. The appropriate\n- * callbacks are then made to the associated item to trigger its deletion. \n+ * callbacks are then made to the associated item to trigger its deletion.\n  */\n-public class Expirer implements AlarmListener,  XmlConstants \n+public class Expirer implements AlarmListener,  XmlConstants\n {\n-    private static TraceComponent tc = SibTr.register(Expirer.class, \n-                                                      MessageStoreConstants.MSG_GROUP, \n+    private static TraceComponent tc = SibTr.register(Expirer.class,\n+                                                      MessageStoreConstants.MSG_GROUP,\n                                                       MessageStoreConstants.MSG_BUNDLE);\n \n     private final static int BATCH_SIZE = 20;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDk5OTgxOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13819#discussion_r484999818", "bodyText": "Since expirable is a parameter and can't be modified by another thread, there is no reason to place the AtomicBoolean.get() first \u2014 it forces a JVM memory read barrier but this can't affect the value of the next check in the logical conjunction.\nIf expirable is likely to be null, perhaps we should test that first, and avoid any additional expense?", "author": "joe-chacko", "createdAt": "2020-09-08T15:14:04Z", "path": "dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java", "diffHunk": "@@ -91,101 +91,67 @@\n \n     /**\n      * Constructor\n-     * @param ms the MessageStore  \n+     * @param messageStore the MessageStore  \n      */\n-    public Expirer(MessageStoreImpl ms)\n-    {\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"<init>\");\n+    public Expirer(MessageStoreImpl messageStore) {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"<init>\", messageStore);\n \n-        messageStore = ms;\n-        expiryIndex = new ExpiryIndex();\n-\n-        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\", this);\n+        this.messageStore = messageStore;\n+       \n+        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\");\n     }\n \n     /**\n-     * Add an Expirable reference for an item to the expiry index. The reference will be \n-     * added to the index in order of expiry time (which must be set within the Expirable).\n-     * Once added to the index, it will become eligible for expiry processing at the \n-     * designated time.\n-     * \n-     * @param expirable the Expirable item for which a reference is to be added to the expiry index.\n+     * Include a WeakReference to an Expirable in the set of pending Expirables. \n      * \n-     * @return true if the reference was added to the index, false otherwise. False may\n-     * be returned if the item has not yet been added to an item stream and therefore does not \n-     * have a unique ID. False may also be returned if the expirer has not been started.\n-     * @throws SevereMessageStoreException \n+     * @param expirable the Expirable to be added to the set of Expirables.\n+     * @throws SevereMessageStoreException if the Expirable is already added.\n      */ \n-    public final boolean addExpirable(Expirable expirable) throws SevereMessageStoreException\n+    public final void addExpirable(Expirable expirable) throws SevereMessageStoreException\n     {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())\n         {\n             SibTr.entry(tc, \"addExpirable\",\n                        \"objId=\"\n                        + (expirable == null ? \"null\" : String.valueOf(expirable.expirableGetID()))\n-                       + \" addEnabled=\"\n-                       + addEnabled);\n+                       + \" started=\"+started);\n         }\n \n-        boolean reply = false;\n-\n         // Ignore this entry if the expirer has ended or the given entry is null\n-        if (addEnabled && expirable != null)\n-        {\n-            long expiryTime = expirable.expirableGetExpiryTime();\n-\n+        // or the referenced item has already gone from the message store.     \n+        if (started.get() && expirable != null && expirable.expirableIsInStore()){", "originalCommit": "841a51d86f7416dad0cc539918d5aafeb2022bbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a2ac2b5a821cb7512dd3244e195241ca28960", "chunk": "diff --git a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java\nindex c369259eea..aca9075588 100644\n--- a/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java\n+++ b/dev/com.ibm.ws.messaging.msgstore/src/com/ibm/ws/sib/msgstore/expiry/Expirer.java\n\n@@ -91,22 +90,22 @@ public class Expirer implements AlarmListener,  XmlConstants\n \n     /**\n      * Constructor\n-     * @param messageStore the MessageStore  \n+     * @param messageStore the MessageStore\n      */\n     public Expirer(MessageStoreImpl messageStore) {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, \"<init>\", messageStore);\n \n         this.messageStore = messageStore;\n-       \n+\n         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, \"<init>\");\n     }\n \n     /**\n-     * Include a WeakReference to an Expirable in the set of pending Expirables. \n-     * \n+     * Include a WeakReference to an Expirable in the set of pending Expirables.\n+     *\n      * @param expirable the Expirable to be added to the set of Expirables.\n      * @throws SevereMessageStoreException if the Expirable is already added.\n-     */ \n+     */\n     public final void addExpirable(Expirable expirable) throws SevereMessageStoreException\n     {\n         if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())\n"}}, {"oid": "216a2ac2b5a821cb7512dd3244e195241ca28960", "url": "https://github.com/OpenLiberty/open-liberty/commit/216a2ac2b5a821cb7512dd3244e195241ca28960", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-09T14:53:02Z", "type": "forcePushed"}, {"oid": "3f67294128da9b3f616d693c915b881db407e80e", "url": "https://github.com/OpenLiberty/open-liberty/commit/3f67294128da9b3f616d693c915b881db407e80e", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-09T15:00:22Z", "type": "forcePushed"}, {"oid": "094a63be90b0da795e296130c8595bbb1821e29c", "url": "https://github.com/OpenLiberty/open-liberty/commit/094a63be90b0da795e296130c8595bbb1821e29c", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-09T16:02:57Z", "type": "forcePushed"}, {"oid": "02f41e458806063ec113d76a9f4587321055b77f", "url": "https://github.com/OpenLiberty/open-liberty/commit/02f41e458806063ec113d76a9f4587321055b77f", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-11T16:53:55Z", "type": "forcePushed"}, {"oid": "6045fdf8babdd99f9c32d957fcd2afc9f4f28dd9", "url": "https://github.com/OpenLiberty/open-liberty/commit/6045fdf8babdd99f9c32d957fcd2afc9f4f28dd9", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-12T09:19:18Z", "type": "forcePushed"}, {"oid": "515253ad4c0a0e6fecbc1e7e901ff282852e3cd7", "url": "https://github.com/OpenLiberty/open-liberty/commit/515253ad4c0a0e6fecbc1e7e901ff282852e3cd7", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-15T13:03:26Z", "type": "forcePushed"}, {"oid": "209a2b0038674c3615b213fde82bf960ccb53564", "url": "https://github.com/OpenLiberty/open-liberty/commit/209a2b0038674c3615b213fde82bf960ccb53564", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-16T08:13:19Z", "type": "forcePushed"}, {"oid": "414b1b8fd58dba0df041c010e310e181fc8e550b", "url": "https://github.com/OpenLiberty/open-liberty/commit/414b1b8fd58dba0df041c010e310e181fc8e550b", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-17T14:43:41Z", "type": "commit"}, {"oid": "414b1b8fd58dba0df041c010e310e181fc8e550b", "url": "https://github.com/OpenLiberty/open-liberty/commit/414b1b8fd58dba0df041c010e310e181fc8e550b", "message": "Replace GBSTree in item Expirer.", "committedDate": "2020-09-17T14:43:41Z", "type": "forcePushed"}, {"oid": "50778fc60b3ae94219ac93c4bb0607eefcded0d8", "url": "https://github.com/OpenLiberty/open-liberty/commit/50778fc60b3ae94219ac93c4bb0607eefcded0d8", "message": "Tracing", "committedDate": "2020-09-22T13:00:26Z", "type": "forcePushed"}, {"oid": "84d0793246cfe3888ef08c15911ed327ffda03d8", "url": "https://github.com/OpenLiberty/open-liberty/commit/84d0793246cfe3888ef08c15911ed327ffda03d8", "message": "Tracing", "committedDate": "2020-09-23T10:23:06Z", "type": "forcePushed"}, {"oid": "6428567066ce39a1015aed743dda135250f4da97", "url": "https://github.com/OpenLiberty/open-liberty/commit/6428567066ce39a1015aed743dda135250f4da97", "message": "Tracing", "committedDate": "2020-09-24T10:35:19Z", "type": "commit"}, {"oid": "6428567066ce39a1015aed743dda135250f4da97", "url": "https://github.com/OpenLiberty/open-liberty/commit/6428567066ce39a1015aed743dda135250f4da97", "message": "Tracing", "committedDate": "2020-09-24T10:35:19Z", "type": "forcePushed"}]}