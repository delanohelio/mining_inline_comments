{"pr_number": 13113, "pr_title": "AMR claim in liberty", "pr_createdAt": "2020-07-20T21:31:50Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/13113", "timeline": [{"oid": "b59b192840dadf61fd7e4d84605bd119c6db1eb6", "url": "https://github.com/OpenLiberty/open-liberty/commit/b59b192840dadf61fd7e4d84605bd119c6db1eb6", "message": "Interface changes to other files", "committedDate": "2020-07-21T01:05:37Z", "type": "forcePushed"}, {"oid": "b033536d4bf3f8d5ab32036140b640357ae642b3", "url": "https://github.com/OpenLiberty/open-liberty/commit/b033536d4bf3f8d5ab32036140b640357ae642b3", "message": "Fixed propertyNamings", "committedDate": "2020-07-21T23:23:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyMzcwOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r461823709", "bodyText": "Please consider using spaces instead of tabs and ensure correct spacing.", "author": "teddyjtorres", "createdAt": "2020-07-28T19:34:51Z", "path": "dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java", "diffHunk": "@@ -160,6 +164,14 @@ private void setClaimsUsingTheConfig(JwtConfig jwtConfig) throws InvalidBuilderE\n         if (jwtConfig.getSharedKey() != null) {\n             sharedKey = jwtConfig.getSharedKey();\n         }\n+        \n+        if (jwtConfig.getAMRAttributes() != null) {\n+        \ttry {", "originalCommit": "8550ee341ed627f6a1ac17beba5b3584115e2858", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "31b940926fec72f5ade10ad09db24ebd90b9b6ab", "chunk": "diff --git a/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java b/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java\nindex 4fcb1e2334..096a3c31ce 100644\n--- a/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java\n+++ b/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java\n\n@@ -165,14 +165,14 @@ public class BuilderImpl implements Builder {\n             sharedKey = jwtConfig.getSharedKey();\n         }\n         \n-        if (jwtConfig.getAMRAttributes() != null) {\n-        \ttry {\n-        \t\tcheckAmrAttrInSubject(jwtConfig.getAMRAttributes());\n-        \t} catch (Exception e) {\n-\t\t\t\t// TODO Auto-generated catch block\n-\t\t\t}\n+        List<String> amrAttr = jwtConfig.getAMRAttributes();// getProperty(amrAttributes);\n+        if (amrAttr != null) {\n+            try {\n+                checkAmrAttrInSubject(amrAttr);\n+            } catch (Exception e) {\n+                // TODO Auto-generated catch block\n+            }\n         }\n-\n     }\n \n     private JwtConfig getTheServiceConfig(String builderConfigId) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgyNDY0Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r461824642", "bodyText": "Please consider using spaces instead of tabs and ensure correct spacing.", "author": "teddyjtorres", "createdAt": "2020-07-28T19:36:30Z", "path": "dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java", "diffHunk": "@@ -814,5 +826,36 @@ private Builder copyClaimsMap(Map<String, Object> map) throws InvalidClaimExcept\n         }\n         return this;\n     }\n+    \n+    /** \n+     * Checks the attributes provided exists in the subject, if so add it to the claims\n+     * as \"amr\" values\n+     * \n+     * @param amrAttr\n+     * @throws Exception\n+     */\n+    private void checkAmrAttrInSubject(List<String> amrAttr) throws Exception {\n+    \tSubject subj = WSSubject.getRunAsSubject();\n+    \tList<Object> amrValues= new ArrayList<Object>();\n+    \tif (subj != null) {\n+    \t\tWSCredential wscred = getWSCredential(subj);", "originalCommit": "8550ee341ed627f6a1ac17beba5b3584115e2858", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "31b940926fec72f5ade10ad09db24ebd90b9b6ab", "chunk": "diff --git a/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java b/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java\nindex 4fcb1e2334..096a3c31ce 100644\n--- a/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java\n+++ b/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/BuilderImpl.java\n\n@@ -827,27 +827,30 @@ public class BuilderImpl implements Builder {\n         return this;\n     }\n     \n-    /** \n-     * Checks the attributes provided exists in the subject, if so add it to the claims\n-     * as \"amr\" values\n-     * \n-     * @param amrAttr\n-     * @throws Exception\n-     */\n-    private void checkAmrAttrInSubject(List<String> amrAttr) throws Exception {\n-    \tSubject subj = WSSubject.getRunAsSubject();\n-    \tList<Object> amrValues= new ArrayList<Object>();\n-    \tif (subj != null) {\n-    \t\tWSCredential wscred = getWSCredential(subj);\n-    \t\tfor (String attr: amrAttr) {\n-    \t\t\tObject subjValue = wscred != null ? wscred.get(attr) : null;\n-    \t\t\tif (subjValue != null)\n-    \t\t\t\tamrValues.add(subjValue);\n-    \t\t}\n-    \t}\n-\t\tgetClaims().put(\"amr\", amrValues);\n-    }\n-    \n+\t/**\n+\t * Checks the attributes provided exists in the subject, if so add it to the\n+\t * claims as \"amr\" values\n+\t * \n+\t * @param amrAttr\n+\t * @throws Exception\n+\t */\n+\tprivate void checkAmrAttrInSubject(List<String> amrAttr) throws Exception {\n+\t    Subject subj = WSSubject.getRunAsSubject();\n+\t    List<Object> amrValues = new ArrayList<Object>();\n+\t    if (subj != null) {\n+            WSCredential wscred = getWSCredential(subj);\n+            for (String attr : amrAttr) {\n+                Object subjValue = wscred != null ? wscred.get(attr) : null;\n+                if (subjValue != null)\n+                   amrValues.add(subjValue);\n+            }\n+        }\n+\t    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+\t\t    Tr.debug(tc, \"Builder Claims Key: amr: [\" + amrValues + \"]\");\n+\t\t}\n+        getClaims().put(\"amr\", amrValues);\n+\t}\n+\n \tprivate WSCredential getWSCredential(Subject subject) {\n \t\tWSCredential wsCredential = null;\n \t\tSet<WSCredential> wsCredentials = subject.getPublicCredentials(WSCredential.class);\n"}}, {"oid": "31b940926fec72f5ade10ad09db24ebd90b9b6ab", "url": "https://github.com/OpenLiberty/open-liberty/commit/31b940926fec72f5ade10ad09db24ebd90b9b6ab", "message": "Added all test for builder", "committedDate": "2020-07-30T21:31:44Z", "type": "forcePushed"}, {"oid": "7385ef949eb2f7537b64e7173959194349901524", "url": "https://github.com/OpenLiberty/open-liberty/commit/7385ef949eb2f7537b64e7173959194349901524", "message": "Fixed attr in the label", "committedDate": "2020-07-30T22:05:36Z", "type": "forcePushed"}, {"oid": "9ec7dceeff9772171433168ae796d502d05eda86", "url": "https://github.com/OpenLiberty/open-liberty/commit/9ec7dceeff9772171433168ae796d502d05eda86", "message": "Fixed attr in the label", "committedDate": "2020-07-30T22:11:04Z", "type": "forcePushed"}, {"oid": "db49fbf6f6cd3fc7ec4eae594189be0e36ef1f11", "url": "https://github.com/OpenLiberty/open-liberty/commit/db49fbf6f6cd3fc7ec4eae594189be0e36ef1f11", "message": "Fixed attr in the label", "committedDate": "2020-07-30T22:56:53Z", "type": "forcePushed"}, {"oid": "7f7934a0bd92f51a4562dd861b50201e922e9361", "url": "https://github.com/OpenLiberty/open-liberty/commit/7f7934a0bd92f51a4562dd861b50201e922e9361", "message": "Added all tests for builder", "committedDate": "2020-08-04T17:32:57Z", "type": "forcePushed"}, {"oid": "369d4c9a99ef9e327cd5852547cb3b6786ac335c", "url": "https://github.com/OpenLiberty/open-liberty/commit/369d4c9a99ef9e327cd5852547cb3b6786ac335c", "message": "Fixed spacing for API class", "committedDate": "2020-08-04T17:43:00Z", "type": "forcePushed"}, {"oid": "fa6a8e34152330f3326a03cec9539cd9e30356ef", "url": "https://github.com/OpenLiberty/open-liberty/commit/fa6a8e34152330f3326a03cec9539cd9e30356ef", "message": "Fixed spacing for API class", "committedDate": "2020-08-04T17:46:53Z", "type": "forcePushed"}, {"oid": "3608162f609dc7ba79a25cb66210cb89dd75040d", "url": "https://github.com/OpenLiberty/open-liberty/commit/3608162f609dc7ba79a25cb66210cb89dd75040d", "message": "Fixed spacing and copyright", "committedDate": "2020-08-04T18:14:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTI0OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r461839249", "bodyText": "There is a potential for regression in this logic. A previous JWT that included an \"amr\" claim could have been accepted prior to these changes and it will now be rejected.\nPlease review if the intention is to make the amr claim optional if the jwtConsumer has not been configured with a list of AMRs to validate.", "author": "teddyjtorres", "createdAt": "2020-07-28T19:55:52Z", "path": "dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/ConsumerUtil.java", "diffHunk": "@@ -687,5 +695,56 @@ String createDateString(NumericDate date) {\n \t\t// milliseconds\n \t\treturn timeUtils.createDateString(1000 * date.getValue());\n \t}\n+\t\n+\t/**\n+\t * Helper method to get the AMR Claim from the jwtClaims.This method checks\n+\t * if the value is a string and return singletonList or the ArrayList of\n+\t * amrClaims. This is called in validateClaims method\n+\t *\n+\t */\n+\tList<String> getJwtAMRList(JwtClaims jwtClaims) throws MalformedClaimException {\n+\t\tString claimName = \"amr\";\n+\t\tObject amrObject = jwtClaims.getClaimValue(claimName);\n+\t\tif (amrObject instanceof String) {\n+\t\t\treturn Collections.singletonList(jwtClaims.getStringClaimValue(claimName));\n+\t\t} else if (!(amrObject instanceof List) && amrObject != null) {\n+\t\t\tthrow new MalformedClaimException(\n+\t\t\t\t\t\"The value of the 'amr' claim is not an array of strings or a single string value.\");\n+\t\t} else {\n+\t\t\treturn jwtClaims.getStringListClaimValue(claimName);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Verifies that values specified in AMR claim is contained in the\n+\t * authenticationMethodsReferences list. If allowedAMRClaim is not an array\n+\t * then jwtClaims can contain more than required values. If not, then the\n+\t * jwtClaimvalues must be a exact match of an element in the array.\n+\t */\n+\tboolean validateAMRClaim(List<String> allowedAmrClaim, List<String> jwtAMRClaims) {\n+\t\tboolean valid = false;\n+\t\tif (allowedAmrClaim != null && jwtAMRClaims != null) {\n+\t\t\t// If it is not array just check if jwtClaim containsAll and not\n+\t\t\t// equals\n+\t\t\tif (allowedAmrClaim.size() == 1) {\n+\t\t\t\tList<String> allowedAMRSingle = Arrays.asList(allowedAmrClaim.get(0).split(\" \"));\n+\t\t\t\tif (jwtAMRClaims.containsAll(allowedAMRSingle)) {\n+\t\t\t\t\tvalid = true;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tfor (String allowedAMR : allowedAmrClaim) {\n+\t\t\t\t\tList<String> allowedAMRSingle = Arrays.asList(allowedAMR.split(\" \"));\n+\t\t\t\t\tif (jwtAMRClaims.equals(allowedAMRSingle)) {\n+\t\t\t\t\t\tvalid = true;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n+\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else if (allowedAmrClaim == null && (jwtAMRClaims == null || jwtAMRClaims.isEmpty())) {", "originalCommit": "8550ee341ed627f6a1ac17beba5b3584115e2858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg4ODA3Mg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r461888072", "bodyText": "@chunlongliang-ibm This is a default behavior change. Is this what was intended?", "author": "teddyjtorres", "createdAt": "2020-07-28T21:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MzM2OQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r466643369", "bodyText": "This is a default behavior change and cannot be merged in as coded. A previous JWT that included an \"amr\" claim could have been accepted prior to these changes and it will now be rejected even when a consumer has not been configured with amrValues. Please ensure that a JWT that contains an amr claim is not rejected when amrValues is not configured.", "author": "teddyjtorres", "createdAt": "2020-08-06T19:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1NzA1Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r466657056", "bodyText": "I can get rid of this code here and it would take that required part off. @chunlongliang-ibm can confirm if that is what it was intended", "author": "AlvinChacko", "createdAt": "2020-08-06T20:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njc1OTg0Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r466759846", "bodyText": "Fixed it in my new code. Although I have a logic that is if the amrConfig is not specified, then validation returns true. Which means if the amrConfig is specified and the jwt doesnt include amr then the validation will fail. Let me know if I need to add any logic there.", "author": "AlvinChacko", "createdAt": "2020-08-07T00:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgzOTI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b27a3c97bccc3fb6faeb2eae1821bd83072b26eb", "chunk": "diff --git a/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/ConsumerUtil.java b/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/ConsumerUtil.java\nindex dd9cbdafd6..8852af908a 100644\n--- a/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/ConsumerUtil.java\n+++ b/dev/com.ibm.ws.security.jwt/src/com/ibm/ws/security/jwt/internal/ConsumerUtil.java\n\n@@ -53,698 +54,739 @@ import com.ibm.ws.ssl.KeyStoreService;\n import com.ibm.wsspi.kernel.service.utils.AtomicServiceReference;\n \n public class ConsumerUtil {\n-\tprivate static final TraceComponent tc = Tr.register(ConsumerUtil.class);\n-\tprivate static final Class<?> thisClass = ConsumerUtil.class;\n-\n-\tprivate AtomicServiceReference<KeyStoreService> keyStoreService = null;\n-\n-\tprivate static TimeUtils timeUtils = new TimeUtils(TimeUtils.YearMonthDateHourMinSecZone);\n-\tprivate final JtiNonceCache jtiCache = new JtiNonceCache();\n-\tpublic final static String ISSUER = \"mp.jwt.verify.issuer\";\n-\tpublic final static String PUBLIC_KEY = \"mp.jwt.verify.publickey\";\n-\tpublic final static String KEY_LOCATION = \"mp.jwt.verify.publickey.location\";\n-\n-\tpublic ConsumerUtil(AtomicServiceReference<KeyStoreService> kss) {\n-\t\tkeyStoreService = kss;\n-\t}\n-\n-\tpublic JwtToken parseJwt(String jwtString, JwtConsumerConfig config) throws Exception {\n-\t\treturn parseJwt(jwtString, config, null);\n-\t}\n-\n-\tpublic JwtToken parseJwt(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n-\t\tJwtContext jwtContext = parseJwtAndGetJwtContext(jwtString, config, properties);\n-\t\tJwtTokenConsumerImpl jwtToken = new JwtTokenConsumerImpl(jwtContext);\n-\t\tcheckForReusedJwt(jwtToken, config);\n-\t\treturn jwtToken;\n-\t}\n-\n-\tJwtContext parseJwtAndGetJwtContext(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n-\t\tJwtContext jwtContext = parseJwtWithoutValidation(jwtString, config);\n-\t\tif (config.isValidationRequired()) {\n-\t\t\tjwtContext = getSigningKeyAndParseJwtWithValidation(jwtString, config, jwtContext, properties);\n-\t\t}\n-\t\treturn jwtContext;\n-\t}\n-\n-\tJwtContext getSigningKeyAndParseJwtWithValidation(String jwtString, JwtConsumerConfig config, JwtContext jwtContext,\n-\t\t\tMap properties) throws Exception {\n-\t\tKey signingKey = getSigningKey(config, jwtContext, properties);\n-\t\treturn parseJwtWithValidation(jwtString, jwtContext, config, signingKey, properties);\n-\t}\n-\n-\t/**\n-\t * Throws an exception if JWTs are not allowed to be reused (as configured by\n-\t * the provided config option) AND a token with a matching \"jti\" and \"issuer\"\n-\t * claim already exists in the cache.\n-\t */\n-\tvoid checkForReusedJwt(JwtTokenConsumerImpl jwt, JwtConsumerConfig config) throws InvalidTokenException {\n-\t\t// Only throw an error if tokens are not allowed to be reused\n-\t\tif (!config.getTokenReuse()) {\n-\t\t\tthrowExceptionIfJwtReused(jwt);\n-\t\t}\n-\t}\n-\n-\tvoid throwExceptionIfJwtReused(JwtTokenConsumerImpl jwt) throws InvalidTokenException {\n-\t\tif (jtiCache.contains(jwt)) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JWT token can only be submitted once. The issuer is \" + jwt.getClaims().getIssuer()\n-\t\t\t\t\t\t+ \", and JTI is \" + jwt.getClaims().getJwtId());\n-\t\t\t}\n-\t\t\tString errorMsg = Tr.formatMessage(tc, \"JWT_DUP_JTI_ERR\",\n-\t\t\t\t\tnew Object[] { jwt.getClaims().getIssuer(), jwt.getClaims().getJwtId() });\n-\t\t\tthrow new InvalidTokenException(errorMsg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Get the appropriate signing key based on the signature algorithm specified in\n-\t * the config.\n-\t */\n-\tKey getSigningKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\tif (config == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JWT consumer config object is null\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tsigningKey = getSigningKeyBasedOnSignatureAlgorithm(config, jwtContext, properties);\n-\t\tif (signingKey == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"A signing key could not be found\");\n-\t\t\t}\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getSigningKeyBasedOnSignatureAlgorithm(JwtConsumerConfig config, JwtContext jwtContext, Map properties)\n-\t\t\tthrows KeyException {\n-\t\tKey signingKey = null;\n-\t\tString sigAlg = config.getSignatureAlgorithm();\n-\n-\t\tif (Constants.SIGNATURE_ALG_HS256.equals(sigAlg)) {\n-\t\t\tsigningKey = getSigningKeyForHS256(config);\n-\t\t} else if (Constants.SIGNATURE_ALG_RS256.equals(sigAlg)) {\n-\t\t\tsigningKey = getSigningKeyForRS256(config, jwtContext, properties);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getSigningKeyForHS256(JwtConsumerConfig config) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\ttry {\n-\t\t\tsigningKey = getSharedSecretKey(config);\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_SHARED_KEY\", new Object[] { e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\t/**\n-\t * Creates a Key object from the shared key specified in the provided\n-\t * configuration.\n-\t */\n-\tKey getSharedSecretKey(JwtConsumerConfig config) throws KeyException {\n-\t\tif (config == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JWT consumer config object is null\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tString sharedKey = config.getSharedKey();\n-\t\treturn createKeyFromSharedKey(sharedKey);\n-\t}\n-\n-\tKey createKeyFromSharedKey(String sharedKey) throws KeyException {\n-\t\tif (sharedKey == null || sharedKey.isEmpty()) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_MISSING_SHARED_KEY\");\n-\t\t\tthrow new KeyException(msg);\n-\t\t}\n-\t\ttry {\n-\t\t\treturn new HmacKey(sharedKey.getBytes(Constants.UTF_8));\n-\t\t} catch (UnsupportedEncodingException e) {\n-\t\t\t// Should not happen - UTF-8 should be supported\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Caught exception getting shared key bytes: \" + e.getLocalizedMessage());\n-\t\t\t}\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\tboolean isPublicKeyPropsPresent(Map props) {\n-\t\tif (props == null) {\n-\t\t\treturn false;\n-\t\t}\n-\t\treturn props.get(PUBLIC_KEY) != null || props.get(KEY_LOCATION) != null;\n-\t}\n-\n-\tKey getSigningKeyForRS256(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\tif (config.getJwkEnabled() || (config.getTrustedAlias() == null && isPublicKeyPropsPresent(properties))) { // need\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// change\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// consider\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// MP-Config\n-\t\t\tsigningKey = getKeyForJwkEnabled(config, jwtContext, properties);\n-\t\t} else {\n-\t\t\tsigningKey = getKeyForJwkDisabled(config);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getKeyForJwkEnabled(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\ttry {\n-\t\t\tsigningKey = getJwksKey(config, jwtContext, properties);\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_JWK_KEY\",\n-\t\t\t\t\tnew Object[] { config.getJwkEndpointUrl(), e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tprotected Key getJwksKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws Exception {\n-\t\tJsonWebStructure jwtHeader = getJwtHeader(jwtContext);\n-\t\tString kid = jwtHeader.getKeyIdHeaderValue();\n-\t\tJwKRetriever jwkRetriever = null;\n-\t\tif (properties != null) {\n-\t\t\tString publickey = (String) properties.get(PUBLIC_KEY);\n-\t\t\tString keyLocation = (String) properties.get(KEY_LOCATION);\n-\t\t\tif (publickey != null || keyLocation != null) {\n-\t\t\t\tjwkRetriever = new JwKRetriever(config.getId(), config.getSslRef(), config.getJwkEndpointUrl(),\n-\t\t\t\t\t\tconfig.getJwkSet(), JwtUtils.getSSLSupportService(), config.isHostNameVerificationEnabled(),\n-\t\t\t\t\t\tnull, null, publickey, keyLocation);\n-\t\t\t}\n-\t\t}\n-\t\tif (jwkRetriever == null) {\n-\t\t\tjwkRetriever = new JwKRetriever(config.getId(), config.getSslRef(), config.getJwkEndpointUrl(),\n-\t\t\t\t\tconfig.getJwkSet(), JwtUtils.getSSLSupportService(), config.isHostNameVerificationEnabled(), null,\n-\t\t\t\t\tnull);\n-\t\t}\n-\t\tKey signingKey = jwkRetriever.getPublicKeyFromJwk(kid, null,\n-\t\t\t\tconfig.getUseSystemPropertiesForHttpClientConnections()); // only kid or x5t will work but not both\n-\t\treturn signingKey;\n-\t}\n-\n-\tJsonWebStructure getJwtHeader(JwtContext jwtContext) throws Exception {\n-\t\tList<JsonWebStructure> jsonStructures = jwtContext.getJoseObjects();\n-\t\tif (jsonStructures == null || jsonStructures.isEmpty()) {\n-\t\t\t// TODO - NLS message\n-\t\t    throw new Exception(\"Invalid JsonWebStructure\");\n-\t\t}\n-\t\tJsonWebStructure jwtHeader = jsonStructures.get(0);\n-\t\tdebugJwtHeader(jwtHeader);\n-\t\treturn jwtHeader;\n-\t}\n-\n-\tvoid debugJwtHeader(JsonWebStructure jwtHeader) {\n-\t\tif (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"JsonWebStructure class: \" + jwtHeader.getClass().getName() + \" data:\" + jwtHeader);\n-\t\t\tif (jwtHeader instanceof JsonWebSignature) {\n-\t\t\t\tJsonWebSignature signature = (JsonWebSignature) jwtHeader;\n-\t\t\t\tTr.debug(tc, \"JsonWebSignature alg: \" + signature.getAlgorithmHeaderValue() + \" 3rd:'\"\n-\t\t\t\t\t\t+ signature.getEncodedSignature() + \"'\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tKey getKeyForJwkDisabled(JwtConsumerConfig config) throws KeyException {\n-\t\tKey signingKey = null;\n-\t\tString trustedAlias = config.getTrustedAlias();\n-\t\tString trustStoreRef = config.getTrustStoreRef();\n-\t\ttry {\n-\t\t\tsigningKey = getPublicKey(trustedAlias, trustStoreRef, Constants.SIGNATURE_ALG_RS256);\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_PUBLIC_KEY\",\n-\t\t\t\t\tnew Object[] { trustedAlias, trustStoreRef, e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\t/**\n-\t * Creates a Key object from the certificate stored in the trust store and alias\n-\t * provided.\n-\t */\n-\tKey getPublicKey(String trustedAlias, String trustStoreRef, String signatureAlgorithm)\n-\t\t\tthrows KeyStoreServiceException, KeyException {\n-\t\tKey signingKey = getPublicKeyFromKeystore(trustedAlias, trustStoreRef, signatureAlgorithm);\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"Trusted alias: \" + trustedAlias + \", Truststore: \" + trustStoreRef);\n-\t\t\tTr.debug(tc, \"RSAPublicKey: \" + (signingKey instanceof RSAPublicKey));\n-\t\t}\n-\t\tif (signingKey != null && !(signingKey instanceof RSAPublicKey)) {\n-\t\t\tsigningKey = null;\n-\t\t}\n-\t\treturn signingKey;\n-\t}\n-\n-\tKey getPublicKeyFromKeystore(String trustedAlias, String trustStoreRef, String signatureAlgorithm)\n-\t\t\tthrows KeyException {\n-\t\ttry {\n-\t\t\tif (keyStoreService == null) {\n-\t\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TRUSTSTORE_SERVICE_NOT_AVAILABLE\");\n-\t\t\t\tthrow new KeyStoreServiceException(msg);\n-\t\t\t}\n-\t\t\treturn JwtUtils.getPublicKey(trustedAlias, trustStoreRef, keyStoreService.getService());\n-\t\t} catch (Exception e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_NULL_SIGNING_KEY_WITH_ERROR\",\n-\t\t\t\t\tnew Object[] { signatureAlgorithm, Constants.SIGNING_KEY_X509, e.getLocalizedMessage() });\n-\t\t\tthrow new KeyException(msg, e);\n-\t\t}\n-\t}\n-\n-\tprotected JwtContext parseJwtWithoutValidation(String jwtString, JwtConsumerConfig config) throws Exception {\n-\t\tif (jwtString == null || jwtString.isEmpty()) {\n-\t\t\tString errorMsg = Tr.formatMessage(tc, \"JWT_CONSUMER_NULL_OR_EMPTY_STRING\",\n-\t\t\t\t\tnew Object[] { config.getId(), jwtString });\n-\t\t\tthrow new InvalidTokenException(errorMsg);\n-\t\t}\n-\t\tJwtConsumerBuilder builder = initializeJwtConsumerBuilderWithoutValidation(config);\n-\t\tJwtConsumer firstPassJwtConsumer = builder.build();\n-\t\treturn firstPassJwtConsumer.process(jwtString);\n-\t}\n-\n-\tprotected JwtContext parseJwtWithValidation(String jwtString, JwtContext jwtContext, JwtConsumerConfig config,\n-\t\t\tKey key, Map properties) throws Exception {\n-\t\tJwtClaims jwtClaims = jwtContext.getJwtClaims();\n-\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"Key from config: \" + key);\n-\t\t}\n-\n-\t\tvalidateClaims(jwtClaims, jwtContext, config, properties);\n-\t\tvalidateSignatureAlgorithmWithKey(config, key);\n-\n-\t\tJwtConsumerBuilder consumerBuilder = initializeJwtConsumerBuilderWithValidation(config, jwtClaims, key);\n-\t\tJwtConsumer jwtConsumer = consumerBuilder.build();\n-\t\treturn processJwtStringWithConsumer(jwtConsumer, jwtString);\n-\t}\n-\n-\tJwtConsumerBuilder initializeJwtConsumerBuilderWithoutValidation(JwtConsumerConfig config) {\n-\t\tJwtConsumerBuilder builder = new JwtConsumerBuilder();\n-\t\tbuilder.setSkipAllValidators();\n-\t\tbuilder.setDisableRequireSignature();\n-\t\tbuilder.setSkipSignatureVerification();\n-\t\tbuilder.setAllowedClockSkewInSeconds((int) ((config.getClockSkew()) / 1000));\n-\t\treturn builder;\n-\t}\n-\n-\tJwtConsumerBuilder initializeJwtConsumerBuilderWithValidation(JwtConsumerConfig config, JwtClaims jwtClaims,\n-\t\t\tKey key) throws MalformedClaimException {\n-\t\tJwtConsumerBuilder builder = new JwtConsumerBuilder();\n-\t\tbuilder.setExpectedIssuer(jwtClaims.getIssuer());\n-\t\tbuilder.setSkipDefaultAudienceValidation();\n-\t\tbuilder.setRequireExpirationTime();\n-\t\tbuilder.setVerificationKey(key);\n-\t\tbuilder.setRelaxVerificationKeyValidation();\n-\t\tbuilder.setAllowedClockSkewInSeconds((int) (config.getClockSkew() / 1000));\n-\t\treturn builder;\n-\t}\n-\n-\tvoid validateClaims(JwtClaims jwtClaims, JwtContext jwtContext, JwtConsumerConfig config, Map properties)\n-\t\t\tthrows MalformedClaimException, InvalidClaimException, InvalidTokenException {\n-\t\tString issuer = config.getIssuer();\n-\t\tif (issuer == null) {\n-\t\t\tissuer = (properties == null) ? null : (String) properties.get(ISSUER);\n-\t\t}\n-\n-\t\tvalidateIssuer(config.getId(), issuer, jwtClaims.getIssuer());\n-\n-\t\tif (!validateAudience(config.getAudiences(), jwtClaims.getAudience())) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_AUDIENCE_NOT_TRUSTED\",\n-\t\t\t\t\tnew Object[] { jwtClaims.getAudience(), config.getId(), config.getAudiences() });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t\t\n-\t\tif (!validateAMRClaim(config.getAMRClaim(), getJwtAMRList(jwtClaims))) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_AMR_CLAIM_NOT_VALID\",\n-\t\t\t\t\tnew Object[] { getJwtAMRList(jwtClaims), config.getId(), config.getAMRClaim() });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\n-\t\t// check azp\n-\n-\t\tvalidateIatAndExp(jwtClaims, config.getClockSkew());\n-\n-\t\tvalidateNbf(jwtClaims, config.getClockSkew());\n-\n-\t\tvalidateAlgorithm(jwtContext, config.getSignatureAlgorithm());\n-\t}\n-\n-\t/**\n-\t * Throws an exception if the provided key is null but the config specifies a\n-\t * signature algorithm other than \"none\".\n-\t */\n-\tvoid validateSignatureAlgorithmWithKey(JwtConsumerConfig config, Key key) throws InvalidClaimException {\n-\t\tString signatureAlgorithm = config.getSignatureAlgorithm();\n-\t\tif (key == null && signatureAlgorithm != null && !signatureAlgorithm.equalsIgnoreCase(\"none\")) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_MISSING_KEY\", new Object[] { signatureAlgorithm });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Verifies that tokenIssuer is one of the values specified in the\n-\t * comma-separated issuers string.\n-\t */\n-\tboolean validateIssuer(String consumerConfigId, String issuers, String tokenIssuer) throws InvalidClaimException {\n-\t\tboolean isIssuer = false;\n-\t\tif (issuers == null || issuers.isEmpty()) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TRUSTED_ISSUERS_NULL\",\n-\t\t\t\t\tnew Object[] { tokenIssuer, consumerConfigId });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\n-\t\tStringTokenizer st = new StringTokenizer(issuers, \",\");\n-\t\twhile (st.hasMoreTokens()) {\n-\t\t\tString iss = st.nextToken().trim();\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Trusted issuer: \" + iss);\n-\t\t\t}\n-\t\t\tif (Constants.ALL_ISSUERS.equals(iss) || (tokenIssuer != null && tokenIssuer.equals(iss))) {\n-\t\t\t\tisIssuer = true;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (!isIssuer) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ISSUER_NOT_TRUSTED\",\n-\t\t\t\t\tnew Object[] { tokenIssuer, consumerConfigId, issuers });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t\treturn isIssuer;\n-\t}\n-\n-\t/**\n-\t * Verifies that at least one of the values specified in audiences is contained\n-\t * in the allowedAudiences list.\n-\t */\n-\tboolean validateAudience(List<String> allowedAudiences, List<String> audiences) {\n-\t\tboolean valid = false;\n-\n-\t\tif (allowedAudiences != null && allowedAudiences.contains(Constants.ALL_AUDIENCES)) {\n-\t\t\treturn true;\n-\t\t}\n-\t\tif (allowedAudiences != null && audiences != null) {\n-\t\t\tfor (String audience : audiences) {\n-\t\t\t\tfor (String allowedAud : allowedAudiences) {\n-\t\t\t\t\tif (allowedAud.equals(audience)) {\n-\t\t\t\t\t\tvalid = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (allowedAudiences == null && (audiences == null || audiences.isEmpty())) {\n-\t\t\tvalid = true;\n-\t\t}\n-\n-\t\treturn valid;\n-\t}\n-\n-\t/**\n-\t * Validates the the {@value Claims#ISSUED_AT} and {@value Claims#EXPIRATION}\n-\t * claims are present and properly formed. Also verifies that the\n-\t * {@value Claims#ISSUED_AT} time is after the {@value Claims#EXPIRATION} time.\n-\t */\n-\tvoid validateIatAndExp(JwtClaims jwtClaims, long clockSkewInMilliseconds) throws InvalidClaimException {\n-\t\tif (jwtClaims == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Missing JwtClaims object\");\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tNumericDate issueAtClaim = getIssuedAtClaim(jwtClaims);\n-\t\tNumericDate expirationClaim = getExpirationClaim(jwtClaims);\n-\n-\t\tdebugCurrentTimes(clockSkewInMilliseconds, issueAtClaim, expirationClaim);\n-\n-\t\tvalidateIssuedAtClaim(issueAtClaim, expirationClaim, clockSkewInMilliseconds);\n-\t\tvalidateExpirationClaim(expirationClaim, clockSkewInMilliseconds);\n-\n-\t}\n-\n-\tvoid debugCurrentTimes(long clockSkewInMilliseconds, NumericDate issueAtClaim, NumericDate expirationClaim) {\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tlong now = (new Date()).getTime();\n-\t\t\tNumericDate currentTimeMinusSkew = NumericDate.fromMilliseconds(now - clockSkewInMilliseconds);\n-\t\t\tNumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n-\t\t\tTr.debug(tc, \"Checking iat [\" + createDateString(issueAtClaim) + \"] and exp [\"\n-\t\t\t\t\t+ createDateString(expirationClaim) + \"]\");\n-\t\t\tTr.debug(tc, \"Comparing against current time (minus clock skew of \" + (clockSkewInMilliseconds / 1000)\n-\t\t\t\t\t+ \" seconds) [\" + createDateString(currentTimeMinusSkew) + \"]\");\n-\t\t\tTr.debug(tc, \"Comparing against current time (plus clock skew of \" + (clockSkewInMilliseconds / 1000)\n-\t\t\t\t\t+ \" seconds) [\" + createDateString(currentTimePlusSkew) + \"]\");\n-\t\t}\n-\t}\n-\n-\tvoid validateIssuedAtClaim(NumericDate issueAtClaim, NumericDate expirationClaim, long clockSkewInMilliseconds)\n-\t\t\tthrows InvalidClaimException {\n-\t\tlong now = (new Date()).getTime();\n-\t\tNumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n-\n-\t\tif (issueAtClaim != null && expirationClaim != null) {\n-\t\t\tif (issueAtClaim.isAfter(currentTimePlusSkew)) {\n-\t\t\t\tString msg = Tr.formatMessage(tc, \"JWT_IAT_AFTER_CURRENT_TIME\",\n-\t\t\t\t\t\tnew Object[] { createDateString(issueAtClaim), createDateString(currentTimePlusSkew),\n-\t\t\t\t\t\t\t\t(clockSkewInMilliseconds / 1000) });\n-\t\t\t\tthrow new InvalidClaimException(msg);\n-\t\t\t}\n-\t\t\tif (issueAtClaim.isOnOrAfter(expirationClaim)) {\n-\t\t\t\tString msg = Tr.formatMessage(tc, \"JWT_IAT_AFTER_EXP\",\n-\t\t\t\t\t\tnew Object[] { createDateString(issueAtClaim), createDateString(expirationClaim) });\n-\t\t\t\tthrow new InvalidClaimException(msg);\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// TODO - what if one or the other is missing? is that an error\n-\t\t\t// condition?\n-\t\t}\n-\t}\n-\n-\t\n-\tvoid validateExpirationClaim(NumericDate expirationClaim, long clockSkewInMilliseconds)\n-\t\t\tthrows InvalidClaimException {\n-\t\tlong now = (new Date()).getTime();\n-\t\tNumericDate currentTimeMinusSkew = NumericDate.fromMilliseconds(now - clockSkewInMilliseconds);\n-\n-\t\t// Check that expiration claim is in the future, accounting for the\n-\t\t// clock skew\n-\t\tif (expirationClaim == null || (!expirationClaim.isAfter(currentTimeMinusSkew))) {\n-\t\t\tJwtUtils.setJwtSsoValidationPathExiredToken();\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TOKEN_EXPIRED\", new Object[] { createDateString(expirationClaim),\n-\t\t\t\t\tcreateDateString(currentTimeMinusSkew), (clockSkewInMilliseconds / 1000) });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Validates the the {@value Claims#NOT_BEFORE} claim is present and properly\n-\t * formed. Also\n-\t */\n-\tvoid validateNbf(JwtClaims jwtClaims, long clockSkewInMilliseconds) throws InvalidClaimException {\n-\t\tif (jwtClaims == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Missing JwtClaims object\");\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tNumericDate nbf = getNotBeforeClaim(jwtClaims);\n-\t\tvalidateNotBeforeClaim(nbf, clockSkewInMilliseconds);\n-\t}\n-\n-\tvoid validateNotBeforeClaim(NumericDate nbfClaim, long clockSkewInMilliseconds) throws InvalidClaimException {\n-\t\tlong now = (new Date()).getTime();\n-\t\tNumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n-\n-\t\t// Check that nbf claim is in the past, accounting for the clock skew\n-\t\tif (nbfClaim != null && (nbfClaim.isOnOrAfter(currentTimePlusSkew))) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_TOKEN_BEFORE_NBF\", new Object[] { createDateString(nbfClaim),\n-\t\t\t\t\tcreateDateString(currentTimePlusSkew), (clockSkewInMilliseconds / 1000) });\n-\t\t\tthrow new InvalidClaimException(msg);\n-\t\t}\n-\t}\n-\n-\tNumericDate getIssuedAtClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n-\t\tNumericDate iatClaim = null;\n-\t\ttry {\n-\t\t\tiatClaim = jwtClaims.getIssuedAt();\n-\t\t} catch (MalformedClaimException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n-\t\t\t\t\tnew Object[] { Claims.ISSUED_AT, e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidClaimException(msg, e);\n-\t\t}\n-\t\treturn iatClaim;\n-\t}\n-\n-\tNumericDate getExpirationClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n-\t\tNumericDate expClaim = null;\n-\t\ttry {\n-\t\t\texpClaim = jwtClaims.getExpirationTime();\n-\t\t} catch (MalformedClaimException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n-\t\t\t\t\tnew Object[] { Claims.EXPIRATION, e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidClaimException(msg, e);\n-\t\t}\n-\t\treturn expClaim;\n-\t}\n-\n-\tNumericDate getNotBeforeClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n-\t\tNumericDate nbfClaim = null;\n-\t\ttry {\n-\t\t\tnbfClaim = jwtClaims.getNotBefore();\n-\t\t} catch (MalformedClaimException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n-\t\t\t\t\tnew Object[] { Claims.NOT_BEFORE, e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidClaimException(msg, e);\n-\t\t}\n-\t\treturn nbfClaim;\n-\t}\n-\n-\tvoid validateAlgorithm(JwtContext jwtContext, String requiredAlg) throws InvalidTokenException {\n-\t\tif (requiredAlg == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"No required signature algorithm was specified\");\n-\t\t\t}\n-\t\t\treturn;\n-\t\t}\n-\t\tString tokenAlg = getAlgorithmFromJwtHeader(jwtContext);\n-\t\tvalidateAlgorithm(requiredAlg, tokenAlg);\n-\t}\n-\n-\tvoid validateAlgorithm(String requiredAlg, String tokenAlg) throws InvalidTokenException {\n-\t\tif (tokenAlg == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Signature algorithm was not found in the JWT\");\n-\t\t\t}\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_MISSING_ALG_HEADER\", new Object[] { requiredAlg });\n-\t\t\tthrow new InvalidTokenException(msg);\n-\t\t}\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"JWT is signed with algorithm: \", tokenAlg);\n-\t\t\tTr.debug(tc, \"JWT is required to be signed with algorithm: \", requiredAlg);\n-\t\t}\n-\t\tif (!requiredAlg.equals(tokenAlg)) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_ALGORITHM_MISMATCH\", new Object[] { tokenAlg, requiredAlg });\n-\t\t\tthrow new InvalidTokenException(msg);\n-\t\t}\n-\t}\n-\n-\tJwtContext processJwtStringWithConsumer(JwtConsumer jwtConsumer, String jwtString)\n-\t\t\tthrows InvalidTokenException, InvalidJwtException {\n-\t\tJwtContext validatedJwtContext = null;\n-\t\ttry {\n-\t\t\tvalidatedJwtContext = jwtConsumer.process(jwtString);\n-\t\t} catch (InvalidJwtSignatureException e) {\n-\t\t\tString msg = Tr.formatMessage(tc, \"JWT_INVALID_SIGNATURE\", new Object[] { e.getLocalizedMessage() });\n-\t\t\tthrow new InvalidTokenException(msg, e);\n-\t\t} catch (InvalidJwtException e) {\n-\t\t\tThrowable cause = getRootCause(e);\n-\t\t\tif (cause != null && cause instanceof InvalidKeyException) {\n-\t\t\t\tthrow e;\n-\t\t\t} else {\n-\t\t\t\t// Don't have enough information to output a more useful error\n-\t\t\t\t// message\n-\t\t\t\tthrow e;\n-\t\t\t}\n-\t\t}\n-\t\treturn validatedJwtContext;\n-\t}\n-\n-\tString getAlgorithmFromJwtHeader(JwtContext jwtContext) {\n-\t\tif (jwtContext == null) {\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"JwtContext is null\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tJsonWebStructure jwtHeader = null;\n-\t\ttry {\n-\t\t\tjwtHeader = getJwtHeader(jwtContext);\n-\t\t} catch (Exception e) {\n-\t\t\t// TODO - NLS message?\n-\t\t\tif (tc.isDebugEnabled()) {\n-\t\t\t\tTr.debug(tc, \"Failed to obtain JWT header\");\n-\t\t\t}\n-\t\t\treturn null;\n-\t\t}\n-\t\tString algHeader = jwtHeader.getAlgorithmHeaderValue();\n-\t\tif (tc.isDebugEnabled()) {\n-\t\t\tTr.debug(tc, \"JWT is signed with algorithm: \", algHeader);\n-\t\t}\n-\t\treturn algHeader;\n-\t}\n-\n-\tThrowable getRootCause(Exception e) {\n-\t\tThrowable rootCause = null;\n-\t\tThrowable tmpCause = e;\n-\t\twhile (tmpCause != null) {\n-\t\t\trootCause = tmpCause;\n-\t\t\ttmpCause = rootCause.getCause();\n-\t\t}\n-\t\treturn rootCause;\n-\t}\n-\n-\tString createDateString(NumericDate date) {\n-\t\tif (date == null) {\n-\t\t\treturn null;\n-\t\t}\n-\t\t// NumericDate.getValue() returns a value in seconds, so convert to\n-\t\t// milliseconds\n-\t\treturn timeUtils.createDateString(1000 * date.getValue());\n-\t}\n-\t\n-\t/**\n-\t * Helper method to get the AMR Claim from the jwtClaims.This method checks\n-\t * if the value is a string and return singletonList or the ArrayList of\n-\t * amrClaims. This is called in validateClaims method\n-\t *\n-\t */\n-\tList<String> getJwtAMRList(JwtClaims jwtClaims) throws MalformedClaimException {\n-\t\tString claimName = \"amr\";\n-\t\tObject amrObject = jwtClaims.getClaimValue(claimName);\n-\t\tif (amrObject instanceof String) {\n-\t\t\treturn Collections.singletonList(jwtClaims.getStringClaimValue(claimName));\n-\t\t} else if (!(amrObject instanceof List) && amrObject != null) {\n-\t\t\tthrow new MalformedClaimException(\n-\t\t\t\t\t\"The value of the 'amr' claim is not an array of strings or a single string value.\");\n-\t\t} else {\n-\t\t\treturn jwtClaims.getStringListClaimValue(claimName);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Verifies that values specified in AMR claim is contained in the\n-\t * authenticationMethodsReferences list. If allowedAMRClaim is not an array\n-\t * then jwtClaims can contain more than required values. If not, then the\n-\t * jwtClaimvalues must be a exact match of an element in the array.\n-\t */\n-\tboolean validateAMRClaim(List<String> allowedAmrClaim, List<String> jwtAMRClaims) {\n-\t\tboolean valid = false;\n-\t\tif (allowedAmrClaim != null && jwtAMRClaims != null) {\n-\t\t\t// If it is not array just check if jwtClaim containsAll and not\n-\t\t\t// equals\n-\t\t\tif (allowedAmrClaim.size() == 1) {\n-\t\t\t\tList<String> allowedAMRSingle = Arrays.asList(allowedAmrClaim.get(0).split(\" \"));\n-\t\t\t\tif (jwtAMRClaims.containsAll(allowedAMRSingle)) {\n-\t\t\t\t\tvalid = true;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfor (String allowedAMR : allowedAmrClaim) {\n-\t\t\t\t\tList<String> allowedAMRSingle = Arrays.asList(allowedAMR.split(\" \"));\n-\t\t\t\t\tif (jwtAMRClaims.equals(allowedAMRSingle)) {\n-\t\t\t\t\t\tvalid = true;\n-\t\t\t\t\t\tbreak;\n-\t\t\t\t\t}\n-\n-\t\t\t\t}\n-\t\t\t}\n-\t\t} else if (allowedAmrClaim == null && (jwtAMRClaims == null || jwtAMRClaims.isEmpty())) {\n-\t\t\tvalid = true;\n-\t\t}\n-\t\treturn valid;\n-\t}\n+\n+    private static final TraceComponent tc = Tr.register(ConsumerUtil.class);\n+    private static final Class<?> thisClass = ConsumerUtil.class;\n+\n+    private AtomicServiceReference<KeyStoreService> keyStoreService = null;\n+\n+    private static TimeUtils timeUtils = new TimeUtils(TimeUtils.YearMonthDateHourMinSecZone);\n+    private final JtiNonceCache jtiCache = new JtiNonceCache();\n+    public final static String ISSUER = \"mp.jwt.verify.issuer\";\n+    public final static String PUBLIC_KEY = \"mp.jwt.verify.publickey\";\n+    public final static String KEY_LOCATION = \"mp.jwt.verify.publickey.location\";\n+\n+    public ConsumerUtil(AtomicServiceReference<KeyStoreService> kss) {\n+        keyStoreService = kss;\n+    }\n+\n+    public JwtToken parseJwt(String jwtString, JwtConsumerConfig config) throws Exception {\n+        return parseJwt(jwtString, config, null);\n+    }\n+\n+    public JwtToken parseJwt(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n+        JwtContext jwtContext = parseJwtAndGetJwtContext(jwtString, config, properties);\n+        JwtTokenConsumerImpl jwtToken = new JwtTokenConsumerImpl(jwtContext);\n+        checkForReusedJwt(jwtToken, config);\n+        return jwtToken;\n+    }\n+\n+    JwtContext parseJwtAndGetJwtContext(String jwtString, JwtConsumerConfig config, Map properties) throws Exception {\n+        JwtContext jwtContext = parseJwtWithoutValidation(jwtString, config);\n+        if (config.isValidationRequired()) {\n+            jwtContext = getSigningKeyAndParseJwtWithValidation(jwtString, config, jwtContext, properties);\n+        }\n+        return jwtContext;\n+    }\n+\n+    JwtContext getSigningKeyAndParseJwtWithValidation(String jwtString, JwtConsumerConfig config, JwtContext jwtContext,\n+            Map properties) throws Exception {\n+        Key signingKey = getSigningKey(config, jwtContext, properties);\n+        return parseJwtWithValidation(jwtString, jwtContext, config, signingKey, properties);\n+    }\n+\n+    /**\n+     * Throws an exception if JWTs are not allowed to be reused (as configured\n+     * by the provided config option) AND a token with a matching \"jti\" and\n+     * \"issuer\" claim already exists in the cache.\n+     */\n+    void checkForReusedJwt(JwtTokenConsumerImpl jwt, JwtConsumerConfig config) throws InvalidTokenException {\n+        // Only throw an error if tokens are not allowed to be reused\n+        if (!config.getTokenReuse()) {\n+            throwExceptionIfJwtReused(jwt);\n+        }\n+    }\n+\n+    void throwExceptionIfJwtReused(JwtTokenConsumerImpl jwt) throws InvalidTokenException {\n+        if (jtiCache.contains(jwt)) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JWT token can only be submitted once. The issuer is \" + jwt.getClaims().getIssuer()\n+                        + \", and JTI is \" + jwt.getClaims().getJwtId());\n+            }\n+            String errorMsg = Tr.formatMessage(tc, \"JWT_DUP_JTI_ERR\",\n+                    new Object[] { jwt.getClaims().getIssuer(), jwt.getClaims().getJwtId() });\n+            throw new InvalidTokenException(errorMsg);\n+        }\n+    }\n+\n+    /**\n+     * Get the appropriate signing key based on the signature algorithm\n+     * specified in the config.\n+     */\n+    Key getSigningKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        Key signingKey = null;\n+        if (config == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JWT consumer config object is null\");\n+            }\n+            return null;\n+        }\n+        signingKey = getSigningKeyBasedOnSignatureAlgorithm(config, jwtContext, properties);\n+        if (signingKey == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"A signing key could not be found\");\n+            }\n+        }\n+        return signingKey;\n+    }\n+\n+    Key getSigningKeyBasedOnSignatureAlgorithm(JwtConsumerConfig config, JwtContext jwtContext, Map properties)\n+            throws KeyException {\n+        Key signingKey = null;\n+        String sigAlg = config.getSignatureAlgorithm();\n+\n+        if (isHSAlgorithm(sigAlg)) {\n+            signingKey = getSigningKeyForHS(config);\n+        } else if (isRSAlgorithm(sigAlg)) {\n+            signingKey = getSigningKeyForRS(config, jwtContext, properties);\n+        } else if (isESAlgorithm(sigAlg)) {\n+            signingKey = getSigningKeyForES(config, jwtContext, properties);\n+        }\n+        return signingKey;\n+    }\n+\n+    boolean isHSAlgorithm(String sigAlg) {\n+        if (sigAlg == null) {\n+            return false;\n+        }\n+        return sigAlg.matches(\"HS[0-9]{3,}\");\n+    }\n+\n+    Key getSigningKeyForHS(JwtConsumerConfig config) throws KeyException {\n+        Key signingKey = null;\n+        try {\n+            signingKey = getSharedSecretKey(config);\n+        } catch (Exception e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_SHARED_KEY\", new Object[] { e.getLocalizedMessage() });\n+            throw new KeyException(msg, e);\n+        }\n+        return signingKey;\n+    }\n+\n+    /**\n+     * Creates a Key object from the shared key specified in the provided\n+     * configuration.\n+     */\n+    Key getSharedSecretKey(JwtConsumerConfig config) throws KeyException {\n+        if (config == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JWT consumer config object is null\");\n+            }\n+            return null;\n+        }\n+        String sharedKey = config.getSharedKey();\n+        return createKeyFromSharedKey(sharedKey);\n+    }\n+\n+    Key createKeyFromSharedKey(String sharedKey) throws KeyException {\n+        if (sharedKey == null || sharedKey.isEmpty()) {\n+            String msg = Tr.formatMessage(tc, \"JWT_MISSING_SHARED_KEY\");\n+            throw new KeyException(msg);\n+        }\n+        try {\n+            return new HmacKey(sharedKey.getBytes(Constants.UTF_8));\n+        } catch (UnsupportedEncodingException e) {\n+            // Should not happen - UTF-8 should be supported\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Caught exception getting shared key bytes: \" + e.getLocalizedMessage());\n+            }\n+        }\n+        return null;\n+    }\n+\n+    boolean isESAlgorithm(String sigAlg) {\n+        if (sigAlg == null) {\n+            return false;\n+        }\n+        return sigAlg.matches(\"ES[0-9]{3,}\");\n+    }\n+\n+    boolean isPublicKeyPropsPresent(Map props) {\n+        if (props == null) {\n+            return false;\n+        }\n+        return props.get(PUBLIC_KEY) != null || props.get(KEY_LOCATION) != null;\n+    }\n+\n+    boolean isRSAlgorithm(String sigAlg) {\n+        if (sigAlg == null) {\n+            return false;\n+        }\n+        return sigAlg.matches(\"RS[0-9]{3,}\");\n+    }\n+\n+    Key getSigningKeyForRS(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        return getKeyFromJwkOrTrustStore(config, jwtContext, properties);\n+    }\n+\n+    Key getKeyFromJwkOrTrustStore(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        Key signingKey = null;\n+        if (config.getJwkEnabled() || (config.getTrustedAlias() == null && isPublicKeyPropsPresent(properties))) { // need\n+                                                                                                                   // change\n+                                                                                                                   // to\n+                                                                                                                   // consider\n+                                                                                                                   // MP-Config\n+            signingKey = getKeyForJwkEnabled(config, jwtContext, properties);\n+        } else {\n+            signingKey = getKeyForJwkDisabled(config);\n+        }\n+        return signingKey;\n+    }\n+\n+    Key getKeyForJwkEnabled(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        Key signingKey = null;\n+        try {\n+            signingKey = getJwksKey(config, jwtContext, properties);\n+        } catch (Exception e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_JWK_KEY\",\n+                    new Object[] { config.getJwkEndpointUrl(), e.getLocalizedMessage() });\n+            throw new KeyException(msg, e);\n+        }\n+        return signingKey;\n+    }\n+\n+    protected Key getJwksKey(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws Exception {\n+        JsonWebStructure jwtHeader = getJwtHeader(jwtContext);\n+        String kid = jwtHeader.getKeyIdHeaderValue();\n+        JwKRetriever jwkRetriever = null;\n+        if (properties != null) {\n+            String publickey = (String) properties.get(PUBLIC_KEY);\n+            String keyLocation = (String) properties.get(KEY_LOCATION);\n+            if (publickey != null || keyLocation != null) {\n+                jwkRetriever = new JwKRetriever(config.getId(), config.getSslRef(), config.getJwkEndpointUrl(),\n+                        config.getJwkSet(), JwtUtils.getSSLSupportService(), config.isHostNameVerificationEnabled(),\n+                        null, null, publickey, keyLocation);\n+            }\n+        }\n+        if (jwkRetriever == null) {\n+            jwkRetriever = new JwKRetriever(config.getId(), config.getSslRef(), config.getJwkEndpointUrl(),\n+                    config.getJwkSet(), JwtUtils.getSSLSupportService(), config.isHostNameVerificationEnabled(), null,\n+                    null);\n+        }\n+        Key signingKey = jwkRetriever.getPublicKeyFromJwk(kid, null,\n+                config.getUseSystemPropertiesForHttpClientConnections()); // only\n+                                                                          // kid\n+                                                                          // or\n+                                                                          // x5t\n+                                                                          // will\n+                                                                          // work\n+                                                                          // but\n+                                                                          // not\n+                                                                          // both\n+        return signingKey;\n+    }\n+\n+    JsonWebStructure getJwtHeader(JwtContext jwtContext) throws Exception {\n+        List<JsonWebStructure> jsonStructures = jwtContext.getJoseObjects();\n+        if (jsonStructures == null || jsonStructures.isEmpty()) {\n+            // TODO - NLS message\n+            throw new Exception(\"Invalid JsonWebStructure\");\n+        }\n+        JsonWebStructure jwtHeader = jsonStructures.get(0);\n+        debugJwtHeader(jwtHeader);\n+        return jwtHeader;\n+    }\n+\n+    void debugJwtHeader(JsonWebStructure jwtHeader) {\n+        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"JsonWebStructure class: \" + jwtHeader.getClass().getName() + \" data:\" + jwtHeader);\n+            if (jwtHeader instanceof JsonWebSignature) {\n+                JsonWebSignature signature = (JsonWebSignature) jwtHeader;\n+                Tr.debug(tc, \"JsonWebSignature alg: \" + signature.getAlgorithmHeaderValue() + \" 3rd:'\"\n+                        + signature.getEncodedSignature() + \"'\");\n+            }\n+        }\n+    }\n+\n+    Key getKeyForJwkDisabled(JwtConsumerConfig config) throws KeyException {\n+        Key signingKey = null;\n+        String trustedAlias = config.getTrustedAlias();\n+        String trustStoreRef = config.getTrustStoreRef();\n+        try {\n+            signingKey = getPublicKey(trustedAlias, trustStoreRef, config.getSignatureAlgorithm());\n+        } catch (Exception e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_ERROR_GETTING_PUBLIC_KEY\",\n+                    new Object[] { trustedAlias, trustStoreRef, e.getLocalizedMessage() });\n+            throw new KeyException(msg, e);\n+        }\n+        return signingKey;\n+    }\n+\n+    /**\n+     * Creates a Key object from the certificate stored in the trust store and\n+     * alias provided.\n+     */\n+    Key getPublicKey(String trustedAlias, String trustStoreRef, String signatureAlgorithm)\n+            throws KeyStoreServiceException, KeyException {\n+        Key signingKey = getPublicKeyFromKeystore(trustedAlias, trustStoreRef, signatureAlgorithm);\n+        if (tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"Trusted alias: \" + trustedAlias + \", Truststore: \" + trustStoreRef);\n+            Tr.debug(tc, \"RSAPublicKey: \" + (signingKey instanceof RSAPublicKey));\n+        }\n+        if (signingKey != null && !(signingKey instanceof PublicKey)) {\n+            signingKey = null;\n+        }\n+        return signingKey;\n+    }\n+\n+    Key getPublicKeyFromKeystore(String trustedAlias, String trustStoreRef, String signatureAlgorithm)\n+            throws KeyException {\n+        try {\n+            if (keyStoreService == null) {\n+                String msg = Tr.formatMessage(tc, \"JWT_TRUSTSTORE_SERVICE_NOT_AVAILABLE\");\n+                throw new KeyStoreServiceException(msg);\n+            }\n+            return JwtUtils.getPublicKey(trustedAlias, trustStoreRef, keyStoreService.getService());\n+        } catch (Exception e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_NULL_SIGNING_KEY_WITH_ERROR\",\n+                    new Object[] { signatureAlgorithm, Constants.SIGNING_KEY_X509, e.getLocalizedMessage() });\n+            throw new KeyException(msg, e);\n+        }\n+    }\n+\n+    Key getSigningKeyForES(JwtConsumerConfig config, JwtContext jwtContext, Map properties) throws KeyException {\n+        return getKeyFromJwkOrTrustStore(config, jwtContext, properties);\n+    }\n+\n+    protected JwtContext parseJwtWithoutValidation(String jwtString, JwtConsumerConfig config) throws Exception {\n+        if (jwtString == null || jwtString.isEmpty()) {\n+            String errorMsg = Tr.formatMessage(tc, \"JWT_CONSUMER_NULL_OR_EMPTY_STRING\",\n+                    new Object[] { config.getId(), jwtString });\n+            throw new InvalidTokenException(errorMsg);\n+        }\n+        JwtConsumerBuilder builder = initializeJwtConsumerBuilderWithoutValidation(config);\n+        JwtConsumer firstPassJwtConsumer = builder.build();\n+        return firstPassJwtConsumer.process(jwtString);\n+    }\n+\n+    protected JwtContext parseJwtWithValidation(String jwtString, JwtContext jwtContext, JwtConsumerConfig config,\n+            Key key, Map properties) throws Exception {\n+        JwtClaims jwtClaims = jwtContext.getJwtClaims();\n+\n+        if (tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"Key from config: \" + key);\n+        }\n+\n+        validateClaims(jwtClaims, jwtContext, config, properties);\n+        validateSignatureAlgorithmWithKey(config, key);\n+\n+        JwtConsumerBuilder consumerBuilder = initializeJwtConsumerBuilderWithValidation(config, jwtClaims, key);\n+        JwtConsumer jwtConsumer = consumerBuilder.build();\n+        return processJwtStringWithConsumer(jwtConsumer, jwtString);\n+    }\n+\n+    JwtConsumerBuilder initializeJwtConsumerBuilderWithoutValidation(JwtConsumerConfig config) {\n+        JwtConsumerBuilder builder = new JwtConsumerBuilder();\n+        builder.setSkipAllValidators();\n+        builder.setDisableRequireSignature();\n+        builder.setSkipSignatureVerification();\n+        builder.setAllowedClockSkewInSeconds((int) ((config.getClockSkew()) / 1000));\n+        return builder;\n+    }\n+\n+    JwtConsumerBuilder initializeJwtConsumerBuilderWithValidation(JwtConsumerConfig config, JwtClaims jwtClaims,\n+            Key key) throws MalformedClaimException {\n+        JwtConsumerBuilder builder = new JwtConsumerBuilder();\n+        builder.setExpectedIssuer(jwtClaims.getIssuer());\n+        builder.setSkipDefaultAudienceValidation();\n+        builder.setRequireExpirationTime();\n+        builder.setVerificationKey(key);\n+        builder.setRelaxVerificationKeyValidation();\n+        builder.setAllowedClockSkewInSeconds((int) (config.getClockSkew() / 1000));\n+        return builder;\n+    }\n+\n+    void validateClaims(JwtClaims jwtClaims, JwtContext jwtContext, JwtConsumerConfig config, Map properties)\n+            throws MalformedClaimException, InvalidClaimException, InvalidTokenException {\n+        String issuer = config.getIssuer();\n+        if (issuer == null) {\n+            issuer = (properties == null) ? null : (String) properties.get(ISSUER);\n+        }\n+\n+        validateIssuer(config.getId(), issuer, jwtClaims.getIssuer());\n+\n+        if (!validateAudience(config.getAudiences(), jwtClaims.getAudience())) {\n+            String msg = Tr.formatMessage(tc, \"JWT_AUDIENCE_NOT_TRUSTED\",\n+                    new Object[] { jwtClaims.getAudience(), config.getId(), config.getAudiences() });\n+            throw new InvalidClaimException(msg);\n+        }\n+\n+        if (!validateAMRClaim(config.getAMRClaim(), getJwtAMRList(jwtClaims))) {\n+            String msg = Tr.formatMessage(tc, \"JWT_AMR_CLAIM_NOT_VALID\",\n+                    new Object[] { getJwtAMRList(jwtClaims), config.getId(), config.getAMRClaim() });\n+            throw new InvalidClaimException(msg);\n+        }\n+\n+        // check azp\n+\n+        validateIatAndExp(jwtClaims, config.getClockSkew());\n+\n+        validateNbf(jwtClaims, config.getClockSkew());\n+\n+        validateAlgorithm(jwtContext, config.getSignatureAlgorithm());\n+    }\n+\n+    /**\n+     * Throws an exception if the provided key is null but the config specifies\n+     * a signature algorithm other than \"none\".\n+     */\n+    void validateSignatureAlgorithmWithKey(JwtConsumerConfig config, Key key) throws InvalidClaimException {\n+        String signatureAlgorithm = config.getSignatureAlgorithm();\n+        if (key == null && signatureAlgorithm != null && !signatureAlgorithm.equalsIgnoreCase(\"none\")) {\n+            String msg = Tr.formatMessage(tc, \"JWT_MISSING_KEY\", new Object[] { signatureAlgorithm });\n+            throw new InvalidClaimException(msg);\n+        }\n+    }\n+\n+    /**\n+     * Verifies that tokenIssuer is one of the values specified in the\n+     * comma-separated issuers string.\n+     */\n+    boolean validateIssuer(String consumerConfigId, String issuers, String tokenIssuer) throws InvalidClaimException {\n+        boolean isIssuer = false;\n+        if (issuers == null || issuers.isEmpty()) {\n+            String msg = Tr.formatMessage(tc, \"JWT_TRUSTED_ISSUERS_NULL\",\n+                    new Object[] { tokenIssuer, consumerConfigId });\n+            throw new InvalidClaimException(msg);\n+        }\n+\n+        StringTokenizer st = new StringTokenizer(issuers, \",\");\n+        while (st.hasMoreTokens()) {\n+            String iss = st.nextToken().trim();\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Trusted issuer: \" + iss);\n+            }\n+            if (Constants.ALL_ISSUERS.equals(iss) || (tokenIssuer != null && tokenIssuer.equals(iss))) {\n+                isIssuer = true;\n+                break;\n+            }\n+        }\n+\n+        if (!isIssuer) {\n+            String msg = Tr.formatMessage(tc, \"JWT_ISSUER_NOT_TRUSTED\",\n+                    new Object[] { tokenIssuer, consumerConfigId, issuers });\n+            throw new InvalidClaimException(msg);\n+        }\n+        return isIssuer;\n+    }\n+\n+    /**\n+     * Verifies that at least one of the values specified in audiences is\n+     * contained in the allowedAudiences list.\n+     */\n+    boolean validateAudience(List<String> allowedAudiences, List<String> audiences) {\n+        boolean valid = false;\n+\n+        if (allowedAudiences != null && allowedAudiences.contains(Constants.ALL_AUDIENCES)) {\n+            return true;\n+        }\n+        if (allowedAudiences != null && audiences != null) {\n+            for (String audience : audiences) {\n+                for (String allowedAud : allowedAudiences) {\n+                    if (allowedAud.equals(audience)) {\n+                        valid = true;\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (allowedAudiences == null && (audiences == null || audiences.isEmpty())) {\n+            valid = true;\n+        }\n+\n+        return valid;\n+    }\n+\n+    /**\n+     * Validates the the {@value Claims#ISSUED_AT} and\n+     * {@value Claims#EXPIRATION} claims are present and properly formed. Also\n+     * verifies that the {@value Claims#ISSUED_AT} time is after the\n+     * {@value Claims#EXPIRATION} time.\n+     */\n+    void validateIatAndExp(JwtClaims jwtClaims, long clockSkewInMilliseconds) throws InvalidClaimException {\n+        if (jwtClaims == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Missing JwtClaims object\");\n+            }\n+            return;\n+        }\n+        NumericDate issueAtClaim = getIssuedAtClaim(jwtClaims);\n+        NumericDate expirationClaim = getExpirationClaim(jwtClaims);\n+\n+        debugCurrentTimes(clockSkewInMilliseconds, issueAtClaim, expirationClaim);\n+\n+        validateIssuedAtClaim(issueAtClaim, expirationClaim, clockSkewInMilliseconds);\n+        validateExpirationClaim(expirationClaim, clockSkewInMilliseconds);\n+\n+    }\n+\n+    void debugCurrentTimes(long clockSkewInMilliseconds, NumericDate issueAtClaim, NumericDate expirationClaim) {\n+        if (tc.isDebugEnabled()) {\n+            long now = (new Date()).getTime();\n+            NumericDate currentTimeMinusSkew = NumericDate.fromMilliseconds(now - clockSkewInMilliseconds);\n+            NumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n+            Tr.debug(tc, \"Checking iat [\" + createDateString(issueAtClaim) + \"] and exp [\"\n+                    + createDateString(expirationClaim) + \"]\");\n+            Tr.debug(tc, \"Comparing against current time (minus clock skew of \" + (clockSkewInMilliseconds / 1000)\n+                    + \" seconds) [\" + createDateString(currentTimeMinusSkew) + \"]\");\n+            Tr.debug(tc, \"Comparing against current time (plus clock skew of \" + (clockSkewInMilliseconds / 1000)\n+                    + \" seconds) [\" + createDateString(currentTimePlusSkew) + \"]\");\n+        }\n+    }\n+\n+    void validateIssuedAtClaim(NumericDate issueAtClaim, NumericDate expirationClaim, long clockSkewInMilliseconds)\n+            throws InvalidClaimException {\n+        long now = (new Date()).getTime();\n+        NumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n+\n+        if (issueAtClaim != null && expirationClaim != null) {\n+            if (issueAtClaim.isAfter(currentTimePlusSkew)) {\n+                String msg = Tr.formatMessage(tc, \"JWT_IAT_AFTER_CURRENT_TIME\",\n+                        new Object[] { createDateString(issueAtClaim), createDateString(currentTimePlusSkew),\n+                                (clockSkewInMilliseconds / 1000) });\n+                throw new InvalidClaimException(msg);\n+            }\n+            if (issueAtClaim.isOnOrAfter(expirationClaim)) {\n+                String msg = Tr.formatMessage(tc, \"JWT_IAT_AFTER_EXP\",\n+                        new Object[] { createDateString(issueAtClaim), createDateString(expirationClaim) });\n+                throw new InvalidClaimException(msg);\n+            }\n+        } else {\n+            // TODO - what if one or the other is missing? is that an error\n+            // condition?\n+        }\n+    }\n+\n+    void validateExpirationClaim(NumericDate expirationClaim, long clockSkewInMilliseconds)\n+            throws InvalidClaimException {\n+        long now = (new Date()).getTime();\n+        NumericDate currentTimeMinusSkew = NumericDate.fromMilliseconds(now - clockSkewInMilliseconds);\n+\n+        // Check that expiration claim is in the future, accounting for the\n+        // clock skew\n+        if (expirationClaim == null || (!expirationClaim.isAfter(currentTimeMinusSkew))) {\n+            JwtUtils.setJwtSsoValidationPathExiredToken();\n+            String msg = Tr.formatMessage(tc, \"JWT_TOKEN_EXPIRED\", new Object[] { createDateString(expirationClaim),\n+                    createDateString(currentTimeMinusSkew), (clockSkewInMilliseconds / 1000) });\n+            throw new InvalidClaimException(msg);\n+        }\n+    }\n+\n+    /**\n+     * Validates the the {@value Claims#NOT_BEFORE} claim is present and\n+     * properly formed. Also\n+     */\n+    void validateNbf(JwtClaims jwtClaims, long clockSkewInMilliseconds) throws InvalidClaimException {\n+        if (jwtClaims == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Missing JwtClaims object\");\n+            }\n+            return;\n+        }\n+        NumericDate nbf = getNotBeforeClaim(jwtClaims);\n+        validateNotBeforeClaim(nbf, clockSkewInMilliseconds);\n+    }\n+\n+    void validateNotBeforeClaim(NumericDate nbfClaim, long clockSkewInMilliseconds) throws InvalidClaimException {\n+        long now = (new Date()).getTime();\n+        NumericDate currentTimePlusSkew = NumericDate.fromMilliseconds(now + clockSkewInMilliseconds);\n+\n+        // Check that nbf claim is in the past, accounting for the clock skew\n+        if (nbfClaim != null && (nbfClaim.isOnOrAfter(currentTimePlusSkew))) {\n+            String msg = Tr.formatMessage(tc, \"JWT_TOKEN_BEFORE_NBF\", new Object[] { createDateString(nbfClaim),\n+                    createDateString(currentTimePlusSkew), (clockSkewInMilliseconds / 1000) });\n+            throw new InvalidClaimException(msg);\n+        }\n+    }\n+\n+    NumericDate getIssuedAtClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n+        NumericDate iatClaim = null;\n+        try {\n+            iatClaim = jwtClaims.getIssuedAt();\n+        } catch (MalformedClaimException e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n+                    new Object[] { Claims.ISSUED_AT, e.getLocalizedMessage() });\n+            throw new InvalidClaimException(msg, e);\n+        }\n+        return iatClaim;\n+    }\n+\n+    NumericDate getExpirationClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n+        NumericDate expClaim = null;\n+        try {\n+            expClaim = jwtClaims.getExpirationTime();\n+        } catch (MalformedClaimException e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n+                    new Object[] { Claims.EXPIRATION, e.getLocalizedMessage() });\n+            throw new InvalidClaimException(msg, e);\n+        }\n+        return expClaim;\n+    }\n+\n+    NumericDate getNotBeforeClaim(JwtClaims jwtClaims) throws InvalidClaimException {\n+        NumericDate nbfClaim = null;\n+        try {\n+            nbfClaim = jwtClaims.getNotBefore();\n+        } catch (MalformedClaimException e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_CONSUMER_MALFORMED_CLAIM\",\n+                    new Object[] { Claims.NOT_BEFORE, e.getLocalizedMessage() });\n+            throw new InvalidClaimException(msg, e);\n+        }\n+        return nbfClaim;\n+    }\n+\n+    void validateAlgorithm(JwtContext jwtContext, String requiredAlg) throws InvalidTokenException {\n+        if (requiredAlg == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"No required signature algorithm was specified\");\n+            }\n+            return;\n+        }\n+        String tokenAlg = getAlgorithmFromJwtHeader(jwtContext);\n+        validateAlgorithm(requiredAlg, tokenAlg);\n+    }\n+\n+    void validateAlgorithm(String requiredAlg, String tokenAlg) throws InvalidTokenException {\n+        if (tokenAlg == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Signature algorithm was not found in the JWT\");\n+            }\n+            String msg = Tr.formatMessage(tc, \"JWT_MISSING_ALG_HEADER\", new Object[] { requiredAlg });\n+            throw new InvalidTokenException(msg);\n+        }\n+        if (tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"JWT is signed with algorithm: \", tokenAlg);\n+            Tr.debug(tc, \"JWT is required to be signed with algorithm: \", requiredAlg);\n+        }\n+        if (!requiredAlg.equals(tokenAlg)) {\n+            String msg = Tr.formatMessage(tc, \"JWT_ALGORITHM_MISMATCH\", new Object[] { tokenAlg, requiredAlg });\n+            throw new InvalidTokenException(msg);\n+        }\n+    }\n+\n+    JwtContext processJwtStringWithConsumer(JwtConsumer jwtConsumer, String jwtString)\n+            throws InvalidTokenException, InvalidJwtException {\n+        JwtContext validatedJwtContext = null;\n+        try {\n+            validatedJwtContext = jwtConsumer.process(jwtString);\n+        } catch (InvalidJwtSignatureException e) {\n+            String msg = Tr.formatMessage(tc, \"JWT_INVALID_SIGNATURE\", new Object[] { e.getLocalizedMessage() });\n+            throw new InvalidTokenException(msg, e);\n+        } catch (InvalidJwtException e) {\n+            Throwable cause = getRootCause(e);\n+            if (cause != null && cause instanceof InvalidKeyException) {\n+                throw e;\n+            } else {\n+                // Don't have enough information to output a more useful error\n+                // message\n+                throw e;\n+            }\n+        }\n+        return validatedJwtContext;\n+    }\n+\n+    String getAlgorithmFromJwtHeader(JwtContext jwtContext) {\n+        if (jwtContext == null) {\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"JwtContext is null\");\n+            }\n+            return null;\n+        }\n+        JsonWebStructure jwtHeader = null;\n+        try {\n+            jwtHeader = getJwtHeader(jwtContext);\n+        } catch (Exception e) {\n+            // TODO - NLS message?\n+            if (tc.isDebugEnabled()) {\n+                Tr.debug(tc, \"Failed to obtain JWT header\");\n+            }\n+            return null;\n+        }\n+        String algHeader = jwtHeader.getAlgorithmHeaderValue();\n+        if (tc.isDebugEnabled()) {\n+            Tr.debug(tc, \"JWT is signed with algorithm: \", algHeader);\n+        }\n+        return algHeader;\n+    }\n+\n+    Throwable getRootCause(Exception e) {\n+        Throwable rootCause = null;\n+        Throwable tmpCause = e;\n+        while (tmpCause != null) {\n+            rootCause = tmpCause;\n+            tmpCause = rootCause.getCause();\n+        }\n+        return rootCause;\n+    }\n+\n+    String createDateString(NumericDate date) {\n+        if (date == null) {\n+            return null;\n+        }\n+        // NumericDate.getValue() returns a value in seconds, so convert to\n+        // milliseconds\n+        return timeUtils.createDateString(1000 * date.getValue());\n+    }\n+\n+    /**\n+     * Helper method to get the AMR Claim from the jwtClaims.This method checks\n+     * if the value is a string and return singletonList or the ArrayList of\n+     * amrClaims. This is called in validateCalims method\n+     *\n+     */\n+    List<String> getJwtAMRList(JwtClaims jwtClaims) throws MalformedClaimException {\n+        String claimName = \"amr\";\n+        Object amrObject = jwtClaims.getClaimValue(claimName);\n+        if (amrObject instanceof String) {\n+            return Collections.singletonList(jwtClaims.getStringClaimValue(claimName));\n+        } else if (!(amrObject instanceof List) && amrObject != null) {\n+            throw new MalformedClaimException(\n+                    \"The value of the 'amr' claim is not an array of strings or a single string value.\");\n+        } else {\n+            return jwtClaims.getStringListClaimValue(claimName);\n+        }\n+    }\n+\n+    /**\n+     * Verifies that values specified in AMR claim is contained in the\n+     * authenticationMethodsReferences list. If allowedAMRClaim is not an array\n+     * then jwtClaims can contain more than required values. If not, then the\n+     * jwtClaimvalues must be a exact match of an element in the array.\n+     */\n+    boolean validateAMRClaim(List<String> allowedAmrClaim, List<String> jwtAMRClaims) {\n+        boolean valid = false;\n+        if (allowedAmrClaim != null && jwtAMRClaims != null) {\n+            // If it is not array just check if jwtClaim containsAll and not\n+            // equals\n+            if (allowedAmrClaim.size() == 1) {\n+                List<String> allowedAMRSingle = Arrays.asList(allowedAmrClaim.get(0).split(\" \"));\n+                if (jwtAMRClaims.containsAll(allowedAMRSingle)) {\n+                    valid = true;\n+                }\n+            } else {\n+                for (String allowedAMR : allowedAmrClaim) {\n+                    List<String> allowedAMRSingle = Arrays.asList(allowedAMR.split(\" \"));\n+                    if (jwtAMRClaims.equals(allowedAMRSingle)) {\n+                        valid = true;\n+                        break;\n+                    }\n+\n+                }\n+            }\n+        } else if (allowedAmrClaim == null) {\n+            //To avoid regression, if new amr config is not specified then return true\n+            valid = true;\n+        } \n+        return valid;\n+    }\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg2NjkxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r461866919", "bodyText": "This new expectation might introduce a regression. A previous JWT that included an \"amr\" claim could have been accepted prior to these changes and it will now be rejected.\nPlease review if the intention is to make the amr claim optional if the jwtConsumer has not been configured with a list of AMRs to validate.", "author": "teddyjtorres", "createdAt": "2020-07-28T20:44:15Z", "path": "dev/com.ibm.ws.security.jwt/test/com/ibm/ws/security/jwt/internal/ConsumerUtilTest.java", "diffHunk": "@@ -1886,6 +1886,61 @@ public void testValidateAlgorithm_algMatch() {\n             outputMgr.failWithThrowable(testName.getMethodName(), t);\n         }\n     }\n+    \n+    /********************************************* validateAMRClaim *********************************************/\n+\n+    /**\n+     * Method under test: {@link ConsumerUtil#validateAMRClaim(List, List)}\n+     */\n+    @Test\n+    public void testValidateAMRClaim() {\n+        try {\n+            List<String> emptyList = new ArrayList<String>();\n+            List<String> singleList = new ArrayList<String>();\n+            singleList.add(\"OTP iris\");\n+            List<String> multipleList = new ArrayList<String>();\n+            multipleList.add(\"OTP iris\");\n+            multipleList.add(\"pwd kba\");\n+\n+            // Null/empty token and allowed amrClaims\n+            assertTrue(\"Validation should have succeeded.\", consumerUtil.validateAMRClaim(null, null));\n+            assertTrue(\"Validation should have succeeded.\", consumerUtil.validateAMRClaim(null, emptyList));\n+            assertFalse(\"Validation should NOT have succeeded.\", consumerUtil.validateAMRClaim(emptyList, null));\n+            assertFalse(\"Validation should NOT have succeeded.\", consumerUtil.validateAMRClaim(emptyList, emptyList));\n+\n+            // Null/empty allowed amr, single amr in the token\n+            assertFalse(\"Validation should NOT have succeeded.\", consumerUtil.validateAMRClaim(null, singleList));", "originalCommit": "8550ee341ed627f6a1ac17beba5b3584115e2858", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b27a3c97bccc3fb6faeb2eae1821bd83072b26eb", "chunk": "diff --git a/dev/com.ibm.ws.security.jwt/test/com/ibm/ws/security/jwt/internal/ConsumerUtilTest.java b/dev/com.ibm.ws.security.jwt/test/com/ibm/ws/security/jwt/internal/ConsumerUtilTest.java\nindex 7f27898d28..ab5aaf4f23 100644\n--- a/dev/com.ibm.ws.security.jwt/test/com/ibm/ws/security/jwt/internal/ConsumerUtilTest.java\n+++ b/dev/com.ibm.ws.security.jwt/test/com/ibm/ws/security/jwt/internal/ConsumerUtilTest.java\n\n@@ -1909,7 +1909,7 @@ public class ConsumerUtilTest {\n             assertFalse(\"Validation should NOT have succeeded.\", consumerUtil.validateAMRClaim(emptyList, emptyList));\n \n             // Null/empty allowed amr, single amr in the token\n-            assertFalse(\"Validation should NOT have succeeded.\", consumerUtil.validateAMRClaim(null, singleList));\n+            assertTrue(\"Validation should have succeeded.\", consumerUtil.validateAMRClaim(null, singleList));\n             assertFalse(\"Validation should NOT have succeeded.\", consumerUtil.validateAMRClaim(emptyList, singleList));\n \n             // Null/empty amr in token, single amr in allowed audiences\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg3Nzc5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/13113#discussion_r461877797", "bodyText": "Test description is not consistent with the assertion being performed.", "author": "teddyjtorres", "createdAt": "2020-07-28T21:03:55Z", "path": "dev/com.ibm.ws.security.jwtsso_fat/fat/src/com/ibm/ws/security/jwtsso/fat/ConfigAttributeTests.java", "diffHunk": "@@ -759,4 +759,28 @@ public void test_sslPortNotDefined() throws Exception {\n         validationUtils.validateResult(response, currentAction, expectations);\n     }\n \n+    /**\n+     * Test that the jwtsso cookie respects the webAppSecurity httpOnlyCookies attribute setting.", "originalCommit": "8d9b4d9d9eb1d36e8a3b759288e8c6bc9dac6664", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "31b940926fec72f5ade10ad09db24ebd90b9b6ab", "chunk": "diff --git a/dev/com.ibm.ws.security.jwtsso_fat/fat/src/com/ibm/ws/security/jwtsso/fat/ConfigAttributeTests.java b/dev/com.ibm.ws.security.jwtsso_fat/fat/src/com/ibm/ws/security/jwtsso/fat/ConfigAttributeTests.java\nindex 6e7a40771e..b3884848a7 100644\n--- a/dev/com.ibm.ws.security.jwtsso_fat/fat/src/com/ibm/ws/security/jwtsso/fat/ConfigAttributeTests.java\n+++ b/dev/com.ibm.ws.security.jwtsso_fat/fat/src/com/ibm/ws/security/jwtsso/fat/ConfigAttributeTests.java\n\n@@ -768,19 +777,55 @@ public class ConfigAttributeTests extends CommonSecurityFat {\n     public void test_amrValue() throws Exception {\n         server.reconfigureServerUsingExpandedConfiguration(_testName, \"server_amrValues.xml\");\n         \n+        String amrUrl = \"http://\" + server.getHostname() + \":\" + server.getHttpDefaultPort() + JwtFatConstants.FORMLOGIN_CONTEXT_ROOT + \"/AmrServlet\";\n+\n         WebClient wc = new WebClient();\n+\n         Page response = actions.invokeUrl(_testName, wc, protectedUrl); // get back the login page\n-        //Check if we got to login page\n-        Expectations expectations = new Expectations();\n-        expectations.addExpectations(CommonExpectations.successfullyReachedLoginPage(TestActions.ACTION_INVOKE_PROTECTED_RESOURCE));\n-        validationUtils.validateResult(response, TestActions.ACTION_INVOKE_PROTECTED_RESOURCE, expectations);\n \n+        // log in, which should drive building a token.\n+        String currentAction = TestActions.ACTION_SUBMIT_LOGIN_CREDENTIALS;\n+        Expectations expectations = new Expectations();\n         response = actions.doFormLogin(response, defaultUser, defaultPassword);\n+        validationUtils.validateResult(response, currentAction, expectations);\n+\n+        WebClient webClient = new WebClient();\n+        Cookie cookie = actions.logInAndObtainJwtCookie(_testName, webClient, protectedUrl, defaultUser, defaultPassword);\n+        System.out.println(cookie);\n \n+//        //Invoke servlet to set security attribute\n+//        response = actions.invokeUrl(_testName, wc, amrUrl);\n+//        expectations = new Expectations();\n+//        expectations.addExpectations(CommonExpectations.successfullyReachedUrl(amrUrl));\n+//        validationUtils.validateResult(response, amrUrl, expectations);\n+\n+        response = buildNewJwtAfterAddingSecurityAttribute(cookie);\n         String responseStr = response.getWebResponse().getContentAsString();\n-        boolean check = responseStr.contains(\"\\\"amr\\\":[BasicRealm]\");\n+        boolean check = responseStr.contains(\"\\\"amr\\\":[\\\"amrValue\\\"]\");\n         assertTrue(\"AMR in token did not match the one configured in the builder\", check);\n+\n         \n     }\n \n+    /**\n+     * Invokes the jwtbuilder web application configured in the server that's used for building JWTs outside of the context of\n+     * the JWT SSO feature. A JWT is built using the jwtBuilder configuration with the provided ID and returned as a cookie in\n+     * the response.\n+     */\n+    private Page buildNewJwtAfterAddingSecurityAttribute(Cookie cookie) throws Exception {\n+        String jwtBuilderUrl = \"http://\" + server.getHostname() + \":\" + server.getHttpDefaultPort() + \"/amrbuilder/AmrServlet\";\n+\n+        List<NameValuePair> requestParams = new ArrayList<NameValuePair>();\n+        requestParams.add(new NameValuePair(JwtBuilderServlet.PARAM_BUILDER_ID, \"defaultJwtSso\"));\n+        \n+        Map<String, String> requestHeaders = new HashMap<>();\n+        requestHeaders.put(\"Cookie\", cookie.getName() + \"=\" + cookie.getValue());\n+\n+        WebClient webClient = new WebClient();\n+        Page response = actions.invokeUrlWithParametersAndHeaders(_testName, webClient, jwtBuilderUrl, requestParams, requestHeaders);\n+        Log.info(thisClass, _testName, \"JWT builder app response: \" + WebResponseUtils.getResponseText(response));\n+\n+        return response;\n+    }\n+\n }\n"}}, {"oid": "b27a3c97bccc3fb6faeb2eae1821bd83072b26eb", "url": "https://github.com/OpenLiberty/open-liberty/commit/b27a3c97bccc3fb6faeb2eae1821bd83072b26eb", "message": "Review comments", "committedDate": "2020-08-17T20:59:47Z", "type": "forcePushed"}, {"oid": "131718a92c414e2bd53bfa8acaa345f283098603", "url": "https://github.com/OpenLiberty/open-liberty/commit/131718a92c414e2bd53bfa8acaa345f283098603", "message": "Added beta fencing", "committedDate": "2020-08-19T23:48:09Z", "type": "forcePushed"}, {"oid": "186b8f2ec5b7a033a9bc4520e9322fa001bdb990", "url": "https://github.com/OpenLiberty/open-liberty/commit/186b8f2ec5b7a033a9bc4520e9322fa001bdb990", "message": "Added beta fencing", "committedDate": "2020-08-19T23:51:50Z", "type": "forcePushed"}, {"oid": "1d187a2aa579af21017e8ddaefb8ebf74d9814e0", "url": "https://github.com/OpenLiberty/open-liberty/commit/1d187a2aa579af21017e8ddaefb8ebf74d9814e0", "message": "Intial commit", "committedDate": "2020-08-25T21:15:18Z", "type": "commit"}, {"oid": "6d845dc2a622049c2f0e19f2db51b1e1d37799e8", "url": "https://github.com/OpenLiberty/open-liberty/commit/6d845dc2a622049c2f0e19f2db51b1e1d37799e8", "message": "Added all test for consumer", "committedDate": "2020-08-25T21:23:53Z", "type": "commit"}, {"oid": "d2aceee598b27b7461f69967cbe4bbb8d49e469e", "url": "https://github.com/OpenLiberty/open-liberty/commit/d2aceee598b27b7461f69967cbe4bbb8d49e469e", "message": "Added all tests for builder", "committedDate": "2020-08-25T21:23:56Z", "type": "commit"}, {"oid": "27c861055b69e011692fc47ded1cfc2cdaf3372b", "url": "https://github.com/OpenLiberty/open-liberty/commit/27c861055b69e011692fc47ded1cfc2cdaf3372b", "message": "Fixed spacing and copyright", "committedDate": "2020-08-25T21:23:56Z", "type": "commit"}, {"oid": "b13effa6a351356b5f50769a88dad81f3be8310e", "url": "https://github.com/OpenLiberty/open-liberty/commit/b13effa6a351356b5f50769a88dad81f3be8310e", "message": "Review comments", "committedDate": "2020-08-25T21:23:56Z", "type": "commit"}, {"oid": "c815c9d52de3d1f0d0e58f26f4e0df8796bb7fff", "url": "https://github.com/OpenLiberty/open-liberty/commit/c815c9d52de3d1f0d0e58f26f4e0df8796bb7fff", "message": "Added beta fencing", "committedDate": "2020-08-25T21:24:54Z", "type": "commit"}, {"oid": "c815c9d52de3d1f0d0e58f26f4e0df8796bb7fff", "url": "https://github.com/OpenLiberty/open-liberty/commit/c815c9d52de3d1f0d0e58f26f4e0df8796bb7fff", "message": "Added beta fencing", "committedDate": "2020-08-25T21:24:54Z", "type": "forcePushed"}, {"oid": "eaaf25d7decca43883b9b8f13eef7ce1e4a9fd08", "url": "https://github.com/OpenLiberty/open-liberty/commit/eaaf25d7decca43883b9b8f13eef7ce1e4a9fd08", "message": "Error message number change", "committedDate": "2020-08-25T22:12:27Z", "type": "commit"}]}