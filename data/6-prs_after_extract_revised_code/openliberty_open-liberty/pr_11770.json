{"pr_number": 11770, "pr_title": "hang resolution cleanup including hung-busy detection", "pr_createdAt": "2020-04-15T14:24:35Z", "pr_url": "https://github.com/OpenLiberty/open-liberty/pull/11770", "timeline": [{"oid": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "url": "https://github.com/OpenLiberty/open-liberty/commit/06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-04-15T14:42:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0ODMyNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r411748325", "bodyText": "Copyright should be updated to say 2012, 2020 instead of 2012, 2016", "author": "jhanders34", "createdAt": "2020-04-20T23:01:21Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -136,6 +136,12 @@\n      */\n     private int hangBufferPoolSize = 0;\n \n+    /**", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTg3Ng==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416931876", "bodyText": "Done", "author": "gjdeval", "createdAt": "2020-04-28T21:23:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc0ODMyNQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MDM1MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r411750351", "bodyText": "Should the comment be updated?", "author": "jhanders34", "createdAt": "2020-04-20T23:06:29Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1217,7 +1225,7 @@ int adjustPoolSize(int poolSize, int poolAdjustment) {\n \n         if (poolAdjustment != 0) {\n             // don't shrink below coreThreads", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMjg3MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416932871", "bodyText": "Done", "author": "gjdeval", "createdAt": "2020-04-28T21:25:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1MDM1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "85e68df00e1ef4752ee367d82d6c73960aa9a527", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex 2c57d50ec5..172ef94188 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -1224,7 +1225,7 @@ public final class ThreadPoolController {\n         lastAction = LastAction.NONE;\n \n         if (poolAdjustment != 0) {\n-            // don't shrink below coreThreads\n+            // don't shrink too far\n             if (poolAdjustment < 0 && newPoolSize >= currentMinimumPoolSize) {\n                 lastAction = LastAction.SHRINK;\n                 setPoolSize(newPoolSize);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1ODUyOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r411758528", "bodyText": "Should the comment be updated?", "author": "jhanders34", "createdAt": "2020-04-20T23:28:11Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -893,19 +901,19 @@ boolean handleOutliers(ThroughputDistribution distribution, double throughput) {\n         boolean flippedCoin = false;\n         int downwardCompareSpan = 0;\n \n-        if (poolSize >= coreThreads + poolDecrement) {\n+        if (poolSize >= currentMinimumPoolSize + poolDecrement) {\n             // compareSpan is poolSize range used for throughput comparison\n-            downwardCompareSpan = Math.min(compareRange * poolDecrement, poolSize - coreThreads);\n+            downwardCompareSpan = Math.min(compareRange * poolDecrement, poolSize - currentMinimumPoolSize);\n \n             // if poolSize already close to coreThreads, we can skip some shrinkScore tweaks", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTc5OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416931798", "bodyText": "Done", "author": "gjdeval", "createdAt": "2020-04-28T21:23:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc1ODUyOA=="}], "type": "inlineReview", "revised_code": {"commit": "85e68df00e1ef4752ee367d82d6c73960aa9a527", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex 2c57d50ec5..172ef94188 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -905,7 +906,7 @@ public final class ThreadPoolController {\n             // compareSpan is poolSize range used for throughput comparison\n             downwardCompareSpan = Math.min(compareRange * poolDecrement, poolSize - currentMinimumPoolSize);\n \n-            // if poolSize already close to coreThreads, we can skip some shrinkScore tweaks\n+            // if poolSize already close to currentMinimumPoolSize, we can skip some shrinkScore tweaks\n             boolean smallPool = ((poolSize - currentMinimumPoolSize) <= downwardCompareSpan);\n \n             // average the probabilityGreaterThan results for all valid (not too old or out-of-range)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2MDU1OA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r411760558", "bodyText": "currentMinimumPoolSize is not reset in resetThreadPool.  Should it be?  Or should resetThreadPool use currentMinimumPoolSize instead of coreThreads in its calculation?", "author": "jhanders34", "createdAt": "2020-04-20T23:30:33Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -606,6 +612,7 @@\n         this.executorService = executorService;\n         this.threadPool = pool;\n         this.coreThreads = pool.getCorePoolSize();\n+        this.currentMinimumPoolSize = this.coreThreads;", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMTY1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416931654", "bodyText": "resetThreadPool zeros out all the stats - so on that basis, I'm going with setting currentMinimumPoolSize to coreThreads\ngood catch :)", "author": "gjdeval", "createdAt": "2020-04-28T21:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc2MDU1OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3MTU5NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r415771594", "bodyText": "Should the comments and trace be updated here to reference currentMinimumPoolSize instead of coreThreads?", "author": "jhanders34", "createdAt": "2020-04-27T12:31:42Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1760,13 +1796,14 @@ private void setPoolIncrementDecrement(int poolSize) {\n          * decrement exactly to coreThreads.\n          */\n ", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NTg2Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416945867", "bodyText": "Done", "author": "gjdeval", "createdAt": "2020-04-28T21:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3MTU5NA=="}], "type": "inlineReview", "revised_code": {"commit": "85e68df00e1ef4752ee367d82d6c73960aa9a527", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex 2c57d50ec5..172ef94188 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -1791,17 +1792,17 @@ public final class ThreadPoolController {\n         }\n \n         /**\n-         * ... similar special case for coreThreads ...\n+         * ... similar special case for currentMinimumPoolSize ...\n          * We *should* never hit this, but just in case ... makes sure that we can\n-         * decrement exactly to coreThreads.\n+         * decrement exactly to currentMinimumPoolSize.\n          */\n \n         if (poolSize - poolDecrement < currentMinimumPoolSize) {\n             if (poolSize > currentMinimumPoolSize) {\n                 if (tc.isEventEnabled()) {\n-                    Tr.event(tc, \"poolDecrement vs coreThreads check\", (\" poolSize \" + poolSize +\n-                                                                        \" , poolDecrement: \" + poolDecrement + \", coreThreads: \" + coreThreads\n-                                                                        + \" , currentMinimumPoolSize: \" + currentMinimumPoolSize));\n+                    Tr.event(tc, \"poolDecrement vs currentMinimumPoolSize check\", (\" poolSize \" + poolSize +\n+                                                                                   \" , poolDecrement: \" + poolDecrement + \", coreThreads: \" + coreThreads\n+                                                                                   + \" , currentMinimumPoolSize: \" + currentMinimumPoolSize));\n                 }\n                 poolDecrement = poolSize - currentMinimumPoolSize;\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NDYzOA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r415774638", "bodyText": "Should the above code be updated?\n    if (poolSize < coreThreads) {\n        return \"poolSize < coreThreads\";\n    }\n\nThis ties into the reset though as well and your logic about things not adjusting between intervals.  It is a question that may have the answer of no.  If there is a short lived hang that doesn't require us to grow to the new hang pool size because it resolves with less than that and we never grow to that limit.", "author": "jhanders34", "createdAt": "2020-04-27T12:36:26Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1285,9 +1293,13 @@ synchronized String evaluateInterval() {\n                 return \"monitoring paused\";\n             }\n ", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzOTA1NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416939054", "bodyText": "That check is intended as a start-of-pool-life sanity check. The pool behavior is to start a new thread for every task until it gets to coreThreads size, and until it gets there we don't need to make any adjustments. I think it is correct to leave this one at coreThreads, rather than currentMinimumThreads. If we raised currentMinimumThreads in a hang-resolution action and didn't get there yet, we will figure that out later when resolveHang calls checkTargetPoolSize, and take action if the situation persists.", "author": "gjdeval", "createdAt": "2020-04-28T21:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NDYzOA=="}], "type": "inlineReview", "revised_code": {"commit": "e11368e29139f3e26739ee75ec684974feed68d0", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex 2c57d50ec5..ca985e3d95 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -1295,8 +1315,9 @@ public final class ThreadPoolController {\n \n             if (resolveHang(deltaCompleted, queueEmpty, poolSize, cpuHigh)) {\n                 if (tc.isEventEnabled()) {\n-                    Tr.event(tc, \"\\nExecutor hang detected - poolSize: \" + poolSize + \", queueDepth: \" + queueDepth +\n-                                 \", cpuUtil: \" + cpuUtil + \", processCpuUtil: \" + processCpuUtil + \", systemCpuUtil: \" + systemCpuUtil);\n+                    Tr.event(tc, \"Executor hang detected - poolSize: \" + poolSize + \", activeThreads: \" + activeThreads +\n+                                 \", queueDepth: \" + queueDepth + \", cpuUtil: \" + df.format(cpuUtil) + \", processCpuUtil: \" +\n+                                 df.format(processCpuUtil) + \", systemCpuUtil: \" + df.format(systemCpuUtil));\n                 }\n                 /**\n                  * Sleep the controller thread briefly after increasing the pool size\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3OTI2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r415779265", "bodyText": "I do not understand this else case.", "author": "jhanders34", "createdAt": "2020-04-27T12:43:22Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1552,12 +1585,15 @@ private boolean resolveHang(long tasksCompleted, boolean queueEmpty, int poolSiz\n                     if (controllerCyclesWithoutHang > noHangCyclesThreshold) {\n                         setPoolIncrementDecrement(poolSize);\n                         hangBufferPoolSize -= poolDecrement;\n+                        currentMinimumPoolSize = hangBufferPoolSize;\n                         controllerCyclesWithoutHang = 0;\n                     }\n                 }\n+            } else {", "originalCommit": "06ce0bec1f4f9eeeb92dfc4d6103224afd17e5d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MzEzNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r416943136", "bodyText": "The intent is to \"reset\" currentMinimumPoolSize when a hang condition has abated and hangBufferPoolSize is being relaxed. I think this should happen anyway the last time through the 'if' side of this logic, but I wasn't 100% sure, so I put the 'else' in as a safety-valve ... maybe not necessary?", "author": "gjdeval", "createdAt": "2020-04-28T21:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3OTI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU1OTk3NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419559974", "bodyText": "Based off of the logic, it seemed unnecessary to me which is why I brought it up.", "author": "jhanders34", "createdAt": "2020-05-04T16:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3OTI2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNjE5Nw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420236197", "bodyText": "OK, deleted it.", "author": "gjdeval", "createdAt": "2020-05-05T16:19:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3OTI2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "85e68df00e1ef4752ee367d82d6c73960aa9a527", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex 2c57d50ec5..172ef94188 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -1574,13 +1575,13 @@ public final class ThreadPoolController {\n                 }\n             }\n             /**\n-             * if controller is running below hangResolutionPoolSize marker without hanging,\n-             * we can reduce that marker ... the workload must have changed, so prior hang\n-             * information is no longer valid. We will reduce it gradually, to maintain a\n-             * conservative stance toward avoiding hangs.\n+             * if controller is running at or below hangResolutionPoolSize marker without hanging,\n+             * we can reduce that marker ... the workload must have changed, so prior hang setting\n+             * is no longer valid. We will reduce it gradually, to maintain a conservative stance\n+             * toward avoiding hangs.\n              */\n             if (hangBufferPoolSize > coreThreads) {\n-                if (hangBufferPoolSize > poolSize) {\n+                if (hangBufferPoolSize >= poolSize) {\n                     controllerCyclesWithoutHang++;\n                     if (controllerCyclesWithoutHang > noHangCyclesThreshold) {\n                         setPoolIncrementDecrement(poolSize);\n"}}, {"oid": "85e68df00e1ef4752ee367d82d6c73960aa9a527", "url": "https://github.com/OpenLiberty/open-liberty/commit/85e68df00e1ef4752ee367d82d6c73960aa9a527", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-04-28T22:59:05Z", "type": "forcePushed"}, {"oid": "e11368e29139f3e26739ee75ec684974feed68d0", "url": "https://github.com/OpenLiberty/open-liberty/commit/e11368e29139f3e26739ee75ec684974feed68d0", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-04-30T20:36:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MzMwNg==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419563306", "bodyText": "The use of activeThreads in this method is confusing now that you have a instance scoped variable with the same name.  In reality activeThreads doesn't actually portray what this argument is.  numberOfThreads or something like that may be a better option.", "author": "jhanders34", "createdAt": "2020-05-04T16:27:00Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -749,6 +775,7 @@ synchronized void resume() {\n      * @return the data representing the throughput distribution for the\n      *         specified number of active threads\n      */\n+    @Trivial\n     ThroughputDistribution getThroughputDistribution(int activeThreads, boolean create) {", "originalCommit": "e11368e29139f3e26739ee75ec684974feed68d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIxMzgwNQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420213805", "bodyText": "Agree, done.", "author": "gjdeval", "createdAt": "2020-05-05T15:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2MzMwNg=="}], "type": "inlineReview", "revised_code": {"commit": "affbd9c17c0d80136310b520072212b27c8cd8a1", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex ca985e3d95..e5a099e38c 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -766,20 +766,20 @@ public final class ThreadPoolController {\n      * Get the throughput distribution data associated with the specified\n      * number of active threads.\n      *\n-     * @param activeThreads the number of active threads when the data was\n-     *                          collected\n+     * @param numberOfThreads the number of active threads when the data was\n+     *                            collected\n      *\n-     * @param create        whether to create and return a new throughput distribution\n-     *                          if none currently exists\n+     * @param create          whether to create and return a new throughput distribution\n+     *                            if none currently exists\n      *\n      * @return the data representing the throughput distribution for the\n      *         specified number of active threads\n      */\n     @Trivial\n-    ThroughputDistribution getThroughputDistribution(int activeThreads, boolean create) {\n-        if (activeThreads < coreThreads)\n-            activeThreads = coreThreads;\n-        Integer threads = Integer.valueOf(activeThreads);\n+    ThroughputDistribution getThroughputDistribution(int numberOfThreads, boolean create) {\n+        if (numberOfThreads < coreThreads)\n+            numberOfThreads = coreThreads;\n+        Integer threads = Integer.valueOf(numberOfThreads);\n         ThroughputDistribution throughput = threadStats.get(threads);\n         if ((throughput == null) && create) {\n             throughput = new ThroughputDistribution();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzY0NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419567644", "bodyText": "I am not sure if this is the right comparison for lowActivity related to activeThreads.  I would expect it to be something like activeThreads < poolSize - poolIncrement or maybe 2 * poolIncrement.", "author": "jhanders34", "createdAt": "2020-05-04T16:33:41Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1323,21 +1356,21 @@ synchronized String evaluateInterval() {\n                 currentStats.addDataPoint(throughput, controllerCycle);\n             }\n \n-            boolean lowTput = false;\n-            if (queueDepth == 0 && throughput < poolSize * lowTputThreadsRatio) {\n-                lowTput = true;\n+            boolean lowActivity = false;\n+            if (queueEmpty && ((throughput < (poolSize * lowTputThreadsRatio)) || (activeThreads < (poolSize * activeThreadsGrowthRatio)))) {", "originalCommit": "e11368e29139f3e26739ee75ec684974feed68d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYwNzQwNw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419607407", "bodyText": "Also need to consider looking if less than coreThreads or currentMinimumPoolSize.  May treat those differently.", "author": "jhanders34", "createdAt": "2020-05-04T17:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzMjkyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420232923", "bodyText": "I am also not sure about this :-) but was just looking for a clear indicator of \"low activity\". Finding that a sizable chunk (default 25%) of the threads were not doing anything at the moment of the snapshot seemed to qualify.\nAt this point in the flow, I don't think we need to worry about the absolute number of active threads, e.g. by comparing to coreThreads or currentMinimumPoolSize. This is just to inform getShrinkScore, getGrowScore, and forceVariation that \"the pool isn't doing much work right now\", so they can make their decisions accordingly. Those methods deal with boundary limits like coreThreads and currentMinimumPoolSize.", "author": "gjdeval", "createdAt": "2020-05-05T16:14:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NDkzMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420464933", "bodyText": "One of my issues that I have is that 25% means different things at different thread pool sizes.  75% of 12 is 9.  If it is at 8, but the increment level is 8, we go down to 4 when we shouldn't.  We will just to right back up.  This is why I suggested using a factor of the poolDecrement in order to make the decision of being low activity.\nWhen we get to the lower numbers and closer to the coreThreads or currentMinimumPoolSize, we may have to have different characteristics.  Maybe need a Math.max(75% of current pool size, currentMinimumPoolSize);  that is why I brought up having a different criteria when we get close to currentMinimumPoolSize or coreThreads.  I didn't want us to not decide to shrink because we think we have high activity even though we don't because it is not less than 75% of the current pool size, but it is lower than currentMinimumPoolSize / coreThreads.", "author": "jhanders34", "createdAt": "2020-05-05T23:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg0NDkyMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420844923", "bodyText": "The way lowActivity is used in the controller is primarily to curb unnecessary growth - it does not force the pool to shrink. If lowActivity is true, then getGrowScore returns 0 and forceVariation will not grow the pool. The effect of lowActivity on shrink decisions is much more subtle - a nudge to increase shrinkScore in some cases.\n\n\nWe don't have to worry about lowActivity pushing the pool size below currentMinimumPoolSize because that is prevented by checks in adjustPoolSize.\n\n\nThe example you gave will never arise, because poolDecrement will always be no greater than Math.floor(25% of pool size).\n\n\nFor example, say cpus=2 - then coreThreads is 4 and poolIncrement/Decrement is 2\nSo if poolSize=12, then activeThreads < 9 (8 or lower) would help set lowActivity, but dropping 2 threads from 12 leaves 10, which is 2 above activeThreads.\nThings are closer on the first increment - if poolSize=6 then activeThreads has to be 4 or lower for lowActivity to be set, and a poolDecrement of 2 is still safe\n\n\nTo overcome any concern about shrinking below activeThreads, it is probably a good idea to add it as a limit to shrinking in adjustPoolSize:\n     if (poolAdjustment < 0 && newPoolSize >= Math.max(currentMinimumPoolSize,activeThreads) {\n\n\n\nThat would protect us against unexpected behavior if the various system properties have been manually configured in such a way that poolDecrement might be greater than 25% of poolSize.\nThe thing that I like about 75% is that it provides a very general flag that \"hey the pool is really not very busy at the moment\" which is a good clue that the controller really should not grow the pool, even randomly, and should think about maybe shrinking it. :-)", "author": "gjdeval", "createdAt": "2020-05-06T14:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzY0NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3ODQyMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419578421", "bodyText": "warnings are translated messages.  If you are going to leave this in here you should add a translated message for it.  This will automatically get an FFDC added due to instrumentation which likely will be sufficient.", "author": "jhanders34", "createdAt": "2020-05-04T16:50:19Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1350,16 +1383,21 @@ synchronized String evaluateInterval() {\n             }\n \n             // Force some random variation into the pool size algorithm\n-            poolAdjustment = forceVariation(poolSize, poolAdjustment, deltaCompleted, lowTput);\n+            poolAdjustment = forceVariation(poolSize, poolAdjustment, deltaCompleted, lowActivity);\n \n             // Format an event level trace point with the most useful data\n             if (tc.isEventEnabled()) {\n-                Tr.event(tc, \"Interval data\", toIntervalData(throughput, forecast, shrinkScore, growScore, poolSize, poolAdjustment));\n+                Tr.event(tc, \"Interval data\", toIntervalData(throughput, forecast, deltaCompleted, shrinkScore, growScore,\n+                                                             poolSize, poolAdjustment));\n             }\n \n             // Change the pool size and save the result, will check it at start of next control cycle\n             targetPoolSize = adjustPoolSize(poolSize, poolAdjustment);\n \n+        } catch (Exception ex) {\n+            if (tc.isWarningEnabled()) {\n+                Tr.warning(tc, \"Exception caught: \" + ex);", "originalCommit": "e11368e29139f3e26739ee75ec684974feed68d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3OTM2NQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419579365", "bodyText": "There is a catch on the caller to this method so it should have made an FFDC for any exception as well?  Did you not see one?", "author": "jhanders34", "createdAt": "2020-05-04T16:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3ODQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIyMjIxOQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420222219", "bodyText": "Mmmm ... I did not see an FFDC, but may have overlooked it.\nGuess I will delete this catch.", "author": "gjdeval", "createdAt": "2020-05-05T15:59:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3ODQyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "affbd9c17c0d80136310b520072212b27c8cd8a1", "chunk": "diff --git a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\nindex ca985e3d95..e5a099e38c 100644\n--- a/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n+++ b/dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java\n\n@@ -1394,10 +1394,6 @@ public final class ThreadPoolController {\n             // Change the pool size and save the result, will check it at start of next control cycle\n             targetPoolSize = adjustPoolSize(poolSize, poolAdjustment);\n \n-        } catch (Exception ex) {\n-            if (tc.isWarningEnabled()) {\n-                Tr.warning(tc, \"Exception caught: \" + ex);\n-            }\n         } finally {\n             lastTimerPop = currentTime;\n             previousCompleted = completedWork;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4NTM0MQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419585341", "bodyText": "Should this call executorService.getActiveThreads() instead?", "author": "jhanders34", "createdAt": "2020-05-04T17:00:52Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -1264,6 +1291,7 @@ synchronized String evaluateInterval() {\n         try {\n             queueDepth = threadPool.getQueue().size();\n             boolean queueEmpty = (queueDepth <= 0);\n+            activeThreads = threadPool.getActiveCount();", "originalCommit": "e11368e29139f3e26739ee75ec684974feed68d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYzNzQxMw==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r419637413", "bodyText": "I am thinking it shouldn't be executorService.getActiveThreads() because it is how many threads are active and are waiting to run.", "author": "jhanders34", "createdAt": "2020-05-04T18:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4NTM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIyNDA2NA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420224064", "bodyText": "threadPool.getActiveCount() seems to do what I want - when things are busy, activeThreads is equal to poolSize, as the system quiets down activeThreads falls below poolSize.\nI'm trying to keep this relatively simple - at this snapshot time, were most of the threads working or were many of them idle.", "author": "gjdeval", "createdAt": "2020-05-05T16:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4NTM0MQ=="}], "type": "inlineReview", "revised_code": null}, {"oid": "affbd9c17c0d80136310b520072212b27c8cd8a1", "url": "https://github.com/OpenLiberty/open-liberty/commit/affbd9c17c0d80136310b520072212b27c8cd8a1", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-05-05T16:21:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NjIwMA==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420466200", "bodyText": "It would appear that this does not need to be an instance scoped variable, but instead can be passed to toIntervalData in evaluateInterval.  It is only used in those two methods.", "author": "jhanders34", "createdAt": "2020-05-05T23:26:13Z", "path": "dev/com.ibm.ws.threading/src/com/ibm/ws/threading/internal/ThreadPoolController.java", "diffHunk": "@@ -395,13 +413,19 @@\n     private double processCpuUtil = -1.0;\n     private double systemCpuUtil = -1.0;\n     private double cpuUtil = -1.0;\n+    private static DecimalFormat df = new DecimalFormat(\"0.00\", DecimalFormatSymbols.getInstance(Locale.US));\n \n     /**\n      * The controller uses the threadpool queue depth as an input to some of the\n      * decisions it makes.\n      */\n     private int queueDepth = 0;\n \n+    /**\n+     * How many threads are active (running tasks) at the current controller cycle\n+     */\n+    private int activeThreads = 0;\n+", "originalCommit": "affbd9c17c0d80136310b520072212b27c8cd8a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDg0ODgxMQ==", "url": "https://github.com/OpenLiberty/open-liberty/pull/11770#discussion_r420848811", "bodyText": "I've just added a use of activeThreads in adjustPoolSize ... could still change it to be passed into the methods as a parameter, not sure how much difference it makes?", "author": "gjdeval", "createdAt": "2020-05-06T14:44:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NjIwMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "b35f54e5df454f094d4c30f5ae45df0297944ce6", "url": "https://github.com/OpenLiberty/open-liberty/commit/b35f54e5df454f094d4c30f5ae45df0297944ce6", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-05-06T15:44:10Z", "type": "forcePushed"}, {"oid": "f3848a40399797edbdb029e67ed94805aa618d09", "url": "https://github.com/OpenLiberty/open-liberty/commit/f3848a40399797edbdb029e67ed94805aa618d09", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-05-08T21:24:01Z", "type": "forcePushed"}, {"oid": "b3bdcbf3afb1175584ad6ed581b8611c5f253a2b", "url": "https://github.com/OpenLiberty/open-liberty/commit/b3bdcbf3afb1175584ad6ed581b8611c5f253a2b", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-05-08T22:15:44Z", "type": "forcePushed"}, {"oid": "a5602001feab17db292bfc7623d2ff81f81e721b", "url": "https://github.com/OpenLiberty/open-liberty/commit/a5602001feab17db292bfc7623d2ff81f81e721b", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-05-11T14:30:13Z", "type": "commit"}, {"oid": "a5602001feab17db292bfc7623d2ff81f81e721b", "url": "https://github.com/OpenLiberty/open-liberty/commit/a5602001feab17db292bfc7623d2ff81f81e721b", "message": "hang resolution cleanup including hung-busy detection", "committedDate": "2020-05-11T14:30:13Z", "type": "forcePushed"}]}