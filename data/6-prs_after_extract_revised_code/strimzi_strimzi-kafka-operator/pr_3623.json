{"pr_number": 3623, "pr_title": "Redesigned unknown and deprecated fields in resource status conditions", "pr_createdAt": "2020-09-09T23:08:20Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyOTU5Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486129593", "bodyText": "Why does this have to be a class extending CustomerResource rather than an interface that extends HasMetadata and HasStatus?", "author": "tombentley", "createdAt": "2020-09-10T07:39:09Z", "path": "api/src/main/java/io/strimzi/api/kafka/AbstractCustomResource.java", "diffHunk": "@@ -0,0 +1,17 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka;\n+\n+import io.fabric8.kubernetes.client.CustomResource;\n+import io.strimzi.api.kafka.model.Spec;\n+import io.strimzi.api.kafka.model.status.HasStatus;\n+import io.strimzi.api.kafka.model.status.Status;\n+\n+public abstract class AbstractCustomResource<T extends Spec, S extends Status> extends CustomResource implements HasStatus<S> {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NjUzMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486156531", "bodyText": "Agreed with tom here,  seems like making  a combined interface would probably be a marginally better solution here", "author": "samuel-hawker", "createdAt": "2020-09-10T08:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyOTU5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "273c50a146e02180900de8e91ebf71c985928df8", "chunk": "diff --git a/api/src/main/java/io/strimzi/api/kafka/AbstractCustomResource.java b/api/src/main/java/io/strimzi/api/kafka/AbstractCustomResource.java\ndeleted file mode 100644\nindex 94ee9b427a..0000000000\n--- a/api/src/main/java/io/strimzi/api/kafka/AbstractCustomResource.java\n+++ /dev/null\n\n@@ -1,17 +0,0 @@\n-/*\n- * Copyright Strimzi authors.\n- * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n- */\n-package io.strimzi.api.kafka;\n-\n-import io.fabric8.kubernetes.client.CustomResource;\n-import io.strimzi.api.kafka.model.Spec;\n-import io.strimzi.api.kafka.model.status.HasStatus;\n-import io.strimzi.api.kafka.model.status.Status;\n-\n-public abstract class AbstractCustomResource<T extends Spec, S extends Status> extends CustomResource implements HasStatus<S> {\n-    public abstract T getSpec();\n-    public abstract void setSpec(T spec);\n-    public abstract S getStatus();\n-    public abstract void setStatus(S status);\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzNDYzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486134636", "bodyText": "It shouldn't be in this PR, but I think we should consider using proper names rather than single letters for type parameters, since it remembering the single letters gets harder the more thee are of them.", "author": "tombentley", "createdAt": "2020-09-10T07:47:50Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -40,20 +51,22 @@\n  *\n  * <ul>\n  * <li>uses the Fabric8 kubernetes API and implements\n- * {@link #reconcile(Reconciliation)} by delegating to abstract {@link #createOrUpdate(Reconciliation, HasMetadata)}\n+ * {@link #reconcile(Reconciliation)} by delegating to abstract {@link #createOrUpdate(Reconciliation, AbstractCustomResource)}\n  * and {@link #delete(Reconciliation)} methods for subclasses to implement.\n  * \n- * <li>add support for operator-side {@linkplain #validate(HasMetadata) validation}.\n+ * <li>add support for operator-side {@linkplain #validate(AbstractCustomResource) validation}.\n  *     This can be used to automatically log warnings about source resources which used deprecated part of the CR API.\n  *\n  * </ul>\n  * @param <T> The Java representation of the Kubernetes resource, e.g. {@code Kafka} or {@code KafkaConnect}\n- * @param <S> The \"Resource Operator\" for the source resource type. Typically this will be some instantiation of\n+ * @param <O> The \"Resource Operator\" for the source resource type. Typically this will be some instantiation of\n  *           {@link io.strimzi.operator.common.operator.resource.CrdOperator}.\n  */\n public abstract class AbstractOperator<\n-        T extends HasMetadata,\n-        S extends AbstractWatchableResourceOperator<?, T, ?, ?, ?>>\n+        T extends AbstractCustomResource<P, S>,\n+        P extends Spec,\n+        S extends Status,\n+        O extends AbstractWatchableResourceOperatorWithStatus<?, T, ?, ?, ?>>", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -51,22 +52,22 @@ import static io.strimzi.operator.common.Util.async;\n  *\n  * <ul>\n  * <li>uses the Fabric8 kubernetes API and implements\n- * {@link #reconcile(Reconciliation)} by delegating to abstract {@link #createOrUpdate(Reconciliation, AbstractCustomResource)}\n+ * {@link #reconcile(Reconciliation)} by delegating to abstract {@link #createOrUpdate(Reconciliation, CustomResource)}\n  * and {@link #delete(Reconciliation)} methods for subclasses to implement.\n  * \n- * <li>add support for operator-side {@linkplain #validate(AbstractCustomResource) validation}.\n+ * <li>add support for operator-side {@linkplain #validate(CustomResource) validation}.\n  *     This can be used to automatically log warnings about source resources which used deprecated part of the CR API.\n- *\n+ *\u0105\n  * </ul>\n  * @param <T> The Java representation of the Kubernetes resource, e.g. {@code Kafka} or {@code KafkaConnect}\n  * @param <O> The \"Resource Operator\" for the source resource type. Typically this will be some instantiation of\n  *           {@link io.strimzi.operator.common.operator.resource.CrdOperator}.\n  */\n public abstract class AbstractOperator<\n-        T extends AbstractCustomResource<P, S>,\n+        T extends CustomResource & HasSpecAndStatus<P, S>,\n         P extends Spec,\n         S extends Status,\n-        O extends AbstractWatchableResourceOperatorWithStatus<?, T, ?, ?, ?>>\n+        O extends AbstractWatchableStatusedResourceOperator<?, T, ?, ?, ?>>\n             implements Operator {\n \n     private static final Logger log = LogManager.getLogger(AbstractOperator.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzNzc2MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486137761", "bodyText": "I find this method signature a little odd. You're only passing unknownAndDeprecatedConditions so you can add it to desiredStatus. I think it would be better to factor that into its own method which the caller of this method invokes and passes just the desiredStatus.", "author": "tombentley", "createdAt": "2020-09-10T07:53:11Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -200,6 +262,75 @@ private String getLockName(String namespace, String name) {\n         return result.future();\n     }\n \n+\n+\n+    /**\n+     * Updates the Status field of the Kafka CR. It diffs the desired status against the current status and calls\n+     * the update only when there is any difference in non-timestamp fields.\n+     *\n+     * @param desiredStatus The KafkaStatus which should be set\n+     *\n+     * @return\n+     */\n+    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus, List<Condition> unknownAndDeprecatedConditions) {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -262,17 +272,22 @@ public abstract class AbstractOperator<\n         return result.future();\n     }\n \n-\n+    private void addWarningsToStatus(Status status, Set<Condition> unknownAndDeprecatedConditions)   {\n+        if (status != null)  {\n+            status.addConditions(unknownAndDeprecatedConditions);\n+        }\n+    }\n \n     /**\n      * Updates the Status field of the Kafka CR. It diffs the desired status against the current status and calls\n      * the update only when there is any difference in non-timestamp fields.\n      *\n+     * @param reconciliation the reconciliation identified\n      * @param desiredStatus The KafkaStatus which should be set\n      *\n      * @return\n      */\n-    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus, List<Condition> unknownAndDeprecatedConditions) {\n+    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus) {\n         if (desiredStatus == null)  {\n             log.debug(\"{}: Desired status is null - status will not be updated\", reconciliation);\n             return Future.succeededFuture();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzOTE1OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486139159", "bodyText": "Wouldn't it be easier if the ValidationVisitor just returned a List<Condition>, rather than having to map the two lists of Strings to Conditions?", "author": "tombentley", "createdAt": "2020-09-10T07:55:31Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -258,10 +389,31 @@ private String getLockName(String namespace, String name) {\n      * @param resource The custom resource\n      * @throws InvalidResourceException if the resource cannot be safely reconciled.\n      */\n-    protected void validate(T resource) {\n+    protected List<Condition> validate(T resource) {\n         if (resource != null) {\n-            ResourceVisitor.visit(resource, new ValidationVisitor(resource, log));\n+            Set<String> unknownFields = new HashSet<>(0);\n+            Set<String> deprecatedFields = new HashSet<>(0);\n+\n+            ResourceVisitor.visit(resource, new ValidationVisitor(resource, log, unknownFields, deprecatedFields));", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -389,31 +389,16 @@ public abstract class AbstractOperator<\n      * @param resource The custom resource\n      * @throws InvalidResourceException if the resource cannot be safely reconciled.\n      */\n-    protected List<Condition> validate(T resource) {\n+    private Set<Condition> validate(T resource) {\n         if (resource != null) {\n-            Set<String> unknownFields = new HashSet<>(0);\n-            Set<String> deprecatedFields = new HashSet<>(0);\n+            Set<Condition> warningConditions = new HashSet<>(0);\n \n-            ResourceVisitor.visit(resource, new ValidationVisitor(resource, log, unknownFields, deprecatedFields));\n+            ResourceVisitor.visit(resource, new ValidationVisitor(resource, log, warningConditions));\n \n-            return prepareUnknownAndDeprecatedFieldsConditions(unknownFields, deprecatedFields);\n+            return warningConditions;\n         }\n \n-        return Collections.emptyList();\n-    }\n-\n-    private static List<Condition> prepareUnknownAndDeprecatedFieldsConditions(Set<String> unknownFields, Set<String> deprecatedFields)  {\n-        List<Condition> conditions = new ArrayList<>(unknownFields.size() + deprecatedFields.size());\n-\n-        for (String msg : unknownFields)    {\n-            conditions.add(StatusUtils.buildWarningCondition(\"UnknownFields\", msg));\n-        }\n-\n-        for (String msg : deprecatedFields)    {\n-            conditions.add(StatusUtils.buildWarningCondition(\"DeprecatedFields\", msg));\n-        }\n-\n-        return conditions;\n+        return Collections.emptySet();\n     }\n \n     public Future<Set<NamespaceAndName>> allResourceNames(String namespace) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzOTQwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486139402", "bodyText": "Does this still need to be protected?", "author": "tombentley", "createdAt": "2020-09-10T07:55:54Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -258,10 +389,31 @@ private String getLockName(String namespace, String name) {\n      * @param resource The custom resource\n      * @throws InvalidResourceException if the resource cannot be safely reconciled.\n      */\n-    protected void validate(T resource) {\n+    protected List<Condition> validate(T resource) {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -389,31 +389,16 @@ public abstract class AbstractOperator<\n      * @param resource The custom resource\n      * @throws InvalidResourceException if the resource cannot be safely reconciled.\n      */\n-    protected List<Condition> validate(T resource) {\n+    private Set<Condition> validate(T resource) {\n         if (resource != null) {\n-            Set<String> unknownFields = new HashSet<>(0);\n-            Set<String> deprecatedFields = new HashSet<>(0);\n+            Set<Condition> warningConditions = new HashSet<>(0);\n \n-            ResourceVisitor.visit(resource, new ValidationVisitor(resource, log, unknownFields, deprecatedFields));\n+            ResourceVisitor.visit(resource, new ValidationVisitor(resource, log, warningConditions));\n \n-            return prepareUnknownAndDeprecatedFieldsConditions(unknownFields, deprecatedFields);\n+            return warningConditions;\n         }\n \n-        return Collections.emptyList();\n-    }\n-\n-    private static List<Condition> prepareUnknownAndDeprecatedFieldsConditions(Set<String> unknownFields, Set<String> deprecatedFields)  {\n-        List<Condition> conditions = new ArrayList<>(unknownFields.size() + deprecatedFields.size());\n-\n-        for (String msg : unknownFields)    {\n-            conditions.add(StatusUtils.buildWarningCondition(\"UnknownFields\", msg));\n-        }\n-\n-        for (String msg : deprecatedFields)    {\n-            conditions.add(StatusUtils.buildWarningCondition(\"DeprecatedFields\", msg));\n-        }\n-\n-        return conditions;\n+        return Collections.emptySet();\n     }\n \n     public Future<Set<NamespaceAndName>> allResourceNames(String namespace) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzOTg5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486139898", "bodyText": "Javadoc", "author": "tombentley", "createdAt": "2020-09-10T07:56:46Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.common;\n+\n+import io.strimzi.api.kafka.model.status.Status;\n+\n+public class ReconciliationException extends Exception {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java b/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java\nindex 71cf044815..082949f4de 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java\n\n@@ -6,14 +6,30 @@ package io.strimzi.operator.common;\n \n import io.strimzi.api.kafka.model.status.Status;\n \n+/**\n+ * Custom exception which wraps the Custom Resource status together with the original exception which caused the issue.\n+ * This is used in situations where we need to indicate some problem but also pass the CR Status which should be set on\n+ * the custom resource.\n+ */\n public class ReconciliationException extends Exception {\n     private final Status status;\n \n+    /**\n+     * Creates new exception from the custom resource status and the original exception\n+     *\n+     * @param status    Status which should be set to the CR\n+     * @param cause     Exception which cause the reconciliation to fail\n+     */\n     public ReconciliationException(Status status, Throwable cause) {\n         super(cause);\n         this.status = status;\n     }\n \n+    /**\n+     * Returns the status accompanying the exception\n+     *\n+     * @return  Status from the exception\n+     */\n     public Status getStatus() {\n         return status;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0MDQxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486140419", "bodyText": "Javadoc", "author": "tombentley", "createdAt": "2020-09-10T07:57:39Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableResourceOperatorWithStatus.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.common.operator.resource;\n+\n+import io.fabric8.kubernetes.api.model.Doneable;\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.KubernetesResourceList;\n+import io.fabric8.kubernetes.client.KubernetesClient;\n+import io.fabric8.kubernetes.client.dsl.Resource;\n+import io.vertx.core.Future;\n+import io.vertx.core.Vertx;\n+\n+public abstract class AbstractWatchableResourceOperatorWithStatus<", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableResourceOperatorWithStatus.java b/operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableStatusedResourceOperator.java\nsimilarity index 59%\nrename from operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableResourceOperatorWithStatus.java\nrename to operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableStatusedResourceOperator.java\nindex f307e3d694..3f4fef0f08 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableResourceOperatorWithStatus.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/operator/resource/AbstractWatchableStatusedResourceOperator.java\n\n@@ -12,7 +12,17 @@ import io.fabric8.kubernetes.client.dsl.Resource;\n import io.vertx.core.Future;\n import io.vertx.core.Vertx;\n \n-public abstract class AbstractWatchableResourceOperatorWithStatus<\n+/**\n+ * Class used for managing Kubernetes resources which can be watched and have Status. This is used by the assembly\n+ * operator for access to Custom Resources which have all the status sections.\n+ *\n+ * @param <C>   Kubernetes client\n+ * @param <T>   Kubernetes resource\n+ * @param <L>   Kubernetes resource list\n+ * @param <D>   Doneable Kubernetes resource\n+ * @param <R>   Kubernetes Reasource\n+ */\n+public abstract class AbstractWatchableStatusedResourceOperator<\n         C extends KubernetesClient,\n         T extends HasMetadata,\n         L extends KubernetesResourceList/*<T>*/,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2NTg1Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486165852", "bodyText": "Small nitpick, this sounds like the operator has a status, mybe something like:\nAbstractWatchableStatedResourceOperator", "author": "samuel-hawker", "createdAt": "2020-09-10T08:38:35Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractAssemblyOperator.java", "diffHunk": "@@ -72,7 +74,7 @@\n      */\n     protected AbstractAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa, String kind,\n                                        CertManager certManager, PasswordGenerator passwordGenerator,\n-                                       AbstractWatchableResourceOperator<C, T, L, D, R> resourceOperator,\n+                                       AbstractWatchableResourceOperatorWithStatus<C, T, L, D, R> resourceOperator,", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2NjM0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486166348", "bodyText": "or AbstractWatchableStatusedResourceOperator\nBut statused is not a real word, but maybe it doesn't matter here?", "author": "samuel-hawker", "createdAt": "2020-09-10T08:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2NTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE3MzA0Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486173047", "bodyText": "I would suggest \"stateful\", but that might be confusing in a different way. I think statused is fine.", "author": "tombentley", "createdAt": "2020-09-10T08:49:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2NTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQwMTk0MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486401941", "bodyText": "Yeah stateful has some interesting connotations in the operator, I'd argue that a spec is also stateful though, by being configuration. Whereas statused is a bit more accurate.", "author": "samuel-hawker", "createdAt": "2020-09-10T14:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2NTg1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractAssemblyOperator.java\nindex 136e891c5c..134d6194cd 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractAssemblyOperator.java\n\n@@ -74,7 +76,7 @@ public abstract class AbstractAssemblyOperator<C extends KubernetesClient, T ext\n      */\n     protected AbstractAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa, String kind,\n                                        CertManager certManager, PasswordGenerator passwordGenerator,\n-                                       AbstractWatchableResourceOperatorWithStatus<C, T, L, D, R> resourceOperator,\n+                                       AbstractWatchableStatusedResourceOperator<C, T, L, D, R> resourceOperator,\n                                        ResourceOperatorSupplier supplier,\n                                        ClusterOperatorConfig config) {\n         super(vertx, kind, resourceOperator, supplier.metricsProvider);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE2NzM5OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486167398", "bodyText": "I wonder if, as useful as this is, copying it is an anti-pattern?", "author": "samuel-hawker", "createdAt": "2020-09-10T08:41:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -3523,4 +3526,13 @@ String getInternalServiceHostname(String serviceName, boolean useServiceDnsDomai\n         return new Date();\n     }\n \n+    @Override\n+    protected Kafka copyResource(Kafka res) {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "273c50a146e02180900de8e91ebf71c985928df8", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\nindex f2640e569c..22f7addc18 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n\n@@ -3526,10 +3526,10 @@ public class KafkaAssemblyOperator extends AbstractAssemblyOperator<KubernetesCl\n         return new Date();\n     }\n \n-    @Override\n+    /*@Override\n     protected Kafka copyResource(Kafka res) {\n         return new KafkaBuilder(res).build();\n-    }\n+    }*/\n \n     @Override\n     protected KafkaStatus createStatus() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE3NjY2Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486176667", "bodyText": "status Result is never handled or logged, which may cause potential confusion\nAlbeit this is an extreme edge case anyway", "author": "samuel-hawker", "createdAt": "2020-09-10T08:55:42Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -168,13 +182,61 @@ private String getLockName(String namespace, String name) {\n \n         Future<Void> handler = withLock(reconciliation, LOCK_TIMEOUT_MS, () -> {\n             T cr = resourceOperator.get(namespace, name);\n+\n             if (cr != null) {\n-                validate(cr);\n+                List<Condition> unknownAndDeprecatedConditions = validate(cr);\n+                Promise<Void> createOrUpdate = Promise.promise();\n+\n+                if (cr.getSpec() == null)   {\n+                    InvalidResourceException exception = new InvalidResourceException(\"Spec cannot be null\");\n+\n+                    S status = createStatus();\n+                    Condition errorCondition = new ConditionBuilder()\n+                            .withLastTransitionTime(StatusUtils.iso8601Now())\n+                            .withType(\"NotReady\")\n+                            .withStatus(\"True\")\n+                            .withReason(exception.getClass().getSimpleName())\n+                            .withMessage(exception.getMessage())\n+                            .build();\n+                    status.addCondition(errorCondition);\n+\n+                    log.error(\"{}: {} spec cannot be null\", reconciliation, cr.getMetadata().getName());\n+                    updateStatus(reconciliation, status, unknownAndDeprecatedConditions).onComplete(statusResult -> {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNzg2NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486627864", "bodyText": "I renamed it from statusResult to notUsed to make it clear it is intentional. Not sure I can do any better there since regardless the result we always raise the original exception.", "author": "scholzj", "createdAt": "2020-09-10T20:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE3NjY2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -184,7 +188,6 @@ public abstract class AbstractOperator<\n             T cr = resourceOperator.get(namespace, name);\n \n             if (cr != null) {\n-                List<Condition> unknownAndDeprecatedConditions = validate(cr);\n                 Promise<Void> createOrUpdate = Promise.promise();\n \n                 if (cr.getSpec() == null)   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE3ODgwNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486178804", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            createOrUpdate(reconciliation, cr).onComplete(createOrUpdateResult -> {\n          \n          \n            \n                                if (createOrUpdateResult.succeeded())    {\n          \n          \n            \n                                    updateStatus(reconciliation, createOrUpdateResult.result(), unknownAndDeprecatedConditions).onComplete(statusResult -> {\n          \n          \n            \n                                        if (statusResult.succeeded())   {\n          \n          \n            \n                                            createOrUpdate.complete();\n          \n          \n            \n                                        } else {\n          \n          \n            \n                                            createOrUpdate.fail(statusResult.cause());\n          \n          \n            \n                                        }\n          \n          \n            \n                                    });\n          \n          \n            \n                                } else {\n          \n          \n            \n                                    if (createOrUpdateResult.cause() instanceof ReconciliationException) {\n          \n          \n            \n                                        ReconciliationException e = (ReconciliationException) createOrUpdateResult.cause();\n          \n          \n            \n                                        Status status = e.getStatus();\n          \n          \n            \n            \n          \n          \n            \n                                        log.error(\"{}: createOrUpdate failed\", reconciliation, e.getCause());\n          \n          \n            \n            \n          \n          \n            \n                                        updateStatus(reconciliation, (S) status, unknownAndDeprecatedConditions).onComplete(statusResult -> {\n          \n          \n            \n                                            createOrUpdate.fail(e.getCause());\n          \n          \n            \n                                        });\n          \n          \n            \n                                    } else {\n          \n          \n            \n                                        log.error(\"{}: createOrUpdate failed\", reconciliation, createOrUpdateResult.cause());\n          \n          \n            \n                                        createOrUpdate.fail(createOrUpdateResult.cause());\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            });\n          \n          \n            \n                            createOrUpdate(reconciliation, cr).compose(status -> {\n          \n          \n            \n                                 updateStatus(reconciliation, status, unknownAndDeprecatedConditions)\n          \n          \n            \n                                    .onComplete(statusResult -> {\n          \n          \n            \n                                        if (statusResult.succeeded())   {\n          \n          \n            \n                                            createOrUpdate.complete();\n          \n          \n            \n                                        } else {\n          \n          \n            \n                                            createOrUpdate.fail(statusResult.cause());\n          \n          \n            \n                                        }\n          \n          \n            \n                                    });\n          \n          \n            \n                                }, error -> {\n          \n          \n            \n                                    if (error instanceof ReconciliationException) {\n          \n          \n            \n                                        ReconciliationException e = (ReconciliationException) error;\n          \n          \n            \n                                        Status status = e.getStatus();\n          \n          \n            \n            \n          \n          \n            \n                                        log.error(\"{}: createOrUpdate failed\", reconciliation, e.getCause());\n          \n          \n            \n            \n          \n          \n            \n                                        updateStatus(reconciliation, (S) status, unknownAndDeprecatedConditions).onComplete(statusResult -> {\n          \n          \n            \n                                            createOrUpdate.fail(e.getCause());\n          \n          \n            \n                                        });\n          \n          \n            \n                                    } else {\n          \n          \n            \n                                        log.error(\"{}: createOrUpdate failed\", reconciliation, error);\n          \n          \n            \n                                        createOrUpdate.fail(error);\n          \n          \n            \n                                    }\n          \n          \n            \n                                }\n          \n          \n            \n                            });", "author": "samuel-hawker", "createdAt": "2020-09-10T08:59:13Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -168,13 +182,61 @@ private String getLockName(String namespace, String name) {\n \n         Future<Void> handler = withLock(reconciliation, LOCK_TIMEOUT_MS, () -> {\n             T cr = resourceOperator.get(namespace, name);\n+\n             if (cr != null) {\n-                validate(cr);\n+                List<Condition> unknownAndDeprecatedConditions = validate(cr);\n+                Promise<Void> createOrUpdate = Promise.promise();\n+\n+                if (cr.getSpec() == null)   {\n+                    InvalidResourceException exception = new InvalidResourceException(\"Spec cannot be null\");\n+\n+                    S status = createStatus();\n+                    Condition errorCondition = new ConditionBuilder()\n+                            .withLastTransitionTime(StatusUtils.iso8601Now())\n+                            .withType(\"NotReady\")\n+                            .withStatus(\"True\")\n+                            .withReason(exception.getClass().getSimpleName())\n+                            .withMessage(exception.getMessage())\n+                            .build();\n+                    status.addCondition(errorCondition);\n+\n+                    log.error(\"{}: {} spec cannot be null\", reconciliation, cr.getMetadata().getName());\n+                    updateStatus(reconciliation, status, unknownAndDeprecatedConditions).onComplete(statusResult -> {\n+                        createOrUpdate.fail(exception);\n+                    });\n+\n+                    return createOrUpdate.future();\n+                }\n+\n                 log.info(\"{}: {} {} should be created or updated\", reconciliation, kind, name);\n-                return createOrUpdate(reconciliation, cr).recover(createResult -> {\n-                    log.error(\"{}: createOrUpdate failed\", reconciliation, createResult);\n-                    return Future.failedFuture(createResult);\n+\n+                createOrUpdate(reconciliation, cr).onComplete(createOrUpdateResult -> {\n+                    if (createOrUpdateResult.succeeded())    {\n+                        updateStatus(reconciliation, createOrUpdateResult.result(), unknownAndDeprecatedConditions).onComplete(statusResult -> {\n+                            if (statusResult.succeeded())   {\n+                                createOrUpdate.complete();\n+                            } else {\n+                                createOrUpdate.fail(statusResult.cause());\n+                            }\n+                        });\n+                    } else {\n+                        if (createOrUpdateResult.cause() instanceof ReconciliationException) {\n+                            ReconciliationException e = (ReconciliationException) createOrUpdateResult.cause();\n+                            Status status = e.getStatus();\n+\n+                            log.error(\"{}: createOrUpdate failed\", reconciliation, e.getCause());\n+\n+                            updateStatus(reconciliation, (S) status, unknownAndDeprecatedConditions).onComplete(statusResult -> {\n+                                createOrUpdate.fail(e.getCause());\n+                            });\n+                        } else {\n+                            log.error(\"{}: createOrUpdate failed\", reconciliation, createOrUpdateResult.cause());\n+                            createOrUpdate.fail(createOrUpdateResult.cause());\n+                        }\n+                    }\n                 });", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0MTU0OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486641549", "bodyText": "This code doesn't actually work. When you use compose, you need to return Future and not just complete some Promise defined outside. So I don't think you can mix onComplete and compose so easily. I was thinking to rewrite it whole to compose, but it seemed lot more ugly than with onComplete mainly because these special handlings where we return the original errors etc.", "author": "scholzj", "createdAt": "2020-09-10T21:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE3ODgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -184,7 +188,6 @@ public abstract class AbstractOperator<\n             T cr = resourceOperator.get(namespace, name);\n \n             if (cr != null) {\n-                List<Condition> unknownAndDeprecatedConditions = validate(cr);\n                 Promise<Void> createOrUpdate = Promise.promise();\n \n                 if (cr.getSpec() == null)   {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE4MDQ1NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486180455", "bodyText": "if the get fails, we just hang until timeout as the promise is never addressed. We should use a failure handler (preferably with a compose(successhandler, failhandler)", "author": "samuel-hawker", "createdAt": "2020-09-10T09:01:48Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -200,6 +262,75 @@ private String getLockName(String namespace, String name) {\n         return result.future();\n     }\n \n+\n+\n+    /**\n+     * Updates the Status field of the Kafka CR. It diffs the desired status against the current status and calls\n+     * the update only when there is any difference in non-timestamp fields.\n+     *\n+     * @param desiredStatus The KafkaStatus which should be set\n+     *\n+     * @return\n+     */\n+    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus, List<Condition> unknownAndDeprecatedConditions) {\n+        if (desiredStatus == null)  {\n+            log.debug(\"{}: Desired status is null - status will not be updated\", reconciliation);\n+            return Future.succeededFuture();\n+        }\n+\n+        String namespace = reconciliation.namespace();\n+        String name = reconciliation.name();\n+        desiredStatus.addConditions(unknownAndDeprecatedConditions);\n+\n+        Promise<Void> updateStatusPromise = Promise.promise();\n+\n+        resourceOperator.getAsync(namespace, name).onComplete(getRes -> {\n+            if (getRes.succeeded())    {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyOTExNA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486629114", "bodyText": "I can rewrite it to compose(..., ...). But I think the current code is correct. It fails the promise at the end of the method.", "author": "scholzj", "createdAt": "2020-09-10T20:57:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE4MDQ1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 800f3075ed..522d4a27d5 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -262,17 +272,22 @@ public abstract class AbstractOperator<\n         return result.future();\n     }\n \n-\n+    private void addWarningsToStatus(Status status, Set<Condition> unknownAndDeprecatedConditions)   {\n+        if (status != null)  {\n+            status.addConditions(unknownAndDeprecatedConditions);\n+        }\n+    }\n \n     /**\n      * Updates the Status field of the Kafka CR. It diffs the desired status against the current status and calls\n      * the update only when there is any difference in non-timestamp fields.\n      *\n+     * @param reconciliation the reconciliation identified\n      * @param desiredStatus The KafkaStatus which should be set\n      *\n      * @return\n      */\n-    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus, List<Condition> unknownAndDeprecatedConditions) {\n+    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus) {\n         if (desiredStatus == null)  {\n             log.debug(\"{}: Desired status is null - status will not be updated\", reconciliation);\n             return Future.succeededFuture();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE4Mjg3OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486182878", "bodyText": "What is the purpose behind a new type of exception here?\nJust so that a status can be retreieved from it?\nWouldn't it make sense for the reconciler to catch any exceptions and construct the status prior to ending the reconcile?", "author": "samuel-hawker", "createdAt": "2020-09-10T09:05:42Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.operator.common;\n+\n+import io.strimzi.api.kafka.model.status.Status;\n+\n+public class ReconciliationException extends Exception {", "originalCommit": "a3027e7efa3b8a25ee406de4acc58b1fa99b5133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMyNzMwMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r486327302", "bodyText": "I'm not sure how exactly do you mean it. But we need to be able to pass back the status and yet report that there was an error. The upper class does not have all the info to construct the status. So throwing back just the original exception is not enough and returning success would not properly log the errors and handle metrics.", "author": "scholzj", "createdAt": "2020-09-10T13:16:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE4Mjg3OA=="}], "type": "inlineReview", "revised_code": {"commit": "eb575d223579fd86bd2caa42d426de353164ee1e", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java b/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java\nindex 71cf044815..082949f4de 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/ReconciliationException.java\n\n@@ -6,14 +6,30 @@ package io.strimzi.operator.common;\n \n import io.strimzi.api.kafka.model.status.Status;\n \n+/**\n+ * Custom exception which wraps the Custom Resource status together with the original exception which caused the issue.\n+ * This is used in situations where we need to indicate some problem but also pass the CR Status which should be set on\n+ * the custom resource.\n+ */\n public class ReconciliationException extends Exception {\n     private final Status status;\n \n+    /**\n+     * Creates new exception from the custom resource status and the original exception\n+     *\n+     * @param status    Status which should be set to the CR\n+     * @param cause     Exception which cause the reconciliation to fail\n+     */\n     public ReconciliationException(Status status, Throwable cause) {\n         super(cause);\n         this.status = status;\n     }\n \n+    /**\n+     * Returns the status accompanying the exception\n+     *\n+     * @return  Status from the exception\n+     */\n     public Status getStatus() {\n         return status;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwMjY1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r487702651", "bodyText": "\"generic status\"?", "author": "ppatierno", "createdAt": "2020-09-14T07:24:44Z", "path": "api/src/main/java/io/strimzi/api/kafka/model/Spec.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.kafka.model;\n+\n+import com.fasterxml.jackson.annotation.JsonInclude;\n+import io.sundr.builder.annotations.Buildable;\n+import lombok.EqualsAndHashCode;\n+import lombok.ToString;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static java.util.Collections.emptyMap;\n+\n+/**\n+ * Represents a generic status which can be used across different resources", "originalCommit": "bd0a89ff751d9dba1d802bac443f7cd204a63e44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f24190c5e4bccc3c2f2cf6f51df04ce107c07297", "chunk": "diff --git a/api/src/main/java/io/strimzi/api/kafka/model/Spec.java b/api/src/main/java/io/strimzi/api/kafka/model/Spec.java\nindex 3dc13a17f4..0c66a07ec0 100644\n--- a/api/src/main/java/io/strimzi/api/kafka/model/Spec.java\n+++ b/api/src/main/java/io/strimzi/api/kafka/model/Spec.java\n\n@@ -16,7 +16,7 @@ import java.util.Map;\n import static java.util.Collections.emptyMap;\n \n /**\n- * Represents a generic status which can be used across different resources\n+ * Represents a generic spec which can be used across different resources\n  */\n @Buildable(\n         editableEnabled = false,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwMzU0Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r487703542", "bodyText": "is readyCondition really a good name in this case when you are setting an \"error/warning\" condition?", "author": "ppatierno", "createdAt": "2020-09-14T07:26:31Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java", "diffHunk": "@@ -234,26 +234,10 @@ public KafkaAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pfa,\n                         .withReason(reconcileResult.cause().getClass().getSimpleName())\n                         .withMessage(reconcileResult.cause().getMessage())\n                         .build();\n-            }\n \n-            status.addCondition(readyCondition);\n-            reconcileState.updateStatus(status).onComplete(statusResult -> {\n-                if (statusResult.succeeded())    {\n-                    log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n-                } else {\n-                    log.error(\"Failed to set status for {}\", kafkaAssembly.getMetadata().getName());\n-                }\n-\n-                // If both features succeeded, createOrUpdate succeeded as well\n-                // If one or both of them failed, we prefer the reconciliation failure as the main error\n-                if (reconcileResult.succeeded() && statusResult.succeeded())    {\n-                    createOrUpdatePromise.complete();\n-                } else if (reconcileResult.failed())    {\n-                    createOrUpdatePromise.fail(reconcileResult.cause());\n-                } else {\n-                    createOrUpdatePromise.fail(statusResult.cause());\n-                }\n-            });\n+                status.addCondition(readyCondition);", "originalCommit": "bd0a89ff751d9dba1d802bac443f7cd204a63e44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba03492f88cf5d93f859810731f2121c321117e0", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\nindex a93f42535f..8960123b1f 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaAssemblyOperator.java\n\n@@ -238,6 +238,25 @@ public class KafkaAssemblyOperator extends AbstractAssemblyOperator<KubernetesCl\n                 status.addCondition(readyCondition);\n                 createOrUpdatePromise.fail(new ReconciliationException(status, reconcileResult.cause()));\n             }\n+\n+            /*status.addCondition(readyCondition);\n+            reconcileState.updateStatus(status).onComplete(statusResult -> {\n+                if (statusResult.succeeded())    {\n+                    log.debug(\"Status for {} is up to date\", kafkaAssembly.getMetadata().getName());\n+                } else {\n+                    log.error(\"Failed to set status for {}\", kafkaAssembly.getMetadata().getName());\n+                }\n+\n+                // If both features succeeded, createOrUpdate succeeded as well\n+                // If one or both of them failed, we prefer the reconciliation failure as the main error\n+                if (reconcileResult.succeeded() && statusResult.succeeded())    {\n+                    createOrUpdatePromise.complete();\n+                } else if (reconcileResult.failed())    {\n+                    createOrUpdatePromise.fail(reconcileResult.cause());\n+                } else {\n+                    createOrUpdatePromise.fail(statusResult.cause());\n+                }\n+            });*/\n         });\n \n         return createOrUpdatePromise.future();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwNDgyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r487704820", "bodyText": "can we remove this?", "author": "ppatierno", "createdAt": "2020-09-14T07:29:01Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java", "diffHunk": "@@ -200,6 +267,64 @@ private String getLockName(String namespace, String name) {\n         return result.future();\n     }\n \n+    private void addWarningsToStatus(Status status, Set<Condition> unknownAndDeprecatedConditions)   {\n+        if (status != null)  {\n+            status.addConditions(unknownAndDeprecatedConditions);\n+        }\n+    }\n+\n+    /**\n+     * Updates the Status field of the Kafka CR. It diffs the desired status against the current status and calls\n+     * the update only when there is any difference in non-timestamp fields.\n+     *\n+     * @param reconciliation the reconciliation identified\n+     * @param desiredStatus The KafkaStatus which should be set\n+     *\n+     * @return\n+     */\n+    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus) {\n+        if (desiredStatus == null)  {\n+            log.debug(\"{}: Desired status is null - status will not be updated\", reconciliation);\n+            return Future.succeededFuture();\n+        }\n+\n+        String namespace = reconciliation.namespace();\n+        String name = reconciliation.name();\n+\n+        return resourceOperator.getAsync(namespace, name)\n+                .compose(res -> {\n+                    if (res != null) {\n+                        S currentStatus = res.getStatus();\n+                        StatusDiff sDiff = new StatusDiff(currentStatus, desiredStatus);\n+\n+                        if (!sDiff.isEmpty()) {\n+                            //T copiedResource = copyResource(res);", "originalCommit": "bd0a89ff751d9dba1d802bac443f7cd204a63e44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba03492f88cf5d93f859810731f2121c321117e0", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\nindex 9b69dbc64d..791996498c 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/AbstractOperator.java\n\n@@ -267,22 +268,17 @@ public abstract class AbstractOperator<\n         return result.future();\n     }\n \n-    private void addWarningsToStatus(Status status, Set<Condition> unknownAndDeprecatedConditions)   {\n-        if (status != null)  {\n-            status.addConditions(unknownAndDeprecatedConditions);\n-        }\n-    }\n+\n \n     /**\n      * Updates the Status field of the Kafka CR. It diffs the desired status against the current status and calls\n      * the update only when there is any difference in non-timestamp fields.\n      *\n-     * @param reconciliation the reconciliation identified\n      * @param desiredStatus The KafkaStatus which should be set\n      *\n      * @return\n      */\n-    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus) {\n+    Future<Void> updateStatus(Reconciliation reconciliation, S desiredStatus, List<Condition> unknownAndDeprecatedConditions) {\n         if (desiredStatus == null)  {\n             log.debug(\"{}: Desired status is null - status will not be updated\", reconciliation);\n             return Future.succeededFuture();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcwNTIxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3623#discussion_r487705219", "bodyText": "Let's remove this \"Haaa\" :-D", "author": "ppatierno", "createdAt": "2020-09-14T07:29:53Z", "path": "operator-common/src/main/java/io/strimzi/operator/common/model/ValidationVisitor.java", "diffHunk": "@@ -100,14 +128,17 @@ private String path(List<String> path, String propertyName) {\n \n     @Override\n     public void visitObject(List<String> path, Object object) {\n+        //System.out.println(\"Haaa\");", "originalCommit": "bd0a89ff751d9dba1d802bac443f7cd204a63e44", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ba03492f88cf5d93f859810731f2121c321117e0", "chunk": "diff --git a/operator-common/src/main/java/io/strimzi/operator/common/model/ValidationVisitor.java b/operator-common/src/main/java/io/strimzi/operator/common/model/ValidationVisitor.java\nindex 952cb75deb..9a6a52df9e 100644\n--- a/operator-common/src/main/java/io/strimzi/operator/common/model/ValidationVisitor.java\n+++ b/operator-common/src/main/java/io/strimzi/operator/common/model/ValidationVisitor.java\n\n@@ -128,7 +127,6 @@ public class ValidationVisitor implements ResourceVisitor.Visitor {\n \n     @Override\n     public void visitObject(List<String> path, Object object) {\n-        //System.out.println(\"Haaa\");\n         if (object instanceof UnknownPropertyPreserving) {\n             Map<String, Object> properties = ((UnknownPropertyPreserving) object).getAdditionalProperties();\n             if (properties != null && !properties.isEmpty()) {\n"}}, {"oid": "ba03492f88cf5d93f859810731f2121c321117e0", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ba03492f88cf5d93f859810731f2121c321117e0", "message": "Redesigned unknown and deprecated fields in resource status conditions\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-09-17T08:12:32Z", "type": "commit"}, {"oid": "eb575d223579fd86bd2caa42d426de353164ee1e", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/eb575d223579fd86bd2caa42d426de353164ee1e", "message": "Review comments - still WiP\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-09-17T08:25:47Z", "type": "commit"}, {"oid": "273c50a146e02180900de8e91ebf71c985928df8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/273c50a146e02180900de8e91ebf71c985928df8", "message": "Fix tests\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-09-17T08:27:21Z", "type": "commit"}, {"oid": "b6f5c59a7cd3e2b34f4991613012dea971c8a027", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b6f5c59a7cd3e2b34f4991613012dea971c8a027", "message": "Code cleanup\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-09-17T08:27:22Z", "type": "commit"}, {"oid": "f24190c5e4bccc3c2f2cf6f51df04ce107c07297", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f24190c5e4bccc3c2f2cf6f51df04ce107c07297", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-09-17T08:27:22Z", "type": "commit"}, {"oid": "f24190c5e4bccc3c2f2cf6f51df04ce107c07297", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/f24190c5e4bccc3c2f2cf6f51df04ce107c07297", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-09-17T08:27:22Z", "type": "forcePushed"}]}