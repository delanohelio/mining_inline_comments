{"pr_number": 3512, "pr_title": "Add support for different types under one field in a CRD", "pr_createdAt": "2020-08-14T20:06:06Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512", "timeline": [{"oid": "38be29758c6967ab3c56e04f8d0499406caa3221", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/38be29758c6967ab3c56e04f8d0499406caa3221", "message": "Add support for different types under one field in a CRD\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-14T19:24:59Z", "type": "commit"}, {"oid": "ecb733901e9930689616a32a3531c2fd794ec4b5", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ecb733901e9930689616a32a3531c2fd794ec4b5", "message": "Add some comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-14T20:05:36Z", "type": "commit"}, {"oid": "2b1182f7cac73f7f913a9286ec79be5a1efd9d7a", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2b1182f7cac73f7f913a9286ec79be5a1efd9d7a", "message": "Add possibility to deprecate Type\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-14T22:44:47Z", "type": "commit"}, {"oid": "4eaaa0a9cfe4017e880bb8463a6cb0864e37d1dc", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4eaaa0a9cfe4017e880bb8463a6cb0864e37d1dc", "message": "Fix spotbugs\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-14T22:56:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk4OTIyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r470989225", "bodyText": "What's the reasoning behind initializing with this size?", "author": "samuel-hawker", "createdAt": "2020-08-15T13:47:32Z", "path": "crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java", "diffHunk": "@@ -80,27 +83,57 @@ private void appendHeading(Crd crd, String name) throws IOException {\n     }\n \n     private void usedIn(Class<?> cls, Map<Class<?>, Set<Class<?>>> usedIn) {\n+        Set<Property> memorableProperties = new HashSet<>();\n+\n         for (Property property : properties(cls).values()) {\n             if (property.isAnnotationPresent(KubeLink.class)) {\n                 continue;\n             }\n+\n+            OneOfType oneOfType = property.getAnnotation(OneOfType.class);\n+            if (oneOfType != null && oneOfType.value().length > 0) {\n+                for (OneOfType.Alternative alt : oneOfType.value()) {\n+                    for (OneOfType.Alternative.Field field : alt.value()) {\n+                        try {\n+                            memorableProperties.add(new Property(property.getType().getType().getDeclaredField(field.value())));\n+                        } catch (NoSuchFieldException e) {\n+                            throw new RuntimeException(\"Failed to find field used in OneOfType annotation\", e);\n+                        }\n+                    }\n+                }\n+            } else {\n+                memorableProperties.add(property);\n+            }\n+        }\n+\n+        for (Property property : memorableProperties) {\n             PropertyType propertyType = property.getType();\n             Class<?> type = propertyType.isArray() ? propertyType.arrayBase() : propertyType.getType();\n             for (Class<?> c : subtypesOrSelf(type)) {\n                 if (Schema.isJsonScalarType(c)) {\n                     continue;\n                 }\n-                Set<Class<?>> classes = usedIn.get(c);\n-                if (classes == null) {\n-                    classes = new HashSet<>(2);\n-                    usedIn.put(c, classes);\n-                }\n+\n+                Set<Class<?>> classes = getOrCreateClassesSet(c, usedIn);\n+\n                 classes.add(cls);\n+\n                 usedIn(c, usedIn);\n             }\n         }\n     }\n \n+    private Set<Class<?>> getOrCreateClassesSet(Class<?> c, Map<Class<?>, Set<Class<?>>> usedIn)   {\n+        Set<Class<?>> classes = usedIn.get(c);\n+\n+        if (classes == null) {\n+            classes = new HashSet<>(2);", "originalCommit": "4eaaa0a9cfe4017e880bb8463a6cb0864e37d1dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk5ODA5Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r470998097", "bodyText": "Honestly, it was in the old code. I just move it into separate method because of spotbugs. But I do not see any reason for it, so I changed it to 1.", "author": "scholzj", "createdAt": "2020-08-15T14:57:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk4OTIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "d19e7bbf98b32c4f48995247c7ed1048fa42258c", "chunk": "diff --git a/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java b/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java\nindex bb4800511..111d6748d 100644\n--- a/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java\n+++ b/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java\n\n@@ -127,7 +127,7 @@ public class DocGenerator {\n         Set<Class<?>> classes = usedIn.get(c);\n \n         if (classes == null) {\n-            classes = new HashSet<>(2);\n+            classes = new HashSet<>(1);\n             usedIn.put(c, classes);\n         }\n \n"}}, {"oid": "d19e7bbf98b32c4f48995247c7ed1048fa42258c", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/d19e7bbf98b32c4f48995247c7ed1048fa42258c", "message": "Fix default HashSet size\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-15T14:56:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI1ODg1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471258853", "bodyText": "Any reason not to use java.lang.Class as the type?", "author": "tombentley", "createdAt": "2020-08-17T06:36:29Z", "path": "crd-annotations/src/main/java/io/strimzi/api/annotations/DeprecatedType.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.api.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface DeprecatedType {\n+    /**\n+     * @return The type which should be used as replacement\n+     */\n+    String replacedWithType();", "originalCommit": "d19e7bbf98b32c4f48995247c7ed1048fa42258c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY4NzM5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471687392", "bodyText": "The CrdGenerator and DocGenerator are based around properties. The way the annotation works to day is that the String specifies the name of the filed in the ThisOrThat class and that allows to easily integrate it -> basically just changes the parameter annotated as OneOfType with the two parameters from inside its class.\nIf you think having a class there would be cleaner despite the more complicated DocGenerator and CrdGenerator classes, I can change it.", "author": "scholzj", "createdAt": "2020-08-17T18:30:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI1ODg1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk1MTA5Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471951092", "bodyText": "AFAICS the string is only used in DocGenerator where it's immediately passed to Class.forName() to obtain a Class instance anyway. I don't understand what the drawback/complication is (I'm not saying there isn't one).", "author": "tombentley", "createdAt": "2020-08-18T06:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI1ODg1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "chunk": "diff --git a/crd-annotations/src/main/java/io/strimzi/api/annotations/DeprecatedType.java b/crd-annotations/src/main/java/io/strimzi/api/annotations/DeprecatedType.java\nindex f02735c30..de8907211 100644\n--- a/crd-annotations/src/main/java/io/strimzi/api/annotations/DeprecatedType.java\n+++ b/crd-annotations/src/main/java/io/strimzi/api/annotations/DeprecatedType.java\n\n@@ -15,5 +15,5 @@ public @interface DeprecatedType {\n     /**\n      * @return The type which should be used as replacement\n      */\n-    String replacedWithType();\n+    Class<?> replacedWithType();\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MTA2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471261068", "bodyText": "ObjectMapper is thread-safe and relatively heavyweight. We should be moving in the direction of using a (few) constants, rather than instantiating every time we want to serialize or deserialize.", "author": "tombentley", "createdAt": "2020-08-17T06:42:47Z", "path": "crd-generator/src/test/java/io/strimzi/crdgenerator/Type1OrType2.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.crdgenerator;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import io.strimzi.api.annotations.DeprecatedType;\n+\n+import java.io.IOException;\n+\n+@JsonDeserialize(using = Type1OrType2.Deserializer.class)\n+@JsonSerialize(using = Type1OrType2.Serializer.class)\n+public class Type1OrType2 {\n+    private Type1 type1Value;\n+    private Type2 type2Value;\n+\n+    public Type1OrType2(Type1 type1Value)   {\n+        type1Value = type1Value;\n+        type2Value = null;\n+    }\n+\n+    public Type1OrType2(Type2 type2Value)   {\n+        type1Value = null;\n+        type2Value = type2Value;\n+    }\n+\n+    public Type1 getMapValue()    {\n+        return type1Value;\n+    }\n+\n+    public Type2 getListValue()    {\n+        return type2Value;\n+    }\n+\n+    public static class Serializer extends JsonSerializer<Type1OrType2> {\n+        @Override\n+        public void serialize(Type1OrType2 value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.type1Value != null)    {\n+                    generator.writeObject(value.type1Value);\n+                } else if (value.type2Value != null)  {\n+                    generator.writeObject(value.type2Value);\n+                } else {\n+                    generator.writeNull();\n+                }\n+            } else {\n+                generator.writeNull();\n+            }\n+        }\n+    }\n+\n+    public static class Deserializer extends JsonDeserializer<Type1OrType2> {\n+        @Override\n+        public Type1OrType2 deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n+            ObjectMapper objectMapper = new ObjectMapper();", "originalCommit": "d19e7bbf98b32c4f48995247c7ed1048fa42258c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY5NjgyNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471696825", "bodyText": "I made the ObjectMapper static member of the deserializer class. Is that what you meant here?", "author": "scholzj", "createdAt": "2020-08-17T18:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MTA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "b044907bf3afadb30e905bd684022141d3ef3678", "chunk": "diff --git a/crd-generator/src/test/java/io/strimzi/crdgenerator/Type1OrType2.java b/crd-generator/src/test/java/io/strimzi/crdgenerator/Type1OrType2.java\nindex a431aceb6..b8876847e 100644\n--- a/crd-generator/src/test/java/io/strimzi/crdgenerator/Type1OrType2.java\n+++ b/crd-generator/src/test/java/io/strimzi/crdgenerator/Type1OrType2.java\n\n@@ -63,19 +63,20 @@ public class Type1OrType2 {\n     }\n \n     public static class Deserializer extends JsonDeserializer<Type1OrType2> {\n+        private static ObjectMapper mapper = new ObjectMapper();\n+\n         @Override\n         public Type1OrType2 deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n-            ObjectMapper objectMapper = new ObjectMapper();\n             ObjectCodec oc = jsonParser.getCodec();\n             JsonNode node = oc.readTree(jsonParser);\n             Type1OrType2 type1OrType2;\n \n             if (node.isObject() && node.fieldNames().hasNext() && node.fieldNames().next().equals(\"key1\")) {\n-                ObjectReader reader = objectMapper.readerFor(new TypeReference<Type1>() { });\n+                ObjectReader reader = mapper.readerFor(new TypeReference<Type1>() { });\n                 Type1 value = reader.readValue(node);\n                 type1OrType2 = new Type1OrType2(value);\n             } else if (node.isObject() && node.fieldNames().hasNext() && node.fieldNames().next().equals(\"key2\")) {\n-                ObjectReader reader = objectMapper.readerFor(new TypeReference<Type2>() { });\n+                ObjectReader reader = mapper.readerFor(new TypeReference<Type2>() { });\n                 Type2 value = reader.readValue(node);\n                 type1OrType2 = new Type1OrType2(value);\n             } else {\n"}}, {"oid": "b044907bf3afadb30e905bd684022141d3ef3678", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/b044907bf3afadb30e905bd684022141d3ef3678", "message": "Use static ObjectMapper\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-17T18:36:51Z", "type": "commit"}, {"oid": "4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "message": "Replace @OneOfType with @Alternation and @Alternative (#4)\n\nSigned-off-by: Tom Bentley <tbentley@redhat.com>", "committedDate": "2020-08-18T08:32:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk1NTQwNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471955406", "bodyText": "I'm not really sure I understand this. Each of the alternatives in the OneOfType can have a set of fields, but then the fields each get called alternatives?\nAlso, I think a more idiomatic thing to do would be to get a Property via Property.properties(property.getType().getType()). That way it will work correctly with getters and/or fields. It also keeps the reflection in Properties. Same comment goes for the DocGenerator, I think. Can we, at the same time, make the constructors of Property private?", "author": "tombentley", "createdAt": "2020-08-18T06:57:58Z", "path": "crd-generator/src/main/java/io/strimzi/crdgenerator/CrdGenerator.java", "diffHunk": "@@ -466,11 +468,39 @@ private ArrayNode buildSchemaRequired(Class<?> crdClass) {\n     private ObjectNode buildSchemaProperties(Class<?> crdClass) {\n         ObjectNode properties = nf.objectNode();\n         for (Property property : unionOfSubclassProperties(crdClass)) {\n-            buildProperty(properties, property);\n+            OneOfType oneOfType = property.getAnnotation(OneOfType.class);\n+            if (oneOfType != null && oneOfType.value().length > 0)    {\n+                List<Property> alternatives = new ArrayList<>(0);\n+\n+                for (OneOfType.Alternative alt : oneOfType.value()) {\n+                    for (OneOfType.Alternative.Field field : alt.value()) {\n+                        try {\n+                            alternatives.add(new Property(property.getType().getType().getDeclaredField(field.value())));", "originalCommit": "b044907bf3afadb30e905bd684022141d3ef3678", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "chunk": "diff --git a/crd-generator/src/main/java/io/strimzi/crdgenerator/CrdGenerator.java b/crd-generator/src/main/java/io/strimzi/crdgenerator/CrdGenerator.java\nindex c5cf29748..23e2a0c82 100644\n--- a/crd-generator/src/main/java/io/strimzi/crdgenerator/CrdGenerator.java\n+++ b/crd-generator/src/main/java/io/strimzi/crdgenerator/CrdGenerator.java\n\n@@ -468,18 +468,12 @@ public class CrdGenerator {\n     private ObjectNode buildSchemaProperties(Class<?> crdClass) {\n         ObjectNode properties = nf.objectNode();\n         for (Property property : unionOfSubclassProperties(crdClass)) {\n-            OneOfType oneOfType = property.getAnnotation(OneOfType.class);\n-            if (oneOfType != null && oneOfType.value().length > 0)    {\n-                List<Property> alternatives = new ArrayList<>(0);\n-\n-                for (OneOfType.Alternative alt : oneOfType.value()) {\n-                    for (OneOfType.Alternative.Field field : alt.value()) {\n-                        try {\n-                            alternatives.add(new Property(property.getType().getType().getDeclaredField(field.value())));\n-                        } catch (NoSuchFieldException e) {\n-                            throw new RuntimeException(\"Failed to find field used in OneOfType annotation\", e);\n-                        }\n-                    }\n+            if (property.getType().getType().isAnnotationPresent(Alternation.class)) {\n+                List<Property> alternatives = property.getAlternatives();\n+                if (alternatives.size() < 2) {\n+                    err(\"Class \" + property.getType().getType().getName() + \" is annotated with \" +\n+                            \"@\" + Alternation.class.getSimpleName() + \" but has less than two \" +\n+                            \"@\" + Alternative.class.getSimpleName() + \"-annotated properties\");\n                 }\n                 buildMultiTypeProperty(properties, property, alternatives);\n             } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk1ODcyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471958722", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Set<Class<?>> classes = usedIn.get(c);\n          \n          \n            \n            \n          \n          \n            \n                    if (classes == null) {\n          \n          \n            \n                        classes = new HashSet<>(1);\n          \n          \n            \n                        usedIn.put(c, classes);\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return classes;\n          \n          \n            \n                    return usedIn.computeIfAbsent(c, cls -> new HashSet(1));", "author": "tombentley", "createdAt": "2020-08-18T07:04:43Z", "path": "crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java", "diffHunk": "@@ -80,27 +83,57 @@ private void appendHeading(Crd crd, String name) throws IOException {\n     }\n \n     private void usedIn(Class<?> cls, Map<Class<?>, Set<Class<?>>> usedIn) {\n+        Set<Property> memorableProperties = new HashSet<>();\n+\n         for (Property property : properties(cls).values()) {\n             if (property.isAnnotationPresent(KubeLink.class)) {\n                 continue;\n             }\n+\n+            OneOfType oneOfType = property.getAnnotation(OneOfType.class);\n+            if (oneOfType != null && oneOfType.value().length > 0) {\n+                for (OneOfType.Alternative alt : oneOfType.value()) {\n+                    for (OneOfType.Alternative.Field field : alt.value()) {\n+                        try {\n+                            memorableProperties.add(new Property(property.getType().getType().getDeclaredField(field.value())));\n+                        } catch (NoSuchFieldException e) {\n+                            throw new RuntimeException(\"Failed to find field used in OneOfType annotation\", e);\n+                        }\n+                    }\n+                }\n+            } else {\n+                memorableProperties.add(property);\n+            }\n+        }\n+\n+        for (Property property : memorableProperties) {\n             PropertyType propertyType = property.getType();\n             Class<?> type = propertyType.isArray() ? propertyType.arrayBase() : propertyType.getType();\n             for (Class<?> c : subtypesOrSelf(type)) {\n                 if (Schema.isJsonScalarType(c)) {\n                     continue;\n                 }\n-                Set<Class<?>> classes = usedIn.get(c);\n-                if (classes == null) {\n-                    classes = new HashSet<>(2);\n-                    usedIn.put(c, classes);\n-                }\n+\n+                Set<Class<?>> classes = getOrCreateClassesSet(c, usedIn);\n+\n                 classes.add(cls);\n+\n                 usedIn(c, usedIn);\n             }\n         }\n     }\n \n+    private Set<Class<?>> getOrCreateClassesSet(Class<?> c, Map<Class<?>, Set<Class<?>>> usedIn)   {\n+        Set<Class<?>> classes = usedIn.get(c);\n+\n+        if (classes == null) {\n+            classes = new HashSet<>(1);\n+            usedIn.put(c, classes);\n+        }\n+\n+        return classes;", "originalCommit": "b044907bf3afadb30e905bd684022141d3ef3678", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "chunk": "diff --git a/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java b/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java\nindex 111d6748d..fd035c601 100644\n--- a/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java\n+++ b/crd-generator/src/main/java/io/strimzi/crdgenerator/DocGenerator.java\n\n@@ -90,17 +90,8 @@ public class DocGenerator {\n                 continue;\n             }\n \n-            OneOfType oneOfType = property.getAnnotation(OneOfType.class);\n-            if (oneOfType != null && oneOfType.value().length > 0) {\n-                for (OneOfType.Alternative alt : oneOfType.value()) {\n-                    for (OneOfType.Alternative.Field field : alt.value()) {\n-                        try {\n-                            memorableProperties.add(new Property(property.getType().getType().getDeclaredField(field.value())));\n-                        } catch (NoSuchFieldException e) {\n-                            throw new RuntimeException(\"Failed to find field used in OneOfType annotation\", e);\n-                        }\n-                    }\n-                }\n+            if (property.getType().getType().isAnnotationPresent(Alternation.class)) {\n+                memorableProperties.addAll(property.getAlternatives());\n             } else {\n                 memorableProperties.add(property);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2MDY3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r471960674", "bodyText": "What's the value of using Field, couldn't value just be a String[] of the field names.\nAlso, I think we should use the term property, rather than field, since in Java terms these things can be either fields or getters (aka properties).", "author": "tombentley", "createdAt": "2020-08-18T07:08:48Z", "path": "crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/OneOfType.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.crdgenerator.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+@Retention(RetentionPolicy.RUNTIME)\n+@Target({ElementType.METHOD})\n+public @interface OneOfType {\n+    /** @return List of alternatives */\n+    Alternative[] value();\n+\n+    @interface Alternative {\n+        @interface Field {\n+            /** @return The name of a field */\n+            String value();\n+        }\n+\n+        /** @return Fields in this alternative */\n+        Field[] value();", "originalCommit": "b044907bf3afadb30e905bd684022141d3ef3678", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "chunk": "diff --git a/crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/OneOfType.java b/crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/Alternative.java\nsimilarity index 52%\nrename from crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/OneOfType.java\nrename to crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/Alternative.java\nindex 09feedbf9..4c3d13abe 100644\n--- a/crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/OneOfType.java\n+++ b/crd-generator/src/main/java/io/strimzi/crdgenerator/annotations/Alternative.java\n\n@@ -9,20 +9,10 @@ import java.lang.annotation.Retention;\n import java.lang.annotation.RetentionPolicy;\n import java.lang.annotation.Target;\n \n+/**\n+ * One of several alternatives in an {@link Alternation}-annotated class.\n+ */\n @Retention(RetentionPolicy.RUNTIME)\n-@Target({ElementType.METHOD})\n-public @interface OneOfType {\n-    /** @return List of alternatives */\n-    Alternative[] value();\n-\n-    @interface Alternative {\n-        @interface Field {\n-            /** @return The name of a field */\n-            String value();\n-        }\n-\n-        /** @return Fields in this alternative */\n-        Field[] value();\n-    }\n+@Target({ElementType.METHOD, ElementType.FIELD})\n+public @interface Alternative {\n }\n-\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzMjYxOQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r472332619", "bodyText": "I think you should be able to write the deserializer like this (for this case), which saves having to deserialize the whole tree into JsonNode only to go mapping it to java types:\n        @Override\n        public MapOrList deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n            MapOrList mapOrList;\n            ObjectCodec oc = jsonParser.getCodec();\n            if (jsonParser.currentToken() == JsonToken.START_ARRAY) {\n                mapOrList = new MapOrList(oc.readValue(jsonParser, new TypeReference<List<String>>() { }));\n            } else if (jsonParser.currentToken() == JsonToken.START_OBJECT) {\n                mapOrList = new MapOrList(oc.readValue(jsonParser, new TypeReference<Map<String, String>>() { }));\n            } else {\n                throw new RuntimeException();\n            }\n            return mapOrList;\n        }\nUnfortunately that's not possible for the Type1OrType2 case.", "author": "tombentley", "createdAt": "2020-08-18T16:39:37Z", "path": "crd-generator/src/test/java/io/strimzi/crdgenerator/MapOrList.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Strimzi authors.\n+ * License: Apache License 2.0 (see the file LICENSE or http://apache.org/licenses/LICENSE-2.0.html).\n+ */\n+package io.strimzi.crdgenerator;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.ObjectCodec;\n+import com.fasterxml.jackson.core.type.TypeReference;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.ObjectReader;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import io.strimzi.crdgenerator.annotations.Alternation;\n+import io.strimzi.crdgenerator.annotations.Alternative;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+\n+@JsonDeserialize(using = MapOrList.Deserializer.class)\n+@JsonSerialize(using = MapOrList.Serializer.class)\n+@Alternation\n+public class MapOrList {\n+    private Map<String, String> mapValue;\n+    private List<String> listValue;\n+\n+    public MapOrList(Map<String, String> map)   {\n+        mapValue = map;\n+        listValue = null;\n+    }\n+\n+    public MapOrList(List<String> list)   {\n+        mapValue = null;\n+        listValue = list;\n+    }\n+\n+    @Alternative\n+    public Map<String, String> getMapValue()    {\n+        return mapValue;\n+    }\n+\n+    @Alternative\n+    public List<String> getListValue()    {\n+        return listValue;\n+    }\n+\n+    public static class Serializer extends JsonSerializer<MapOrList> {\n+        @Override\n+        public void serialize(MapOrList value, JsonGenerator generator, SerializerProvider provider) throws IOException {\n+            if (value != null) {\n+                if (value.listValue != null)    {\n+                    generator.writeObject(value.listValue);\n+                } else if (value.mapValue != null)  {\n+                    generator.writeObject(value.mapValue);\n+                } else {\n+                    generator.writeNull();\n+                }\n+            } else {\n+                generator.writeNull();\n+            }\n+        }\n+    }\n+\n+    public static class Deserializer extends JsonDeserializer<MapOrList> {\n+        @Override\n+        public MapOrList deserialize(JsonParser jsonParser, DeserializationContext context) throws IOException {\n+            ObjectMapper objectMapper = new ObjectMapper();\n+            ObjectCodec oc = jsonParser.getCodec();\n+            JsonNode node = oc.readTree(jsonParser);\n+            MapOrList mapOrList;\n+\n+            if (node.isArray()) {\n+                ObjectReader reader = objectMapper.readerFor(new TypeReference<List<String>>() { });\n+                List<String> list = reader.readValue(node);\n+                mapOrList = new MapOrList(list);\n+            } else {\n+                ObjectReader reader = objectMapper.readerFor(new TypeReference<Map<String, String>>() { });\n+                Map<String, String> map = reader.readValue(node);\n+                mapOrList = new MapOrList(map);\n+            }\n+            return mapOrList;\n+        }", "originalCommit": "4d30bda65b7a81c1e5bf4ffbbaab398629821b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEwNDM4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/3512#discussion_r473104382", "bodyText": "Fixed. This seems to work and it will even work in the actual listeners use case. So this is good. Thanks.", "author": "scholzj", "createdAt": "2020-08-19T15:10:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjMzMjYxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "e2f509c76073d89982a041a696961c57110efa3b", "chunk": "diff --git a/crd-generator/src/test/java/io/strimzi/crdgenerator/MapOrList.java b/crd-generator/src/test/java/io/strimzi/crdgenerator/MapOrList.java\nindex 688ea491b..fdd65d17d 100644\n--- a/crd-generator/src/test/java/io/strimzi/crdgenerator/MapOrList.java\n+++ b/crd-generator/src/test/java/io/strimzi/crdgenerator/MapOrList.java\n\n@@ -6,14 +6,12 @@ package io.strimzi.crdgenerator;\n \n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.core.JsonToken;\n import com.fasterxml.jackson.core.ObjectCodec;\n import com.fasterxml.jackson.core.type.TypeReference;\n import com.fasterxml.jackson.databind.DeserializationContext;\n import com.fasterxml.jackson.databind.JsonDeserializer;\n-import com.fasterxml.jackson.databind.JsonNode;\n import com.fasterxml.jackson.databind.JsonSerializer;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.databind.ObjectReader;\n import com.fasterxml.jackson.databind.SerializerProvider;\n import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n"}}, {"oid": "e2f509c76073d89982a041a696961c57110efa3b", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/e2f509c76073d89982a041a696961c57110efa3b", "message": "Improve the MapOrList deserializer\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-08-19T15:09:59Z", "type": "commit"}]}