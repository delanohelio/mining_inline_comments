{"pr_number": 2897, "pr_title": "Make sure KafkaConnect and KafkaConnectS2I can be scaled to zero", "pr_createdAt": "2020-04-26T00:20:25Z", "pr_url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415363551", "bodyText": "I might be wrong in saying this, but maybe we should tell reconcileConnectors to expect a ConnectTimeoutException if replicas ==  0? Then we don't have to capture the exception here.\n(essentially move this logic into reconcileConnectors and change its behaviour.)", "author": "samuel-hawker", "createdAt": "2020-04-26T17:52:02Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,8 +144,15 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "originalCommit": "456c871f34e85df78930db28be1559bc532a535c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2NDc0OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415364748", "bodyText": "I had it that way originally. But it is not completely easy, because the connector reconciliation is triggered form two sources:\n\nKafkaConnectAssemblyOperator and KafkaConnectS2IAssemblyOperator which can provide the replicas.\nThe KafkaConnector watch which doesn't have them. So it creates inconsistent results based on where it is triggered from and it seemed to be better this way.", "author": "scholzj", "createdAt": "2020-04-26T17:57:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NzUxMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415567510", "bodyText": "Won't this error handling result in the Ready status on the KafkaConnect? It's ready in the sense that there wasn't an error in the reconciliation, but not in the sense that the cluster is 'ready' for REST requests, is that what we want?", "author": "tombentley", "createdAt": "2020-04-27T07:15:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MTA2OA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415571068", "bodyText": "It does, but that is the point of the whole issue. To stop the reocnciliation failing when scaled to 0. There will be no REST API, but the resource will be ready in the sense that it will run as requested from the user.", "author": "scholzj", "createdAt": "2020-04-27T07:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4OTU4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415589582", "bodyText": "Fair point. But that means we're treating NotReady has having the semantics of \"failed\", rather than simply the cluster not being ready. Maybe we need a different condition entirely? I do feel that we need some way to distinguish a scaled-to-zero-like-you-asked kind of Ready from REST-interface-should-work kind of Ready, because people will want to automate on top of this status and so it needs to be unambiguous.", "author": "tombentley", "createdAt": "2020-04-27T07:51:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMzU4Nw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415633587", "bodyText": "So what status would you set in such case?", "author": "scholzj", "createdAt": "2020-04-27T08:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY4MjI1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415682253", "bodyText": "I'm not sure, are there any precedents in Kube with scale to zero (in Deployment, ReplicaSet or StatefulSet)? If Kube uses Ready in this case, maybe it would be enough to omit the REST connection information when scaled to zero.", "author": "tombentley", "createdAt": "2020-04-27T10:06:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyMDYyNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415720627", "bodyText": "Only Pod has Ready conditionm but there is no pod when it has 0 replicas. In deployment, the conditions do not show anything different from when they have replicas. They have for example the Available condition set to True.", "author": "scholzj", "createdAt": "2020-04-27T11:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzIxNjAwMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417216000", "bodyText": "I think it would make sense to me that we use a similar mechanism to what deployments and statefulsets use and say Available false and give a reason like: NoReplicas / InvalidReplicas, e.g. the condition would look something like:\n - lastTransitionTime: \"2020-04-29T09:26:39Z\"\n    lastUpdateTime: \"2020-04-29T09:26:39Z\"\n    message: Scaling KafkaConnect to 0 is not supported.\n    reason: InvalidReplicas\n    status: \"False\"\n    type: Available", "author": "samuel-hawker", "createdAt": "2020-04-29T10:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzI1MDQwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417250407", "bodyText": "They actually don't seem to do that. A deployment scaled to 0 has just this:\n  status:\n    conditions:\n    - lastTransitionTime: \"2020-04-29T08:15:31Z\"\n      lastUpdateTime: \"2020-04-29T08:34:48Z\"\n      message: ReplicaSet \"strimzi-cluster-operator-7bcd647d8d\" has successfully progressed.\n      reason: NewReplicaSetAvailable\n      status: \"True\"\n      type: Progressing\n    - lastTransitionTime: \"2020-04-29T11:18:52Z\"\n      lastUpdateTime: \"2020-04-29T11:18:52Z\"\n      message: Deployment has minimum availability.\n      reason: MinimumReplicasAvailable\n      status: \"True\"\n      type: Available\n    observedGeneration: 3\n\nSo it actually says it is available. If we would go for it (regardless what Deployment does), the wierd thing would be whether it make sense to say Available / False when we do not have available / True when everything is working.", "author": "scholzj", "createdAt": "2020-04-29T11:40:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzMyMDMwNQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417320305", "bodyText": "Thinking more I don't think we should try to solve this using conditions, because we'll be forced into have two and that makes life harder at the point of use because to test for readiness you would need to check for both Ready and Available (or Ready and not Unavailable, or whatever). replicas=0 is a bit of an edge case which most people shouldn't have to deal with.\nSo on reflection when replicas=0 I guess it would be OK to say Ready=true, but to not set the status.url or status.connectorPlugins. I think that would be enough of a signal for people wanting to use replicas=0.", "author": "tombentley", "createdAt": "2020-04-29T13:37:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU3MjMxMQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417572311", "bodyText": "Makes sense to me, my original thinking was that we would effectively override the deployments state of availability (that's why my suggestion differs from the deployment example Jakub linked) - but you are right querying two separate status conditions seems like extra complexity...\nTom's suggestion makes sense to me, though I do wonder if a user would be confused why the url/connectorPlugins fields are missing. Perhaps we follow the pattern that @dalelane introduced in #2663 and print an additional condition as a warning so the user has a little more to go on?", "author": "samuel-hawker", "createdAt": "2020-04-29T19:53:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYwMTgxNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417601817", "bodyText": "Tom's suggestion makes sense to me, though I do wonder if a user would be confused why the url/connectorPlugins fields are missing. Perhaps we follow the pattern that @dalelane introduced in #2663 and print an additional condition as a warning so the user has a little more to go on?\n\nI can do that if you want. Although the scaling to 0 is from my point of view always intentional and not done by mistake or not understanding how things work.", "author": "scholzj", "createdAt": "2020-04-29T20:48:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1ODI4NQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r417658285", "bodyText": "Very true, I agree it seems very unlikely a user would scale down to 0 and also expect a service to still exist. But i do still think an additional entry to conditions clarifying that ita ready but only in the trivial sense of that all containers (that is zero of them) are ready as there is nothing to do.", "author": "samuel-hawker", "createdAt": "2020-04-29T22:51:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA1NDk4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418054989", "bodyText": "@tombentley Does this sound reasonable to you? Want to make sure this works for everyone before implementing it.", "author": "scholzj", "createdAt": "2020-04-30T14:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA2ODQ3NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418068474", "bodyText": "What's the proposal exactly:\ntype: \"Available\"\nstatus: \"False\"\nreason: \"ScaledToZero\"", "author": "tombentley", "createdAt": "2020-04-30T14:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA3MTEwNw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418071107", "bodyText": "Something like that. The actual names can be finetuned easily later. I do not think the Available type makes sense ... I would probably form it more as a warning or something.", "author": "scholzj", "createdAt": "2020-04-30T14:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5NTI4MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418095281", "bodyText": "I'm not keen on calling it a warning. They asked for 0, and we gave them 0. There's no particular reason to treat that differently from other numbers of replicas. They asked for 3, but maybe they meant 5?\nI think the warnings we added in #2663 were useful because they highlighted very definite cases where people could break their clusters/lose data. That's not the case here.", "author": "tombentley", "createdAt": "2020-04-30T15:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI0MzE0Ng==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418243146", "bodyText": "I'm not sure I like the Available: False when we have no Available: True. But if that is fine for @samuel-hawker I can implement it.", "author": "scholzj", "createdAt": "2020-04-30T19:36:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NzQ1Mw==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r418297453", "bodyText": "I agree that we should forego the Available condition, I wish I had made that a bit more clear further up the thread.\nI agree that if a user asks for 0 replicas, we give them 0 replicas, I suggested a Warning only because a user in theory could wonder why the status.url or status.connectorPlugins fields are empty or missing.\nSomething like:\ntype: \"Warning\"\nreason: \"Zero replicas so no provided URL\"\n\nBut maybe there is little value in this - what do you think @tombentley ?", "author": "samuel-hawker", "createdAt": "2020-04-30T21:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "5041281a6351e32bd4ea62c6a445970782c3ec72", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java\nindex 930298c66..8bfebc8c2 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java\n\n@@ -155,7 +155,10 @@ public class KafkaConnectAssemblyOperator extends AbstractConnectOperator<Kubern\n                         }))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnect, kafkaConnectStatus, reconciliationResult);\n-                    kafkaConnectStatus.setUrl(KafkaConnectResources.url(connect.getCluster(), namespace, KafkaConnectCluster.REST_API_PORT));\n+\n+                    if (connect.getReplicas() > 0) {\n+                        kafkaConnectStatus.setUrl(KafkaConnectResources.url(connect.getCluster(), namespace, KafkaConnectCluster.REST_API_PORT));\n+                    }\n \n                     this.maybeUpdateStatusCommon(resourceOperator, kafkaConnect, reconciliation, kafkaConnectStatus,\n                         (connect1, status) -> new KafkaConnectBuilder(connect1).withStatus(status).build()).setHandler(statusResult -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTM2MzU3MQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415363571", "bodyText": "ditto prev comment", "author": "samuel-hawker", "createdAt": "2020-04-26T17:52:14Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "diffHunk": "@@ -152,8 +153,15 @@ public KafkaConnectS2IAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability\n                 .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n                 .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus)\n+                        .recover(error -> {\n+                            if (error instanceof ConnectTimeoutException && connect.getReplicas() == 0)   {", "originalCommit": "456c871f34e85df78930db28be1559bc532a535c", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5041281a6351e32bd4ea62c6a445970782c3ec72", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java\nindex 70e889b0f..2a0806994 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java\n\n@@ -164,8 +164,11 @@ public class KafkaConnectS2IAssemblyOperator extends AbstractConnectOperator<Ope\n                         }))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, reconciliationResult);\n-                    kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n-                    kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n+\n+                    if (connect.getReplicas() > 0) {\n+                        kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n+                        kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n+                    }\n \n                     updateStatus(kafkaConnectS2I, reconciliation, kafkaConnectS2Istatus).setHandler(statusResult -> {\n                         // If both features succeeded, createOrUpdate succeeded as well\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDc4OQ==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415564789", "bodyText": "Should the status message include what the connection was being made to? \"Connection to Connect REST API timed out\", or \"Connection to foo.bar:8083 timed out\", or something like that?", "author": "tombentley", "createdAt": "2020-04-27T07:10:35Z", "path": "cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java", "diffHunk": "@@ -938,4 +939,133 @@ public void testConnectorPauseResume() {\n                 eq(connectorName));\n     }\n \n+    /** Create connect, create connector, Scale to 0 */\n+    @Test\n+    public void testConnectScaleToZero() {\n+        String connectName = \"cluster\";\n+        String connectorName = \"connector\";\n+\n+        // Create KafkaConnect cluster and wait till it's ready\n+        Crds.kafkaConnectOperation(client).inNamespace(NAMESPACE).createNew()\n+                .withNewMetadata()\n+                .withNamespace(NAMESPACE)\n+                .withName(connectName)\n+                .addToAnnotations(Annotations.STRIMZI_IO_USE_CONNECTOR_RESOURCES, \"true\")\n+                .endMetadata()\n+                .withNewSpec()\n+                    .withReplicas(1)\n+                .endSpec()\n+                .done();\n+        waitForConnectReady(connectName);\n+\n+        // triggered twice (creation followed by status update)\n+        verify(api, times(2)).list(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT));\n+\n+        verify(api, never()).createOrUpdatePutRequest(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT),\n+                eq(connectorName), any());\n+\n+        // Create KafkaConnector and wait till it's ready\n+        Crds.kafkaConnectorOperation(client).inNamespace(NAMESPACE).createNew()\n+                .withNewMetadata()\n+                .withName(connectorName)\n+                .withNamespace(NAMESPACE)\n+                .addToLabels(Labels.STRIMZI_CLUSTER_LABEL, connectName)\n+                .endMetadata()\n+                .withNewSpec()\n+                .withTasksMax(1)\n+                .withClassName(\"Dummy\")\n+                .endSpec()\n+                .done();\n+        waitForConnectorReady(connectorName);\n+\n+        verify(api, times(2)).list(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT));\n+        verify(api, times(2)).createOrUpdatePutRequest(\n+                eq(KafkaConnectResources.qualifiedServiceName(connectName, NAMESPACE)), eq(KafkaConnectCluster.REST_API_PORT),\n+                eq(connectorName), any());\n+        assertThat(runningConnectors.keySet(), is(Collections.singleton(key(\"cluster-connect-api.ns.svc\", connectorName))));\n+\n+        when(api.list(any(), anyInt())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.listConnectorPlugins(any(), anyInt())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.createOrUpdatePutRequest(any(), anyInt(), anyString(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.getConnectorConfig(any(), any(), anyInt(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+        when(api.getConnector(any(), anyInt(), any())).thenReturn(Future.failedFuture(new ConnectTimeoutException(\"connection timed out\")));\n+\n+        Crds.kafkaConnectOperation(client).inNamespace(NAMESPACE).withName(connectName).edit()\n+                .editSpec()\n+                    .withReplicas(0)\n+                .endSpec()\n+                .done();\n+\n+        waitForConnectReady(connectName);\n+        waitForConnectorNotReady(connectorName, \"ConnectTimeoutException\", \"connection timed out\");", "originalCommit": "456c871f34e85df78930db28be1559bc532a535c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MTY4Mg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r415571682", "bodyText": "Thsi is really just the test exception based on what the mocked APi throws. The atual exception would be much longer and will include the adress.", "author": "scholzj", "createdAt": "2020-04-27T07:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDc4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ddf05db343e1280682bbb727a5bd6a7e0bef8120", "chunk": "diff --git a/cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java b/cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java\nindex 964d830b4..178f86b27 100644\n--- a/cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java\n+++ b/cluster-operator/src/test/java/io/strimzi/operator/cluster/operator/assembly/ConnectorMockTest.java\n\n@@ -939,7 +939,7 @@ public class ConnectorMockTest {\n                 eq(connectorName));\n     }\n \n-    /** Create connect, create connector, Scale to 0 */\n+    /** Create connect, create connector, delete connector, delete connect */\n     @Test\n     public void testConnectScaleToZero() {\n         String connectName = \"cluster\";\n"}}, {"oid": "ddf05db343e1280682bbb727a5bd6a7e0bef8120", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/ddf05db343e1280682bbb727a5bd6a7e0bef8120", "message": "Make sure KafkaConnect and KafkaConnectS2I can be scaled to zero\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T21:12:33Z", "type": "commit"}, {"oid": "725fa51683ae6dd4b2ef13240d4b3b7633c01653", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/725fa51683ae6dd4b2ef13240d4b3b7633c01653", "message": "Add one more test\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T21:12:33Z", "type": "commit"}, {"oid": "2e880bed62b243638911556be7a8a0d1036570c2", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/2e880bed62b243638911556be7a8a0d1036570c2", "message": "Checkstyle\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T21:12:33Z", "type": "commit"}, {"oid": "5041281a6351e32bd4ea62c6a445970782c3ec72", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/5041281a6351e32bd4ea62c6a445970782c3ec72", "message": "Do not set API URL and build name when Connect or Connect S2I is scaled to 0\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T21:12:33Z", "type": "commit"}, {"oid": "0d48f6224ed4014dd343d9c4d468f6a132383cd0", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/0d48f6224ed4014dd343d9c4d468f6a132383cd0", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T21:12:33Z", "type": "commit"}, {"oid": "c38541dcedebff490163a5e5b588e8cba277f48f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c38541dcedebff490163a5e5b588e8cba277f48f", "message": "Fix message and tests\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T22:33:57Z", "type": "commit"}, {"oid": "c38541dcedebff490163a5e5b588e8cba277f48f", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/c38541dcedebff490163a5e5b588e8cba277f48f", "message": "Fix message and tests\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-05T22:33:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYxODgyMA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420618820", "bodyText": "Isn't this the same check twice?", "author": "samuel-hawker", "createdAt": "2020-05-06T08:18:35Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -208,6 +209,11 @@ public void eventReceived(Action action, KafkaConnector kafkaConnector) {\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} does not exist\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n+                                            } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n+                                                    || (connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0))    {", "originalCommit": "c38541dcedebff490163a5e5b588e8cba277f48f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "92956f5fb00f2a08a3444af52ec4563c773add7d", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java\nindex 0ca776ef0..a6b7d2f56 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java\n\n@@ -210,7 +210,7 @@ public abstract class AbstractConnectOperator<C extends KubernetesClient, T exte\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n                                             } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n-                                                    || (connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0))    {\n+                                                    || (connectS2i != null && connectS2i.getSpec() != null && connectS2i.getSpec().getReplicas() == 0))    {\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyMTEzNg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420621136", "bodyText": "Since we are now computing\nconnect.getReplicas() > 0\nconnect.getReplicas() == 0\nand > 0 again here is it worth setting a boolean before the compose something like:\nconnectHasZeroReplicas = connect.getReplicas() == 0\n\nAnd then re-using this value for logic gating? I think it makes sense from the reconcile loop to have as little logic gating as possible and pre-declaring it on a one-time computed boolean might make the intent a little more clearer.", "author": "samuel-hawker", "createdAt": "2020-05-06T08:22:59Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java", "diffHunk": "@@ -143,11 +143,14 @@ public KafkaConnectAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability pf\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus, connect.getReplicas() == 0))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnect, kafkaConnectStatus, reconciliationResult);\n-                    kafkaConnectStatus.setUrl(KafkaConnectResources.url(connect.getCluster(), namespace, KafkaConnectCluster.REST_API_PORT));\n+\n+                    if (connect.getReplicas() > 0) {", "originalCommit": "c38541dcedebff490163a5e5b588e8cba277f48f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "92956f5fb00f2a08a3444af52ec4563c773add7d", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java\nindex df9508b8f..7fc0221ec 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectAssemblyOperator.java\n\n@@ -143,12 +145,12 @@ public class KafkaConnectAssemblyOperator extends AbstractConnectOperator<Kubern\n                 .compose(i -> deploymentOperations.reconcile(namespace, connect.getName(), connect.generateDeployment(annotations, pfa.isOpenshift(), imagePullPolicy, imagePullSecrets)))\n                 .compose(i -> deploymentOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> connect.getReplicas() > 0 ? deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus, connect.getReplicas() == 0))\n+                .compose(i -> connectHasZeroReplicas ? Future.succeededFuture() : deploymentOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnect, kafkaConnectStatus, connectHasZeroReplicas))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnect, kafkaConnectStatus, reconciliationResult);\n \n-                    if (connect.getReplicas() > 0) {\n+                    if (!connectHasZeroReplicas) {\n                         kafkaConnectStatus.setUrl(KafkaConnectResources.url(connect.getCluster(), namespace, KafkaConnectCluster.REST_API_PORT));\n                     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYyMTI0NA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420621244", "bodyText": "ditto", "author": "samuel-hawker", "createdAt": "2020-05-06T08:23:08Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java", "diffHunk": "@@ -152,12 +152,15 @@ public KafkaConnectS2IAssemblyOperator(Vertx vertx, PlatformFeaturesAvailability\n                 .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n                 .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus))\n+                .compose(i -> connect.getReplicas() > 0 ? deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus, connect.getReplicas() == 0))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, reconciliationResult);\n-                    kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n-                    kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n+\n+                    if (connect.getReplicas() > 0) {", "originalCommit": "c38541dcedebff490163a5e5b588e8cba277f48f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "92956f5fb00f2a08a3444af52ec4563c773add7d", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java\nindex ce8a432ac..3bc0890d0 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/KafkaConnectS2IAssemblyOperator.java\n\n@@ -152,12 +154,12 @@ public class KafkaConnectS2IAssemblyOperator extends AbstractConnectOperator<Ope\n                 .compose(i -> buildConfigOperations.reconcile(namespace, KafkaConnectS2IResources.buildConfigName(connect.getCluster()), connect.generateBuildConfig()))\n                 .compose(i -> deploymentConfigOperations.scaleUp(namespace, connect.getName(), connect.getReplicas()))\n                 .compose(i -> deploymentConfigOperations.waitForObserved(namespace, connect.getName(), 1_000, operationTimeoutMs))\n-                .compose(i -> connect.getReplicas() > 0 ? deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs) : Future.succeededFuture())\n-                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus, connect.getReplicas() == 0))\n+                .compose(i -> connectHasZeroReplicas ? Future.succeededFuture() : deploymentConfigOperations.readiness(namespace, connect.getName(), 1_000, operationTimeoutMs))\n+                .compose(i -> reconcileConnectors(reconciliation, kafkaConnectS2I, kafkaConnectS2Istatus, connectHasZeroReplicas))\n                 .setHandler(reconciliationResult -> {\n                     StatusUtils.setStatusConditionAndObservedGeneration(kafkaConnectS2I, kafkaConnectS2Istatus, reconciliationResult);\n \n-                    if (connect.getReplicas() > 0) {\n+                    if (!connectHasZeroReplicas) {\n                         kafkaConnectS2Istatus.setUrl(KafkaConnectS2IResources.url(connect.getCluster(), namespace, KafkaConnectS2ICluster.REST_API_PORT));\n                         kafkaConnectS2Istatus.setBuildConfigName(KafkaConnectS2IResources.buildConfigName(connect.getCluster()));\n                     }\n"}}, {"oid": "92956f5fb00f2a08a3444af52ec4563c773add7d", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/92956f5fb00f2a08a3444af52ec4563c773add7d", "message": "Review comments\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-06T08:37:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzcyMg==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420633722", "bodyText": "What about the case where both connect and connectS2i are non null, but connectS2i is scaled to 0? We'd say there were zero replicas via the first branch, but we ought to proceed via the 2nd branch, right?", "author": "tombentley", "createdAt": "2020-05-06T08:45:03Z", "path": "cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java", "diffHunk": "@@ -208,6 +209,11 @@ public void eventReceived(Action action, KafkaConnector kafkaConnector) {\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} does not exist\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n+                                            } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n+                                                    || (connectS2i != null && connectS2i.getSpec() != null && connectS2i.getSpec().getReplicas() == 0))    {\n+                                                log.info(\"{} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", connectorKind, connectorName, connectorNamespace, action, connectName);\n+                                                updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n+                                                return Future.succeededFuture();\n                                             } else if (connect != null && isOlderOrAlone(connect.getMetadata().getCreationTimestamp(), connectS2i)) {", "originalCommit": "92956f5fb00f2a08a3444af52ec4563c773add7d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY0NDk4MA==", "url": "https://github.com/strimzi/strimzi-kafka-operator/pull/2897#discussion_r420644980", "bodyText": "Good point. I pushed it one block below to make sure it is reflected which Connect takes the priority. Thanks", "author": "scholzj", "createdAt": "2020-05-06T09:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDYzMzcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "9219a65c499826825d8d03164bec6496ec9a86c8", "chunk": "diff --git a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java\nindex a6b7d2f56..b03d1b797 100644\n--- a/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java\n+++ b/cluster-operator/src/main/java/io/strimzi/operator/cluster/operator/assembly/AbstractConnectOperator.java\n\n@@ -209,43 +209,52 @@ public abstract class AbstractConnectOperator<C extends KubernetesClient, T exte\n                                                 log.info(\"{} {} in namespace {} was {}, but Connect cluster {} does not exist\", connectorKind, connectorName, connectorNamespace, action, connectName);\n                                                 updateStatus(noConnectCluster(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n                                                 return Future.succeededFuture();\n-                                            } else if ((connect != null && connect.getSpec() != null && connect.getSpec().getReplicas() == 0)\n-                                                    || (connectS2i != null && connectS2i.getSpec() != null && connectS2i.getSpec().getReplicas() == 0))    {\n-                                                log.info(\"{} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", connectorKind, connectorName, connectorNamespace, action, connectName);\n-                                                updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n-                                                return Future.succeededFuture();\n                                             } else if (connect != null && isOlderOrAlone(connect.getMetadata().getCreationTimestamp(), connectS2i)) {\n                                                 // grab the lock and call reconcileConnectors()\n                                                 // (i.e. short circuit doing a whole KafkaConnect reconciliation).\n                                                 Reconciliation reconciliation = new Reconciliation(\"connector-watch\", connectOperator.kind(),\n                                                         kafkaConnector.getMetadata().getNamespace(), connectName);\n-                                                log.info(\"{}: {} {} in namespace {} was {}\", reconciliation, connectorKind, connectorName, connectorNamespace, action);\n-\n-                                                return connectOperator.withLock(reconciliation, LOCK_TIMEOUT_MS,\n-                                                    () -> connectOperator.reconcileConnectorAndHandleResult(reconciliation,\n-                                                                KafkaConnectResources.qualifiedServiceName(connectName, connectNamespace), apiClient,\n-                                                                isUseResources(connect),\n-                                                                kafkaConnector.getMetadata().getName(), action == Action.DELETED ? null : kafkaConnector)\n-                                                            .compose(reconcileResult -> {\n-                                                                log.info(\"{}: reconciled\", reconciliation);\n-                                                                return Future.succeededFuture(reconcileResult);\n-                                                            }));\n+\n+                                                if (connect.getSpec() != null && connect.getSpec().getReplicas() == 0)  {\n+                                                    log.info(\"{}: {} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", reconciliation, connectorKind, connectorName, connectorNamespace, action, connectName);\n+                                                    updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n+                                                    return Future.succeededFuture();\n+                                                } else {\n+                                                    log.info(\"{}: {} {} in namespace {} was {}\", reconciliation, connectorKind, connectorName, connectorNamespace, action);\n+\n+                                                    return connectOperator.withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                                            () -> connectOperator.reconcileConnectorAndHandleResult(reconciliation,\n+                                                                    KafkaConnectResources.qualifiedServiceName(connectName, connectNamespace), apiClient,\n+                                                                    isUseResources(connect),\n+                                                                    kafkaConnector.getMetadata().getName(), action == Action.DELETED ? null : kafkaConnector)\n+                                                                    .compose(reconcileResult -> {\n+                                                                        log.info(\"{}: reconciled\", reconciliation);\n+                                                                        return Future.succeededFuture(reconcileResult);\n+                                                                    }));\n+                                                }\n                                             } else {\n                                                 // grab the lock and call reconcileConnectors()\n                                                 // (i.e. short circuit doing a whole KafkaConnect reconciliation).\n                                                 Reconciliation reconciliation = new Reconciliation(\"connector-watch\", connectS2IOperator.kind(),\n                                                         kafkaConnector.getMetadata().getNamespace(), connectName);\n-                                                log.info(\"{}: {} {} in namespace {} was {}\", reconciliation, connectorKind, connectorName, connectorNamespace, action);\n-\n-                                                return connectS2IOperator.withLock(reconciliation, LOCK_TIMEOUT_MS,\n-                                                    () -> connectS2IOperator.reconcileConnectorAndHandleResult(reconciliation,\n-                                                                KafkaConnectResources.qualifiedServiceName(connectName, connectNamespace), apiClient,\n-                                                                isUseResources(connectS2i),\n-                                                                kafkaConnector.getMetadata().getName(), action == Action.DELETED ? null : kafkaConnector)\n-                                                            .compose(reconcileResult -> {\n-                                                                log.info(\"{}: reconciled\", reconciliation);\n-                                                                return Future.succeededFuture(reconcileResult);\n-                                                            }));\n+\n+                                                if (connectS2i.getSpec() != null && connectS2i.getSpec().getReplicas() == 0)    {\n+                                                    log.info(\"{}: {} {} in namespace {} was {}, but Connect cluster {} has 0 replicas\", reconciliation, connectorKind, connectorName, connectorNamespace, action, connectName);\n+                                                    updateStatus(zeroReplicas(connectNamespace, connectName), kafkaConnector, connectOperator.connectorOperator);\n+                                                    return Future.succeededFuture();\n+                                                } else {\n+                                                    log.info(\"{}: {} {} in namespace {} was {}\", reconciliation, connectorKind, connectorName, connectorNamespace, action);\n+\n+                                                    return connectS2IOperator.withLock(reconciliation, LOCK_TIMEOUT_MS,\n+                                                            () -> connectS2IOperator.reconcileConnectorAndHandleResult(reconciliation,\n+                                                                    KafkaConnectResources.qualifiedServiceName(connectName, connectNamespace), apiClient,\n+                                                                    isUseResources(connectS2i),\n+                                                                    kafkaConnector.getMetadata().getName(), action == Action.DELETED ? null : kafkaConnector)\n+                                                                    .compose(reconcileResult -> {\n+                                                                        log.info(\"{}: reconciled\", reconciliation);\n+                                                                        return Future.succeededFuture(reconcileResult);\n+                                                                    }));\n+                                                }\n                                             }\n                                         });\n                             } else {\n"}}, {"oid": "9219a65c499826825d8d03164bec6496ec9a86c8", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/9219a65c499826825d8d03164bec6496ec9a86c8", "message": "Review Comments II\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-06T09:03:48Z", "type": "commit"}, {"oid": "dda8d94f23222c9927225ef6ba8c4759a5b6b076", "url": "https://github.com/strimzi/strimzi-kafka-operator/commit/dda8d94f23222c9927225ef6ba8c4759a5b6b076", "message": "Fix indentation\n\nSigned-off-by: Jakub Scholz <www@scholzj.com>", "committedDate": "2020-05-06T09:09:43Z", "type": "commit"}]}