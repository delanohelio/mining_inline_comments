{"pr_number": 3194, "pr_title": "[DROOLS-5730] improve performances of arguments fetch in executable m\u2026", "pr_createdAt": "2020-10-27T15:49:26Z", "pr_url": "https://github.com/kiegroup/drools/pull/3194", "timeline": [{"oid": "101b2f8e00f3aebab89ce104acb7262d446ecbf3", "url": "https://github.com/kiegroup/drools/commit/101b2f8e00f3aebab89ce104acb7262d446ecbf3", "message": "[DROOLS-5730] improve performances of arguments fetch in executable model consequence", "committedDate": "2020-10-27T15:13:55Z", "type": "commit"}, {"oid": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "url": "https://github.com/kiegroup/drools/commit/d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "message": "wip", "committedDate": "2020-10-27T17:02:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1MjM4NA==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513252384", "bodyText": "Is it possible to wrap this logic in a method to improve readability?\n/**\n * When rule has only AND as top level, it is possible to precalculate requiredDeclarations as optimization \n */\nprivate Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\n        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n        Variable[] consequenceVars = consequence.getDeclarations();\n        String[] requiredDeclarationNames = new String[consequenceVars.length];\n        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n        for (int i = 0; i < consequenceVars.length; i++) {\n            requiredDeclarationNames[i] = consequenceVars[i].getName();\n            if (!ruleHasFirstLevelOr) {\n                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n            }\n        }\n\n        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );\n        return requiredDeclarations;\n}", "author": "danielezonca", "createdAt": "2020-10-28T08:18:43Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,50 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n+        Variable[] consequenceVars = consequence.getDeclarations();\n+        String[] requiredDeclarationNames = new String[consequenceVars.length];\n+        Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n+        for (int i = 0; i < consequenceVars.length; i++) {\n+            requiredDeclarationNames[i] = consequenceVars[i].getName();\n+            if (!ruleHasFirstLevelOr) {\n+                requiredDeclarations[i] = ctx.getRule().getDeclaration( requiredDeclarationNames[i] );\n+            }\n+        }\n+\n+        ctx.getRule().setRequiredDeclarationsForConsequence( name, requiredDeclarationNames );", "originalCommit": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3e28754f3289232005c0aba1ef3d96ed59612112", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java\nindex 03dd95c442..088a157142 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java\n\n@@ -382,7 +382,11 @@ public class KiePackagesBuilder {\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        // If there's an OR in the rule the fired tuple hasn't fixed structure and size because it dependens\n+        // on which branch of the OR gets activated. In this case no optimization is possible and it's usless\n+        // to precalculate the declartions at compile time.\n         boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n+\n         Variable[] consequenceVars = consequence.getDeclarations();\n         String[] requiredDeclarationNames = new String[consequenceVars.length];\n         Declaration[] requiredDeclarations = ruleHasFirstLevelOr ? null : new Declaration[consequenceVars.length];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1Mzg0Ng==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513253846", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else {\n          \n          \n            \n                    // declarations is not null when first level rule is AND so it is possible to calculate them upfront\n          \n          \n            \n                    } else {", "author": "danielezonca", "createdAt": "2020-10-28T08:21:14Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -43,23 +52,28 @@ public String getName() {\n \n     @Override\n     public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemory ) throws Exception {\n-        Declaration[] declarations = ((RuleTerminalNode)knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n-        Object[] facts = declarationsToFacts( knowledgeHelper, workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        Object[] facts;\n+        if ( this.declarations == null ) {\n+            Declaration[] declarations = (( RuleTerminalNode ) knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n+            facts = declarationsToFacts( knowledgeHelper, ( InternalWorkingMemory ) workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n+        } else {", "originalCommit": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java\nindex 658df16818..b2e149c9c4 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java\n\n@@ -57,6 +60,7 @@ public class LambdaConsequence implements Consequence {\n             Declaration[] declarations = (( RuleTerminalNode ) knowledgeHelper.getMatch().getTuple().getTupleSink()).getRequiredDeclarations();\n             facts = declarationsToFacts( knowledgeHelper, ( InternalWorkingMemory ) workingMemory, knowledgeHelper.getTuple(), declarations, consequence.getVariables(), consequence.isUsingDrools() );\n         } else {\n+            // declarations is not null when first level rule is AND so it is possible to calculate them upfront\n             facts = fetchFacts( knowledgeHelper, ( InternalWorkingMemory ) workingMemory );\n         }\n         consequence.getBlock().execute( facts );\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513254355", "bodyText": "Is this an additional/unrelated bugfix/improvement?", "author": "danielezonca", "createdAt": "2020-10-28T08:22:07Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +83,184 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }", "originalCommit": "d887b0a52f53e7a5e4c1256388dc8eafca60a22d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI2MDQ5OA==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513260498", "bodyText": "If look at the old code\n    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n        return linkedFH != null ? linkedFH : handle;\n    }\n\n\nand at the new one\n    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n        if ( !handle.isEvent() ) {\n            return handle;\n        }\n        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n        return linkedFH != null ? linkedFH : handle;\n    }\n\nyou will realize that the 2 codes are functionally identical: if the handle is not an event nothing has to be done and the handle can be used as it is. I just wanted to make this thing more explicit and avoid a useless second null check in that case.", "author": "mariofusco", "createdAt": "2020-10-28T08:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI1NDM1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "3e28754f3289232005c0aba1ef3d96ed59612112", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java\nindex 658df16818..1690b3a78a 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java\n\n@@ -107,6 +108,7 @@ public class LambdaConsequence implements Consequence {\n         if (factSuppliers == null) {\n             return initConsequence(knowledgeHelper, workingMemory, tuple);\n         }\n+        Object[] facts = new Object[factSuppliers.length];\n         for (int i = 0; i < facts.length; i++) {\n             tuple = factSuppliers[i].get( facts, knowledgeHelper, workingMemory, tuple );\n         }\n"}}, {"oid": "3e28754f3289232005c0aba1ef3d96ed59612112", "url": "https://github.com/kiegroup/drools/commit/3e28754f3289232005c0aba1ef3d96ed59612112", "message": "fix multithreading use of LambdaConsequence + add a few comments", "committedDate": "2020-10-28T08:55:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MTEzNw==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513571137", "bodyText": "Can you please first introduce the optimization and then explain why it is not applicable to OR? :)", "author": "danielezonca", "createdAt": "2020-10-28T16:08:10Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java", "diffHunk": "@@ -375,30 +375,54 @@ private void addQueryPattern( Query query, QueryImpl queryImpl, RuleContext ctx\n         queryImpl.setParameters( declarations );\n     }\n \n-    private void processConsequences( RuleContext ctx, Rule rule ) {\n-        for (Map.Entry<String, Consequence> entry : rule.getConsequences().entrySet()) {\n+    private void processConsequences( RuleContext ctx, Map<String, Consequence> consequences ) {\n+        for (Map.Entry<String, Consequence> entry : consequences.entrySet()) {\n             processConsequence( ctx, entry.getValue(), entry.getKey() );\n         }\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        // If there's an OR in the rule the fired tuple hasn't fixed structure and size because it dependens\n+        // on which branch of the OR gets activated. In this case no optimization is possible and it's usless\n+        // to precalculate the declartions at compile time.", "originalCommit": "3e28754f3289232005c0aba1ef3d96ed59612112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java\nindex 088a157142..d1c5a1228a 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/KiePackagesBuilder.java\n\n@@ -382,10 +382,26 @@ public class KiePackagesBuilder {\n     }\n \n     private void processConsequence( RuleContext ctx, Consequence consequence, String name ) {\n+        Declaration[] requiredDeclarations = getRequiredDeclarationsIfPossible( ctx, consequence, name );\n+\n+        if ( name.equals( RuleImpl.DEFAULT_CONSEQUENCE_NAME ) ) {\n+            if (\"java\".equals(consequence.getLanguage())) {\n+                ctx.getRule().setConsequence( new LambdaConsequence( consequence, requiredDeclarations ) );\n+            } else {\n+                throw new UnsupportedOperationException(\"Unknown script language for consequence: \" + consequence.getLanguage());\n+            }\n+        } else {\n+            ctx.getRule().addNamedConsequence( name, new LambdaConsequence( consequence, requiredDeclarations ) );\n+        }\n+    }\n+\n+    private Declaration[] getRequiredDeclarationsIfPossible( RuleContext ctx, Consequence consequence, String name ) {\n+        // Retrieving the required declarations for the consequence at build time allows to extract from the activation\n+        // tuple the arguments to be passed to the consequence in linear time by traversing the tuple only once.\n         // If there's an OR in the rule the fired tuple hasn't fixed structure and size because it dependens\n         // on which branch of the OR gets activated. In this case no optimization is possible and it's usless\n-        // to precalculate the declartions at compile time.\n-        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr(ctx.getRule());\n+        // to precalculate the declartions at build time.\n+        boolean ruleHasFirstLevelOr = ruleHasFirstLevelOr( ctx.getRule());\n \n         Variable[] consequenceVars = consequence.getDeclarations();\n         String[] requiredDeclarationNames = new String[consequenceVars.length];\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3ODIyOA==", "url": "https://github.com/kiegroup/drools/pull/3194#discussion_r513578228", "bodyText": "Can you refer the optimization here too (in the future we will not have the PR to see the whole code together :) )?", "author": "danielezonca", "createdAt": "2020-10-28T16:17:16Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/consequence/LambdaConsequence.java", "diffHunk": "@@ -69,19 +84,196 @@ public void evaluate( KnowledgeHelper knowledgeHelper, WorkingMemory workingMemo\n             if ( var.isFact() ) {\n                 Declaration declaration = declarations[declrCounter++];\n                 InternalFactHandle fh = getOriginalFactHandle( tuple.get( declaration ) );\n-                if (useDrools) {\n-                    ( (DroolsImpl) facts[0] ).registerFactHandle( fh );\n+                if ( useDrools ) {\n+                    (( DroolsImpl ) facts[0]).registerFactHandle( fh );\n                 }\n-                facts[factsOffset++] = declaration.getValue( (InternalWorkingMemory ) workingMemory, fh.getObject() );\n+                facts[factsOffset++] = declaration.getValue( workingMemory, fh.getObject() );\n             } else {\n                 facts[factsOffset++] = workingMemory.getGlobal( var.getName() );\n             }\n         }\n         return facts;\n     }\n \n-    private static InternalFactHandle getOriginalFactHandle(InternalFactHandle handle) {\n-        InternalFactHandle linkedFH = handle.isEvent() ? ((EventFactHandle )handle).getLinkedFactHandle() : null;\n+    private static InternalFactHandle getOriginalFactHandle( InternalFactHandle handle ) {\n+        if ( !handle.isEvent() ) {\n+            return handle;\n+        }\n+        InternalFactHandle linkedFH = (( EventFactHandle ) handle).getLinkedFactHandle();\n         return linkedFH != null ? linkedFH : handle;\n     }\n-}\n+\n+    private Object[] fetchFacts( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory ) {\n+        Tuple tuple = knowledgeHelper.getTuple();\n+        if (factSuppliers == null) {\n+            return initConsequence(knowledgeHelper, workingMemory, tuple);\n+        }\n+        Object[] facts = new Object[factSuppliers.length];\n+        for (int i = 0; i < facts.length; i++) {\n+            tuple = factSuppliers[i].get( facts, knowledgeHelper, workingMemory, tuple );\n+        }\n+        return facts;\n+    }\n+\n+    private Object[] initConsequence( KnowledgeHelper knowledgeHelper, InternalWorkingMemory workingMemory, Tuple tuple ) {\n+        Variable[] vars = consequence.getVariables();\n+        List<FactSupplier> factSuppliers = new ArrayList<>();\n+\n+        Object[] facts;\n+        int factsOffset = 0;\n+        if ( consequence.isUsingDrools() ) {\n+            factsOffset++;\n+            factSuppliers.add( DroolsImplSupplier.INSTANCE );\n+            facts = new Object[vars.length + 1];\n+            facts[0] = new DroolsImpl( knowledgeHelper, workingMemory );\n+        } else {\n+            facts = new Object[vars.length];\n+        }\n+\n+        int declrCounter = 0;\n+        for (Variable var : vars) {\n+            if ( var.isFact() ) {\n+                factSuppliers.add( new TupleFactSupplier(factsOffset, declarations[declrCounter++], consequence.isUsingDrools()) );\n+            } else {\n+                facts[factsOffset] = workingMemory.getGlobal( var.getName() );\n+                factSuppliers.add( new GlobalSupplier(factsOffset, var.getName()) );\n+            }\n+            factsOffset++;\n+        }\n+\n+        // At this point the FactSuppliers (each of them supplying a single argument to be passed to the consequence)", "originalCommit": "3e28754f3289232005c0aba1ef3d96ed59612112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "url": "https://github.com/kiegroup/drools/commit/1df73e5ba100d99c28b3f4ad55fe1e1da17f546b", "message": "wip", "committedDate": "2020-10-28T18:05:41Z", "type": "commit"}]}