{"pr_number": 2900, "pr_title": "[BAPL-1259] Add logging for rule performance analysis", "pr_createdAt": "2020-05-15T06:13:49Z", "pr_url": "https://github.com/kiegroup/drools/pull/2900", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0MzIzNA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432443234", "bodyText": "Instead of 4 different ThreadLocals would be better (for perf reasons too) to encapsulate the statistics collected per BaseNode into a BaseNodeStats class that could be used into a single ThreadLocal", "author": "franz1981", "createdAt": "2020-05-29T12:16:11Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8adf0839793929a354155ce2d95661f2253505ca", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex 45b3d420fb..a76ded0586 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -16,8 +16,6 @@\n \n package org.drools.core.util;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.drools.core.common.BaseNode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0MzcyNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432443725", "bodyText": "There is no need to use an AtomicInteger here, but a single int (or long?) field into the BaseNodeStats (see prev comment) would be enough, given that is being used in a single threaded fashion", "author": "franz1981", "createdAt": "2020-05-29T12:17:14Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();\n+    private static final ThreadLocal<AtomicInteger> evalCount = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8adf0839793929a354155ce2d95661f2253505ca", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex 45b3d420fb..a76ded0586 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -16,8 +16,6 @@\n \n package org.drools.core.util;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.drools.core.common.BaseNode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0NDQ2MQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432444461", "bodyText": "There is no need to use a boxed type here, but just a single long field into BaseNodeStats (see previous comments) is enough: it would save both pointer chasing and garbage produced", "author": "franz1981", "createdAt": "2020-05-29T12:18:40Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();\n+    private static final ThreadLocal<AtomicInteger> evalCount = new ThreadLocal<>();\n+    private static final ThreadLocal<Long> startTime = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8adf0839793929a354155ce2d95661f2253505ca", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex 45b3d420fb..a76ded0586 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -16,8 +16,6 @@\n \n package org.drools.core.util;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.drools.core.common.BaseNode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ0Njg0OA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r432446848", "bodyText": "Ditto as before: could be part of a single thread local instance (ie BaseNodeStats), but it worries me that I cannot see any code path that set it to null..it risks to became an actual memory leak: I suggest to rethink if it worths to make this a weak reference field instead...", "author": "franz1981", "createdAt": "2020-05-29T12:23:02Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<Boolean> started = new ThreadLocal<>();\n+    private static final ThreadLocal<AtomicInteger> evalCount = new ThreadLocal<>();\n+    private static final ThreadLocal<Long> startTime = new ThreadLocal<>();\n+    private static final ThreadLocal<BaseNode> node = new ThreadLocal<>();", "originalCommit": "064e986a5f5c87a9fae8570ce5344e8e31b69ac9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8adf0839793929a354155ce2d95661f2253505ca", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex 45b3d420fb..a76ded0586 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -16,8 +16,6 @@\n \n package org.drools.core.util;\n \n-import java.util.concurrent.atomic.AtomicInteger;\n-\n import org.drools.core.common.BaseNode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA5MjE0Mw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r433092143", "bodyText": "I would save this expensive computation ie  elapsedTime / 1000 to perform it just once and I would handle the case of stats == null with a log or something similar: at this point this is not supposed to be null right?", "author": "franz1981", "createdAt": "2020-06-01T07:53:51Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -55,33 +50,29 @@ public static void setEnabled(boolean enabled) {\n \n     public static void startMetrics(BaseNode baseNode) {\n         if (enabled) {\n-            started.set(true);\n-            node.set(baseNode);\n-            evalCount.set(new AtomicInteger(0));\n-            startTime.set(System.nanoTime());\n-        }\n-    }\n-\n-    public static void endMetrics() {\n-        if (enabled) {\n-            started.set(false);\n+            nodeStats.set(new NodeStats(baseNode));\n         }\n     }\n \n     public static void incrementEvalCount() {\n-        if (enabled && started.get().booleanValue()) {\n-            evalCount.get().getAndIncrement();\n+        if (enabled) {\n+            NodeStats stats = nodeStats.get();\n+            if (stats != null && stats.isStarted()) {\n+                stats.incrementEvalCount();\n+            }\n         }\n     }\n \n     public static void logAndEndMetrics() {\n-        if (enabled && started.get().booleanValue()) {\n-            long elapsedTime = (System.nanoTime() - startTime.get());\n-            int count = evalCount.get().intValue();\n-            if (count > 0 && (elapsedTime / 1000) > threshold) {\n-                logger.trace(\"{}, evalCount:{}, elapsed:{}\", node.get(), count, elapsedTime / 1000); // microseconds\n+        if (enabled) {\n+            NodeStats stats = nodeStats.get();\n+            if (stats != null && stats.isStarted()) {\n+                long elapsedTime = (System.nanoTime() - stats.getStartTime());\n+                if (stats.getEvalCount() > 0 && (elapsedTime / 1000) > threshold) {", "originalCommit": "c09049ac9b83c905e70ff4bd1a51d1daaa991182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU4ODE3MQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r433588171", "bodyText": "Applied the suggestion. Thanks!", "author": "tkobayas", "createdAt": "2020-06-02T02:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA5MjE0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "8adf0839793929a354155ce2d95661f2253505ca", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex 39af7d8f92..a76ded0586 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -59,7 +59,7 @@ public class PerfLogUtils {\n             NodeStats stats = nodeStats.get();\n             if (stats != null && stats.isStarted()) {\n                 stats.incrementEvalCount();\n-            }\n+            } // don't log warn for stats == null because an evaluation may be executed under metrics or not.\n         }\n     }\n \n"}}, {"oid": "8adf0839793929a354155ce2d95661f2253505ca", "url": "https://github.com/kiegroup/drools/commit/8adf0839793929a354155ce2d95661f2253505ca", "message": "- applied to PhrealEvalNode\n- try/finally", "committedDate": "2020-06-22T00:17:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzOTI4Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r443439282", "bodyText": "Given that's globally visible...maybe it should use a volatile here: you expect this to change while the application is running?", "author": "franz1981", "createdAt": "2020-06-22T09:42:44Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private static boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private static int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private static final ThreadLocal<NodeStats> nodeStats = new ThreadLocal<>();\n+\n+    public static int getThreshold() {\n+        return threshold;\n+    }\n+\n+    public static void setThreshold(int threshold) {\n+        PerfLogUtils.threshold = threshold;\n+    }\n+\n+    public static boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    public static void setEnabled(boolean enabled) {\n+        PerfLogUtils.enabled = enabled;", "originalCommit": "8adf0839793929a354155ce2d95661f2253505ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk1MjMyMQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r443952321", "bodyText": "I don't expect this to be changed while the application is running, I added this for test convenience but maybe I can make it package private (or even remove)... Thanks for pointing this out :)", "author": "tkobayas", "createdAt": "2020-06-23T04:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQzOTI4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex a76ded0586..45b3d420fb 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -16,6 +16,8 @@\n \n package org.drools.core.util;\n \n+import java.util.concurrent.atomic.AtomicInteger;\n+\n import org.drools.core.common.BaseNode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMDgyNA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446810824", "bodyText": "I think that this constructor is called by default. Any reason for explicitly adding it here?", "author": "jiripetrlik", "createdAt": "2020-06-29T06:58:34Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.common.metric;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.common.DefaultBetaConstraints;\n+import org.drools.core.common.InternalFactHandle;\n+import org.drools.core.rule.ContextEntry;\n+import org.drools.core.rule.MutableTypeConstraint;\n+import org.drools.core.spi.BetaNodeFieldConstraint;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n+\n+    private static final long serialVersionUID = 510l;\n+\n+    public DefaultBetaConstraintsMetric() {\n+        super();", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMTMzOA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446911338", "bodyText": "Thank you for pointing this! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMDgyNA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java\ndeleted file mode 100644\nindex a11e36abf6..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.DefaultBetaConstraints;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n-\n-    private static final long serialVersionUID = 510l;\n-\n-    public DefaultBetaConstraintsMetric() {\n-        super();\n-    }\n-\n-    public DefaultBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                        final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-\n-    }\n-\n-    public DefaultBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                        final RuleBaseConfiguration conf,\n-                                        final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    @Override\n-    public DefaultBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint)constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            DefaultBetaConstraintsMetric clone = new DefaultBetaConstraintsMetric();\n-            clone.constraints = clonedConstraints;\n-            clone.disableIndexing = disableIndexing;\n-            clone.indexPrecedenceOption = indexPrecedenceOption;\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTU1Nw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446811557", "bodyText": "I know it is a detail. But maybe please update 2005 to 2020.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:00:16Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java\ndeleted file mode 100644\nindex a11e36abf6..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.DefaultBetaConstraints;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n-\n-    private static final long serialVersionUID = 510l;\n-\n-    public DefaultBetaConstraintsMetric() {\n-        super();\n-    }\n-\n-    public DefaultBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                        final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-\n-    }\n-\n-    public DefaultBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                        final RuleBaseConfiguration conf,\n-                                        final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    @Override\n-    public DefaultBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint)constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            DefaultBetaConstraintsMetric clone = new DefaultBetaConstraintsMetric();\n-            clone.constraints = clonedConstraints;\n-            clone.disableIndexing = disableIndexing;\n-            clone.indexPrecedenceOption = indexPrecedenceOption;\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTYxMA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446811610", "bodyText": "I know it is a detail. But maybe please update 2005 to 2020.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:00:23Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DoubleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMTc4OQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446911789", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTYxMA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/DoubleBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/DoubleBetaConstraintsMetric.java\ndeleted file mode 100644\nindex c1d371ba4d..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/DoubleBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.DoubleBetaConstraints;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-import org.kie.internal.conf.IndexPrecedenceOption;\n-\n-public class DoubleBetaConstraintsMetric extends DoubleBetaConstraints {\n-\n-    private static final long serialVersionUID = 510l;\n-\n-    public DoubleBetaConstraintsMetric() {}\n-\n-    public DoubleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                       final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-    }\n-\n-    public DoubleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                       final RuleBaseConfiguration conf,\n-                                       final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    protected DoubleBetaConstraintsMetric(BetaNodeFieldConstraint[] constraints,\n-                                          IndexPrecedenceOption indexPrecedenceOption,\n-                                          boolean disableIndexing) {\n-        super(constraints, indexPrecedenceOption, disableIndexing);\n-    }\n-\n-    @Override\n-    public DoubleBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint) constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            DoubleBetaConstraintsMetric clone = new DoubleBetaConstraintsMetric(clonedConstraints, indexPrecedenceOption, disableIndexing);\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTc5Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446811792", "bodyText": "I know it is a detail. But maybe please update 2005 to 2020.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:00:46Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMTk3MQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446911971", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMTc5Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java\ndeleted file mode 100644\nindex 48083ae0d5..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.common.QuadroupleBetaConstraints;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-import org.kie.internal.conf.IndexPrecedenceOption;\n-\n-public class QuadroupleBetaConstraintsMetric extends QuadroupleBetaConstraints {\n-\n-    private static final long             serialVersionUID = 510l;\n-\n-    public QuadroupleBetaConstraintsMetric() { }\n-\n-    public QuadroupleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                     final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-    }\n-\n-    public QuadroupleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                     final RuleBaseConfiguration conf,\n-                                     final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    protected QuadroupleBetaConstraintsMetric( BetaNodeFieldConstraint[] constraints,\n-                                   IndexPrecedenceOption indexPrecedenceOption,\n-                                   boolean disableIndexing) {\n-        super(constraints, indexPrecedenceOption, disableIndexing);\n-    }\n-\n-    @Override\n-    public QuadroupleBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint)constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            QuadroupleBetaConstraintsMetric clone = new QuadroupleBetaConstraintsMetric(clonedConstraints, indexPrecedenceOption, disableIndexing);\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjA4OQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812089", "bodyText": "Isn't this called by default?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:01:28Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.common.metric;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.common.DefaultBetaConstraints;\n+import org.drools.core.common.InternalFactHandle;\n+import org.drools.core.rule.ContextEntry;\n+import org.drools.core.rule.MutableTypeConstraint;\n+import org.drools.core.spi.BetaNodeFieldConstraint;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n+\n+    private static final long serialVersionUID = 510l;\n+\n+    public DefaultBetaConstraintsMetric() {\n+        super();", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjQyMQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912421", "bodyText": "Thank you for pointing this! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjA4OQ=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java\ndeleted file mode 100644\nindex a11e36abf6..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/DefaultBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,78 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.DefaultBetaConstraints;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class DefaultBetaConstraintsMetric extends DefaultBetaConstraints {\n-\n-    private static final long serialVersionUID = 510l;\n-\n-    public DefaultBetaConstraintsMetric() {\n-        super();\n-    }\n-\n-    public DefaultBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                        final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-\n-    }\n-\n-    public DefaultBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                        final RuleBaseConfiguration conf,\n-                                        final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    @Override\n-    public DefaultBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint)constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            DefaultBetaConstraintsMetric clone = new DefaultBetaConstraintsMetric();\n-            clone.constraints = clonedConstraints;\n-            clone.disableIndexing = disableIndexing;\n-            clone.indexPrecedenceOption = indexPrecedenceOption;\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjE1MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812150", "bodyText": "Is this indent intentional?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:01:38Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.common.metric;\n+\n+import org.drools.core.RuleBaseConfiguration;\n+import org.drools.core.common.InternalFactHandle;\n+import org.drools.core.common.QuadroupleBetaConstraints;\n+import org.drools.core.rule.ContextEntry;\n+import org.drools.core.rule.MutableTypeConstraint;\n+import org.drools.core.spi.BetaNodeFieldConstraint;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+import org.kie.internal.conf.IndexPrecedenceOption;\n+\n+public class QuadroupleBetaConstraintsMetric extends QuadroupleBetaConstraints {\n+\n+    private static final long             serialVersionUID = 510l;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjE1Ng==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912156", "bodyText": "Thanks! Formatted", "author": "tkobayas", "createdAt": "2020-06-29T11:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjE1MA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java\ndeleted file mode 100644\nindex 48083ae0d5..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/QuadroupleBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.common.QuadroupleBetaConstraints;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-import org.kie.internal.conf.IndexPrecedenceOption;\n-\n-public class QuadroupleBetaConstraintsMetric extends QuadroupleBetaConstraints {\n-\n-    private static final long             serialVersionUID = 510l;\n-\n-    public QuadroupleBetaConstraintsMetric() { }\n-\n-    public QuadroupleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                     final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-    }\n-\n-    public QuadroupleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                     final RuleBaseConfiguration conf,\n-                                     final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    protected QuadroupleBetaConstraintsMetric( BetaNodeFieldConstraint[] constraints,\n-                                   IndexPrecedenceOption indexPrecedenceOption,\n-                                   boolean disableIndexing) {\n-        super(constraints, indexPrecedenceOption, disableIndexing);\n-    }\n-\n-    @Override\n-    public QuadroupleBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint)constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            QuadroupleBetaConstraintsMetric clone = new QuadroupleBetaConstraintsMetric(clonedConstraints, indexPrecedenceOption, disableIndexing);\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjM0Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812342", "bodyText": "Please update date.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:02:05Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/SingleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjIxNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912215", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjM0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/SingleBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/SingleBetaConstraintsMetric.java\ndeleted file mode 100644\nindex 4ecc4c71b8..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/SingleBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,75 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.common.SingleBetaConstraints;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class SingleBetaConstraintsMetric extends SingleBetaConstraints {\n-\n-    private static final long serialVersionUID = 510l;\n-\n-    public SingleBetaConstraintsMetric() {\n-        super();\n-    }\n-\n-    public SingleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraint,\n-                                       final RuleBaseConfiguration conf) {\n-        super(constraint[0], conf);\n-    }\n-\n-    public SingleBetaConstraintsMetric(final BetaNodeFieldConstraint constraint,\n-                                       final RuleBaseConfiguration conf) {\n-        super(constraint, conf);\n-    }\n-\n-    public SingleBetaConstraintsMetric(final BetaNodeFieldConstraint constraint,\n-                                       final RuleBaseConfiguration conf,\n-                                       final boolean disableIndex) {\n-        super(constraint, conf, disableIndex);\n-    }\n-\n-    @Override\n-    public SingleBetaConstraintsMetric cloneIfInUse() {\n-        if (constraint instanceof MutableTypeConstraint && ((MutableTypeConstraint) constraint).setInUse()) {\n-            SingleBetaConstraintsMetric clone = new SingleBetaConstraintsMetric(constraint.cloneIfInUse(), null, disableIndex);\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjYyMA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812620", "bodyText": "Please fix date.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:02:50Z", "path": "drools-core/src/main/java/org/drools/core/common/metric/TripleBetaConstraintsMetric.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2005 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjU0NA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912544", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjYyMA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/common/metric/TripleBetaConstraintsMetric.java b/drools-core/src/main/java/org/drools/core/common/metric/TripleBetaConstraintsMetric.java\ndeleted file mode 100644\nindex c742f4c8cd..0000000000\n--- a/drools-core/src/main/java/org/drools/core/common/metric/TripleBetaConstraintsMetric.java\n+++ /dev/null\n\n@@ -1,79 +0,0 @@\n-/*\n- * Copyright 2005 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.drools.core.common.metric;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.InternalFactHandle;\n-import org.drools.core.common.TripleBetaConstraints;\n-import org.drools.core.rule.ContextEntry;\n-import org.drools.core.rule.MutableTypeConstraint;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-import org.kie.internal.conf.IndexPrecedenceOption;\n-\n-public class TripleBetaConstraintsMetric extends TripleBetaConstraints {\n-\n-    private static final long serialVersionUID = 510l;\n-\n-    public TripleBetaConstraintsMetric() {}\n-\n-    public TripleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                       final RuleBaseConfiguration conf) {\n-        super(constraints, conf);\n-    }\n-\n-    public TripleBetaConstraintsMetric(final BetaNodeFieldConstraint[] constraints,\n-                                       final RuleBaseConfiguration conf,\n-                                       final boolean disableIndexing) {\n-        super(constraints, conf, disableIndexing);\n-    }\n-\n-    protected TripleBetaConstraintsMetric(BetaNodeFieldConstraint[] constraints,\n-                                          IndexPrecedenceOption indexPrecedenceOption,\n-                                          boolean disableIndexing) {\n-        super(constraints, indexPrecedenceOption, disableIndexing);\n-    }\n-\n-    @Override\n-    public TripleBetaConstraintsMetric cloneIfInUse() {\n-        if (constraints[0] instanceof MutableTypeConstraint && ((MutableTypeConstraint) constraints[0]).setInUse()) {\n-            BetaNodeFieldConstraint[] clonedConstraints = new BetaNodeFieldConstraint[constraints.length];\n-            for (int i = 0; i < constraints.length; i++) {\n-                clonedConstraints[i] = constraints[i].cloneIfInUse();\n-            }\n-            TripleBetaConstraintsMetric clone = new TripleBetaConstraintsMetric(clonedConstraints, indexPrecedenceOption, disableIndexing);\n-            clone.indexed = indexed;\n-            return clone;\n-        }\n-        return this;\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedLeft(final ContextEntry[] context,\n-                                       final InternalFactHandle handle) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedLeft(context, handle);\n-    }\n-\n-    @Override\n-    public boolean isAllowedCachedRight(final ContextEntry[] context,\n-                                        final Tuple tuple) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowedCachedRight(context, tuple);\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjcxMA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446812710", "bodyText": "Missing license header.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:03:04Z", "path": "drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.drools.core.phreak;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMjYxNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446912615", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMjcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java b/drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java\ndeleted file mode 100644\nindex 896b83de6a..0000000000\n--- a/drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java\n+++ /dev/null\n\n@@ -1,135 +0,0 @@\n-package org.drools.core.phreak;\n-\n-import org.drools.core.phreak.metric.PhreakAccumulateNodeMetric;\n-import org.drools.core.phreak.metric.PhreakAsyncReceiveNodeMetric;\n-import org.drools.core.phreak.metric.PhreakAsyncSendNodeMetric;\n-import org.drools.core.phreak.metric.PhreakBranchNodeMetric;\n-import org.drools.core.phreak.metric.PhreakEvalNodeMetric;\n-import org.drools.core.phreak.metric.PhreakExistsNodeMetric;\n-import org.drools.core.phreak.metric.PhreakFromNodeMetric;\n-import org.drools.core.phreak.metric.PhreakJoinNodeMetric;\n-import org.drools.core.phreak.metric.PhreakNotNodeMetric;\n-import org.drools.core.phreak.metric.PhreakQueryNodeMetric;\n-import org.drools.core.phreak.metric.PhreakQueryTerminalNodeMetric;\n-import org.drools.core.phreak.metric.PhreakReactiveFromNodeMetric;\n-import org.drools.core.phreak.metric.PhreakTimerNodeMetric;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class PhreakNetworkNodeFactory {\n-\n-    private static final PhreakNetworkNodeFactory INSTANCE = new PhreakNetworkNodeFactory();\n-\n-    public static PhreakNetworkNodeFactory getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private PhreakNetworkNodeFactory() {}\n-\n-    PhreakJoinNode createPhreakJoinNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakJoinNodeMetric();\n-        } else {\n-            return new PhreakJoinNode();\n-        }\n-    }\n-\n-    PhreakEvalNode createPhreakEvalNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakEvalNodeMetric();\n-        } else {\n-            return new PhreakEvalNode();\n-        }\n-    }\n-\n-    PhreakFromNode createPhreakFromNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakFromNodeMetric();\n-        } else {\n-            return new PhreakFromNode();\n-        }\n-    }\n-\n-    PhreakReactiveFromNode createPhreakReactiveFromNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakReactiveFromNodeMetric();\n-        } else {\n-            return new PhreakReactiveFromNode();\n-        }\n-    }\n-\n-    PhreakNotNode createPhreakNotNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakNotNodeMetric();\n-        } else {\n-            return new PhreakNotNode();\n-        }\n-    }\n-\n-    PhreakExistsNode createPhreakExistsNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakExistsNodeMetric();\n-        } else {\n-            return new PhreakExistsNode();\n-        }\n-    }\n-\n-    PhreakAccumulateNode createPhreakAccumulateNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakAccumulateNodeMetric();\n-        } else {\n-            return new PhreakAccumulateNode();\n-        }\n-    }\n-\n-    PhreakBranchNode createPhreakBranchNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakBranchNodeMetric();\n-        } else {\n-            return new PhreakBranchNode();\n-        }\n-    }\n-\n-    PhreakQueryNode createPhreakQueryNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakQueryNodeMetric();\n-        } else {\n-            return new PhreakQueryNode();\n-        }\n-    }\n-\n-    PhreakTimerNode createPhreakTimerNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakTimerNodeMetric();\n-        } else {\n-            return new PhreakTimerNode();\n-        }\n-    }\n-\n-    PhreakAsyncSendNode createPhreakAsyncSendNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakAsyncSendNodeMetric();\n-        } else {\n-            return new PhreakAsyncSendNode();\n-        }\n-    }\n-\n-    PhreakAsyncReceiveNode createPhreakAsyncReceiveNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakAsyncReceiveNodeMetric();\n-        } else {\n-            return new PhreakAsyncReceiveNode();\n-        }\n-    }\n-\n-    PhreakRuleTerminalNode createPhreakRuleTerminalNode() {\n-        return new PhreakRuleTerminalNode(); // TerminalNode is not BaseNode so cannot use PerfLogUtils\n-    }\n-\n-    PhreakQueryTerminalNode createPhreakQueryTerminalNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakQueryTerminalNodeMetric();\n-        } else {\n-            return new PhreakQueryTerminalNode();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzgwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446813807", "bodyText": "Is missing access modifier intentional? Shouldn't we rather use public?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:05:33Z", "path": "drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package org.drools.core.phreak;\n+\n+import org.drools.core.phreak.metric.PhreakAccumulateNodeMetric;\n+import org.drools.core.phreak.metric.PhreakAsyncReceiveNodeMetric;\n+import org.drools.core.phreak.metric.PhreakAsyncSendNodeMetric;\n+import org.drools.core.phreak.metric.PhreakBranchNodeMetric;\n+import org.drools.core.phreak.metric.PhreakEvalNodeMetric;\n+import org.drools.core.phreak.metric.PhreakExistsNodeMetric;\n+import org.drools.core.phreak.metric.PhreakFromNodeMetric;\n+import org.drools.core.phreak.metric.PhreakJoinNodeMetric;\n+import org.drools.core.phreak.metric.PhreakNotNodeMetric;\n+import org.drools.core.phreak.metric.PhreakQueryNodeMetric;\n+import org.drools.core.phreak.metric.PhreakQueryTerminalNodeMetric;\n+import org.drools.core.phreak.metric.PhreakReactiveFromNodeMetric;\n+import org.drools.core.phreak.metric.PhreakTimerNodeMetric;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class PhreakNetworkNodeFactory {\n+\n+    private static final PhreakNetworkNodeFactory INSTANCE = new PhreakNetworkNodeFactory();\n+\n+    public static PhreakNetworkNodeFactory getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private PhreakNetworkNodeFactory() {}\n+\n+    PhreakJoinNode createPhreakJoinNode() {", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMzM4NA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446913384", "bodyText": "Yes, it's intentional to be package private. Thanks!", "author": "tkobayas", "createdAt": "2020-06-29T11:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzgwNw=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java b/drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java\ndeleted file mode 100644\nindex 896b83de6a..0000000000\n--- a/drools-core/src/main/java/org/drools/core/phreak/PhreakNetworkNodeFactory.java\n+++ /dev/null\n\n@@ -1,135 +0,0 @@\n-package org.drools.core.phreak;\n-\n-import org.drools.core.phreak.metric.PhreakAccumulateNodeMetric;\n-import org.drools.core.phreak.metric.PhreakAsyncReceiveNodeMetric;\n-import org.drools.core.phreak.metric.PhreakAsyncSendNodeMetric;\n-import org.drools.core.phreak.metric.PhreakBranchNodeMetric;\n-import org.drools.core.phreak.metric.PhreakEvalNodeMetric;\n-import org.drools.core.phreak.metric.PhreakExistsNodeMetric;\n-import org.drools.core.phreak.metric.PhreakFromNodeMetric;\n-import org.drools.core.phreak.metric.PhreakJoinNodeMetric;\n-import org.drools.core.phreak.metric.PhreakNotNodeMetric;\n-import org.drools.core.phreak.metric.PhreakQueryNodeMetric;\n-import org.drools.core.phreak.metric.PhreakQueryTerminalNodeMetric;\n-import org.drools.core.phreak.metric.PhreakReactiveFromNodeMetric;\n-import org.drools.core.phreak.metric.PhreakTimerNodeMetric;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class PhreakNetworkNodeFactory {\n-\n-    private static final PhreakNetworkNodeFactory INSTANCE = new PhreakNetworkNodeFactory();\n-\n-    public static PhreakNetworkNodeFactory getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private PhreakNetworkNodeFactory() {}\n-\n-    PhreakJoinNode createPhreakJoinNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakJoinNodeMetric();\n-        } else {\n-            return new PhreakJoinNode();\n-        }\n-    }\n-\n-    PhreakEvalNode createPhreakEvalNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakEvalNodeMetric();\n-        } else {\n-            return new PhreakEvalNode();\n-        }\n-    }\n-\n-    PhreakFromNode createPhreakFromNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakFromNodeMetric();\n-        } else {\n-            return new PhreakFromNode();\n-        }\n-    }\n-\n-    PhreakReactiveFromNode createPhreakReactiveFromNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakReactiveFromNodeMetric();\n-        } else {\n-            return new PhreakReactiveFromNode();\n-        }\n-    }\n-\n-    PhreakNotNode createPhreakNotNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakNotNodeMetric();\n-        } else {\n-            return new PhreakNotNode();\n-        }\n-    }\n-\n-    PhreakExistsNode createPhreakExistsNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakExistsNodeMetric();\n-        } else {\n-            return new PhreakExistsNode();\n-        }\n-    }\n-\n-    PhreakAccumulateNode createPhreakAccumulateNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakAccumulateNodeMetric();\n-        } else {\n-            return new PhreakAccumulateNode();\n-        }\n-    }\n-\n-    PhreakBranchNode createPhreakBranchNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakBranchNodeMetric();\n-        } else {\n-            return new PhreakBranchNode();\n-        }\n-    }\n-\n-    PhreakQueryNode createPhreakQueryNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakQueryNodeMetric();\n-        } else {\n-            return new PhreakQueryNode();\n-        }\n-    }\n-\n-    PhreakTimerNode createPhreakTimerNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakTimerNodeMetric();\n-        } else {\n-            return new PhreakTimerNode();\n-        }\n-    }\n-\n-    PhreakAsyncSendNode createPhreakAsyncSendNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakAsyncSendNodeMetric();\n-        } else {\n-            return new PhreakAsyncSendNode();\n-        }\n-    }\n-\n-    PhreakAsyncReceiveNode createPhreakAsyncReceiveNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakAsyncReceiveNodeMetric();\n-        } else {\n-            return new PhreakAsyncReceiveNode();\n-        }\n-    }\n-\n-    PhreakRuleTerminalNode createPhreakRuleTerminalNode() {\n-        return new PhreakRuleTerminalNode(); // TerminalNode is not BaseNode so cannot use PerfLogUtils\n-    }\n-\n-    PhreakQueryTerminalNode createPhreakQueryTerminalNode() {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new PhreakQueryTerminalNodeMetric();\n-        } else {\n-            return new PhreakQueryTerminalNode();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzk2MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446813960", "bodyText": "Please fix date.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:05:52Z", "path": "drools-core/src/main/java/org/drools/core/phreak/metric/PhreakAccumulateNodeMetric.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2015 Red Hat, Inc. and/or its affiliates.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkxMzYwNQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446913605", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T11:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxMzk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/phreak/metric/PhreakAccumulateNodeMetric.java b/drools-core/src/main/java/org/drools/core/phreak/metric/PhreakAccumulateNodeMetric.java\ndeleted file mode 100644\nindex 6985b9d0af..0000000000\n--- a/drools-core/src/main/java/org/drools/core/phreak/metric/PhreakAccumulateNodeMetric.java\n+++ /dev/null\n\n@@ -1,47 +0,0 @@\n-/*\n- * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n-*/\n-\n-package org.drools.core.phreak.metric;\n-\n-import org.drools.core.common.InternalWorkingMemory;\n-import org.drools.core.common.TupleSets;\n-import org.drools.core.phreak.PhreakAccumulateNode;\n-import org.drools.core.reteoo.AccumulateNode;\n-import org.drools.core.reteoo.AccumulateNode.AccumulateMemory;\n-import org.drools.core.reteoo.LeftTuple;\n-import org.drools.core.reteoo.LeftTupleSink;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class PhreakAccumulateNodeMetric extends PhreakAccumulateNode {\n-\n-    @Override\n-    public void doNode(AccumulateNode accNode,\n-                       LeftTupleSink sink,\n-                       AccumulateMemory am,\n-                       InternalWorkingMemory wm,\n-                       TupleSets<LeftTuple> srcLeftTuples,\n-                       TupleSets<LeftTuple> trgLeftTuples,\n-                       TupleSets<LeftTuple> stagedLeftTuples) {\n-\n-        try {\n-            PerfLogUtils.getInstance().startMetrics(accNode);\n-\n-            super.doNode(accNode, sink, am, wm, srcLeftTuples, trgLeftTuples, stagedLeftTuples);\n-\n-        } finally {\n-            PerfLogUtils.getInstance().logAndEndMetrics();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTc0Mg==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446815742", "bodyText": "Is it ok to do nothing for all these exception types? For example Security or Illegal argument exceptions? Maybe it would be good to at least log something at debug or trace level. What do you think?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:09:56Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.drools.core.reteoo;\n+\n+import java.io.PrintWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.core.common.BaseNode;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.kie.api.KieBase;\n+import org.kie.api.definition.rule.Rule;\n+import org.kie.api.runtime.KieRuntime;\n+import org.kie.api.runtime.KieSession;\n+\n+/**\n+ * \n+ * Utility class to view Rete models\n+ *\n+ */\n+public class ReteDumper {\n+\n+    private PrintWriter writer;\n+    private StringBuilder sb;\n+    private Predicate<BaseNode> nodesFilter;\n+\n+    private boolean nodeInfoOnly = false;\n+\n+    public ReteDumper() {\n+        this(node -> true);\n+    }\n+\n+    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n+        this.nodesFilter = nodesFilter;\n+    }\n+\n+    public ReteDumper(String ruleName) {\n+        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n+    }\n+\n+    public PrintWriter getWriter() {\n+        return writer;\n+    }\n+\n+    /**\n+     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n+     * @param writer\n+     */\n+    public void setWriter(PrintWriter writer) {\n+        this.writer = writer;\n+    }\n+\n+    public boolean isNodeInfoOnly() {\n+        return nodeInfoOnly;\n+    }\n+\n+    /**\n+     * If true, dump without partition/mask information. Default value is false\n+     * @param nodeInfoOnly\n+     */\n+    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n+        this.nodeInfoOnly = nodeInfoOnly;\n+    }\n+\n+    public static void dumpRete(KieBase kbase ) {\n+        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static void dumpRete(KieRuntime session ) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(KieSession session) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(InternalKnowledgeBase kBase) {\n+        new ReteDumper().dump(kBase.getRete());\n+    }\n+\n+    public static void dumpRete(Rete rete) {\n+        new ReteDumper().dump(rete);\n+    }\n+\n+    public void dump(KieBase kbase ) {\n+        dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public void dump(KieRuntime session ) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(KieSession session) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(InternalKnowledgeBase kBase) {\n+        dump(kBase.getRete());\n+    }\n+\n+    public void dump(Rete rete) {\n+        // Other dump/dumpRete methods eventually call this method\n+        sb = new StringBuilder();\n+        traverseRete(rete, this::dumpNode);\n+        printResults();\n+    }\n+\n+    private void printResults() {\n+        if (writer == null) {\n+            System.out.print(sb.toString());\n+        } else {\n+            // if a writer is given by a caller, the caller is responsible for closing\n+            writer.print(sb.toString());\n+        }\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieBase kbase ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieRuntime session ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieSession session) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n+        return new ReteDumper().collect(kBase.getRete());\n+    }\n+\n+    public static Set<BaseNode> collectRete(Rete rete) {\n+        return new ReteDumper().collect(rete);\n+    }\n+\n+    public Set<BaseNode> collect(KieBase kbase ) {\n+        return collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public Set<BaseNode> collect(KieRuntime session ) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(KieSession session) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n+        return collect(kBase.getRete());\n+    }\n+\n+    public Set<BaseNode> collect(Rete rete) {\n+        Set<BaseNode> nodes = createIdentitySet();\n+        traverseRete(rete, (node, s) -> nodes.add(node));\n+        return nodes;\n+    }\n+\n+    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n+        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n+            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n+        }\n+    }\n+\n+    private <T> Set<T> createIdentitySet() {\n+        return Collections.newSetFromMap(new IdentityHashMap<>());\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n+        consumer.accept( node, ident );\n+        if (!visitedNodes.add( node )) {\n+            return;\n+        }\n+        Sink[] sinks = node.getSinks();\n+        if (sinks != null) {\n+            for (Sink sink : sinks) {\n+                if (sink instanceof BaseNode) {\n+                    BaseNode sinkNode = ( BaseNode ) sink;\n+                    if ( nodesFilter.test( sinkNode ) ) {\n+                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident ) {\n+        sb.append(ident + formatNode(node));\n+        if (!nodeInfoOnly) {\n+            sb.append(\" on \" + node.getPartitionId());\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);\n+                Object inferreddMask = node.getClass().getMethod(\"getInferredMask\").invoke(node);\n+                sb.append(\" d \"+declaredMask + \" i \" + inferreddMask);\n+            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+                // do nothing.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzNzY4OA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446937688", "bodyText": "Hmm, I think that this part is used only for debugging purpose by core developers so it may not need to handle Exception. But anyway, I added trace logging as suggested so that other people will not need to worry in the future :) Thanks!", "author": "tkobayas", "createdAt": "2020-06-29T12:38:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTc0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java b/drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java\ndeleted file mode 100644\nindex 37cd6dfbb3..0000000000\n--- a/drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java\n+++ /dev/null\n\n@@ -1,291 +0,0 @@\n-/*\n- * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n-*/\n-\n-package org.drools.core.reteoo;\n-\n-import java.io.PrintWriter;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.IdentityHashMap;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import org.drools.core.common.BaseNode;\n-import org.drools.core.impl.InternalKnowledgeBase;\n-import org.kie.api.KieBase;\n-import org.kie.api.definition.rule.Rule;\n-import org.kie.api.runtime.KieRuntime;\n-import org.kie.api.runtime.KieSession;\n-\n-/**\n- * \n- * Utility class to view Rete models\n- *\n- */\n-public class ReteDumper {\n-\n-    private PrintWriter writer;\n-    private StringBuilder sb;\n-    private Predicate<BaseNode> nodesFilter;\n-\n-    private boolean nodeInfoOnly = false;\n-\n-    public ReteDumper() {\n-        this(node -> true);\n-    }\n-\n-    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n-        this.nodesFilter = nodesFilter;\n-    }\n-\n-    public ReteDumper(String ruleName) {\n-        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n-    }\n-\n-    public PrintWriter getWriter() {\n-        return writer;\n-    }\n-\n-    /**\n-     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n-     * @param writer\n-     */\n-    public void setWriter(PrintWriter writer) {\n-        this.writer = writer;\n-    }\n-\n-    public boolean isNodeInfoOnly() {\n-        return nodeInfoOnly;\n-    }\n-\n-    /**\n-     * If true, dump without partition/mask information. Default value is false\n-     * @param nodeInfoOnly\n-     */\n-    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n-        this.nodeInfoOnly = nodeInfoOnly;\n-    }\n-\n-    public static void dumpRete(KieBase kbase ) {\n-        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public static void dumpRete(KieRuntime session ) {\n-        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static void dumpRete(KieSession session) {\n-        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static void dumpRete(InternalKnowledgeBase kBase) {\n-        new ReteDumper().dump(kBase.getRete());\n-    }\n-\n-    public static void dumpRete(Rete rete) {\n-        new ReteDumper().dump(rete);\n-    }\n-\n-    public void dump(KieBase kbase ) {\n-        dump((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public void dump(KieRuntime session ) {\n-        dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public void dump(KieSession session) {\n-        dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public void dump(InternalKnowledgeBase kBase) {\n-        dump(kBase.getRete());\n-    }\n-\n-    public void dump(Rete rete) {\n-        // Other dump/dumpRete methods eventually call this method\n-        sb = new StringBuilder();\n-        traverseRete(rete, this::dumpNode);\n-        printResults();\n-    }\n-\n-    private void printResults() {\n-        if (writer == null) {\n-            System.out.print(sb.toString());\n-        } else {\n-            // if a writer is given by a caller, the caller is responsible for closing\n-            writer.print(sb.toString());\n-        }\n-    }\n-\n-    public static Set<BaseNode> collectRete(KieBase kbase ) {\n-        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public static Set<BaseNode> collectRete(KieRuntime session ) {\n-        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static Set<BaseNode> collectRete(KieSession session) {\n-        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n-        return new ReteDumper().collect(kBase.getRete());\n-    }\n-\n-    public static Set<BaseNode> collectRete(Rete rete) {\n-        return new ReteDumper().collect(rete);\n-    }\n-\n-    public Set<BaseNode> collect(KieBase kbase ) {\n-        return collect((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public Set<BaseNode> collect(KieRuntime session ) {\n-        return collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public Set<BaseNode> collect(KieSession session) {\n-        return collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n-        return collect(kBase.getRete());\n-    }\n-\n-    public Set<BaseNode> collect(Rete rete) {\n-        Set<BaseNode> nodes = createIdentitySet();\n-        traverseRete(rete, (node, s) -> nodes.add(node));\n-        return nodes;\n-    }\n-\n-    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n-        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n-            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n-        }\n-    }\n-\n-    private <T> Set<T> createIdentitySet() {\n-        return Collections.newSetFromMap(new IdentityHashMap<>());\n-    }\n-\n-    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n-        consumer.accept( node, ident );\n-        if (!visitedNodes.add( node )) {\n-            return;\n-        }\n-        Sink[] sinks = node.getSinks();\n-        if (sinks != null) {\n-            for (Sink sink : sinks) {\n-                if (sink instanceof BaseNode) {\n-                    BaseNode sinkNode = ( BaseNode ) sink;\n-                    if ( nodesFilter.test( sinkNode ) ) {\n-                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private void dumpNode( BaseNode node, String ident ) {\n-        sb.append(ident + formatNode(node));\n-        if (!nodeInfoOnly) {\n-            sb.append(\" on \" + node.getPartitionId());\n-            try {\n-                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);\n-                Object inferreddMask = node.getClass().getMethod(\"getInferredMask\").invoke(node);\n-                sb.append(\" d \"+declaredMask + \" i \" + inferreddMask);\n-            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                // do nothing.\n-            }\n-            try {\n-                Object declaredMask = node.getClass().getMethod(\"getLeftDeclaredMask\").invoke(node);\n-                Object inferreddMask = node.getClass().getMethod(\"getLeftInferredMask\").invoke(node);\n-                sb.append(\" Ld \"+declaredMask + \" Li \" + inferreddMask);\n-            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                // do nothing.\n-            }\n-            try {\n-                Object declaredMask = node.getClass().getMethod(\"getRightDeclaredMask\").invoke(node);\n-                Object inferreddMask = node.getClass().getMethod(\"getRightInferredMask\").invoke(node);\n-                sb.append(\" Rd \"+declaredMask + \" Ri \" + inferreddMask);\n-            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                // do nothing.\n-            }\n-        }\n-        sb.append(\"\\n\");\n-    }\n-\n-    /**\n-     * Format a node to informative String\n-     *\n-     * @param node\n-     * @return formatted String\n-     */\n-    public String formatNode(BaseNode node) {\n-        StringBuilder additionalInfo = new StringBuilder();\n-        if (node instanceof BetaNode) {\n-            BetaNode betaNode = (BetaNode) node;\n-            additionalInfo.append(\"contraints=\");\n-            if (betaNode.getRawConstraints() != null) {\n-                additionalInfo.append(Arrays.toString(betaNode.getConstraints()));\n-            }\n-            if (node instanceof AccumulateNode) {\n-                AccumulateNode accNode = (AccumulateNode) node;\n-                additionalInfo.append(\", resultConstraints=\" + Arrays.toString(accNode.getResultConstraints()));\n-                additionalInfo.append(\", resultBinder=\" + Arrays.toString(accNode.getResultBinder().getConstraints()));\n-            }\n-        } else if (node instanceof FromNode<?>) {\n-            FromNode<?> fromNode = (FromNode<?>) node;\n-            additionalInfo.append(\"result=\" + fromNode.getResultClass().getName());\n-            additionalInfo.append(\", alphaConstraints=\" + Arrays.toString(fromNode.getAlphaConstraints()));\n-            additionalInfo.append(\", betaConstraints=\" + Arrays.toString(fromNode.getBetaConstraints().getConstraints()));\n-        }\n-\n-        if (additionalInfo.length() > 0) {\n-            return node + \" <\" + additionalInfo.toString() + \"> \";\n-        }\n-\n-        return node.toString();\n-    }\n-\n-    public static void dumpAssociatedRulesRete(KieBase kieBase) {\n-        new ReteDumper().dumpAssociatedRules(((InternalKnowledgeBase) kieBase).getRete());\n-    }\n-\n-    /**\n-     * Dump nodes with associated rules. Helps to locate rules from a node in problem\n-     * @param kieBase\n-     */\n-    public void dumpAssociatedRules(KieBase kieBase) {\n-        dumpAssociatedRules(((InternalKnowledgeBase) kieBase).getRete());\n-    }\n-\n-    public void dumpAssociatedRules(Rete rete) {\n-        sb = new StringBuilder();\n-        Set<BaseNode> nodes = collect(rete);\n-        for (BaseNode node : nodes) {\n-            String ruleNames = Arrays.stream(node.getAssociatedRules()).map(Rule::getName)\n-                                     .collect(Collectors.joining(\", \"));\n-            sb.append(node + \" : [\" + ruleNames + \"]\\n\");\n-        }\n-        printResults();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTkxNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446815917", "bodyText": "Same as for previous try catch block.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:10:17Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.drools.core.reteoo;\n+\n+import java.io.PrintWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.core.common.BaseNode;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.kie.api.KieBase;\n+import org.kie.api.definition.rule.Rule;\n+import org.kie.api.runtime.KieRuntime;\n+import org.kie.api.runtime.KieSession;\n+\n+/**\n+ * \n+ * Utility class to view Rete models\n+ *\n+ */\n+public class ReteDumper {\n+\n+    private PrintWriter writer;\n+    private StringBuilder sb;\n+    private Predicate<BaseNode> nodesFilter;\n+\n+    private boolean nodeInfoOnly = false;\n+\n+    public ReteDumper() {\n+        this(node -> true);\n+    }\n+\n+    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n+        this.nodesFilter = nodesFilter;\n+    }\n+\n+    public ReteDumper(String ruleName) {\n+        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n+    }\n+\n+    public PrintWriter getWriter() {\n+        return writer;\n+    }\n+\n+    /**\n+     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n+     * @param writer\n+     */\n+    public void setWriter(PrintWriter writer) {\n+        this.writer = writer;\n+    }\n+\n+    public boolean isNodeInfoOnly() {\n+        return nodeInfoOnly;\n+    }\n+\n+    /**\n+     * If true, dump without partition/mask information. Default value is false\n+     * @param nodeInfoOnly\n+     */\n+    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n+        this.nodeInfoOnly = nodeInfoOnly;\n+    }\n+\n+    public static void dumpRete(KieBase kbase ) {\n+        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static void dumpRete(KieRuntime session ) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(KieSession session) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(InternalKnowledgeBase kBase) {\n+        new ReteDumper().dump(kBase.getRete());\n+    }\n+\n+    public static void dumpRete(Rete rete) {\n+        new ReteDumper().dump(rete);\n+    }\n+\n+    public void dump(KieBase kbase ) {\n+        dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public void dump(KieRuntime session ) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(KieSession session) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(InternalKnowledgeBase kBase) {\n+        dump(kBase.getRete());\n+    }\n+\n+    public void dump(Rete rete) {\n+        // Other dump/dumpRete methods eventually call this method\n+        sb = new StringBuilder();\n+        traverseRete(rete, this::dumpNode);\n+        printResults();\n+    }\n+\n+    private void printResults() {\n+        if (writer == null) {\n+            System.out.print(sb.toString());\n+        } else {\n+            // if a writer is given by a caller, the caller is responsible for closing\n+            writer.print(sb.toString());\n+        }\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieBase kbase ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieRuntime session ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieSession session) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n+        return new ReteDumper().collect(kBase.getRete());\n+    }\n+\n+    public static Set<BaseNode> collectRete(Rete rete) {\n+        return new ReteDumper().collect(rete);\n+    }\n+\n+    public Set<BaseNode> collect(KieBase kbase ) {\n+        return collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public Set<BaseNode> collect(KieRuntime session ) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(KieSession session) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n+        return collect(kBase.getRete());\n+    }\n+\n+    public Set<BaseNode> collect(Rete rete) {\n+        Set<BaseNode> nodes = createIdentitySet();\n+        traverseRete(rete, (node, s) -> nodes.add(node));\n+        return nodes;\n+    }\n+\n+    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n+        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n+            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n+        }\n+    }\n+\n+    private <T> Set<T> createIdentitySet() {\n+        return Collections.newSetFromMap(new IdentityHashMap<>());\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n+        consumer.accept( node, ident );\n+        if (!visitedNodes.add( node )) {\n+            return;\n+        }\n+        Sink[] sinks = node.getSinks();\n+        if (sinks != null) {\n+            for (Sink sink : sinks) {\n+                if (sink instanceof BaseNode) {\n+                    BaseNode sinkNode = ( BaseNode ) sink;\n+                    if ( nodesFilter.test( sinkNode ) ) {\n+                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident ) {\n+        sb.append(ident + formatNode(node));\n+        if (!nodeInfoOnly) {\n+            sb.append(\" on \" + node.getPartitionId());\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);\n+                Object inferreddMask = node.getClass().getMethod(\"getInferredMask\").invoke(node);\n+                sb.append(\" d \"+declaredMask + \" i \" + inferreddMask);\n+            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+                // do nothing.\n+            }\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getLeftDeclaredMask\").invoke(node);\n+                Object inferreddMask = node.getClass().getMethod(\"getLeftInferredMask\").invoke(node);\n+                sb.append(\" Ld \"+declaredMask + \" Li \" + inferreddMask);\n+            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n+                // do nothing.", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkzODAwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446938007", "bodyText": "Added logging. Thanks!", "author": "tkobayas", "createdAt": "2020-06-29T12:38:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNTkxNw=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java b/drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java\ndeleted file mode 100644\nindex 37cd6dfbb3..0000000000\n--- a/drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java\n+++ /dev/null\n\n@@ -1,291 +0,0 @@\n-/*\n- * Copyright 2015 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * \n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n-*/\n-\n-package org.drools.core.reteoo;\n-\n-import java.io.PrintWriter;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.IdentityHashMap;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import org.drools.core.common.BaseNode;\n-import org.drools.core.impl.InternalKnowledgeBase;\n-import org.kie.api.KieBase;\n-import org.kie.api.definition.rule.Rule;\n-import org.kie.api.runtime.KieRuntime;\n-import org.kie.api.runtime.KieSession;\n-\n-/**\n- * \n- * Utility class to view Rete models\n- *\n- */\n-public class ReteDumper {\n-\n-    private PrintWriter writer;\n-    private StringBuilder sb;\n-    private Predicate<BaseNode> nodesFilter;\n-\n-    private boolean nodeInfoOnly = false;\n-\n-    public ReteDumper() {\n-        this(node -> true);\n-    }\n-\n-    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n-        this.nodesFilter = nodesFilter;\n-    }\n-\n-    public ReteDumper(String ruleName) {\n-        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n-    }\n-\n-    public PrintWriter getWriter() {\n-        return writer;\n-    }\n-\n-    /**\n-     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n-     * @param writer\n-     */\n-    public void setWriter(PrintWriter writer) {\n-        this.writer = writer;\n-    }\n-\n-    public boolean isNodeInfoOnly() {\n-        return nodeInfoOnly;\n-    }\n-\n-    /**\n-     * If true, dump without partition/mask information. Default value is false\n-     * @param nodeInfoOnly\n-     */\n-    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n-        this.nodeInfoOnly = nodeInfoOnly;\n-    }\n-\n-    public static void dumpRete(KieBase kbase ) {\n-        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public static void dumpRete(KieRuntime session ) {\n-        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static void dumpRete(KieSession session) {\n-        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static void dumpRete(InternalKnowledgeBase kBase) {\n-        new ReteDumper().dump(kBase.getRete());\n-    }\n-\n-    public static void dumpRete(Rete rete) {\n-        new ReteDumper().dump(rete);\n-    }\n-\n-    public void dump(KieBase kbase ) {\n-        dump((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public void dump(KieRuntime session ) {\n-        dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public void dump(KieSession session) {\n-        dump((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public void dump(InternalKnowledgeBase kBase) {\n-        dump(kBase.getRete());\n-    }\n-\n-    public void dump(Rete rete) {\n-        // Other dump/dumpRete methods eventually call this method\n-        sb = new StringBuilder();\n-        traverseRete(rete, this::dumpNode);\n-        printResults();\n-    }\n-\n-    private void printResults() {\n-        if (writer == null) {\n-            System.out.print(sb.toString());\n-        } else {\n-            // if a writer is given by a caller, the caller is responsible for closing\n-            writer.print(sb.toString());\n-        }\n-    }\n-\n-    public static Set<BaseNode> collectRete(KieBase kbase ) {\n-        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public static Set<BaseNode> collectRete(KieRuntime session ) {\n-        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static Set<BaseNode> collectRete(KieSession session) {\n-        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n-        return new ReteDumper().collect(kBase.getRete());\n-    }\n-\n-    public static Set<BaseNode> collectRete(Rete rete) {\n-        return new ReteDumper().collect(rete);\n-    }\n-\n-    public Set<BaseNode> collect(KieBase kbase ) {\n-        return collect((InternalKnowledgeBase) kbase);\n-    }\n-\n-    public Set<BaseNode> collect(KieRuntime session ) {\n-        return collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public Set<BaseNode> collect(KieSession session) {\n-        return collect((InternalKnowledgeBase)session.getKieBase());\n-    }\n-\n-    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n-        return collect(kBase.getRete());\n-    }\n-\n-    public Set<BaseNode> collect(Rete rete) {\n-        Set<BaseNode> nodes = createIdentitySet();\n-        traverseRete(rete, (node, s) -> nodes.add(node));\n-        return nodes;\n-    }\n-\n-    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n-        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n-            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n-        }\n-    }\n-\n-    private <T> Set<T> createIdentitySet() {\n-        return Collections.newSetFromMap(new IdentityHashMap<>());\n-    }\n-\n-    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n-        consumer.accept( node, ident );\n-        if (!visitedNodes.add( node )) {\n-            return;\n-        }\n-        Sink[] sinks = node.getSinks();\n-        if (sinks != null) {\n-            for (Sink sink : sinks) {\n-                if (sink instanceof BaseNode) {\n-                    BaseNode sinkNode = ( BaseNode ) sink;\n-                    if ( nodesFilter.test( sinkNode ) ) {\n-                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private void dumpNode( BaseNode node, String ident ) {\n-        sb.append(ident + formatNode(node));\n-        if (!nodeInfoOnly) {\n-            sb.append(\" on \" + node.getPartitionId());\n-            try {\n-                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);\n-                Object inferreddMask = node.getClass().getMethod(\"getInferredMask\").invoke(node);\n-                sb.append(\" d \"+declaredMask + \" i \" + inferreddMask);\n-            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                // do nothing.\n-            }\n-            try {\n-                Object declaredMask = node.getClass().getMethod(\"getLeftDeclaredMask\").invoke(node);\n-                Object inferreddMask = node.getClass().getMethod(\"getLeftInferredMask\").invoke(node);\n-                sb.append(\" Ld \"+declaredMask + \" Li \" + inferreddMask);\n-            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                // do nothing.\n-            }\n-            try {\n-                Object declaredMask = node.getClass().getMethod(\"getRightDeclaredMask\").invoke(node);\n-                Object inferreddMask = node.getClass().getMethod(\"getRightInferredMask\").invoke(node);\n-                sb.append(\" Rd \"+declaredMask + \" Ri \" + inferreddMask);\n-            } catch (NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {\n-                // do nothing.\n-            }\n-        }\n-        sb.append(\"\\n\");\n-    }\n-\n-    /**\n-     * Format a node to informative String\n-     *\n-     * @param node\n-     * @return formatted String\n-     */\n-    public String formatNode(BaseNode node) {\n-        StringBuilder additionalInfo = new StringBuilder();\n-        if (node instanceof BetaNode) {\n-            BetaNode betaNode = (BetaNode) node;\n-            additionalInfo.append(\"contraints=\");\n-            if (betaNode.getRawConstraints() != null) {\n-                additionalInfo.append(Arrays.toString(betaNode.getConstraints()));\n-            }\n-            if (node instanceof AccumulateNode) {\n-                AccumulateNode accNode = (AccumulateNode) node;\n-                additionalInfo.append(\", resultConstraints=\" + Arrays.toString(accNode.getResultConstraints()));\n-                additionalInfo.append(\", resultBinder=\" + Arrays.toString(accNode.getResultBinder().getConstraints()));\n-            }\n-        } else if (node instanceof FromNode<?>) {\n-            FromNode<?> fromNode = (FromNode<?>) node;\n-            additionalInfo.append(\"result=\" + fromNode.getResultClass().getName());\n-            additionalInfo.append(\", alphaConstraints=\" + Arrays.toString(fromNode.getAlphaConstraints()));\n-            additionalInfo.append(\", betaConstraints=\" + Arrays.toString(fromNode.getBetaConstraints().getConstraints()));\n-        }\n-\n-        if (additionalInfo.length() > 0) {\n-            return node + \" <\" + additionalInfo.toString() + \"> \";\n-        }\n-\n-        return node.toString();\n-    }\n-\n-    public static void dumpAssociatedRulesRete(KieBase kieBase) {\n-        new ReteDumper().dumpAssociatedRules(((InternalKnowledgeBase) kieBase).getRete());\n-    }\n-\n-    /**\n-     * Dump nodes with associated rules. Helps to locate rules from a node in problem\n-     * @param kieBase\n-     */\n-    public void dumpAssociatedRules(KieBase kieBase) {\n-        dumpAssociatedRules(((InternalKnowledgeBase) kieBase).getRete());\n-    }\n-\n-    public void dumpAssociatedRules(Rete rete) {\n-        sb = new StringBuilder();\n-        Set<BaseNode> nodes = collect(rete);\n-        for (BaseNode node : nodes) {\n-            String ruleNames = Arrays.stream(node.getAssociatedRules()).map(Rule::getName)\n-                                     .collect(Collectors.joining(\", \"));\n-            sb.append(node + \" : [\" + ruleNames + \"]\\n\");\n-        }\n-        printResults();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjI5NA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446816294", "bodyText": "Missing license header.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:11:06Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/builder/BetaNodeConstraintFactory.java", "diffHunk": "@@ -0,0 +1,76 @@\n+package org.drools.core.reteoo.builder;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTYyNA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446925624", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T12:18:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjI5NA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/reteoo/builder/BetaNodeConstraintFactory.java b/drools-core/src/main/java/org/drools/core/reteoo/builder/BetaNodeConstraintFactory.java\ndeleted file mode 100644\nindex 3a985a6c37..0000000000\n--- a/drools-core/src/main/java/org/drools/core/reteoo/builder/BetaNodeConstraintFactory.java\n+++ /dev/null\n\n@@ -1,76 +0,0 @@\n-package org.drools.core.reteoo.builder;\n-\n-import org.drools.core.RuleBaseConfiguration;\n-import org.drools.core.common.DefaultBetaConstraints;\n-import org.drools.core.common.DoubleBetaConstraints;\n-import org.drools.core.common.QuadroupleBetaConstraints;\n-import org.drools.core.common.SingleBetaConstraints;\n-import org.drools.core.common.TripleBetaConstraints;\n-import org.drools.core.common.metric.DefaultBetaConstraintsMetric;\n-import org.drools.core.common.metric.DoubleBetaConstraintsMetric;\n-import org.drools.core.common.metric.QuadroupleBetaConstraintsMetric;\n-import org.drools.core.common.metric.SingleBetaConstraintsMetric;\n-import org.drools.core.common.metric.TripleBetaConstraintsMetric;\n-import org.drools.core.spi.BetaNodeFieldConstraint;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class BetaNodeConstraintFactory {\n-\n-    private static final BetaNodeConstraintFactory INSTANCE = new BetaNodeConstraintFactory();\n-\n-    public static BetaNodeConstraintFactory getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private BetaNodeConstraintFactory() {}\n-\n-    SingleBetaConstraints createSingleBetaConstraints(final BetaNodeFieldConstraint constraint,\n-                                                      final RuleBaseConfiguration conf,\n-                                                      final boolean disableIndex) {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new SingleBetaConstraintsMetric(constraint, conf, disableIndex);\n-        } else {\n-            return new SingleBetaConstraints(constraint, conf, disableIndex);\n-        }\n-    }\n-\n-    DoubleBetaConstraints createDoubleBetaConstraints(final BetaNodeFieldConstraint[] constraints,\n-                                                      final RuleBaseConfiguration conf,\n-                                                      final boolean disableIndexing) {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new DoubleBetaConstraintsMetric(constraints, conf, disableIndexing);\n-        } else {\n-            return new DoubleBetaConstraints(constraints, conf, disableIndexing);\n-        }\n-    }\n-\n-    TripleBetaConstraints createTripleBetaConstraints(final BetaNodeFieldConstraint[] constraints,\n-                                                      final RuleBaseConfiguration conf,\n-                                                      final boolean disableIndexing) {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new TripleBetaConstraintsMetric(constraints, conf, disableIndexing);\n-        } else {\n-            return new TripleBetaConstraints(constraints, conf, disableIndexing);\n-        }\n-    }\n-\n-    QuadroupleBetaConstraints createQuadroupleBetaConstraints(final BetaNodeFieldConstraint[] constraints,\n-                                                              final RuleBaseConfiguration conf,\n-                                                              final boolean disableIndexing) {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new QuadroupleBetaConstraintsMetric(constraints, conf, disableIndexing);\n-        } else {\n-            return new QuadroupleBetaConstraints(constraints, conf, disableIndexing);\n-        }\n-    }\n-\n-    DefaultBetaConstraints createDefaultBetaConstraints(final BetaNodeFieldConstraint[] constraints,\n-                                                        final RuleBaseConfiguration conf,\n-                                                        final boolean disableIndexing) {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new DefaultBetaConstraintsMetric(constraints, conf, disableIndexing);\n-        } else {\n-            return new DefaultBetaConstraints(constraints, conf, disableIndexing);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjc5NQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446816795", "bodyText": "Only for curiosity. Is there any reason for this change? It seems both do the same.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:12:14Z", "path": "drools-core/src/main/java/org/drools/core/rule/EvalCondition.java", "diffHunk": "@@ -153,7 +153,7 @@ public boolean equals(final Object object) {\n             return true;\n         }\n \n-        if ( object == null || object.getClass() != EvalCondition.class ) {\n+        if ( object == null || object.getClass() != this.getClass() ) {", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNzkwMw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446927903", "bodyText": "I wanted to compare with the right class (= if \"this\" is a sub class, e.g. EvalConditionMetric, I need to use \"this.getClass()\").", "author": "tkobayas", "createdAt": "2020-06-29T12:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/rule/EvalCondition.java b/drools-core/src/main/java/org/drools/core/rule/EvalCondition.java\nindex c66442a70b..f4fddf3327 100644\n--- a/drools-core/src/main/java/org/drools/core/rule/EvalCondition.java\n+++ b/drools-core/src/main/java/org/drools/core/rule/EvalCondition.java\n\n@@ -153,7 +153,7 @@ public class EvalCondition extends ConditionalElement\n             return true;\n         }\n \n-        if ( object == null || object.getClass() != this.getClass() ) {\n+        if ( object == null || object.getClass() != EvalCondition.class ) {\n             return false;\n         }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjg5NQ==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446816895", "bodyText": "Missing license header.", "author": "jiripetrlik", "createdAt": "2020-06-29T07:12:29Z", "path": "drools-core/src/main/java/org/drools/core/rule/EvalConditionFactory.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package org.drools.core.rule;", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTcwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446925707", "bodyText": "Thanks! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T12:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNjg5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/rule/EvalConditionFactory.java b/drools-core/src/main/java/org/drools/core/rule/EvalConditionFactory.java\ndeleted file mode 100644\nindex 38d385e5b1..0000000000\n--- a/drools-core/src/main/java/org/drools/core/rule/EvalConditionFactory.java\n+++ /dev/null\n\n@@ -1,23 +0,0 @@\n-package org.drools.core.rule;\n-\n-import org.drools.core.rule.metric.EvalConditionMetric;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class EvalConditionFactory {\n-\n-    private static final EvalConditionFactory INSTANCE = new EvalConditionFactory();\n-\n-    public static EvalConditionFactory getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private EvalConditionFactory() {}\n-\n-    public EvalCondition createEvalCondition(final Declaration[] requiredDeclarations) {\n-        if (PerfLogUtils.getInstance().isEnabled()) {\n-            return new EvalConditionMetric(requiredDeclarations);\n-        } else {\n-            return new EvalCondition(requiredDeclarations);\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNzA0MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446817040", "bodyText": "Any reason for calling super here?", "author": "jiripetrlik", "createdAt": "2020-06-29T07:12:48Z", "path": "drools-core/src/main/java/org/drools/core/rule/metric/EvalConditionMetric.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.drools.core.rule.metric;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.drools.core.WorkingMemory;\n+import org.drools.core.rule.Declaration;\n+import org.drools.core.rule.EvalCondition;\n+import org.drools.core.spi.EvalExpression;\n+import org.drools.core.spi.Tuple;\n+import org.drools.core.util.PerfLogUtils;\n+\n+public class EvalConditionMetric extends EvalCondition {\n+\n+    public EvalConditionMetric() {\n+        super();", "originalCommit": "68c28376da268412a558190d0263896e8152505b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjkyNTg0MA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r446925840", "bodyText": "Thank you for pointing this! Fixed", "author": "tkobayas", "createdAt": "2020-06-29T12:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgxNzA0MA=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/rule/metric/EvalConditionMetric.java b/drools-core/src/main/java/org/drools/core/rule/metric/EvalConditionMetric.java\ndeleted file mode 100644\nindex d0368bb970..0000000000\n--- a/drools-core/src/main/java/org/drools/core/rule/metric/EvalConditionMetric.java\n+++ /dev/null\n\n@@ -1,51 +0,0 @@\n-package org.drools.core.rule.metric;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-\n-import org.drools.core.WorkingMemory;\n-import org.drools.core.rule.Declaration;\n-import org.drools.core.rule.EvalCondition;\n-import org.drools.core.spi.EvalExpression;\n-import org.drools.core.spi.Tuple;\n-import org.drools.core.util.PerfLogUtils;\n-\n-public class EvalConditionMetric extends EvalCondition {\n-\n-    public EvalConditionMetric() {\n-        super();\n-    }\n-\n-    public EvalConditionMetric(final Declaration[] requiredDeclarations) {\n-        super(requiredDeclarations);\n-    }\n-\n-    public EvalConditionMetric(final EvalExpression eval,\n-                               final Declaration[] requiredDeclarations) {\n-\n-        super(eval, requiredDeclarations);\n-    }\n-\n-    @Override\n-    public boolean isAllowed(final Tuple tuple,\n-                             final WorkingMemory workingMemory,\n-                             final Object context) {\n-        PerfLogUtils.getInstance().incrementEvalCount();\n-        return super.isAllowed(tuple, workingMemory, context);\n-    }\n-\n-    @Override\n-    public EvalCondition clone() {\n-        // cannot rely on super.clone() because it enlists an EvalCondition instance to \"cloned\"\n-        final EvalConditionMetric clone = new EvalConditionMetric(this.expression.clone(),\n-                                                                  this.requiredDeclarations.clone());\n-\n-        if (this.getCloned() == Collections.<EvalCondition> emptyList()) {\n-            this.setCloned(new ArrayList<EvalCondition>(1));\n-        }\n-\n-        this.getCloned().add(clone);\n-\n-        return clone;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODIwNw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r450648207", "bodyText": "I believe that having a ThreadLocal here is only necessary if the engine is running in parallel evaluation mode (which is not the default). Probably you could have a single plain NodeStats if parallel evaluation is not enabled.", "author": "mariofusco", "createdAt": "2020-07-07T06:55:40Z", "path": "drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.drools.core.util;\n+\n+import org.drools.core.common.BaseNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class PerfLogUtils {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(PerfLogUtils.class);\n+\n+    public static final String PERF_LOGGER_ENABLED = \"drools.performance.logger.enabled\";\n+    private boolean enabled = Boolean.parseBoolean(System.getProperty(PERF_LOGGER_ENABLED, \"false\"));\n+\n+    public static final String PERF_LOGGER_THRESHOLD = \"drools.performance.logger.threshold\";\n+    private int threshold = Integer.parseInt(System.getProperty(PERF_LOGGER_THRESHOLD, \"500\")); // microseconds\n+\n+    private final ThreadLocal<NodeStats> nodeStats = new ThreadLocal<>();", "originalCommit": "8ecf6a08302c2a59c8003dd34438626cf74fa211", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI5MjkzOA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r451292938", "bodyText": "@mariofusco I used ThreadLocal considering the case where a user executes multiple ksessions concurrently (e.g. in kie-server). But of course, we can limit the use of this feature only for single thread execution (= Raise an error log when PerfLogUtils is concurrently accessed). If you think it's better, I'll change. Please let me know your thought, thanks!", "author": "tkobayas", "createdAt": "2020-07-08T05:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjA4OTA1Nw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r452089057", "bodyText": "As discussed with Mario, we keep ThreadLocal for now", "author": "tkobayas", "createdAt": "2020-07-09T09:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0ODIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "chunk": "diff --git a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\nindex f5ddc756ad..45b3d420fb 100644\n--- a/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n+++ b/drools-core/src/main/java/org/drools/core/util/PerfLogUtils.java\n\n@@ -16,6 +16,8 @@\n \n package org.drools.core.util;\n \n+import java.util.concurrent.atomic.AtomicInteger;\n+\n import org.drools.core.common.BaseNode;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"oid": "b01eddfc9e8034c0fb6b255bc356092071da55a4", "url": "https://github.com/kiegroup/drools/commit/b01eddfc9e8034c0fb6b255bc356092071da55a4", "message": "[BAPL-1259] Add logging for rule performance analysis\n- wip", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "3d8ebd7238423977f098ec41f4e0db3e50a6da7b", "url": "https://github.com/kiegroup/drools/commit/3d8ebd7238423977f098ec41f4e0db3e50a6da7b", "message": "- Encapsulate data in NodeStats", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "a2ef0e4cc6eed8cf4e9aab961beedd962c1f1008", "url": "https://github.com/kiegroup/drools/commit/a2ef0e4cc6eed8cf4e9aab961beedd962c1f1008", "message": "- License", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "985d0d3e24363938f6757565fac2f6cc85a2672d", "url": "https://github.com/kiegroup/drools/commit/985d0d3e24363938f6757565fac2f6cc85a2672d", "message": "- warn log. better calc", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "77b515ceb5e6e862927f050f77a323429c3c7d2e", "url": "https://github.com/kiegroup/drools/commit/77b515ceb5e6e862927f050f77a323429c3c7d2e", "message": "- applied to phreak nodes\n- moved ReteDumper to src", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "3a95c02c40a69663bfefa1b1b2b489ad0210d117", "url": "https://github.com/kiegroup/drools/commit/3a95c02c40a69663bfefa1b1b2b489ad0210d117", "message": "- applied to PhrealEvalNode\n- try/finally", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "cdb3615ca655c02736ec4b86fa2fca6c71e9c20e", "url": "https://github.com/kiegroup/drools/commit/cdb3615ca655c02736ec4b86fa2fca6c71e9c20e", "message": "- Introduced Factory to keep original PhreakNode and Constraints clean. Mertic classes are implemented as sub class", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "219553a7a632dfcb7ac39b79f1d8159be2c78d4a", "url": "https://github.com/kiegroup/drools/commit/219553a7a632dfcb7ac39b79f1d8159be2c78d4a", "message": "- fix equals", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "cedbab8213bb31643acb7b37c82d53f611289cbd", "url": "https://github.com/kiegroup/drools/commit/cedbab8213bb31643acb7b37c82d53f611289cbd", "message": "- revert pom", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "6ee0206f0390d79849ba8095e2a670879f53dc18", "url": "https://github.com/kiegroup/drools/commit/6ee0206f0390d79849ba8095e2a670879f53dc18", "message": "- remove setEnabled", "committedDate": "2020-07-09T03:09:32Z", "type": "commit"}, {"oid": "4970a98b3d5c378d4474daf1139426fa85e4a016", "url": "https://github.com/kiegroup/drools/commit/4970a98b3d5c378d4474daf1139426fa85e4a016", "message": "- fixed code smells", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "02926f0a1fe101ffa7f90b757873e7a3ea8bfc1b", "url": "https://github.com/kiegroup/drools/commit/02926f0a1fe101ffa7f90b757873e7a3ea8bfc1b", "message": "- fixed code smells. Keep \"cloned\" private", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "9c0a70c1129313c8af65e7101dc6831e3faf2012", "url": "https://github.com/kiegroup/drools/commit/9c0a70c1129313c8af65e7101dc6831e3faf2012", "message": "- Fix/Add license\n- Removed unnecessary super()\n- Fixed access modifier", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "4202f96fbed76826d078744dc6d392ee0020d4de", "url": "https://github.com/kiegroup/drools/commit/4202f96fbed76826d078744dc6d392ee0020d4de", "message": "- Add log to ReteDumper", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "7af973cddd7ffb37a5d1d190de806f7e882dea6b", "url": "https://github.com/kiegroup/drools/commit/7af973cddd7ffb37a5d1d190de806f7e882dea6b", "message": "- fixed license", "committedDate": "2020-07-09T03:09:33Z", "type": "commit"}, {"oid": "c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "url": "https://github.com/kiegroup/drools/commit/c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "message": "- moved to drools-metric", "committedDate": "2020-07-09T09:27:51Z", "type": "commit"}, {"oid": "c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "url": "https://github.com/kiegroup/drools/commit/c6cbb56515f09c0a7d76dabb3d2a7786f18dca1d", "message": "- moved to drools-metric", "committedDate": "2020-07-09T09:27:51Z", "type": "forcePushed"}, {"oid": "f1bceab3b02781876e84acabadc9b4970ea2020d", "url": "https://github.com/kiegroup/drools/commit/f1bceab3b02781876e84acabadc9b4970ea2020d", "message": "- osgi bundle", "committedDate": "2020-07-17T02:23:05Z", "type": "commit"}, {"oid": "149b69bf34a48bf19f6c7b39f507052a295c4291", "url": "https://github.com/kiegroup/drools/commit/149b69bf34a48bf19f6c7b39f507052a295c4291", "message": "- fixed code smell", "committedDate": "2020-07-17T02:57:58Z", "type": "commit"}, {"oid": "8c6660fd9a667bf0bc5cb67a505a094cab0664c3", "url": "https://github.com/kiegroup/drools/commit/8c6660fd9a667bf0bc5cb67a505a094cab0664c3", "message": "- Removed OSGi bundle", "committedDate": "2020-07-21T01:31:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1MzUzOA==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r513953538", "bodyText": "@lucamolteni I strongly suggest to look into MethodHandle::invokeExact that disturb much less the security manager while producing less garbage too", "author": "franz1981", "createdAt": "2020-10-29T04:22:13Z", "path": "drools-core/src/main/java/org/drools/core/reteoo/ReteDumper.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+*/\n+\n+package org.drools.core.reteoo;\n+\n+import java.io.PrintWriter;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.core.common.BaseNode;\n+import org.drools.core.impl.InternalKnowledgeBase;\n+import org.kie.api.KieBase;\n+import org.kie.api.definition.rule.Rule;\n+import org.kie.api.runtime.KieRuntime;\n+import org.kie.api.runtime.KieSession;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * \n+ * Utility class to view Rete models\n+ *\n+ */\n+public class ReteDumper {\n+\n+    private static Logger logger = LoggerFactory.getLogger(ReteDumper.class);\n+\n+    private PrintWriter writer;\n+    private StringBuilder sb;\n+    private Predicate<BaseNode> nodesFilter;\n+\n+    private boolean nodeInfoOnly = false;\n+\n+    public ReteDumper() {\n+        this(node -> true);\n+    }\n+\n+    public ReteDumper(Predicate<BaseNode> nodesFilter) {\n+        this.nodesFilter = nodesFilter;\n+    }\n+\n+    public ReteDumper(String ruleName) {\n+        this( node -> Stream.of( node.getAssociatedRules() ).anyMatch( rule -> rule.getName().equals( ruleName ) ) );\n+    }\n+\n+    public PrintWriter getWriter() {\n+        return writer;\n+    }\n+\n+    /**\n+     * Set a writer to which ReteDumper prints results. By default, results will be printed to STDOUT\n+     * @param writer\n+     */\n+    public void setWriter(PrintWriter writer) {\n+        this.writer = writer;\n+    }\n+\n+    public boolean isNodeInfoOnly() {\n+        return nodeInfoOnly;\n+    }\n+\n+    /**\n+     * If true, dump without partition/mask information. Default value is false\n+     * @param nodeInfoOnly\n+     */\n+    public void setNodeInfoOnly(boolean nodeInfoOnly) {\n+        this.nodeInfoOnly = nodeInfoOnly;\n+    }\n+\n+    public static void dumpRete(KieBase kbase ) {\n+        new ReteDumper().dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static void dumpRete(KieRuntime session ) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(KieSession session) {\n+        new ReteDumper().dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static void dumpRete(InternalKnowledgeBase kBase) {\n+        new ReteDumper().dump(kBase.getRete());\n+    }\n+\n+    public static void dumpRete(Rete rete) {\n+        new ReteDumper().dump(rete);\n+    }\n+\n+    public void dump(KieBase kbase ) {\n+        dump((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public void dump(KieRuntime session ) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(KieSession session) {\n+        dump((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public void dump(InternalKnowledgeBase kBase) {\n+        dump(kBase.getRete());\n+    }\n+\n+    public void dump(Rete rete) {\n+        // Other dump/dumpRete methods eventually call this method\n+        sb = new StringBuilder();\n+        traverseRete(rete, this::dumpNode);\n+        printResults();\n+    }\n+\n+    private void printResults() {\n+        if (writer == null) {\n+            System.out.print(sb.toString());\n+        } else {\n+            // if a writer is given by a caller, the caller is responsible for closing\n+            writer.print(sb.toString());\n+        }\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieBase kbase ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieRuntime session ) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(KieSession session) {\n+        return new ReteDumper().collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public static Set<BaseNode> collectRete(InternalKnowledgeBase kBase) {\n+        return new ReteDumper().collect(kBase.getRete());\n+    }\n+\n+    public static Set<BaseNode> collectRete(Rete rete) {\n+        return new ReteDumper().collect(rete);\n+    }\n+\n+    public Set<BaseNode> collect(KieBase kbase ) {\n+        return collect((InternalKnowledgeBase) kbase);\n+    }\n+\n+    public Set<BaseNode> collect(KieRuntime session ) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(KieSession session) {\n+        return collect((InternalKnowledgeBase)session.getKieBase());\n+    }\n+\n+    public Set<BaseNode> collect(InternalKnowledgeBase kBase) {\n+        return collect(kBase.getRete());\n+    }\n+\n+    public Set<BaseNode> collect(Rete rete) {\n+        Set<BaseNode> nodes = createIdentitySet();\n+        traverseRete(rete, (node, s) -> nodes.add(node));\n+        return nodes;\n+    }\n+\n+    public void traverseRete(Rete rete, BiConsumer<BaseNode, String> consumer) {\n+        for (EntryPointNode entryPointNode : rete.getEntryPointNodes().values()) {\n+            dumpNode( entryPointNode, \"\", createIdentitySet(), consumer);\n+        }\n+    }\n+\n+    private <T> Set<T> createIdentitySet() {\n+        return Collections.newSetFromMap(new IdentityHashMap<>());\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident, Set<BaseNode> visitedNodes, BiConsumer<BaseNode, String> consumer ) {\n+        consumer.accept( node, ident );\n+        if (!visitedNodes.add( node )) {\n+            return;\n+        }\n+        Sink[] sinks = node.getSinks();\n+        if (sinks != null) {\n+            for (Sink sink : sinks) {\n+                if (sink instanceof BaseNode) {\n+                    BaseNode sinkNode = ( BaseNode ) sink;\n+                    if ( nodesFilter.test( sinkNode ) ) {\n+                        dumpNode( sinkNode, ident + \"  \", visitedNodes, consumer );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private void dumpNode( BaseNode node, String ident ) {\n+        sb.append(ident + formatNode(node));\n+        if (!nodeInfoOnly) {\n+            sb.append(\" on \" + node.getPartitionId());\n+            try {\n+                Object declaredMask = node.getClass().getMethod(\"getDeclaredMask\").invoke(node);", "originalCommit": "8c6660fd9a667bf0bc5cb67a505a094cab0664c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDA0NzI1Nw==", "url": "https://github.com/kiegroup/drools/pull/2900#discussion_r514047257", "bodyText": "@franz1981 Thank you for the suggestion. I filed https://issues.redhat.com/browse/DROOLS-5772", "author": "tkobayas", "createdAt": "2020-10-29T07:17:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzk1MzUzOA=="}], "type": "inlineReview", "revised_code": null}]}