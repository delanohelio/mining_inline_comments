{"pr_number": 2706, "pr_title": "[DROOLS-4870] Materialize consequences using Drools", "pr_createdAt": "2020-01-07T10:00:23Z", "pr_url": "https://github.com/kiegroup/drools/pull/2706", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMTIxNA==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r363801214", "bodyText": "Let's not use JP types as input for the model compiler, only for output.\nThis is because in the future we'd like to emit JP code at the very end, therefore during the processing we should only use types owned by us.", "author": "lucamolteni", "createdAt": "2020-01-07T15:25:07Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java", "diffHunk": "@@ -114,12 +120,21 @@ private Expression lambdaInstance(ClassOrInterfaceType type) {\n     }\n \n     private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n+        List<VariableDeclarator> bitMaskVariables = new ArrayList<>();", "originalCommit": "ef99c4aa364699c1c17ffa5468ee9f57ab241177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTYyMQ==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364111621", "bodyText": "Fix applied. thanks!", "author": "tkobayas", "createdAt": "2020-01-08T08:30:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMTIxNA=="}], "type": "inlineReview", "revised_code": {"commit": "740f3fb479195c984023013cca022e88946c2a42", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\nindex 410db6591a..6c8382e201 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\n\n@@ -119,22 +124,47 @@ public class ExecModelLambdaPostProcessor {\n         return new FieldAccessExpr(new NameExpr(type.asString()), \"INSTANCE\");\n     }\n \n-    private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n-        List<VariableDeclarator> bitMaskVariables = new ArrayList<>();\n-        if (lambdaExtractor.get() instanceof MaterializedLambdaConsequence) {\n-            methodCallExpr.findAncestor(MethodDeclaration.class).ifPresent(node -> {\n-                bitMaskVariables.addAll(node.findAll(VariableDeclarator.class).stream()\n-                                            .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n-                                            .collect(Collectors.toList()));\n-            });\n-        }\n+    private List<MaterializedLambda.BitMaskVariable> findBitMaskFields(MethodCallExpr methodCallExpr) {\n+        List<MaterializedLambda.BitMaskVariable> bitMaskVariables = new ArrayList<>();\n+        methodCallExpr.findAncestor(MethodDeclaration.class).ifPresent(node -> {\n+\n+            List<MaterializedLambda.BitMaskVariable> collect =\n+                    node.findAll(VariableDeclarator.class)\n+                            .stream()\n+                            .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n+                            .flatMap(vd -> {\n+                                ArrayList<AssignExpr> result = new ArrayList<>();\n+                                vd.findAncestor(AssignExpr.class)\n+                                        .ifPresent(result::add);\n+                                return result.stream();\n+                            })\n+                            .map(ae -> {\n+                                String maskName = ae.getTarget().asVariableDeclarationExpr().getVariables().iterator().next().getNameAsString();\n+                                MethodCallExpr maskInit = ae.getValue().asMethodCallExpr();\n+                                if(maskInit.getArguments().isEmpty()) {\n+                                    return new MaterializedLambda.AllSetButLastBitMask(maskName);\n+                                } else {\n+                                    NodeList<Expression> arguments = maskInit.getArguments();\n+                                    String domainClassMetadata = arguments.get(0).toString();\n+                                    List<String> fields = arguments.subList(1, arguments.size()).stream().map(Expression::toString).collect(Collectors.toList());\n+                                    return new MaterializedLambda.BitMaskVariableWithFields(domainClassMetadata, fields, maskName);\n+                                }\n+                            })\n+                            .collect(Collectors.toList());\n+\n+            bitMaskVariables.addAll(collect);\n+        });\n+        return bitMaskVariables;\n+    }\n+\n \n+    private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n         methodCallExpr.getArguments().forEach(a -> {\n             if (a.isLambdaExpr()) {\n                 LambdaExpr lambdaExpr = a.asLambdaExpr();\n \n                 try {\n-                    CreatedClass aClass = lambdaExtractor.get().create(lambdaExpr.toString(), imports, staticImports, bitMaskVariables);\n+                    CreatedClass aClass = lambdaExtractor.get().create(lambdaExpr.toString(), imports, staticImports);\n                     lambdaClasses.put(aClass.getClassNameWithPackage(), aClass);\n \n                     ClassOrInterfaceType type = StaticJavaParser.parseClassOrInterfaceType(aClass.getClassNameWithPackage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMTQ1NA==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r363801454", "bodyText": "I moved this parsing outside in the patch to avoid the instanceof", "author": "lucamolteni", "createdAt": "2020-01-07T15:25:32Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java", "diffHunk": "@@ -114,12 +120,21 @@ private Expression lambdaInstance(ClassOrInterfaceType type) {\n     }\n \n     private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n+        List<VariableDeclarator> bitMaskVariables = new ArrayList<>();\n+        if (lambdaExtractor.get() instanceof MaterializedLambdaConsequence) {", "originalCommit": "ef99c4aa364699c1c17ffa5468ee9f57ab241177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTgxOA==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364111818", "bodyText": "Fix applied. thanks!", "author": "tkobayas", "createdAt": "2020-01-08T08:31:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMTQ1NA=="}], "type": "inlineReview", "revised_code": {"commit": "740f3fb479195c984023013cca022e88946c2a42", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\nindex 410db6591a..6c8382e201 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\n\n@@ -119,22 +124,47 @@ public class ExecModelLambdaPostProcessor {\n         return new FieldAccessExpr(new NameExpr(type.asString()), \"INSTANCE\");\n     }\n \n-    private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n-        List<VariableDeclarator> bitMaskVariables = new ArrayList<>();\n-        if (lambdaExtractor.get() instanceof MaterializedLambdaConsequence) {\n-            methodCallExpr.findAncestor(MethodDeclaration.class).ifPresent(node -> {\n-                bitMaskVariables.addAll(node.findAll(VariableDeclarator.class).stream()\n-                                            .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n-                                            .collect(Collectors.toList()));\n-            });\n-        }\n+    private List<MaterializedLambda.BitMaskVariable> findBitMaskFields(MethodCallExpr methodCallExpr) {\n+        List<MaterializedLambda.BitMaskVariable> bitMaskVariables = new ArrayList<>();\n+        methodCallExpr.findAncestor(MethodDeclaration.class).ifPresent(node -> {\n+\n+            List<MaterializedLambda.BitMaskVariable> collect =\n+                    node.findAll(VariableDeclarator.class)\n+                            .stream()\n+                            .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n+                            .flatMap(vd -> {\n+                                ArrayList<AssignExpr> result = new ArrayList<>();\n+                                vd.findAncestor(AssignExpr.class)\n+                                        .ifPresent(result::add);\n+                                return result.stream();\n+                            })\n+                            .map(ae -> {\n+                                String maskName = ae.getTarget().asVariableDeclarationExpr().getVariables().iterator().next().getNameAsString();\n+                                MethodCallExpr maskInit = ae.getValue().asMethodCallExpr();\n+                                if(maskInit.getArguments().isEmpty()) {\n+                                    return new MaterializedLambda.AllSetButLastBitMask(maskName);\n+                                } else {\n+                                    NodeList<Expression> arguments = maskInit.getArguments();\n+                                    String domainClassMetadata = arguments.get(0).toString();\n+                                    List<String> fields = arguments.subList(1, arguments.size()).stream().map(Expression::toString).collect(Collectors.toList());\n+                                    return new MaterializedLambda.BitMaskVariableWithFields(domainClassMetadata, fields, maskName);\n+                                }\n+                            })\n+                            .collect(Collectors.toList());\n+\n+            bitMaskVariables.addAll(collect);\n+        });\n+        return bitMaskVariables;\n+    }\n+\n \n+    private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n         methodCallExpr.getArguments().forEach(a -> {\n             if (a.isLambdaExpr()) {\n                 LambdaExpr lambdaExpr = a.asLambdaExpr();\n \n                 try {\n-                    CreatedClass aClass = lambdaExtractor.get().create(lambdaExpr.toString(), imports, staticImports, bitMaskVariables);\n+                    CreatedClass aClass = lambdaExtractor.get().create(lambdaExpr.toString(), imports, staticImports);\n                     lambdaClasses.put(aClass.getClassNameWithPackage(), aClass);\n \n                     ClassOrInterfaceType type = StaticJavaParser.parseClassOrInterfaceType(aClass.getClassNameWithPackage());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMTY3Mg==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r363801672", "bodyText": "Superclass shouldn't be aware of implementation details of Consequences", "author": "lucamolteni", "createdAt": "2020-01-07T15:25:57Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java", "diffHunk": "@@ -38,6 +39,7 @@\n abstract class MaterializedLambda {\n \n     final List<LambdaParameter> lambdaParameters = new ArrayList<>();\n+    final List<VariableDeclarator> bitMaskVariables = new ArrayList<>();", "originalCommit": "ef99c4aa364699c1c17ffa5468ee9f57ab241177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTg2Ng==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364111866", "bodyText": "Fix applied. thanks!", "author": "tkobayas", "createdAt": "2020-01-08T08:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMTY3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "740f3fb479195c984023013cca022e88946c2a42", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java\nindex b488176841..f0f2e92114 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java\n\n@@ -18,28 +18,34 @@\n package org.drools.modelcompiler.util.lambdareplace;\n \n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.List;\n import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n import com.github.javaparser.StaticJavaParser;\n import com.github.javaparser.ast.CompilationUnit;\n+import com.github.javaparser.ast.Modifier;\n import com.github.javaparser.ast.NodeList;\n import com.github.javaparser.ast.body.EnumConstantDeclaration;\n import com.github.javaparser.ast.body.EnumDeclaration;\n import com.github.javaparser.ast.body.MethodDeclaration;\n import com.github.javaparser.ast.body.Parameter;\n-import com.github.javaparser.ast.body.VariableDeclarator;\n import com.github.javaparser.ast.expr.Expression;\n import com.github.javaparser.ast.expr.LambdaExpr;\n+import com.github.javaparser.ast.expr.MethodCallExpr;\n+import com.github.javaparser.ast.expr.NameExpr;\n+import com.github.javaparser.ast.nodeTypes.NodeWithMembers;\n import com.github.javaparser.ast.type.ClassOrInterfaceType;\n import com.github.javaparser.ast.type.Type;\n import com.github.javaparser.ast.type.UnknownType;\n \n+import static com.github.javaparser.StaticJavaParser.parseType;\n+\n abstract class MaterializedLambda {\n \n     final List<LambdaParameter> lambdaParameters = new ArrayList<>();\n-    final List<VariableDeclarator> bitMaskVariables = new ArrayList<>();\n \n     protected final String packageName;\n     protected String className;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMjEyMQ==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r363802121", "bodyText": "In the refactor patch I changed a logic reconstructing the original initialization method here, to avoid depending on JP data on input.", "author": "lucamolteni", "createdAt": "2020-01-07T15:26:45Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequence.java", "diffHunk": "@@ -65,6 +65,23 @@ void createMethodDeclaration(EnumDeclaration classDeclaration) {\n         }\n     }\n \n+    @Override\n+    protected EnumDeclaration create(CompilationUnit compilationUnit) {\n+        EnumDeclaration lambdaClass = super.create(compilationUnit);\n+\n+        boolean hasDroolsParameter = lambdaParameters.stream().anyMatch(this::isDroolsParameter);", "originalCommit": "ef99c4aa364699c1c17ffa5468ee9f57ab241177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMjA3MQ==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364112071", "bodyText": "Fix applied. thanks!", "author": "tkobayas", "createdAt": "2020-01-08T08:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMjEyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "740f3fb479195c984023013cca022e88946c2a42", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequence.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequence.java\nindex e626e00e67..84189404e9 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequence.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequence.java\n\n@@ -71,13 +72,7 @@ public class MaterializedLambdaConsequence extends MaterializedLambda {\n \n         boolean hasDroolsParameter = lambdaParameters.stream().anyMatch(this::isDroolsParameter);\n         if (hasDroolsParameter) {\n-            bitMaskVariables.stream().forEach(vd -> {\n-                Optional<ExpressionStmt> expressionStmt = vd.findAncestor(ExpressionStmt.class);\n-                MethodCallExpr methodCallExpr = expressionStmt.flatMap(a -> a.findFirst(MethodCallExpr.class))\n-                                                          .orElseThrow(() -> new IllegalStateException(\"MethodCallExpr is not found\"));\n-                lambdaClass.addFieldWithInitializer(vd.getType(), vd.getName().asString(), methodCallExpr,\n-                                                    Modifier.Keyword.PRIVATE, Modifier.Keyword.FINAL);\n-            });\n+            bitMaskVariables.forEach(vd -> vd.generateBitMaskField(lambdaClass));\n         }\n         return lambdaClass;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMjYwMA==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r363802600", "bodyText": "This test has too much Java code in text to be readable.\nIn the patch I modified the signature of the create method so that it can be tested in an easier way. Please take a look at it", "author": "lucamolteni", "createdAt": "2020-01-07T15:27:41Z", "path": "drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequenceTest.java", "diffHunk": "@@ -32,4 +38,188 @@ public void createConsequence() {\n         assertThat(aClass.getCompilationUnitAsString(), equalToIgnoringWhiteSpace(expectedResult));\n \n     }\n+\n+    @Test\n+    public void createConsequenceWithDrools() {\n+        String originalJavaSource = \"package defaultpkg;\\n\" +\n+                \"\\n\" +", "originalCommit": "ef99c4aa364699c1c17ffa5468ee9f57ab241177", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTkyMw==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364111923", "bodyText": "Fix applied. thanks!", "author": "tkobayas", "createdAt": "2020-01-08T08:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzgwMjYwMA=="}], "type": "inlineReview", "revised_code": {"commit": "740f3fb479195c984023013cca022e88946c2a42", "chunk": "diff --git a/drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequenceTest.java b/drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequenceTest.java\nindex 0cd0c834fc..d37523fa8c 100644\n--- a/drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequenceTest.java\n+++ b/drools-model/drools-model-compiler/src/test/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambdaConsequenceTest.java\n\n@@ -41,58 +37,12 @@ public class MaterializedLambdaConsequenceTest {\n \n     @Test\n     public void createConsequenceWithDrools() {\n-        String originalJavaSource = \"package defaultpkg;\\n\" +\n-                \"\\n\" +\n-                \"import java.util.*;\\n\" +\n-                \"import org.drools.model.*;\\n\" +\n-                \"import org.drools.modelcompiler.dsl.pattern.D;\\n\" +\n-                \"import org.drools.model.Index.ConstraintType;\\n\" +\n-                \"import java.time.*;\\n\" +\n-                \"import java.time.format.*;\\n\" +\n-                \"import java.text.*;\\n\" +\n-                \"import org.drools.core.util.*;\\n\" +\n-                \"import org.drools.modelcompiler.domain.Person;\\n\" +\n-                \"import static defaultpkg.RulesA3B8DE4BEBF13D94572A10FD20BBE729.*;\\n\" +\n-                \"\\n\" +\n-                \"public class RulesA3B8DE4BEBF13D94572A10FD20BBE729RuleMethods0 {\\n\" +\n-                \"\\n\" +\n-                \"    /**\\n\" +\n-                \"     * Rule name: R\\n\" +\n-                \"     */\\n\" +\n-                \"    public static org.drools.model.Rule rule_R() {\\n\" +\n-                \"        final org.drools.model.Variable<org.drools.modelcompiler.domain.Person> var_$p = D.declarationOf(org.drools.modelcompiler.domain.Person.class,\\n\" +\n-                \"                            DomainClassesMetadataA3B8DE4BEBF13D94572A10FD20BBE729.org_drools_modelcompiler_domain_Person_Metadata_INSTANCE,\\n\" +\n-                \"                                        \\\"$p\\\");\\n\" +\n-                \"        final org.drools.model.BitMask mask_$p = org.drools.model.BitMask.getPatternMask(\" +\n-                \"                             DomainClassesMetadataA3B8DE4BEBF13D94572A10FD20BBE729.org_drools_modelcompiler_domain_Person_Metadata_INSTANCE,\\n\" +\n-                \"                                        \\\"age\\\");\\n\" +\n-                \"        org.drools.model.Rule rule = D.rule(\\\"R\\\").build(D.pattern(var_$p).expr(\\\"593440B7603CA900F1A34F18497AB0EA\\\",\\n\" +\n-                \"                            (org.drools.modelcompiler.domain.Person _this) -> org.drools.modelcompiler.util.EvaluationUtil.areNullSafeEquals(_this.getName(),\\n\" +\n-                \"                                                                                                                                            \\\"Mario\\\"),\\n\" +\n-                \"                                        D.alphaIndexedBy(java.lang.String.class,\\n\" +\n-                \"                                        org.drools.model.Index.ConstraintType.EQUAL,\\n\" +\n-                \"                                        DomainClassesMetadataA3B8DE4BEBF13D94572A10FD20BBE729.org_drools_modelcompiler_domain_Person_Metadata_INSTANCE.getPropertyIndex(\\\"name\\\"),\\n\" +\n-                \"                                        (org.drools.modelcompiler.domain.Person _this) -> _this.getName(),\\n\" +\n-                \"                                             \\\"Mario\\\"),\\n\" +\n-                \"                                        D.reactOn(\\\"name\\\")),\\n\" +\n-                \"                                        D.on(var_$p).execute((org.drools.model.Drools drools, org.drools.modelcompiler.domain.Person $p) -> {\\n\" +\n-                \"                                                           {\\n\" +\n-                \"                                                               ($p).setAge($p.getAge() + 1);\\n\" +\n-                \"                                                               drools.update($p,\\n\" +\n-                \"                                                                             mask_$p);\\n\" +\n-                \"                                                           }\\n\" +\n-                \"                                        }));\\n\" +\n-                \"        return rule;\\n\" +\n-                \"    }\\n\" +\n-                \"}\";\n-\n-        CompilationUnit compilationUnit = StaticJavaParser.parse(originalJavaSource);\n-        List<VariableDeclarator> bitMaskVariables = compilationUnit.findAll(VariableDeclarator.class).stream()\n-                       .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n-                       .collect(Collectors.toList());\n+        ArrayList<String> fields = new ArrayList<>();\n+        fields.add(\"\\\"age\\\"\");\n+        MaterializedLambda.BitMaskVariable bitMaskVariable = new MaterializedLambda.BitMaskVariableWithFields(\"DomainClassesMetadataA3B8DE4BEBF13D94572A10FD20BBE729.org_drools_modelcompiler_domain_Person_Metadata_INSTANCE\", fields, \"mask_$p\");\n \n-        CreatedClass aClass = new MaterializedLambdaConsequence(\"defaultpkg\", \"defaultpkg.RulesA3B8DE4BEBF13D94572A10FD20BBE729\")\n-                .create(\"(org.drools.model.Drools drools, org.drools.modelcompiler.domain.Person $p) -> {{($p).setAge($p.getAge() + 1); drools.update($p, mask_$p);}}\", new ArrayList<>(), new ArrayList<>(), bitMaskVariables);\n+        CreatedClass aClass = new MaterializedLambdaConsequence(\"defaultpkg\", \"defaultpkg.RulesA3B8DE4BEBF13D94572A10FD20BBE729\", Collections.singletonList(bitMaskVariable))\n+                .create(\"(org.drools.model.Drools drools, org.drools.modelcompiler.domain.Person $p) -> {{($p).setAge($p.getAge() + 1); drools.update($p, mask_$p);}}\", new ArrayList<>(), new ArrayList<>());\n \n         //language=JAVA\n         String expectedResult = \"\" +\n"}}, {"oid": "740f3fb479195c984023013cca022e88946c2a42", "url": "https://github.com/kiegroup/drools/commit/740f3fb479195c984023013cca022e88946c2a42", "message": "[DROOLS-4870] Materialize consequences using Drools", "committedDate": "2020-01-08T08:17:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDEwOTI2MA==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364109260", "bodyText": "Originally, it picks only one field but BitMask may take multiple fields so I changed it to a List.", "author": "tkobayas", "createdAt": "2020-01-08T08:24:13Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java", "diffHunk": "@@ -113,6 +124,40 @@ private Expression lambdaInstance(ClassOrInterfaceType type) {\n         return new FieldAccessExpr(new NameExpr(type.asString()), \"INSTANCE\");\n     }\n \n+    private List<MaterializedLambda.BitMaskVariable> findBitMaskFields(MethodCallExpr methodCallExpr) {\n+        List<MaterializedLambda.BitMaskVariable> bitMaskVariables = new ArrayList<>();\n+        methodCallExpr.findAncestor(MethodDeclaration.class).ifPresent(node -> {\n+\n+            List<MaterializedLambda.BitMaskVariable> collect =\n+                    node.findAll(VariableDeclarator.class)\n+                            .stream()\n+                            .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n+                            .flatMap(vd -> {\n+                                ArrayList<AssignExpr> result = new ArrayList<>();\n+                                vd.findAncestor(AssignExpr.class)\n+                                        .ifPresent(result::add);\n+                                return result.stream();\n+                            })\n+                            .map(ae -> {\n+                                String maskName = ae.getTarget().asVariableDeclarationExpr().getVariables().iterator().next().getNameAsString();\n+                                MethodCallExpr maskInit = ae.getValue().asMethodCallExpr();\n+                                if(maskInit.getArguments().isEmpty()) {\n+                                    return new MaterializedLambda.AllSetButLastBitMask(maskName);\n+                                } else {\n+                                    NodeList<Expression> arguments = maskInit.getArguments();\n+                                    String domainClassMetadata = arguments.get(0).toString();\n+                                    List<String> fields = arguments.subList(1, arguments.size()).stream().map(Expression::toString).collect(Collectors.toList());", "originalCommit": "740f3fb479195c984023013cca022e88946c2a42", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2bda482029f733fe395a4a436b3d26b92d128519", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\nindex 6c8382e201..1cb5062f70 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/ExecModelLambdaPostProcessor.java\n\n@@ -125,38 +125,38 @@ public class ExecModelLambdaPostProcessor {\n     }\n \n     private List<MaterializedLambda.BitMaskVariable> findBitMaskFields(MethodCallExpr methodCallExpr) {\n-        List<MaterializedLambda.BitMaskVariable> bitMaskVariables = new ArrayList<>();\n-        methodCallExpr.findAncestor(MethodDeclaration.class).ifPresent(node -> {\n-\n-            List<MaterializedLambda.BitMaskVariable> collect =\n-                    node.findAll(VariableDeclarator.class)\n-                            .stream()\n-                            .filter(vd -> vd.getType().asString().equals(BitMask.class.getCanonicalName()))\n-                            .flatMap(vd -> {\n-                                ArrayList<AssignExpr> result = new ArrayList<>();\n-                                vd.findAncestor(AssignExpr.class)\n-                                        .ifPresent(result::add);\n-                                return result.stream();\n-                            })\n-                            .map(ae -> {\n-                                String maskName = ae.getTarget().asVariableDeclarationExpr().getVariables().iterator().next().getNameAsString();\n-                                MethodCallExpr maskInit = ae.getValue().asMethodCallExpr();\n-                                if(maskInit.getArguments().isEmpty()) {\n-                                    return new MaterializedLambda.AllSetButLastBitMask(maskName);\n-                                } else {\n-                                    NodeList<Expression> arguments = maskInit.getArguments();\n-                                    String domainClassMetadata = arguments.get(0).toString();\n-                                    List<String> fields = arguments.subList(1, arguments.size()).stream().map(Expression::toString).collect(Collectors.toList());\n-                                    return new MaterializedLambda.BitMaskVariableWithFields(domainClassMetadata, fields, maskName);\n-                                }\n-                            })\n-                            .collect(Collectors.toList());\n-\n-            bitMaskVariables.addAll(collect);\n-        });\n-        return bitMaskVariables;\n+        return optionalToStream(methodCallExpr.findAncestor(MethodDeclaration.class))\n+                .flatMap(node -> node.findAll(VariableDeclarator.class).stream())\n+                .filter(this::isBitMaskType)\n+                .flatMap(this::findAssignExpr)\n+                .map(this::toMaterializedLambdaFactory)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private boolean isBitMaskType(VariableDeclarator vd) {\n+        return vd.getType().asString().equals(BitMask.class.getCanonicalName());\n     }\n \n+    private MaterializedLambda.BitMaskVariable toMaterializedLambdaFactory(AssignExpr ae) {\n+        String maskName = ae.getTarget().asVariableDeclarationExpr().getVariables().iterator().next().getNameAsString();\n+        MethodCallExpr maskInit = ae.getValue().asMethodCallExpr();\n+        if (maskInit.getArguments().isEmpty()) {\n+            return new MaterializedLambda.AllSetButLastBitMask(maskName);\n+        } else {\n+            NodeList<Expression> arguments = maskInit.getArguments();\n+            String domainClassMetadata = arguments.get(0).toString();\n+            List<String> fields = arguments.subList(1, arguments.size()).stream().map(Expression::toString).collect(Collectors.toList());\n+            return new MaterializedLambda.BitMaskVariableWithFields(domainClassMetadata, fields, maskName);\n+        }\n+    }\n+\n+    private Stream<? extends AssignExpr> findAssignExpr(VariableDeclarator vd) {\n+        return optionalToStream(vd.findAncestor(AssignExpr.class));\n+    }\n+\n+    private <T> Stream<T> optionalToStream(Optional<T> opt) {\n+        return opt.map(Stream::of).orElse(Stream.empty());\n+    }\n \n     private void extractLambdaFromMethodCall(MethodCallExpr methodCallExpr, Supplier<MaterializedLambda> lambdaExtractor) {\n         methodCallExpr.getArguments().forEach(a -> {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTAwNw==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364111007", "bodyText": "Originally, the argument NodeWithMembers was not parameterized so i see compiler warns. It's fine to have <EnumDeclaration> here?", "author": "tkobayas", "createdAt": "2020-01-08T08:29:08Z", "path": "drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java", "diffHunk": "@@ -146,4 +154,53 @@ private EnumDeclaration create(CompilationUnit compilationUnit) {\n             this.type = type;\n         }\n     }\n+\n+    interface BitMaskVariable {\n+\n+        void generateBitMaskField(NodeWithMembers<EnumDeclaration> clazz);", "originalCommit": "740f3fb479195c984023013cca022e88946c2a42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExOTMwOQ==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364119309", "bodyText": "I also think it's better to remove the generic type argument", "author": "lucamolteni", "createdAt": "2020-01-08T08:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTAwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDEzOTAzNA==", "url": "https://github.com/kiegroup/drools/pull/2706#discussion_r364139034", "bodyText": "Talked with Luca and confirmed that NodeWithMembers<EnumDeclaration> is better.", "author": "tkobayas", "createdAt": "2020-01-08T09:37:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDExMTAwNw=="}], "type": "inlineReview", "revised_code": {"commit": "108e80ac13bb0d746fc8d49d29c0ef4158b116c2", "chunk": "diff --git a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java\nindex f0f2e92114..99ca68de57 100644\n--- a/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java\n+++ b/drools-model/drools-model-compiler/src/main/java/org/drools/modelcompiler/util/lambdareplace/MaterializedLambda.java\n\n@@ -198,7 +196,7 @@ abstract class MaterializedLambda {\n \n             NodeList<Expression> args = new NodeList<>();\n             args.add(new NameExpr(domainClassMetadata));\n-            args.addAll(fields.stream().map(f -> new NameExpr(f)).collect(Collectors.toList()));\n+            args.addAll(fields.stream().map(NameExpr::new).collect(Collectors.toList()));\n             MethodCallExpr methodCallExpr = new MethodCallExpr(new NameExpr(bitMaskString), \"getPatternMask\", args);\n             clazz.addFieldWithInitializer(bitMaskType, maskName, methodCallExpr, Modifier.Keyword.PRIVATE, Modifier.Keyword.FINAL);\n         }\n"}}, {"oid": "108e80ac13bb0d746fc8d49d29c0ef4158b116c2", "url": "https://github.com/kiegroup/drools/commit/108e80ac13bb0d746fc8d49d29c0ef4158b116c2", "message": "[DROOLS-4870] Materialize consequences using Drools", "committedDate": "2020-01-08T09:34:05Z", "type": "forcePushed"}, {"oid": "2bda482029f733fe395a4a436b3d26b92d128519", "url": "https://github.com/kiegroup/drools/commit/2bda482029f733fe395a4a436b3d26b92d128519", "message": "[DROOLS-4870] Materialize consequences using Drools", "committedDate": "2020-01-09T04:21:03Z", "type": "forcePushed"}, {"oid": "d4d959b29c611d7e8aa338a667c2d55af13fb5f3", "url": "https://github.com/kiegroup/drools/commit/d4d959b29c611d7e8aa338a667c2d55af13fb5f3", "message": "[DROOLS-4870] Materialize consequences using Drools", "committedDate": "2020-02-05T02:56:11Z", "type": "forcePushed"}, {"oid": "474b460a94c313352fe2508f2550f3221626f7d6", "url": "https://github.com/kiegroup/drools/commit/474b460a94c313352fe2508f2550f3221626f7d6", "message": "[DROOLS-4870] Materialize consequences using Drools", "committedDate": "2020-02-06T09:53:08Z", "type": "commit"}, {"oid": "474b460a94c313352fe2508f2550f3221626f7d6", "url": "https://github.com/kiegroup/drools/commit/474b460a94c313352fe2508f2550f3221626f7d6", "message": "[DROOLS-4870] Materialize consequences using Drools", "committedDate": "2020-02-06T09:53:08Z", "type": "forcePushed"}]}