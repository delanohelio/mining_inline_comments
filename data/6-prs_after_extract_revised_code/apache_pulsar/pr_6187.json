{"pr_number": 6187, "pr_title": "[Issue 5904]Support `unload` all partitions of a partitioned topic", "pr_createdAt": "2020-02-03T03:11:55Z", "pr_url": "https://github.com/apache/pulsar/pull/6187", "timeline": [{"oid": "98dfd5d3348a1d26e10716052209157ec0d8db7e", "url": "https://github.com/apache/pulsar/commit/98dfd5d3348a1d26e10716052209157ec0d8db7e", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-03T03:07:19Z", "type": "commit"}, {"oid": "c690c4773efa6b07323e73c3b858849901cd3c97", "url": "https://github.com/apache/pulsar/commit/c690c4773efa6b07323e73c3b858849901cd3c97", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-03T05:52:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNDczOQ==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r373914739", "bodyText": "Are these codes to be deleted?", "author": "codelipenghui", "createdAt": "2020-02-03T04:04:30Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -655,12 +655,65 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n         });\n     }\n \n-    protected void internalUnloadTopic(boolean authoritative) {\n+//    protected void internalUnloadTopic(boolean authoritative) {\n+//        log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n+//        if (topicName.isGlobal()) {\n+//            validateGlobalNamespaceOwnership(namespaceName);\n+//        }\n+//        unloadTopic(topicName, authoritative);\n+//    }", "originalCommit": "98dfd5d3348a1d26e10716052209157ec0d8db7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0OTYwOQ==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r374049609", "bodyText": "Yes, I will fix it.", "author": "ltamber", "createdAt": "2020-02-03T11:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxNDczOQ=="}], "type": "inlineReview", "revised_code": {"commit": "c690c4773efa6b07323e73c3b858849901cd3c97", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex 0174b6057cf..0b6e80f758c 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -706,7 +706,7 @@ public class PersistentTopicsBase extends AdminResource {\n \n             Topic topic = getTopicReference(topicName);\n             try {\n-                topic.close().get();\n+                topic.close(false).get();\n                 asyncResponse.resume(Response.noContent().build());\n                 log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n             } catch (Exception e) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwNzE0NQ==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r374007145", "bodyText": "validateAdminAccessForTenant or lower validate maybe better?", "author": "jiazhai", "createdAt": "2020-02-03T09:51:00Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -655,12 +655,65 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n         });\n     }\n \n-    protected void internalUnloadTopic(boolean authoritative) {\n+//    protected void internalUnloadTopic(boolean authoritative) {\n+//        log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n+//        if (topicName.isGlobal()) {\n+//            validateGlobalNamespaceOwnership(namespaceName);\n+//        }\n+//        unloadTopic(topicName, authoritative);\n+//    }\n+\n+    protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authoritative) {\n         log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        unloadTopic(topicName, authoritative);\n+\n+        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+        if (partitionMetadata.partitions > 0) {\n+            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                TopicName topicNamePartition = topicName.getPartition(i);\n+                try {\n+                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                } catch (Exception e) {\n+                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+            }\n+\n+            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                if (exception != null) {\n+                    Throwable t = exception.getCause();\n+                    if (t instanceof NotFoundException) {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                        return null;\n+                    } else {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                        asyncResponse.resume(new RestException(exception));\n+                        return null;\n+                    }\n+                }\n+\n+                asyncResponse.resume(Response.noContent().build());\n+                return null;\n+            });\n+        } else {\n+            validateSuperUserAccess();", "originalCommit": "c690c4773efa6b07323e73c3b858849901cd3c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0OTc5Mg==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r374049792", "bodyText": "ok", "author": "ltamber", "createdAt": "2020-02-03T11:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAwNzE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "416b0a01ef63659a5349737fbbbb39c902d2f3a6", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex 0b6e80f758c..2337ff19621 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -655,14 +655,6 @@ public class PersistentTopicsBase extends AdminResource {\n         });\n     }\n \n-//    protected void internalUnloadTopic(boolean authoritative) {\n-//        log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n-//        if (topicName.isGlobal()) {\n-//            validateGlobalNamespaceOwnership(namespaceName);\n-//        }\n-//        unloadTopic(topicName, authoritative);\n-//    }\n-\n     protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authoritative) {\n         log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n         if (topicName.isGlobal()) {\n"}}, {"oid": "416b0a01ef63659a5349737fbbbb39c902d2f3a6", "url": "https://github.com/apache/pulsar/commit/416b0a01ef63659a5349737fbbbb39c902d2f3a6", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-03T11:09:21Z", "type": "commit"}, {"oid": "86a8d9c0da890bc09836f84b98bf653f22f18541", "url": "https://github.com/apache/pulsar/commit/86a8d9c0da890bc09836f84b98bf653f22f18541", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-03T11:46:08Z", "type": "commit"}, {"oid": "d8a5c65abfb20a74622aaef3503a11996242a290", "url": "https://github.com/apache/pulsar/commit/d8a5c65abfb20a74622aaef3503a11996242a290", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-03T12:04:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3ODE2Mg==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r374878162", "bodyText": "AsyncResponse indicates that this method is an async operation. So can we implement this method in an async way?", "author": "sijie", "createdAt": "2020-02-04T19:32:25Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -655,12 +655,56 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n         });\n     }\n \n-    protected void internalUnloadTopic(boolean authoritative) {\n+    protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authoritative) {\n         log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        unloadTopic(topicName, authoritative);\n+\n+        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);", "originalCommit": "d8a5c65abfb20a74622aaef3503a11996242a290", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY3MDM5NA==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376670394", "bodyText": "Does it seem that my comment here was not addressed?", "author": "sijie", "createdAt": "2020-02-08T00:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3ODE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc1NDIyOA==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376754228", "bodyText": "implement getPartitionedTopicMetadata in an async way?", "author": "ltamber", "createdAt": "2020-02-09T04:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3ODE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjkyMDAwMw==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376920003", "bodyText": "Yes. we need to make sure this method is also implemented in an async way.", "author": "sijie", "createdAt": "2020-02-10T08:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3ODE2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex 05f17014100..fcfec09af1b 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -661,50 +661,61 @@ public class PersistentTopicsBase extends AdminResource {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n \n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false)\n+                .whenComplete((metadata, ex) -> {\n+                    if (ex != null) {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName);\n+                        asyncResponse.resume(new RestException(ex));\n+                    } else {\n+                        if (metadata.partitions > 0) {\n+                            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                            for (int i = 0; i < metadata.partitions; i++) {\n+                                TopicName topicNamePartition = topicName.getPartition(i);\n+                                try {\n+                                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                                } catch (Exception e) {\n+                                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                                    asyncResponse.resume(new RestException(e));\n+                                    return;\n+                                }\n+                            }\n \n-            for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n-                } catch (Exception e) {\n-                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n-                }\n-            }\n+                            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                                if (exception != null) {\n+                                    Throwable t = exception.getCause();\n+                                    if (t instanceof NotFoundException) {\n+                                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                                    } else {\n+                                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                                        asyncResponse.resume(new RestException(exception));\n+                                    }\n+                                    return null;\n+                                }\n \n-            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                if (exception != null) {\n-                    Throwable t = exception.getCause();\n-                    if (t instanceof NotFoundException) {\n-                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n-                    } else {\n-                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n-                        asyncResponse.resume(new RestException(exception));\n+                                asyncResponse.resume(Response.noContent().build());\n+                                return null;\n+                            });\n+                        } else {\n+                            validateAdminAccessForTenant(topicName.getTenant());\n+                            validateTopicOwnership(topicName, authoritative);\n+\n+                            Topic topic = getTopicReference(topicName);\n+                            try {\n+                                topic.close(false).get();\n+                                asyncResponse.resume(Response.noContent().build());\n+                                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n+                            } catch (Exception e) {\n+                                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n+                                asyncResponse.resume(new RestException(e));\n+                            }\n+                        }\n                     }\n+                }).exceptionally(t -> {\n+                    Throwable th = t.getCause();\n+                    asyncResponse.resume(new RestException(th));\n                     return null;\n-                }\n-\n-                asyncResponse.resume(Response.noContent().build());\n-                return null;\n-            });\n-        } else {\n-            validateAdminAccessForTenant(topicName.getTenant());\n-            validateTopicOwnership(topicName, authoritative);\n-\n-            Topic topic = getTopicReference(topicName);\n-            try {\n-                topic.close(false).get();\n-                asyncResponse.resume(Response.noContent().build());\n-                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n-            } catch (Exception e) {\n-                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n-                asyncResponse.resume(new RestException(e));\n-            }\n-        }\n+        });\n     }\n \n     protected void internalDeleteTopic(boolean authoritative, boolean force) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg3ODc3OQ==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r374878779", "bodyText": "If this is already an async method, can you put the logic in the callback?", "author": "sijie", "createdAt": "2020-02-04T19:33:41Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -655,12 +655,56 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n         });\n     }\n \n-    protected void internalUnloadTopic(boolean authoritative) {\n+    protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authoritative) {\n         log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        unloadTopic(topicName, authoritative);\n+\n+        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+        if (partitionMetadata.partitions > 0) {\n+            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                TopicName topicNamePartition = topicName.getPartition(i);\n+                try {\n+                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                } catch (Exception e) {\n+                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+            }\n+\n+            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                if (exception != null) {\n+                    Throwable t = exception.getCause();\n+                    if (t instanceof NotFoundException) {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                    } else {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                        asyncResponse.resume(new RestException(exception));\n+                    }\n+                    return null;\n+                }\n+\n+                asyncResponse.resume(Response.noContent().build());\n+                return null;\n+            });\n+        } else {\n+            validateAdminAccessForTenant(topicName.getTenant());\n+            validateTopicOwnership(topicName, authoritative);\n+\n+            Topic topic = getTopicReference(topicName);\n+            try {\n+                topic.close(false).get();", "originalCommit": "d8a5c65abfb20a74622aaef3503a11996242a290", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex 05f17014100..fcfec09af1b 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -661,50 +661,61 @@ public class PersistentTopicsBase extends AdminResource {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n \n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions > 0) {\n-            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false)\n+                .whenComplete((metadata, ex) -> {\n+                    if (ex != null) {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName);\n+                        asyncResponse.resume(new RestException(ex));\n+                    } else {\n+                        if (metadata.partitions > 0) {\n+                            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                            for (int i = 0; i < metadata.partitions; i++) {\n+                                TopicName topicNamePartition = topicName.getPartition(i);\n+                                try {\n+                                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                                } catch (Exception e) {\n+                                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                                    asyncResponse.resume(new RestException(e));\n+                                    return;\n+                                }\n+                            }\n \n-            for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                TopicName topicNamePartition = topicName.getPartition(i);\n-                try {\n-                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n-                } catch (Exception e) {\n-                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n-                    asyncResponse.resume(new RestException(e));\n-                    return;\n-                }\n-            }\n+                            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                                if (exception != null) {\n+                                    Throwable t = exception.getCause();\n+                                    if (t instanceof NotFoundException) {\n+                                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                                    } else {\n+                                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                                        asyncResponse.resume(new RestException(exception));\n+                                    }\n+                                    return null;\n+                                }\n \n-            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                if (exception != null) {\n-                    Throwable t = exception.getCause();\n-                    if (t instanceof NotFoundException) {\n-                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n-                    } else {\n-                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n-                        asyncResponse.resume(new RestException(exception));\n+                                asyncResponse.resume(Response.noContent().build());\n+                                return null;\n+                            });\n+                        } else {\n+                            validateAdminAccessForTenant(topicName.getTenant());\n+                            validateTopicOwnership(topicName, authoritative);\n+\n+                            Topic topic = getTopicReference(topicName);\n+                            try {\n+                                topic.close(false).get();\n+                                asyncResponse.resume(Response.noContent().build());\n+                                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n+                            } catch (Exception e) {\n+                                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n+                                asyncResponse.resume(new RestException(e));\n+                            }\n+                        }\n                     }\n+                }).exceptionally(t -> {\n+                    Throwable th = t.getCause();\n+                    asyncResponse.resume(new RestException(th));\n                     return null;\n-                }\n-\n-                asyncResponse.resume(Response.noContent().build());\n-                return null;\n-            });\n-        } else {\n-            validateAdminAccessForTenant(topicName.getTenant());\n-            validateTopicOwnership(topicName, authoritative);\n-\n-            Topic topic = getTopicReference(topicName);\n-            try {\n-                topic.close(false).get();\n-                asyncResponse.resume(Response.noContent().build());\n-                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n-            } catch (Exception e) {\n-                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n-                asyncResponse.resume(new RestException(e));\n-            }\n-        }\n+        });\n     }\n \n     protected void internalDeleteTopic(boolean authoritative, boolean force) {\n"}}, {"oid": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "url": "https://github.com/apache/pulsar/commit/53e49dc320d915b97d9f275d6030dbbc734e84d5", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-06T16:07:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1ODc0OQ==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376158749", "bodyText": "Don't we need to return here?", "author": "sijie", "createdAt": "2020-02-07T00:34:42Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java", "diffHunk": "@@ -552,6 +552,36 @@ protected ZooKeeperChildrenCache failureDomainListCache() {\n         return pulsar().getConfigurationCache().failureDomainListCache();\n     }\n \n+    protected CompletableFuture<PartitionedTopicMetadata> getPartitionedTopicMetadataAsync(\n+            TopicName topicName, boolean authoritative, boolean checkAllowAutoCreation) {\n+        validateClusterOwnership(topicName.getCluster());\n+        // validates global-namespace contains local/peer cluster: if peer/local cluster present then lookup can\n+        // serve/redirect request else fail partitioned-metadata-request so, client fails while creating\n+        // producer/consumer\n+        validateGlobalNamespaceOwnership(topicName.getNamespaceObject());\n+\n+        CompletableFuture<PartitionedTopicMetadata> future = new CompletableFuture<>();\n+\n+        try {\n+            checkConnect(topicName);\n+        } catch (WebApplicationException e) {\n+            validateAdminAccessForTenant(topicName.getTenant());\n+        } catch (Exception e) {\n+            // unknown error marked as internal server error\n+            log.warn(\"Unexpected error while authorizing lookup. topic={}, role={}. Error: {}\", topicName,\n+                    clientAppId(), e.getMessage(), e);\n+            future.completeExceptionally(e);", "originalCommit": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7192f3327f96ac6f10b28128d47d01dc35d372b0", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java\nindex 6c8cb9f0b81..e9d559ef014 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java\n\n@@ -552,36 +552,6 @@ public abstract class AdminResource extends PulsarWebResource {\n         return pulsar().getConfigurationCache().failureDomainListCache();\n     }\n \n-    protected CompletableFuture<PartitionedTopicMetadata> getPartitionedTopicMetadataAsync(\n-            TopicName topicName, boolean authoritative, boolean checkAllowAutoCreation) {\n-        validateClusterOwnership(topicName.getCluster());\n-        // validates global-namespace contains local/peer cluster: if peer/local cluster present then lookup can\n-        // serve/redirect request else fail partitioned-metadata-request so, client fails while creating\n-        // producer/consumer\n-        validateGlobalNamespaceOwnership(topicName.getNamespaceObject());\n-\n-        CompletableFuture<PartitionedTopicMetadata> future = new CompletableFuture<>();\n-\n-        try {\n-            checkConnect(topicName);\n-        } catch (WebApplicationException e) {\n-            validateAdminAccessForTenant(topicName.getTenant());\n-        } catch (Exception e) {\n-            // unknown error marked as internal server error\n-            log.warn(\"Unexpected error while authorizing lookup. topic={}, role={}. Error: {}\", topicName,\n-                    clientAppId(), e.getMessage(), e);\n-            future.completeExceptionally(e);\n-        }\n-\n-        if (checkAllowAutoCreation) {\n-            future = pulsar().getBrokerService().fetchPartitionedTopicMetadataCheckAllowAutoCreationAsync(topicName);\n-        } else {\n-            future = pulsar().getBrokerService().fetchPartitionedTopicMetadataAsync(topicName);\n-        }\n-\n-        return future;\n-    }\n-\n     protected PartitionedTopicMetadata getPartitionedTopicMetadata(TopicName topicName,\n             boolean authoritative, boolean checkAllowAutoCreation) {\n         validateClusterOwnership(topicName.getCluster());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1ODkzNg==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376158936", "bodyText": "line 577 and line 579 reinitialize a completable future. so I don't think we need to initialize here.", "author": "sijie", "createdAt": "2020-02-07T00:35:32Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java", "diffHunk": "@@ -552,6 +552,36 @@ protected ZooKeeperChildrenCache failureDomainListCache() {\n         return pulsar().getConfigurationCache().failureDomainListCache();\n     }\n \n+    protected CompletableFuture<PartitionedTopicMetadata> getPartitionedTopicMetadataAsync(\n+            TopicName topicName, boolean authoritative, boolean checkAllowAutoCreation) {\n+        validateClusterOwnership(topicName.getCluster());\n+        // validates global-namespace contains local/peer cluster: if peer/local cluster present then lookup can\n+        // serve/redirect request else fail partitioned-metadata-request so, client fails while creating\n+        // producer/consumer\n+        validateGlobalNamespaceOwnership(topicName.getNamespaceObject());\n+\n+        CompletableFuture<PartitionedTopicMetadata> future = new CompletableFuture<>();", "originalCommit": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7192f3327f96ac6f10b28128d47d01dc35d372b0", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java\nindex 6c8cb9f0b81..e9d559ef014 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/AdminResource.java\n\n@@ -552,36 +552,6 @@ public abstract class AdminResource extends PulsarWebResource {\n         return pulsar().getConfigurationCache().failureDomainListCache();\n     }\n \n-    protected CompletableFuture<PartitionedTopicMetadata> getPartitionedTopicMetadataAsync(\n-            TopicName topicName, boolean authoritative, boolean checkAllowAutoCreation) {\n-        validateClusterOwnership(topicName.getCluster());\n-        // validates global-namespace contains local/peer cluster: if peer/local cluster present then lookup can\n-        // serve/redirect request else fail partitioned-metadata-request so, client fails while creating\n-        // producer/consumer\n-        validateGlobalNamespaceOwnership(topicName.getNamespaceObject());\n-\n-        CompletableFuture<PartitionedTopicMetadata> future = new CompletableFuture<>();\n-\n-        try {\n-            checkConnect(topicName);\n-        } catch (WebApplicationException e) {\n-            validateAdminAccessForTenant(topicName.getTenant());\n-        } catch (Exception e) {\n-            // unknown error marked as internal server error\n-            log.warn(\"Unexpected error while authorizing lookup. topic={}, role={}. Error: {}\", topicName,\n-                    clientAppId(), e.getMessage(), e);\n-            future.completeExceptionally(e);\n-        }\n-\n-        if (checkAllowAutoCreation) {\n-            future = pulsar().getBrokerService().fetchPartitionedTopicMetadataCheckAllowAutoCreationAsync(topicName);\n-        } else {\n-            future = pulsar().getBrokerService().fetchPartitionedTopicMetadataAsync(topicName);\n-        }\n-\n-        return future;\n-    }\n-\n     protected PartitionedTopicMetadata getPartitionedTopicMetadata(TopicName topicName,\n             boolean authoritative, boolean checkAllowAutoCreation) {\n         validateClusterOwnership(topicName.getCluster());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1OTcwNQ==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376159705", "bodyText": "this should be implemented in an async way.", "author": "sijie", "createdAt": "2020-02-07T00:38:10Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -655,12 +655,67 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n         });\n     }\n \n-    protected void internalUnloadTopic(boolean authoritative) {\n+    protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authoritative) {\n         log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        unloadTopic(topicName, authoritative);\n+\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false)\n+                .whenComplete((metadata, ex) -> {\n+                    if (ex != null) {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName);\n+                        asyncResponse.resume(new RestException(ex));\n+                    } else {\n+                        if (metadata.partitions > 0) {\n+                            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                            for (int i = 0; i < metadata.partitions; i++) {\n+                                TopicName topicNamePartition = topicName.getPartition(i);\n+                                try {\n+                                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                                } catch (Exception e) {\n+                                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                                    asyncResponse.resume(new RestException(e));\n+                                    return;\n+                                }\n+                            }\n+\n+                            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                                if (exception != null) {\n+                                    Throwable t = exception.getCause();\n+                                    if (t instanceof NotFoundException) {\n+                                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                                    } else {\n+                                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                                        asyncResponse.resume(new RestException(exception));\n+                                    }\n+                                    return null;\n+                                }\n+\n+                                asyncResponse.resume(Response.noContent().build());\n+                                return null;\n+                            });\n+                        } else {\n+                            validateAdminAccessForTenant(topicName.getTenant());\n+                            validateTopicOwnership(topicName, authoritative);\n+\n+                            Topic topic = getTopicReference(topicName);\n+                            try {\n+                                topic.close(false).get();", "originalCommit": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQyNDYzMg==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376424632", "bodyText": "OK", "author": "ltamber", "createdAt": "2020-02-07T14:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1OTcwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "7192f3327f96ac6f10b28128d47d01dc35d372b0", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex fcfec09af1b..28b9eedf394 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -661,61 +661,52 @@ public class PersistentTopicsBase extends AdminResource {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n \n-        getPartitionedTopicMetadataAsync(topicName, authoritative, false)\n-                .whenComplete((metadata, ex) -> {\n-                    if (ex != null) {\n-                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName);\n-                        asyncResponse.resume(new RestException(ex));\n-                    } else {\n-                        if (metadata.partitions > 0) {\n-                            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                            for (int i = 0; i < metadata.partitions; i++) {\n-                                TopicName topicNamePartition = topicName.getPartition(i);\n-                                try {\n-                                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n-                                } catch (Exception e) {\n-                                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n-                                    asyncResponse.resume(new RestException(e));\n-                                    return;\n-                                }\n-                            }\n+        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+        if (partitionMetadata.partitions > 0) {\n+            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-                            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                                if (exception != null) {\n-                                    Throwable t = exception.getCause();\n-                                    if (t instanceof NotFoundException) {\n-                                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n-                                    } else {\n-                                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n-                                        asyncResponse.resume(new RestException(exception));\n-                                    }\n-                                    return null;\n-                                }\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                TopicName topicNamePartition = topicName.getPartition(i);\n+                try {\n+                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                } catch (Exception e) {\n+                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+            }\n \n-                                asyncResponse.resume(Response.noContent().build());\n-                                return null;\n-                            });\n-                        } else {\n-                            validateAdminAccessForTenant(topicName.getTenant());\n-                            validateTopicOwnership(topicName, authoritative);\n-\n-                            Topic topic = getTopicReference(topicName);\n-                            try {\n-                                topic.close(false).get();\n-                                asyncResponse.resume(Response.noContent().build());\n-                                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n-                            } catch (Exception e) {\n-                                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n-                                asyncResponse.resume(new RestException(e));\n-                            }\n-                        }\n+            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                if (exception != null) {\n+                    Throwable t = exception.getCause();\n+                    if (t instanceof NotFoundException) {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                    } else {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                        asyncResponse.resume(new RestException(exception));\n                     }\n-                }).exceptionally(t -> {\n-                    Throwable th = t.getCause();\n-                    asyncResponse.resume(new RestException(th));\n                     return null;\n-        });\n+                }\n+\n+                asyncResponse.resume(Response.noContent().build());\n+                return null;\n+            });\n+        } else {\n+            validateAdminAccessForTenant(topicName.getTenant());\n+            validateTopicOwnership(topicName, authoritative);\n+\n+            Topic topic = getTopicReference(topicName);\n+            topic.close(false).whenComplete((r, ex) -> {\n+                if (ex != null) {\n+                    log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, ex.getMessage(), ex);\n+                    asyncResponse.resume(new RestException(ex));\n+\n+                } else {\n+                    log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n+                    asyncResponse.resume(Response.noContent().build());\n+                }\n+            });\n+        }\n     }\n \n     protected void internalDeleteTopic(boolean authoritative, boolean force) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE1OTc5Mw==", "url": "https://github.com/apache/pulsar/pull/6187#discussion_r376159793", "bodyText": "Fix indention", "author": "sijie", "createdAt": "2020-02-07T00:38:29Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -655,12 +655,67 @@ protected void internalDeletePartitionedTopic(AsyncResponse asyncResponse, boole\n         });\n     }\n \n-    protected void internalUnloadTopic(boolean authoritative) {\n+    protected void internalUnloadTopic(AsyncResponse asyncResponse, boolean authoritative) {\n         log.info(\"[{}] Unloading topic {}\", clientAppId(), topicName);\n         if (topicName.isGlobal()) {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n-        unloadTopic(topicName, authoritative);\n+\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false)\n+                .whenComplete((metadata, ex) -> {\n+                    if (ex != null) {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName);\n+                        asyncResponse.resume(new RestException(ex));\n+                    } else {\n+                        if (metadata.partitions > 0) {\n+                            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                            for (int i = 0; i < metadata.partitions; i++) {\n+                                TopicName topicNamePartition = topicName.getPartition(i);\n+                                try {\n+                                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                                } catch (Exception e) {\n+                                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                                    asyncResponse.resume(new RestException(e));\n+                                    return;\n+                                }\n+                            }\n+\n+                            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                                if (exception != null) {\n+                                    Throwable t = exception.getCause();\n+                                    if (t instanceof NotFoundException) {\n+                                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                                    } else {\n+                                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                                        asyncResponse.resume(new RestException(exception));\n+                                    }\n+                                    return null;\n+                                }\n+\n+                                asyncResponse.resume(Response.noContent().build());\n+                                return null;\n+                            });\n+                        } else {\n+                            validateAdminAccessForTenant(topicName.getTenant());\n+                            validateTopicOwnership(topicName, authoritative);\n+\n+                            Topic topic = getTopicReference(topicName);\n+                            try {\n+                                topic.close(false).get();\n+                                asyncResponse.resume(Response.noContent().build());\n+                                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n+                            } catch (Exception e) {\n+                                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n+                                asyncResponse.resume(new RestException(e));\n+                            }\n+                        }\n+                    }\n+                }).exceptionally(t -> {\n+                    Throwable th = t.getCause();\n+                    asyncResponse.resume(new RestException(th));\n+                    return null;\n+        });", "originalCommit": "53e49dc320d915b97d9f275d6030dbbc734e84d5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7192f3327f96ac6f10b28128d47d01dc35d372b0", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex fcfec09af1b..28b9eedf394 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -661,61 +661,52 @@ public class PersistentTopicsBase extends AdminResource {\n             validateGlobalNamespaceOwnership(namespaceName);\n         }\n \n-        getPartitionedTopicMetadataAsync(topicName, authoritative, false)\n-                .whenComplete((metadata, ex) -> {\n-                    if (ex != null) {\n-                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName);\n-                        asyncResponse.resume(new RestException(ex));\n-                    } else {\n-                        if (metadata.partitions > 0) {\n-                            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                            for (int i = 0; i < metadata.partitions; i++) {\n-                                TopicName topicNamePartition = topicName.getPartition(i);\n-                                try {\n-                                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n-                                } catch (Exception e) {\n-                                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n-                                    asyncResponse.resume(new RestException(e));\n-                                    return;\n-                                }\n-                            }\n+        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+        if (partitionMetadata.partitions > 0) {\n+            final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-                            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                                if (exception != null) {\n-                                    Throwable t = exception.getCause();\n-                                    if (t instanceof NotFoundException) {\n-                                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n-                                    } else {\n-                                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n-                                        asyncResponse.resume(new RestException(exception));\n-                                    }\n-                                    return null;\n-                                }\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                TopicName topicNamePartition = topicName.getPartition(i);\n+                try {\n+                    futures.add(pulsar().getAdminClient().topics().unloadAsync(topicNamePartition.toString()));\n+                } catch (Exception e) {\n+                    log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicNamePartition, e);\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+            }\n \n-                                asyncResponse.resume(Response.noContent().build());\n-                                return null;\n-                            });\n-                        } else {\n-                            validateAdminAccessForTenant(topicName.getTenant());\n-                            validateTopicOwnership(topicName, authoritative);\n-\n-                            Topic topic = getTopicReference(topicName);\n-                            try {\n-                                topic.close(false).get();\n-                                asyncResponse.resume(Response.noContent().build());\n-                                log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n-                            } catch (Exception e) {\n-                                log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, e.getMessage(), e);\n-                                asyncResponse.resume(new RestException(e));\n-                            }\n-                        }\n+            FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                if (exception != null) {\n+                    Throwable t = exception.getCause();\n+                    if (t instanceof NotFoundException) {\n+                        asyncResponse.resume(new RestException(Status.NOT_FOUND, t.getMessage()));\n+                    } else {\n+                        log.error(\"[{}] Failed to unload topic {}\", clientAppId(), topicName, exception);\n+                        asyncResponse.resume(new RestException(exception));\n                     }\n-                }).exceptionally(t -> {\n-                    Throwable th = t.getCause();\n-                    asyncResponse.resume(new RestException(th));\n                     return null;\n-        });\n+                }\n+\n+                asyncResponse.resume(Response.noContent().build());\n+                return null;\n+            });\n+        } else {\n+            validateAdminAccessForTenant(topicName.getTenant());\n+            validateTopicOwnership(topicName, authoritative);\n+\n+            Topic topic = getTopicReference(topicName);\n+            topic.close(false).whenComplete((r, ex) -> {\n+                if (ex != null) {\n+                    log.error(\"[{}] Failed to unload topic {}, {}\", clientAppId(), topicName, ex.getMessage(), ex);\n+                    asyncResponse.resume(new RestException(ex));\n+\n+                } else {\n+                    log.info(\"[{}] Successfully unloaded topic {}\", clientAppId(), topicName);\n+                    asyncResponse.resume(Response.noContent().build());\n+                }\n+            });\n+        }\n     }\n \n     protected void internalDeleteTopic(boolean authoritative, boolean force) {\n"}}, {"oid": "7192f3327f96ac6f10b28128d47d01dc35d372b0", "url": "https://github.com/apache/pulsar/commit/7192f3327f96ac6f10b28128d47d01dc35d372b0", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-07T05:39:38Z", "type": "commit"}, {"oid": "b1ad179995340294e09af658a1de5a5489abf9f4", "url": "https://github.com/apache/pulsar/commit/b1ad179995340294e09af658a1de5a5489abf9f4", "message": "Support `unload` all partitions of a partitioned topic", "committedDate": "2020-02-12T08:02:26Z", "type": "commit"}]}