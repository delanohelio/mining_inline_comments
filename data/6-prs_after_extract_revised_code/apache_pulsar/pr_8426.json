{"pr_number": 8426, "pr_title": "[Transaction]Transaction pendingack server implement patch", "pr_createdAt": "2020-11-02T09:44:21Z", "pr_url": "https://github.com/apache/pulsar/pull/8426", "timeline": [{"oid": "efe0fb3fec6fc67cfd18eaa48b3a3c9e64411507", "url": "https://github.com/apache/pulsar/commit/efe0fb3fec6fc67cfd18eaa48b3a3c9e64411507", "message": "Patch 8256", "committedDate": "2020-11-02T09:42:22Z", "type": "commit"}, {"oid": "e87fb2d3f8a4439ebc5b05e83aa0181832f33472", "url": "https://github.com/apache/pulsar/commit/e87fb2d3f8a4439ebc5b05e83aa0181832f33472", "message": "recover", "committedDate": "2020-11-02T10:01:30Z", "type": "commit"}, {"oid": "7760fba5ecad21223a442eab86056214d629798d", "url": "https://github.com/apache/pulsar/commit/7760fba5ecad21223a442eab86056214d629798d", "message": "Redeliver move to server", "committedDate": "2020-11-04T02:07:31Z", "type": "commit"}, {"oid": "7769465800cce281c4b7b66def010fdddf6dab4c", "url": "https://github.com/apache/pulsar/commit/7769465800cce281c4b7b66def010fdddf6dab4c", "message": "Delete cache in broker memory", "committedDate": "2020-11-05T10:54:37Z", "type": "commit"}, {"oid": "d15164a78f318218734211cce987f27019ac157a", "url": "https://github.com/apache/pulsar/commit/d15164a78f318218734211cce987f27019ac157a", "message": "Move ack set util postion", "committedDate": "2020-11-05T11:08:48Z", "type": "commit"}, {"oid": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "url": "https://github.com/apache/pulsar/commit/855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "message": "Add the clear broker memory test", "committedDate": "2020-11-06T07:47:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzNjk0Nw==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518636947", "bodyText": "It's better to throw an exception here, if return -1 it means the currentPosition is lower than otherPosition", "author": "codelipenghui", "createdAt": "2020-11-06T09:47:43Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\nindex 31d8ea106dc..d65638f0a32 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\n\n@@ -59,38 +59,38 @@ public class PositionAckSetUtil {\n     //compare the ack set next bit index is bigger than another one.\n     public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n         if (currentPosition == null || otherPosition ==null) {\n-            return -1;\n+            throw new NullPointerException(\"Two positions can't be null! \" +\n+                    \"current position : [\" + currentPosition + \"] other position : [\" + otherPosition + \"]\");\n         }\n         int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n                 otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n                 .result();\n         if (result == 0) {\n+            BitSetRecyclable otherAckSet;\n+            BitSetRecyclable currentAckSet;\n+\n             if (otherPosition.getAckSet() == null) {\n-                return result;\n+                otherAckSet = BitSetRecyclable.create();\n+            } else {\n+                otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n             }\n \n-            BitSetRecyclable otherAckSet;\n             if (currentPosition.getAckSet() == null) {\n-                if (otherPosition.getAckSet() != null) {\n-                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n-                    if (otherAckSet.isEmpty()) {\n-                        otherAckSet.recycle();\n-                        return result;\n-                    } else {\n-                        otherAckSet.recycle();\n-                        return 1;\n-                    }\n+                currentAckSet = BitSetRecyclable.create();\n+            } else {\n+                currentAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            }\n \n-                }\n-                return result;\n+            if (currentAckSet.isEmpty() || otherAckSet.isEmpty()) {\n+                //when ack set is empty, the nextSetBit will return -1, so we should return the inverse value.\n+                result = -(currentAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0));\n+            } else {\n+                result = currentAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n             }\n-            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n-            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n-            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            currentAckSet.recycle();\n             otherAckSet.recycle();\n-            thisAckSet.recycle();\n-            return result;\n         }\n         return result;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODYzOTI3MA==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518639270", "bodyText": "Why otherPosition's ackSet is null then return the result?", "author": "codelipenghui", "createdAt": "2020-11-06T09:51:45Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\nindex 31d8ea106dc..d65638f0a32 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\n\n@@ -59,38 +59,38 @@ public class PositionAckSetUtil {\n     //compare the ack set next bit index is bigger than another one.\n     public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n         if (currentPosition == null || otherPosition ==null) {\n-            return -1;\n+            throw new NullPointerException(\"Two positions can't be null! \" +\n+                    \"current position : [\" + currentPosition + \"] other position : [\" + otherPosition + \"]\");\n         }\n         int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n                 otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n                 .result();\n         if (result == 0) {\n+            BitSetRecyclable otherAckSet;\n+            BitSetRecyclable currentAckSet;\n+\n             if (otherPosition.getAckSet() == null) {\n-                return result;\n+                otherAckSet = BitSetRecyclable.create();\n+            } else {\n+                otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n             }\n \n-            BitSetRecyclable otherAckSet;\n             if (currentPosition.getAckSet() == null) {\n-                if (otherPosition.getAckSet() != null) {\n-                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n-                    if (otherAckSet.isEmpty()) {\n-                        otherAckSet.recycle();\n-                        return result;\n-                    } else {\n-                        otherAckSet.recycle();\n-                        return 1;\n-                    }\n+                currentAckSet = BitSetRecyclable.create();\n+            } else {\n+                currentAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            }\n \n-                }\n-                return result;\n+            if (currentAckSet.isEmpty() || otherAckSet.isEmpty()) {\n+                //when ack set is empty, the nextSetBit will return -1, so we should return the inverse value.\n+                result = -(currentAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0));\n+            } else {\n+                result = currentAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n             }\n-            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n-            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n-            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            currentAckSet.recycle();\n             otherAckSet.recycle();\n-            thisAckSet.recycle();\n-            return result;\n         }\n         return result;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0NDAyOA==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518644028", "bodyText": "I think we can use an empty ackset to simplify these lines.", "author": "codelipenghui", "createdAt": "2020-11-06T09:59:53Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.bookkeeper.mledger.util;\n+\n+import com.google.common.collect.ComparisonChain;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.pulsar.common.util.collections.BitSetRecyclable;\n+\n+public class PositionAckSetUtil {\n+\n+    //This method is to compare two ack set whether overlap or not\n+    public static boolean isAckSetOverlap(long[] currentAckSet, long[] otherAckSet) {\n+        if (currentAckSet == null || otherAckSet == null) {\n+            return false;\n+        }\n+\n+        BitSetRecyclable currentBitSet = BitSetRecyclable.valueOf(currentAckSet);\n+        BitSetRecyclable otherBitSet = BitSetRecyclable.valueOf(otherAckSet);\n+        currentBitSet.flip(0, currentBitSet.size());\n+        otherBitSet.flip(0, otherBitSet.size());\n+        currentBitSet.and(otherBitSet);\n+        boolean isAckSetRepeated = !currentBitSet.isEmpty();\n+        currentBitSet.recycle();\n+        otherBitSet.recycle();\n+        return isAckSetRepeated;\n+    }\n+\n+    //This method is do `and` operation for position's ack set\n+    public static void andAckSet(PositionImpl currentPosition, PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition == null) {\n+            return;\n+        }\n+        BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+        BitSetRecyclable otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+        thisAckSet.and(otherAckSet);\n+        currentPosition.setAckSet(thisAckSet.toLongArray());\n+        thisAckSet.recycle();\n+        otherAckSet.recycle();\n+    }\n+\n+    //This method is compare two position which position is bigger than another one.\n+    //When the ledgerId and entryId in this position is same to another one and two position all have ack set, it will\n+    //compare the ack set next bit index is bigger than another one.\n+    public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n+        if (currentPosition == null || otherPosition ==null) {\n+            return -1;\n+        }\n+        int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n+                otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n+                .result();\n+        if (result == 0) {\n+            if (otherPosition.getAckSet() == null) {\n+                return result;\n+            }\n+\n+            BitSetRecyclable otherAckSet;\n+            if (currentPosition.getAckSet() == null) {\n+                if (otherPosition.getAckSet() != null) {\n+                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+                    if (otherAckSet.isEmpty()) {\n+                        otherAckSet.recycle();\n+                        return result;\n+                    } else {\n+                        otherAckSet.recycle();\n+                        return 1;\n+                    }\n+\n+                }\n+                return result;\n+            }\n+            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n+            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            otherAckSet.recycle();\n+            thisAckSet.recycle();", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\nindex 31d8ea106dc..d65638f0a32 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/util/PositionAckSetUtil.java\n\n@@ -59,38 +59,38 @@ public class PositionAckSetUtil {\n     //compare the ack set next bit index is bigger than another one.\n     public static int compareToWithAckSet(PositionImpl currentPosition,PositionImpl otherPosition) {\n         if (currentPosition == null || otherPosition ==null) {\n-            return -1;\n+            throw new NullPointerException(\"Two positions can't be null! \" +\n+                    \"current position : [\" + currentPosition + \"] other position : [\" + otherPosition + \"]\");\n         }\n         int result = ComparisonChain.start().compare(currentPosition.getLedgerId(),\n                 otherPosition.getLedgerId()).compare(currentPosition.getEntryId(), otherPosition.getEntryId())\n                 .result();\n         if (result == 0) {\n+            BitSetRecyclable otherAckSet;\n+            BitSetRecyclable currentAckSet;\n+\n             if (otherPosition.getAckSet() == null) {\n-                return result;\n+                otherAckSet = BitSetRecyclable.create();\n+            } else {\n+                otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n             }\n \n-            BitSetRecyclable otherAckSet;\n             if (currentPosition.getAckSet() == null) {\n-                if (otherPosition.getAckSet() != null) {\n-                    otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n-                    if (otherAckSet.isEmpty()) {\n-                        otherAckSet.recycle();\n-                        return result;\n-                    } else {\n-                        otherAckSet.recycle();\n-                        return 1;\n-                    }\n+                currentAckSet = BitSetRecyclable.create();\n+            } else {\n+                currentAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n+            }\n \n-                }\n-                return result;\n+            if (currentAckSet.isEmpty() || otherAckSet.isEmpty()) {\n+                //when ack set is empty, the nextSetBit will return -1, so we should return the inverse value.\n+                result = -(currentAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0));\n+            } else {\n+                result = currentAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n             }\n-            otherAckSet = BitSetRecyclable.valueOf(otherPosition.getAckSet());\n-            BitSetRecyclable thisAckSet = BitSetRecyclable.valueOf(currentPosition.getAckSet());\n-            result = thisAckSet.nextSetBit(0) - otherAckSet.nextSetBit(0);\n+            currentAckSet.recycle();\n             otherAckSet.recycle();\n-            thisAckSet.recycle();\n-            return result;\n         }\n         return result;\n     }\n+\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY0ODg0Mg==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518648842", "bodyText": "If this for normal ack, shall we need to return TransactionConflictException?", "author": "codelipenghui", "createdAt": "2020-11-06T10:08:26Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex 55848ab9963..a3e0fb96b63 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -440,7 +435,7 @@ public class Consumer {\n     private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n         List<Position> positionsAcked = new ArrayList<>();\n         List<PositionImpl> checkBatchPositions = null;\n-        if (isTransactionEnabled) {\n+        if (isTransactionEnabled()) {\n             checkBatchPositions = new ArrayList<>();\n         }\n         for (int i = 0; i < ack.getMessageIdCount(); i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MDc0Nw==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r518650747", "bodyText": "Looks there is much duplicate code with the individualAckNormal, is it possible to refine it?", "author": "codelipenghui", "createdAt": "2020-11-06T10:11:59Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -413,49 +419,149 @@ void doUnsubscribe(final long requestId) {\n                     position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n                 }\n             }\n-            List<Position> positionsAcked = Collections.singletonList(position);\n             if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Cumulative);\n+                List<PositionImpl> positionsAcked = Collections.singletonList(position);\n+                return transactionCumulativeAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked);\n             } else {\n+                List<Position> positionsAcked = Collections.singletonList(position);\n                 subscription.acknowledgeMessage(positionsAcked, AckType.Cumulative, properties);\n+                return CompletableFuture.completedFuture(null);\n             }\n         } else {\n-            // Individual ack\n-            List<Position> positionsAcked = new ArrayList<>();\n-            for (int i = 0; i < ack.getMessageIdCount(); i++) {\n-                MessageIdData msgId = ack.getMessageId(i);\n-                PositionImpl position;\n-                if (msgId.getAckSetCount() > 0) {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(), SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n-                } else {\n-                    position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n-                }\n-                positionsAcked.add(position);\n+            if (ack.hasTxnidLeastBits() && ack.hasTxnidMostBits()) {\n+                return individualAckWithTransaction(ack);\n+            } else {\n+                return individualAckNormal(ack, properties);\n+            }\n+        }\n+    }\n \n-                if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n-                    removePendingAcks(position);\n+    //this method is for individual ack not carry the transaction\n+    private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n+        List<Position> positionsAcked = new ArrayList<>();\n+        List<PositionImpl> checkBatchPositions = null;\n+        if (isTransactionEnabled) {\n+            checkBatchPositions = new ArrayList<>();\n+        }\n+        for (int i = 0; i < ack.getMessageIdCount(); i++) {\n+            MessageIdData msgId = ack.getMessageId(i);\n+            PositionImpl position;\n+            if (msgId.getAckSetCount() > 0) {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId(),\n+                        SafeCollectionUtils.longListToArray(msgId.getAckSetList()));\n+                if (isTransactionEnabled) {\n+                    //sync the batch position bit set point, in order to delete the position in pending acks\n+                    checkBatchPositions.add(position);\n+                    LongPair batchSizePair = this.pendingAcks.get(msgId.getLedgerId(), msgId.getEntryId());\n+                    if (batchSizePair == null) {\n+                        String error = \"Batch position [\" + position + \"] could not find \" +\n+                                \"it's batch size from consumer pendingAcks!\";\n+                        log.warn(error);\n+                        return FutureUtil.failedFuture(\n+                                new TransactionConflictException(error));\n+                    }\n+                    ((PersistentSubscription) subscription)\n+                            .syncBatchPositionBitSetForPendingAck(new MutablePair<>(position, batchSizePair.first));\n+                    //check if the position can remove from the consumer pending acks.\n+                    // the bit set is empty in pending ack handle.\n+                    if (((PersistentSubscription) subscription).checkIsCanDeleteConsumerPendingAck(position)) {\n+                        removePendingAcks(position);\n+                    }\n                 }\n+            } else {\n+                position = PositionImpl.get(msgId.getLedgerId(), msgId.getEntryId());\n+            }\n+            positionsAcked.add(position);\n+            if (Subscription.isIndividualAckMode(subType) && msgId.getAckSetCount() == 0) {\n+                removePendingAcks(position);\n+            }\n \n-                if (ack.hasValidationError()) {\n-                    log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n-                            consumerId, position, ack.getValidationError());\n-                }\n+            if (ack.hasValidationError()) {\n+                log.error(\"[{}] [{}] Received ack for corrupted message at {} - Reason: {}\", subscription,\n+                        consumerId, position, ack.getValidationError());\n             }\n-            if (ack.hasTxnidMostBits() && ack.hasTxnidLeastBits()) {\n-                return transactionAcknowledge(ack.getTxnidMostBits(), ack.getTxnidLeastBits(), positionsAcked, AckType.Individual);\n+        }\n+        subscription.acknowledgeMessage(positionsAcked, AckType.Individual, properties);\n+        return CompletableFuture.completedFuture(null);\n+    }\n+\n+\n+    //this method is for individual ack carry the transaction\n+    private CompletableFuture<Void> individualAckWithTransaction(CommandAck ack) {", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex 55848ab9963..a3e0fb96b63 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -440,7 +435,7 @@ public class Consumer {\n     private CompletableFuture<Void> individualAckNormal(CommandAck ack, Map<String,Long> properties) {\n         List<Position> positionsAcked = new ArrayList<>();\n         List<PositionImpl> checkBatchPositions = null;\n-        if (isTransactionEnabled) {\n+        if (isTransactionEnabled()) {\n             checkBatchPositions = new ArrayList<>();\n         }\n         for (int i = 0; i < ack.getMessageIdCount(); i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUwMjQwNw==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r519502407", "bodyText": "Move the isTransactionEnabled to the topic or subscription?  We cannot treat consumers differently in transaction.", "author": "codelipenghui", "createdAt": "2020-11-09T00:40:34Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -131,12 +132,13 @@\n     private static final double avgPercent = 0.9;\n     private boolean preciseDispatcherFlowControl;\n     private PositionImpl readPositionWhenJoining;\n+    private final boolean isTransactionEnabled;", "originalCommit": "855fa5c001e0a8b9458baa74f6fcf3c0a8b5f753", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex 55848ab9963..a3e0fb96b63 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -132,13 +133,12 @@ public class Consumer {\n     private static final double avgPercent = 0.9;\n     private boolean preciseDispatcherFlowControl;\n     private PositionImpl readPositionWhenJoining;\n-    private final boolean isTransactionEnabled;\n \n     public Consumer(Subscription subscription, SubType subType, String topicName, long consumerId,\n                     int priorityLevel, String consumerName,\n                     int maxUnackedMessages, ServerCnx cnx, String appId,\n                     Map<String, String> metadata, boolean readCompacted, InitialPosition subscriptionInitialPosition,\n-                    PulsarApi.KeySharedMeta keySharedMeta, boolean isTransactionEnabled) throws BrokerServiceException {\n+                    PulsarApi.KeySharedMeta keySharedMeta) throws BrokerServiceException {\n \n         this.subscription = subscription;\n         this.subType = subType;\n"}}, {"oid": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "url": "https://github.com/apache/pulsar/commit/704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "message": "Fix some comments", "committedDate": "2020-11-09T05:54:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI2NDEyNg==", "url": "https://github.com/apache/pulsar/pull/8426#discussion_r520264126", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //this method will return the a copy of the position's ack set\n          \n          \n            \n                //this method will return a copy of the position's ack set", "author": "gaoran10", "createdAt": "2020-11-10T03:31:48Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -2773,6 +2773,24 @@ public boolean isMessageDeleted(Position position) {\n                 ((PositionImpl) position).getEntryId()) || ((PositionImpl) position).compareTo(markDeletePosition) <= 0 ;\n     }\n \n+    //this method will return the a copy of the position's ack set", "originalCommit": "704221b4ed5f1a2308b866f321c5cc7cfb7527f1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bc5618040c5df285f01d94044040eee71efaaaac", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\nindex 5eb91b62235..5b599866769 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\n@@ -2773,7 +2773,7 @@ public class ManagedCursorImpl implements ManagedCursor {\n                 ((PositionImpl) position).getEntryId()) || ((PositionImpl) position).compareTo(markDeletePosition) <= 0 ;\n     }\n \n-    //this method will return the a copy of the position's ack set\n+    //this method will return a copy of the position's ack set\n     public long[] getBatchPositionAckSet(Position position) {\n         if (!(position instanceof PositionImpl)) {\n             return null;\n"}}, {"oid": "bc5618040c5df285f01d94044040eee71efaaaac", "url": "https://github.com/apache/pulsar/commit/bc5618040c5df285f01d94044040eee71efaaaac", "message": "Update managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\nCo-authored-by: ran <gaoran_10@126.com>", "committedDate": "2020-11-10T12:09:30Z", "type": "commit"}, {"oid": "bade2ed2fb7a82f6a1b3f7ba8eb9d40dfdb9f1ac", "url": "https://github.com/apache/pulsar/commit/bade2ed2fb7a82f6a1b3f7ba8eb9d40dfdb9f1ac", "message": "Modify the exception when can't find batch size", "committedDate": "2020-11-10T12:51:12Z", "type": "commit"}, {"oid": "310bd78645a0093ee3cb8724f738a0d1093ae0d4", "url": "https://github.com/apache/pulsar/commit/310bd78645a0093ee3cb8724f738a0d1093ae0d4", "message": "Merge remote-tracking branch 'apache/master' into congbobo184_transaction_pendingack_server_implement", "committedDate": "2020-11-10T12:52:09Z", "type": "commit"}, {"oid": "51bbcb4de293338443e535b43625bc3005910feb", "url": "https://github.com/apache/pulsar/commit/51bbcb4de293338443e535b43625bc3005910feb", "message": "Merge remote-tracking branch 'origin/congbobo184_transaction_pendingack_server_implement' into congbobo184_transaction_pendingack_server_implement", "committedDate": "2020-11-10T12:53:10Z", "type": "commit"}, {"oid": "81aafaba0d17be6fe8797ce9e499a45a8a9e10a6", "url": "https://github.com/apache/pulsar/commit/81aafaba0d17be6fe8797ce9e499a45a8a9e10a6", "message": "add the judement", "committedDate": "2020-11-11T02:38:41Z", "type": "commit"}, {"oid": "48ef7558296f5ac475f70ed7d3d63e92f9bcebb2", "url": "https://github.com/apache/pulsar/commit/48ef7558296f5ac475f70ed7d3d63e92f9bcebb2", "message": "Fix the exception return", "committedDate": "2020-11-11T03:51:58Z", "type": "commit"}]}