{"pr_number": 6052, "pr_title": "[PIP-54] Support acknowledgment at batch index level", "pr_createdAt": "2020-01-14T13:34:57Z", "pr_url": "https://github.com/apache/pulsar/pull/6052", "timeline": [{"oid": "94fba9ef4a2191b4526ffa67e1d1d87a76b439df", "url": "https://github.com/apache/pulsar/commit/94fba9ef4a2191b4526ffa67e1d1d87a76b439df", "message": "Add support for batch local index ack", "committedDate": "2020-01-22T03:19:48Z", "type": "forcePushed"}, {"oid": "201bc3e07847f5a0b97769af3b8e0467fe91d984", "url": "https://github.com/apache/pulsar/commit/201bc3e07847f5a0b97769af3b8e0467fe91d984", "message": "Fix unit test", "committedDate": "2020-02-13T12:12:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5MTEzMw==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378891133", "bodyText": "It seems that a large code section has been locked/unlocked. You might want to consider to move these initialization outside of protect section.\nIsn't ConcurrentSkipListMap already thread safe when you read? Probably only the iteration should be protected. I think the goal is avoid lock a large section of code not to let another thread to wait on.", "author": "zzzming", "createdAt": "2020-02-13T14:24:32Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -2246,11 +2317,44 @@ public void deleteComplete(int rc, Object ctx) {\n         }\n     }\n \n+    private List<MLDataFormats.BatchDeletedIndexInfo> buildBatchDeletedIndexInfoList() {\n+        lock.readLock().lock();\n+        try {\n+            if (!config.isBatchIndexDeleteEnabled() || batchDeletedIndexes.isEmpty()) {\n+                return Collections.emptyList();\n+            }\n+            MLDataFormats.NestedPositionInfo.Builder nestedPositionBuilder = MLDataFormats.NestedPositionInfo\n+                .newBuilder();\n+            MLDataFormats.BatchDeletedIndexInfo.Builder batchDeletedIndexInfoBuilder = MLDataFormats.BatchDeletedIndexInfo\n+                .newBuilder();\n+            List<MLDataFormats.BatchDeletedIndexInfo> result = Lists.newArrayList();", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\nindex 103c0e68847..80b83cc2a09 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\n@@ -2317,36 +2328,30 @@ public class ManagedCursorImpl implements ManagedCursor {\n         }\n     }\n \n-    private List<MLDataFormats.BatchDeletedIndexInfo> buildBatchDeletedIndexInfoList() {\n-        lock.readLock().lock();\n-        try {\n-            if (!config.isBatchIndexDeleteEnabled() || batchDeletedIndexes.isEmpty()) {\n-                return Collections.emptyList();\n-            }\n-            MLDataFormats.NestedPositionInfo.Builder nestedPositionBuilder = MLDataFormats.NestedPositionInfo\n-                .newBuilder();\n-            MLDataFormats.BatchDeletedIndexInfo.Builder batchDeletedIndexInfoBuilder = MLDataFormats.BatchDeletedIndexInfo\n-                .newBuilder();\n-            List<MLDataFormats.BatchDeletedIndexInfo> result = Lists.newArrayList();\n-            for (Map.Entry<PositionImpl, BitSet> entry : batchDeletedIndexes.entrySet()) {\n-                nestedPositionBuilder.setLedgerId(entry.getKey().getLedgerId());\n-                nestedPositionBuilder.setEntryId(entry.getKey().getEntryId());\n-                batchDeletedIndexInfoBuilder.setPosition(nestedPositionBuilder.build());\n-                long[] array = entry.getValue().toLongArray();\n-                List<Long> ackBitSet = new ArrayList<>(array.length);\n-                for (long l : array) {\n-                    ackBitSet.add(l);\n-                }\n-                batchDeletedIndexInfoBuilder.addAllAckBitSet(ackBitSet);\n-                result.add(batchDeletedIndexInfoBuilder.build());\n-                if (result.size() >= config.getMaxBatchDeletedIndexToPersist()) {\n-                    break;\n-                }\n+    private List<MLDataFormats.BatchedEntryDeletionIndexInfo> buildBatchEntryDeletionIndexInfoList() {\n+        if (!config.isDeletionAtBatchIndexLevelEnabled() || batchDeletedIndexes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+        MLDataFormats.NestedPositionInfo.Builder nestedPositionBuilder = MLDataFormats.NestedPositionInfo\n+            .newBuilder();\n+        MLDataFormats.BatchedEntryDeletionIndexInfo.Builder batchDeletedIndexInfoBuilder = MLDataFormats.BatchedEntryDeletionIndexInfo\n+            .newBuilder();\n+        List<MLDataFormats.BatchedEntryDeletionIndexInfo> result = Lists.newArrayList();\n+        Iterator<Map.Entry<PositionImpl, BitSetRecyclable>> iterator = batchDeletedIndexes.entrySet().iterator();\n+        while (iterator.hasNext() && result.size() < config.getMaxBatchDeletedIndexToPersist()) {\n+            Map.Entry<PositionImpl, BitSetRecyclable> entry = iterator.next();\n+            nestedPositionBuilder.setLedgerId(entry.getKey().getLedgerId());\n+            nestedPositionBuilder.setEntryId(entry.getKey().getEntryId());\n+            batchDeletedIndexInfoBuilder.setPosition(nestedPositionBuilder.build());\n+            long[] array = entry.getValue().toLongArray();\n+            List<Long> deleteSet = new ArrayList<>(array.length);\n+            for (long l : array) {\n+                deleteSet.add(l);\n             }\n-            return result;\n-        } finally {\n-            lock.readLock().unlock();\n+            batchDeletedIndexInfoBuilder.addAllDeleteSet(deleteSet);\n+            result.add(batchDeletedIndexInfoBuilder.build());\n         }\n+        return result;\n     }\n \n     void persistPositionToLedger(final LedgerHandle lh, MarkDeleteEntry mdEntry, final VoidCallback callback) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg5MzI3OA==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378893278", "bodyText": "Ditto. I think only batchDeleteIndexes.get() part should be locked. Again, double check with concurrentSkipList get() if it is already a thread safe data struct in terms of read. I think it should although I have never used this map collection.", "author": "zzzming", "createdAt": "2020-02-13T14:27:53Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -2631,5 +2735,16 @@ public void trimDeletedEntries(List<Entry> entries) {\n                 || individualDeletedMessages.contains(entry.getLedgerId(), entry.getEntryId()));\n     }\n \n+    @Override\n+    public long[] getDeletedBatchIndexesLongArray(PositionImpl position) {\n+        lock.readLock().lock();\n+        try {\n+            BitSet bitSet = batchDeletedIndexes.get(position);", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\nindex 103c0e68847..80b83cc2a09 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\n@@ -2736,14 +2741,9 @@ public class ManagedCursorImpl implements ManagedCursor {\n     }\n \n     @Override\n-    public long[] getDeletedBatchIndexesLongArray(PositionImpl position) {\n-        lock.readLock().lock();\n-        try {\n-            BitSet bitSet = batchDeletedIndexes.get(position);\n-            return bitSet == null ? null : bitSet.toLongArray();\n-        } finally {\n-            lock.readLock().unlock();\n-        }\n+    public long[] getDeletedBatchIndexesAsLongArray(PositionImpl position) {\n+        BitSetRecyclable bitSet = batchDeletedIndexes.get(position);\n+        return bitSet == null ? null : bitSet.toLongArray();\n     }\n \n     private static final Logger log = LoggerFactory.getLogger(ManagedCursorImpl.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODkzNDQ1Mw==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378934453", "bodyText": "How about using stream in Java 8?\nreturn Arrays.stream(a).boxed().collect(Collectors.toList())\nActually the entire function can be\nreturn array == null ? Collections.emptyList() : Arrays.stream(a).boxed().collect(Collectors.toList())\nCollections.emptyList() returns an immutable list however new ArrayList is mutable. So I do not know whether you would like to have a mutable or immutable list. This needs to be clarified.", "author": "zzzming", "createdAt": "2020-02-13T15:30:56Z", "path": "pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.common.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Safe collection utils.\n+ */\n+public class SafeCollectionUtils {\n+\n+    public static List<Long> longArrayToList(long[] array) {\n+        if (array == null || array.length == 0) {\n+            return Collections.emptyList();\n+        } else {\n+            List<Long> result = new ArrayList<>(array.length);\n+            for (long l : array) {\n+                result.add(l);\n+            }\n+            return result;", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java b/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java\nindex 180e59b6e5c..21488fb3e5a 100644\n--- a/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java\n+++ b/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java\n\n@@ -18,9 +18,10 @@\n  */\n package org.apache.pulsar.common.util;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n /**\n  * Safe collection utils.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk0NzE0OQ==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378947149", "bodyText": "Again consider using stream\nreturn list == null ? new long[0] : list.stream().mapToLong(l->l).toArray()\nProbably there is no need to have a file to deal with primitive type array and list conversion. Does Apache common lang or Guava have library for that?", "author": "zzzming", "createdAt": "2020-02-13T15:49:42Z", "path": "pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.common.util;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Safe collection utils.\n+ */\n+public class SafeCollectionUtils {\n+\n+    public static List<Long> longArrayToList(long[] array) {\n+        if (array == null || array.length == 0) {\n+            return Collections.emptyList();\n+        } else {\n+            List<Long> result = new ArrayList<>(array.length);\n+            for (long l : array) {\n+                result.add(l);\n+            }\n+            return result;\n+        }\n+    }\n+\n+    public static long[] longListToArray(List<Long> list) {\n+        if (list == null || list.size() == 0) {\n+            return new long[0];\n+        } else {\n+            long[] array = new long[list.size()];\n+            for (int i = 0; i < list.size(); i++) {\n+                array[i] = list.get(i);\n+            }\n+            return array;\n+        }", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java b/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java\nindex 180e59b6e5c..21488fb3e5a 100644\n--- a/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java\n+++ b/pulsar-common/src/main/java/org/apache/pulsar/common/util/SafeCollectionUtils.java\n\n@@ -18,9 +18,10 @@\n  */\n package org.apache.pulsar.common.util;\n \n-import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n /**\n  * Safe collection utils.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1NDgwNA==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378954804", "bodyText": "Double ;; You might want to do a global replacement since these are in multiple places.", "author": "zzzming", "createdAt": "2020-02-13T16:00:53Z", "path": "pulsar-common/src/main/java/org/apache/pulsar/common/api/proto/PulsarApi.java", "diffHunk": "@@ -1209,11 +1214,26 @@ public int getBatchIndex() {\n       return batchIndex_;\n     }\n     \n+    // repeated int64 ackSet = 5;\n+    public static final int ACKSET_FIELD_NUMBER = 5;\n+    private java.util.List<java.lang.Long> ackSet_;\n+    public java.util.List<java.lang.Long>\n+        getAckSetList() {\n+      return ackSet_;\n+    }\n+    public int getAckSetCount() {\n+      return ackSet_.size();\n+    }\n+    public long getAckSet(int index) {\n+      return ackSet_.get(index);\n+    }\n+    \n     private void initFields() {\n       ledgerId_ = 0L;\n       entryId_ = 0L;\n       partition_ = -1;\n       batchIndex_ = -1;\n+      ackSet_ = java.util.Collections.emptyList();;", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYyMDE3OQ==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r380620179", "bodyText": "The PulsarApi.java is generated by a proto tool. So I won\u2019t do it manually here, it's better to improve the generation tool.", "author": "codelipenghui", "createdAt": "2020-02-18T11:41:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk1NDgwNA=="}], "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/pulsar-common/src/main/java/org/apache/pulsar/common/api/proto/PulsarApi.java b/pulsar-common/src/main/java/org/apache/pulsar/common/api/proto/PulsarApi.java\nindex 0869499ce08..0ebea6af41f 100644\n--- a/pulsar-common/src/main/java/org/apache/pulsar/common/api/proto/PulsarApi.java\n+++ b/pulsar-common/src/main/java/org/apache/pulsar/common/api/proto/PulsarApi.java\n\n@@ -1214,8 +1214,8 @@ public final class PulsarApi {\n       return batchIndex_;\n     }\n     \n-    // repeated int64 ackSet = 5;\n-    public static final int ACKSET_FIELD_NUMBER = 5;\n+    // repeated int64 ack_set = 5;\n+    public static final int ACK_SET_FIELD_NUMBER = 5;\n     private java.util.List<java.lang.Long> ackSet_;\n     public java.util.List<java.lang.Long>\n         getAckSetList() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk2MjI4OA==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378962288", "bodyText": "Would this case be covered if the total number of messages in a batch is greater the allowed number of permits? Or is this not even possible?", "author": "zzzming", "createdAt": "2020-02-13T16:12:34Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -219,7 +226,8 @@ public ChannelPromise sendMessages(final List<Entry> entries, EntryBatchSizes ba\n         }\n \n         // reduce permit and increment unackedMsg count with total number of messages in batch-msgs\n-        MESSAGE_PERMITS_UPDATER.addAndGet(this, -totalMessages);\n+        int ackedCount = batchIndexesAcks == null ? 0 : batchIndexesAcks.getTotalAckedIndexCount();\n+        MESSAGE_PERMITS_UPDATER.addAndGet(this, ackedCount - totalMessages);", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYyMDkzNg==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r380620936", "bodyText": "The batch size can greater than available permits and already handled at the client size.", "author": "codelipenghui", "createdAt": "2020-02-18T11:42:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk2MjI4OA=="}], "type": "inlineReview", "revised_code": {"commit": "994d5c9257d393c15dc369addf626676b534467e", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex 8a2e64d6949..a7cd9eff971 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -230,6 +235,8 @@ public class Consumer {\n         MESSAGE_PERMITS_UPDATER.addAndGet(this, ackedCount - totalMessages);\n         incrementUnackedMessages(totalMessages);\n         msgOut.recordMultipleEvents(totalMessages, totalBytes);\n+        msgOutCounter.add(totalMessages);\n+        bytesOutCounter.add(totalBytes);\n \n         ctx.channel().eventLoop().execute(() -> {\n             for (int i = 0; i < entries.size(); i++) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk2NjcwMw==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r378966703", "bodyText": "If this is a feature has to enabled on the broker, is there a way for consumer to know or set such feature is supported? I think the problem comes how to help troubleshooting when both broker and consumer need to support this.", "author": "zzzming", "createdAt": "2020-02-13T16:19:35Z", "path": "pulsar-broker-common/src/main/java/org/apache/pulsar/broker/ServiceConfiguration.java", "diffHunk": "@@ -171,6 +171,9 @@\n             + \" affecting the accuracy of the delivery time compared to the scheduled time. Default is 1 second.\")\n     private long delayedDeliveryTickTimeMillis = 1000;\n \n+    @FieldContext(category = CATEGORY_SERVER, doc = \"Whether to enable the acknowledge of batch local index\")\n+    private boolean batchIndexAcknowledgeEnable = true;", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDYyNzUxMQ==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r380627511", "bodyText": "Should we consider adding a flag to enable or disable at consumer side? I think this feature does not introduce too much overhead on the consumer side.\nFor troubleshooting, users just to ensure that their brokers are enabled this feature and the client version is 2.6.0", "author": "codelipenghui", "createdAt": "2020-02-18T11:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk2NjcwMw=="}], "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/pulsar-broker-common/src/main/java/org/apache/pulsar/broker/ServiceConfiguration.java b/pulsar-broker-common/src/main/java/org/apache/pulsar/broker/ServiceConfiguration.java\nindex 3f66e0bb46f..3cb5ce862b2 100644\n--- a/pulsar-broker-common/src/main/java/org/apache/pulsar/broker/ServiceConfiguration.java\n+++ b/pulsar-broker-common/src/main/java/org/apache/pulsar/broker/ServiceConfiguration.java\n\n@@ -172,7 +173,7 @@ public class ServiceConfiguration implements PulsarConfiguration {\n     private long delayedDeliveryTickTimeMillis = 1000;\n \n     @FieldContext(category = CATEGORY_SERVER, doc = \"Whether to enable the acknowledge of batch local index\")\n-    private boolean batchIndexAcknowledgeEnable = true;\n+    private boolean acknowledgmentAtBatchIndexLevelEnabled = false;\n \n     @FieldContext(\n         category = CATEGORY_WEBSOCKET,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NjcyOQ==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379146729", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                long[] getDeletedBatchIndexesLongArray(PositionImpl position);\n          \n          \n            \n                long[] getDeletedBatchIndexesAsLongArray(PositionImpl position);", "author": "sijie", "createdAt": "2020-02-13T22:07:57Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedCursor.java", "diffHunk": "@@ -608,4 +608,9 @@ void asyncFindNewestMatching(FindPositionConstraint constraint, Predicate<Entry>\n      * Trim delete entries for the given entries\n      */\n     void trimDeletedEntries(List<Entry> entries);\n+\n+    /**\n+     * Get deleted batch indexes list for a batch message.\n+     */\n+    long[] getDeletedBatchIndexesLongArray(PositionImpl position);", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedCursor.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedCursor.java\nindex be25695c263..818054d0a64 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedCursor.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedCursor.java\n\n@@ -612,5 +613,5 @@ public interface ManagedCursor {\n     /**\n      * Get deleted batch indexes list for a batch message.\n      */\n-    long[] getDeletedBatchIndexesLongArray(PositionImpl position);\n+    long[] getDeletedBatchIndexesAsLongArray(PositionImpl position);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NjkxMg==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379146912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean batchIndexDeleteEnabled = true;\n          \n          \n            \n                private boolean deletionAtBatchIndexLevelEnabled = true;", "author": "sijie", "createdAt": "2020-02-13T22:08:22Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedLedgerConfig.java", "diffHunk": "@@ -39,6 +39,8 @@\n \n     private boolean createIfMissing = true;\n     private int maxUnackedRangesToPersist = 10000;\n+    private int maxBatchDeletedIndexToPersist = 10000;\n+    private boolean batchIndexDeleteEnabled = true;", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedLedgerConfig.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedLedgerConfig.java\nindex 6981aaeef31..22bd605f6a3 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedLedgerConfig.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/ManagedLedgerConfig.java\n\n@@ -40,7 +40,7 @@ public class ManagedLedgerConfig {\n     private boolean createIfMissing = true;\n     private int maxUnackedRangesToPersist = 10000;\n     private int maxBatchDeletedIndexToPersist = 10000;\n-    private boolean batchIndexDeleteEnabled = true;\n+    private boolean deletionAtBatchIndexLevelEnabled = true;\n     private int maxUnackedRangesToPersistInZk = 1000;\n     private int maxEntriesPerLedger = 50000;\n     private int maxSizePerLedgerMb = 100;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzY2Nw==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379147667", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Maintain the indexes deleted status of batch messages that not deleted completely\n          \n          \n            \n                // Maintain the deletion status for batch messages", "author": "sijie", "createdAt": "2020-02-13T22:10:14Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -148,6 +151,10 @@\n         return position;\n     };\n     private final LongPairRangeSet<PositionImpl> individualDeletedMessages;\n+\n+    // Maintain the indexes deleted status of batch messages that not deleted completely", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\nindex 103c0e68847..80b83cc2a09 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\n@@ -152,9 +153,9 @@ public class ManagedCursorImpl implements ManagedCursor {\n     };\n     private final LongPairRangeSet<PositionImpl> individualDeletedMessages;\n \n-    // Maintain the indexes deleted status of batch messages that not deleted completely\n-    // (ledgerId, entryId) -> deleted indexes\n-    private final ConcurrentSkipListMap<PositionImpl, BitSet> batchDeletedIndexes;\n+    // Maintain the deletion status for batch messages\n+    // (ledgerId, entryId) -> deletion indexes\n+    private final ConcurrentSkipListMap<PositionImpl, BitSetRecyclable> batchDeletedIndexes;\n     private final ReadWriteLock lock = new ReentrantReadWriteLock();\n \n     private RateLimiter markDeleteLimiter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzgwOQ==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379147809", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // (ledgerId, entryId) -> deleted indexes\n          \n          \n            \n                // (ledgerId, entryId) -> deletion indexes", "author": "sijie", "createdAt": "2020-02-13T22:10:32Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -148,6 +151,10 @@\n         return position;\n     };\n     private final LongPairRangeSet<PositionImpl> individualDeletedMessages;\n+\n+    // Maintain the indexes deleted status of batch messages that not deleted completely\n+    // (ledgerId, entryId) -> deleted indexes", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\nindex 103c0e68847..80b83cc2a09 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\n@@ -152,9 +153,9 @@ public class ManagedCursorImpl implements ManagedCursor {\n     };\n     private final LongPairRangeSet<PositionImpl> individualDeletedMessages;\n \n-    // Maintain the indexes deleted status of batch messages that not deleted completely\n-    // (ledgerId, entryId) -> deleted indexes\n-    private final ConcurrentSkipListMap<PositionImpl, BitSet> batchDeletedIndexes;\n+    // Maintain the deletion status for batch messages\n+    // (ledgerId, entryId) -> deletion indexes\n+    private final ConcurrentSkipListMap<PositionImpl, BitSetRecyclable> batchDeletedIndexes;\n     private final ReadWriteLock lock = new ReentrantReadWriteLock();\n \n     private RateLimiter markDeleteLimiter;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NDk5Nw==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379154997", "bodyText": "Why do we need a concurrent bit set?", "author": "sijie", "createdAt": "2020-02-13T22:27:50Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java", "diffHunk": "@@ -103,22 +114,48 @@ public void addAcknowledgment(MessageIdImpl msgId, AckType ackType, Map<String,\n             // uncommon condition since it's only used for the compaction subscription.\n             doImmediateAck(msgId, ackType, properties);\n         } else if (ackType == AckType.Cumulative) {\n-            doCumulativeAck(msgId);\n+            doCumulativeAck(msgId, null);\n         } else {\n             // Individual ack\n             pendingIndividualAcks.add(msgId);\n+            pendingIndividualBatchIndexAcks.remove(msgId);\n             if (pendingIndividualAcks.size() >= MAX_ACK_GROUP_SIZE) {\n                 flush();\n             }\n         }\n     }\n \n-    private void doCumulativeAck(MessageIdImpl msgId) {\n+    @Override\n+    public void addBatchIndexAcknowledgment(BatchMessageIdImpl msgId, int batchIndex, int batchSize, AckType ackType, Map<String, Long> properties) {\n+        if (acknowledgementGroupTimeMicros == 0 || !properties.isEmpty()) {\n+            doImmediateBatchIndexAck(msgId, batchIndex, batchSize, ackType, properties);\n+        } else if (ackType == AckType.Cumulative) {\n+            ConcurrentBitSet bitSet = new ConcurrentBitSet(batchSize);", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java\nindex 3ab3ad0a962..045419593b9 100644\n--- a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java\n+++ b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java\n\n@@ -130,14 +129,14 @@ public class PersistentAcknowledgmentsGroupingTracker implements Acknowledgments\n         if (acknowledgementGroupTimeMicros == 0 || !properties.isEmpty()) {\n             doImmediateBatchIndexAck(msgId, batchIndex, batchSize, ackType, properties);\n         } else if (ackType == AckType.Cumulative) {\n-            ConcurrentBitSet bitSet = new ConcurrentBitSet(batchSize);\n+            BitSetRecyclable bitSet = BitSetRecyclable.create();\n             bitSet.set(0, batchSize);\n             bitSet.clear(0, batchIndex + 1);\n             doCumulativeAck(msgId, bitSet);\n         } else if (ackType == AckType.Individual) {\n-            ConcurrentBitSet bitSet = pendingIndividualBatchIndexAcks.computeIfAbsent(\n+            ConcurrentBitSetRecyclable bitSet = pendingIndividualBatchIndexAcks.computeIfAbsent(\n                 new MessageIdImpl(msgId.getLedgerId(), msgId.getEntryId(), msgId.getPartitionIndex()), (v) -> {\n-                    ConcurrentBitSet value = new ConcurrentBitSet(batchSize);\n+                    ConcurrentBitSetRecyclable value = ConcurrentBitSetRecyclable.create();\n                     value.set(0, batchSize + 1);\n                     value.clear(batchIndex);\n                     return value;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NzcwOA==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379157708", "bodyText": "bookkeeper has a pretty efficient AckSet / WriteSet implementation that can avoid producing a lot of garbages. I think we should leverage the implementation there - https://github.com/apache/bookkeeper/blob/master/bookkeeper-server/src/main/java/org/apache/bookkeeper/client/RoundRobinDistributionSchedule.java#L76", "author": "sijie", "createdAt": "2020-02-13T22:34:27Z", "path": "pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java", "diffHunk": "@@ -57,23 +62,29 @@\n      * Latest cumulative ack sent to broker\n      */\n     private volatile MessageIdImpl lastCumulativeAck = (MessageIdImpl) MessageId.earliest;\n+    private volatile ConcurrentBitSet lastCumulativeAckSet = null;\n     private volatile boolean cumulativeAckFlushRequired = false;\n \n     private static final AtomicReferenceFieldUpdater<PersistentAcknowledgmentsGroupingTracker, MessageIdImpl> LAST_CUMULATIVE_ACK_UPDATER = AtomicReferenceFieldUpdater\n             .newUpdater(PersistentAcknowledgmentsGroupingTracker.class, MessageIdImpl.class, \"lastCumulativeAck\");\n+    private static final AtomicReferenceFieldUpdater<PersistentAcknowledgmentsGroupingTracker, ConcurrentBitSet> LAST_CUMULATIVE_ACK_SET_UPDATER = AtomicReferenceFieldUpdater\n+        .newUpdater(PersistentAcknowledgmentsGroupingTracker.class, ConcurrentBitSet.class, \"lastCumulativeAckSet\");\n+\n \n     /**\n      * This is a set of all the individual acks that the application has issued and that were not already sent to\n      * broker.\n      */\n     private final ConcurrentSkipListSet<MessageIdImpl> pendingIndividualAcks;\n+    private final ConcurrentHashMap<MessageIdImpl, ConcurrentBitSet> pendingIndividualBatchIndexAcks;", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java\nindex 3ab3ad0a962..045419593b9 100644\n--- a/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java\n+++ b/pulsar-client/src/main/java/org/apache/pulsar/client/impl/PersistentAcknowledgmentsGroupingTracker.java\n\n@@ -62,13 +61,13 @@ public class PersistentAcknowledgmentsGroupingTracker implements Acknowledgments\n      * Latest cumulative ack sent to broker\n      */\n     private volatile MessageIdImpl lastCumulativeAck = (MessageIdImpl) MessageId.earliest;\n-    private volatile ConcurrentBitSet lastCumulativeAckSet = null;\n+    private volatile BitSetRecyclable lastCumulativeAckSet = null;\n     private volatile boolean cumulativeAckFlushRequired = false;\n \n     private static final AtomicReferenceFieldUpdater<PersistentAcknowledgmentsGroupingTracker, MessageIdImpl> LAST_CUMULATIVE_ACK_UPDATER = AtomicReferenceFieldUpdater\n             .newUpdater(PersistentAcknowledgmentsGroupingTracker.class, MessageIdImpl.class, \"lastCumulativeAck\");\n-    private static final AtomicReferenceFieldUpdater<PersistentAcknowledgmentsGroupingTracker, ConcurrentBitSet> LAST_CUMULATIVE_ACK_SET_UPDATER = AtomicReferenceFieldUpdater\n-        .newUpdater(PersistentAcknowledgmentsGroupingTracker.class, ConcurrentBitSet.class, \"lastCumulativeAckSet\");\n+    private static final AtomicReferenceFieldUpdater<PersistentAcknowledgmentsGroupingTracker, BitSetRecyclable> LAST_CUMULATIVE_ACK_SET_UPDATER = AtomicReferenceFieldUpdater\n+        .newUpdater(PersistentAcknowledgmentsGroupingTracker.class, BitSetRecyclable.class, \"lastCumulativeAckSet\");\n \n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1ODY5OQ==", "url": "https://github.com/apache/pulsar/pull/6052#discussion_r379158699", "bodyText": "Same comment as I made to client side change. We should consider re-using some of the AckSet implementation in bookkeeper client.", "author": "sijie", "createdAt": "2020-02-13T22:37:11Z", "path": "managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java", "diffHunk": "@@ -148,6 +151,10 @@\n         return position;\n     };\n     private final LongPairRangeSet<PositionImpl> individualDeletedMessages;\n+\n+    // Maintain the indexes deleted status of batch messages that not deleted completely\n+    // (ledgerId, entryId) -> deleted indexes\n+    private final ConcurrentSkipListMap<PositionImpl, BitSet> batchDeletedIndexes;", "originalCommit": "c23b9e84ac803390747bba80bf76ebcabf87e109", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "00f08652c000dc4700761fdc06c6d37e4084f514", "chunk": "diff --git a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\nindex 103c0e68847..80b83cc2a09 100644\n--- a/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n+++ b/managed-ledger/src/main/java/org/apache/bookkeeper/mledger/impl/ManagedCursorImpl.java\n\n@@ -152,9 +153,9 @@ public class ManagedCursorImpl implements ManagedCursor {\n     };\n     private final LongPairRangeSet<PositionImpl> individualDeletedMessages;\n \n-    // Maintain the indexes deleted status of batch messages that not deleted completely\n-    // (ledgerId, entryId) -> deleted indexes\n-    private final ConcurrentSkipListMap<PositionImpl, BitSet> batchDeletedIndexes;\n+    // Maintain the deletion status for batch messages\n+    // (ledgerId, entryId) -> deletion indexes\n+    private final ConcurrentSkipListMap<PositionImpl, BitSetRecyclable> batchDeletedIndexes;\n     private final ReadWriteLock lock = new ReentrantReadWriteLock();\n \n     private RateLimiter markDeleteLimiter;\n"}}, {"oid": "00f08652c000dc4700761fdc06c6d37e4084f514", "url": "https://github.com/apache/pulsar/commit/00f08652c000dc4700761fdc06c6d37e4084f514", "message": "Introduce BitSetRecyclable that leverage with netty recycler", "committedDate": "2020-02-19T12:14:36Z", "type": "forcePushed"}, {"oid": "f69fc22983033c72540bb30f45790e1bb1468381", "url": "https://github.com/apache/pulsar/commit/f69fc22983033c72540bb30f45790e1bb1468381", "message": "Add support for batch local index ack", "committedDate": "2020-04-24T07:15:28Z", "type": "commit"}, {"oid": "0bd8eabfceb01251f998630e861f960db0bcab52", "url": "https://github.com/apache/pulsar/commit/0bd8eabfceb01251f998630e861f960db0bcab52", "message": "Fix comments", "committedDate": "2020-04-24T07:26:15Z", "type": "commit"}, {"oid": "6c8725c7ad4e9fcc50e6f1c7918f60a536d158d2", "url": "https://github.com/apache/pulsar/commit/6c8725c7ad4e9fcc50e6f1c7918f60a536d158d2", "message": "Fix comments", "committedDate": "2020-04-24T07:26:15Z", "type": "commit"}, {"oid": "0799dfd8720d420ae34d95b23b826d3a5929e147", "url": "https://github.com/apache/pulsar/commit/0799dfd8720d420ae34d95b23b826d3a5929e147", "message": "Fix checkstyle", "committedDate": "2020-04-24T07:26:15Z", "type": "commit"}, {"oid": "cab09482c608d202922983321a78ef63465a2853", "url": "https://github.com/apache/pulsar/commit/cab09482c608d202922983321a78ef63465a2853", "message": "Fix unit test", "committedDate": "2020-04-24T07:26:15Z", "type": "commit"}, {"oid": "e320c6f3393daf0780cc8b1e17f1c8bae6222b63", "url": "https://github.com/apache/pulsar/commit/e320c6f3393daf0780cc8b1e17f1c8bae6222b63", "message": "Generate PulsarApi.java", "committedDate": "2020-04-24T07:26:15Z", "type": "commit"}, {"oid": "76217ac6147160ef79a7dc5b604ada6604c08f79", "url": "https://github.com/apache/pulsar/commit/76217ac6147160ef79a7dc5b604ada6604c08f79", "message": "Fix checkstyle", "committedDate": "2020-04-24T07:26:15Z", "type": "commit"}, {"oid": "dd28770994dc3ba6911838eabb8d633327bf7598", "url": "https://github.com/apache/pulsar/commit/dd28770994dc3ba6911838eabb8d633327bf7598", "message": "Apply comments", "committedDate": "2020-04-24T07:28:07Z", "type": "commit"}, {"oid": "fa2b9f707bb1e4e49e8e01ba7f9c5651ee807f43", "url": "https://github.com/apache/pulsar/commit/fa2b9f707bb1e4e49e8e01ba7f9c5651ee807f43", "message": "Apply comments", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "a75e9f653532f724422f3c327ca9d48b5719b1e2", "url": "https://github.com/apache/pulsar/commit/a75e9f653532f724422f3c327ca9d48b5719b1e2", "message": "Fix checkstyle", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "aa388f3dc85e9f849cba63d7df05c74382660ef8", "url": "https://github.com/apache/pulsar/commit/aa388f3dc85e9f849cba63d7df05c74382660ef8", "message": "Fix tests.", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "af497bd7077ebeac08b9b6f44face015c94e85ba", "url": "https://github.com/apache/pulsar/commit/af497bd7077ebeac08b9b6f44face015c94e85ba", "message": "Introduce BitSetRecyclable that leverage with netty recycler", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "26816c02195fc844f0caaa84d1c3038004a01c37", "url": "https://github.com/apache/pulsar/commit/26816c02195fc844f0caaa84d1c3038004a01c37", "message": "Check not null for recycle.", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "ae832ffe0951dfbd559e8401820eeb3ed5816a55", "url": "https://github.com/apache/pulsar/commit/ae832ffe0951dfbd559e8401820eeb3ed5816a55", "message": "Fix tests.", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "a297843b47e143a1a26712847932d897c678c336", "url": "https://github.com/apache/pulsar/commit/a297843b47e143a1a26712847932d897c678c336", "message": "fix tests.", "committedDate": "2020-04-24T07:28:08Z", "type": "commit"}, {"oid": "a297843b47e143a1a26712847932d897c678c336", "url": "https://github.com/apache/pulsar/commit/a297843b47e143a1a26712847932d897c678c336", "message": "fix tests.", "committedDate": "2020-04-24T07:28:08Z", "type": "forcePushed"}, {"oid": "75aec3966e5f02b3f421fcba92bb771871965eeb", "url": "https://github.com/apache/pulsar/commit/75aec3966e5f02b3f421fcba92bb771871965eeb", "message": "Fix test.", "committedDate": "2020-04-24T08:00:31Z", "type": "commit"}, {"oid": "cca1a5a0c83104d26730408a827331008f9eaee1", "url": "https://github.com/apache/pulsar/commit/cca1a5a0c83104d26730408a827331008f9eaee1", "message": "Remove unused tests.", "committedDate": "2020-04-24T08:03:06Z", "type": "commit"}, {"oid": "36d899ac47a4c1b52a1cbfa080b7ba5c4df4f4db", "url": "https://github.com/apache/pulsar/commit/36d899ac47a4c1b52a1cbfa080b7ba5c4df4f4db", "message": "Remove unused tests.", "committedDate": "2020-04-24T08:05:54Z", "type": "commit"}, {"oid": "994d5c9257d393c15dc369addf626676b534467e", "url": "https://github.com/apache/pulsar/commit/994d5c9257d393c15dc369addf626676b534467e", "message": "Merge remote-tracking branch 'apache/master' into batch_index_ack", "committedDate": "2020-05-19T09:56:11Z", "type": "commit"}, {"oid": "ef9929a35ccad0e91d2fd86ff84ddc48de10cc58", "url": "https://github.com/apache/pulsar/commit/ef9929a35ccad0e91d2fd86ff84ddc48de10cc58", "message": "Fix tests.", "committedDate": "2020-05-19T10:18:43Z", "type": "commit"}, {"oid": "64af907d453ce183a61985429668b8e67b48c196", "url": "https://github.com/apache/pulsar/commit/64af907d453ce183a61985429668b8e67b48c196", "message": "Merge branch 'master' into batch_index_ack", "committedDate": "2020-05-20T11:40:07Z", "type": "commit"}, {"oid": "d6433aaba555ff7cc1cb0be881c352d50d2b39f4", "url": "https://github.com/apache/pulsar/commit/d6433aaba555ff7cc1cb0be881c352d50d2b39f4", "message": "Merge remote-tracking branch 'apache/master' into batch_index_ack", "committedDate": "2020-05-22T10:21:34Z", "type": "commit"}, {"oid": "f248dc8fd279e220bf3aafab7622080625cf69f5", "url": "https://github.com/apache/pulsar/commit/f248dc8fd279e220bf3aafab7622080625cf69f5", "message": "Fix tests", "committedDate": "2020-05-27T09:31:31Z", "type": "commit"}, {"oid": "e3f9e7259571244c0c49f8c075b34323084068b6", "url": "https://github.com/apache/pulsar/commit/e3f9e7259571244c0c49f8c075b34323084068b6", "message": "Merge remote-tracking branch 'apache/master' into batch_index_ack", "committedDate": "2020-05-28T00:27:13Z", "type": "commit"}, {"oid": "15f39790e19f8a7904ce5f1e19a432181dc75d4b", "url": "https://github.com/apache/pulsar/commit/15f39790e19f8a7904ce5f1e19a432181dc75d4b", "message": "Fix tests.", "committedDate": "2020-05-28T10:30:08Z", "type": "commit"}, {"oid": "4d65aa6eb64c91f2c040c4c58f696f3bd4c37b24", "url": "https://github.com/apache/pulsar/commit/4d65aa6eb64c91f2c040c4c58f696f3bd4c37b24", "message": "Merge remote-tracking branch 'apache/master' into batch_index_ack", "committedDate": "2020-05-29T06:54:44Z", "type": "commit"}, {"oid": "9789f396182812c6d33de91e9bf1fb1bba55065b", "url": "https://github.com/apache/pulsar/commit/9789f396182812c6d33de91e9bf1fb1bba55065b", "message": "Merge branch 'master' into batch_index_ack", "committedDate": "2020-05-29T11:52:56Z", "type": "commit"}]}