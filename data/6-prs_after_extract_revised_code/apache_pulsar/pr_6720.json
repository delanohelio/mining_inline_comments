{"pr_number": 6720, "pr_title": "Make ServerCnx, Producer and Consumer independent of Netty", "pr_createdAt": "2020-04-12T13:36:15Z", "pr_url": "https://github.com/apache/pulsar/pull/6720", "timeline": [{"oid": "c420382d7ab61015e53383a185f404a14c7be8ae", "url": "https://github.com/apache/pulsar/commit/c420382d7ab61015e53383a185f404a14c7be8ae", "message": "Make ServerCnx and Producer independent of Netty\n* ServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter\n* Producer is changed into an abstract class with a PulsarProducer implementation\nthat sends the frames through the Pulsar bnary protocol", "committedDate": "2020-04-12T13:43:29Z", "type": "forcePushed"}, {"oid": "47262e0b92c2dcbb6c96a2059abec915c9209a24", "url": "https://github.com/apache/pulsar/commit/47262e0b92c2dcbb6c96a2059abec915c9209a24", "message": "Make ServerCnx and Producer independent of Netty\n* ServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter\n* Producer is changed into an abstract class with a PulsarProducer implementation\nthat sends the frames through the Pulsar bnary protocol", "committedDate": "2020-04-12T14:03:40Z", "type": "forcePushed"}, {"oid": "2bc4ee69de1e583b1cdbe29a07fc341ccec963ba", "url": "https://github.com/apache/pulsar/commit/2bc4ee69de1e583b1cdbe29a07fc341ccec963ba", "message": "Make ServerCnx and Producer independent of Netty\n* ServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter\n* Producer is changed into an abstract class with a PulsarProducer implementation\nthat sends the frames through the Pulsar bnary protocol", "committedDate": "2020-04-12T14:12:09Z", "type": "forcePushed"}, {"oid": "dffe5089f722a45c644e56919045400c3f2efb6f", "url": "https://github.com/apache/pulsar/commit/dffe5089f722a45c644e56919045400c3f2efb6f", "message": "Make ServerCnx and Producer independent of Netty\n* ServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter\n* Producer is changed into an abstract class with a PulsarProducer implementation\nthat sends the frames through the Pulsar bnary protocol", "committedDate": "2020-04-12T14:18:38Z", "type": "forcePushed"}, {"oid": "d4946240fcd8dbaa001615de923a8c2f020747b2", "url": "https://github.com/apache/pulsar/commit/d4946240fcd8dbaa001615de923a8c2f020747b2", "message": "Make ServerCnx and Producer independent of Netty\n* ServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter\n* Producer is changed into an abstract class with a PulsarProducer implementation\nthat sends the frames through the Pulsar bnary protocol", "committedDate": "2020-04-12T14:26:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzIwNjQzOA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r407206438", "bodyText": "beforePublish makes some checks.\npublishMessageToTopic shouldn't be called if those checks fail.", "author": "cbornet", "createdAt": "2020-04-12T14:31:34Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Producer.java", "diffHunk": "@@ -137,42 +137,39 @@ public boolean equals(Object obj) {\n     }\n \n     public void publishMessage(long producerId, long sequenceId, ByteBuf headersAndPayload, long batchSize) {\n-        beforePublish(producerId, sequenceId, headersAndPayload, batchSize);\n-        publishMessageToTopic(headersAndPayload, sequenceId, batchSize);\n+        if (checkAndStartPublish(producerId, sequenceId, headersAndPayload, batchSize)) {\n+            publishMessageToTopic(headersAndPayload, sequenceId, batchSize);\n+        }\n     }\n \n     public void publishMessage(long producerId, long lowestSequenceId, long highestSequenceId,\n-           ByteBuf headersAndPayload, long batchSize) {\n+            ByteBuf headersAndPayload, long batchSize) {\n         if (lowestSequenceId > highestSequenceId) {\n-            cnx.ctx().channel().eventLoop().execute(() -> {\n-                cnx.ctx().writeAndFlush(Commands.newSendError(producerId, highestSequenceId, ServerError.MetadataError,\n-                        \"Invalid lowest or highest sequence id\"));\n+            execute(() -> {\n+                sendError(producerId, highestSequenceId, ServerError.MetadataError, \"Invalid lowest or highest sequence id\");\n                 cnx.completedSendOperation(isNonPersistentTopic, headersAndPayload.readableBytes());\n             });\n-            return;\n         }\n-        beforePublish(producerId, highestSequenceId, headersAndPayload, batchSize);", "originalCommit": "d4946240fcd8dbaa001615de923a8c2f020747b2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e71b3b7220925d9b596797150b7bb8b4a80485c5", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Producer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Producer.java\nindex b43c092b425..758d21c17a6 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Producer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Producer.java\n\n@@ -145,8 +145,8 @@ public abstract class Producer {\n     public void publishMessage(long producerId, long lowestSequenceId, long highestSequenceId,\n             ByteBuf headersAndPayload, long batchSize) {\n         if (lowestSequenceId > highestSequenceId) {\n-            execute(() -> {\n-                sendError(producerId, highestSequenceId, ServerError.MetadataError, \"Invalid lowest or highest sequence id\");\n+            cnx.execute(() -> {\n+                cnx.sendError(producerId, highestSequenceId, ServerError.MetadataError, \"Invalid lowest or highest sequence id\");\n                 cnx.completedSendOperation(isNonPersistentTopic, headersAndPayload.readableBytes());\n             });\n         }\n"}}, {"oid": "e71b3b7220925d9b596797150b7bb8b4a80485c5", "url": "https://github.com/apache/pulsar/commit/e71b3b7220925d9b596797150b7bb8b4a80485c5", "message": "Make ServerCnx and Producer independent of Netty\nServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter", "committedDate": "2020-04-12T14:50:49Z", "type": "forcePushed"}, {"oid": "2bcd5d1cc6def1824527f06d3b5373c0feb8827d", "url": "https://github.com/apache/pulsar/commit/2bcd5d1cc6def1824527f06d3b5373c0feb8827d", "message": "Make ServerCnx and Producer independent of Netty\n* ServerCnx is changed into an interface for which PulsarServerCnx is an\nimplementation extending Netty's ChannelInboundHandlerAdapter\nand which implement the Pulsar binary protocol", "committedDate": "2020-04-12T14:56:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMwOTUxNg==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r407309516", "bodyText": "what is the motivation of renaming ServerCnx to PulsarServerCntx? Can we avoid renaming this file?", "author": "sijie", "createdAt": "2020-04-13T04:09:44Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -65,7 +65,7 @@\n public class Consumer {\n     private final Subscription subscription;\n     private final SubType subType;\n-    private final ServerCnx cnx;\n+    private final PulsarServerCnx cnx;", "originalCommit": "2bcd5d1cc6def1824527f06d3b5373c0feb8827d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUzODIwOQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r407538209", "bodyText": "Ultimately Consumer shall depend on the interface and not the implementation. It's just that I haven't done it yet. Do you want me to do it in this PR ? It's the next step of my work anyway.", "author": "cbornet", "createdAt": "2020-04-13T15:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMwOTUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzU0MzM1Nw==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r407543357", "bodyText": "I'll do the change for Consumer. It will also make Topic, NonPersistentTopic, and PersistentTopic depend of ServerCnx instead of PulsarServerCnx so that's better.", "author": "cbornet", "createdAt": "2020-04-13T15:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMwOTUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzc1NTc3Mw==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r407755773", "bodyText": "@sijie I've done the change for Consumer.", "author": "cbornet", "createdAt": "2020-04-13T22:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMwOTUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "8fb1634a071b1757d4a8cc3f21073a6b0a1b3fbe", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex 5d15dee85ca..b1e741fa457 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -65,7 +58,7 @@ import org.slf4j.LoggerFactory;\n public class Consumer {\n     private final Subscription subscription;\n     private final SubType subType;\n-    private final PulsarServerCnx cnx;\n+    private final ServerCnx cnx;\n     private final String appId;\n     private AuthenticationDataSource authenticationData;\n     private final String topicName;\n"}}, {"oid": "8fb1634a071b1757d4a8cc3f21073a6b0a1b3fbe", "url": "https://github.com/apache/pulsar/commit/8fb1634a071b1757d4a8cc3f21073a6b0a1b3fbe", "message": "Make Consumer independent of Netty", "committedDate": "2020-04-13T22:22:40Z", "type": "forcePushed"}, {"oid": "2db149b691c0f9aa13a291abb7d32fc9f6d3b912", "url": "https://github.com/apache/pulsar/commit/2db149b691c0f9aa13a291abb7d32fc9f6d3b912", "message": "Make Consumer independent of Netty", "committedDate": "2020-04-14T06:12:33Z", "type": "forcePushed"}, {"oid": "3a16679e8526da58214f66c16754fee1367eac2f", "url": "https://github.com/apache/pulsar/commit/3a16679e8526da58214f66c16754fee1367eac2f", "message": "Make Consumer independent of Netty", "committedDate": "2020-04-15T09:10:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQxMTAwOA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r409411008", "bodyText": "Some methods could probably have default implementations. WDYT ?", "author": "cbornet", "createdAt": "2020-04-16T09:23:46Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -18,1911 +18,67 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static org.apache.commons.lang3.StringUtils.isNotBlank;\n-import static org.apache.pulsar.broker.admin.impl.PersistentTopicsBase.getPartitionedTopicMetadata;\n-import static org.apache.pulsar.broker.lookup.TopicLookupBase.lookupTopicAsync;\n-import static org.apache.pulsar.common.protocol.Commands.newLookupErrorResponse;\n-import static org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion.v5;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Strings;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOption;\n-import io.netty.handler.ssl.SslHandler;\n-\n-import java.net.SocketAddress;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.stream.Collectors;\n-\n-import javax.naming.AuthenticationException;\n-import javax.net.ssl.SSLSession;\n-\n-import org.apache.bookkeeper.mledger.AsyncCallbacks;\n import org.apache.bookkeeper.mledger.Entry;\n-import org.apache.bookkeeper.mledger.ManagedLedgerException;\n-import org.apache.bookkeeper.mledger.Position;\n-import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n-import org.apache.bookkeeper.mledger.impl.PositionImpl;\n-import org.apache.bookkeeper.mledger.util.SafeRun;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.exception.ExceptionUtils;\n-import org.apache.pulsar.broker.PulsarServerException;\n-import org.apache.pulsar.broker.PulsarService;\n import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n-import org.apache.pulsar.broker.authentication.AuthenticationProvider;\n-import org.apache.pulsar.broker.authentication.AuthenticationState;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerBusyException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ServerMetadataException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ServiceUnitNotReadyException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.SubscriptionNotFoundException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.TopicNotFoundException;\n-import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n-import org.apache.pulsar.broker.service.schema.exceptions.IncompatibleSchemaException;\n-import org.apache.pulsar.broker.service.schema.SchemaRegistryService;\n-import org.apache.pulsar.broker.web.RestException;\n-import org.apache.pulsar.client.api.PulsarClientException;\n-import org.apache.pulsar.client.impl.BatchMessageIdImpl;\n-import org.apache.pulsar.client.impl.ClientCnx;\n-import org.apache.pulsar.client.impl.MessageIdImpl;\n-import org.apache.pulsar.common.api.AuthData;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandNewTxn;\n-import org.apache.pulsar.common.protocol.CommandUtils;\n-import org.apache.pulsar.common.protocol.Commands;\n-import org.apache.pulsar.common.protocol.PulsarHandler;\n-import org.apache.pulsar.common.api.proto.PulsarApi;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandAuthResponse;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseConsumer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseProducer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConnect;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStats;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStatsResponse;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandFlow;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetLastMessageId;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetSchema;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetOrCreateSchema;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetTopicsOfNamespace;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandLookupTopic;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandPartitionedTopicMetadata;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandProducer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandRedeliverUnacknowledgedMessages;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSeek;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSend;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.SubType;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandUnsubscribe;\n-import org.apache.pulsar.common.api.proto.PulsarApi.FeatureFlags;\n-import org.apache.pulsar.common.api.proto.PulsarApi.MessageIdData;\n-import org.apache.pulsar.common.api.proto.PulsarApi.MessageMetadata;\n-import org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion;\n import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n-import org.apache.pulsar.common.naming.Metadata;\n-import org.apache.pulsar.common.naming.NamespaceName;\n-import org.apache.pulsar.common.naming.TopicName;\n-import org.apache.pulsar.common.policies.data.BacklogQuota;\n-import org.apache.pulsar.common.policies.data.ConsumerStats;\n-import org.apache.pulsar.common.protocol.schema.SchemaData;\n-import org.apache.pulsar.common.protocol.schema.SchemaInfoUtil;\n-import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n-import org.apache.pulsar.common.schema.SchemaType;\n-import org.apache.pulsar.common.util.FutureUtil;\n-import org.apache.pulsar.common.util.collections.ConcurrentLongHashMap;\n-import org.apache.pulsar.shaded.com.google.protobuf.v241.GeneratedMessageLite;\n-import org.apache.pulsar.transaction.coordinator.TransactionCoordinatorID;\n-import org.apache.pulsar.transaction.impl.common.TxnID;\n-import org.apache.pulsar.transaction.impl.common.TxnStatus;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class ServerCnx extends PulsarHandler {\n-    private final BrokerService service;\n-    private final SchemaRegistryService schemaService;\n-    private final ConcurrentLongHashMap<CompletableFuture<Producer>> producers;\n-    private final ConcurrentLongHashMap<CompletableFuture<Consumer>> consumers;\n-    private State state;\n-    private volatile boolean isActive = true;\n-    String authRole = null;\n-    AuthenticationDataSource authenticationData;\n-    AuthenticationProvider authenticationProvider;\n-    AuthenticationState authState;\n-    // In case of proxy, if the authentication credentials are forwardable,\n-    // it will hold the credentials of the original client\n-    AuthenticationState originalAuthState;\n-    private boolean pendingAuthChallengeResponse = false;\n-\n-    // Max number of pending requests per connections. If multiple producers are sharing the same connection the flow\n-    // control done by a single producer might not be enough to prevent write spikes on the broker.\n-    private final int maxPendingSendRequests;\n-    private final int resumeReadsThreshold;\n-    private int pendingSendRequest = 0;\n-    private final String replicatorPrefix;\n-    private String clientVersion = null;\n-    private int nonPersistentPendingMessages = 0;\n-    private final int MaxNonPersistentPendingMessages;\n-    private String originalPrincipal = null;\n-    private Set<String> proxyRoles;\n-    private boolean authenticateOriginalAuthData;\n-    private final boolean schemaValidationEnforced;\n-    private String authMethod = \"none\";\n-    private final int maxMessageSize;\n-\n-    // Flag to manage throttling-rate by atomically enable/disable read-channel.\n-    private volatile boolean autoReadDisabledRateLimiting = false;\n-    private FeatureFlags features;\n-    // Flag to manage throttling-publish-buffer by atomically enable/disable read-channel.\n-    private volatile boolean autoReadDisabledPublishBufferLimiting = false;\n-    private static final AtomicLongFieldUpdater<ServerCnx> MSG_PUBLISH_BUFFER_SIZE_UPDATER =\n-            AtomicLongFieldUpdater.newUpdater(ServerCnx.class, \"messagePublishBufferSize\");\n-    private volatile long messagePublishBufferSize = 0;\n-\n-    enum State {\n-        Start, Connected, Failed, Connecting\n-    }\n-\n-    public ServerCnx(PulsarService pulsar) {\n-        super(pulsar.getBrokerService().getKeepAliveIntervalSeconds(), TimeUnit.SECONDS);\n-        this.service = pulsar.getBrokerService();\n-        this.schemaService = pulsar.getSchemaRegistryService();\n-        this.state = State.Start;\n-\n-        // This maps are not heavily contended since most accesses are within the cnx thread\n-        this.producers = new ConcurrentLongHashMap<>(8, 1);\n-        this.consumers = new ConcurrentLongHashMap<>(8, 1);\n-        this.replicatorPrefix = service.pulsar().getConfiguration().getReplicatorPrefix();\n-        this.MaxNonPersistentPendingMessages = service.pulsar().getConfiguration()\n-                .getMaxConcurrentNonPersistentMessagePerConnection();\n-        this.proxyRoles = service.pulsar().getConfiguration().getProxyRoles();\n-        this.authenticateOriginalAuthData = service.pulsar().getConfiguration().isAuthenticateOriginalAuthData();\n-        this.schemaValidationEnforced = pulsar.getConfiguration().isSchemaValidationEnforced();\n-        this.maxMessageSize = pulsar.getConfiguration().getMaxMessageSize();\n-        this.maxPendingSendRequests = pulsar.getConfiguration().getMaxPendingPublishdRequestsPerConnection();\n-        this.resumeReadsThreshold = maxPendingSendRequests / 2;\n-    }\n-\n-    @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelActive(ctx);\n-        log.info(\"New connection from {}\", remoteAddress);\n-        this.ctx = ctx;\n-    }\n-\n-    @Override\n-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelInactive(ctx);\n-        isActive = false;\n-        log.info(\"Closed connection from {}\", remoteAddress);\n-\n-        // Connection is gone, close the producers immediately\n-        producers.values().forEach((producerFuture) -> {\n-            if (producerFuture.isDone() && !producerFuture.isCompletedExceptionally()) {\n-                Producer producer = producerFuture.getNow(null);\n-                producer.closeNow(true);\n-            }\n-        });\n-\n-        consumers.values().forEach((consumerFuture) -> {\n-            Consumer consumer;\n-            if (consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-                consumer = consumerFuture.getNow(null);\n-            } else {\n-                return;\n-            }\n-\n-            try {\n-                consumer.close();\n-            } catch (BrokerServiceException e) {\n-                log.warn(\"Consumer {} was already closed: {}\", consumer, e);\n-            }\n-        });\n-    }\n-\n-    @Override\n-    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Channel writability has changed to: {}\", ctx.channel().isWritable());\n-        }\n-    }\n-\n-    @Override\n-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-        if (state != State.Failed) {\n-            // No need to report stack trace for known exceptions that happen in disconnections\n-            log.warn(\"[{}] Got exception {}\", remoteAddress,\n-                    ClientCnx.isKnownException(cause) ? cause : ExceptionUtils.getStackTrace(cause));\n-            state = State.Failed;\n-        } else {\n-            // At default info level, suppress all subsequent exceptions that are thrown when the connection has already\n-            // failed\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Got exception: {}\", remoteAddress, cause);\n-            }\n-        }\n-        ctx.close();\n-    }\n-\n-    /*\n-     * If authentication and authorization is enabled(and not sasl) and if the authRole is one of proxyRoles we want to enforce\n-     * - the originalPrincipal is given while connecting\n-     * - originalPrincipal is not blank\n-     * - originalPrincipal is not a proxy principal\n-     */\n-    private boolean invalidOriginalPrincipal(String originalPrincipal) {\n-        return (service.isAuthenticationEnabled() && service.isAuthorizationEnabled()\n-            && proxyRoles.contains(authRole) && (StringUtils.isBlank(originalPrincipal) || proxyRoles.contains(originalPrincipal)));\n-    }\n-\n-    // ////\n-    // // Incoming commands handling\n-    // ////\n-\n-    @Override\n-    protected void handleLookup(CommandLookupTopic lookup) {\n-        final long requestId = lookup.getRequestId();\n-        final boolean authoritative = lookup.getAuthoritative();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received Lookup from {} for {}\", lookup.getTopic(), remoteAddress, requestId);\n-        }\n-\n-        TopicName topicName = validateTopicName(lookup.getTopic(), requestId, lookup);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n-        if (lookupSemaphore.tryAcquire()) {\n-            if (invalidOriginalPrincipal(originalPrincipal)) {\n-                final String msg = \"Valid Proxy Client role should be provided for lookup \";\n-                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                        originalPrincipal, topicName);\n-                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return;\n-            }\n-            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-                isProxyAuthorizedFuture = service.getAuthorizationService().canLookupAsync(topicName, authRole,\n-                    authenticationData);\n-            } else {\n-                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-            }\n-            String finalOriginalPrincipal = originalPrincipal;\n-            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-                if (isProxyAuthorized) {\n-                    lookupTopicAsync(getBrokerService().pulsar(), topicName, authoritative,\n-                            finalOriginalPrincipal != null ? finalOriginalPrincipal : authRole, authenticationData,\n-                            requestId).handle((lookupResponse, ex) -> {\n-                                if (ex == null) {\n-                                    ctx.writeAndFlush(lookupResponse);\n-                                } else {\n-                                    // it should never happen\n-                                    log.warn(\"[{}] lookup failed with error {}, {}\", remoteAddress, topicName,\n-                                            ex.getMessage(), ex);\n-                                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.ServiceNotReady,\n-                                            ex.getMessage(), requestId));\n-                                }\n-                                lookupSemaphore.release();\n-                                return null;\n-                            });\n-                } else {\n-                    final String msg = \"Proxy Client is not authorized to Lookup\";\n-                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                    lookupSemaphore.release();\n-                }\n-                return null;\n-            }).exceptionally(ex -> {\n-                final String msg = \"Exception occured while trying to authorize lookup\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName, ex);\n-                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return null;\n-            });\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Failed lookup due to too many lookup-requests {}\", remoteAddress, topicName);\n-            }\n-            ctx.writeAndFlush(newLookupErrorResponse(ServerError.TooManyRequests,\n-                    \"Failed due to too many pending lookup requests\", requestId));\n-        }\n-    }\n-\n-    @Override\n-    protected void handlePartitionMetadataRequest(CommandPartitionedTopicMetadata partitionMetadata) {\n-        final long requestId = partitionMetadata.getRequestId();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received PartitionMetadataLookup from {} for {}\", partitionMetadata.getTopic(),\n-                    remoteAddress, requestId);\n-        }\n-\n-        TopicName topicName = validateTopicName(partitionMetadata.getTopic(), requestId, partitionMetadata);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n-        if (lookupSemaphore.tryAcquire()) {\n-            if (invalidOriginalPrincipal(originalPrincipal)) {\n-                final String msg = \"Valid Proxy Client role should be provided for getPartitionMetadataRequest \";\n-                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                        originalPrincipal, topicName);\n-                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError,\n-                        msg, requestId));\n-                lookupSemaphore.release();\n-                return;\n-            }\n-            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-                isProxyAuthorizedFuture = service.getAuthorizationService()\n-                        .canLookupAsync(topicName, authRole, authenticationData);\n-            } else {\n-                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-            }\n-            String finalOriginalPrincipal = originalPrincipal;\n-            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-                if (isProxyAuthorized) {\n-                    getPartitionedTopicMetadata(getBrokerService().pulsar(),\n-                            authRole, finalOriginalPrincipal, authenticationData,\n-                            topicName).handle((metadata, ex) -> {\n-                                if (ex == null) {\n-                                    int partitions = metadata.partitions;\n-                                    ctx.writeAndFlush(Commands.newPartitionMetadataResponse(partitions, requestId));\n-                                } else {\n-                                    if (ex instanceof PulsarClientException) {\n-                                        log.warn(\"Failed to authorize {} at [{}] on topic {} : {}\", getRole(),\n-                                                remoteAddress, topicName, ex.getMessage());\n-                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(\n-                                                ServerError.AuthorizationError, ex.getMessage(), requestId));\n-                                    } else {\n-                                        log.warn(\"Failed to get Partitioned Metadata [{}] {}: {}\", remoteAddress,\n-                                                topicName, ex.getMessage(), ex);\n-                                        ServerError error = (ex instanceof RestException)\n-                                                && ((RestException) ex).getResponse().getStatus() < 500\n-                                                        ? ServerError.MetadataError\n-                                                        : ServerError.ServiceNotReady;\n-                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(error,\n-                                                ex.getMessage(), requestId));\n-                                    }\n-                                }\n-                                lookupSemaphore.release();\n-                                return null;\n-                            });\n-                } else {\n-                    final String msg = \"Proxy Client is not authorized to Get Partition Metadata\";\n-                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                    ctx.writeAndFlush(\n-                            Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n-                    lookupSemaphore.release();\n-                }\n-                return null;\n-            }).exceptionally(ex -> {\n-                final String msg = \"Exception occured while trying to authorize get Partition Metadata\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return null;\n-            });\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Failed Partition-Metadata lookup due to too many lookup-requests {}\", remoteAddress,\n-                        topicName);\n-            }\n-            ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.TooManyRequests,\n-                    \"Failed due to too many pending lookup requests\", requestId));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleConsumerStats(CommandConsumerStats commandConsumerStats) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandConsumerStats call from {}\", remoteAddress);\n-        }\n-\n-        final long requestId = commandConsumerStats.getRequestId();\n-        final long consumerId = commandConsumerStats.getConsumerId();\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n-        Consumer consumer = consumerFuture.getNow(null);\n-        ByteBuf msg = null;\n-\n-        if (consumer == null) {\n-            log.error(\n-                    \"Failed to get consumer-stats response - Consumer not found for CommandConsumerStats[remoteAddress = {}, requestId = {}, consumerId = {}]\",\n-                    remoteAddress, requestId, consumerId);\n-            msg = Commands.newConsumerStatsResponse(ServerError.ConsumerNotFound,\n-                    \"Consumer \" + consumerId + \" not found\", requestId);\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"CommandConsumerStats[requestId = {}, consumer = {}]\", requestId, consumer);\n-            }\n-            msg = Commands.newConsumerStatsResponse(createConsumerStatsResponse(consumer, requestId));\n-        }\n-\n-        ctx.writeAndFlush(msg);\n-    }\n-\n-    CommandConsumerStatsResponse.Builder createConsumerStatsResponse(Consumer consumer, long requestId) {\n-        CommandConsumerStatsResponse.Builder commandConsumerStatsResponseBuilder = CommandConsumerStatsResponse\n-                .newBuilder();\n-        ConsumerStats consumerStats = consumer.getStats();\n-        commandConsumerStatsResponseBuilder.setRequestId(requestId);\n-        commandConsumerStatsResponseBuilder.setMsgRateOut(consumerStats.msgRateOut);\n-        commandConsumerStatsResponseBuilder.setMsgThroughputOut(consumerStats.msgThroughputOut);\n-        commandConsumerStatsResponseBuilder.setMsgRateRedeliver(consumerStats.msgRateRedeliver);\n-        commandConsumerStatsResponseBuilder.setConsumerName(consumerStats.consumerName);\n-        commandConsumerStatsResponseBuilder.setAvailablePermits(consumerStats.availablePermits);\n-        commandConsumerStatsResponseBuilder.setUnackedMessages(consumerStats.unackedMessages);\n-        commandConsumerStatsResponseBuilder.setBlockedConsumerOnUnackedMsgs(consumerStats.blockedConsumerOnUnackedMsgs);\n-        commandConsumerStatsResponseBuilder.setAddress(consumerStats.getAddress());\n-        commandConsumerStatsResponseBuilder.setConnectedSince(consumerStats.getConnectedSince());\n-\n-        Subscription subscription = consumer.getSubscription();\n-        commandConsumerStatsResponseBuilder.setMsgBacklog(subscription.getNumberOfEntriesInBacklog(false));\n-        commandConsumerStatsResponseBuilder.setMsgRateExpired(subscription.getExpiredMessageRate());\n-        commandConsumerStatsResponseBuilder.setType(subscription.getTypeString());\n-\n-        return commandConsumerStatsResponseBuilder;\n-    }\n-\n-    // complete the connect and sent newConnected command\n-    private void completeConnect(int clientProtoVersion, String clientVersion) {\n-        ctx.writeAndFlush(Commands.newConnected(clientProtoVersion, maxMessageSize));\n-        state = State.Connected;\n-        remoteEndpointProtocolVersion = clientProtoVersion;\n-        if (isNotBlank(clientVersion) && !clientVersion.contains(\" \") /* ignore default version: pulsar client */) {\n-            this.clientVersion = clientVersion.intern();\n-        }\n-    }\n-\n-    // According to auth result, send newConnected or newAuthChallenge command.\n-    private State doAuthentication(AuthData clientData,\n-                                   int clientProtocolVersion,\n-                                   String clientVersion) throws Exception {\n-\n-        // The original auth state can only be set on subsequent auth attempts (and only\n-        // in presence of a proxy and if the proxy is forwarding the credentials).\n-        // In this case, the re-validation needs to be done against the original client\n-        // credentials.\n-        boolean useOriginalAuthState = (originalAuthState != null);\n-        AuthenticationState authState =  useOriginalAuthState ? originalAuthState : this.authState;\n-        String authRole = useOriginalAuthState ? originalPrincipal : this.authRole;\n-        AuthData brokerData = authState.authenticate(clientData);\n-\n-\n-        if (authState.isComplete()) {\n-            // Authentication has completed. It was either:\n-            // 1. the 1st time the authentication process was done, in which case we'll\n-            //    a `CommandConnected` response\n-            // 2. an authentication refresh, in which case we don't need to do anything else\n-\n-            String newAuthRole = authState.getAuthRole();\n-\n-            if (!useOriginalAuthState) {\n-                this.authRole = newAuthRole;\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Client successfully authenticated with {} role {} and originalPrincipal {}\",\n-                        remoteAddress, authMethod, authRole, originalPrincipal);\n-            }\n-\n-            if (state != State.Connected) {\n-                // First time authentication is done\n-                completeConnect(clientProtocolVersion, clientVersion);\n-            } else {\n-                // If the connection was already ready, it means we're doing a refresh\n-                if (!StringUtils.isEmpty(authRole)) {\n-                    if (!authRole.equals(newAuthRole)) {\n-                        log.warn(\"[{}] Principal cannot be changed during an authentication refresh\", remoteAddress);\n-                        ctx.close();\n-                    } else {\n-                        log.info(\"[{}] Refreshed authentication credentials for role {}\", remoteAddress, authRole);\n-                    }\n-                }\n-            }\n-\n-            return State.Connected;\n-        }\n-\n-        // auth not complete, continue auth with client side.\n-        ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, clientProtocolVersion));\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Authentication in progress client by method {}.\",\n-                remoteAddress, authMethod);\n-        }\n-        return State.Connecting;\n-    }\n-\n-    public void refreshAuthenticationCredentials() {\n-        AuthenticationState authState = this.originalAuthState != null ? originalAuthState : this.authState;\n-\n-        if (authState == null) {\n-            // Authentication is disabled or there's no local state to refresh\n-            return;\n-        } else if (getState() != State.Connected || !isActive) {\n-            // Connection is either still being established or already closed.\n-            return;\n-        } else if (authState != null && !authState.isExpired()) {\n-            // Credentials are still valid. Nothing to do at this point\n-            return;\n-        } else if (originalPrincipal != null && originalAuthState == null) {\n-            log.info(\n-                    \"[{}] Cannot revalidate user credential when using proxy and not forwarding the credentials. Closing connection\",\n-                    remoteAddress);\n-            return;\n-        }\n-\n-        ctx.executor().execute(SafeRun.safeRun(() -> {\n-            log.info(\"[{}] Refreshing authentication credentials for originalPrincipal {} and authRole {}\", remoteAddress, originalPrincipal, this.authRole);\n-\n-            if (!supportsAuthenticationRefresh()) {\n-                log.warn(\"[{}] Closing connection because client doesn't support auth credentials refresh\", remoteAddress);\n-                ctx.close();\n-                return;\n-            }\n-\n-            if (pendingAuthChallengeResponse) {\n-                log.warn(\"[{}] Closing connection after timeout on refreshing auth credentials\", remoteAddress);\n-                ctx.close();\n-                return;\n-            }\n-\n-            try {\n-                AuthData brokerData = authState.refreshAuthentication();\n-\n-                ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, remoteEndpointProtocolVersion));\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] Sent auth challenge to client to refresh credentials with method: {}.\",\n-                        remoteAddress, authMethod);\n-                }\n-\n-                pendingAuthChallengeResponse = true;\n-\n-            } catch (AuthenticationException e) {\n-                log.warn(\"[{}] Failed to refresh authentication: {}\", remoteAddress, e);\n-                ctx.close();\n-            }\n-        }));\n-    }\n-\n-    @Override\n-    protected void handleConnect(CommandConnect connect) {\n-        checkArgument(state == State.Start);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CONNECT from {}, auth enabled: {}\",\n-                remoteAddress, service.isAuthenticationEnabled());\n-        }\n-\n-        String clientVersion = connect.getClientVersion();\n-        int clientProtocolVersion = connect.getProtocolVersion();\n-        features = connect.getFeatureFlags();\n-\n-        if (!service.isAuthenticationEnabled()) {\n-            completeConnect(clientProtocolVersion, clientVersion);\n-            return;\n-        }\n-\n-        try {\n-            AuthData clientData = AuthData.of(connect.getAuthData().toByteArray());\n-\n-            // init authentication\n-            if (connect.hasAuthMethodName()) {\n-                authMethod = connect.getAuthMethodName();\n-            } else if (connect.hasAuthMethod()) {\n-                // Legacy client is passing enum\n-                authMethod = connect.getAuthMethod().name().substring(10).toLowerCase();\n-            } else {\n-                authMethod = \"none\";\n-            }\n-\n-            authenticationProvider = getBrokerService()\n-                .getAuthenticationService()\n-                .getAuthenticationProvider(authMethod);\n-\n-            // Not find provider named authMethod. Most used for tests.\n-            // In AuthenticationDisabled, it will set authMethod \"none\".\n-            if (authenticationProvider == null) {\n-                authRole = getBrokerService().getAuthenticationService().getAnonymousUserRole()\n-                    .orElseThrow(() ->\n-                        new AuthenticationException(\"No anonymous role, and no authentication provider configured\"));\n-                completeConnect(clientProtocolVersion, clientVersion);\n-                return;\n-            }\n-\n-            // init authState and other var\n-            ChannelHandler sslHandler = ctx.channel().pipeline().get(PulsarChannelInitializer.TLS_HANDLER);\n-            SSLSession sslSession = null;\n-            if (sslHandler != null) {\n-                sslSession = ((SslHandler) sslHandler).engine().getSession();\n-            }\n-\n-            authState = authenticationProvider.newAuthState(clientData, remoteAddress, sslSession);\n-            authenticationData = authState.getAuthDataSource();\n-            state = doAuthentication(clientData, clientProtocolVersion, clientVersion);\n-\n-            // This will fail the check if:\n-            //  1. client is coming through a proxy\n-            //  2. we require to validate the original credentials\n-            //  3. no credentials were passed\n-            if (connect.hasOriginalPrincipal() && service.getPulsar().getConfig().isAuthenticateOriginalAuthData()) {\n-                AuthenticationProvider originalAuthenticationProvider = getBrokerService()\n-                        .getAuthenticationService()\n-                        .getAuthenticationProvider(authMethod);\n-                originalAuthState = originalAuthenticationProvider.newAuthState(\n-                        AuthData.of(connect.getOriginalAuthData().getBytes()),\n-                        remoteAddress,\n-                        sslSession);\n-                originalPrincipal = originalAuthState.getAuthRole();\n-            } else {\n-                originalPrincipal = connect.hasOriginalPrincipal() ? connect.getOriginalPrincipal() : null;\n-            }\n-        } catch (Exception e) {\n-            String msg = \"Unable to authenticate\";\n-            if (e instanceof AuthenticationException) {\n-                log.warn(\"[{}] {}: {}\", remoteAddress, msg, e.getMessage());\n-            } else {\n-                log.warn(\"[{}] {}\", remoteAddress, msg, e);\n-            }\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, msg));\n-            close();\n-        }\n-    }\n-\n-    @Override\n-    protected void handleAuthResponse(CommandAuthResponse authResponse) {\n-        checkArgument(authResponse.hasResponse());\n-        checkArgument(authResponse.getResponse().hasAuthData() && authResponse.getResponse().hasAuthMethodName());\n-\n-        pendingAuthChallengeResponse = false;\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received AuthResponse from {}, auth method: {}\",\n-                remoteAddress, authResponse.getResponse().getAuthMethodName());\n-        }\n-\n-        try {\n-            AuthData clientData = AuthData.of(authResponse.getResponse().getAuthData().toByteArray());\n-            doAuthentication(clientData, authResponse.getProtocolVersion(), authResponse.getClientVersion());\n-        } catch (AuthenticationException e) {\n-            log.warn(\"[{}] Authentication failed: {} \", remoteAddress, e.getMessage());\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, e.getMessage()));\n-            close();\n-        } catch (Exception e) {\n-            String msg = \"Unable to handleAuthResponse\";\n-            log.warn(\"[{}] {} \", remoteAddress, msg, e);\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.UnknownError, msg));\n-            close();\n-        }\n-    }\n-\n-    @Override\n-    protected void handleSubscribe(final CommandSubscribe subscribe) {\n-        checkArgument(state == State.Connected);\n-        final long requestId = subscribe.getRequestId();\n-        final long consumerId = subscribe.getConsumerId();\n-        TopicName topicName = validateTopicName(subscribe.getTopic(), requestId, subscribe);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        if (invalidOriginalPrincipal(originalPrincipal)) {\n-            final String msg = \"Valid Proxy Client role should be provided while subscribing \";\n-            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                    originalPrincipal, topicName);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            return;\n-        }\n-\n-        final String subscriptionName = subscribe.getSubscription();\n-        final SubType subType = subscribe.getSubType();\n-        final String consumerName = subscribe.getConsumerName();\n-        final boolean isDurable = subscribe.getDurable();\n-        final MessageIdImpl startMessageId = subscribe.hasStartMessageId() ? new BatchMessageIdImpl(\n-                subscribe.getStartMessageId().getLedgerId(), subscribe.getStartMessageId().getEntryId(),\n-                subscribe.getStartMessageId().getPartition(), subscribe.getStartMessageId().getBatchIndex())\n-                : null;\n-        final int priorityLevel = subscribe.hasPriorityLevel() ? subscribe.getPriorityLevel() : 0;\n-        final boolean readCompacted = subscribe.getReadCompacted();\n-        final Map<String, String> metadata = CommandUtils.metadataFromCommand(subscribe);\n-        final InitialPosition initialPosition = subscribe.getInitialPosition();\n-        final long startMessageRollbackDurationSec = subscribe.hasStartMessageRollbackDurationSec()\n-                ? subscribe.getStartMessageRollbackDurationSec()\n-                : -1;\n-        final SchemaData schema = subscribe.hasSchema() ? getSchema(subscribe.getSchema()) : null;\n-        final boolean isReplicated = subscribe.hasReplicateSubscriptionState() && subscribe.getReplicateSubscriptionState();\n-        final boolean forceTopicCreation = subscribe.getForceTopicCreation();\n-        final PulsarApi.KeySharedMeta keySharedMeta = subscribe.hasKeySharedMeta() ? subscribe.getKeySharedMeta() : null;\n-\n-        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-            isProxyAuthorizedFuture = service.getAuthorizationService().canConsumeAsync(topicName, authRole,\n-                    authenticationData, subscribe.getSubscription());\n-        } else {\n-            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-        }\n-        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-            if (isProxyAuthorized) {\n-                CompletableFuture<Boolean> authorizationFuture;\n-                if (service.isAuthorizationEnabled()) {\n-                    authorizationFuture = service.getAuthorizationService().canConsumeAsync(topicName,\n-                            originalPrincipal != null ? originalPrincipal : authRole, authenticationData,\n-                            subscriptionName);\n-                } else {\n-                    authorizationFuture = CompletableFuture.completedFuture(true);\n-                }\n-\n-                authorizationFuture.thenApply(isAuthorized -> {\n-                    if (isAuthorized) {\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"[{}] Client is authorized to subscribe with role {}\", remoteAddress, authRole);\n-                        }\n-\n-                        log.info(\"[{}] Subscribing on topic {} / {}\", remoteAddress, topicName, subscriptionName);\n-                        try {\n-                            Metadata.validateMetadata(metadata);\n-                        } catch (IllegalArgumentException iae) {\n-                            final String msg = iae.getMessage();\n-                            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n-                            return null;\n-                        }\n-                        CompletableFuture<Consumer> consumerFuture = new CompletableFuture<>();\n-                        CompletableFuture<Consumer> existingConsumerFuture = consumers.putIfAbsent(consumerId,\n-                                consumerFuture);\n-\n-                        if (existingConsumerFuture != null) {\n-                            if (existingConsumerFuture.isDone() && !existingConsumerFuture.isCompletedExceptionally()) {\n-                                Consumer consumer = existingConsumerFuture.getNow(null);\n-                                log.info(\"[{}] Consumer with the same id {} is already created: {}\", remoteAddress,\n-                                        consumerId, consumer);\n-                                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-                                return null;\n-                            } else {\n-                                // There was an early request to create a consumer with same consumerId. This can happen\n-                                // when\n-                                // client timeout is lower the broker timeouts. We need to wait until the previous\n-                                // consumer\n-                                // creation request either complete or fails.\n-                                log.warn(\"[{}][{}][{}] Consumer with id {} is already present on the connection\", remoteAddress,\n-                                        topicName, subscriptionName, consumerId);\n-                                ServerError error = null;\n-                                if(!existingConsumerFuture.isDone()) {\n-                                    error = ServerError.ServiceNotReady;\n-                                }else {\n-                                    error = getErrorCode(existingConsumerFuture);\n-                                    consumers.remove(consumerId);\n-                                }\n-                                ctx.writeAndFlush(Commands.newError(requestId, error,\n-                                        \"Consumer is already present on the connection\"));\n-                                return null;\n-                            }\n-                        }\n-\n-                        boolean createTopicIfDoesNotExist = forceTopicCreation\n-                                && service.isAllowAutoTopicCreation(topicName.toString());\n-\n-                        service.getTopic(topicName.toString(), createTopicIfDoesNotExist)\n-                                .thenCompose(optTopic -> {\n-                                    if (!optTopic.isPresent()) {\n-                                        return FutureUtil\n-                                                .failedFuture(new TopicNotFoundException(\"Topic does not exist\"));\n-                                    }\n-\n-                                    Topic topic = optTopic.get();\n-\n-                                    boolean rejectSubscriptionIfDoesNotExist = isDurable\n-                                        && !service.isAllowAutoSubscriptionCreation(topicName.toString())\n-                                        && !topic.getSubscriptions().containsKey(subscriptionName);\n-\n-                                    if (rejectSubscriptionIfDoesNotExist) {\n-                                        return FutureUtil\n-                                            .failedFuture(new SubscriptionNotFoundException(\"Subscription does not exist\"));\n-                                    }\n-\n-                                    if (schema != null) {\n-                                        return topic.addSchemaIfIdleOrCheckCompatible(schema)\n-                                            .thenCompose(v -> topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n-                                                    subType, priorityLevel, consumerName, isDurable,\n-                                                    startMessageId, metadata,\n-                                                    readCompacted, initialPosition, startMessageRollbackDurationSec, isReplicated, keySharedMeta));\n-                                    } else {\n-                                        return topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n-                                            subType, priorityLevel, consumerName, isDurable,\n-                                            startMessageId, metadata, readCompacted, initialPosition,\n-                                            startMessageRollbackDurationSec, isReplicated, keySharedMeta);\n-                                    }\n-                                })\n-                                .thenAccept(consumer -> {\n-                                    if (consumerFuture.complete(consumer)) {\n-                                        log.info(\"[{}] Created subscription on topic {} / {}\", remoteAddress, topicName,\n-                                                subscriptionName);\n-                                        ctx.writeAndFlush(Commands.newSuccess(requestId), ctx.voidPromise());\n-                                    } else {\n-                                        // The consumer future was completed before by a close command\n-                                        try {\n-                                            consumer.close();\n-                                            log.info(\"[{}] Cleared consumer created after timeout on client side {}\",\n-                                                    remoteAddress, consumer);\n-                                        } catch (BrokerServiceException e) {\n-                                            log.warn(\n-                                                    \"[{}] Error closing consumer created after timeout on client side {}: {}\",\n-                                                    remoteAddress, consumer, e.getMessage());\n-                                        }\n-                                        consumers.remove(consumerId, consumerFuture);\n-                                    }\n-\n-                                }) //\n-                                .exceptionally(exception -> {\n-                                    if (exception.getCause() instanceof ConsumerBusyException) {\n-                                        if (log.isDebugEnabled()) {\n-                                            log.debug(\n-                                                    \"[{}][{}][{}] Failed to create consumer because exclusive consumer is already connected: {}\",\n-                                                    remoteAddress, topicName, subscriptionName,\n-                                                    exception.getCause().getMessage());\n-                                        }\n-                                    } else if (exception.getCause() instanceof BrokerServiceException) {\n-                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n-                                                subscriptionName, exception.getCause().getMessage());\n-                                    } else {\n-                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n-                                                subscriptionName, exception.getCause().getMessage(), exception);\n-                                    }\n-\n-                                    // If client timed out, the future would have been completed by subsequent close.\n-                                    // Send error\n-                                    // back to client, only if not completed already.\n-                                    if (consumerFuture.completeExceptionally(exception)) {\n-                                        ctx.writeAndFlush(Commands.newError(requestId,\n-                                                BrokerServiceException.getClientErrorCode(exception),\n-                                                exception.getCause().getMessage()));\n-                                    }\n-                                    consumers.remove(consumerId, consumerFuture);\n-\n-                                    return null;\n-\n-                                });\n-                    } else {\n-                        String msg = \"Client is not authorized to subscribe\";\n-                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n-                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-                    }\n-                    return null;\n-                }).exceptionally(e -> {\n-                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n-                    log.warn(msg);\n-                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n-                    return null;\n-                });\n-            } else {\n-                final String msg = \"Proxy Client is not authorized to subscribe\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            }\n-            return null;\n-        }).exceptionally(ex -> {\n-            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n-            if (ex.getCause() instanceof PulsarServerException) {\n-                log.info(msg);\n-            } else {\n-                log.warn(msg);\n-            }\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    private SchemaData getSchema(PulsarApi.Schema protocolSchema) {\n-        return SchemaData.builder()\n-            .data(protocolSchema.getSchemaData().toByteArray())\n-            .isDeleted(false)\n-            .timestamp(System.currentTimeMillis())\n-            .user(Strings.nullToEmpty(originalPrincipal))\n-            .type(Commands.getSchemaType(protocolSchema.getType()))\n-            .props(protocolSchema.getPropertiesList().stream().collect(\n-                Collectors.toMap(\n-                    PulsarApi.KeyValue::getKey,\n-                    PulsarApi.KeyValue::getValue\n-                )\n-            )).build();\n-    }\n-\n-    @Override\n-    protected void handleProducer(final CommandProducer cmdProducer) {\n-        checkArgument(state == State.Connected);\n-        final long producerId = cmdProducer.getProducerId();\n-        final long requestId = cmdProducer.getRequestId();\n-        // Use producer name provided by client if present\n-        final String producerName = cmdProducer.hasProducerName() ? cmdProducer.getProducerName()\n-                : service.generateUniqueProducerName();\n-        final long epoch = cmdProducer.getEpoch();\n-        final boolean userProvidedProducerName = cmdProducer.getUserProvidedProducerName();\n-        final boolean isEncrypted = cmdProducer.getEncrypted();\n-        final Map<String, String> metadata = CommandUtils.metadataFromCommand(cmdProducer);\n-        final SchemaData schema = cmdProducer.hasSchema() ? getSchema(cmdProducer.getSchema()) : null;\n-\n-        TopicName topicName = validateTopicName(cmdProducer.getTopic(), requestId, cmdProducer);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        if (invalidOriginalPrincipal(originalPrincipal)) {\n-            final String msg = \"Valid Proxy Client role should be provided while creating producer \";\n-            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                    originalPrincipal, topicName);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            return;\n-        }\n-\n-        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-            isProxyAuthorizedFuture = service.getAuthorizationService().canProduceAsync(topicName,\n-                    authRole, authenticationData);\n-        } else {\n-            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-        }\n-        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-            if (isProxyAuthorized) {\n-                CompletableFuture<Boolean> authorizationFuture;\n-                if (service.isAuthorizationEnabled()) {\n-                    authorizationFuture = service.getAuthorizationService().canProduceAsync(topicName,\n-                            originalPrincipal != null ? originalPrincipal : authRole, authenticationData);\n-                } else {\n-                    authorizationFuture = CompletableFuture.completedFuture(true);\n-                }\n \n-                authorizationFuture.thenApply(isAuthorized -> {\n-                    if (isAuthorized) {\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"[{}] Client is authorized to Produce with role {}\", remoteAddress, authRole);\n-                        }\n-                        CompletableFuture<Producer> producerFuture = new CompletableFuture<>();\n-                        CompletableFuture<Producer> existingProducerFuture = producers.putIfAbsent(producerId,\n-                                producerFuture);\n-\n-                        if (existingProducerFuture != null) {\n-                            if (existingProducerFuture.isDone() && !existingProducerFuture.isCompletedExceptionally()) {\n-                                Producer producer = existingProducerFuture.getNow(null);\n-                                log.info(\"[{}] Producer with the same id {} is already created: {}\", remoteAddress,\n-                                        producerId, producer);\n-                                ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producer.getProducerName(),\n-                                    producer.getSchemaVersion()));\n-                                return null;\n-                            } else {\n-                                // There was an early request to create a producer with\n-                                // same producerId. This can happen when\n-                                // client\n-                                // timeout is lower the broker timeouts. We need to wait\n-                                // until the previous producer creation\n-                                // request\n-                                // either complete or fails.\n-                                ServerError error = null;\n-                                if(!existingProducerFuture.isDone()) {\n-                                    error = ServerError.ServiceNotReady;\n-                                }else {\n-                                    error = getErrorCode(existingProducerFuture);\n-                                    // remove producer with producerId as it's already completed with exception\n-                                    producers.remove(producerId);\n-                                }\n-                                log.warn(\"[{}][{}] Producer with id {} is already present on the connection\", remoteAddress,\n-                                        producerId, topicName);\n-                                ctx.writeAndFlush(Commands.newError(requestId, error,\n-                                        \"Producer is already present on the connection\"));\n-                                return null;\n-                            }\n-                        }\n-\n-                        log.info(\"[{}][{}] Creating producer. producerId={}\", remoteAddress, topicName, producerId);\n-\n-                        service.getOrCreateTopic(topicName.toString()).thenAccept((Topic topic) -> {\n-                            // Before creating producer, check if backlog quota exceeded\n-                            // on topic\n-                            if (topic.isBacklogQuotaExceeded(producerName)) {\n-                                IllegalStateException illegalStateException = new IllegalStateException(\n-                                        \"Cannot create producer on topic with backlog quota exceeded\");\n-                                BacklogQuota.RetentionPolicy retentionPolicy = topic.getBacklogQuota().getPolicy();\n-                                if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold) {\n-                                    ctx.writeAndFlush(\n-                                            Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededError,\n-                                                    illegalStateException.getMessage()));\n-                                } else if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception) {\n-                                    ctx.writeAndFlush(Commands.newError(requestId,\n-                                            ServerError.ProducerBlockedQuotaExceededException,\n-                                            illegalStateException.getMessage()));\n-                                }\n-                                producerFuture.completeExceptionally(illegalStateException);\n-                                producers.remove(producerId, producerFuture);\n-                                return;\n-                            }\n-\n-                            // Check whether the producer will publish encrypted messages or not\n-                            if (topic.isEncryptionRequired() && !isEncrypted) {\n-                                String msg = String.format(\"Encryption is required in %s\", topicName);\n-                                log.warn(\"[{}] {}\", remoteAddress, msg);\n-                                ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n-                                producers.remove(producerId, producerFuture);\n-                                return;\n-                            }\n-\n-                            disableTcpNoDelayIfNeeded(topicName.toString(), producerName);\n-\n-                            CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n-\n-                            schemaVersionFuture.exceptionally(exception -> {\n-                                ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(exception),\n-                                        exception.getMessage()));\n-                                producers.remove(producerId, producerFuture);\n-                                return null;\n-                            });\n-\n-                            schemaVersionFuture.thenAccept(schemaVersion -> {\n-                                Producer producer = new Producer(topic, ServerCnx.this, producerId, producerName, authRole,\n-                                    isEncrypted, metadata, schemaVersion, epoch, userProvidedProducerName);\n-\n-                                try {\n-                                    topic.addProducer(producer);\n-\n-                                    if (isActive()) {\n-                                        if (producerFuture.complete(producer)) {\n-                                            log.info(\"[{}] Created new producer: {}\", remoteAddress, producer);\n-                                            ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producerName,\n-                                                producer.getLastSequenceId(), producer.getSchemaVersion()));\n-                                            return;\n-                                        } else {\n-                                            // The producer's future was completed before by\n-                                            // a close command\n-                                            producer.closeNow(true);\n-                                            log.info(\"[{}] Cleared producer created after timeout on client side {}\",\n-                                                remoteAddress, producer);\n-                                        }\n-                                    } else {\n-                                        producer.closeNow(true);\n-                                        log.info(\"[{}] Cleared producer created after connection was closed: {}\",\n-                                            remoteAddress, producer);\n-                                        producerFuture.completeExceptionally(\n-                                            new IllegalStateException(\"Producer created after connection was closed\"));\n-                                    }\n-                                } catch (BrokerServiceException ise) {\n-                                    log.error(\"[{}] Failed to add producer to topic {}: {}\", remoteAddress, topicName,\n-                                        ise.getMessage());\n-                                    ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(ise), ise.getMessage()));\n-                                    producerFuture.completeExceptionally(ise);\n-                                }\n-\n-                                producers.remove(producerId, producerFuture);\n-                            });\n-                        }).exceptionally(exception -> {\n-                            Throwable cause = exception.getCause();\n-                            if (!(cause instanceof ServiceUnitNotReadyException)) {\n-                                // Do not print stack traces for expected exceptions\n-                                log.error(\"[{}] Failed to create topic {}\", remoteAddress, topicName, exception);\n-                            }\n-\n-                            // If client timed out, the future would have been completed\n-                            // by subsequent close. Send error back to\n-                            // client, only if not completed already.\n-                            if (producerFuture.completeExceptionally(exception)) {\n-                                ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(cause), cause.getMessage()));\n-                            }\n-                            producers.remove(producerId, producerFuture);\n-\n-                            return null;\n-                        });\n-                    } else {\n-                        String msg = \"Client is not authorized to Produce\";\n-                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n-                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-                    }\n-                    return null;\n-                }).exceptionally(e -> {\n-                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n-                    log.warn(msg);\n-                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n-                    return null;\n-                });\n-            } else {\n-                final String msg = \"Proxy Client is not authorized to Produce\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            }\n-            return null;\n-        }).exceptionally(ex -> {\n-            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n-            log.warn(msg);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleSend(CommandSend send, ByteBuf headersAndPayload) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Producer> producerFuture = producers.get(send.getProducerId());\n-\n-        if (producerFuture == null || !producerFuture.isDone() || producerFuture.isCompletedExceptionally()) {\n-            log.warn(\"[{}] Producer had already been closed: {}\", remoteAddress, send.getProducerId());\n-            return;\n-        }\n-\n-        Producer producer = producerFuture.getNow(null);\n-        if (log.isDebugEnabled()) {\n-            printSendCommandDebug(send, headersAndPayload);\n-        }\n-\n-        if (producer.isNonPersistentTopic()) {\n-            // avoid processing non-persist message if reached max concurrent-message limit\n-            if (nonPersistentPendingMessages > MaxNonPersistentPendingMessages) {\n-                final long producerId = send.getProducerId();\n-                final long sequenceId = send.getSequenceId();\n-                final long highestSequenceId = send.getHighestSequenceId();\n-                service.getTopicOrderedExecutor().executeOrdered(producer.getTopic().getName(), SafeRun.safeRun(() -> {\n-                    ctx.writeAndFlush(Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, -1, -1), ctx.voidPromise());\n-                }));\n-                producer.recordMessageDrop(send.getNumMessages());\n-                return;\n-            } else {\n-                nonPersistentPendingMessages++;\n-            }\n-        }\n-\n-        startSendOperation(producer, headersAndPayload.readableBytes());\n-\n-        // Persist the message\n-        if (send.hasHighestSequenceId() && send.getSequenceId() <= send.getHighestSequenceId()) {\n-            producer.publishMessage(send.getProducerId(), send.getSequenceId(), send.getHighestSequenceId(),\n-                    headersAndPayload, send.getNumMessages());\n-        } else {\n-            producer.publishMessage(send.getProducerId(), send.getSequenceId(), headersAndPayload, send.getNumMessages());\n-        }\n-    }\n-\n-    private void printSendCommandDebug(CommandSend send, ByteBuf headersAndPayload) {\n-        headersAndPayload.markReaderIndex();\n-        MessageMetadata msgMetadata = Commands.parseMessageMetadata(headersAndPayload);\n-        headersAndPayload.resetReaderIndex();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received send message request. producer: {}:{} {}:{} size: {}, partition key is: {}, ordering key is {}\",\n-                    remoteAddress, send.getProducerId(), send.getSequenceId(), msgMetadata.getProducerName(), msgMetadata.getSequenceId(),\n-                    headersAndPayload.readableBytes(), msgMetadata.getPartitionKey(), msgMetadata.getOrderingKey());\n-        }\n-        msgMetadata.recycle();\n-    }\n-\n-    @Override\n-    protected void handleAck(CommandAck ack) {\n-        checkArgument(state == State.Connected);\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(ack.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            consumerFuture.getNow(null).messageAcked(ack);\n-        }\n-    }\n-\n-    @Override\n-    protected void handleFlow(CommandFlow flow) {\n-        checkArgument(state == State.Connected);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received flow from consumer {} permits: {}\", remoteAddress, flow.getConsumerId(),\n-                    flow.getMessagePermits());\n-        }\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(flow.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            if (consumer != null) {\n-                consumer.flowPermits(flow.getMessagePermits());\n-            } else {\n-                log.info(\"[{}] Couldn't find consumer {}\", remoteAddress, flow.getConsumerId());\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void handleRedeliverUnacknowledged(CommandRedeliverUnacknowledgedMessages redeliver) {\n-        checkArgument(state == State.Connected);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received Resend Command from consumer {} \", remoteAddress, redeliver.getConsumerId());\n-        }\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(redeliver.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            if (redeliver.getMessageIdsCount() > 0 && Subscription.isIndividualAckMode(consumer.subType())) {\n-                consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());\n-            } else {\n-                consumer.redeliverUnacknowledgedMessages();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void handleUnsubscribe(CommandUnsubscribe unsubscribe) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(unsubscribe.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            consumerFuture.getNow(null).doUnsubscribe(unsubscribe.getRequestId());\n-        } else {\n-            ctx.writeAndFlush(\n-                    Commands.newError(unsubscribe.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleSeek(CommandSeek seek) {\n-        checkArgument(state == State.Connected);\n-        final long requestId = seek.getRequestId();\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(seek.getConsumerId());\n-\n-        if (!seek.hasMessageId() && !seek.hasMessagePublishTime()) {\n-            ctx.writeAndFlush(\n-                    Commands.newError(requestId, ServerError.MetadataError, \"Message id and message publish time were not present\"));\n-            return;\n-        }\n-\n-        boolean consumerCreated = consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally();\n-\n-        if (consumerCreated && seek.hasMessageId()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            Subscription subscription = consumer.getSubscription();\n-            MessageIdData msgIdData = seek.getMessageId();\n-\n-            Position position = new PositionImpl(msgIdData.getLedgerId(), msgIdData.getEntryId());\n-\n-\n-            subscription.resetCursor(position).thenRun(() -> {\n-                log.info(\"[{}] [{}][{}] Reset subscription to message id {}\", remoteAddress,\n-                        subscription.getTopic().getName(), subscription.getName(), position);\n-                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            }).exceptionally(ex -> {\n-                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                        \"Error when resetting subscription: \" + ex.getCause().getMessage()));\n-                return null;\n-            });\n-        } else if (consumerCreated && seek.hasMessagePublishTime()){\n-            Consumer consumer = consumerFuture.getNow(null);\n-            Subscription subscription = consumer.getSubscription();\n-            long timestamp = seek.getMessagePublishTime();\n-\n-            subscription.resetCursor(timestamp).thenRun(() -> {\n-                log.info(\"[{}] [{}][{}] Reset subscription to publish time {}\", remoteAddress,\n-                        subscription.getTopic().getName(), subscription.getName(), timestamp);\n-                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            }).exceptionally(ex -> {\n-                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                        \"Reset subscription to publish time error: \" + ex.getCause().getMessage()));\n-                return null;\n-            });\n-        } else {\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleCloseProducer(CommandCloseProducer closeProducer) {\n-        checkArgument(state == State.Connected);\n-\n-        final long producerId = closeProducer.getProducerId();\n-        final long requestId = closeProducer.getRequestId();\n-\n-        CompletableFuture<Producer> producerFuture = producers.get(producerId);\n-        if (producerFuture == null) {\n-            log.warn(\"[{}] Producer {} was not registered on the connection\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                    \"Producer was not registered on the connection\"));\n-            return;\n-        }\n-\n-        if (!producerFuture.isDone() && producerFuture\n-                .completeExceptionally(new IllegalStateException(\"Closed producer before creation was complete\"))) {\n-            // We have received a request to close the producer before it was actually completed, we have marked the\n-            // producer future as failed and we can tell the client the close operation was successful.\n-            log.info(\"[{}] Closed producer {} before its creation was completed\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-            return;\n-        } else if (producerFuture.isCompletedExceptionally()) {\n-            log.info(\"[{}] Closed producer {} that already failed to be created\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-            return;\n-        }\n-\n-        // Proceed with normal close, the producer\n-        Producer producer = producerFuture.getNow(null);\n-        log.info(\"[{}][{}] Closing producer on cnx {}\", producer.getTopic(), producer.getProducerName(), remoteAddress);\n-\n-        producer.close(true).thenAccept(v -> {\n-            log.info(\"[{}][{}] Closed producer on cnx {}\", producer.getTopic(), producer.getProducerName(),\n-                    remoteAddress);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-        });\n-    }\n-\n-    @Override\n-    protected void handleCloseConsumer(CommandCloseConsumer closeConsumer) {\n-        checkArgument(state == State.Connected);\n-        log.info(\"[{}] Closing consumer: {}\", remoteAddress, closeConsumer.getConsumerId());\n-\n-        long requestId = closeConsumer.getRequestId();\n-        long consumerId = closeConsumer.getConsumerId();\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n-        if (consumerFuture == null) {\n-            log.warn(\"[{}] Consumer was not registered on the connection: {}\", consumerId, remoteAddress);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n-            return;\n-        }\n-\n-        if (!consumerFuture.isDone() && consumerFuture\n-                .completeExceptionally(new IllegalStateException(\"Closed consumer before creation was complete\"))) {\n-            // We have received a request to close the consumer before it was actually completed, we have marked the\n-            // consumer future as failed and we can tell the client the close operation was successful. When the actual\n-            // create operation will complete, the new consumer will be discarded.\n-            log.info(\"[{}] Closed consumer {} before its creation was completed\", remoteAddress, consumerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            return;\n-        }\n-\n-        if (consumerFuture.isCompletedExceptionally()) {\n-            log.info(\"[{}] Closed consumer {} that already failed to be created\", remoteAddress, consumerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            return;\n-        }\n-\n-        // Proceed with normal consumer close\n-        Consumer consumer = consumerFuture.getNow(null);\n-        try {\n-            consumer.close();\n-            consumers.remove(consumerId, consumerFuture);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            log.info(\"[{}] Closed consumer {}\", remoteAddress, consumer);\n-        } catch (BrokerServiceException e) {\n-            log.warn(\"[{]] Error closing consumer {} : {}\", remoteAddress, consumer, e);\n-            ctx.writeAndFlush(\n-                    Commands.newError(requestId, BrokerServiceException.getClientErrorCode(e), e.getMessage()));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleGetLastMessageId(CommandGetLastMessageId getLastMessageId) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(getLastMessageId.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            long requestId = getLastMessageId.getRequestId();\n-\n-            Topic topic = consumer.getSubscription().getTopic();\n-            Position position = topic.getLastPosition();\n-            int partitionIndex = TopicName.getPartitionIndex(topic.getName());\n-\n-            getLargestBatchIndexWhenPossible(\n-                    topic,\n-                    (PositionImpl) position,\n-                    partitionIndex,\n-                    requestId,\n-                    consumer.getSubscription().getName());\n-\n-        } else {\n-            ctx.writeAndFlush(Commands.newError(getLastMessageId.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    private void getLargestBatchIndexWhenPossible(\n-            Topic topic,\n-            PositionImpl position,\n-            int partitionIndex,\n-            long requestId,\n-            String subscriptionName) {\n-\n-        PersistentTopic persistentTopic = (PersistentTopic) topic;\n-        ManagedLedgerImpl ml = (ManagedLedgerImpl) persistentTopic.getManagedLedger();\n-\n-        // If it's not pointing to a valid entry, respond messageId of the current position.\n-        if (position.getEntryId() == -1) {\n-            MessageIdData messageId = MessageIdData.newBuilder()\n-                    .setLedgerId(position.getLedgerId())\n-                    .setEntryId(position.getEntryId())\n-                    .setPartition(partitionIndex).build();\n-\n-            ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n-        }\n-\n-        // For a valid position, we read the entry out and parse the batch size from its metadata.\n-        CompletableFuture<Entry> entryFuture = new CompletableFuture<>();\n-        ml.asyncReadEntry(position, new AsyncCallbacks.ReadEntryCallback() {\n-            @Override\n-            public void readEntryComplete(Entry entry, Object ctx) {\n-                entryFuture.complete(entry);\n-            }\n-\n-            @Override\n-            public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n-                entryFuture.completeExceptionally(exception);\n-            }\n-        }, null);\n-\n-        CompletableFuture<Integer> batchSizeFuture = entryFuture.thenApply(entry -> {\n-            MessageMetadata metadata = Commands.parseMessageMetadata(entry.getDataBuffer());\n-            int batchSize = metadata.getNumMessagesInBatch();\n-            entry.release();\n-            return batchSize;\n-        });\n-\n-        batchSizeFuture.whenComplete((batchSize, e) -> {\n-            if (e != null) {\n-                ctx.writeAndFlush(Commands.newError(\n-                        requestId, ServerError.MetadataError, \"Failed to get batch size for entry \" + e.getMessage()));\n-            } else {\n-                int largestBatchIndex = batchSize > 1 ? batchSize - 1 : -1;\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] [{}][{}] Get LastMessageId {} partitionIndex {}\", remoteAddress,\n-                            topic.getName(), subscriptionName, position, partitionIndex);\n-                }\n-\n-                MessageIdData messageId = MessageIdData.newBuilder()\n-                        .setLedgerId(position.getLedgerId())\n-                        .setEntryId(position.getEntryId())\n-                        .setPartition(partitionIndex)\n-                        .setBatchIndex(largestBatchIndex).build();\n-\n-                ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n-            }\n-        });\n-    }\n-\n-    @Override\n-    protected void handleGetTopicsOfNamespace(CommandGetTopicsOfNamespace commandGetTopicsOfNamespace) {\n-        final long requestId = commandGetTopicsOfNamespace.getRequestId();\n-        final String namespace = commandGetTopicsOfNamespace.getNamespace();\n-        final CommandGetTopicsOfNamespace.Mode mode = commandGetTopicsOfNamespace.getMode();\n-        final NamespaceName namespaceName = NamespaceName.get(namespace);\n-\n-        getBrokerService().pulsar().getNamespaceService().getListOfTopics(namespaceName, mode)\n-                .thenAccept(topics -> {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"[{}] Received CommandGetTopicsOfNamespace for namespace [//{}] by {}, size:{}\",\n-                                remoteAddress, namespace, requestId, topics.size());\n-                    }\n-\n-                    ctx.writeAndFlush(Commands.newGetTopicsOfNamespaceResponse(topics, requestId));\n-                })\n-                .exceptionally(ex -> {\n-                    log.warn(\"[{}] Error GetTopicsOfNamespace for namespace [//{}] by {}\",\n-                            remoteAddress, namespace, requestId);\n-                    ctx.writeAndFlush(\n-                            Commands.newError(requestId,\n-                                    BrokerServiceException.getClientErrorCode(new ServerMetadataException(ex)),\n-                                    ex.getMessage()));\n-\n-                    return null;\n-                });\n-    }\n-\n-    @Override\n-    protected void handleGetSchema(CommandGetSchema commandGetSchema) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandGetSchema call from {}, schemaVersion: {}, topic: {}, requestId: {}\",\n-                    remoteAddress, new String(commandGetSchema.getSchemaVersion().toByteArray()),\n-                    commandGetSchema.getTopic(), commandGetSchema.getRequestId());\n-        }\n-\n-        long requestId = commandGetSchema.getRequestId();\n-        SchemaVersion schemaVersion = SchemaVersion.Latest;\n-        if (commandGetSchema.hasSchemaVersion()) {\n-            schemaVersion = schemaService.versionFromBytes(commandGetSchema.getSchemaVersion().toByteArray());\n-        }\n-\n-        String schemaName;\n-        try {\n-            schemaName = TopicName.get(commandGetSchema.getTopic()).getSchemaName();\n-        } catch (Throwable t) {\n-            ctx.writeAndFlush(\n-                    Commands.newGetSchemaResponseError(requestId, ServerError.InvalidTopicName, t.getMessage()));\n-            return;\n-        }\n-\n-        schemaService.getSchema(schemaName, schemaVersion).thenAccept(schemaAndMetadata -> {\n-            if (schemaAndMetadata == null) {\n-                ctx.writeAndFlush(Commands.newGetSchemaResponseError(requestId, ServerError.TopicNotFound,\n-                        \"Topic not found or no-schema\"));\n-            } else {\n-                ctx.writeAndFlush(Commands.newGetSchemaResponse(requestId,\n-                        SchemaInfoUtil.newSchemaInfo(schemaName, schemaAndMetadata.schema), schemaAndMetadata.version));\n-            }\n-        }).exceptionally(ex -> {\n-            ctx.writeAndFlush(\n-                    Commands.newGetSchemaResponseError(requestId, ServerError.UnknownError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleGetOrCreateSchema(CommandGetOrCreateSchema commandGetOrCreateSchema) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandGetOrCreateSchema call from {}\", remoteAddress);\n-        }\n-        long requestId = commandGetOrCreateSchema.getRequestId();\n-        String topicName = commandGetOrCreateSchema.getTopic();\n-        SchemaData schemaData = getSchema(commandGetOrCreateSchema.getSchema());\n-        SchemaData schema = schemaData.getType() == SchemaType.NONE ? null : schemaData;\n-        service.getTopicIfExists(topicName).thenAccept(topicOpt -> {\n-            if (topicOpt.isPresent()) {\n-                Topic topic = topicOpt.get();\n-                CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n-                schemaVersionFuture.exceptionally(ex -> {\n-                    ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n-                    ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                            requestId, errorCode, ex.getMessage()));\n-                    return null;\n-                }).thenAccept(schemaVersion -> {\n-                        ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponse(\n-                                requestId, schemaVersion));\n-                });\n-            } else {\n-                ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                        requestId, ServerError.TopicNotFound, \"Topic not found\"));\n-            }\n-        }).exceptionally(ex -> {\n-            ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n-            ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                    requestId, errorCode, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleNewTxn(CommandNewTxn command) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive new txn request {} to transaction meta store {} from {}.\", command.getRequestId(), command.getTcId(), remoteAddress);\n-        }\n-        TransactionCoordinatorID tcId = TransactionCoordinatorID.get(command.getTcId());\n-        service.pulsar().getTransactionMetadataStoreService().newTransaction(tcId)\n-            .whenComplete(((txnID, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response {} for new txn request {}\", tcId.getId(),  command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for new txn request {}\", command.getRequestId(), ex);\n-                    }\n-                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), tcId.getId(), BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            }));\n-    }\n-\n-    @Override\n-    protected void handleAddPartitionToTxn(PulsarApi.CommandAddPartitionToTxn command) {\n-        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive add published partition to txn request {} from {} with txnId {}\", command.getRequestId(), remoteAddress, txnID);\n-        }\n-        service.pulsar().getTransactionMetadataStoreService().addProducedPartitionToTxn(txnID, command.getPartitionsList())\n-            .whenComplete(((v, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response success for add published partition to txn request {}\",  command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(),\n-                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for add published partition to txn request {}\",  command.getRequestId(), ex);\n-                    }\n-                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n-                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            }));\n-    }\n-\n-    @Override\n-    protected void handleEndTxn(PulsarApi.CommandEndTxn command) {\n-        TxnStatus newStatus = null;\n-        switch (command.getTxnAction()) {\n-            case COMMIT:\n-                newStatus = TxnStatus.COMMITTING;\n-                break;\n-            case ABORT:\n-                newStatus = TxnStatus.ABORTING;\n-                break;\n-        }\n-        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive end txn by {} request {} from {} with txnId {}\", newStatus, command.getRequestId(), remoteAddress, txnID);\n-        }\n-        service.pulsar().getTransactionMetadataStoreService().updateTxnStatus(txnID, newStatus, TxnStatus.OPEN)\n-            .whenComplete((v, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response success for end txn request {}\", command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(),\n-                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for end txn request {}\", command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n-                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            });\n-    }\n-\n-    private CompletableFuture<SchemaVersion> tryAddSchema(Topic topic, SchemaData schema) {\n-        if (schema != null) {\n-            return topic.addSchema(schema);\n-        } else {\n-            return topic.hasSchema().thenCompose((hasSchema) -> {\n-                log.info(\"[{}] {} configured with schema {}\",\n-                         remoteAddress, topic.getName(), hasSchema);\n-                CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n-                if (hasSchema && (schemaValidationEnforced || topic.getSchemaValidationEnforced())) {\n-                    result.completeExceptionally(new IncompatibleSchemaException(\n-                            \"Producers cannot connect or send message without a schema to topics with a schema\"));\n-                } else {\n-                    result.complete(SchemaVersion.Empty);\n-                }\n-                return result;\n-            });\n-        }\n-    }\n-\n-    @Override\n-    protected boolean isHandshakeCompleted() {\n-        return state == State.Connected;\n-    }\n-\n-    ChannelHandlerContext ctx() {\n-        return ctx;\n-    }\n-\n-    public void closeProducer(Producer producer) {\n-        // removes producer-connection from map and send close command to producer\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n-        }\n-        long producerId = producer.getProducerId();\n-        producers.remove(producerId);\n-        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n-            ctx.writeAndFlush(Commands.newCloseProducer(producerId, -1L));\n-        } else {\n-            close();\n-        }\n-\n-    }\n-\n-    public void closeConsumer(Consumer consumer) {\n-        // removes consumer-connection from map and send close command to consumer\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n-        }\n-        long consumerId = consumer.consumerId();\n-        consumers.remove(consumerId);\n-        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n-            ctx.writeAndFlush(Commands.newCloseConsumer(consumerId, -1L));\n-        } else {\n-            close();\n-        }\n-    }\n-\n-    /**\n-     * It closes the connection with client which triggers {@code channelInactive()} which clears all producers and\n-     * consumers from connection-map\n-     */\n-    protected void close() {\n-        ctx.close();\n-    }\n-\n-    public SocketAddress clientAddress() {\n-        return remoteAddress;\n-    }\n-\n-    public void removedConsumer(Consumer consumer) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n-        }\n-\n-        consumers.remove(consumer.consumerId());\n-    }\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n \n-    public void removedProducer(Producer producer) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n-        }\n-        producers.remove(producer.getProducerId());\n-    }\n+public interface ServerCnx {\n \n-    public boolean isActive() {\n-        return isActive;\n-    }\n+    String getClientVersion();\n \n-    public boolean isWritable() {\n-        return ctx.channel().isWritable();\n-    }\n+    SocketAddress clientAddress();\n \n-    public void startSendOperation(Producer producer, int msgSize) {\n-        MSG_PUBLISH_BUFFER_SIZE_UPDATER.getAndAdd(this, msgSize);\n-        boolean isPublishRateExceeded = producer.getTopic().isPublishRateExceeded();\n-        if (++pendingSendRequest == maxPendingSendRequests || isPublishRateExceeded) {\n-            // When the quota of pending send requests is reached, stop reading from socket to cause backpressure on\n-            // client connection, possibly shared between multiple producers\n-            ctx.channel().config().setAutoRead(false);\n-            autoReadDisabledRateLimiting = isPublishRateExceeded;\n+    BrokerService getBrokerService();\n \n-        }\n-        if (getBrokerService().isReachMessagePublishBufferThreshold()) {\n-            ctx.channel().config().setAutoRead(false);\n-            autoReadDisabledPublishBufferLimiting = true;\n-        }\n-    }\n+    boolean isBatchMessageCompatibleVersion();\n \n-    public void completedSendOperation(boolean isNonPersistentTopic, int msgSize) {\n-        MSG_PUBLISH_BUFFER_SIZE_UPDATER.getAndAdd(this, -msgSize);\n-        if (--pendingSendRequest == resumeReadsThreshold) {\n-            // Resume reading from socket\n-            ctx.channel().config().setAutoRead(true);\n-            // triggers channel read if autoRead couldn't trigger it\n-            ctx.read();\n-        }\n-        if (isNonPersistentTopic) {\n-            nonPersistentPendingMessages--;\n-        }\n-    }\n+    String getRole();\n \n-    public void enableCnxAutoRead() {\n-        // we can add check (&& pendingSendRequest < MaxPendingSendRequests) here but then it requires\n-        // pendingSendRequest to be volatile and it can be expensive while writing. also this will be called on if\n-        // throttling is enable on the topic. so, avoid pendingSendRequest check will be fine.\n-        if (!ctx.channel().config().isAutoRead() && !autoReadDisabledRateLimiting && !autoReadDisabledPublishBufferLimiting) {\n-            // Resume reading from socket if pending-request is not reached to threshold\n-            ctx.channel().config().setAutoRead(true);\n-            // triggers channel read\n-            ctx.read();\n-        }\n-    }\n+    boolean isActive();\n \n-    public void disableCnxAutoRead() {\n-        if (ctx.channel().config().isAutoRead() ) {\n-            ctx.channel().config().setAutoRead(false);\n-        }\n-    }\n+    void completedSendOperation(boolean isNonPersistentTopic, int msgSize);", "originalCommit": "3a16679e8526da58214f66c16754fee1367eac2f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9a753a66b82eda6e0ad82bf3eec2278955586ea9", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\nindex 359db504148..ae01f3f3b55 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n\n@@ -28,57 +28,109 @@ import java.util.concurrent.CompletableFuture;\n \n public interface ServerCnx {\n \n-    String getClientVersion();\n+    default String getClientVersion() {\n+        return null;\n+    }\n \n     SocketAddress clientAddress();\n \n     BrokerService getBrokerService();\n \n-    boolean isBatchMessageCompatibleVersion();\n+    default boolean isBatchMessageCompatibleVersion() {\n+        return true;\n+    }\n \n-    String getRole();\n+    /**\n+     * The security role for this connection\n+     * @return the role\n+     */\n+    default String getRole() {\n+        return null;\n+    }\n \n-    boolean isActive();\n+    default AuthenticationDataSource getAuthenticationData() {\n+        return null;\n+    }\n \n-    void completedSendOperation(boolean isNonPersistentTopic, int msgSize);\n+    default boolean isActive() {\n+        return true;\n+    }\n \n-    AuthenticationDataSource getAuthenticationData();\n+    default boolean isWritable() {\n+        return true;\n+    }\n \n-    void removedProducer(Producer producer);\n+    default void completedSendOperation(boolean isNonPersistentTopic, int msgSize) {\n+        // No-op\n+    }\n \n-    void closeProducer(Producer producer);\n+    default void removedProducer(Producer producer) {\n+        // No-op\n+    }\n \n-    void enableCnxAutoRead();\n+    default void closeProducer(Producer producer) {\n+        // No-op\n+    }\n \n-    long getMessagePublishBufferSize();\n+    default long getMessagePublishBufferSize() {\n+        return Long.MAX_VALUE;\n+    }\n \n-    void cancelPublishRateLimiting();\n+    default void cancelPublishRateLimiting() {\n+        // No-op\n+    }\n \n-    void cancelPublishBufferLimiting();\n+    default void cancelPublishBufferLimiting() {\n+        // No-op\n+    }\n \n-    void disableCnxAutoRead();\n+    default void disableCnxAutoRead() {\n+        // No-op\n+    }\n \n-    void execute(Runnable runnable);\n+    default void enableCnxAutoRead() {\n+        // No-op\n+    }\n \n-    void removedConsumer(Consumer consumer);\n+    default void execute(Runnable runnable) {\n+        CompletableFuture.runAsync(runnable);\n+    }\n \n-    void closeConsumer(Consumer consumer);\n+    default void removedConsumer(Consumer consumer) {\n+        // No-op\n+    }\n \n-    boolean isWritable();\n+    default void closeConsumer(Consumer consumer) {\n+        // No-op\n+    }\n \n-    void sendProducerError(long producerId, long sequenceId, ServerError serverError, String message);\n+    default void sendProducerError(long producerId, long sequenceId, ServerError serverError, String message) {\n+        // No-op\n+    }\n \n-    void sendProducerReceipt(long producerId, long sequenceId, long highestSequenceId, long ledgerId, long entryId);\n+    default void sendProducerReceipt(long producerId, long sequenceId, long highestSequenceId, long ledgerId, long entryId) {\n+        // No-op\n+    }\n \n-    void sendActiveConsumerChange(long consumerId, boolean isActive);\n+    default void sendActiveConsumerChange(long consumerId, boolean isActive) {\n+        // No-op\n+    }\n \n-    void sendSuccess(long requestId);\n+    default void sendSuccess(long requestId) {\n+        // No-op\n+    }\n \n-    void sendError(long requestId, ServerError error, String message);\n+    default void sendError(long requestId, ServerError error, String message) {\n+        // No-op\n+    }\n \n-    void sendReachedEndOfTopic(long consumerId);\n+    default void sendReachedEndOfTopic(long consumerId) {\n+        // No-op\n+    }\n \n-    CompletableFuture<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n+    default CompletableFuture<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n             int partitionIdx, final List<Entry> entries, EntryBatchSizes batchSizes,\n-            RedeliveryTracker redeliveryTracker);\n+            RedeliveryTracker redeliveryTracker) {\n+        return CompletableFuture.completedFuture(null);\n+    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1NjUxMQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r409456511", "bodyText": "Replace with an Optional ?", "author": "cbornet", "createdAt": "2020-04-16T10:38:09Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -18,1911 +18,119 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static org.apache.commons.lang3.StringUtils.isNotBlank;\n-import static org.apache.pulsar.broker.admin.impl.PersistentTopicsBase.getPartitionedTopicMetadata;\n-import static org.apache.pulsar.broker.lookup.TopicLookupBase.lookupTopicAsync;\n-import static org.apache.pulsar.common.protocol.Commands.newLookupErrorResponse;\n-import static org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion.v5;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Strings;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOption;\n-import io.netty.handler.ssl.SslHandler;\n-\n-import java.net.SocketAddress;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.stream.Collectors;\n-\n-import javax.naming.AuthenticationException;\n-import javax.net.ssl.SSLSession;\n-\n-import org.apache.bookkeeper.mledger.AsyncCallbacks;\n import org.apache.bookkeeper.mledger.Entry;\n-import org.apache.bookkeeper.mledger.ManagedLedgerException;\n-import org.apache.bookkeeper.mledger.Position;\n-import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n-import org.apache.bookkeeper.mledger.impl.PositionImpl;\n-import org.apache.bookkeeper.mledger.util.SafeRun;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.exception.ExceptionUtils;\n-import org.apache.pulsar.broker.PulsarServerException;\n-import org.apache.pulsar.broker.PulsarService;\n import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n-import org.apache.pulsar.broker.authentication.AuthenticationProvider;\n-import org.apache.pulsar.broker.authentication.AuthenticationState;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerBusyException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ServerMetadataException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ServiceUnitNotReadyException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.SubscriptionNotFoundException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.TopicNotFoundException;\n-import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n-import org.apache.pulsar.broker.service.schema.exceptions.IncompatibleSchemaException;\n-import org.apache.pulsar.broker.service.schema.SchemaRegistryService;\n-import org.apache.pulsar.broker.web.RestException;\n-import org.apache.pulsar.client.api.PulsarClientException;\n-import org.apache.pulsar.client.impl.BatchMessageIdImpl;\n-import org.apache.pulsar.client.impl.ClientCnx;\n-import org.apache.pulsar.client.impl.MessageIdImpl;\n-import org.apache.pulsar.common.api.AuthData;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandNewTxn;\n-import org.apache.pulsar.common.protocol.CommandUtils;\n-import org.apache.pulsar.common.protocol.Commands;\n-import org.apache.pulsar.common.protocol.PulsarHandler;\n-import org.apache.pulsar.common.api.proto.PulsarApi;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandAuthResponse;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseConsumer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseProducer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConnect;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStats;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStatsResponse;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandFlow;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetLastMessageId;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetSchema;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetOrCreateSchema;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetTopicsOfNamespace;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandLookupTopic;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandPartitionedTopicMetadata;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandProducer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandRedeliverUnacknowledgedMessages;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSeek;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSend;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.SubType;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandUnsubscribe;\n-import org.apache.pulsar.common.api.proto.PulsarApi.FeatureFlags;\n-import org.apache.pulsar.common.api.proto.PulsarApi.MessageIdData;\n-import org.apache.pulsar.common.api.proto.PulsarApi.MessageMetadata;\n-import org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion;\n import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n-import org.apache.pulsar.common.naming.Metadata;\n-import org.apache.pulsar.common.naming.NamespaceName;\n-import org.apache.pulsar.common.naming.TopicName;\n-import org.apache.pulsar.common.policies.data.BacklogQuota;\n-import org.apache.pulsar.common.policies.data.ConsumerStats;\n-import org.apache.pulsar.common.protocol.schema.SchemaData;\n-import org.apache.pulsar.common.protocol.schema.SchemaInfoUtil;\n-import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n-import org.apache.pulsar.common.schema.SchemaType;\n-import org.apache.pulsar.common.util.FutureUtil;\n-import org.apache.pulsar.common.util.collections.ConcurrentLongHashMap;\n-import org.apache.pulsar.shaded.com.google.protobuf.v241.GeneratedMessageLite;\n-import org.apache.pulsar.transaction.coordinator.TransactionCoordinatorID;\n-import org.apache.pulsar.transaction.impl.common.TxnID;\n-import org.apache.pulsar.transaction.impl.common.TxnStatus;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class ServerCnx extends PulsarHandler {\n-    private final BrokerService service;\n-    private final SchemaRegistryService schemaService;\n-    private final ConcurrentLongHashMap<CompletableFuture<Producer>> producers;\n-    private final ConcurrentLongHashMap<CompletableFuture<Consumer>> consumers;\n-    private State state;\n-    private volatile boolean isActive = true;\n-    String authRole = null;\n-    AuthenticationDataSource authenticationData;\n-    AuthenticationProvider authenticationProvider;\n-    AuthenticationState authState;\n-    // In case of proxy, if the authentication credentials are forwardable,\n-    // it will hold the credentials of the original client\n-    AuthenticationState originalAuthState;\n-    private boolean pendingAuthChallengeResponse = false;\n-\n-    // Max number of pending requests per connections. If multiple producers are sharing the same connection the flow\n-    // control done by a single producer might not be enough to prevent write spikes on the broker.\n-    private final int maxPendingSendRequests;\n-    private final int resumeReadsThreshold;\n-    private int pendingSendRequest = 0;\n-    private final String replicatorPrefix;\n-    private String clientVersion = null;\n-    private int nonPersistentPendingMessages = 0;\n-    private final int MaxNonPersistentPendingMessages;\n-    private String originalPrincipal = null;\n-    private Set<String> proxyRoles;\n-    private boolean authenticateOriginalAuthData;\n-    private final boolean schemaValidationEnforced;\n-    private String authMethod = \"none\";\n-    private final int maxMessageSize;\n-\n-    // Flag to manage throttling-rate by atomically enable/disable read-channel.\n-    private volatile boolean autoReadDisabledRateLimiting = false;\n-    private FeatureFlags features;\n-    // Flag to manage throttling-publish-buffer by atomically enable/disable read-channel.\n-    private volatile boolean autoReadDisabledPublishBufferLimiting = false;\n-    private static final AtomicLongFieldUpdater<ServerCnx> MSG_PUBLISH_BUFFER_SIZE_UPDATER =\n-            AtomicLongFieldUpdater.newUpdater(ServerCnx.class, \"messagePublishBufferSize\");\n-    private volatile long messagePublishBufferSize = 0;\n-\n-    enum State {\n-        Start, Connected, Failed, Connecting\n-    }\n-\n-    public ServerCnx(PulsarService pulsar) {\n-        super(pulsar.getBrokerService().getKeepAliveIntervalSeconds(), TimeUnit.SECONDS);\n-        this.service = pulsar.getBrokerService();\n-        this.schemaService = pulsar.getSchemaRegistryService();\n-        this.state = State.Start;\n-\n-        // This maps are not heavily contended since most accesses are within the cnx thread\n-        this.producers = new ConcurrentLongHashMap<>(8, 1);\n-        this.consumers = new ConcurrentLongHashMap<>(8, 1);\n-        this.replicatorPrefix = service.pulsar().getConfiguration().getReplicatorPrefix();\n-        this.MaxNonPersistentPendingMessages = service.pulsar().getConfiguration()\n-                .getMaxConcurrentNonPersistentMessagePerConnection();\n-        this.proxyRoles = service.pulsar().getConfiguration().getProxyRoles();\n-        this.authenticateOriginalAuthData = service.pulsar().getConfiguration().isAuthenticateOriginalAuthData();\n-        this.schemaValidationEnforced = pulsar.getConfiguration().isSchemaValidationEnforced();\n-        this.maxMessageSize = pulsar.getConfiguration().getMaxMessageSize();\n-        this.maxPendingSendRequests = pulsar.getConfiguration().getMaxPendingPublishdRequestsPerConnection();\n-        this.resumeReadsThreshold = maxPendingSendRequests / 2;\n-    }\n-\n-    @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelActive(ctx);\n-        log.info(\"New connection from {}\", remoteAddress);\n-        this.ctx = ctx;\n-    }\n-\n-    @Override\n-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelInactive(ctx);\n-        isActive = false;\n-        log.info(\"Closed connection from {}\", remoteAddress);\n-\n-        // Connection is gone, close the producers immediately\n-        producers.values().forEach((producerFuture) -> {\n-            if (producerFuture.isDone() && !producerFuture.isCompletedExceptionally()) {\n-                Producer producer = producerFuture.getNow(null);\n-                producer.closeNow(true);\n-            }\n-        });\n-\n-        consumers.values().forEach((consumerFuture) -> {\n-            Consumer consumer;\n-            if (consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-                consumer = consumerFuture.getNow(null);\n-            } else {\n-                return;\n-            }\n-\n-            try {\n-                consumer.close();\n-            } catch (BrokerServiceException e) {\n-                log.warn(\"Consumer {} was already closed: {}\", consumer, e);\n-            }\n-        });\n-    }\n-\n-    @Override\n-    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Channel writability has changed to: {}\", ctx.channel().isWritable());\n-        }\n-    }\n-\n-    @Override\n-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-        if (state != State.Failed) {\n-            // No need to report stack trace for known exceptions that happen in disconnections\n-            log.warn(\"[{}] Got exception {}\", remoteAddress,\n-                    ClientCnx.isKnownException(cause) ? cause : ExceptionUtils.getStackTrace(cause));\n-            state = State.Failed;\n-        } else {\n-            // At default info level, suppress all subsequent exceptions that are thrown when the connection has already\n-            // failed\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Got exception: {}\", remoteAddress, cause);\n-            }\n-        }\n-        ctx.close();\n-    }\n-\n-    /*\n-     * If authentication and authorization is enabled(and not sasl) and if the authRole is one of proxyRoles we want to enforce\n-     * - the originalPrincipal is given while connecting\n-     * - originalPrincipal is not blank\n-     * - originalPrincipal is not a proxy principal\n-     */\n-    private boolean invalidOriginalPrincipal(String originalPrincipal) {\n-        return (service.isAuthenticationEnabled() && service.isAuthorizationEnabled()\n-            && proxyRoles.contains(authRole) && (StringUtils.isBlank(originalPrincipal) || proxyRoles.contains(originalPrincipal)));\n-    }\n-\n-    // ////\n-    // // Incoming commands handling\n-    // ////\n-\n-    @Override\n-    protected void handleLookup(CommandLookupTopic lookup) {\n-        final long requestId = lookup.getRequestId();\n-        final boolean authoritative = lookup.getAuthoritative();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received Lookup from {} for {}\", lookup.getTopic(), remoteAddress, requestId);\n-        }\n-\n-        TopicName topicName = validateTopicName(lookup.getTopic(), requestId, lookup);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n-        if (lookupSemaphore.tryAcquire()) {\n-            if (invalidOriginalPrincipal(originalPrincipal)) {\n-                final String msg = \"Valid Proxy Client role should be provided for lookup \";\n-                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                        originalPrincipal, topicName);\n-                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return;\n-            }\n-            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-                isProxyAuthorizedFuture = service.getAuthorizationService().canLookupAsync(topicName, authRole,\n-                    authenticationData);\n-            } else {\n-                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-            }\n-            String finalOriginalPrincipal = originalPrincipal;\n-            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-                if (isProxyAuthorized) {\n-                    lookupTopicAsync(getBrokerService().pulsar(), topicName, authoritative,\n-                            finalOriginalPrincipal != null ? finalOriginalPrincipal : authRole, authenticationData,\n-                            requestId).handle((lookupResponse, ex) -> {\n-                                if (ex == null) {\n-                                    ctx.writeAndFlush(lookupResponse);\n-                                } else {\n-                                    // it should never happen\n-                                    log.warn(\"[{}] lookup failed with error {}, {}\", remoteAddress, topicName,\n-                                            ex.getMessage(), ex);\n-                                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.ServiceNotReady,\n-                                            ex.getMessage(), requestId));\n-                                }\n-                                lookupSemaphore.release();\n-                                return null;\n-                            });\n-                } else {\n-                    final String msg = \"Proxy Client is not authorized to Lookup\";\n-                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                    lookupSemaphore.release();\n-                }\n-                return null;\n-            }).exceptionally(ex -> {\n-                final String msg = \"Exception occured while trying to authorize lookup\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName, ex);\n-                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return null;\n-            });\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Failed lookup due to too many lookup-requests {}\", remoteAddress, topicName);\n-            }\n-            ctx.writeAndFlush(newLookupErrorResponse(ServerError.TooManyRequests,\n-                    \"Failed due to too many pending lookup requests\", requestId));\n-        }\n-    }\n-\n-    @Override\n-    protected void handlePartitionMetadataRequest(CommandPartitionedTopicMetadata partitionMetadata) {\n-        final long requestId = partitionMetadata.getRequestId();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received PartitionMetadataLookup from {} for {}\", partitionMetadata.getTopic(),\n-                    remoteAddress, requestId);\n-        }\n-\n-        TopicName topicName = validateTopicName(partitionMetadata.getTopic(), requestId, partitionMetadata);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n-        if (lookupSemaphore.tryAcquire()) {\n-            if (invalidOriginalPrincipal(originalPrincipal)) {\n-                final String msg = \"Valid Proxy Client role should be provided for getPartitionMetadataRequest \";\n-                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                        originalPrincipal, topicName);\n-                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError,\n-                        msg, requestId));\n-                lookupSemaphore.release();\n-                return;\n-            }\n-            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-                isProxyAuthorizedFuture = service.getAuthorizationService()\n-                        .canLookupAsync(topicName, authRole, authenticationData);\n-            } else {\n-                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-            }\n-            String finalOriginalPrincipal = originalPrincipal;\n-            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-                if (isProxyAuthorized) {\n-                    getPartitionedTopicMetadata(getBrokerService().pulsar(),\n-                            authRole, finalOriginalPrincipal, authenticationData,\n-                            topicName).handle((metadata, ex) -> {\n-                                if (ex == null) {\n-                                    int partitions = metadata.partitions;\n-                                    ctx.writeAndFlush(Commands.newPartitionMetadataResponse(partitions, requestId));\n-                                } else {\n-                                    if (ex instanceof PulsarClientException) {\n-                                        log.warn(\"Failed to authorize {} at [{}] on topic {} : {}\", getRole(),\n-                                                remoteAddress, topicName, ex.getMessage());\n-                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(\n-                                                ServerError.AuthorizationError, ex.getMessage(), requestId));\n-                                    } else {\n-                                        log.warn(\"Failed to get Partitioned Metadata [{}] {}: {}\", remoteAddress,\n-                                                topicName, ex.getMessage(), ex);\n-                                        ServerError error = (ex instanceof RestException)\n-                                                && ((RestException) ex).getResponse().getStatus() < 500\n-                                                        ? ServerError.MetadataError\n-                                                        : ServerError.ServiceNotReady;\n-                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(error,\n-                                                ex.getMessage(), requestId));\n-                                    }\n-                                }\n-                                lookupSemaphore.release();\n-                                return null;\n-                            });\n-                } else {\n-                    final String msg = \"Proxy Client is not authorized to Get Partition Metadata\";\n-                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                    ctx.writeAndFlush(\n-                            Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n-                    lookupSemaphore.release();\n-                }\n-                return null;\n-            }).exceptionally(ex -> {\n-                final String msg = \"Exception occured while trying to authorize get Partition Metadata\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return null;\n-            });\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Failed Partition-Metadata lookup due to too many lookup-requests {}\", remoteAddress,\n-                        topicName);\n-            }\n-            ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.TooManyRequests,\n-                    \"Failed due to too many pending lookup requests\", requestId));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleConsumerStats(CommandConsumerStats commandConsumerStats) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandConsumerStats call from {}\", remoteAddress);\n-        }\n-\n-        final long requestId = commandConsumerStats.getRequestId();\n-        final long consumerId = commandConsumerStats.getConsumerId();\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n-        Consumer consumer = consumerFuture.getNow(null);\n-        ByteBuf msg = null;\n-\n-        if (consumer == null) {\n-            log.error(\n-                    \"Failed to get consumer-stats response - Consumer not found for CommandConsumerStats[remoteAddress = {}, requestId = {}, consumerId = {}]\",\n-                    remoteAddress, requestId, consumerId);\n-            msg = Commands.newConsumerStatsResponse(ServerError.ConsumerNotFound,\n-                    \"Consumer \" + consumerId + \" not found\", requestId);\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"CommandConsumerStats[requestId = {}, consumer = {}]\", requestId, consumer);\n-            }\n-            msg = Commands.newConsumerStatsResponse(createConsumerStatsResponse(consumer, requestId));\n-        }\n-\n-        ctx.writeAndFlush(msg);\n-    }\n-\n-    CommandConsumerStatsResponse.Builder createConsumerStatsResponse(Consumer consumer, long requestId) {\n-        CommandConsumerStatsResponse.Builder commandConsumerStatsResponseBuilder = CommandConsumerStatsResponse\n-                .newBuilder();\n-        ConsumerStats consumerStats = consumer.getStats();\n-        commandConsumerStatsResponseBuilder.setRequestId(requestId);\n-        commandConsumerStatsResponseBuilder.setMsgRateOut(consumerStats.msgRateOut);\n-        commandConsumerStatsResponseBuilder.setMsgThroughputOut(consumerStats.msgThroughputOut);\n-        commandConsumerStatsResponseBuilder.setMsgRateRedeliver(consumerStats.msgRateRedeliver);\n-        commandConsumerStatsResponseBuilder.setConsumerName(consumerStats.consumerName);\n-        commandConsumerStatsResponseBuilder.setAvailablePermits(consumerStats.availablePermits);\n-        commandConsumerStatsResponseBuilder.setUnackedMessages(consumerStats.unackedMessages);\n-        commandConsumerStatsResponseBuilder.setBlockedConsumerOnUnackedMsgs(consumerStats.blockedConsumerOnUnackedMsgs);\n-        commandConsumerStatsResponseBuilder.setAddress(consumerStats.getAddress());\n-        commandConsumerStatsResponseBuilder.setConnectedSince(consumerStats.getConnectedSince());\n-\n-        Subscription subscription = consumer.getSubscription();\n-        commandConsumerStatsResponseBuilder.setMsgBacklog(subscription.getNumberOfEntriesInBacklog(false));\n-        commandConsumerStatsResponseBuilder.setMsgRateExpired(subscription.getExpiredMessageRate());\n-        commandConsumerStatsResponseBuilder.setType(subscription.getTypeString());\n-\n-        return commandConsumerStatsResponseBuilder;\n-    }\n-\n-    // complete the connect and sent newConnected command\n-    private void completeConnect(int clientProtoVersion, String clientVersion) {\n-        ctx.writeAndFlush(Commands.newConnected(clientProtoVersion, maxMessageSize));\n-        state = State.Connected;\n-        remoteEndpointProtocolVersion = clientProtoVersion;\n-        if (isNotBlank(clientVersion) && !clientVersion.contains(\" \") /* ignore default version: pulsar client */) {\n-            this.clientVersion = clientVersion.intern();\n-        }\n-    }\n-\n-    // According to auth result, send newConnected or newAuthChallenge command.\n-    private State doAuthentication(AuthData clientData,\n-                                   int clientProtocolVersion,\n-                                   String clientVersion) throws Exception {\n-\n-        // The original auth state can only be set on subsequent auth attempts (and only\n-        // in presence of a proxy and if the proxy is forwarding the credentials).\n-        // In this case, the re-validation needs to be done against the original client\n-        // credentials.\n-        boolean useOriginalAuthState = (originalAuthState != null);\n-        AuthenticationState authState =  useOriginalAuthState ? originalAuthState : this.authState;\n-        String authRole = useOriginalAuthState ? originalPrincipal : this.authRole;\n-        AuthData brokerData = authState.authenticate(clientData);\n-\n-\n-        if (authState.isComplete()) {\n-            // Authentication has completed. It was either:\n-            // 1. the 1st time the authentication process was done, in which case we'll\n-            //    a `CommandConnected` response\n-            // 2. an authentication refresh, in which case we don't need to do anything else\n-\n-            String newAuthRole = authState.getAuthRole();\n-\n-            if (!useOriginalAuthState) {\n-                this.authRole = newAuthRole;\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Client successfully authenticated with {} role {} and originalPrincipal {}\",\n-                        remoteAddress, authMethod, authRole, originalPrincipal);\n-            }\n-\n-            if (state != State.Connected) {\n-                // First time authentication is done\n-                completeConnect(clientProtocolVersion, clientVersion);\n-            } else {\n-                // If the connection was already ready, it means we're doing a refresh\n-                if (!StringUtils.isEmpty(authRole)) {\n-                    if (!authRole.equals(newAuthRole)) {\n-                        log.warn(\"[{}] Principal cannot be changed during an authentication refresh\", remoteAddress);\n-                        ctx.close();\n-                    } else {\n-                        log.info(\"[{}] Refreshed authentication credentials for role {}\", remoteAddress, authRole);\n-                    }\n-                }\n-            }\n-\n-            return State.Connected;\n-        }\n-\n-        // auth not complete, continue auth with client side.\n-        ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, clientProtocolVersion));\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Authentication in progress client by method {}.\",\n-                remoteAddress, authMethod);\n-        }\n-        return State.Connecting;\n-    }\n-\n-    public void refreshAuthenticationCredentials() {\n-        AuthenticationState authState = this.originalAuthState != null ? originalAuthState : this.authState;\n-\n-        if (authState == null) {\n-            // Authentication is disabled or there's no local state to refresh\n-            return;\n-        } else if (getState() != State.Connected || !isActive) {\n-            // Connection is either still being established or already closed.\n-            return;\n-        } else if (authState != null && !authState.isExpired()) {\n-            // Credentials are still valid. Nothing to do at this point\n-            return;\n-        } else if (originalPrincipal != null && originalAuthState == null) {\n-            log.info(\n-                    \"[{}] Cannot revalidate user credential when using proxy and not forwarding the credentials. Closing connection\",\n-                    remoteAddress);\n-            return;\n-        }\n-\n-        ctx.executor().execute(SafeRun.safeRun(() -> {\n-            log.info(\"[{}] Refreshing authentication credentials for originalPrincipal {} and authRole {}\", remoteAddress, originalPrincipal, this.authRole);\n-\n-            if (!supportsAuthenticationRefresh()) {\n-                log.warn(\"[{}] Closing connection because client doesn't support auth credentials refresh\", remoteAddress);\n-                ctx.close();\n-                return;\n-            }\n-\n-            if (pendingAuthChallengeResponse) {\n-                log.warn(\"[{}] Closing connection after timeout on refreshing auth credentials\", remoteAddress);\n-                ctx.close();\n-                return;\n-            }\n-\n-            try {\n-                AuthData brokerData = authState.refreshAuthentication();\n-\n-                ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, remoteEndpointProtocolVersion));\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] Sent auth challenge to client to refresh credentials with method: {}.\",\n-                        remoteAddress, authMethod);\n-                }\n-\n-                pendingAuthChallengeResponse = true;\n-\n-            } catch (AuthenticationException e) {\n-                log.warn(\"[{}] Failed to refresh authentication: {}\", remoteAddress, e);\n-                ctx.close();\n-            }\n-        }));\n-    }\n-\n-    @Override\n-    protected void handleConnect(CommandConnect connect) {\n-        checkArgument(state == State.Start);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CONNECT from {}, auth enabled: {}\",\n-                remoteAddress, service.isAuthenticationEnabled());\n-        }\n-\n-        String clientVersion = connect.getClientVersion();\n-        int clientProtocolVersion = connect.getProtocolVersion();\n-        features = connect.getFeatureFlags();\n-\n-        if (!service.isAuthenticationEnabled()) {\n-            completeConnect(clientProtocolVersion, clientVersion);\n-            return;\n-        }\n-\n-        try {\n-            AuthData clientData = AuthData.of(connect.getAuthData().toByteArray());\n-\n-            // init authentication\n-            if (connect.hasAuthMethodName()) {\n-                authMethod = connect.getAuthMethodName();\n-            } else if (connect.hasAuthMethod()) {\n-                // Legacy client is passing enum\n-                authMethod = connect.getAuthMethod().name().substring(10).toLowerCase();\n-            } else {\n-                authMethod = \"none\";\n-            }\n-\n-            authenticationProvider = getBrokerService()\n-                .getAuthenticationService()\n-                .getAuthenticationProvider(authMethod);\n-\n-            // Not find provider named authMethod. Most used for tests.\n-            // In AuthenticationDisabled, it will set authMethod \"none\".\n-            if (authenticationProvider == null) {\n-                authRole = getBrokerService().getAuthenticationService().getAnonymousUserRole()\n-                    .orElseThrow(() ->\n-                        new AuthenticationException(\"No anonymous role, and no authentication provider configured\"));\n-                completeConnect(clientProtocolVersion, clientVersion);\n-                return;\n-            }\n-\n-            // init authState and other var\n-            ChannelHandler sslHandler = ctx.channel().pipeline().get(PulsarChannelInitializer.TLS_HANDLER);\n-            SSLSession sslSession = null;\n-            if (sslHandler != null) {\n-                sslSession = ((SslHandler) sslHandler).engine().getSession();\n-            }\n-\n-            authState = authenticationProvider.newAuthState(clientData, remoteAddress, sslSession);\n-            authenticationData = authState.getAuthDataSource();\n-            state = doAuthentication(clientData, clientProtocolVersion, clientVersion);\n-\n-            // This will fail the check if:\n-            //  1. client is coming through a proxy\n-            //  2. we require to validate the original credentials\n-            //  3. no credentials were passed\n-            if (connect.hasOriginalPrincipal() && service.getPulsar().getConfig().isAuthenticateOriginalAuthData()) {\n-                AuthenticationProvider originalAuthenticationProvider = getBrokerService()\n-                        .getAuthenticationService()\n-                        .getAuthenticationProvider(authMethod);\n-                originalAuthState = originalAuthenticationProvider.newAuthState(\n-                        AuthData.of(connect.getOriginalAuthData().getBytes()),\n-                        remoteAddress,\n-                        sslSession);\n-                originalPrincipal = originalAuthState.getAuthRole();\n-            } else {\n-                originalPrincipal = connect.hasOriginalPrincipal() ? connect.getOriginalPrincipal() : null;\n-            }\n-        } catch (Exception e) {\n-            String msg = \"Unable to authenticate\";\n-            if (e instanceof AuthenticationException) {\n-                log.warn(\"[{}] {}: {}\", remoteAddress, msg, e.getMessage());\n-            } else {\n-                log.warn(\"[{}] {}\", remoteAddress, msg, e);\n-            }\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, msg));\n-            close();\n-        }\n-    }\n-\n-    @Override\n-    protected void handleAuthResponse(CommandAuthResponse authResponse) {\n-        checkArgument(authResponse.hasResponse());\n-        checkArgument(authResponse.getResponse().hasAuthData() && authResponse.getResponse().hasAuthMethodName());\n-\n-        pendingAuthChallengeResponse = false;\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received AuthResponse from {}, auth method: {}\",\n-                remoteAddress, authResponse.getResponse().getAuthMethodName());\n-        }\n-\n-        try {\n-            AuthData clientData = AuthData.of(authResponse.getResponse().getAuthData().toByteArray());\n-            doAuthentication(clientData, authResponse.getProtocolVersion(), authResponse.getClientVersion());\n-        } catch (AuthenticationException e) {\n-            log.warn(\"[{}] Authentication failed: {} \", remoteAddress, e.getMessage());\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, e.getMessage()));\n-            close();\n-        } catch (Exception e) {\n-            String msg = \"Unable to handleAuthResponse\";\n-            log.warn(\"[{}] {} \", remoteAddress, msg, e);\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.UnknownError, msg));\n-            close();\n-        }\n-    }\n-\n-    @Override\n-    protected void handleSubscribe(final CommandSubscribe subscribe) {\n-        checkArgument(state == State.Connected);\n-        final long requestId = subscribe.getRequestId();\n-        final long consumerId = subscribe.getConsumerId();\n-        TopicName topicName = validateTopicName(subscribe.getTopic(), requestId, subscribe);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        if (invalidOriginalPrincipal(originalPrincipal)) {\n-            final String msg = \"Valid Proxy Client role should be provided while subscribing \";\n-            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                    originalPrincipal, topicName);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            return;\n-        }\n-\n-        final String subscriptionName = subscribe.getSubscription();\n-        final SubType subType = subscribe.getSubType();\n-        final String consumerName = subscribe.getConsumerName();\n-        final boolean isDurable = subscribe.getDurable();\n-        final MessageIdImpl startMessageId = subscribe.hasStartMessageId() ? new BatchMessageIdImpl(\n-                subscribe.getStartMessageId().getLedgerId(), subscribe.getStartMessageId().getEntryId(),\n-                subscribe.getStartMessageId().getPartition(), subscribe.getStartMessageId().getBatchIndex())\n-                : null;\n-        final int priorityLevel = subscribe.hasPriorityLevel() ? subscribe.getPriorityLevel() : 0;\n-        final boolean readCompacted = subscribe.getReadCompacted();\n-        final Map<String, String> metadata = CommandUtils.metadataFromCommand(subscribe);\n-        final InitialPosition initialPosition = subscribe.getInitialPosition();\n-        final long startMessageRollbackDurationSec = subscribe.hasStartMessageRollbackDurationSec()\n-                ? subscribe.getStartMessageRollbackDurationSec()\n-                : -1;\n-        final SchemaData schema = subscribe.hasSchema() ? getSchema(subscribe.getSchema()) : null;\n-        final boolean isReplicated = subscribe.hasReplicateSubscriptionState() && subscribe.getReplicateSubscriptionState();\n-        final boolean forceTopicCreation = subscribe.getForceTopicCreation();\n-        final PulsarApi.KeySharedMeta keySharedMeta = subscribe.hasKeySharedMeta() ? subscribe.getKeySharedMeta() : null;\n-\n-        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-            isProxyAuthorizedFuture = service.getAuthorizationService().canConsumeAsync(topicName, authRole,\n-                    authenticationData, subscribe.getSubscription());\n-        } else {\n-            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-        }\n-        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-            if (isProxyAuthorized) {\n-                CompletableFuture<Boolean> authorizationFuture;\n-                if (service.isAuthorizationEnabled()) {\n-                    authorizationFuture = service.getAuthorizationService().canConsumeAsync(topicName,\n-                            originalPrincipal != null ? originalPrincipal : authRole, authenticationData,\n-                            subscriptionName);\n-                } else {\n-                    authorizationFuture = CompletableFuture.completedFuture(true);\n-                }\n-\n-                authorizationFuture.thenApply(isAuthorized -> {\n-                    if (isAuthorized) {\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"[{}] Client is authorized to subscribe with role {}\", remoteAddress, authRole);\n-                        }\n-\n-                        log.info(\"[{}] Subscribing on topic {} / {}\", remoteAddress, topicName, subscriptionName);\n-                        try {\n-                            Metadata.validateMetadata(metadata);\n-                        } catch (IllegalArgumentException iae) {\n-                            final String msg = iae.getMessage();\n-                            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n-                            return null;\n-                        }\n-                        CompletableFuture<Consumer> consumerFuture = new CompletableFuture<>();\n-                        CompletableFuture<Consumer> existingConsumerFuture = consumers.putIfAbsent(consumerId,\n-                                consumerFuture);\n-\n-                        if (existingConsumerFuture != null) {\n-                            if (existingConsumerFuture.isDone() && !existingConsumerFuture.isCompletedExceptionally()) {\n-                                Consumer consumer = existingConsumerFuture.getNow(null);\n-                                log.info(\"[{}] Consumer with the same id {} is already created: {}\", remoteAddress,\n-                                        consumerId, consumer);\n-                                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-                                return null;\n-                            } else {\n-                                // There was an early request to create a consumer with same consumerId. This can happen\n-                                // when\n-                                // client timeout is lower the broker timeouts. We need to wait until the previous\n-                                // consumer\n-                                // creation request either complete or fails.\n-                                log.warn(\"[{}][{}][{}] Consumer with id {} is already present on the connection\", remoteAddress,\n-                                        topicName, subscriptionName, consumerId);\n-                                ServerError error = null;\n-                                if(!existingConsumerFuture.isDone()) {\n-                                    error = ServerError.ServiceNotReady;\n-                                }else {\n-                                    error = getErrorCode(existingConsumerFuture);\n-                                    consumers.remove(consumerId);\n-                                }\n-                                ctx.writeAndFlush(Commands.newError(requestId, error,\n-                                        \"Consumer is already present on the connection\"));\n-                                return null;\n-                            }\n-                        }\n-\n-                        boolean createTopicIfDoesNotExist = forceTopicCreation\n-                                && service.isAllowAutoTopicCreation(topicName.toString());\n-\n-                        service.getTopic(topicName.toString(), createTopicIfDoesNotExist)\n-                                .thenCompose(optTopic -> {\n-                                    if (!optTopic.isPresent()) {\n-                                        return FutureUtil\n-                                                .failedFuture(new TopicNotFoundException(\"Topic does not exist\"));\n-                                    }\n-\n-                                    Topic topic = optTopic.get();\n-\n-                                    boolean rejectSubscriptionIfDoesNotExist = isDurable\n-                                        && !service.isAllowAutoSubscriptionCreation(topicName.toString())\n-                                        && !topic.getSubscriptions().containsKey(subscriptionName);\n-\n-                                    if (rejectSubscriptionIfDoesNotExist) {\n-                                        return FutureUtil\n-                                            .failedFuture(new SubscriptionNotFoundException(\"Subscription does not exist\"));\n-                                    }\n-\n-                                    if (schema != null) {\n-                                        return topic.addSchemaIfIdleOrCheckCompatible(schema)\n-                                            .thenCompose(v -> topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n-                                                    subType, priorityLevel, consumerName, isDurable,\n-                                                    startMessageId, metadata,\n-                                                    readCompacted, initialPosition, startMessageRollbackDurationSec, isReplicated, keySharedMeta));\n-                                    } else {\n-                                        return topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n-                                            subType, priorityLevel, consumerName, isDurable,\n-                                            startMessageId, metadata, readCompacted, initialPosition,\n-                                            startMessageRollbackDurationSec, isReplicated, keySharedMeta);\n-                                    }\n-                                })\n-                                .thenAccept(consumer -> {\n-                                    if (consumerFuture.complete(consumer)) {\n-                                        log.info(\"[{}] Created subscription on topic {} / {}\", remoteAddress, topicName,\n-                                                subscriptionName);\n-                                        ctx.writeAndFlush(Commands.newSuccess(requestId), ctx.voidPromise());\n-                                    } else {\n-                                        // The consumer future was completed before by a close command\n-                                        try {\n-                                            consumer.close();\n-                                            log.info(\"[{}] Cleared consumer created after timeout on client side {}\",\n-                                                    remoteAddress, consumer);\n-                                        } catch (BrokerServiceException e) {\n-                                            log.warn(\n-                                                    \"[{}] Error closing consumer created after timeout on client side {}: {}\",\n-                                                    remoteAddress, consumer, e.getMessage());\n-                                        }\n-                                        consumers.remove(consumerId, consumerFuture);\n-                                    }\n-\n-                                }) //\n-                                .exceptionally(exception -> {\n-                                    if (exception.getCause() instanceof ConsumerBusyException) {\n-                                        if (log.isDebugEnabled()) {\n-                                            log.debug(\n-                                                    \"[{}][{}][{}] Failed to create consumer because exclusive consumer is already connected: {}\",\n-                                                    remoteAddress, topicName, subscriptionName,\n-                                                    exception.getCause().getMessage());\n-                                        }\n-                                    } else if (exception.getCause() instanceof BrokerServiceException) {\n-                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n-                                                subscriptionName, exception.getCause().getMessage());\n-                                    } else {\n-                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n-                                                subscriptionName, exception.getCause().getMessage(), exception);\n-                                    }\n-\n-                                    // If client timed out, the future would have been completed by subsequent close.\n-                                    // Send error\n-                                    // back to client, only if not completed already.\n-                                    if (consumerFuture.completeExceptionally(exception)) {\n-                                        ctx.writeAndFlush(Commands.newError(requestId,\n-                                                BrokerServiceException.getClientErrorCode(exception),\n-                                                exception.getCause().getMessage()));\n-                                    }\n-                                    consumers.remove(consumerId, consumerFuture);\n-\n-                                    return null;\n-\n-                                });\n-                    } else {\n-                        String msg = \"Client is not authorized to subscribe\";\n-                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n-                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-                    }\n-                    return null;\n-                }).exceptionally(e -> {\n-                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n-                    log.warn(msg);\n-                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n-                    return null;\n-                });\n-            } else {\n-                final String msg = \"Proxy Client is not authorized to subscribe\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            }\n-            return null;\n-        }).exceptionally(ex -> {\n-            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n-            if (ex.getCause() instanceof PulsarServerException) {\n-                log.info(msg);\n-            } else {\n-                log.warn(msg);\n-            }\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    private SchemaData getSchema(PulsarApi.Schema protocolSchema) {\n-        return SchemaData.builder()\n-            .data(protocolSchema.getSchemaData().toByteArray())\n-            .isDeleted(false)\n-            .timestamp(System.currentTimeMillis())\n-            .user(Strings.nullToEmpty(originalPrincipal))\n-            .type(Commands.getSchemaType(protocolSchema.getType()))\n-            .props(protocolSchema.getPropertiesList().stream().collect(\n-                Collectors.toMap(\n-                    PulsarApi.KeyValue::getKey,\n-                    PulsarApi.KeyValue::getValue\n-                )\n-            )).build();\n-    }\n-\n-    @Override\n-    protected void handleProducer(final CommandProducer cmdProducer) {\n-        checkArgument(state == State.Connected);\n-        final long producerId = cmdProducer.getProducerId();\n-        final long requestId = cmdProducer.getRequestId();\n-        // Use producer name provided by client if present\n-        final String producerName = cmdProducer.hasProducerName() ? cmdProducer.getProducerName()\n-                : service.generateUniqueProducerName();\n-        final long epoch = cmdProducer.getEpoch();\n-        final boolean userProvidedProducerName = cmdProducer.getUserProvidedProducerName();\n-        final boolean isEncrypted = cmdProducer.getEncrypted();\n-        final Map<String, String> metadata = CommandUtils.metadataFromCommand(cmdProducer);\n-        final SchemaData schema = cmdProducer.hasSchema() ? getSchema(cmdProducer.getSchema()) : null;\n-\n-        TopicName topicName = validateTopicName(cmdProducer.getTopic(), requestId, cmdProducer);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        if (invalidOriginalPrincipal(originalPrincipal)) {\n-            final String msg = \"Valid Proxy Client role should be provided while creating producer \";\n-            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                    originalPrincipal, topicName);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            return;\n-        }\n-\n-        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-            isProxyAuthorizedFuture = service.getAuthorizationService().canProduceAsync(topicName,\n-                    authRole, authenticationData);\n-        } else {\n-            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-        }\n-        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-            if (isProxyAuthorized) {\n-                CompletableFuture<Boolean> authorizationFuture;\n-                if (service.isAuthorizationEnabled()) {\n-                    authorizationFuture = service.getAuthorizationService().canProduceAsync(topicName,\n-                            originalPrincipal != null ? originalPrincipal : authRole, authenticationData);\n-                } else {\n-                    authorizationFuture = CompletableFuture.completedFuture(true);\n-                }\n-\n-                authorizationFuture.thenApply(isAuthorized -> {\n-                    if (isAuthorized) {\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"[{}] Client is authorized to Produce with role {}\", remoteAddress, authRole);\n-                        }\n-                        CompletableFuture<Producer> producerFuture = new CompletableFuture<>();\n-                        CompletableFuture<Producer> existingProducerFuture = producers.putIfAbsent(producerId,\n-                                producerFuture);\n-\n-                        if (existingProducerFuture != null) {\n-                            if (existingProducerFuture.isDone() && !existingProducerFuture.isCompletedExceptionally()) {\n-                                Producer producer = existingProducerFuture.getNow(null);\n-                                log.info(\"[{}] Producer with the same id {} is already created: {}\", remoteAddress,\n-                                        producerId, producer);\n-                                ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producer.getProducerName(),\n-                                    producer.getSchemaVersion()));\n-                                return null;\n-                            } else {\n-                                // There was an early request to create a producer with\n-                                // same producerId. This can happen when\n-                                // client\n-                                // timeout is lower the broker timeouts. We need to wait\n-                                // until the previous producer creation\n-                                // request\n-                                // either complete or fails.\n-                                ServerError error = null;\n-                                if(!existingProducerFuture.isDone()) {\n-                                    error = ServerError.ServiceNotReady;\n-                                }else {\n-                                    error = getErrorCode(existingProducerFuture);\n-                                    // remove producer with producerId as it's already completed with exception\n-                                    producers.remove(producerId);\n-                                }\n-                                log.warn(\"[{}][{}] Producer with id {} is already present on the connection\", remoteAddress,\n-                                        producerId, topicName);\n-                                ctx.writeAndFlush(Commands.newError(requestId, error,\n-                                        \"Producer is already present on the connection\"));\n-                                return null;\n-                            }\n-                        }\n-\n-                        log.info(\"[{}][{}] Creating producer. producerId={}\", remoteAddress, topicName, producerId);\n-\n-                        service.getOrCreateTopic(topicName.toString()).thenAccept((Topic topic) -> {\n-                            // Before creating producer, check if backlog quota exceeded\n-                            // on topic\n-                            if (topic.isBacklogQuotaExceeded(producerName)) {\n-                                IllegalStateException illegalStateException = new IllegalStateException(\n-                                        \"Cannot create producer on topic with backlog quota exceeded\");\n-                                BacklogQuota.RetentionPolicy retentionPolicy = topic.getBacklogQuota().getPolicy();\n-                                if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold) {\n-                                    ctx.writeAndFlush(\n-                                            Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededError,\n-                                                    illegalStateException.getMessage()));\n-                                } else if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception) {\n-                                    ctx.writeAndFlush(Commands.newError(requestId,\n-                                            ServerError.ProducerBlockedQuotaExceededException,\n-                                            illegalStateException.getMessage()));\n-                                }\n-                                producerFuture.completeExceptionally(illegalStateException);\n-                                producers.remove(producerId, producerFuture);\n-                                return;\n-                            }\n \n-                            // Check whether the producer will publish encrypted messages or not\n-                            if (topic.isEncryptionRequired() && !isEncrypted) {\n-                                String msg = String.format(\"Encryption is required in %s\", topicName);\n-                                log.warn(\"[{}] {}\", remoteAddress, msg);\n-                                ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n-                                producers.remove(producerId, producerFuture);\n-                                return;\n-                            }\n-\n-                            disableTcpNoDelayIfNeeded(topicName.toString(), producerName);\n-\n-                            CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n-\n-                            schemaVersionFuture.exceptionally(exception -> {\n-                                ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(exception),\n-                                        exception.getMessage()));\n-                                producers.remove(producerId, producerFuture);\n-                                return null;\n-                            });\n-\n-                            schemaVersionFuture.thenAccept(schemaVersion -> {\n-                                Producer producer = new Producer(topic, ServerCnx.this, producerId, producerName, authRole,\n-                                    isEncrypted, metadata, schemaVersion, epoch, userProvidedProducerName);\n-\n-                                try {\n-                                    topic.addProducer(producer);\n-\n-                                    if (isActive()) {\n-                                        if (producerFuture.complete(producer)) {\n-                                            log.info(\"[{}] Created new producer: {}\", remoteAddress, producer);\n-                                            ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producerName,\n-                                                producer.getLastSequenceId(), producer.getSchemaVersion()));\n-                                            return;\n-                                        } else {\n-                                            // The producer's future was completed before by\n-                                            // a close command\n-                                            producer.closeNow(true);\n-                                            log.info(\"[{}] Cleared producer created after timeout on client side {}\",\n-                                                remoteAddress, producer);\n-                                        }\n-                                    } else {\n-                                        producer.closeNow(true);\n-                                        log.info(\"[{}] Cleared producer created after connection was closed: {}\",\n-                                            remoteAddress, producer);\n-                                        producerFuture.completeExceptionally(\n-                                            new IllegalStateException(\"Producer created after connection was closed\"));\n-                                    }\n-                                } catch (BrokerServiceException ise) {\n-                                    log.error(\"[{}] Failed to add producer to topic {}: {}\", remoteAddress, topicName,\n-                                        ise.getMessage());\n-                                    ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(ise), ise.getMessage()));\n-                                    producerFuture.completeExceptionally(ise);\n-                                }\n-\n-                                producers.remove(producerId, producerFuture);\n-                            });\n-                        }).exceptionally(exception -> {\n-                            Throwable cause = exception.getCause();\n-                            if (!(cause instanceof ServiceUnitNotReadyException)) {\n-                                // Do not print stack traces for expected exceptions\n-                                log.error(\"[{}] Failed to create topic {}\", remoteAddress, topicName, exception);\n-                            }\n-\n-                            // If client timed out, the future would have been completed\n-                            // by subsequent close. Send error back to\n-                            // client, only if not completed already.\n-                            if (producerFuture.completeExceptionally(exception)) {\n-                                ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(cause), cause.getMessage()));\n-                            }\n-                            producers.remove(producerId, producerFuture);\n-\n-                            return null;\n-                        });\n-                    } else {\n-                        String msg = \"Client is not authorized to Produce\";\n-                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n-                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-                    }\n-                    return null;\n-                }).exceptionally(e -> {\n-                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n-                    log.warn(msg);\n-                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n-                    return null;\n-                });\n-            } else {\n-                final String msg = \"Proxy Client is not authorized to Produce\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            }\n-            return null;\n-        }).exceptionally(ex -> {\n-            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n-            log.warn(msg);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleSend(CommandSend send, ByteBuf headersAndPayload) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Producer> producerFuture = producers.get(send.getProducerId());\n-\n-        if (producerFuture == null || !producerFuture.isDone() || producerFuture.isCompletedExceptionally()) {\n-            log.warn(\"[{}] Producer had already been closed: {}\", remoteAddress, send.getProducerId());\n-            return;\n-        }\n-\n-        Producer producer = producerFuture.getNow(null);\n-        if (log.isDebugEnabled()) {\n-            printSendCommandDebug(send, headersAndPayload);\n-        }\n-\n-        if (producer.isNonPersistentTopic()) {\n-            // avoid processing non-persist message if reached max concurrent-message limit\n-            if (nonPersistentPendingMessages > MaxNonPersistentPendingMessages) {\n-                final long producerId = send.getProducerId();\n-                final long sequenceId = send.getSequenceId();\n-                final long highestSequenceId = send.getHighestSequenceId();\n-                service.getTopicOrderedExecutor().executeOrdered(producer.getTopic().getName(), SafeRun.safeRun(() -> {\n-                    ctx.writeAndFlush(Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, -1, -1), ctx.voidPromise());\n-                }));\n-                producer.recordMessageDrop(send.getNumMessages());\n-                return;\n-            } else {\n-                nonPersistentPendingMessages++;\n-            }\n-        }\n-\n-        startSendOperation(producer, headersAndPayload.readableBytes());\n-\n-        // Persist the message\n-        if (send.hasHighestSequenceId() && send.getSequenceId() <= send.getHighestSequenceId()) {\n-            producer.publishMessage(send.getProducerId(), send.getSequenceId(), send.getHighestSequenceId(),\n-                    headersAndPayload, send.getNumMessages());\n-        } else {\n-            producer.publishMessage(send.getProducerId(), send.getSequenceId(), headersAndPayload, send.getNumMessages());\n-        }\n-    }\n-\n-    private void printSendCommandDebug(CommandSend send, ByteBuf headersAndPayload) {\n-        headersAndPayload.markReaderIndex();\n-        MessageMetadata msgMetadata = Commands.parseMessageMetadata(headersAndPayload);\n-        headersAndPayload.resetReaderIndex();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received send message request. producer: {}:{} {}:{} size: {}, partition key is: {}, ordering key is {}\",\n-                    remoteAddress, send.getProducerId(), send.getSequenceId(), msgMetadata.getProducerName(), msgMetadata.getSequenceId(),\n-                    headersAndPayload.readableBytes(), msgMetadata.getPartitionKey(), msgMetadata.getOrderingKey());\n-        }\n-        msgMetadata.recycle();\n-    }\n-\n-    @Override\n-    protected void handleAck(CommandAck ack) {\n-        checkArgument(state == State.Connected);\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(ack.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            consumerFuture.getNow(null).messageAcked(ack);\n-        }\n-    }\n-\n-    @Override\n-    protected void handleFlow(CommandFlow flow) {\n-        checkArgument(state == State.Connected);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received flow from consumer {} permits: {}\", remoteAddress, flow.getConsumerId(),\n-                    flow.getMessagePermits());\n-        }\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(flow.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            if (consumer != null) {\n-                consumer.flowPermits(flow.getMessagePermits());\n-            } else {\n-                log.info(\"[{}] Couldn't find consumer {}\", remoteAddress, flow.getConsumerId());\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void handleRedeliverUnacknowledged(CommandRedeliverUnacknowledgedMessages redeliver) {\n-        checkArgument(state == State.Connected);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received Resend Command from consumer {} \", remoteAddress, redeliver.getConsumerId());\n-        }\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(redeliver.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            if (redeliver.getMessageIdsCount() > 0 && Subscription.isIndividualAckMode(consumer.subType())) {\n-                consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());\n-            } else {\n-                consumer.redeliverUnacknowledgedMessages();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void handleUnsubscribe(CommandUnsubscribe unsubscribe) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(unsubscribe.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            consumerFuture.getNow(null).doUnsubscribe(unsubscribe.getRequestId());\n-        } else {\n-            ctx.writeAndFlush(\n-                    Commands.newError(unsubscribe.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleSeek(CommandSeek seek) {\n-        checkArgument(state == State.Connected);\n-        final long requestId = seek.getRequestId();\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(seek.getConsumerId());\n-\n-        if (!seek.hasMessageId() && !seek.hasMessagePublishTime()) {\n-            ctx.writeAndFlush(\n-                    Commands.newError(requestId, ServerError.MetadataError, \"Message id and message publish time were not present\"));\n-            return;\n-        }\n-\n-        boolean consumerCreated = consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally();\n-\n-        if (consumerCreated && seek.hasMessageId()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            Subscription subscription = consumer.getSubscription();\n-            MessageIdData msgIdData = seek.getMessageId();\n-\n-            Position position = new PositionImpl(msgIdData.getLedgerId(), msgIdData.getEntryId());\n-\n-\n-            subscription.resetCursor(position).thenRun(() -> {\n-                log.info(\"[{}] [{}][{}] Reset subscription to message id {}\", remoteAddress,\n-                        subscription.getTopic().getName(), subscription.getName(), position);\n-                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            }).exceptionally(ex -> {\n-                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                        \"Error when resetting subscription: \" + ex.getCause().getMessage()));\n-                return null;\n-            });\n-        } else if (consumerCreated && seek.hasMessagePublishTime()){\n-            Consumer consumer = consumerFuture.getNow(null);\n-            Subscription subscription = consumer.getSubscription();\n-            long timestamp = seek.getMessagePublishTime();\n-\n-            subscription.resetCursor(timestamp).thenRun(() -> {\n-                log.info(\"[{}] [{}][{}] Reset subscription to publish time {}\", remoteAddress,\n-                        subscription.getTopic().getName(), subscription.getName(), timestamp);\n-                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            }).exceptionally(ex -> {\n-                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                        \"Reset subscription to publish time error: \" + ex.getCause().getMessage()));\n-                return null;\n-            });\n-        } else {\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleCloseProducer(CommandCloseProducer closeProducer) {\n-        checkArgument(state == State.Connected);\n-\n-        final long producerId = closeProducer.getProducerId();\n-        final long requestId = closeProducer.getRequestId();\n-\n-        CompletableFuture<Producer> producerFuture = producers.get(producerId);\n-        if (producerFuture == null) {\n-            log.warn(\"[{}] Producer {} was not registered on the connection\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                    \"Producer was not registered on the connection\"));\n-            return;\n-        }\n-\n-        if (!producerFuture.isDone() && producerFuture\n-                .completeExceptionally(new IllegalStateException(\"Closed producer before creation was complete\"))) {\n-            // We have received a request to close the producer before it was actually completed, we have marked the\n-            // producer future as failed and we can tell the client the close operation was successful.\n-            log.info(\"[{}] Closed producer {} before its creation was completed\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-            return;\n-        } else if (producerFuture.isCompletedExceptionally()) {\n-            log.info(\"[{}] Closed producer {} that already failed to be created\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-            return;\n-        }\n-\n-        // Proceed with normal close, the producer\n-        Producer producer = producerFuture.getNow(null);\n-        log.info(\"[{}][{}] Closing producer on cnx {}\", producer.getTopic(), producer.getProducerName(), remoteAddress);\n-\n-        producer.close(true).thenAccept(v -> {\n-            log.info(\"[{}][{}] Closed producer on cnx {}\", producer.getTopic(), producer.getProducerName(),\n-                    remoteAddress);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-        });\n-    }\n-\n-    @Override\n-    protected void handleCloseConsumer(CommandCloseConsumer closeConsumer) {\n-        checkArgument(state == State.Connected);\n-        log.info(\"[{}] Closing consumer: {}\", remoteAddress, closeConsumer.getConsumerId());\n-\n-        long requestId = closeConsumer.getRequestId();\n-        long consumerId = closeConsumer.getConsumerId();\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n-        if (consumerFuture == null) {\n-            log.warn(\"[{}] Consumer was not registered on the connection: {}\", consumerId, remoteAddress);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n-            return;\n-        }\n-\n-        if (!consumerFuture.isDone() && consumerFuture\n-                .completeExceptionally(new IllegalStateException(\"Closed consumer before creation was complete\"))) {\n-            // We have received a request to close the consumer before it was actually completed, we have marked the\n-            // consumer future as failed and we can tell the client the close operation was successful. When the actual\n-            // create operation will complete, the new consumer will be discarded.\n-            log.info(\"[{}] Closed consumer {} before its creation was completed\", remoteAddress, consumerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            return;\n-        }\n-\n-        if (consumerFuture.isCompletedExceptionally()) {\n-            log.info(\"[{}] Closed consumer {} that already failed to be created\", remoteAddress, consumerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            return;\n-        }\n-\n-        // Proceed with normal consumer close\n-        Consumer consumer = consumerFuture.getNow(null);\n-        try {\n-            consumer.close();\n-            consumers.remove(consumerId, consumerFuture);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            log.info(\"[{}] Closed consumer {}\", remoteAddress, consumer);\n-        } catch (BrokerServiceException e) {\n-            log.warn(\"[{]] Error closing consumer {} : {}\", remoteAddress, consumer, e);\n-            ctx.writeAndFlush(\n-                    Commands.newError(requestId, BrokerServiceException.getClientErrorCode(e), e.getMessage()));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleGetLastMessageId(CommandGetLastMessageId getLastMessageId) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(getLastMessageId.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            long requestId = getLastMessageId.getRequestId();\n-\n-            Topic topic = consumer.getSubscription().getTopic();\n-            Position position = topic.getLastPosition();\n-            int partitionIndex = TopicName.getPartitionIndex(topic.getName());\n-\n-            getLargestBatchIndexWhenPossible(\n-                    topic,\n-                    (PositionImpl) position,\n-                    partitionIndex,\n-                    requestId,\n-                    consumer.getSubscription().getName());\n-\n-        } else {\n-            ctx.writeAndFlush(Commands.newError(getLastMessageId.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    private void getLargestBatchIndexWhenPossible(\n-            Topic topic,\n-            PositionImpl position,\n-            int partitionIndex,\n-            long requestId,\n-            String subscriptionName) {\n-\n-        PersistentTopic persistentTopic = (PersistentTopic) topic;\n-        ManagedLedgerImpl ml = (ManagedLedgerImpl) persistentTopic.getManagedLedger();\n-\n-        // If it's not pointing to a valid entry, respond messageId of the current position.\n-        if (position.getEntryId() == -1) {\n-            MessageIdData messageId = MessageIdData.newBuilder()\n-                    .setLedgerId(position.getLedgerId())\n-                    .setEntryId(position.getEntryId())\n-                    .setPartition(partitionIndex).build();\n-\n-            ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n-        }\n-\n-        // For a valid position, we read the entry out and parse the batch size from its metadata.\n-        CompletableFuture<Entry> entryFuture = new CompletableFuture<>();\n-        ml.asyncReadEntry(position, new AsyncCallbacks.ReadEntryCallback() {\n-            @Override\n-            public void readEntryComplete(Entry entry, Object ctx) {\n-                entryFuture.complete(entry);\n-            }\n-\n-            @Override\n-            public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n-                entryFuture.completeExceptionally(exception);\n-            }\n-        }, null);\n-\n-        CompletableFuture<Integer> batchSizeFuture = entryFuture.thenApply(entry -> {\n-            MessageMetadata metadata = Commands.parseMessageMetadata(entry.getDataBuffer());\n-            int batchSize = metadata.getNumMessagesInBatch();\n-            entry.release();\n-            return batchSize;\n-        });\n-\n-        batchSizeFuture.whenComplete((batchSize, e) -> {\n-            if (e != null) {\n-                ctx.writeAndFlush(Commands.newError(\n-                        requestId, ServerError.MetadataError, \"Failed to get batch size for entry \" + e.getMessage()));\n-            } else {\n-                int largestBatchIndex = batchSize > 1 ? batchSize - 1 : -1;\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] [{}][{}] Get LastMessageId {} partitionIndex {}\", remoteAddress,\n-                            topic.getName(), subscriptionName, position, partitionIndex);\n-                }\n-\n-                MessageIdData messageId = MessageIdData.newBuilder()\n-                        .setLedgerId(position.getLedgerId())\n-                        .setEntryId(position.getEntryId())\n-                        .setPartition(partitionIndex)\n-                        .setBatchIndex(largestBatchIndex).build();\n-\n-                ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n-            }\n-        });\n-    }\n-\n-    @Override\n-    protected void handleGetTopicsOfNamespace(CommandGetTopicsOfNamespace commandGetTopicsOfNamespace) {\n-        final long requestId = commandGetTopicsOfNamespace.getRequestId();\n-        final String namespace = commandGetTopicsOfNamespace.getNamespace();\n-        final CommandGetTopicsOfNamespace.Mode mode = commandGetTopicsOfNamespace.getMode();\n-        final NamespaceName namespaceName = NamespaceName.get(namespace);\n-\n-        getBrokerService().pulsar().getNamespaceService().getListOfTopics(namespaceName, mode)\n-                .thenAccept(topics -> {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"[{}] Received CommandGetTopicsOfNamespace for namespace [//{}] by {}, size:{}\",\n-                                remoteAddress, namespace, requestId, topics.size());\n-                    }\n-\n-                    ctx.writeAndFlush(Commands.newGetTopicsOfNamespaceResponse(topics, requestId));\n-                })\n-                .exceptionally(ex -> {\n-                    log.warn(\"[{}] Error GetTopicsOfNamespace for namespace [//{}] by {}\",\n-                            remoteAddress, namespace, requestId);\n-                    ctx.writeAndFlush(\n-                            Commands.newError(requestId,\n-                                    BrokerServiceException.getClientErrorCode(new ServerMetadataException(ex)),\n-                                    ex.getMessage()));\n-\n-                    return null;\n-                });\n-    }\n-\n-    @Override\n-    protected void handleGetSchema(CommandGetSchema commandGetSchema) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandGetSchema call from {}, schemaVersion: {}, topic: {}, requestId: {}\",\n-                    remoteAddress, new String(commandGetSchema.getSchemaVersion().toByteArray()),\n-                    commandGetSchema.getTopic(), commandGetSchema.getRequestId());\n-        }\n-\n-        long requestId = commandGetSchema.getRequestId();\n-        SchemaVersion schemaVersion = SchemaVersion.Latest;\n-        if (commandGetSchema.hasSchemaVersion()) {\n-            schemaVersion = schemaService.versionFromBytes(commandGetSchema.getSchemaVersion().toByteArray());\n-        }\n-\n-        String schemaName;\n-        try {\n-            schemaName = TopicName.get(commandGetSchema.getTopic()).getSchemaName();\n-        } catch (Throwable t) {\n-            ctx.writeAndFlush(\n-                    Commands.newGetSchemaResponseError(requestId, ServerError.InvalidTopicName, t.getMessage()));\n-            return;\n-        }\n-\n-        schemaService.getSchema(schemaName, schemaVersion).thenAccept(schemaAndMetadata -> {\n-            if (schemaAndMetadata == null) {\n-                ctx.writeAndFlush(Commands.newGetSchemaResponseError(requestId, ServerError.TopicNotFound,\n-                        \"Topic not found or no-schema\"));\n-            } else {\n-                ctx.writeAndFlush(Commands.newGetSchemaResponse(requestId,\n-                        SchemaInfoUtil.newSchemaInfo(schemaName, schemaAndMetadata.schema), schemaAndMetadata.version));\n-            }\n-        }).exceptionally(ex -> {\n-            ctx.writeAndFlush(\n-                    Commands.newGetSchemaResponseError(requestId, ServerError.UnknownError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleGetOrCreateSchema(CommandGetOrCreateSchema commandGetOrCreateSchema) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandGetOrCreateSchema call from {}\", remoteAddress);\n-        }\n-        long requestId = commandGetOrCreateSchema.getRequestId();\n-        String topicName = commandGetOrCreateSchema.getTopic();\n-        SchemaData schemaData = getSchema(commandGetOrCreateSchema.getSchema());\n-        SchemaData schema = schemaData.getType() == SchemaType.NONE ? null : schemaData;\n-        service.getTopicIfExists(topicName).thenAccept(topicOpt -> {\n-            if (topicOpt.isPresent()) {\n-                Topic topic = topicOpt.get();\n-                CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n-                schemaVersionFuture.exceptionally(ex -> {\n-                    ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n-                    ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                            requestId, errorCode, ex.getMessage()));\n-                    return null;\n-                }).thenAccept(schemaVersion -> {\n-                        ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponse(\n-                                requestId, schemaVersion));\n-                });\n-            } else {\n-                ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                        requestId, ServerError.TopicNotFound, \"Topic not found\"));\n-            }\n-        }).exceptionally(ex -> {\n-            ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n-            ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                    requestId, errorCode, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleNewTxn(CommandNewTxn command) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive new txn request {} to transaction meta store {} from {}.\", command.getRequestId(), command.getTcId(), remoteAddress);\n-        }\n-        TransactionCoordinatorID tcId = TransactionCoordinatorID.get(command.getTcId());\n-        service.pulsar().getTransactionMetadataStoreService().newTransaction(tcId)\n-            .whenComplete(((txnID, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response {} for new txn request {}\", tcId.getId(),  command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for new txn request {}\", command.getRequestId(), ex);\n-                    }\n-                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), tcId.getId(), BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            }));\n-    }\n-\n-    @Override\n-    protected void handleAddPartitionToTxn(PulsarApi.CommandAddPartitionToTxn command) {\n-        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive add published partition to txn request {} from {} with txnId {}\", command.getRequestId(), remoteAddress, txnID);\n-        }\n-        service.pulsar().getTransactionMetadataStoreService().addProducedPartitionToTxn(txnID, command.getPartitionsList())\n-            .whenComplete(((v, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response success for add published partition to txn request {}\",  command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(),\n-                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for add published partition to txn request {}\",  command.getRequestId(), ex);\n-                    }\n-                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n-                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            }));\n-    }\n-\n-    @Override\n-    protected void handleEndTxn(PulsarApi.CommandEndTxn command) {\n-        TxnStatus newStatus = null;\n-        switch (command.getTxnAction()) {\n-            case COMMIT:\n-                newStatus = TxnStatus.COMMITTING;\n-                break;\n-            case ABORT:\n-                newStatus = TxnStatus.ABORTING;\n-                break;\n-        }\n-        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive end txn by {} request {} from {} with txnId {}\", newStatus, command.getRequestId(), remoteAddress, txnID);\n-        }\n-        service.pulsar().getTransactionMetadataStoreService().updateTxnStatus(txnID, newStatus, TxnStatus.OPEN)\n-            .whenComplete((v, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response success for end txn request {}\", command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(),\n-                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for end txn request {}\", command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n-                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            });\n-    }\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n \n-    private CompletableFuture<SchemaVersion> tryAddSchema(Topic topic, SchemaData schema) {\n-        if (schema != null) {\n-            return topic.addSchema(schema);\n-        } else {\n-            return topic.hasSchema().thenCompose((hasSchema) -> {\n-                log.info(\"[{}] {} configured with schema {}\",\n-                         remoteAddress, topic.getName(), hasSchema);\n-                CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n-                if (hasSchema && (schemaValidationEnforced || topic.getSchemaValidationEnforced())) {\n-                    result.completeExceptionally(new IncompatibleSchemaException(\n-                            \"Producers cannot connect or send message without a schema to topics with a schema\"));\n-                } else {\n-                    result.complete(SchemaVersion.Empty);\n-                }\n-                return result;\n-            });\n-        }\n-    }\n+public interface ServerCnx {\n \n-    @Override\n-    protected boolean isHandshakeCompleted() {\n-        return state == State.Connected;\n+    default String getClientVersion() {\n+        return null;", "originalCommit": "70f7da54e7c130171b53e41bbbf60ff9f966f1c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "551eb5a7180d9446f86d1c7eea9d2f97b02e97ce", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\nindex ae01f3f3b55..ce870485d8a 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n\n@@ -18,119 +18,2099 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import org.apache.bookkeeper.mledger.Entry;\n-import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n-import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+import static org.apache.pulsar.broker.admin.impl.PersistentTopicsBase.getPartitionedTopicMetadata;\n+import static org.apache.pulsar.broker.lookup.TopicLookupBase.lookupTopicAsync;\n+import static org.apache.pulsar.common.protocol.Commands.newLookupErrorResponse;\n+import static org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion.v5;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandler;\n \n import java.net.SocketAddress;\n+\n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.AuthenticationException;\n+import javax.net.ssl.SSLSession;\n+\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.bookkeeper.mledger.util.SafeRun;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n+import org.apache.pulsar.broker.PulsarServerException;\n+import org.apache.pulsar.broker.PulsarService;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataCommand;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n+import org.apache.pulsar.broker.authentication.AuthenticationProvider;\n+import org.apache.pulsar.broker.authentication.AuthenticationState;\n+import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerBusyException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.ServerMetadataException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.ServiceUnitNotReadyException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.SubscriptionNotFoundException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.TopicNotFoundException;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.broker.service.schema.exceptions.IncompatibleSchemaException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistryService;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.impl.BatchMessageIdImpl;\n+import org.apache.pulsar.client.impl.ClientCnx;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.common.api.AuthData;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandNewTxn;\n+import org.apache.pulsar.common.policies.data.TopicOperation;\n+import org.apache.pulsar.common.protocol.CommandUtils;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.PulsarHandler;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAuthResponse;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseConsumer;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseProducer;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandConnect;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStats;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStatsResponse;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandFlow;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetLastMessageId;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetSchema;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetOrCreateSchema;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetTopicsOfNamespace;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandLookupTopic;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandPartitionedTopicMetadata;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandProducer;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandRedeliverUnacknowledgedMessages;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSeek;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSend;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.SubType;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandUnsubscribe;\n+import org.apache.pulsar.common.api.proto.PulsarApi.FeatureFlags;\n+import org.apache.pulsar.common.api.proto.PulsarApi.MessageIdData;\n+import org.apache.pulsar.common.api.proto.PulsarApi.MessageMetadata;\n+import org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion;\n+import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n+import org.apache.pulsar.common.naming.Metadata;\n+import org.apache.pulsar.common.naming.NamespaceName;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.policies.data.BacklogQuota;\n+import org.apache.pulsar.common.policies.data.ConsumerStats;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaInfoUtil;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.collections.ConcurrentLongHashMap;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.GeneratedMessageLite;\n+import org.apache.pulsar.transaction.coordinator.TransactionCoordinatorID;\n+import org.apache.pulsar.transaction.impl.common.TxnID;\n+import org.apache.pulsar.transaction.impl.common.TxnStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerCnx extends PulsarHandler implements TransportCnx {\n+    private final BrokerService service;\n+    private final SchemaRegistryService schemaService;\n+    private final ConcurrentLongHashMap<CompletableFuture<Producer>> producers;\n+    private final ConcurrentLongHashMap<CompletableFuture<Consumer>> consumers;\n+    private State state;\n+    private volatile boolean isActive = true;\n+    String authRole = null;\n+    AuthenticationDataSource authenticationData;\n+    AuthenticationProvider authenticationProvider;\n+    AuthenticationState authState;\n+    // In case of proxy, if the authentication credentials are forwardable,\n+    // it will hold the credentials of the original client\n+    AuthenticationState originalAuthState;\n+    private boolean pendingAuthChallengeResponse = false;\n+\n+    // Max number of pending requests per connections. If multiple producers are sharing the same connection the flow\n+    // control done by a single producer might not be enough to prevent write spikes on the broker.\n+    private final int maxPendingSendRequests;\n+    private final int resumeReadsThreshold;\n+    private int pendingSendRequest = 0;\n+    private final String replicatorPrefix;\n+    private String clientVersion = null;\n+    private int nonPersistentPendingMessages = 0;\n+    private final int MaxNonPersistentPendingMessages;\n+    private String originalPrincipal = null;\n+    private Set<String> proxyRoles;\n+    private boolean authenticateOriginalAuthData;\n+    private final boolean schemaValidationEnforced;\n+    private String authMethod = \"none\";\n+    private final int maxMessageSize;\n+    private boolean preciseDispatcherFlowControl;\n+\n+    private boolean preciseTopicPublishRateLimitingEnable;\n+\n+    // Flag to manage throttling-rate by atomically enable/disable read-channel.\n+    private volatile boolean autoReadDisabledRateLimiting = false;\n+    private FeatureFlags features;\n+    // Flag to manage throttling-publish-buffer by atomically enable/disable read-channel.\n+    private volatile boolean autoReadDisabledPublishBufferLimiting = false;\n+    private static final AtomicLongFieldUpdater<ServerCnx> MSG_PUBLISH_BUFFER_SIZE_UPDATER =\n+            AtomicLongFieldUpdater.newUpdater(ServerCnx.class, \"messagePublishBufferSize\");\n+    private volatile long messagePublishBufferSize = 0;\n+\n+    enum State {\n+        Start, Connected, Failed, Connecting\n+    }\n+\n+    public ServerCnx(PulsarService pulsar) {\n+        super(pulsar.getBrokerService().getKeepAliveIntervalSeconds(), TimeUnit.SECONDS);\n+        this.service = pulsar.getBrokerService();\n+        this.schemaService = pulsar.getSchemaRegistryService();\n+        this.state = State.Start;\n+\n+        // This maps are not heavily contended since most accesses are within the cnx thread\n+        this.producers = new ConcurrentLongHashMap<>(8, 1);\n+        this.consumers = new ConcurrentLongHashMap<>(8, 1);\n+        this.replicatorPrefix = service.pulsar().getConfiguration().getReplicatorPrefix();\n+        this.MaxNonPersistentPendingMessages = service.pulsar().getConfiguration()\n+                .getMaxConcurrentNonPersistentMessagePerConnection();\n+        this.proxyRoles = service.pulsar().getConfiguration().getProxyRoles();\n+        this.authenticateOriginalAuthData = service.pulsar().getConfiguration().isAuthenticateOriginalAuthData();\n+        this.schemaValidationEnforced = pulsar.getConfiguration().isSchemaValidationEnforced();\n+        this.maxMessageSize = pulsar.getConfiguration().getMaxMessageSize();\n+        this.maxPendingSendRequests = pulsar.getConfiguration().getMaxPendingPublishRequestsPerConnection();\n+        this.resumeReadsThreshold = maxPendingSendRequests / 2;\n+        this.preciseDispatcherFlowControl = pulsar.getConfiguration().isPreciseDispatcherFlowControl();\n+        this.preciseTopicPublishRateLimitingEnable = pulsar.getConfiguration().isPreciseTopicPublishRateLimiterEnable();\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        super.channelActive(ctx);\n+        log.info(\"New connection from {}\", remoteAddress);\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        super.channelInactive(ctx);\n+        isActive = false;\n+        log.info(\"Closed connection from {}\", remoteAddress);\n+\n+        // Connection is gone, close the producers immediately\n+        producers.values().forEach((producerFuture) -> {\n+            if (producerFuture.isDone() && !producerFuture.isCompletedExceptionally()) {\n+                Producer producer = producerFuture.getNow(null);\n+                producer.closeNow(true);\n+            }\n+        });\n+\n+        consumers.values().forEach((consumerFuture) -> {\n+            Consumer consumer;\n+            if (consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+                consumer = consumerFuture.getNow(null);\n+            } else {\n+                return;\n+            }\n+\n+            try {\n+                consumer.close();\n+            } catch (BrokerServiceException e) {\n+                log.warn(\"Consumer {} was already closed: {}\", consumer, e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Channel writability has changed to: {}\", ctx.channel().isWritable());\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        if (state != State.Failed) {\n+            // No need to report stack trace for known exceptions that happen in disconnections\n+            log.warn(\"[{}] Got exception {}\", remoteAddress,\n+                    ClientCnx.isKnownException(cause) ? cause : ExceptionUtils.getStackTrace(cause));\n+            state = State.Failed;\n+        } else {\n+            // At default info level, suppress all subsequent exceptions that are thrown when the connection has already\n+            // failed\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Got exception: {}\", remoteAddress, cause);\n+            }\n+        }\n+        ctx.close();\n+    }\n+\n+    /*\n+     * If authentication and authorization is enabled(and not sasl) and if the authRole is one of proxyRoles we want to enforce\n+     * - the originalPrincipal is given while connecting\n+     * - originalPrincipal is not blank\n+     * - originalPrincipal is not a proxy principal\n+     */\n+    private boolean invalidOriginalPrincipal(String originalPrincipal) {\n+        return (service.isAuthenticationEnabled() && service.isAuthorizationEnabled()\n+            && proxyRoles.contains(authRole) && (StringUtils.isBlank(originalPrincipal) || proxyRoles.contains(originalPrincipal)));\n+    }\n+\n+    // ////\n+    // // Incoming commands handling\n+    // ////\n+\n+    @Override\n+    protected void handleLookup(CommandLookupTopic lookup) {\n+        final long requestId = lookup.getRequestId();\n+        final boolean authoritative = lookup.getAuthoritative();\n+        final String advertisedListenerName = lookup.getAdvertisedListenerName();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received Lookup from {} for {}\", lookup.getTopic(), remoteAddress, requestId);\n+        }\n+\n+        TopicName topicName = validateTopicName(lookup.getTopic(), requestId, lookup);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n+        if (lookupSemaphore.tryAcquire()) {\n+            if (invalidOriginalPrincipal(originalPrincipal)) {\n+                final String msg = \"Valid Proxy Client role should be provided for lookup \";\n+                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                        originalPrincipal, topicName);\n+                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n+                lookupSemaphore.release();\n+                return;\n+            }\n+            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+                isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                        TopicOperation.LOOKUP, originalPrincipal, authRole, authenticationData);\n+            } else {\n+                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+            }\n+            String finalOriginalPrincipal = originalPrincipal;\n+            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+                if (isProxyAuthorized) {\n+                    lookupTopicAsync(getBrokerService().pulsar(), topicName, authoritative,\n+                            finalOriginalPrincipal != null ? finalOriginalPrincipal : authRole, authenticationData,\n+                            requestId, advertisedListenerName).handle((lookupResponse, ex) -> {\n+                                if (ex == null) {\n+                                    ctx.writeAndFlush(lookupResponse);\n+                                } else {\n+                                    // it should never happen\n+                                    log.warn(\"[{}] lookup failed with error {}, {}\", remoteAddress, topicName,\n+                                            ex.getMessage(), ex);\n+                                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.ServiceNotReady,\n+                                            ex.getMessage(), requestId));\n+                                }\n+                                lookupSemaphore.release();\n+                                return null;\n+                            });\n+                } else {\n+                    final String msg = \"Proxy Client is not authorized to Lookup\";\n+                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n+                    lookupSemaphore.release();\n+                }\n+                return null;\n+            }).exceptionally(ex -> {\n+                final String msg = \"Exception occured while trying to authorize lookup\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName, ex);\n+                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n+                lookupSemaphore.release();\n+                return null;\n+            });\n+        } else {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Failed lookup due to too many lookup-requests {}\", remoteAddress, topicName);\n+            }\n+            ctx.writeAndFlush(newLookupErrorResponse(ServerError.TooManyRequests,\n+                    \"Failed due to too many pending lookup requests\", requestId));\n+        }\n+    }\n+\n+    @Override\n+    protected void handlePartitionMetadataRequest(CommandPartitionedTopicMetadata partitionMetadata) {\n+        final long requestId = partitionMetadata.getRequestId();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received PartitionMetadataLookup from {} for {}\", partitionMetadata.getTopic(),\n+                    remoteAddress, requestId);\n+        }\n+\n+        TopicName topicName = validateTopicName(partitionMetadata.getTopic(), requestId, partitionMetadata);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n+        if (lookupSemaphore.tryAcquire()) {\n+            if (invalidOriginalPrincipal(originalPrincipal)) {\n+                final String msg = \"Valid Proxy Client role should be provided for getPartitionMetadataRequest \";\n+                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                        originalPrincipal, topicName);\n+                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError,\n+                        msg, requestId));\n+                lookupSemaphore.release();\n+                return;\n+            }\n+            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+                isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                        TopicOperation.LOOKUP, originalPrincipal, authRole, authenticationData);\n+            } else {\n+                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+            }\n+            String finalOriginalPrincipal = originalPrincipal;\n+            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+                if (isProxyAuthorized) {\n+                    getPartitionedTopicMetadata(getBrokerService().pulsar(),\n+                            authRole, finalOriginalPrincipal, authenticationData,\n+                            topicName).handle((metadata, ex) -> {\n+                                if (ex == null) {\n+                                    int partitions = metadata.partitions;\n+                                    ctx.writeAndFlush(Commands.newPartitionMetadataResponse(partitions, requestId));\n+                                } else {\n+                                    if (ex instanceof PulsarClientException) {\n+                                        log.warn(\"Failed to authorize {} at [{}] on topic {} : {}\", getRole(),\n+                                                remoteAddress, topicName, ex.getMessage());\n+                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(\n+                                                ServerError.AuthorizationError, ex.getMessage(), requestId));\n+                                    } else {\n+                                        log.warn(\"Failed to get Partitioned Metadata [{}] {}: {}\", remoteAddress,\n+                                                topicName, ex.getMessage(), ex);\n+                                        ServerError error = (ex instanceof RestException)\n+                                                && ((RestException) ex).getResponse().getStatus() < 500\n+                                                        ? ServerError.MetadataError\n+                                                        : ServerError.ServiceNotReady;\n+                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(error,\n+                                                ex.getMessage(), requestId));\n+                                    }\n+                                }\n+                                lookupSemaphore.release();\n+                                return null;\n+                            });\n+                } else {\n+                    final String msg = \"Proxy Client is not authorized to Get Partition Metadata\";\n+                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                    ctx.writeAndFlush(\n+                            Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n+                    lookupSemaphore.release();\n+                }\n+                return null;\n+            }).exceptionally(ex -> {\n+                final String msg = \"Exception occured while trying to authorize get Partition Metadata\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n+                lookupSemaphore.release();\n+                return null;\n+            });\n+        } else {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Failed Partition-Metadata lookup due to too many lookup-requests {}\", remoteAddress,\n+                        topicName);\n+            }\n+            ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.TooManyRequests,\n+                    \"Failed due to too many pending lookup requests\", requestId));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleConsumerStats(CommandConsumerStats commandConsumerStats) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CommandConsumerStats call from {}\", remoteAddress);\n+        }\n+\n+        final long requestId = commandConsumerStats.getRequestId();\n+        final long consumerId = commandConsumerStats.getConsumerId();\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n+        Consumer consumer = consumerFuture.getNow(null);\n+        ByteBuf msg = null;\n+\n+        if (consumer == null) {\n+            log.error(\n+                    \"Failed to get consumer-stats response - Consumer not found for CommandConsumerStats[remoteAddress = {}, requestId = {}, consumerId = {}]\",\n+                    remoteAddress, requestId, consumerId);\n+            msg = Commands.newConsumerStatsResponse(ServerError.ConsumerNotFound,\n+                    \"Consumer \" + consumerId + \" not found\", requestId);\n+        } else {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"CommandConsumerStats[requestId = {}, consumer = {}]\", requestId, consumer);\n+            }\n+            msg = Commands.newConsumerStatsResponse(createConsumerStatsResponse(consumer, requestId));\n+        }\n+\n+        ctx.writeAndFlush(msg);\n+    }\n+\n+    CommandConsumerStatsResponse.Builder createConsumerStatsResponse(Consumer consumer, long requestId) {\n+        CommandConsumerStatsResponse.Builder commandConsumerStatsResponseBuilder = CommandConsumerStatsResponse\n+                .newBuilder();\n+        ConsumerStats consumerStats = consumer.getStats();\n+        commandConsumerStatsResponseBuilder.setRequestId(requestId);\n+        commandConsumerStatsResponseBuilder.setMsgRateOut(consumerStats.msgRateOut);\n+        commandConsumerStatsResponseBuilder.setMsgThroughputOut(consumerStats.msgThroughputOut);\n+        commandConsumerStatsResponseBuilder.setMsgRateRedeliver(consumerStats.msgRateRedeliver);\n+        commandConsumerStatsResponseBuilder.setConsumerName(consumerStats.consumerName);\n+        commandConsumerStatsResponseBuilder.setAvailablePermits(consumerStats.availablePermits);\n+        commandConsumerStatsResponseBuilder.setUnackedMessages(consumerStats.unackedMessages);\n+        commandConsumerStatsResponseBuilder.setBlockedConsumerOnUnackedMsgs(consumerStats.blockedConsumerOnUnackedMsgs);\n+        commandConsumerStatsResponseBuilder.setAddress(consumerStats.getAddress());\n+        commandConsumerStatsResponseBuilder.setConnectedSince(consumerStats.getConnectedSince());\n+\n+        Subscription subscription = consumer.getSubscription();\n+        commandConsumerStatsResponseBuilder.setMsgBacklog(subscription.getNumberOfEntriesInBacklog(false));\n+        commandConsumerStatsResponseBuilder.setMsgRateExpired(subscription.getExpiredMessageRate());\n+        commandConsumerStatsResponseBuilder.setType(subscription.getTypeString());\n+\n+        return commandConsumerStatsResponseBuilder;\n+    }\n+\n+    // complete the connect and sent newConnected command\n+    private void completeConnect(int clientProtoVersion, String clientVersion) {\n+        ctx.writeAndFlush(Commands.newConnected(clientProtoVersion, maxMessageSize));\n+        state = State.Connected;\n+        remoteEndpointProtocolVersion = clientProtoVersion;\n+        if (isNotBlank(clientVersion) && !clientVersion.contains(\" \") /* ignore default version: pulsar client */) {\n+            this.clientVersion = clientVersion.intern();\n+        }\n+    }\n+\n+    // According to auth result, send newConnected or newAuthChallenge command.\n+    private State doAuthentication(AuthData clientData,\n+                                   int clientProtocolVersion,\n+                                   String clientVersion) throws Exception {\n+\n+        // The original auth state can only be set on subsequent auth attempts (and only\n+        // in presence of a proxy and if the proxy is forwarding the credentials).\n+        // In this case, the re-validation needs to be done against the original client\n+        // credentials.\n+        boolean useOriginalAuthState = (originalAuthState != null);\n+        AuthenticationState authState =  useOriginalAuthState ? originalAuthState : this.authState;\n+        String authRole = useOriginalAuthState ? originalPrincipal : this.authRole;\n+        AuthData brokerData = authState.authenticate(clientData);\n+\n+\n+        if (authState.isComplete()) {\n+            // Authentication has completed. It was either:\n+            // 1. the 1st time the authentication process was done, in which case we'll\n+            //    a `CommandConnected` response\n+            // 2. an authentication refresh, in which case we don't need to do anything else\n+\n+            String newAuthRole = authState.getAuthRole();\n+\n+            if (!useOriginalAuthState) {\n+                this.authRole = newAuthRole;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Client successfully authenticated with {} role {} and originalPrincipal {}\",\n+                        remoteAddress, authMethod, authRole, originalPrincipal);\n+            }\n+\n+            if (state != State.Connected) {\n+                // First time authentication is done\n+                completeConnect(clientProtocolVersion, clientVersion);\n+            } else {\n+                // If the connection was already ready, it means we're doing a refresh\n+                if (!StringUtils.isEmpty(authRole)) {\n+                    if (!authRole.equals(newAuthRole)) {\n+                        log.warn(\"[{}] Principal cannot be changed during an authentication refresh\", remoteAddress);\n+                        ctx.close();\n+                    } else {\n+                        log.info(\"[{}] Refreshed authentication credentials for role {}\", remoteAddress, authRole);\n+                    }\n+                }\n+            }\n+\n+            return State.Connected;\n+        }\n+\n+        // auth not complete, continue auth with client side.\n+        ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, clientProtocolVersion));\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Authentication in progress client by method {}.\",\n+                remoteAddress, authMethod);\n+        }\n+        return State.Connecting;\n+    }\n+\n+    public void refreshAuthenticationCredentials() {\n+        AuthenticationState authState = this.originalAuthState != null ? originalAuthState : this.authState;\n+\n+        if (authState == null) {\n+            // Authentication is disabled or there's no local state to refresh\n+            return;\n+        } else if (getState() != State.Connected || !isActive) {\n+            // Connection is either still being established or already closed.\n+            return;\n+        } else if (authState != null && !authState.isExpired()) {\n+            // Credentials are still valid. Nothing to do at this point\n+            return;\n+        } else if (originalPrincipal != null && originalAuthState == null) {\n+            log.info(\n+                    \"[{}] Cannot revalidate user credential when using proxy and not forwarding the credentials. Closing connection\",\n+                    remoteAddress);\n+            return;\n+        }\n \n-public interface ServerCnx {\n+        ctx.executor().execute(SafeRun.safeRun(() -> {\n+            log.info(\"[{}] Refreshing authentication credentials for originalPrincipal {} and authRole {}\", remoteAddress, originalPrincipal, this.authRole);\n \n-    default String getClientVersion() {\n-        return null;\n+            if (!supportsAuthenticationRefresh()) {\n+                log.warn(\"[{}] Closing connection because client doesn't support auth credentials refresh\", remoteAddress);\n+                ctx.close();\n+                return;\n+            }\n+\n+            if (pendingAuthChallengeResponse) {\n+                log.warn(\"[{}] Closing connection after timeout on refreshing auth credentials\", remoteAddress);\n+                ctx.close();\n+                return;\n+            }\n+\n+            try {\n+                AuthData brokerData = authState.refreshAuthentication();\n+\n+                ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, remoteEndpointProtocolVersion));\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"[{}] Sent auth challenge to client to refresh credentials with method: {}.\",\n+                        remoteAddress, authMethod);\n+                }\n+\n+                pendingAuthChallengeResponse = true;\n+\n+            } catch (AuthenticationException e) {\n+                log.warn(\"[{}] Failed to refresh authentication: {}\", remoteAddress, e);\n+                ctx.close();\n+            }\n+        }));\n+    }\n+\n+    @Override\n+    protected void handleConnect(CommandConnect connect) {\n+        checkArgument(state == State.Start);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CONNECT from {}, auth enabled: {}\",\n+                remoteAddress, service.isAuthenticationEnabled());\n+        }\n+\n+        String clientVersion = connect.getClientVersion();\n+        int clientProtocolVersion = connect.getProtocolVersion();\n+        features = connect.getFeatureFlags();\n+\n+        if (!service.isAuthenticationEnabled()) {\n+            completeConnect(clientProtocolVersion, clientVersion);\n+            return;\n+        }\n+\n+        try {\n+            AuthData clientData = AuthData.of(connect.getAuthData().toByteArray());\n+\n+            // init authentication\n+            if (connect.hasAuthMethodName()) {\n+                authMethod = connect.getAuthMethodName();\n+            } else if (connect.hasAuthMethod()) {\n+                // Legacy client is passing enum\n+                authMethod = connect.getAuthMethod().name().substring(10).toLowerCase();\n+            } else {\n+                authMethod = \"none\";\n+            }\n+\n+            authenticationProvider = getBrokerService()\n+                .getAuthenticationService()\n+                .getAuthenticationProvider(authMethod);\n+\n+            // Not find provider named authMethod. Most used for tests.\n+            // In AuthenticationDisabled, it will set authMethod \"none\".\n+            if (authenticationProvider == null) {\n+                authRole = getBrokerService().getAuthenticationService().getAnonymousUserRole()\n+                    .orElseThrow(() ->\n+                        new AuthenticationException(\"No anonymous role, and no authentication provider configured\"));\n+                completeConnect(clientProtocolVersion, clientVersion);\n+                return;\n+            }\n+\n+            // init authState and other var\n+            ChannelHandler sslHandler = ctx.channel().pipeline().get(PulsarChannelInitializer.TLS_HANDLER);\n+            SSLSession sslSession = null;\n+            if (sslHandler != null) {\n+                sslSession = ((SslHandler) sslHandler).engine().getSession();\n+            }\n+\n+            authState = authenticationProvider.newAuthState(clientData, remoteAddress, sslSession);\n+            authenticationData = authState.getAuthDataSource();\n+            state = doAuthentication(clientData, clientProtocolVersion, clientVersion);\n+\n+            // This will fail the check if:\n+            //  1. client is coming through a proxy\n+            //  2. we require to validate the original credentials\n+            //  3. no credentials were passed\n+            if (connect.hasOriginalPrincipal() && service.getPulsar().getConfig().isAuthenticateOriginalAuthData()) {\n+                // init authentication\n+                String originalAuthMethod;\n+                if (connect.hasOriginalAuthMethod()) {\n+                    originalAuthMethod = connect.getOriginalAuthMethod();\n+                } else {\n+                    originalAuthMethod = \"none\";\n+                }\n+\n+                AuthenticationProvider originalAuthenticationProvider = getBrokerService()\n+                        .getAuthenticationService()\n+                        .getAuthenticationProvider(originalAuthMethod);\n+\n+                if (originalAuthenticationProvider == null) {\n+                    throw new AuthenticationException(String.format(\"Can't find AuthenticationProvider for original role\" +\n+                            \" using auth method [%s] is not available\", originalAuthMethod));\n+                }\n+\n+                originalAuthState = originalAuthenticationProvider.newAuthState(\n+                        AuthData.of(connect.getOriginalAuthData().getBytes()),\n+                        remoteAddress,\n+                        sslSession);\n+                originalPrincipal = originalAuthState.getAuthRole();\n+            } else {\n+                originalPrincipal = connect.hasOriginalPrincipal() ? connect.getOriginalPrincipal() : null;\n+            }\n+        } catch (Exception e) {\n+            String msg = \"Unable to authenticate\";\n+            if (e instanceof AuthenticationException) {\n+                log.warn(\"[{}] {}: {}\", remoteAddress, msg, e.getMessage());\n+            } else {\n+                log.warn(\"[{}] {}\", remoteAddress, msg, e);\n+            }\n+            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, msg));\n+            close();\n+        }\n     }\n \n-    SocketAddress clientAddress();\n+    @Override\n+    protected void handleAuthResponse(CommandAuthResponse authResponse) {\n+        checkArgument(authResponse.hasResponse());\n+        checkArgument(authResponse.getResponse().hasAuthData() && authResponse.getResponse().hasAuthMethodName());\n \n-    BrokerService getBrokerService();\n+        pendingAuthChallengeResponse = false;\n \n-    default boolean isBatchMessageCompatibleVersion() {\n-        return true;\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received AuthResponse from {}, auth method: {}\",\n+                remoteAddress, authResponse.getResponse().getAuthMethodName());\n+        }\n+\n+        try {\n+            AuthData clientData = AuthData.of(authResponse.getResponse().getAuthData().toByteArray());\n+            doAuthentication(clientData, authResponse.getProtocolVersion(), authResponse.getClientVersion());\n+        } catch (AuthenticationException e) {\n+            log.warn(\"[{}] Authentication failed: {} \", remoteAddress, e.getMessage());\n+            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, e.getMessage()));\n+            close();\n+        } catch (Exception e) {\n+            String msg = \"Unable to handleAuthResponse\";\n+            log.warn(\"[{}] {} \", remoteAddress, msg, e);\n+            ctx.writeAndFlush(Commands.newError(-1, ServerError.UnknownError, msg));\n+            close();\n+        }\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final CommandSubscribe subscribe) {\n+        checkArgument(state == State.Connected);\n+        final long requestId = subscribe.getRequestId();\n+        final long consumerId = subscribe.getConsumerId();\n+        TopicName topicName = validateTopicName(subscribe.getTopic(), requestId, subscribe);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        if (invalidOriginalPrincipal(originalPrincipal)) {\n+            final String msg = \"Valid Proxy Client role should be provided while subscribing \";\n+            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                    originalPrincipal, topicName);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            return;\n+        }\n+\n+        final String subscriptionName = subscribe.getSubscription();\n+        final SubType subType = subscribe.getSubType();\n+        final String consumerName = subscribe.getConsumerName();\n+        final boolean isDurable = subscribe.getDurable();\n+        final MessageIdImpl startMessageId = subscribe.hasStartMessageId() ? new BatchMessageIdImpl(\n+                subscribe.getStartMessageId().getLedgerId(), subscribe.getStartMessageId().getEntryId(),\n+                subscribe.getStartMessageId().getPartition(), subscribe.getStartMessageId().getBatchIndex())\n+                : null;\n+        final int priorityLevel = subscribe.hasPriorityLevel() ? subscribe.getPriorityLevel() : 0;\n+        final boolean readCompacted = subscribe.getReadCompacted();\n+        final Map<String, String> metadata = CommandUtils.metadataFromCommand(subscribe);\n+        final InitialPosition initialPosition = subscribe.getInitialPosition();\n+        final long startMessageRollbackDurationSec = subscribe.hasStartMessageRollbackDurationSec()\n+                ? subscribe.getStartMessageRollbackDurationSec()\n+                : -1;\n+        final SchemaData schema = subscribe.hasSchema() ? getSchema(subscribe.getSchema()) : null;\n+        final boolean isReplicated = subscribe.hasReplicateSubscriptionState() && subscribe.getReplicateSubscriptionState();\n+        final boolean forceTopicCreation = subscribe.getForceTopicCreation();\n+        final PulsarApi.KeySharedMeta keySharedMeta = subscribe.hasKeySharedMeta() ? subscribe.getKeySharedMeta() : null;\n+\n+        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+            authenticationData.setSubscription(subscriptionName);\n+            isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                    TopicOperation.CONSUME, originalPrincipal, authRole, authenticationData);\n+        } else {\n+            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+        }\n+        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+            if (isProxyAuthorized) {\n+                CompletableFuture<Boolean> authorizationFuture;\n+                if (service.isAuthorizationEnabled()) {\n+                    if (authenticationData == null) {\n+                        authenticationData = new AuthenticationDataCommand(\"\", subscriptionName);\n+                    } else {\n+                        authenticationData.setSubscription(subscriptionName);\n+                    }\n+                    authorizationFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                            TopicOperation.CONSUME, originalPrincipal, authRole, authenticationData);\n+                } else {\n+                    authorizationFuture = CompletableFuture.completedFuture(true);\n+                }\n+\n+                authorizationFuture.thenApply(isAuthorized -> {\n+                    if (isAuthorized) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] Client is authorized to subscribe with role {}\", remoteAddress, authRole);\n+                        }\n+\n+                        log.info(\"[{}] Subscribing on topic {} / {}\", remoteAddress, topicName, subscriptionName);\n+                        try {\n+                            Metadata.validateMetadata(metadata);\n+                        } catch (IllegalArgumentException iae) {\n+                            final String msg = iae.getMessage();\n+                            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n+                            return null;\n+                        }\n+                        CompletableFuture<Consumer> consumerFuture = new CompletableFuture<>();\n+                        CompletableFuture<Consumer> existingConsumerFuture = consumers.putIfAbsent(consumerId,\n+                                consumerFuture);\n+\n+                        if (existingConsumerFuture != null) {\n+                            if (existingConsumerFuture.isDone() && !existingConsumerFuture.isCompletedExceptionally()) {\n+                                Consumer consumer = existingConsumerFuture.getNow(null);\n+                                log.info(\"[{}] Consumer with the same id {} is already created: {}\", remoteAddress,\n+                                        consumerId, consumer);\n+                                ctx.writeAndFlush(Commands.newSuccess(requestId));\n+                                return null;\n+                            } else {\n+                                // There was an early request to create a consumer with same consumerId. This can happen\n+                                // when\n+                                // client timeout is lower the broker timeouts. We need to wait until the previous\n+                                // consumer\n+                                // creation request either complete or fails.\n+                                log.warn(\"[{}][{}][{}] Consumer with id {} is already present on the connection\", remoteAddress,\n+                                        topicName, subscriptionName, consumerId);\n+                                ServerError error = null;\n+                                if(!existingConsumerFuture.isDone()) {\n+                                    error = ServerError.ServiceNotReady;\n+                                }else {\n+                                    error = getErrorCode(existingConsumerFuture);\n+                                    consumers.remove(consumerId);\n+                                }\n+                                ctx.writeAndFlush(Commands.newError(requestId, error,\n+                                        \"Consumer is already present on the connection\"));\n+                                return null;\n+                            }\n+                        }\n+\n+                        boolean createTopicIfDoesNotExist = forceTopicCreation\n+                                && service.isAllowAutoTopicCreation(topicName.toString());\n+\n+                        service.getTopic(topicName.toString(), createTopicIfDoesNotExist)\n+                                .thenCompose(optTopic -> {\n+                                    if (!optTopic.isPresent()) {\n+                                        return FutureUtil\n+                                                .failedFuture(new TopicNotFoundException(\"Topic does not exist\"));\n+                                    }\n+\n+                                    Topic topic = optTopic.get();\n+\n+                                    boolean rejectSubscriptionIfDoesNotExist = isDurable\n+                                        && !service.isAllowAutoSubscriptionCreation(topicName.toString())\n+                                        && !topic.getSubscriptions().containsKey(subscriptionName);\n+\n+                                    if (rejectSubscriptionIfDoesNotExist) {\n+                                        return FutureUtil\n+                                            .failedFuture(new SubscriptionNotFoundException(\"Subscription does not exist\"));\n+                                    }\n+\n+                                    if (schema != null) {\n+                                        return topic.addSchemaIfIdleOrCheckCompatible(schema)\n+                                            .thenCompose(v -> topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n+                                                    subType, priorityLevel, consumerName, isDurable,\n+                                                    startMessageId, metadata,\n+                                                    readCompacted, initialPosition, startMessageRollbackDurationSec, isReplicated, keySharedMeta));\n+                                    } else {\n+                                        return topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n+                                            subType, priorityLevel, consumerName, isDurable,\n+                                            startMessageId, metadata, readCompacted, initialPosition,\n+                                            startMessageRollbackDurationSec, isReplicated, keySharedMeta);\n+                                    }\n+                                })\n+                                .thenAccept(consumer -> {\n+                                    if (consumerFuture.complete(consumer)) {\n+                                        log.info(\"[{}] Created subscription on topic {} / {}\", remoteAddress, topicName,\n+                                                subscriptionName);\n+                                        ctx.writeAndFlush(Commands.newSuccess(requestId), ctx.voidPromise());\n+                                    } else {\n+                                        // The consumer future was completed before by a close command\n+                                        try {\n+                                            consumer.close();\n+                                            log.info(\"[{}] Cleared consumer created after timeout on client side {}\",\n+                                                    remoteAddress, consumer);\n+                                        } catch (BrokerServiceException e) {\n+                                            log.warn(\n+                                                    \"[{}] Error closing consumer created after timeout on client side {}: {}\",\n+                                                    remoteAddress, consumer, e.getMessage());\n+                                        }\n+                                        consumers.remove(consumerId, consumerFuture);\n+                                    }\n+\n+                                }) //\n+                                .exceptionally(exception -> {\n+                                    if (exception.getCause() instanceof ConsumerBusyException) {\n+                                        if (log.isDebugEnabled()) {\n+                                            log.debug(\n+                                                    \"[{}][{}][{}] Failed to create consumer because exclusive consumer is already connected: {}\",\n+                                                    remoteAddress, topicName, subscriptionName,\n+                                                    exception.getCause().getMessage());\n+                                        }\n+                                    } else if (exception.getCause() instanceof BrokerServiceException) {\n+                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n+                                                subscriptionName, exception.getCause().getMessage());\n+                                    } else {\n+                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n+                                                subscriptionName, exception.getCause().getMessage(), exception);\n+                                    }\n+\n+                                    // If client timed out, the future would have been completed by subsequent close.\n+                                    // Send error\n+                                    // back to client, only if not completed already.\n+                                    if (consumerFuture.completeExceptionally(exception)) {\n+                                        ctx.writeAndFlush(Commands.newError(requestId,\n+                                                BrokerServiceException.getClientErrorCode(exception),\n+                                                exception.getCause().getMessage()));\n+                                    }\n+                                    consumers.remove(consumerId, consumerFuture);\n+\n+                                    return null;\n+\n+                                });\n+                    } else {\n+                        String msg = \"Client is not authorized to subscribe\";\n+                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n+                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+                    }\n+                    return null;\n+                }).exceptionally(e -> {\n+                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n+                    log.warn(msg);\n+                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n+                    return null;\n+                });\n+            } else {\n+                final String msg = \"Proxy Client is not authorized to subscribe\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            }\n+            return null;\n+        }).exceptionally(ex -> {\n+            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n+            if (ex.getCause() instanceof PulsarServerException) {\n+                log.info(msg);\n+            } else {\n+                log.warn(msg);\n+            }\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    private SchemaData getSchema(PulsarApi.Schema protocolSchema) {\n+        return SchemaData.builder()\n+            .data(protocolSchema.getSchemaData().toByteArray())\n+            .isDeleted(false)\n+            .timestamp(System.currentTimeMillis())\n+            .user(Strings.nullToEmpty(originalPrincipal))\n+            .type(Commands.getSchemaType(protocolSchema.getType()))\n+            .props(protocolSchema.getPropertiesList().stream().collect(\n+                Collectors.toMap(\n+                    PulsarApi.KeyValue::getKey,\n+                    PulsarApi.KeyValue::getValue\n+                )\n+            )).build();\n+    }\n+\n+    @Override\n+    protected void handleProducer(final CommandProducer cmdProducer) {\n+        checkArgument(state == State.Connected);\n+        final long producerId = cmdProducer.getProducerId();\n+        final long requestId = cmdProducer.getRequestId();\n+        // Use producer name provided by client if present\n+        final String producerName = cmdProducer.hasProducerName() ? cmdProducer.getProducerName()\n+                : service.generateUniqueProducerName();\n+        final long epoch = cmdProducer.getEpoch();\n+        final boolean userProvidedProducerName = cmdProducer.getUserProvidedProducerName();\n+        final boolean isEncrypted = cmdProducer.getEncrypted();\n+        final Map<String, String> metadata = CommandUtils.metadataFromCommand(cmdProducer);\n+        final SchemaData schema = cmdProducer.hasSchema() ? getSchema(cmdProducer.getSchema()) : null;\n+\n+        TopicName topicName = validateTopicName(cmdProducer.getTopic(), requestId, cmdProducer);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        if (invalidOriginalPrincipal(originalPrincipal)) {\n+            final String msg = \"Valid Proxy Client role should be provided while creating producer \";\n+            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                    originalPrincipal, topicName);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            return;\n+        }\n+\n+        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+            isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                    TopicOperation.PRODUCE, originalPrincipal, authRole, authenticationData);\n+        } else {\n+            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+        }\n+        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+            if (isProxyAuthorized) {\n+                CompletableFuture<Boolean> authorizationFuture;\n+                if (service.isAuthorizationEnabled()) {\n+                    authorizationFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                            TopicOperation.PRODUCE, originalPrincipal, authRole, authenticationData);\n+                } else {\n+                    authorizationFuture = CompletableFuture.completedFuture(true);\n+                }\n+\n+                authorizationFuture.thenApply(isAuthorized -> {\n+                    if (isAuthorized) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] Client is authorized to Produce with role {}\", remoteAddress, authRole);\n+                        }\n+                        CompletableFuture<Producer> producerFuture = new CompletableFuture<>();\n+                        CompletableFuture<Producer> existingProducerFuture = producers.putIfAbsent(producerId,\n+                                producerFuture);\n+\n+                        if (existingProducerFuture != null) {\n+                            if (existingProducerFuture.isDone() && !existingProducerFuture.isCompletedExceptionally()) {\n+                                Producer producer = existingProducerFuture.getNow(null);\n+                                log.info(\"[{}] Producer with the same id {} is already created: {}\", remoteAddress,\n+                                        producerId, producer);\n+                                ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producer.getProducerName(),\n+                                    producer.getSchemaVersion()));\n+                                return null;\n+                            } else {\n+                                // There was an early request to create a producer with\n+                                // same producerId. This can happen when\n+                                // client\n+                                // timeout is lower the broker timeouts. We need to wait\n+                                // until the previous producer creation\n+                                // request\n+                                // either complete or fails.\n+                                ServerError error = null;\n+                                if(!existingProducerFuture.isDone()) {\n+                                    error = ServerError.ServiceNotReady;\n+                                } else {\n+                                    error = getErrorCode(existingProducerFuture);\n+                                    // remove producer with producerId as it's already completed with exception\n+                                    producers.remove(producerId);\n+                                }\n+                                log.warn(\"[{}][{}] Producer with id {} is already present on the connection\", remoteAddress,\n+                                        producerId, topicName);\n+                                ctx.writeAndFlush(Commands.newError(requestId, error,\n+                                        \"Producer is already present on the connection\"));\n+                                return null;\n+                            }\n+                        }\n+\n+                        log.info(\"[{}][{}] Creating producer. producerId={}\", remoteAddress, topicName, producerId);\n+\n+                        service.getOrCreateTopic(topicName.toString()).thenAccept((Topic topic) -> {\n+                            // Before creating producer, check if backlog quota exceeded\n+                            // on topic\n+                            if (topic.isBacklogQuotaExceeded(producerName)) {\n+                                IllegalStateException illegalStateException = new IllegalStateException(\n+                                        \"Cannot create producer on topic with backlog quota exceeded\");\n+                                BacklogQuota.RetentionPolicy retentionPolicy = topic.getBacklogQuota().getPolicy();\n+                                if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold) {\n+                                    ctx.writeAndFlush(\n+                                            Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededError,\n+                                                    illegalStateException.getMessage()));\n+                                } else if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception) {\n+                                    ctx.writeAndFlush(Commands.newError(requestId,\n+                                            ServerError.ProducerBlockedQuotaExceededException,\n+                                            illegalStateException.getMessage()));\n+                                }\n+                                producerFuture.completeExceptionally(illegalStateException);\n+                                producers.remove(producerId, producerFuture);\n+                                return;\n+                            }\n+\n+                            // Check whether the producer will publish encrypted messages or not\n+                            if (topic.isEncryptionRequired() && !isEncrypted) {\n+                                String msg = String.format(\"Encryption is required in %s\", topicName);\n+                                log.warn(\"[{}] {}\", remoteAddress, msg);\n+                                ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n+                                producers.remove(producerId, producerFuture);\n+                                return;\n+                            }\n+\n+                            disableTcpNoDelayIfNeeded(topicName.toString(), producerName);\n+\n+                            CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n+\n+                            schemaVersionFuture.exceptionally(exception -> {\n+                                ctx.writeAndFlush(Commands.newError(requestId,\n+                                        BrokerServiceException.getClientErrorCode(exception),\n+                                        exception.getMessage()));\n+                                producers.remove(producerId, producerFuture);\n+                                return null;\n+                            });\n+\n+                            schemaVersionFuture.thenAccept(schemaVersion -> {\n+                                Producer producer = new Producer(topic, ServerCnx.this, producerId, producerName, authRole,\n+                                    isEncrypted, metadata, schemaVersion, epoch, userProvidedProducerName);\n+\n+                                try {\n+                                    topic.addProducer(producer);\n+\n+                                    if (isActive()) {\n+                                        if (producerFuture.complete(producer)) {\n+                                            log.info(\"[{}] Created new producer: {}\", remoteAddress, producer);\n+                                            ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producerName,\n+                                                producer.getLastSequenceId(), producer.getSchemaVersion()));\n+                                            return;\n+                                        } else {\n+                                            // The producer's future was completed before by\n+                                            // a close command\n+                                            producer.closeNow(true);\n+                                            log.info(\"[{}] Cleared producer created after timeout on client side {}\",\n+                                                remoteAddress, producer);\n+                                        }\n+                                    } else {\n+                                        producer.closeNow(true);\n+                                        log.info(\"[{}] Cleared producer created after connection was closed: {}\",\n+                                            remoteAddress, producer);\n+                                        producerFuture.completeExceptionally(\n+                                            new IllegalStateException(\"Producer created after connection was closed\"));\n+                                    }\n+                                } catch (Exception ise) {\n+                                    log.error(\"[{}] Failed to add producer to topic {}: {}\", remoteAddress, topicName,\n+                                        ise.getMessage());\n+                                    ctx.writeAndFlush(Commands.newError(requestId,\n+                                        BrokerServiceException.getClientErrorCode(ise), ise.getMessage()));\n+                                    producerFuture.completeExceptionally(ise);\n+                                }\n+\n+                                producers.remove(producerId, producerFuture);\n+                            });\n+                        }).exceptionally(exception -> {\n+                            Throwable cause = exception.getCause();\n+\n+                            if (cause instanceof NoSuchElementException) {\n+                                cause = new TopicNotFoundException(\"Topic Not Found.\");\n+                            }\n+\n+                            if (!(cause instanceof ServiceUnitNotReadyException)) {\n+                                // Do not print stack traces for expected exceptions\n+                                log.error(\"[{}] Failed to create topic {}\", remoteAddress, topicName, exception);\n+                            }\n+\n+                            // If client timed out, the future would have been completed\n+                            // by subsequent close. Send error back to\n+                            // client, only if not completed already.\n+                            if (producerFuture.completeExceptionally(exception)) {\n+                                ctx.writeAndFlush(Commands.newError(requestId,\n+                                        BrokerServiceException.getClientErrorCode(cause), cause.getMessage()));\n+                            }\n+                            producers.remove(producerId, producerFuture);\n+\n+                            return null;\n+                        });\n+                    } else {\n+                        String msg = \"Client is not authorized to Produce\";\n+                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n+                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+                    }\n+                    return null;\n+                }).exceptionally(e -> {\n+                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n+                    log.warn(msg);\n+                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n+                    return null;\n+                });\n+            } else {\n+                final String msg = \"Proxy Client is not authorized to Produce\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            }\n+            return null;\n+        }).exceptionally(ex -> {\n+            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n+            log.warn(msg);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void handleSend(CommandSend send, ByteBuf headersAndPayload) {\n+        checkArgument(state == State.Connected);\n+\n+        CompletableFuture<Producer> producerFuture = producers.get(send.getProducerId());\n+\n+        if (producerFuture == null || !producerFuture.isDone() || producerFuture.isCompletedExceptionally()) {\n+            log.warn(\"[{}] Producer had already been closed: {}\", remoteAddress, send.getProducerId());\n+            return;\n+        }\n+\n+        Producer producer = producerFuture.getNow(null);\n+        if (log.isDebugEnabled()) {\n+            printSendCommandDebug(send, headersAndPayload);\n+        }\n+\n+        if (producer.isNonPersistentTopic()) {\n+            // avoid processing non-persist message if reached max concurrent-message limit\n+            if (nonPersistentPendingMessages > MaxNonPersistentPendingMessages) {\n+                final long producerId = send.getProducerId();\n+                final long sequenceId = send.getSequenceId();\n+                final long highestSequenceId = send.getHighestSequenceId();\n+                service.getTopicOrderedExecutor().executeOrdered(producer.getTopic().getName(), SafeRun.safeRun(() -> {\n+                    ctx.writeAndFlush(Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, -1, -1), ctx.voidPromise());\n+                }));\n+                producer.recordMessageDrop(send.getNumMessages());\n+                return;\n+            } else {\n+                nonPersistentPendingMessages++;\n+            }\n+        }\n+\n+        startSendOperation(producer, headersAndPayload.readableBytes(), send.getNumMessages());\n+\n+        // Persist the message\n+        if (send.hasHighestSequenceId() && send.getSequenceId() <= send.getHighestSequenceId()) {\n+            producer.publishMessage(send.getProducerId(), send.getSequenceId(), send.getHighestSequenceId(),\n+                    headersAndPayload, send.getNumMessages(), send.getIsChunk());\n+        } else {\n+            producer.publishMessage(send.getProducerId(), send.getSequenceId(), headersAndPayload,\n+                    send.getNumMessages(), send.getIsChunk());\n+        }\n+    }\n+\n+    private void printSendCommandDebug(CommandSend send, ByteBuf headersAndPayload) {\n+        headersAndPayload.markReaderIndex();\n+        MessageMetadata msgMetadata = Commands.parseMessageMetadata(headersAndPayload);\n+        headersAndPayload.resetReaderIndex();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received send message request. producer: {}:{} {}:{} size: {}, partition key is: {}, ordering key is {}\",\n+                    remoteAddress, send.getProducerId(), send.getSequenceId(), msgMetadata.getProducerName(), msgMetadata.getSequenceId(),\n+                    headersAndPayload.readableBytes(), msgMetadata.getPartitionKey(), msgMetadata.getOrderingKey());\n+        }\n+        msgMetadata.recycle();\n+    }\n+\n+    @Override\n+    protected void handleAck(CommandAck ack) {\n+        checkArgument(state == State.Connected);\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(ack.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            consumerFuture.getNow(null).messageAcked(ack);\n+        }\n+    }\n+\n+    @Override\n+    protected void handleFlow(CommandFlow flow) {\n+        checkArgument(state == State.Connected);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received flow from consumer {} permits: {}\", remoteAddress, flow.getConsumerId(),\n+                    flow.getMessagePermits());\n+        }\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(flow.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            if (consumer != null) {\n+                consumer.flowPermits(flow.getMessagePermits());\n+            } else {\n+                log.info(\"[{}] Couldn't find consumer {}\", remoteAddress, flow.getConsumerId());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleRedeliverUnacknowledged(CommandRedeliverUnacknowledgedMessages redeliver) {\n+        checkArgument(state == State.Connected);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received Resend Command from consumer {} \", remoteAddress, redeliver.getConsumerId());\n+        }\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(redeliver.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            if (redeliver.getMessageIdsCount() > 0 && Subscription.isIndividualAckMode(consumer.subType())) {\n+                consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());\n+            } else {\n+                consumer.redeliverUnacknowledgedMessages();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleUnsubscribe(CommandUnsubscribe unsubscribe) {\n+        checkArgument(state == State.Connected);\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(unsubscribe.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            consumerFuture.getNow(null).doUnsubscribe(unsubscribe.getRequestId());\n+        } else {\n+            ctx.writeAndFlush(\n+                    Commands.newError(unsubscribe.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleSeek(CommandSeek seek) {\n+        checkArgument(state == State.Connected);\n+        final long requestId = seek.getRequestId();\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(seek.getConsumerId());\n+\n+        if (!seek.hasMessageId() && !seek.hasMessagePublishTime()) {\n+            ctx.writeAndFlush(\n+                    Commands.newError(requestId, ServerError.MetadataError, \"Message id and message publish time were not present\"));\n+            return;\n+        }\n+\n+        boolean consumerCreated = consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally();\n+\n+        if (consumerCreated && seek.hasMessageId()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            Subscription subscription = consumer.getSubscription();\n+            MessageIdData msgIdData = seek.getMessageId();\n+\n+            Position position = new PositionImpl(msgIdData.getLedgerId(), msgIdData.getEntryId());\n+\n+\n+            subscription.resetCursor(position).thenRun(() -> {\n+                log.info(\"[{}] [{}][{}] Reset subscription to message id {}\", remoteAddress,\n+                        subscription.getTopic().getName(), subscription.getName(), position);\n+                ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            }).exceptionally(ex -> {\n+                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n+                        \"Error when resetting subscription: \" + ex.getCause().getMessage()));\n+                return null;\n+            });\n+        } else if (consumerCreated && seek.hasMessagePublishTime()){\n+            Consumer consumer = consumerFuture.getNow(null);\n+            Subscription subscription = consumer.getSubscription();\n+            long timestamp = seek.getMessagePublishTime();\n+\n+            subscription.resetCursor(timestamp).thenRun(() -> {\n+                log.info(\"[{}] [{}][{}] Reset subscription to publish time {}\", remoteAddress,\n+                        subscription.getTopic().getName(), subscription.getName(), timestamp);\n+                ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            }).exceptionally(ex -> {\n+                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n+                        \"Reset subscription to publish time error: \" + ex.getCause().getMessage()));\n+                return null;\n+            });\n+        } else {\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleCloseProducer(CommandCloseProducer closeProducer) {\n+        checkArgument(state == State.Connected);\n+\n+        final long producerId = closeProducer.getProducerId();\n+        final long requestId = closeProducer.getRequestId();\n+\n+        CompletableFuture<Producer> producerFuture = producers.get(producerId);\n+        if (producerFuture == null) {\n+            log.warn(\"[{}] Producer {} was not registered on the connection\", remoteAddress, producerId);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n+                    \"Producer was not registered on the connection\"));\n+            return;\n+        }\n+\n+        if (!producerFuture.isDone() && producerFuture\n+                .completeExceptionally(new IllegalStateException(\"Closed producer before creation was complete\"))) {\n+            // We have received a request to close the producer before it was actually completed, we have marked the\n+            // producer future as failed and we can tell the client the close operation was successful.\n+            log.info(\"[{}] Closed producer {} before its creation was completed\", remoteAddress, producerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            producers.remove(producerId, producerFuture);\n+            return;\n+        } else if (producerFuture.isCompletedExceptionally()) {\n+            log.info(\"[{}] Closed producer {} that already failed to be created\", remoteAddress, producerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            producers.remove(producerId, producerFuture);\n+            return;\n+        }\n+\n+        // Proceed with normal close, the producer\n+        Producer producer = producerFuture.getNow(null);\n+        log.info(\"[{}][{}] Closing producer on cnx {}\", producer.getTopic(), producer.getProducerName(), remoteAddress);\n+\n+        producer.close(true).thenAccept(v -> {\n+            log.info(\"[{}][{}] Closed producer on cnx {}\", producer.getTopic(), producer.getProducerName(),\n+                    remoteAddress);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            producers.remove(producerId, producerFuture);\n+        });\n+    }\n+\n+    @Override\n+    protected void handleCloseConsumer(CommandCloseConsumer closeConsumer) {\n+        checkArgument(state == State.Connected);\n+        log.info(\"[{}] Closing consumer: {}\", remoteAddress, closeConsumer.getConsumerId());\n+\n+        long requestId = closeConsumer.getRequestId();\n+        long consumerId = closeConsumer.getConsumerId();\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n+        if (consumerFuture == null) {\n+            log.warn(\"[{}] Consumer was not registered on the connection: {}\", consumerId, remoteAddress);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n+            return;\n+        }\n+\n+        if (!consumerFuture.isDone() && consumerFuture\n+                .completeExceptionally(new IllegalStateException(\"Closed consumer before creation was complete\"))) {\n+            // We have received a request to close the consumer before it was actually completed, we have marked the\n+            // consumer future as failed and we can tell the client the close operation was successful. When the actual\n+            // create operation will complete, the new consumer will be discarded.\n+            log.info(\"[{}] Closed consumer {} before its creation was completed\", remoteAddress, consumerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            return;\n+        }\n+\n+        if (consumerFuture.isCompletedExceptionally()) {\n+            log.info(\"[{}] Closed consumer {} that already failed to be created\", remoteAddress, consumerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            return;\n+        }\n+\n+        // Proceed with normal consumer close\n+        Consumer consumer = consumerFuture.getNow(null);\n+        try {\n+            consumer.close();\n+            consumers.remove(consumerId, consumerFuture);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            log.info(\"[{}] Closed consumer {}\", remoteAddress, consumer);\n+        } catch (BrokerServiceException e) {\n+            log.warn(\"[{]] Error closing consumer {} : {}\", remoteAddress, consumer, e);\n+            ctx.writeAndFlush(\n+                    Commands.newError(requestId, BrokerServiceException.getClientErrorCode(e), e.getMessage()));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleGetLastMessageId(CommandGetLastMessageId getLastMessageId) {\n+        checkArgument(state == State.Connected);\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(getLastMessageId.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            long requestId = getLastMessageId.getRequestId();\n+\n+            Topic topic = consumer.getSubscription().getTopic();\n+            Position position = topic.getLastPosition();\n+            int partitionIndex = TopicName.getPartitionIndex(topic.getName());\n+\n+            getLargestBatchIndexWhenPossible(\n+                    topic,\n+                    (PositionImpl) position,\n+                    partitionIndex,\n+                    requestId,\n+                    consumer.getSubscription().getName());\n+\n+        } else {\n+            ctx.writeAndFlush(Commands.newError(getLastMessageId.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n+        }\n+    }\n+\n+    private void getLargestBatchIndexWhenPossible(\n+            Topic topic,\n+            PositionImpl position,\n+            int partitionIndex,\n+            long requestId,\n+            String subscriptionName) {\n+\n+        PersistentTopic persistentTopic = (PersistentTopic) topic;\n+        ManagedLedgerImpl ml = (ManagedLedgerImpl) persistentTopic.getManagedLedger();\n+\n+        // If it's not pointing to a valid entry, respond messageId of the current position.\n+        if (position.getEntryId() == -1) {\n+            MessageIdData messageId = MessageIdData.newBuilder()\n+                    .setLedgerId(position.getLedgerId())\n+                    .setEntryId(position.getEntryId())\n+                    .setPartition(partitionIndex).build();\n+\n+            ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n+        }\n+\n+        // For a valid position, we read the entry out and parse the batch size from its metadata.\n+        CompletableFuture<Entry> entryFuture = new CompletableFuture<>();\n+        ml.asyncReadEntry(position, new AsyncCallbacks.ReadEntryCallback() {\n+            @Override\n+            public void readEntryComplete(Entry entry, Object ctx) {\n+                entryFuture.complete(entry);\n+            }\n+\n+            @Override\n+            public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n+                entryFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+\n+        CompletableFuture<Integer> batchSizeFuture = entryFuture.thenApply(entry -> {\n+            MessageMetadata metadata = Commands.parseMessageMetadata(entry.getDataBuffer());\n+            int batchSize = metadata.getNumMessagesInBatch();\n+            entry.release();\n+            return batchSize;\n+        });\n+\n+        batchSizeFuture.whenComplete((batchSize, e) -> {\n+            if (e != null) {\n+                ctx.writeAndFlush(Commands.newError(\n+                        requestId, ServerError.MetadataError, \"Failed to get batch size for entry \" + e.getMessage()));\n+            } else {\n+                int largestBatchIndex = batchSize > 1 ? batchSize - 1 : -1;\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"[{}] [{}][{}] Get LastMessageId {} partitionIndex {}\", remoteAddress,\n+                            topic.getName(), subscriptionName, position, partitionIndex);\n+                }\n+\n+                MessageIdData messageId = MessageIdData.newBuilder()\n+                        .setLedgerId(position.getLedgerId())\n+                        .setEntryId(position.getEntryId())\n+                        .setPartition(partitionIndex)\n+                        .setBatchIndex(largestBatchIndex).build();\n+\n+                ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void handleGetTopicsOfNamespace(CommandGetTopicsOfNamespace commandGetTopicsOfNamespace) {\n+        final long requestId = commandGetTopicsOfNamespace.getRequestId();\n+        final String namespace = commandGetTopicsOfNamespace.getNamespace();\n+        final CommandGetTopicsOfNamespace.Mode mode = commandGetTopicsOfNamespace.getMode();\n+        final NamespaceName namespaceName = NamespaceName.get(namespace);\n+\n+        getBrokerService().pulsar().getNamespaceService().getListOfTopics(namespaceName, mode)\n+                .thenAccept(topics -> {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}] Received CommandGetTopicsOfNamespace for namespace [//{}] by {}, size:{}\",\n+                                remoteAddress, namespace, requestId, topics.size());\n+                    }\n+\n+                    ctx.writeAndFlush(Commands.newGetTopicsOfNamespaceResponse(topics, requestId));\n+                })\n+                .exceptionally(ex -> {\n+                    log.warn(\"[{}] Error GetTopicsOfNamespace for namespace [//{}] by {}\",\n+                            remoteAddress, namespace, requestId);\n+                    ctx.writeAndFlush(\n+                            Commands.newError(requestId,\n+                                    BrokerServiceException.getClientErrorCode(new ServerMetadataException(ex)),\n+                                    ex.getMessage()));\n+\n+                    return null;\n+                });\n+    }\n+\n+    @Override\n+    protected void handleGetSchema(CommandGetSchema commandGetSchema) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CommandGetSchema call from {}, schemaVersion: {}, topic: {}, requestId: {}\",\n+                    remoteAddress, new String(commandGetSchema.getSchemaVersion().toByteArray()),\n+                    commandGetSchema.getTopic(), commandGetSchema.getRequestId());\n+        }\n+\n+        long requestId = commandGetSchema.getRequestId();\n+        SchemaVersion schemaVersion = SchemaVersion.Latest;\n+        if (commandGetSchema.hasSchemaVersion()) {\n+            schemaVersion = schemaService.versionFromBytes(commandGetSchema.getSchemaVersion().toByteArray());\n+        }\n+\n+        String schemaName;\n+        try {\n+            schemaName = TopicName.get(commandGetSchema.getTopic()).getSchemaName();\n+        } catch (Throwable t) {\n+            ctx.writeAndFlush(\n+                    Commands.newGetSchemaResponseError(requestId, ServerError.InvalidTopicName, t.getMessage()));\n+            return;\n+        }\n+\n+        schemaService.getSchema(schemaName, schemaVersion).thenAccept(schemaAndMetadata -> {\n+            if (schemaAndMetadata == null) {\n+                ctx.writeAndFlush(Commands.newGetSchemaResponseError(requestId, ServerError.TopicNotFound,\n+                        \"Topic not found or no-schema\"));\n+            } else {\n+                ctx.writeAndFlush(Commands.newGetSchemaResponse(requestId,\n+                        SchemaInfoUtil.newSchemaInfo(schemaName, schemaAndMetadata.schema), schemaAndMetadata.version));\n+            }\n+        }).exceptionally(ex -> {\n+            ctx.writeAndFlush(\n+                    Commands.newGetSchemaResponseError(requestId, ServerError.UnknownError, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void handleGetOrCreateSchema(CommandGetOrCreateSchema commandGetOrCreateSchema) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CommandGetOrCreateSchema call from {}\", remoteAddress);\n+        }\n+        long requestId = commandGetOrCreateSchema.getRequestId();\n+        String topicName = commandGetOrCreateSchema.getTopic();\n+        SchemaData schemaData = getSchema(commandGetOrCreateSchema.getSchema());\n+        SchemaData schema = schemaData.getType() == SchemaType.NONE ? null : schemaData;\n+        service.getTopicIfExists(topicName).thenAccept(topicOpt -> {\n+            if (topicOpt.isPresent()) {\n+                Topic topic = topicOpt.get();\n+                CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n+                schemaVersionFuture.exceptionally(ex -> {\n+                    ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n+                    ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n+                            requestId, errorCode, ex.getMessage()));\n+                    return null;\n+                }).thenAccept(schemaVersion -> {\n+                        ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponse(\n+                                requestId, schemaVersion));\n+                });\n+            } else {\n+                ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n+                        requestId, ServerError.TopicNotFound, \"Topic not found\"));\n+            }\n+        }).exceptionally(ex -> {\n+            ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n+            ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n+                    requestId, errorCode, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void handleNewTxn(CommandNewTxn command) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive new txn request {} to transaction meta store {} from {}.\", command.getRequestId(), command.getTcId(), remoteAddress);\n+        }\n+        TransactionCoordinatorID tcId = TransactionCoordinatorID.get(command.getTcId());\n+        service.pulsar().getTransactionMetadataStoreService().newTransaction(tcId)\n+            .whenComplete(((txnID, ex) -> {\n+                if (ex == null) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response {} for new txn request {}\", tcId.getId(),  command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response error for new txn request {}\", command.getRequestId(), ex);\n+                    }\n+                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), tcId.getId(), BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n+                }\n+            }));\n+    }\n+\n+    @Override\n+    protected void handleAddPartitionToTxn(PulsarApi.CommandAddPartitionToTxn command) {\n+        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive add published partition to txn request {} from {} with txnId {}\", command.getRequestId(), remoteAddress, txnID);\n+        }\n+        service.pulsar().getTransactionMetadataStoreService().addProducedPartitionToTxn(txnID, command.getPartitionsList())\n+            .whenComplete(((v, ex) -> {\n+                if (ex == null) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response success for add published partition to txn request {}\",  command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(),\n+                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response error for add published partition to txn request {}\",  command.getRequestId(), ex);\n+                    }\n+                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n+                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n+                }\n+            }));\n+    }\n+\n+    @Override\n+    protected void handleEndTxn(PulsarApi.CommandEndTxn command) {\n+        TxnStatus newStatus = null;\n+        switch (command.getTxnAction()) {\n+            case COMMIT:\n+                newStatus = TxnStatus.COMMITTING;\n+                break;\n+            case ABORT:\n+                newStatus = TxnStatus.ABORTING;\n+                break;\n+        }\n+        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive end txn by {} request {} from {} with txnId {}\", newStatus, command.getRequestId(), remoteAddress, txnID);\n+        }\n+        service.pulsar().getTransactionMetadataStoreService().updateTxnStatus(txnID, newStatus, TxnStatus.OPEN)\n+            .whenComplete((v, ex) -> {\n+                if (ex == null) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response success for end txn request {}\", command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(),\n+                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response error for end txn request {}\", command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n+                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n+                }\n+            });\n+    }\n+\n+    private CompletableFuture<SchemaVersion> tryAddSchema(Topic topic, SchemaData schema) {\n+        if (schema != null) {\n+            return topic.addSchema(schema);\n+        } else {\n+            return topic.hasSchema().thenCompose((hasSchema) -> {\n+                log.info(\"[{}] {} configured with schema {}\",\n+                         remoteAddress, topic.getName(), hasSchema);\n+                CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+                if (hasSchema && (schemaValidationEnforced || topic.getSchemaValidationEnforced())) {\n+                    result.completeExceptionally(new IncompatibleSchemaException(\n+                            \"Producers cannot connect or send message without a schema to topics with a schema\"));\n+                } else {\n+                    result.complete(SchemaVersion.Empty);\n+                }\n+                return result;\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected boolean isHandshakeCompleted() {\n+        return state == State.Connected;\n+    }\n+\n+    public void closeProducer(Producer producer) {\n+        // removes producer-connection from map and send close command to producer\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n+        }\n+        long producerId = producer.getProducerId();\n+        producers.remove(producerId);\n+        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n+            ctx.writeAndFlush(Commands.newCloseProducer(producerId, -1L));\n+        } else {\n+            close();\n+        }\n+\n+    }\n+\n+    @Override\n+    public void closeConsumer(Consumer consumer) {\n+        // removes consumer-connection from map and send close command to consumer\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n+        }\n+        long consumerId = consumer.consumerId();\n+        consumers.remove(consumerId);\n+        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n+            ctx.writeAndFlush(Commands.newCloseConsumer(consumerId, -1L));\n+        } else {\n+            close();\n+        }\n     }\n \n     /**\n-     * The security role for this connection\n-     * @return the role\n+     * It closes the connection with client which triggers {@code channelInactive()} which clears all producers and\n+     * consumers from connection-map\n      */\n-    default String getRole() {\n-        return null;\n+    protected void close() {\n+        ctx.close();\n+    }\n+\n+    @Override\n+    public SocketAddress clientAddress() {\n+        return remoteAddress;\n+    }\n+\n+    @Override\n+    public void removedConsumer(Consumer consumer) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n+        }\n+\n+        consumers.remove(consumer.consumerId());\n+    }\n+\n+    @Override\n+    public void removedProducer(Producer producer) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n+        }\n+        producers.remove(producer.getProducerId());\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return isActive;\n+    }\n+\n+    @Override\n+    public boolean isWritable() {\n+        return ctx.channel().isWritable();\n     }\n \n-    default AuthenticationDataSource getAuthenticationData() {\n-        return null;\n+\n+    public void startSendOperation(Producer producer, int msgSize, int numMessages) {\n+        MSG_PUBLISH_BUFFER_SIZE_UPDATER.getAndAdd(this, msgSize);\n+        boolean isPublishRateExceeded = false;\n+        if (preciseTopicPublishRateLimitingEnable) {\n+            boolean isPreciseTopicPublishRateExceeded = producer.getTopic().isTopicPublishRateExceeded(numMessages, msgSize);\n+            if (isPreciseTopicPublishRateExceeded) {\n+                producer.getTopic().disableCnxAutoRead();\n+                return;\n+            }\n+            isPublishRateExceeded = producer.getTopic().isBrokerPublishRateExceeded();\n+        } else {\n+            isPublishRateExceeded = producer.getTopic().isPublishRateExceeded();\n+        }\n+\n+        if (++pendingSendRequest == maxPendingSendRequests || isPublishRateExceeded) {\n+            // When the quota of pending send requests is reached, stop reading from socket to cause backpressure on\n+            // client connection, possibly shared between multiple producers\n+            ctx.channel().config().setAutoRead(false);\n+            autoReadDisabledRateLimiting = isPublishRateExceeded;\n+\n+        }\n+        if (getBrokerService().isReachMessagePublishBufferThreshold()) {\n+            ctx.channel().config().setAutoRead(false);\n+            autoReadDisabledPublishBufferLimiting = true;\n+        }\n     }\n \n-    default boolean isActive() {\n-        return true;\n+    @Override\n+    public void completedSendOperation(boolean isNonPersistentTopic, int msgSize) {\n+        MSG_PUBLISH_BUFFER_SIZE_UPDATER.getAndAdd(this, -msgSize);\n+        if (--pendingSendRequest == resumeReadsThreshold) {\n+            // Resume reading from socket\n+            ctx.channel().config().setAutoRead(true);\n+            // triggers channel read if autoRead couldn't trigger it\n+            ctx.read();\n+        }\n+        if (isNonPersistentTopic) {\n+            nonPersistentPendingMessages--;\n+        }\n     }\n \n-    default boolean isWritable() {\n-        return true;\n+    @Override\n+    public AuthenticationDataSource getAuthenticationData() {\n+        return authenticationData;\n     }\n \n-    default void completedSendOperation(boolean isNonPersistentTopic, int msgSize) {\n-        // No-op\n+    @Override\n+    public void enableCnxAutoRead() {\n+        // we can add check (&& pendingSendRequest < MaxPendingSendRequests) here but then it requires\n+        // pendingSendRequest to be volatile and it can be expensive while writing. also this will be called on if\n+        // throttling is enable on the topic. so, avoid pendingSendRequest check will be fine.\n+        if (!ctx.channel().config().isAutoRead() && !autoReadDisabledRateLimiting && !autoReadDisabledPublishBufferLimiting) {\n+            // Resume reading from socket if pending-request is not reached to threshold\n+            ctx.channel().config().setAutoRead(true);\n+            // triggers channel read\n+            ctx.read();\n+        }\n     }\n \n-    default void removedProducer(Producer producer) {\n-        // No-op\n+    @Override\n+    public void disableCnxAutoRead() {\n+        if (ctx.channel().config().isAutoRead() ) {\n+            ctx.channel().config().setAutoRead(false);\n+        }\n     }\n \n-    default void closeProducer(Producer producer) {\n-        // No-op\n+    @Override\n+    public void cancelPublishRateLimiting() {\n+        if (autoReadDisabledRateLimiting) {\n+            autoReadDisabledRateLimiting = false;\n+        }\n     }\n \n-    default long getMessagePublishBufferSize() {\n-        return Long.MAX_VALUE;\n+    @Override\n+    public void cancelPublishBufferLimiting() {\n+        if (autoReadDisabledPublishBufferLimiting) {\n+            autoReadDisabledPublishBufferLimiting = false;\n+        }\n     }\n \n-    default void cancelPublishRateLimiting() {\n-        // No-op\n+    private <T> ServerError getErrorCode(CompletableFuture<T> future) {\n+        ServerError error = ServerError.UnknownError;\n+        try {\n+            future.getNow(null);\n+        } catch (Exception e) {\n+            if (e.getCause() instanceof BrokerServiceException) {\n+                error = BrokerServiceException.getClientErrorCode(e.getCause());\n+            }\n+        }\n+        return error;\n     }\n \n-    default void cancelPublishBufferLimiting() {\n-        // No-op\n+    private void disableTcpNoDelayIfNeeded(String topic, String producerName) {\n+        if (producerName != null && producerName.startsWith(replicatorPrefix)) {\n+            // Re-enable nagle algorithm on connections used for replication purposes\n+            try {\n+                if (ctx.channel().config().getOption(ChannelOption.TCP_NODELAY).booleanValue() == true) {\n+                    ctx.channel().config().setOption(ChannelOption.TCP_NODELAY, false);\n+                }\n+            } catch (Throwable t) {\n+                log.warn(\"[{}] [{}] Failed to remove TCP no-delay property on client cnx {}\", topic, producerName,\n+                        ctx.channel());\n+            }\n+        }\n     }\n \n-    default void disableCnxAutoRead() {\n-        // No-op\n+    private TopicName validateTopicName(String topic, long requestId, GeneratedMessageLite requestCommand) {\n+        try {\n+            return TopicName.get(topic);\n+        } catch (Throwable t) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Failed to parse topic name '{}'\", remoteAddress, topic, t);\n+            }\n+\n+            if (requestCommand instanceof CommandLookupTopic) {\n+                ctx.writeAndFlush(Commands.newLookupErrorResponse(ServerError.InvalidTopicName,\n+                        \"Invalid topic name: \" + t.getMessage(), requestId));\n+            } else if (requestCommand instanceof CommandPartitionedTopicMetadata) {\n+                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.InvalidTopicName,\n+                        \"Invalid topic name: \" + t.getMessage(), requestId));\n+            } else {\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.InvalidTopicName,\n+                        \"Invalid topic name: \" + t.getMessage()));\n+            }\n+\n+            return null;\n+        }\n     }\n \n-    default void enableCnxAutoRead() {\n-        // No-op\n+    private static final Logger log = LoggerFactory.getLogger(ServerCnx.class);\n+\n+    /**\n+     * Helper method for testability\n+     *\n+     * @return\n+     */\n+    public State getState() {\n+        return state;\n     }\n \n-    default void execute(Runnable runnable) {\n-        CompletableFuture.runAsync(runnable);\n+    public BrokerService getBrokerService() {\n+        return service;\n     }\n \n-    default void removedConsumer(Consumer consumer) {\n-        // No-op\n+    public String getRole() {\n+        return authRole;\n     }\n \n-    default void closeConsumer(Consumer consumer) {\n-        // No-op\n+    boolean hasConsumer(long consumerId) {\n+        return consumers.containsKey(consumerId);\n     }\n \n-    default void sendProducerError(long producerId, long sequenceId, ServerError serverError, String message) {\n-        // No-op\n+    @Override\n+    public boolean isBatchMessageCompatibleVersion() {\n+        return remoteEndpointProtocolVersion >= ProtocolVersion.v4.getNumber();\n     }\n \n-    default void sendProducerReceipt(long producerId, long sequenceId, long highestSequenceId, long ledgerId, long entryId) {\n-        // No-op\n+    boolean supportsAuthenticationRefresh() {\n+        return features != null && features.getSupportsAuthRefresh();\n     }\n \n-    default void sendActiveConsumerChange(long consumerId, boolean isActive) {\n-        // No-op\n+    @Override\n+    public String getClientVersion() {\n+        return clientVersion;\n     }\n \n-    default void sendSuccess(long requestId) {\n-        // No-op\n+    @Override\n+    public long getMessagePublishBufferSize() {\n+        return this.messagePublishBufferSize;\n     }\n \n-    default void sendError(long requestId, ServerError error, String message) {\n-        // No-op\n+    @VisibleForTesting\n+    void setMessagePublishBufferSize(long bufferSize) {\n+        this.messagePublishBufferSize = bufferSize;\n     }\n \n-    default void sendReachedEndOfTopic(long consumerId) {\n-        // No-op\n+    @VisibleForTesting\n+    void setAutoReadDisabledRateLimiting(boolean isLimiting) {\n+        this.autoReadDisabledRateLimiting = isLimiting;\n     }\n \n-    default CompletableFuture<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n-            int partitionIdx, final List<Entry> entries, EntryBatchSizes batchSizes,\n+    @VisibleForTesting\n+    void setCtx(ChannelHandlerContext ctx) {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public boolean isPreciseDispatcherFlowControl() {\n+        return preciseDispatcherFlowControl;\n+    }\n+\n+    @Override\n+    public void sendProducerError(long producerId, long sequenceId, PulsarApi.ServerError serverError, String message) {\n+        ctx.writeAndFlush(Commands.newSendError(producerId, sequenceId, serverError, message));\n+    }\n+\n+    @Override\n+    public void execute(Runnable runnable) {\n+        ctx.channel().eventLoop().execute(runnable);\n+    }\n+\n+    @Override\n+    public void sendProducerReceipt(long producerId, long sequenceId, long highestSequenceId, long ledgerId, long entryId) {\n+        ctx.writeAndFlush(\n+                Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, ledgerId, entryId),\n+                ctx.voidPromise());\n+    }\n+\n+    @Override\n+    public void sendActiveConsumerChange(long consumerId, boolean isActive) {\n+        if (!Commands.peerSupportsActiveConsumerListener(getRemoteEndpointProtocolVersion())) {\n+            // if the client is older than `v12`, we don't need to send consumer group changes.\n+            return;\n+        }\n+        ctx.writeAndFlush(\n+                Commands.newActiveConsumerChange(consumerId, isActive),\n+                ctx.voidPromise());\n+    }\n+\n+    @Override\n+    public void sendSuccess(long requestId) {\n+        ctx.writeAndFlush(Commands.newSuccess(requestId));\n+    }\n+\n+    @Override\n+    public void sendError(long requestId, ServerError error, String message) {\n+        ctx.writeAndFlush(Commands.newError(requestId, error, message));\n+    }\n+\n+    @Override\n+    public void sendReachedEndOfTopic(long consumerId) {\n+        // Only send notification if the client understand the command\n+        if (getRemoteEndpointProtocolVersion() >= ProtocolVersion.v9_VALUE) {\n+            log.info(\"[{}] Notifying consumer that end of topic has been reached\", this);\n+            ctx.writeAndFlush(Commands.newReachedEndOfTopic(consumerId));\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n+            int partitionIdx, final List<Entry> entries, EntryBatchSizes batchSizes, EntryBatchIndexesAcks batchIndexesAcks,\n             RedeliveryTracker redeliveryTracker) {\n-        return CompletableFuture.completedFuture(null);\n+        CompletableFuture<Void> writeFuture = new CompletableFuture<>();\n+        ctx.channel().eventLoop().execute(() -> {\n+            for (int i = 0; i < entries.size(); i++) {\n+                Entry entry = entries.get(i);\n+                if (entry == null) {\n+                    // Entry was filtered out\n+                    continue;\n+                }\n+\n+                int batchSize = batchSizes.getBatchSize(i);\n+\n+                if (batchSize > 1 && !isBatchMessageCompatibleVersion()) {\n+                    log.warn(\"[{}-{}] Consumer doesn't support batch messages -  consumerId {}, msg id {}-{}\",\n+                            topicName, subscription,\n+                            consumerId, entry.getLedgerId(), entry.getEntryId());\n+                    ctx.close();\n+                    entry.release();\n+                    continue;\n+                }\n+\n+                MessageIdData.Builder messageIdBuilder = MessageIdData.newBuilder();\n+                MessageIdData messageId = messageIdBuilder\n+                    .setLedgerId(entry.getLedgerId())\n+                    .setEntryId(entry.getEntryId())\n+                    .setPartition(partitionIdx)\n+                    .build();\n+\n+                ByteBuf metadataAndPayload = entry.getDataBuffer();\n+                // increment ref-count of data and release at the end of process: so, we can get chance to call entry.release\n+                metadataAndPayload.retain();\n+                // skip checksum by incrementing reader-index if consumer-client doesn't support checksum verification\n+                if (getRemoteEndpointProtocolVersion() < ProtocolVersion.v11.getNumber()) {\n+                    Commands.skipChecksumIfPresent(metadataAndPayload);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"[{}-{}] Sending message to consumerId {}, msg id {}-{}\", topicName, subscription,\n+                            consumerId, entry.getLedgerId(), entry.getEntryId());\n+                }\n+\n+                int redeliveryCount = 0;\n+                PositionImpl position = PositionImpl.get(messageId.getLedgerId(), messageId.getEntryId());\n+                if (redeliveryTracker.contains(position)) {\n+                    redeliveryCount = redeliveryTracker.incrementAndGetRedeliveryCount(position);\n+                }\n+                ctx.write(Commands.newMessage(consumerId, messageId, redeliveryCount, metadataAndPayload,\n+                    batchIndexesAcks == null ? null : batchIndexesAcks.getAckSet(i)), ctx.voidPromise());\n+                messageId.recycle();\n+                messageIdBuilder.recycle();\n+                entry.release();\n+            }\n+\n+            final ChannelPromise writePromise = ctx.newPromise().addListener(future -> {\n+                    if(future.isSuccess()) {\n+                        writeFuture.complete(null);\n+                    } else {\n+                        writeFuture.completeExceptionally(future.cause());\n+                    }\n+            });\n+            // Use an empty write here so that we can just tie the flush with the write promise for last entry\n+            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER, writePromise);\n+            batchSizes.recyle();\n+            if (batchIndexesAcks != null) {\n+                batchIndexesAcks.recycle();\n+            }\n+        });\n+        return writeFuture;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTQ1Njc0MQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r409456741", "bodyText": "Replace with an Optional ?", "author": "cbornet", "createdAt": "2020-04-16T10:38:34Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -18,1911 +18,119 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n-import static org.apache.commons.lang3.StringUtils.isNotBlank;\n-import static org.apache.pulsar.broker.admin.impl.PersistentTopicsBase.getPartitionedTopicMetadata;\n-import static org.apache.pulsar.broker.lookup.TopicLookupBase.lookupTopicAsync;\n-import static org.apache.pulsar.common.protocol.Commands.newLookupErrorResponse;\n-import static org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion.v5;\n-\n-import com.google.common.annotations.VisibleForTesting;\n-import com.google.common.base.Strings;\n-\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandler;\n-import io.netty.channel.ChannelHandlerContext;\n-import io.netty.channel.ChannelOption;\n-import io.netty.handler.ssl.SslHandler;\n-\n-import java.net.SocketAddress;\n-\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.Semaphore;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n-import java.util.stream.Collectors;\n-\n-import javax.naming.AuthenticationException;\n-import javax.net.ssl.SSLSession;\n-\n-import org.apache.bookkeeper.mledger.AsyncCallbacks;\n import org.apache.bookkeeper.mledger.Entry;\n-import org.apache.bookkeeper.mledger.ManagedLedgerException;\n-import org.apache.bookkeeper.mledger.Position;\n-import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n-import org.apache.bookkeeper.mledger.impl.PositionImpl;\n-import org.apache.bookkeeper.mledger.util.SafeRun;\n-import org.apache.commons.lang3.StringUtils;\n-import org.apache.commons.lang3.exception.ExceptionUtils;\n-import org.apache.pulsar.broker.PulsarServerException;\n-import org.apache.pulsar.broker.PulsarService;\n import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n-import org.apache.pulsar.broker.authentication.AuthenticationProvider;\n-import org.apache.pulsar.broker.authentication.AuthenticationState;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerBusyException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ServerMetadataException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.ServiceUnitNotReadyException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.SubscriptionNotFoundException;\n-import org.apache.pulsar.broker.service.BrokerServiceException.TopicNotFoundException;\n-import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n-import org.apache.pulsar.broker.service.schema.exceptions.IncompatibleSchemaException;\n-import org.apache.pulsar.broker.service.schema.SchemaRegistryService;\n-import org.apache.pulsar.broker.web.RestException;\n-import org.apache.pulsar.client.api.PulsarClientException;\n-import org.apache.pulsar.client.impl.BatchMessageIdImpl;\n-import org.apache.pulsar.client.impl.ClientCnx;\n-import org.apache.pulsar.client.impl.MessageIdImpl;\n-import org.apache.pulsar.common.api.AuthData;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandNewTxn;\n-import org.apache.pulsar.common.protocol.CommandUtils;\n-import org.apache.pulsar.common.protocol.Commands;\n-import org.apache.pulsar.common.protocol.PulsarHandler;\n-import org.apache.pulsar.common.api.proto.PulsarApi;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandAuthResponse;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseConsumer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseProducer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConnect;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStats;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStatsResponse;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandFlow;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetLastMessageId;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetSchema;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetOrCreateSchema;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetTopicsOfNamespace;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandLookupTopic;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandPartitionedTopicMetadata;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandProducer;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandRedeliverUnacknowledgedMessages;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSeek;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSend;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.SubType;\n-import org.apache.pulsar.common.api.proto.PulsarApi.CommandUnsubscribe;\n-import org.apache.pulsar.common.api.proto.PulsarApi.FeatureFlags;\n-import org.apache.pulsar.common.api.proto.PulsarApi.MessageIdData;\n-import org.apache.pulsar.common.api.proto.PulsarApi.MessageMetadata;\n-import org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion;\n import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n-import org.apache.pulsar.common.naming.Metadata;\n-import org.apache.pulsar.common.naming.NamespaceName;\n-import org.apache.pulsar.common.naming.TopicName;\n-import org.apache.pulsar.common.policies.data.BacklogQuota;\n-import org.apache.pulsar.common.policies.data.ConsumerStats;\n-import org.apache.pulsar.common.protocol.schema.SchemaData;\n-import org.apache.pulsar.common.protocol.schema.SchemaInfoUtil;\n-import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n-import org.apache.pulsar.common.schema.SchemaType;\n-import org.apache.pulsar.common.util.FutureUtil;\n-import org.apache.pulsar.common.util.collections.ConcurrentLongHashMap;\n-import org.apache.pulsar.shaded.com.google.protobuf.v241.GeneratedMessageLite;\n-import org.apache.pulsar.transaction.coordinator.TransactionCoordinatorID;\n-import org.apache.pulsar.transaction.impl.common.TxnID;\n-import org.apache.pulsar.transaction.impl.common.TxnStatus;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-public class ServerCnx extends PulsarHandler {\n-    private final BrokerService service;\n-    private final SchemaRegistryService schemaService;\n-    private final ConcurrentLongHashMap<CompletableFuture<Producer>> producers;\n-    private final ConcurrentLongHashMap<CompletableFuture<Consumer>> consumers;\n-    private State state;\n-    private volatile boolean isActive = true;\n-    String authRole = null;\n-    AuthenticationDataSource authenticationData;\n-    AuthenticationProvider authenticationProvider;\n-    AuthenticationState authState;\n-    // In case of proxy, if the authentication credentials are forwardable,\n-    // it will hold the credentials of the original client\n-    AuthenticationState originalAuthState;\n-    private boolean pendingAuthChallengeResponse = false;\n-\n-    // Max number of pending requests per connections. If multiple producers are sharing the same connection the flow\n-    // control done by a single producer might not be enough to prevent write spikes on the broker.\n-    private final int maxPendingSendRequests;\n-    private final int resumeReadsThreshold;\n-    private int pendingSendRequest = 0;\n-    private final String replicatorPrefix;\n-    private String clientVersion = null;\n-    private int nonPersistentPendingMessages = 0;\n-    private final int MaxNonPersistentPendingMessages;\n-    private String originalPrincipal = null;\n-    private Set<String> proxyRoles;\n-    private boolean authenticateOriginalAuthData;\n-    private final boolean schemaValidationEnforced;\n-    private String authMethod = \"none\";\n-    private final int maxMessageSize;\n-\n-    // Flag to manage throttling-rate by atomically enable/disable read-channel.\n-    private volatile boolean autoReadDisabledRateLimiting = false;\n-    private FeatureFlags features;\n-    // Flag to manage throttling-publish-buffer by atomically enable/disable read-channel.\n-    private volatile boolean autoReadDisabledPublishBufferLimiting = false;\n-    private static final AtomicLongFieldUpdater<ServerCnx> MSG_PUBLISH_BUFFER_SIZE_UPDATER =\n-            AtomicLongFieldUpdater.newUpdater(ServerCnx.class, \"messagePublishBufferSize\");\n-    private volatile long messagePublishBufferSize = 0;\n-\n-    enum State {\n-        Start, Connected, Failed, Connecting\n-    }\n-\n-    public ServerCnx(PulsarService pulsar) {\n-        super(pulsar.getBrokerService().getKeepAliveIntervalSeconds(), TimeUnit.SECONDS);\n-        this.service = pulsar.getBrokerService();\n-        this.schemaService = pulsar.getSchemaRegistryService();\n-        this.state = State.Start;\n-\n-        // This maps are not heavily contended since most accesses are within the cnx thread\n-        this.producers = new ConcurrentLongHashMap<>(8, 1);\n-        this.consumers = new ConcurrentLongHashMap<>(8, 1);\n-        this.replicatorPrefix = service.pulsar().getConfiguration().getReplicatorPrefix();\n-        this.MaxNonPersistentPendingMessages = service.pulsar().getConfiguration()\n-                .getMaxConcurrentNonPersistentMessagePerConnection();\n-        this.proxyRoles = service.pulsar().getConfiguration().getProxyRoles();\n-        this.authenticateOriginalAuthData = service.pulsar().getConfiguration().isAuthenticateOriginalAuthData();\n-        this.schemaValidationEnforced = pulsar.getConfiguration().isSchemaValidationEnforced();\n-        this.maxMessageSize = pulsar.getConfiguration().getMaxMessageSize();\n-        this.maxPendingSendRequests = pulsar.getConfiguration().getMaxPendingPublishdRequestsPerConnection();\n-        this.resumeReadsThreshold = maxPendingSendRequests / 2;\n-    }\n-\n-    @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelActive(ctx);\n-        log.info(\"New connection from {}\", remoteAddress);\n-        this.ctx = ctx;\n-    }\n-\n-    @Override\n-    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelInactive(ctx);\n-        isActive = false;\n-        log.info(\"Closed connection from {}\", remoteAddress);\n-\n-        // Connection is gone, close the producers immediately\n-        producers.values().forEach((producerFuture) -> {\n-            if (producerFuture.isDone() && !producerFuture.isCompletedExceptionally()) {\n-                Producer producer = producerFuture.getNow(null);\n-                producer.closeNow(true);\n-            }\n-        });\n-\n-        consumers.values().forEach((consumerFuture) -> {\n-            Consumer consumer;\n-            if (consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-                consumer = consumerFuture.getNow(null);\n-            } else {\n-                return;\n-            }\n-\n-            try {\n-                consumer.close();\n-            } catch (BrokerServiceException e) {\n-                log.warn(\"Consumer {} was already closed: {}\", consumer, e);\n-            }\n-        });\n-    }\n-\n-    @Override\n-    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Channel writability has changed to: {}\", ctx.channel().isWritable());\n-        }\n-    }\n-\n-    @Override\n-    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n-        if (state != State.Failed) {\n-            // No need to report stack trace for known exceptions that happen in disconnections\n-            log.warn(\"[{}] Got exception {}\", remoteAddress,\n-                    ClientCnx.isKnownException(cause) ? cause : ExceptionUtils.getStackTrace(cause));\n-            state = State.Failed;\n-        } else {\n-            // At default info level, suppress all subsequent exceptions that are thrown when the connection has already\n-            // failed\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Got exception: {}\", remoteAddress, cause);\n-            }\n-        }\n-        ctx.close();\n-    }\n-\n-    /*\n-     * If authentication and authorization is enabled(and not sasl) and if the authRole is one of proxyRoles we want to enforce\n-     * - the originalPrincipal is given while connecting\n-     * - originalPrincipal is not blank\n-     * - originalPrincipal is not a proxy principal\n-     */\n-    private boolean invalidOriginalPrincipal(String originalPrincipal) {\n-        return (service.isAuthenticationEnabled() && service.isAuthorizationEnabled()\n-            && proxyRoles.contains(authRole) && (StringUtils.isBlank(originalPrincipal) || proxyRoles.contains(originalPrincipal)));\n-    }\n-\n-    // ////\n-    // // Incoming commands handling\n-    // ////\n-\n-    @Override\n-    protected void handleLookup(CommandLookupTopic lookup) {\n-        final long requestId = lookup.getRequestId();\n-        final boolean authoritative = lookup.getAuthoritative();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received Lookup from {} for {}\", lookup.getTopic(), remoteAddress, requestId);\n-        }\n-\n-        TopicName topicName = validateTopicName(lookup.getTopic(), requestId, lookup);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n-        if (lookupSemaphore.tryAcquire()) {\n-            if (invalidOriginalPrincipal(originalPrincipal)) {\n-                final String msg = \"Valid Proxy Client role should be provided for lookup \";\n-                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                        originalPrincipal, topicName);\n-                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return;\n-            }\n-            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-                isProxyAuthorizedFuture = service.getAuthorizationService().canLookupAsync(topicName, authRole,\n-                    authenticationData);\n-            } else {\n-                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-            }\n-            String finalOriginalPrincipal = originalPrincipal;\n-            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-                if (isProxyAuthorized) {\n-                    lookupTopicAsync(getBrokerService().pulsar(), topicName, authoritative,\n-                            finalOriginalPrincipal != null ? finalOriginalPrincipal : authRole, authenticationData,\n-                            requestId).handle((lookupResponse, ex) -> {\n-                                if (ex == null) {\n-                                    ctx.writeAndFlush(lookupResponse);\n-                                } else {\n-                                    // it should never happen\n-                                    log.warn(\"[{}] lookup failed with error {}, {}\", remoteAddress, topicName,\n-                                            ex.getMessage(), ex);\n-                                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.ServiceNotReady,\n-                                            ex.getMessage(), requestId));\n-                                }\n-                                lookupSemaphore.release();\n-                                return null;\n-                            });\n-                } else {\n-                    final String msg = \"Proxy Client is not authorized to Lookup\";\n-                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                    lookupSemaphore.release();\n-                }\n-                return null;\n-            }).exceptionally(ex -> {\n-                final String msg = \"Exception occured while trying to authorize lookup\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName, ex);\n-                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return null;\n-            });\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Failed lookup due to too many lookup-requests {}\", remoteAddress, topicName);\n-            }\n-            ctx.writeAndFlush(newLookupErrorResponse(ServerError.TooManyRequests,\n-                    \"Failed due to too many pending lookup requests\", requestId));\n-        }\n-    }\n-\n-    @Override\n-    protected void handlePartitionMetadataRequest(CommandPartitionedTopicMetadata partitionMetadata) {\n-        final long requestId = partitionMetadata.getRequestId();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received PartitionMetadataLookup from {} for {}\", partitionMetadata.getTopic(),\n-                    remoteAddress, requestId);\n-        }\n-\n-        TopicName topicName = validateTopicName(partitionMetadata.getTopic(), requestId, partitionMetadata);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n-        if (lookupSemaphore.tryAcquire()) {\n-            if (invalidOriginalPrincipal(originalPrincipal)) {\n-                final String msg = \"Valid Proxy Client role should be provided for getPartitionMetadataRequest \";\n-                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                        originalPrincipal, topicName);\n-                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError,\n-                        msg, requestId));\n-                lookupSemaphore.release();\n-                return;\n-            }\n-            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-                isProxyAuthorizedFuture = service.getAuthorizationService()\n-                        .canLookupAsync(topicName, authRole, authenticationData);\n-            } else {\n-                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-            }\n-            String finalOriginalPrincipal = originalPrincipal;\n-            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-                if (isProxyAuthorized) {\n-                    getPartitionedTopicMetadata(getBrokerService().pulsar(),\n-                            authRole, finalOriginalPrincipal, authenticationData,\n-                            topicName).handle((metadata, ex) -> {\n-                                if (ex == null) {\n-                                    int partitions = metadata.partitions;\n-                                    ctx.writeAndFlush(Commands.newPartitionMetadataResponse(partitions, requestId));\n-                                } else {\n-                                    if (ex instanceof PulsarClientException) {\n-                                        log.warn(\"Failed to authorize {} at [{}] on topic {} : {}\", getRole(),\n-                                                remoteAddress, topicName, ex.getMessage());\n-                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(\n-                                                ServerError.AuthorizationError, ex.getMessage(), requestId));\n-                                    } else {\n-                                        log.warn(\"Failed to get Partitioned Metadata [{}] {}: {}\", remoteAddress,\n-                                                topicName, ex.getMessage(), ex);\n-                                        ServerError error = (ex instanceof RestException)\n-                                                && ((RestException) ex).getResponse().getStatus() < 500\n-                                                        ? ServerError.MetadataError\n-                                                        : ServerError.ServiceNotReady;\n-                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(error,\n-                                                ex.getMessage(), requestId));\n-                                    }\n-                                }\n-                                lookupSemaphore.release();\n-                                return null;\n-                            });\n-                } else {\n-                    final String msg = \"Proxy Client is not authorized to Get Partition Metadata\";\n-                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                    ctx.writeAndFlush(\n-                            Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n-                    lookupSemaphore.release();\n-                }\n-                return null;\n-            }).exceptionally(ex -> {\n-                final String msg = \"Exception occured while trying to authorize get Partition Metadata\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n-                lookupSemaphore.release();\n-                return null;\n-            });\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Failed Partition-Metadata lookup due to too many lookup-requests {}\", remoteAddress,\n-                        topicName);\n-            }\n-            ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.TooManyRequests,\n-                    \"Failed due to too many pending lookup requests\", requestId));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleConsumerStats(CommandConsumerStats commandConsumerStats) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandConsumerStats call from {}\", remoteAddress);\n-        }\n-\n-        final long requestId = commandConsumerStats.getRequestId();\n-        final long consumerId = commandConsumerStats.getConsumerId();\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n-        Consumer consumer = consumerFuture.getNow(null);\n-        ByteBuf msg = null;\n-\n-        if (consumer == null) {\n-            log.error(\n-                    \"Failed to get consumer-stats response - Consumer not found for CommandConsumerStats[remoteAddress = {}, requestId = {}, consumerId = {}]\",\n-                    remoteAddress, requestId, consumerId);\n-            msg = Commands.newConsumerStatsResponse(ServerError.ConsumerNotFound,\n-                    \"Consumer \" + consumerId + \" not found\", requestId);\n-        } else {\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"CommandConsumerStats[requestId = {}, consumer = {}]\", requestId, consumer);\n-            }\n-            msg = Commands.newConsumerStatsResponse(createConsumerStatsResponse(consumer, requestId));\n-        }\n-\n-        ctx.writeAndFlush(msg);\n-    }\n-\n-    CommandConsumerStatsResponse.Builder createConsumerStatsResponse(Consumer consumer, long requestId) {\n-        CommandConsumerStatsResponse.Builder commandConsumerStatsResponseBuilder = CommandConsumerStatsResponse\n-                .newBuilder();\n-        ConsumerStats consumerStats = consumer.getStats();\n-        commandConsumerStatsResponseBuilder.setRequestId(requestId);\n-        commandConsumerStatsResponseBuilder.setMsgRateOut(consumerStats.msgRateOut);\n-        commandConsumerStatsResponseBuilder.setMsgThroughputOut(consumerStats.msgThroughputOut);\n-        commandConsumerStatsResponseBuilder.setMsgRateRedeliver(consumerStats.msgRateRedeliver);\n-        commandConsumerStatsResponseBuilder.setConsumerName(consumerStats.consumerName);\n-        commandConsumerStatsResponseBuilder.setAvailablePermits(consumerStats.availablePermits);\n-        commandConsumerStatsResponseBuilder.setUnackedMessages(consumerStats.unackedMessages);\n-        commandConsumerStatsResponseBuilder.setBlockedConsumerOnUnackedMsgs(consumerStats.blockedConsumerOnUnackedMsgs);\n-        commandConsumerStatsResponseBuilder.setAddress(consumerStats.getAddress());\n-        commandConsumerStatsResponseBuilder.setConnectedSince(consumerStats.getConnectedSince());\n-\n-        Subscription subscription = consumer.getSubscription();\n-        commandConsumerStatsResponseBuilder.setMsgBacklog(subscription.getNumberOfEntriesInBacklog(false));\n-        commandConsumerStatsResponseBuilder.setMsgRateExpired(subscription.getExpiredMessageRate());\n-        commandConsumerStatsResponseBuilder.setType(subscription.getTypeString());\n-\n-        return commandConsumerStatsResponseBuilder;\n-    }\n-\n-    // complete the connect and sent newConnected command\n-    private void completeConnect(int clientProtoVersion, String clientVersion) {\n-        ctx.writeAndFlush(Commands.newConnected(clientProtoVersion, maxMessageSize));\n-        state = State.Connected;\n-        remoteEndpointProtocolVersion = clientProtoVersion;\n-        if (isNotBlank(clientVersion) && !clientVersion.contains(\" \") /* ignore default version: pulsar client */) {\n-            this.clientVersion = clientVersion.intern();\n-        }\n-    }\n-\n-    // According to auth result, send newConnected or newAuthChallenge command.\n-    private State doAuthentication(AuthData clientData,\n-                                   int clientProtocolVersion,\n-                                   String clientVersion) throws Exception {\n-\n-        // The original auth state can only be set on subsequent auth attempts (and only\n-        // in presence of a proxy and if the proxy is forwarding the credentials).\n-        // In this case, the re-validation needs to be done against the original client\n-        // credentials.\n-        boolean useOriginalAuthState = (originalAuthState != null);\n-        AuthenticationState authState =  useOriginalAuthState ? originalAuthState : this.authState;\n-        String authRole = useOriginalAuthState ? originalPrincipal : this.authRole;\n-        AuthData brokerData = authState.authenticate(clientData);\n-\n-\n-        if (authState.isComplete()) {\n-            // Authentication has completed. It was either:\n-            // 1. the 1st time the authentication process was done, in which case we'll\n-            //    a `CommandConnected` response\n-            // 2. an authentication refresh, in which case we don't need to do anything else\n-\n-            String newAuthRole = authState.getAuthRole();\n-\n-            if (!useOriginalAuthState) {\n-                this.authRole = newAuthRole;\n-            }\n-\n-            if (log.isDebugEnabled()) {\n-                log.debug(\"[{}] Client successfully authenticated with {} role {} and originalPrincipal {}\",\n-                        remoteAddress, authMethod, authRole, originalPrincipal);\n-            }\n-\n-            if (state != State.Connected) {\n-                // First time authentication is done\n-                completeConnect(clientProtocolVersion, clientVersion);\n-            } else {\n-                // If the connection was already ready, it means we're doing a refresh\n-                if (!StringUtils.isEmpty(authRole)) {\n-                    if (!authRole.equals(newAuthRole)) {\n-                        log.warn(\"[{}] Principal cannot be changed during an authentication refresh\", remoteAddress);\n-                        ctx.close();\n-                    } else {\n-                        log.info(\"[{}] Refreshed authentication credentials for role {}\", remoteAddress, authRole);\n-                    }\n-                }\n-            }\n-\n-            return State.Connected;\n-        }\n-\n-        // auth not complete, continue auth with client side.\n-        ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, clientProtocolVersion));\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Authentication in progress client by method {}.\",\n-                remoteAddress, authMethod);\n-        }\n-        return State.Connecting;\n-    }\n-\n-    public void refreshAuthenticationCredentials() {\n-        AuthenticationState authState = this.originalAuthState != null ? originalAuthState : this.authState;\n-\n-        if (authState == null) {\n-            // Authentication is disabled or there's no local state to refresh\n-            return;\n-        } else if (getState() != State.Connected || !isActive) {\n-            // Connection is either still being established or already closed.\n-            return;\n-        } else if (authState != null && !authState.isExpired()) {\n-            // Credentials are still valid. Nothing to do at this point\n-            return;\n-        } else if (originalPrincipal != null && originalAuthState == null) {\n-            log.info(\n-                    \"[{}] Cannot revalidate user credential when using proxy and not forwarding the credentials. Closing connection\",\n-                    remoteAddress);\n-            return;\n-        }\n-\n-        ctx.executor().execute(SafeRun.safeRun(() -> {\n-            log.info(\"[{}] Refreshing authentication credentials for originalPrincipal {} and authRole {}\", remoteAddress, originalPrincipal, this.authRole);\n-\n-            if (!supportsAuthenticationRefresh()) {\n-                log.warn(\"[{}] Closing connection because client doesn't support auth credentials refresh\", remoteAddress);\n-                ctx.close();\n-                return;\n-            }\n-\n-            if (pendingAuthChallengeResponse) {\n-                log.warn(\"[{}] Closing connection after timeout on refreshing auth credentials\", remoteAddress);\n-                ctx.close();\n-                return;\n-            }\n-\n-            try {\n-                AuthData brokerData = authState.refreshAuthentication();\n-\n-                ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, remoteEndpointProtocolVersion));\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] Sent auth challenge to client to refresh credentials with method: {}.\",\n-                        remoteAddress, authMethod);\n-                }\n-\n-                pendingAuthChallengeResponse = true;\n-\n-            } catch (AuthenticationException e) {\n-                log.warn(\"[{}] Failed to refresh authentication: {}\", remoteAddress, e);\n-                ctx.close();\n-            }\n-        }));\n-    }\n-\n-    @Override\n-    protected void handleConnect(CommandConnect connect) {\n-        checkArgument(state == State.Start);\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CONNECT from {}, auth enabled: {}\",\n-                remoteAddress, service.isAuthenticationEnabled());\n-        }\n-\n-        String clientVersion = connect.getClientVersion();\n-        int clientProtocolVersion = connect.getProtocolVersion();\n-        features = connect.getFeatureFlags();\n-\n-        if (!service.isAuthenticationEnabled()) {\n-            completeConnect(clientProtocolVersion, clientVersion);\n-            return;\n-        }\n-\n-        try {\n-            AuthData clientData = AuthData.of(connect.getAuthData().toByteArray());\n-\n-            // init authentication\n-            if (connect.hasAuthMethodName()) {\n-                authMethod = connect.getAuthMethodName();\n-            } else if (connect.hasAuthMethod()) {\n-                // Legacy client is passing enum\n-                authMethod = connect.getAuthMethod().name().substring(10).toLowerCase();\n-            } else {\n-                authMethod = \"none\";\n-            }\n-\n-            authenticationProvider = getBrokerService()\n-                .getAuthenticationService()\n-                .getAuthenticationProvider(authMethod);\n-\n-            // Not find provider named authMethod. Most used for tests.\n-            // In AuthenticationDisabled, it will set authMethod \"none\".\n-            if (authenticationProvider == null) {\n-                authRole = getBrokerService().getAuthenticationService().getAnonymousUserRole()\n-                    .orElseThrow(() ->\n-                        new AuthenticationException(\"No anonymous role, and no authentication provider configured\"));\n-                completeConnect(clientProtocolVersion, clientVersion);\n-                return;\n-            }\n-\n-            // init authState and other var\n-            ChannelHandler sslHandler = ctx.channel().pipeline().get(PulsarChannelInitializer.TLS_HANDLER);\n-            SSLSession sslSession = null;\n-            if (sslHandler != null) {\n-                sslSession = ((SslHandler) sslHandler).engine().getSession();\n-            }\n-\n-            authState = authenticationProvider.newAuthState(clientData, remoteAddress, sslSession);\n-            authenticationData = authState.getAuthDataSource();\n-            state = doAuthentication(clientData, clientProtocolVersion, clientVersion);\n-\n-            // This will fail the check if:\n-            //  1. client is coming through a proxy\n-            //  2. we require to validate the original credentials\n-            //  3. no credentials were passed\n-            if (connect.hasOriginalPrincipal() && service.getPulsar().getConfig().isAuthenticateOriginalAuthData()) {\n-                AuthenticationProvider originalAuthenticationProvider = getBrokerService()\n-                        .getAuthenticationService()\n-                        .getAuthenticationProvider(authMethod);\n-                originalAuthState = originalAuthenticationProvider.newAuthState(\n-                        AuthData.of(connect.getOriginalAuthData().getBytes()),\n-                        remoteAddress,\n-                        sslSession);\n-                originalPrincipal = originalAuthState.getAuthRole();\n-            } else {\n-                originalPrincipal = connect.hasOriginalPrincipal() ? connect.getOriginalPrincipal() : null;\n-            }\n-        } catch (Exception e) {\n-            String msg = \"Unable to authenticate\";\n-            if (e instanceof AuthenticationException) {\n-                log.warn(\"[{}] {}: {}\", remoteAddress, msg, e.getMessage());\n-            } else {\n-                log.warn(\"[{}] {}\", remoteAddress, msg, e);\n-            }\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, msg));\n-            close();\n-        }\n-    }\n-\n-    @Override\n-    protected void handleAuthResponse(CommandAuthResponse authResponse) {\n-        checkArgument(authResponse.hasResponse());\n-        checkArgument(authResponse.getResponse().hasAuthData() && authResponse.getResponse().hasAuthMethodName());\n-\n-        pendingAuthChallengeResponse = false;\n-\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received AuthResponse from {}, auth method: {}\",\n-                remoteAddress, authResponse.getResponse().getAuthMethodName());\n-        }\n-\n-        try {\n-            AuthData clientData = AuthData.of(authResponse.getResponse().getAuthData().toByteArray());\n-            doAuthentication(clientData, authResponse.getProtocolVersion(), authResponse.getClientVersion());\n-        } catch (AuthenticationException e) {\n-            log.warn(\"[{}] Authentication failed: {} \", remoteAddress, e.getMessage());\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, e.getMessage()));\n-            close();\n-        } catch (Exception e) {\n-            String msg = \"Unable to handleAuthResponse\";\n-            log.warn(\"[{}] {} \", remoteAddress, msg, e);\n-            ctx.writeAndFlush(Commands.newError(-1, ServerError.UnknownError, msg));\n-            close();\n-        }\n-    }\n-\n-    @Override\n-    protected void handleSubscribe(final CommandSubscribe subscribe) {\n-        checkArgument(state == State.Connected);\n-        final long requestId = subscribe.getRequestId();\n-        final long consumerId = subscribe.getConsumerId();\n-        TopicName topicName = validateTopicName(subscribe.getTopic(), requestId, subscribe);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        if (invalidOriginalPrincipal(originalPrincipal)) {\n-            final String msg = \"Valid Proxy Client role should be provided while subscribing \";\n-            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                    originalPrincipal, topicName);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            return;\n-        }\n-\n-        final String subscriptionName = subscribe.getSubscription();\n-        final SubType subType = subscribe.getSubType();\n-        final String consumerName = subscribe.getConsumerName();\n-        final boolean isDurable = subscribe.getDurable();\n-        final MessageIdImpl startMessageId = subscribe.hasStartMessageId() ? new BatchMessageIdImpl(\n-                subscribe.getStartMessageId().getLedgerId(), subscribe.getStartMessageId().getEntryId(),\n-                subscribe.getStartMessageId().getPartition(), subscribe.getStartMessageId().getBatchIndex())\n-                : null;\n-        final int priorityLevel = subscribe.hasPriorityLevel() ? subscribe.getPriorityLevel() : 0;\n-        final boolean readCompacted = subscribe.getReadCompacted();\n-        final Map<String, String> metadata = CommandUtils.metadataFromCommand(subscribe);\n-        final InitialPosition initialPosition = subscribe.getInitialPosition();\n-        final long startMessageRollbackDurationSec = subscribe.hasStartMessageRollbackDurationSec()\n-                ? subscribe.getStartMessageRollbackDurationSec()\n-                : -1;\n-        final SchemaData schema = subscribe.hasSchema() ? getSchema(subscribe.getSchema()) : null;\n-        final boolean isReplicated = subscribe.hasReplicateSubscriptionState() && subscribe.getReplicateSubscriptionState();\n-        final boolean forceTopicCreation = subscribe.getForceTopicCreation();\n-        final PulsarApi.KeySharedMeta keySharedMeta = subscribe.hasKeySharedMeta() ? subscribe.getKeySharedMeta() : null;\n-\n-        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-            isProxyAuthorizedFuture = service.getAuthorizationService().canConsumeAsync(topicName, authRole,\n-                    authenticationData, subscribe.getSubscription());\n-        } else {\n-            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-        }\n-        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-            if (isProxyAuthorized) {\n-                CompletableFuture<Boolean> authorizationFuture;\n-                if (service.isAuthorizationEnabled()) {\n-                    authorizationFuture = service.getAuthorizationService().canConsumeAsync(topicName,\n-                            originalPrincipal != null ? originalPrincipal : authRole, authenticationData,\n-                            subscriptionName);\n-                } else {\n-                    authorizationFuture = CompletableFuture.completedFuture(true);\n-                }\n-\n-                authorizationFuture.thenApply(isAuthorized -> {\n-                    if (isAuthorized) {\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"[{}] Client is authorized to subscribe with role {}\", remoteAddress, authRole);\n-                        }\n-\n-                        log.info(\"[{}] Subscribing on topic {} / {}\", remoteAddress, topicName, subscriptionName);\n-                        try {\n-                            Metadata.validateMetadata(metadata);\n-                        } catch (IllegalArgumentException iae) {\n-                            final String msg = iae.getMessage();\n-                            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n-                            return null;\n-                        }\n-                        CompletableFuture<Consumer> consumerFuture = new CompletableFuture<>();\n-                        CompletableFuture<Consumer> existingConsumerFuture = consumers.putIfAbsent(consumerId,\n-                                consumerFuture);\n-\n-                        if (existingConsumerFuture != null) {\n-                            if (existingConsumerFuture.isDone() && !existingConsumerFuture.isCompletedExceptionally()) {\n-                                Consumer consumer = existingConsumerFuture.getNow(null);\n-                                log.info(\"[{}] Consumer with the same id {} is already created: {}\", remoteAddress,\n-                                        consumerId, consumer);\n-                                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-                                return null;\n-                            } else {\n-                                // There was an early request to create a consumer with same consumerId. This can happen\n-                                // when\n-                                // client timeout is lower the broker timeouts. We need to wait until the previous\n-                                // consumer\n-                                // creation request either complete or fails.\n-                                log.warn(\"[{}][{}][{}] Consumer with id {} is already present on the connection\", remoteAddress,\n-                                        topicName, subscriptionName, consumerId);\n-                                ServerError error = null;\n-                                if(!existingConsumerFuture.isDone()) {\n-                                    error = ServerError.ServiceNotReady;\n-                                }else {\n-                                    error = getErrorCode(existingConsumerFuture);\n-                                    consumers.remove(consumerId);\n-                                }\n-                                ctx.writeAndFlush(Commands.newError(requestId, error,\n-                                        \"Consumer is already present on the connection\"));\n-                                return null;\n-                            }\n-                        }\n-\n-                        boolean createTopicIfDoesNotExist = forceTopicCreation\n-                                && service.isAllowAutoTopicCreation(topicName.toString());\n-\n-                        service.getTopic(topicName.toString(), createTopicIfDoesNotExist)\n-                                .thenCompose(optTopic -> {\n-                                    if (!optTopic.isPresent()) {\n-                                        return FutureUtil\n-                                                .failedFuture(new TopicNotFoundException(\"Topic does not exist\"));\n-                                    }\n-\n-                                    Topic topic = optTopic.get();\n-\n-                                    boolean rejectSubscriptionIfDoesNotExist = isDurable\n-                                        && !service.isAllowAutoSubscriptionCreation(topicName.toString())\n-                                        && !topic.getSubscriptions().containsKey(subscriptionName);\n-\n-                                    if (rejectSubscriptionIfDoesNotExist) {\n-                                        return FutureUtil\n-                                            .failedFuture(new SubscriptionNotFoundException(\"Subscription does not exist\"));\n-                                    }\n-\n-                                    if (schema != null) {\n-                                        return topic.addSchemaIfIdleOrCheckCompatible(schema)\n-                                            .thenCompose(v -> topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n-                                                    subType, priorityLevel, consumerName, isDurable,\n-                                                    startMessageId, metadata,\n-                                                    readCompacted, initialPosition, startMessageRollbackDurationSec, isReplicated, keySharedMeta));\n-                                    } else {\n-                                        return topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n-                                            subType, priorityLevel, consumerName, isDurable,\n-                                            startMessageId, metadata, readCompacted, initialPosition,\n-                                            startMessageRollbackDurationSec, isReplicated, keySharedMeta);\n-                                    }\n-                                })\n-                                .thenAccept(consumer -> {\n-                                    if (consumerFuture.complete(consumer)) {\n-                                        log.info(\"[{}] Created subscription on topic {} / {}\", remoteAddress, topicName,\n-                                                subscriptionName);\n-                                        ctx.writeAndFlush(Commands.newSuccess(requestId), ctx.voidPromise());\n-                                    } else {\n-                                        // The consumer future was completed before by a close command\n-                                        try {\n-                                            consumer.close();\n-                                            log.info(\"[{}] Cleared consumer created after timeout on client side {}\",\n-                                                    remoteAddress, consumer);\n-                                        } catch (BrokerServiceException e) {\n-                                            log.warn(\n-                                                    \"[{}] Error closing consumer created after timeout on client side {}: {}\",\n-                                                    remoteAddress, consumer, e.getMessage());\n-                                        }\n-                                        consumers.remove(consumerId, consumerFuture);\n-                                    }\n-\n-                                }) //\n-                                .exceptionally(exception -> {\n-                                    if (exception.getCause() instanceof ConsumerBusyException) {\n-                                        if (log.isDebugEnabled()) {\n-                                            log.debug(\n-                                                    \"[{}][{}][{}] Failed to create consumer because exclusive consumer is already connected: {}\",\n-                                                    remoteAddress, topicName, subscriptionName,\n-                                                    exception.getCause().getMessage());\n-                                        }\n-                                    } else if (exception.getCause() instanceof BrokerServiceException) {\n-                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n-                                                subscriptionName, exception.getCause().getMessage());\n-                                    } else {\n-                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n-                                                subscriptionName, exception.getCause().getMessage(), exception);\n-                                    }\n-\n-                                    // If client timed out, the future would have been completed by subsequent close.\n-                                    // Send error\n-                                    // back to client, only if not completed already.\n-                                    if (consumerFuture.completeExceptionally(exception)) {\n-                                        ctx.writeAndFlush(Commands.newError(requestId,\n-                                                BrokerServiceException.getClientErrorCode(exception),\n-                                                exception.getCause().getMessage()));\n-                                    }\n-                                    consumers.remove(consumerId, consumerFuture);\n-\n-                                    return null;\n-\n-                                });\n-                    } else {\n-                        String msg = \"Client is not authorized to subscribe\";\n-                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n-                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-                    }\n-                    return null;\n-                }).exceptionally(e -> {\n-                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n-                    log.warn(msg);\n-                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n-                    return null;\n-                });\n-            } else {\n-                final String msg = \"Proxy Client is not authorized to subscribe\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            }\n-            return null;\n-        }).exceptionally(ex -> {\n-            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n-            if (ex.getCause() instanceof PulsarServerException) {\n-                log.info(msg);\n-            } else {\n-                log.warn(msg);\n-            }\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    private SchemaData getSchema(PulsarApi.Schema protocolSchema) {\n-        return SchemaData.builder()\n-            .data(protocolSchema.getSchemaData().toByteArray())\n-            .isDeleted(false)\n-            .timestamp(System.currentTimeMillis())\n-            .user(Strings.nullToEmpty(originalPrincipal))\n-            .type(Commands.getSchemaType(protocolSchema.getType()))\n-            .props(protocolSchema.getPropertiesList().stream().collect(\n-                Collectors.toMap(\n-                    PulsarApi.KeyValue::getKey,\n-                    PulsarApi.KeyValue::getValue\n-                )\n-            )).build();\n-    }\n-\n-    @Override\n-    protected void handleProducer(final CommandProducer cmdProducer) {\n-        checkArgument(state == State.Connected);\n-        final long producerId = cmdProducer.getProducerId();\n-        final long requestId = cmdProducer.getRequestId();\n-        // Use producer name provided by client if present\n-        final String producerName = cmdProducer.hasProducerName() ? cmdProducer.getProducerName()\n-                : service.generateUniqueProducerName();\n-        final long epoch = cmdProducer.getEpoch();\n-        final boolean userProvidedProducerName = cmdProducer.getUserProvidedProducerName();\n-        final boolean isEncrypted = cmdProducer.getEncrypted();\n-        final Map<String, String> metadata = CommandUtils.metadataFromCommand(cmdProducer);\n-        final SchemaData schema = cmdProducer.hasSchema() ? getSchema(cmdProducer.getSchema()) : null;\n-\n-        TopicName topicName = validateTopicName(cmdProducer.getTopic(), requestId, cmdProducer);\n-        if (topicName == null) {\n-            return;\n-        }\n-\n-        if (invalidOriginalPrincipal(originalPrincipal)) {\n-            final String msg = \"Valid Proxy Client role should be provided while creating producer \";\n-            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n-                    originalPrincipal, topicName);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            return;\n-        }\n-\n-        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n-        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n-            isProxyAuthorizedFuture = service.getAuthorizationService().canProduceAsync(topicName,\n-                    authRole, authenticationData);\n-        } else {\n-            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n-        }\n-        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n-            if (isProxyAuthorized) {\n-                CompletableFuture<Boolean> authorizationFuture;\n-                if (service.isAuthorizationEnabled()) {\n-                    authorizationFuture = service.getAuthorizationService().canProduceAsync(topicName,\n-                            originalPrincipal != null ? originalPrincipal : authRole, authenticationData);\n-                } else {\n-                    authorizationFuture = CompletableFuture.completedFuture(true);\n-                }\n-\n-                authorizationFuture.thenApply(isAuthorized -> {\n-                    if (isAuthorized) {\n-                        if (log.isDebugEnabled()) {\n-                            log.debug(\"[{}] Client is authorized to Produce with role {}\", remoteAddress, authRole);\n-                        }\n-                        CompletableFuture<Producer> producerFuture = new CompletableFuture<>();\n-                        CompletableFuture<Producer> existingProducerFuture = producers.putIfAbsent(producerId,\n-                                producerFuture);\n-\n-                        if (existingProducerFuture != null) {\n-                            if (existingProducerFuture.isDone() && !existingProducerFuture.isCompletedExceptionally()) {\n-                                Producer producer = existingProducerFuture.getNow(null);\n-                                log.info(\"[{}] Producer with the same id {} is already created: {}\", remoteAddress,\n-                                        producerId, producer);\n-                                ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producer.getProducerName(),\n-                                    producer.getSchemaVersion()));\n-                                return null;\n-                            } else {\n-                                // There was an early request to create a producer with\n-                                // same producerId. This can happen when\n-                                // client\n-                                // timeout is lower the broker timeouts. We need to wait\n-                                // until the previous producer creation\n-                                // request\n-                                // either complete or fails.\n-                                ServerError error = null;\n-                                if(!existingProducerFuture.isDone()) {\n-                                    error = ServerError.ServiceNotReady;\n-                                }else {\n-                                    error = getErrorCode(existingProducerFuture);\n-                                    // remove producer with producerId as it's already completed with exception\n-                                    producers.remove(producerId);\n-                                }\n-                                log.warn(\"[{}][{}] Producer with id {} is already present on the connection\", remoteAddress,\n-                                        producerId, topicName);\n-                                ctx.writeAndFlush(Commands.newError(requestId, error,\n-                                        \"Producer is already present on the connection\"));\n-                                return null;\n-                            }\n-                        }\n-\n-                        log.info(\"[{}][{}] Creating producer. producerId={}\", remoteAddress, topicName, producerId);\n-\n-                        service.getOrCreateTopic(topicName.toString()).thenAccept((Topic topic) -> {\n-                            // Before creating producer, check if backlog quota exceeded\n-                            // on topic\n-                            if (topic.isBacklogQuotaExceeded(producerName)) {\n-                                IllegalStateException illegalStateException = new IllegalStateException(\n-                                        \"Cannot create producer on topic with backlog quota exceeded\");\n-                                BacklogQuota.RetentionPolicy retentionPolicy = topic.getBacklogQuota().getPolicy();\n-                                if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold) {\n-                                    ctx.writeAndFlush(\n-                                            Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededError,\n-                                                    illegalStateException.getMessage()));\n-                                } else if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception) {\n-                                    ctx.writeAndFlush(Commands.newError(requestId,\n-                                            ServerError.ProducerBlockedQuotaExceededException,\n-                                            illegalStateException.getMessage()));\n-                                }\n-                                producerFuture.completeExceptionally(illegalStateException);\n-                                producers.remove(producerId, producerFuture);\n-                                return;\n-                            }\n \n-                            // Check whether the producer will publish encrypted messages or not\n-                            if (topic.isEncryptionRequired() && !isEncrypted) {\n-                                String msg = String.format(\"Encryption is required in %s\", topicName);\n-                                log.warn(\"[{}] {}\", remoteAddress, msg);\n-                                ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n-                                producers.remove(producerId, producerFuture);\n-                                return;\n-                            }\n-\n-                            disableTcpNoDelayIfNeeded(topicName.toString(), producerName);\n-\n-                            CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n-\n-                            schemaVersionFuture.exceptionally(exception -> {\n-                                ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(exception),\n-                                        exception.getMessage()));\n-                                producers.remove(producerId, producerFuture);\n-                                return null;\n-                            });\n-\n-                            schemaVersionFuture.thenAccept(schemaVersion -> {\n-                                Producer producer = new Producer(topic, ServerCnx.this, producerId, producerName, authRole,\n-                                    isEncrypted, metadata, schemaVersion, epoch, userProvidedProducerName);\n-\n-                                try {\n-                                    topic.addProducer(producer);\n-\n-                                    if (isActive()) {\n-                                        if (producerFuture.complete(producer)) {\n-                                            log.info(\"[{}] Created new producer: {}\", remoteAddress, producer);\n-                                            ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producerName,\n-                                                producer.getLastSequenceId(), producer.getSchemaVersion()));\n-                                            return;\n-                                        } else {\n-                                            // The producer's future was completed before by\n-                                            // a close command\n-                                            producer.closeNow(true);\n-                                            log.info(\"[{}] Cleared producer created after timeout on client side {}\",\n-                                                remoteAddress, producer);\n-                                        }\n-                                    } else {\n-                                        producer.closeNow(true);\n-                                        log.info(\"[{}] Cleared producer created after connection was closed: {}\",\n-                                            remoteAddress, producer);\n-                                        producerFuture.completeExceptionally(\n-                                            new IllegalStateException(\"Producer created after connection was closed\"));\n-                                    }\n-                                } catch (BrokerServiceException ise) {\n-                                    log.error(\"[{}] Failed to add producer to topic {}: {}\", remoteAddress, topicName,\n-                                        ise.getMessage());\n-                                    ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(ise), ise.getMessage()));\n-                                    producerFuture.completeExceptionally(ise);\n-                                }\n-\n-                                producers.remove(producerId, producerFuture);\n-                            });\n-                        }).exceptionally(exception -> {\n-                            Throwable cause = exception.getCause();\n-                            if (!(cause instanceof ServiceUnitNotReadyException)) {\n-                                // Do not print stack traces for expected exceptions\n-                                log.error(\"[{}] Failed to create topic {}\", remoteAddress, topicName, exception);\n-                            }\n-\n-                            // If client timed out, the future would have been completed\n-                            // by subsequent close. Send error back to\n-                            // client, only if not completed already.\n-                            if (producerFuture.completeExceptionally(exception)) {\n-                                ctx.writeAndFlush(Commands.newError(requestId,\n-                                        BrokerServiceException.getClientErrorCode(cause), cause.getMessage()));\n-                            }\n-                            producers.remove(producerId, producerFuture);\n-\n-                            return null;\n-                        });\n-                    } else {\n-                        String msg = \"Client is not authorized to Produce\";\n-                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n-                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-                    }\n-                    return null;\n-                }).exceptionally(e -> {\n-                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n-                    log.warn(msg);\n-                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n-                    return null;\n-                });\n-            } else {\n-                final String msg = \"Proxy Client is not authorized to Produce\";\n-                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n-            }\n-            return null;\n-        }).exceptionally(ex -> {\n-            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n-            log.warn(msg);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleSend(CommandSend send, ByteBuf headersAndPayload) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Producer> producerFuture = producers.get(send.getProducerId());\n-\n-        if (producerFuture == null || !producerFuture.isDone() || producerFuture.isCompletedExceptionally()) {\n-            log.warn(\"[{}] Producer had already been closed: {}\", remoteAddress, send.getProducerId());\n-            return;\n-        }\n-\n-        Producer producer = producerFuture.getNow(null);\n-        if (log.isDebugEnabled()) {\n-            printSendCommandDebug(send, headersAndPayload);\n-        }\n-\n-        if (producer.isNonPersistentTopic()) {\n-            // avoid processing non-persist message if reached max concurrent-message limit\n-            if (nonPersistentPendingMessages > MaxNonPersistentPendingMessages) {\n-                final long producerId = send.getProducerId();\n-                final long sequenceId = send.getSequenceId();\n-                final long highestSequenceId = send.getHighestSequenceId();\n-                service.getTopicOrderedExecutor().executeOrdered(producer.getTopic().getName(), SafeRun.safeRun(() -> {\n-                    ctx.writeAndFlush(Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, -1, -1), ctx.voidPromise());\n-                }));\n-                producer.recordMessageDrop(send.getNumMessages());\n-                return;\n-            } else {\n-                nonPersistentPendingMessages++;\n-            }\n-        }\n-\n-        startSendOperation(producer, headersAndPayload.readableBytes());\n-\n-        // Persist the message\n-        if (send.hasHighestSequenceId() && send.getSequenceId() <= send.getHighestSequenceId()) {\n-            producer.publishMessage(send.getProducerId(), send.getSequenceId(), send.getHighestSequenceId(),\n-                    headersAndPayload, send.getNumMessages());\n-        } else {\n-            producer.publishMessage(send.getProducerId(), send.getSequenceId(), headersAndPayload, send.getNumMessages());\n-        }\n-    }\n-\n-    private void printSendCommandDebug(CommandSend send, ByteBuf headersAndPayload) {\n-        headersAndPayload.markReaderIndex();\n-        MessageMetadata msgMetadata = Commands.parseMessageMetadata(headersAndPayload);\n-        headersAndPayload.resetReaderIndex();\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received send message request. producer: {}:{} {}:{} size: {}, partition key is: {}, ordering key is {}\",\n-                    remoteAddress, send.getProducerId(), send.getSequenceId(), msgMetadata.getProducerName(), msgMetadata.getSequenceId(),\n-                    headersAndPayload.readableBytes(), msgMetadata.getPartitionKey(), msgMetadata.getOrderingKey());\n-        }\n-        msgMetadata.recycle();\n-    }\n-\n-    @Override\n-    protected void handleAck(CommandAck ack) {\n-        checkArgument(state == State.Connected);\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(ack.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            consumerFuture.getNow(null).messageAcked(ack);\n-        }\n-    }\n-\n-    @Override\n-    protected void handleFlow(CommandFlow flow) {\n-        checkArgument(state == State.Connected);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received flow from consumer {} permits: {}\", remoteAddress, flow.getConsumerId(),\n-                    flow.getMessagePermits());\n-        }\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(flow.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            if (consumer != null) {\n-                consumer.flowPermits(flow.getMessagePermits());\n-            } else {\n-                log.info(\"[{}] Couldn't find consumer {}\", remoteAddress, flow.getConsumerId());\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void handleRedeliverUnacknowledged(CommandRedeliverUnacknowledgedMessages redeliver) {\n-        checkArgument(state == State.Connected);\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Received Resend Command from consumer {} \", remoteAddress, redeliver.getConsumerId());\n-        }\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(redeliver.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            if (redeliver.getMessageIdsCount() > 0 && Subscription.isIndividualAckMode(consumer.subType())) {\n-                consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());\n-            } else {\n-                consumer.redeliverUnacknowledgedMessages();\n-            }\n-        }\n-    }\n-\n-    @Override\n-    protected void handleUnsubscribe(CommandUnsubscribe unsubscribe) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(unsubscribe.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            consumerFuture.getNow(null).doUnsubscribe(unsubscribe.getRequestId());\n-        } else {\n-            ctx.writeAndFlush(\n-                    Commands.newError(unsubscribe.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleSeek(CommandSeek seek) {\n-        checkArgument(state == State.Connected);\n-        final long requestId = seek.getRequestId();\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(seek.getConsumerId());\n-\n-        if (!seek.hasMessageId() && !seek.hasMessagePublishTime()) {\n-            ctx.writeAndFlush(\n-                    Commands.newError(requestId, ServerError.MetadataError, \"Message id and message publish time were not present\"));\n-            return;\n-        }\n-\n-        boolean consumerCreated = consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally();\n-\n-        if (consumerCreated && seek.hasMessageId()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            Subscription subscription = consumer.getSubscription();\n-            MessageIdData msgIdData = seek.getMessageId();\n-\n-            Position position = new PositionImpl(msgIdData.getLedgerId(), msgIdData.getEntryId());\n-\n-\n-            subscription.resetCursor(position).thenRun(() -> {\n-                log.info(\"[{}] [{}][{}] Reset subscription to message id {}\", remoteAddress,\n-                        subscription.getTopic().getName(), subscription.getName(), position);\n-                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            }).exceptionally(ex -> {\n-                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                        \"Error when resetting subscription: \" + ex.getCause().getMessage()));\n-                return null;\n-            });\n-        } else if (consumerCreated && seek.hasMessagePublishTime()){\n-            Consumer consumer = consumerFuture.getNow(null);\n-            Subscription subscription = consumer.getSubscription();\n-            long timestamp = seek.getMessagePublishTime();\n-\n-            subscription.resetCursor(timestamp).thenRun(() -> {\n-                log.info(\"[{}] [{}][{}] Reset subscription to publish time {}\", remoteAddress,\n-                        subscription.getTopic().getName(), subscription.getName(), timestamp);\n-                ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            }).exceptionally(ex -> {\n-                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n-                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                        \"Reset subscription to publish time error: \" + ex.getCause().getMessage()));\n-                return null;\n-            });\n-        } else {\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleCloseProducer(CommandCloseProducer closeProducer) {\n-        checkArgument(state == State.Connected);\n-\n-        final long producerId = closeProducer.getProducerId();\n-        final long requestId = closeProducer.getRequestId();\n-\n-        CompletableFuture<Producer> producerFuture = producers.get(producerId);\n-        if (producerFuture == null) {\n-            log.warn(\"[{}] Producer {} was not registered on the connection\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n-                    \"Producer was not registered on the connection\"));\n-            return;\n-        }\n-\n-        if (!producerFuture.isDone() && producerFuture\n-                .completeExceptionally(new IllegalStateException(\"Closed producer before creation was complete\"))) {\n-            // We have received a request to close the producer before it was actually completed, we have marked the\n-            // producer future as failed and we can tell the client the close operation was successful.\n-            log.info(\"[{}] Closed producer {} before its creation was completed\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-            return;\n-        } else if (producerFuture.isCompletedExceptionally()) {\n-            log.info(\"[{}] Closed producer {} that already failed to be created\", remoteAddress, producerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-            return;\n-        }\n-\n-        // Proceed with normal close, the producer\n-        Producer producer = producerFuture.getNow(null);\n-        log.info(\"[{}][{}] Closing producer on cnx {}\", producer.getTopic(), producer.getProducerName(), remoteAddress);\n-\n-        producer.close(true).thenAccept(v -> {\n-            log.info(\"[{}][{}] Closed producer on cnx {}\", producer.getTopic(), producer.getProducerName(),\n-                    remoteAddress);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            producers.remove(producerId, producerFuture);\n-        });\n-    }\n-\n-    @Override\n-    protected void handleCloseConsumer(CommandCloseConsumer closeConsumer) {\n-        checkArgument(state == State.Connected);\n-        log.info(\"[{}] Closing consumer: {}\", remoteAddress, closeConsumer.getConsumerId());\n-\n-        long requestId = closeConsumer.getRequestId();\n-        long consumerId = closeConsumer.getConsumerId();\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n-        if (consumerFuture == null) {\n-            log.warn(\"[{}] Consumer was not registered on the connection: {}\", consumerId, remoteAddress);\n-            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n-            return;\n-        }\n-\n-        if (!consumerFuture.isDone() && consumerFuture\n-                .completeExceptionally(new IllegalStateException(\"Closed consumer before creation was complete\"))) {\n-            // We have received a request to close the consumer before it was actually completed, we have marked the\n-            // consumer future as failed and we can tell the client the close operation was successful. When the actual\n-            // create operation will complete, the new consumer will be discarded.\n-            log.info(\"[{}] Closed consumer {} before its creation was completed\", remoteAddress, consumerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            return;\n-        }\n-\n-        if (consumerFuture.isCompletedExceptionally()) {\n-            log.info(\"[{}] Closed consumer {} that already failed to be created\", remoteAddress, consumerId);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            return;\n-        }\n-\n-        // Proceed with normal consumer close\n-        Consumer consumer = consumerFuture.getNow(null);\n-        try {\n-            consumer.close();\n-            consumers.remove(consumerId, consumerFuture);\n-            ctx.writeAndFlush(Commands.newSuccess(requestId));\n-            log.info(\"[{}] Closed consumer {}\", remoteAddress, consumer);\n-        } catch (BrokerServiceException e) {\n-            log.warn(\"[{]] Error closing consumer {} : {}\", remoteAddress, consumer, e);\n-            ctx.writeAndFlush(\n-                    Commands.newError(requestId, BrokerServiceException.getClientErrorCode(e), e.getMessage()));\n-        }\n-    }\n-\n-    @Override\n-    protected void handleGetLastMessageId(CommandGetLastMessageId getLastMessageId) {\n-        checkArgument(state == State.Connected);\n-\n-        CompletableFuture<Consumer> consumerFuture = consumers.get(getLastMessageId.getConsumerId());\n-\n-        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n-            Consumer consumer = consumerFuture.getNow(null);\n-            long requestId = getLastMessageId.getRequestId();\n-\n-            Topic topic = consumer.getSubscription().getTopic();\n-            Position position = topic.getLastPosition();\n-            int partitionIndex = TopicName.getPartitionIndex(topic.getName());\n-\n-            getLargestBatchIndexWhenPossible(\n-                    topic,\n-                    (PositionImpl) position,\n-                    partitionIndex,\n-                    requestId,\n-                    consumer.getSubscription().getName());\n-\n-        } else {\n-            ctx.writeAndFlush(Commands.newError(getLastMessageId.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n-        }\n-    }\n-\n-    private void getLargestBatchIndexWhenPossible(\n-            Topic topic,\n-            PositionImpl position,\n-            int partitionIndex,\n-            long requestId,\n-            String subscriptionName) {\n-\n-        PersistentTopic persistentTopic = (PersistentTopic) topic;\n-        ManagedLedgerImpl ml = (ManagedLedgerImpl) persistentTopic.getManagedLedger();\n-\n-        // If it's not pointing to a valid entry, respond messageId of the current position.\n-        if (position.getEntryId() == -1) {\n-            MessageIdData messageId = MessageIdData.newBuilder()\n-                    .setLedgerId(position.getLedgerId())\n-                    .setEntryId(position.getEntryId())\n-                    .setPartition(partitionIndex).build();\n-\n-            ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n-        }\n-\n-        // For a valid position, we read the entry out and parse the batch size from its metadata.\n-        CompletableFuture<Entry> entryFuture = new CompletableFuture<>();\n-        ml.asyncReadEntry(position, new AsyncCallbacks.ReadEntryCallback() {\n-            @Override\n-            public void readEntryComplete(Entry entry, Object ctx) {\n-                entryFuture.complete(entry);\n-            }\n-\n-            @Override\n-            public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n-                entryFuture.completeExceptionally(exception);\n-            }\n-        }, null);\n-\n-        CompletableFuture<Integer> batchSizeFuture = entryFuture.thenApply(entry -> {\n-            MessageMetadata metadata = Commands.parseMessageMetadata(entry.getDataBuffer());\n-            int batchSize = metadata.getNumMessagesInBatch();\n-            entry.release();\n-            return batchSize;\n-        });\n-\n-        batchSizeFuture.whenComplete((batchSize, e) -> {\n-            if (e != null) {\n-                ctx.writeAndFlush(Commands.newError(\n-                        requestId, ServerError.MetadataError, \"Failed to get batch size for entry \" + e.getMessage()));\n-            } else {\n-                int largestBatchIndex = batchSize > 1 ? batchSize - 1 : -1;\n-\n-                if (log.isDebugEnabled()) {\n-                    log.debug(\"[{}] [{}][{}] Get LastMessageId {} partitionIndex {}\", remoteAddress,\n-                            topic.getName(), subscriptionName, position, partitionIndex);\n-                }\n-\n-                MessageIdData messageId = MessageIdData.newBuilder()\n-                        .setLedgerId(position.getLedgerId())\n-                        .setEntryId(position.getEntryId())\n-                        .setPartition(partitionIndex)\n-                        .setBatchIndex(largestBatchIndex).build();\n-\n-                ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n-            }\n-        });\n-    }\n-\n-    @Override\n-    protected void handleGetTopicsOfNamespace(CommandGetTopicsOfNamespace commandGetTopicsOfNamespace) {\n-        final long requestId = commandGetTopicsOfNamespace.getRequestId();\n-        final String namespace = commandGetTopicsOfNamespace.getNamespace();\n-        final CommandGetTopicsOfNamespace.Mode mode = commandGetTopicsOfNamespace.getMode();\n-        final NamespaceName namespaceName = NamespaceName.get(namespace);\n-\n-        getBrokerService().pulsar().getNamespaceService().getListOfTopics(namespaceName, mode)\n-                .thenAccept(topics -> {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"[{}] Received CommandGetTopicsOfNamespace for namespace [//{}] by {}, size:{}\",\n-                                remoteAddress, namespace, requestId, topics.size());\n-                    }\n-\n-                    ctx.writeAndFlush(Commands.newGetTopicsOfNamespaceResponse(topics, requestId));\n-                })\n-                .exceptionally(ex -> {\n-                    log.warn(\"[{}] Error GetTopicsOfNamespace for namespace [//{}] by {}\",\n-                            remoteAddress, namespace, requestId);\n-                    ctx.writeAndFlush(\n-                            Commands.newError(requestId,\n-                                    BrokerServiceException.getClientErrorCode(new ServerMetadataException(ex)),\n-                                    ex.getMessage()));\n-\n-                    return null;\n-                });\n-    }\n-\n-    @Override\n-    protected void handleGetSchema(CommandGetSchema commandGetSchema) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandGetSchema call from {}, schemaVersion: {}, topic: {}, requestId: {}\",\n-                    remoteAddress, new String(commandGetSchema.getSchemaVersion().toByteArray()),\n-                    commandGetSchema.getTopic(), commandGetSchema.getRequestId());\n-        }\n-\n-        long requestId = commandGetSchema.getRequestId();\n-        SchemaVersion schemaVersion = SchemaVersion.Latest;\n-        if (commandGetSchema.hasSchemaVersion()) {\n-            schemaVersion = schemaService.versionFromBytes(commandGetSchema.getSchemaVersion().toByteArray());\n-        }\n-\n-        String schemaName;\n-        try {\n-            schemaName = TopicName.get(commandGetSchema.getTopic()).getSchemaName();\n-        } catch (Throwable t) {\n-            ctx.writeAndFlush(\n-                    Commands.newGetSchemaResponseError(requestId, ServerError.InvalidTopicName, t.getMessage()));\n-            return;\n-        }\n-\n-        schemaService.getSchema(schemaName, schemaVersion).thenAccept(schemaAndMetadata -> {\n-            if (schemaAndMetadata == null) {\n-                ctx.writeAndFlush(Commands.newGetSchemaResponseError(requestId, ServerError.TopicNotFound,\n-                        \"Topic not found or no-schema\"));\n-            } else {\n-                ctx.writeAndFlush(Commands.newGetSchemaResponse(requestId,\n-                        SchemaInfoUtil.newSchemaInfo(schemaName, schemaAndMetadata.schema), schemaAndMetadata.version));\n-            }\n-        }).exceptionally(ex -> {\n-            ctx.writeAndFlush(\n-                    Commands.newGetSchemaResponseError(requestId, ServerError.UnknownError, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleGetOrCreateSchema(CommandGetOrCreateSchema commandGetOrCreateSchema) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Received CommandGetOrCreateSchema call from {}\", remoteAddress);\n-        }\n-        long requestId = commandGetOrCreateSchema.getRequestId();\n-        String topicName = commandGetOrCreateSchema.getTopic();\n-        SchemaData schemaData = getSchema(commandGetOrCreateSchema.getSchema());\n-        SchemaData schema = schemaData.getType() == SchemaType.NONE ? null : schemaData;\n-        service.getTopicIfExists(topicName).thenAccept(topicOpt -> {\n-            if (topicOpt.isPresent()) {\n-                Topic topic = topicOpt.get();\n-                CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n-                schemaVersionFuture.exceptionally(ex -> {\n-                    ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n-                    ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                            requestId, errorCode, ex.getMessage()));\n-                    return null;\n-                }).thenAccept(schemaVersion -> {\n-                        ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponse(\n-                                requestId, schemaVersion));\n-                });\n-            } else {\n-                ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                        requestId, ServerError.TopicNotFound, \"Topic not found\"));\n-            }\n-        }).exceptionally(ex -> {\n-            ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n-            ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n-                    requestId, errorCode, ex.getMessage()));\n-            return null;\n-        });\n-    }\n-\n-    @Override\n-    protected void handleNewTxn(CommandNewTxn command) {\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive new txn request {} to transaction meta store {} from {}.\", command.getRequestId(), command.getTcId(), remoteAddress);\n-        }\n-        TransactionCoordinatorID tcId = TransactionCoordinatorID.get(command.getTcId());\n-        service.pulsar().getTransactionMetadataStoreService().newTransaction(tcId)\n-            .whenComplete(((txnID, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response {} for new txn request {}\", tcId.getId(),  command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for new txn request {}\", command.getRequestId(), ex);\n-                    }\n-                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), tcId.getId(), BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            }));\n-    }\n-\n-    @Override\n-    protected void handleAddPartitionToTxn(PulsarApi.CommandAddPartitionToTxn command) {\n-        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive add published partition to txn request {} from {} with txnId {}\", command.getRequestId(), remoteAddress, txnID);\n-        }\n-        service.pulsar().getTransactionMetadataStoreService().addProducedPartitionToTxn(txnID, command.getPartitionsList())\n-            .whenComplete(((v, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response success for add published partition to txn request {}\",  command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(),\n-                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for add published partition to txn request {}\",  command.getRequestId(), ex);\n-                    }\n-                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n-                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            }));\n-    }\n-\n-    @Override\n-    protected void handleEndTxn(PulsarApi.CommandEndTxn command) {\n-        TxnStatus newStatus = null;\n-        switch (command.getTxnAction()) {\n-            case COMMIT:\n-                newStatus = TxnStatus.COMMITTING;\n-                break;\n-            case ABORT:\n-                newStatus = TxnStatus.ABORTING;\n-                break;\n-        }\n-        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"Receive end txn by {} request {} from {} with txnId {}\", newStatus, command.getRequestId(), remoteAddress, txnID);\n-        }\n-        service.pulsar().getTransactionMetadataStoreService().updateTxnStatus(txnID, newStatus, TxnStatus.OPEN)\n-            .whenComplete((v, ex) -> {\n-                if (ex == null) {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response success for end txn request {}\", command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(),\n-                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n-                } else {\n-                    if (log.isDebugEnabled()) {\n-                        log.debug(\"Send response error for end txn request {}\", command.getRequestId());\n-                    }\n-                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n-                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n-                }\n-            });\n-    }\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n \n-    private CompletableFuture<SchemaVersion> tryAddSchema(Topic topic, SchemaData schema) {\n-        if (schema != null) {\n-            return topic.addSchema(schema);\n-        } else {\n-            return topic.hasSchema().thenCompose((hasSchema) -> {\n-                log.info(\"[{}] {} configured with schema {}\",\n-                         remoteAddress, topic.getName(), hasSchema);\n-                CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n-                if (hasSchema && (schemaValidationEnforced || topic.getSchemaValidationEnforced())) {\n-                    result.completeExceptionally(new IncompatibleSchemaException(\n-                            \"Producers cannot connect or send message without a schema to topics with a schema\"));\n-                } else {\n-                    result.complete(SchemaVersion.Empty);\n-                }\n-                return result;\n-            });\n-        }\n-    }\n+public interface ServerCnx {\n \n-    @Override\n-    protected boolean isHandshakeCompleted() {\n-        return state == State.Connected;\n+    default String getClientVersion() {\n+        return null;\n     }\n \n-    ChannelHandlerContext ctx() {\n-        return ctx;\n-    }\n+    SocketAddress clientAddress();\n \n-    public void closeProducer(Producer producer) {\n-        // removes producer-connection from map and send close command to producer\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n-        }\n-        long producerId = producer.getProducerId();\n-        producers.remove(producerId);\n-        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n-            ctx.writeAndFlush(Commands.newCloseProducer(producerId, -1L));\n-        } else {\n-            close();\n-        }\n+    BrokerService getBrokerService();\n \n-    }\n-\n-    public void closeConsumer(Consumer consumer) {\n-        // removes consumer-connection from map and send close command to consumer\n-        if (log.isDebugEnabled()) {\n-            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n-        }\n-        long consumerId = consumer.consumerId();\n-        consumers.remove(consumerId);\n-        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n-            ctx.writeAndFlush(Commands.newCloseConsumer(consumerId, -1L));\n-        } else {\n-            close();\n-        }\n+    default boolean isBatchMessageCompatibleVersion() {\n+        return true;\n     }\n \n     /**\n-     * It closes the connection with client which triggers {@code channelInactive()} which clears all producers and\n-     * consumers from connection-map\n+     * The security role for this connection\n+     * @return the role\n      */\n-    protected void close() {\n-        ctx.close();\n+    default String getRole() {\n+        return null;\n     }\n \n-    public SocketAddress clientAddress() {\n-        return remoteAddress;\n+    default AuthenticationDataSource getAuthenticationData() {\n+        return null;", "originalCommit": "70f7da54e7c130171b53e41bbbf60ff9f966f1c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "551eb5a7180d9446f86d1c7eea9d2f97b02e97ce", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\nindex ae01f3f3b55..ce870485d8a 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n\n@@ -18,119 +18,2099 @@\n  */\n package org.apache.pulsar.broker.service;\n \n-import org.apache.bookkeeper.mledger.Entry;\n-import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n-import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+import static org.apache.pulsar.broker.admin.impl.PersistentTopicsBase.getPartitionedTopicMetadata;\n+import static org.apache.pulsar.broker.lookup.TopicLookupBase.lookupTopicAsync;\n+import static org.apache.pulsar.common.protocol.Commands.newLookupErrorResponse;\n+import static org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion.v5;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOption;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.ssl.SslHandler;\n \n import java.net.SocketAddress;\n+\n import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLongFieldUpdater;\n+import java.util.stream.Collectors;\n+\n+import javax.naming.AuthenticationException;\n+import javax.net.ssl.SSLSession;\n+\n+import org.apache.bookkeeper.mledger.AsyncCallbacks;\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.bookkeeper.mledger.ManagedLedgerException;\n+import org.apache.bookkeeper.mledger.Position;\n+import org.apache.bookkeeper.mledger.impl.ManagedLedgerImpl;\n+import org.apache.bookkeeper.mledger.impl.PositionImpl;\n+import org.apache.bookkeeper.mledger.util.SafeRun;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.exception.ExceptionUtils;\n+import org.apache.pulsar.broker.PulsarServerException;\n+import org.apache.pulsar.broker.PulsarService;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataCommand;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n+import org.apache.pulsar.broker.authentication.AuthenticationProvider;\n+import org.apache.pulsar.broker.authentication.AuthenticationState;\n+import org.apache.pulsar.broker.service.BrokerServiceException.ConsumerBusyException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.ServerMetadataException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.ServiceUnitNotReadyException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.SubscriptionNotFoundException;\n+import org.apache.pulsar.broker.service.BrokerServiceException.TopicNotFoundException;\n+import org.apache.pulsar.broker.service.persistent.PersistentTopic;\n+import org.apache.pulsar.broker.service.schema.exceptions.IncompatibleSchemaException;\n+import org.apache.pulsar.broker.service.schema.SchemaRegistryService;\n+import org.apache.pulsar.broker.web.RestException;\n+import org.apache.pulsar.client.api.PulsarClientException;\n+import org.apache.pulsar.client.impl.BatchMessageIdImpl;\n+import org.apache.pulsar.client.impl.ClientCnx;\n+import org.apache.pulsar.client.impl.MessageIdImpl;\n+import org.apache.pulsar.common.api.AuthData;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandNewTxn;\n+import org.apache.pulsar.common.policies.data.TopicOperation;\n+import org.apache.pulsar.common.protocol.CommandUtils;\n+import org.apache.pulsar.common.protocol.Commands;\n+import org.apache.pulsar.common.protocol.PulsarHandler;\n+import org.apache.pulsar.common.api.proto.PulsarApi;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAck;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandAuthResponse;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseConsumer;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandCloseProducer;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandConnect;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStats;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandConsumerStatsResponse;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandFlow;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetLastMessageId;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetSchema;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetOrCreateSchema;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandGetTopicsOfNamespace;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandLookupTopic;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandPartitionedTopicMetadata;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandProducer;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandRedeliverUnacknowledgedMessages;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSeek;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSend;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.InitialPosition;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandSubscribe.SubType;\n+import org.apache.pulsar.common.api.proto.PulsarApi.CommandUnsubscribe;\n+import org.apache.pulsar.common.api.proto.PulsarApi.FeatureFlags;\n+import org.apache.pulsar.common.api.proto.PulsarApi.MessageIdData;\n+import org.apache.pulsar.common.api.proto.PulsarApi.MessageMetadata;\n+import org.apache.pulsar.common.api.proto.PulsarApi.ProtocolVersion;\n+import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n+import org.apache.pulsar.common.naming.Metadata;\n+import org.apache.pulsar.common.naming.NamespaceName;\n+import org.apache.pulsar.common.naming.TopicName;\n+import org.apache.pulsar.common.policies.data.BacklogQuota;\n+import org.apache.pulsar.common.policies.data.ConsumerStats;\n+import org.apache.pulsar.common.protocol.schema.SchemaData;\n+import org.apache.pulsar.common.protocol.schema.SchemaInfoUtil;\n+import org.apache.pulsar.common.protocol.schema.SchemaVersion;\n+import org.apache.pulsar.common.schema.SchemaType;\n+import org.apache.pulsar.common.util.FutureUtil;\n+import org.apache.pulsar.common.util.collections.ConcurrentLongHashMap;\n+import org.apache.pulsar.shaded.com.google.protobuf.v241.GeneratedMessageLite;\n+import org.apache.pulsar.transaction.coordinator.TransactionCoordinatorID;\n+import org.apache.pulsar.transaction.impl.common.TxnID;\n+import org.apache.pulsar.transaction.impl.common.TxnStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ServerCnx extends PulsarHandler implements TransportCnx {\n+    private final BrokerService service;\n+    private final SchemaRegistryService schemaService;\n+    private final ConcurrentLongHashMap<CompletableFuture<Producer>> producers;\n+    private final ConcurrentLongHashMap<CompletableFuture<Consumer>> consumers;\n+    private State state;\n+    private volatile boolean isActive = true;\n+    String authRole = null;\n+    AuthenticationDataSource authenticationData;\n+    AuthenticationProvider authenticationProvider;\n+    AuthenticationState authState;\n+    // In case of proxy, if the authentication credentials are forwardable,\n+    // it will hold the credentials of the original client\n+    AuthenticationState originalAuthState;\n+    private boolean pendingAuthChallengeResponse = false;\n+\n+    // Max number of pending requests per connections. If multiple producers are sharing the same connection the flow\n+    // control done by a single producer might not be enough to prevent write spikes on the broker.\n+    private final int maxPendingSendRequests;\n+    private final int resumeReadsThreshold;\n+    private int pendingSendRequest = 0;\n+    private final String replicatorPrefix;\n+    private String clientVersion = null;\n+    private int nonPersistentPendingMessages = 0;\n+    private final int MaxNonPersistentPendingMessages;\n+    private String originalPrincipal = null;\n+    private Set<String> proxyRoles;\n+    private boolean authenticateOriginalAuthData;\n+    private final boolean schemaValidationEnforced;\n+    private String authMethod = \"none\";\n+    private final int maxMessageSize;\n+    private boolean preciseDispatcherFlowControl;\n+\n+    private boolean preciseTopicPublishRateLimitingEnable;\n+\n+    // Flag to manage throttling-rate by atomically enable/disable read-channel.\n+    private volatile boolean autoReadDisabledRateLimiting = false;\n+    private FeatureFlags features;\n+    // Flag to manage throttling-publish-buffer by atomically enable/disable read-channel.\n+    private volatile boolean autoReadDisabledPublishBufferLimiting = false;\n+    private static final AtomicLongFieldUpdater<ServerCnx> MSG_PUBLISH_BUFFER_SIZE_UPDATER =\n+            AtomicLongFieldUpdater.newUpdater(ServerCnx.class, \"messagePublishBufferSize\");\n+    private volatile long messagePublishBufferSize = 0;\n+\n+    enum State {\n+        Start, Connected, Failed, Connecting\n+    }\n+\n+    public ServerCnx(PulsarService pulsar) {\n+        super(pulsar.getBrokerService().getKeepAliveIntervalSeconds(), TimeUnit.SECONDS);\n+        this.service = pulsar.getBrokerService();\n+        this.schemaService = pulsar.getSchemaRegistryService();\n+        this.state = State.Start;\n+\n+        // This maps are not heavily contended since most accesses are within the cnx thread\n+        this.producers = new ConcurrentLongHashMap<>(8, 1);\n+        this.consumers = new ConcurrentLongHashMap<>(8, 1);\n+        this.replicatorPrefix = service.pulsar().getConfiguration().getReplicatorPrefix();\n+        this.MaxNonPersistentPendingMessages = service.pulsar().getConfiguration()\n+                .getMaxConcurrentNonPersistentMessagePerConnection();\n+        this.proxyRoles = service.pulsar().getConfiguration().getProxyRoles();\n+        this.authenticateOriginalAuthData = service.pulsar().getConfiguration().isAuthenticateOriginalAuthData();\n+        this.schemaValidationEnforced = pulsar.getConfiguration().isSchemaValidationEnforced();\n+        this.maxMessageSize = pulsar.getConfiguration().getMaxMessageSize();\n+        this.maxPendingSendRequests = pulsar.getConfiguration().getMaxPendingPublishRequestsPerConnection();\n+        this.resumeReadsThreshold = maxPendingSendRequests / 2;\n+        this.preciseDispatcherFlowControl = pulsar.getConfiguration().isPreciseDispatcherFlowControl();\n+        this.preciseTopicPublishRateLimitingEnable = pulsar.getConfiguration().isPreciseTopicPublishRateLimiterEnable();\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        super.channelActive(ctx);\n+        log.info(\"New connection from {}\", remoteAddress);\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n+        super.channelInactive(ctx);\n+        isActive = false;\n+        log.info(\"Closed connection from {}\", remoteAddress);\n+\n+        // Connection is gone, close the producers immediately\n+        producers.values().forEach((producerFuture) -> {\n+            if (producerFuture.isDone() && !producerFuture.isCompletedExceptionally()) {\n+                Producer producer = producerFuture.getNow(null);\n+                producer.closeNow(true);\n+            }\n+        });\n+\n+        consumers.values().forEach((consumerFuture) -> {\n+            Consumer consumer;\n+            if (consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+                consumer = consumerFuture.getNow(null);\n+            } else {\n+                return;\n+            }\n+\n+            try {\n+                consumer.close();\n+            } catch (BrokerServiceException e) {\n+                log.warn(\"Consumer {} was already closed: {}\", consumer, e);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Channel writability has changed to: {}\", ctx.channel().isWritable());\n+        }\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+        if (state != State.Failed) {\n+            // No need to report stack trace for known exceptions that happen in disconnections\n+            log.warn(\"[{}] Got exception {}\", remoteAddress,\n+                    ClientCnx.isKnownException(cause) ? cause : ExceptionUtils.getStackTrace(cause));\n+            state = State.Failed;\n+        } else {\n+            // At default info level, suppress all subsequent exceptions that are thrown when the connection has already\n+            // failed\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Got exception: {}\", remoteAddress, cause);\n+            }\n+        }\n+        ctx.close();\n+    }\n+\n+    /*\n+     * If authentication and authorization is enabled(and not sasl) and if the authRole is one of proxyRoles we want to enforce\n+     * - the originalPrincipal is given while connecting\n+     * - originalPrincipal is not blank\n+     * - originalPrincipal is not a proxy principal\n+     */\n+    private boolean invalidOriginalPrincipal(String originalPrincipal) {\n+        return (service.isAuthenticationEnabled() && service.isAuthorizationEnabled()\n+            && proxyRoles.contains(authRole) && (StringUtils.isBlank(originalPrincipal) || proxyRoles.contains(originalPrincipal)));\n+    }\n+\n+    // ////\n+    // // Incoming commands handling\n+    // ////\n+\n+    @Override\n+    protected void handleLookup(CommandLookupTopic lookup) {\n+        final long requestId = lookup.getRequestId();\n+        final boolean authoritative = lookup.getAuthoritative();\n+        final String advertisedListenerName = lookup.getAdvertisedListenerName();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received Lookup from {} for {}\", lookup.getTopic(), remoteAddress, requestId);\n+        }\n+\n+        TopicName topicName = validateTopicName(lookup.getTopic(), requestId, lookup);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n+        if (lookupSemaphore.tryAcquire()) {\n+            if (invalidOriginalPrincipal(originalPrincipal)) {\n+                final String msg = \"Valid Proxy Client role should be provided for lookup \";\n+                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                        originalPrincipal, topicName);\n+                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n+                lookupSemaphore.release();\n+                return;\n+            }\n+            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+                isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                        TopicOperation.LOOKUP, originalPrincipal, authRole, authenticationData);\n+            } else {\n+                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+            }\n+            String finalOriginalPrincipal = originalPrincipal;\n+            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+                if (isProxyAuthorized) {\n+                    lookupTopicAsync(getBrokerService().pulsar(), topicName, authoritative,\n+                            finalOriginalPrincipal != null ? finalOriginalPrincipal : authRole, authenticationData,\n+                            requestId, advertisedListenerName).handle((lookupResponse, ex) -> {\n+                                if (ex == null) {\n+                                    ctx.writeAndFlush(lookupResponse);\n+                                } else {\n+                                    // it should never happen\n+                                    log.warn(\"[{}] lookup failed with error {}, {}\", remoteAddress, topicName,\n+                                            ex.getMessage(), ex);\n+                                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.ServiceNotReady,\n+                                            ex.getMessage(), requestId));\n+                                }\n+                                lookupSemaphore.release();\n+                                return null;\n+                            });\n+                } else {\n+                    final String msg = \"Proxy Client is not authorized to Lookup\";\n+                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                    ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n+                    lookupSemaphore.release();\n+                }\n+                return null;\n+            }).exceptionally(ex -> {\n+                final String msg = \"Exception occured while trying to authorize lookup\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName, ex);\n+                ctx.writeAndFlush(newLookupErrorResponse(ServerError.AuthorizationError, msg, requestId));\n+                lookupSemaphore.release();\n+                return null;\n+            });\n+        } else {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Failed lookup due to too many lookup-requests {}\", remoteAddress, topicName);\n+            }\n+            ctx.writeAndFlush(newLookupErrorResponse(ServerError.TooManyRequests,\n+                    \"Failed due to too many pending lookup requests\", requestId));\n+        }\n+    }\n+\n+    @Override\n+    protected void handlePartitionMetadataRequest(CommandPartitionedTopicMetadata partitionMetadata) {\n+        final long requestId = partitionMetadata.getRequestId();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received PartitionMetadataLookup from {} for {}\", partitionMetadata.getTopic(),\n+                    remoteAddress, requestId);\n+        }\n+\n+        TopicName topicName = validateTopicName(partitionMetadata.getTopic(), requestId, partitionMetadata);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        final Semaphore lookupSemaphore = service.getLookupRequestSemaphore();\n+        if (lookupSemaphore.tryAcquire()) {\n+            if (invalidOriginalPrincipal(originalPrincipal)) {\n+                final String msg = \"Valid Proxy Client role should be provided for getPartitionMetadataRequest \";\n+                log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                        originalPrincipal, topicName);\n+                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError,\n+                        msg, requestId));\n+                lookupSemaphore.release();\n+                return;\n+            }\n+            CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+            if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+                isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                        TopicOperation.LOOKUP, originalPrincipal, authRole, authenticationData);\n+            } else {\n+                isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+            }\n+            String finalOriginalPrincipal = originalPrincipal;\n+            isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+                if (isProxyAuthorized) {\n+                    getPartitionedTopicMetadata(getBrokerService().pulsar(),\n+                            authRole, finalOriginalPrincipal, authenticationData,\n+                            topicName).handle((metadata, ex) -> {\n+                                if (ex == null) {\n+                                    int partitions = metadata.partitions;\n+                                    ctx.writeAndFlush(Commands.newPartitionMetadataResponse(partitions, requestId));\n+                                } else {\n+                                    if (ex instanceof PulsarClientException) {\n+                                        log.warn(\"Failed to authorize {} at [{}] on topic {} : {}\", getRole(),\n+                                                remoteAddress, topicName, ex.getMessage());\n+                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(\n+                                                ServerError.AuthorizationError, ex.getMessage(), requestId));\n+                                    } else {\n+                                        log.warn(\"Failed to get Partitioned Metadata [{}] {}: {}\", remoteAddress,\n+                                                topicName, ex.getMessage(), ex);\n+                                        ServerError error = (ex instanceof RestException)\n+                                                && ((RestException) ex).getResponse().getStatus() < 500\n+                                                        ? ServerError.MetadataError\n+                                                        : ServerError.ServiceNotReady;\n+                                        ctx.writeAndFlush(Commands.newPartitionMetadataResponse(error,\n+                                                ex.getMessage(), requestId));\n+                                    }\n+                                }\n+                                lookupSemaphore.release();\n+                                return null;\n+                            });\n+                } else {\n+                    final String msg = \"Proxy Client is not authorized to Get Partition Metadata\";\n+                    log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                    ctx.writeAndFlush(\n+                            Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n+                    lookupSemaphore.release();\n+                }\n+                return null;\n+            }).exceptionally(ex -> {\n+                final String msg = \"Exception occured while trying to authorize get Partition Metadata\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.AuthorizationError, msg, requestId));\n+                lookupSemaphore.release();\n+                return null;\n+            });\n+        } else {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Failed Partition-Metadata lookup due to too many lookup-requests {}\", remoteAddress,\n+                        topicName);\n+            }\n+            ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.TooManyRequests,\n+                    \"Failed due to too many pending lookup requests\", requestId));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleConsumerStats(CommandConsumerStats commandConsumerStats) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CommandConsumerStats call from {}\", remoteAddress);\n+        }\n+\n+        final long requestId = commandConsumerStats.getRequestId();\n+        final long consumerId = commandConsumerStats.getConsumerId();\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n+        Consumer consumer = consumerFuture.getNow(null);\n+        ByteBuf msg = null;\n+\n+        if (consumer == null) {\n+            log.error(\n+                    \"Failed to get consumer-stats response - Consumer not found for CommandConsumerStats[remoteAddress = {}, requestId = {}, consumerId = {}]\",\n+                    remoteAddress, requestId, consumerId);\n+            msg = Commands.newConsumerStatsResponse(ServerError.ConsumerNotFound,\n+                    \"Consumer \" + consumerId + \" not found\", requestId);\n+        } else {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"CommandConsumerStats[requestId = {}, consumer = {}]\", requestId, consumer);\n+            }\n+            msg = Commands.newConsumerStatsResponse(createConsumerStatsResponse(consumer, requestId));\n+        }\n+\n+        ctx.writeAndFlush(msg);\n+    }\n+\n+    CommandConsumerStatsResponse.Builder createConsumerStatsResponse(Consumer consumer, long requestId) {\n+        CommandConsumerStatsResponse.Builder commandConsumerStatsResponseBuilder = CommandConsumerStatsResponse\n+                .newBuilder();\n+        ConsumerStats consumerStats = consumer.getStats();\n+        commandConsumerStatsResponseBuilder.setRequestId(requestId);\n+        commandConsumerStatsResponseBuilder.setMsgRateOut(consumerStats.msgRateOut);\n+        commandConsumerStatsResponseBuilder.setMsgThroughputOut(consumerStats.msgThroughputOut);\n+        commandConsumerStatsResponseBuilder.setMsgRateRedeliver(consumerStats.msgRateRedeliver);\n+        commandConsumerStatsResponseBuilder.setConsumerName(consumerStats.consumerName);\n+        commandConsumerStatsResponseBuilder.setAvailablePermits(consumerStats.availablePermits);\n+        commandConsumerStatsResponseBuilder.setUnackedMessages(consumerStats.unackedMessages);\n+        commandConsumerStatsResponseBuilder.setBlockedConsumerOnUnackedMsgs(consumerStats.blockedConsumerOnUnackedMsgs);\n+        commandConsumerStatsResponseBuilder.setAddress(consumerStats.getAddress());\n+        commandConsumerStatsResponseBuilder.setConnectedSince(consumerStats.getConnectedSince());\n+\n+        Subscription subscription = consumer.getSubscription();\n+        commandConsumerStatsResponseBuilder.setMsgBacklog(subscription.getNumberOfEntriesInBacklog(false));\n+        commandConsumerStatsResponseBuilder.setMsgRateExpired(subscription.getExpiredMessageRate());\n+        commandConsumerStatsResponseBuilder.setType(subscription.getTypeString());\n+\n+        return commandConsumerStatsResponseBuilder;\n+    }\n+\n+    // complete the connect and sent newConnected command\n+    private void completeConnect(int clientProtoVersion, String clientVersion) {\n+        ctx.writeAndFlush(Commands.newConnected(clientProtoVersion, maxMessageSize));\n+        state = State.Connected;\n+        remoteEndpointProtocolVersion = clientProtoVersion;\n+        if (isNotBlank(clientVersion) && !clientVersion.contains(\" \") /* ignore default version: pulsar client */) {\n+            this.clientVersion = clientVersion.intern();\n+        }\n+    }\n+\n+    // According to auth result, send newConnected or newAuthChallenge command.\n+    private State doAuthentication(AuthData clientData,\n+                                   int clientProtocolVersion,\n+                                   String clientVersion) throws Exception {\n+\n+        // The original auth state can only be set on subsequent auth attempts (and only\n+        // in presence of a proxy and if the proxy is forwarding the credentials).\n+        // In this case, the re-validation needs to be done against the original client\n+        // credentials.\n+        boolean useOriginalAuthState = (originalAuthState != null);\n+        AuthenticationState authState =  useOriginalAuthState ? originalAuthState : this.authState;\n+        String authRole = useOriginalAuthState ? originalPrincipal : this.authRole;\n+        AuthData brokerData = authState.authenticate(clientData);\n+\n+\n+        if (authState.isComplete()) {\n+            // Authentication has completed. It was either:\n+            // 1. the 1st time the authentication process was done, in which case we'll\n+            //    a `CommandConnected` response\n+            // 2. an authentication refresh, in which case we don't need to do anything else\n+\n+            String newAuthRole = authState.getAuthRole();\n+\n+            if (!useOriginalAuthState) {\n+                this.authRole = newAuthRole;\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Client successfully authenticated with {} role {} and originalPrincipal {}\",\n+                        remoteAddress, authMethod, authRole, originalPrincipal);\n+            }\n+\n+            if (state != State.Connected) {\n+                // First time authentication is done\n+                completeConnect(clientProtocolVersion, clientVersion);\n+            } else {\n+                // If the connection was already ready, it means we're doing a refresh\n+                if (!StringUtils.isEmpty(authRole)) {\n+                    if (!authRole.equals(newAuthRole)) {\n+                        log.warn(\"[{}] Principal cannot be changed during an authentication refresh\", remoteAddress);\n+                        ctx.close();\n+                    } else {\n+                        log.info(\"[{}] Refreshed authentication credentials for role {}\", remoteAddress, authRole);\n+                    }\n+                }\n+            }\n+\n+            return State.Connected;\n+        }\n+\n+        // auth not complete, continue auth with client side.\n+        ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, clientProtocolVersion));\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Authentication in progress client by method {}.\",\n+                remoteAddress, authMethod);\n+        }\n+        return State.Connecting;\n+    }\n+\n+    public void refreshAuthenticationCredentials() {\n+        AuthenticationState authState = this.originalAuthState != null ? originalAuthState : this.authState;\n+\n+        if (authState == null) {\n+            // Authentication is disabled or there's no local state to refresh\n+            return;\n+        } else if (getState() != State.Connected || !isActive) {\n+            // Connection is either still being established or already closed.\n+            return;\n+        } else if (authState != null && !authState.isExpired()) {\n+            // Credentials are still valid. Nothing to do at this point\n+            return;\n+        } else if (originalPrincipal != null && originalAuthState == null) {\n+            log.info(\n+                    \"[{}] Cannot revalidate user credential when using proxy and not forwarding the credentials. Closing connection\",\n+                    remoteAddress);\n+            return;\n+        }\n \n-public interface ServerCnx {\n+        ctx.executor().execute(SafeRun.safeRun(() -> {\n+            log.info(\"[{}] Refreshing authentication credentials for originalPrincipal {} and authRole {}\", remoteAddress, originalPrincipal, this.authRole);\n \n-    default String getClientVersion() {\n-        return null;\n+            if (!supportsAuthenticationRefresh()) {\n+                log.warn(\"[{}] Closing connection because client doesn't support auth credentials refresh\", remoteAddress);\n+                ctx.close();\n+                return;\n+            }\n+\n+            if (pendingAuthChallengeResponse) {\n+                log.warn(\"[{}] Closing connection after timeout on refreshing auth credentials\", remoteAddress);\n+                ctx.close();\n+                return;\n+            }\n+\n+            try {\n+                AuthData brokerData = authState.refreshAuthentication();\n+\n+                ctx.writeAndFlush(Commands.newAuthChallenge(authMethod, brokerData, remoteEndpointProtocolVersion));\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"[{}] Sent auth challenge to client to refresh credentials with method: {}.\",\n+                        remoteAddress, authMethod);\n+                }\n+\n+                pendingAuthChallengeResponse = true;\n+\n+            } catch (AuthenticationException e) {\n+                log.warn(\"[{}] Failed to refresh authentication: {}\", remoteAddress, e);\n+                ctx.close();\n+            }\n+        }));\n+    }\n+\n+    @Override\n+    protected void handleConnect(CommandConnect connect) {\n+        checkArgument(state == State.Start);\n+\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CONNECT from {}, auth enabled: {}\",\n+                remoteAddress, service.isAuthenticationEnabled());\n+        }\n+\n+        String clientVersion = connect.getClientVersion();\n+        int clientProtocolVersion = connect.getProtocolVersion();\n+        features = connect.getFeatureFlags();\n+\n+        if (!service.isAuthenticationEnabled()) {\n+            completeConnect(clientProtocolVersion, clientVersion);\n+            return;\n+        }\n+\n+        try {\n+            AuthData clientData = AuthData.of(connect.getAuthData().toByteArray());\n+\n+            // init authentication\n+            if (connect.hasAuthMethodName()) {\n+                authMethod = connect.getAuthMethodName();\n+            } else if (connect.hasAuthMethod()) {\n+                // Legacy client is passing enum\n+                authMethod = connect.getAuthMethod().name().substring(10).toLowerCase();\n+            } else {\n+                authMethod = \"none\";\n+            }\n+\n+            authenticationProvider = getBrokerService()\n+                .getAuthenticationService()\n+                .getAuthenticationProvider(authMethod);\n+\n+            // Not find provider named authMethod. Most used for tests.\n+            // In AuthenticationDisabled, it will set authMethod \"none\".\n+            if (authenticationProvider == null) {\n+                authRole = getBrokerService().getAuthenticationService().getAnonymousUserRole()\n+                    .orElseThrow(() ->\n+                        new AuthenticationException(\"No anonymous role, and no authentication provider configured\"));\n+                completeConnect(clientProtocolVersion, clientVersion);\n+                return;\n+            }\n+\n+            // init authState and other var\n+            ChannelHandler sslHandler = ctx.channel().pipeline().get(PulsarChannelInitializer.TLS_HANDLER);\n+            SSLSession sslSession = null;\n+            if (sslHandler != null) {\n+                sslSession = ((SslHandler) sslHandler).engine().getSession();\n+            }\n+\n+            authState = authenticationProvider.newAuthState(clientData, remoteAddress, sslSession);\n+            authenticationData = authState.getAuthDataSource();\n+            state = doAuthentication(clientData, clientProtocolVersion, clientVersion);\n+\n+            // This will fail the check if:\n+            //  1. client is coming through a proxy\n+            //  2. we require to validate the original credentials\n+            //  3. no credentials were passed\n+            if (connect.hasOriginalPrincipal() && service.getPulsar().getConfig().isAuthenticateOriginalAuthData()) {\n+                // init authentication\n+                String originalAuthMethod;\n+                if (connect.hasOriginalAuthMethod()) {\n+                    originalAuthMethod = connect.getOriginalAuthMethod();\n+                } else {\n+                    originalAuthMethod = \"none\";\n+                }\n+\n+                AuthenticationProvider originalAuthenticationProvider = getBrokerService()\n+                        .getAuthenticationService()\n+                        .getAuthenticationProvider(originalAuthMethod);\n+\n+                if (originalAuthenticationProvider == null) {\n+                    throw new AuthenticationException(String.format(\"Can't find AuthenticationProvider for original role\" +\n+                            \" using auth method [%s] is not available\", originalAuthMethod));\n+                }\n+\n+                originalAuthState = originalAuthenticationProvider.newAuthState(\n+                        AuthData.of(connect.getOriginalAuthData().getBytes()),\n+                        remoteAddress,\n+                        sslSession);\n+                originalPrincipal = originalAuthState.getAuthRole();\n+            } else {\n+                originalPrincipal = connect.hasOriginalPrincipal() ? connect.getOriginalPrincipal() : null;\n+            }\n+        } catch (Exception e) {\n+            String msg = \"Unable to authenticate\";\n+            if (e instanceof AuthenticationException) {\n+                log.warn(\"[{}] {}: {}\", remoteAddress, msg, e.getMessage());\n+            } else {\n+                log.warn(\"[{}] {}\", remoteAddress, msg, e);\n+            }\n+            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, msg));\n+            close();\n+        }\n     }\n \n-    SocketAddress clientAddress();\n+    @Override\n+    protected void handleAuthResponse(CommandAuthResponse authResponse) {\n+        checkArgument(authResponse.hasResponse());\n+        checkArgument(authResponse.getResponse().hasAuthData() && authResponse.getResponse().hasAuthMethodName());\n \n-    BrokerService getBrokerService();\n+        pendingAuthChallengeResponse = false;\n \n-    default boolean isBatchMessageCompatibleVersion() {\n-        return true;\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received AuthResponse from {}, auth method: {}\",\n+                remoteAddress, authResponse.getResponse().getAuthMethodName());\n+        }\n+\n+        try {\n+            AuthData clientData = AuthData.of(authResponse.getResponse().getAuthData().toByteArray());\n+            doAuthentication(clientData, authResponse.getProtocolVersion(), authResponse.getClientVersion());\n+        } catch (AuthenticationException e) {\n+            log.warn(\"[{}] Authentication failed: {} \", remoteAddress, e.getMessage());\n+            ctx.writeAndFlush(Commands.newError(-1, ServerError.AuthenticationError, e.getMessage()));\n+            close();\n+        } catch (Exception e) {\n+            String msg = \"Unable to handleAuthResponse\";\n+            log.warn(\"[{}] {} \", remoteAddress, msg, e);\n+            ctx.writeAndFlush(Commands.newError(-1, ServerError.UnknownError, msg));\n+            close();\n+        }\n+    }\n+\n+    @Override\n+    protected void handleSubscribe(final CommandSubscribe subscribe) {\n+        checkArgument(state == State.Connected);\n+        final long requestId = subscribe.getRequestId();\n+        final long consumerId = subscribe.getConsumerId();\n+        TopicName topicName = validateTopicName(subscribe.getTopic(), requestId, subscribe);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        if (invalidOriginalPrincipal(originalPrincipal)) {\n+            final String msg = \"Valid Proxy Client role should be provided while subscribing \";\n+            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                    originalPrincipal, topicName);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            return;\n+        }\n+\n+        final String subscriptionName = subscribe.getSubscription();\n+        final SubType subType = subscribe.getSubType();\n+        final String consumerName = subscribe.getConsumerName();\n+        final boolean isDurable = subscribe.getDurable();\n+        final MessageIdImpl startMessageId = subscribe.hasStartMessageId() ? new BatchMessageIdImpl(\n+                subscribe.getStartMessageId().getLedgerId(), subscribe.getStartMessageId().getEntryId(),\n+                subscribe.getStartMessageId().getPartition(), subscribe.getStartMessageId().getBatchIndex())\n+                : null;\n+        final int priorityLevel = subscribe.hasPriorityLevel() ? subscribe.getPriorityLevel() : 0;\n+        final boolean readCompacted = subscribe.getReadCompacted();\n+        final Map<String, String> metadata = CommandUtils.metadataFromCommand(subscribe);\n+        final InitialPosition initialPosition = subscribe.getInitialPosition();\n+        final long startMessageRollbackDurationSec = subscribe.hasStartMessageRollbackDurationSec()\n+                ? subscribe.getStartMessageRollbackDurationSec()\n+                : -1;\n+        final SchemaData schema = subscribe.hasSchema() ? getSchema(subscribe.getSchema()) : null;\n+        final boolean isReplicated = subscribe.hasReplicateSubscriptionState() && subscribe.getReplicateSubscriptionState();\n+        final boolean forceTopicCreation = subscribe.getForceTopicCreation();\n+        final PulsarApi.KeySharedMeta keySharedMeta = subscribe.hasKeySharedMeta() ? subscribe.getKeySharedMeta() : null;\n+\n+        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+            authenticationData.setSubscription(subscriptionName);\n+            isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                    TopicOperation.CONSUME, originalPrincipal, authRole, authenticationData);\n+        } else {\n+            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+        }\n+        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+            if (isProxyAuthorized) {\n+                CompletableFuture<Boolean> authorizationFuture;\n+                if (service.isAuthorizationEnabled()) {\n+                    if (authenticationData == null) {\n+                        authenticationData = new AuthenticationDataCommand(\"\", subscriptionName);\n+                    } else {\n+                        authenticationData.setSubscription(subscriptionName);\n+                    }\n+                    authorizationFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                            TopicOperation.CONSUME, originalPrincipal, authRole, authenticationData);\n+                } else {\n+                    authorizationFuture = CompletableFuture.completedFuture(true);\n+                }\n+\n+                authorizationFuture.thenApply(isAuthorized -> {\n+                    if (isAuthorized) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] Client is authorized to subscribe with role {}\", remoteAddress, authRole);\n+                        }\n+\n+                        log.info(\"[{}] Subscribing on topic {} / {}\", remoteAddress, topicName, subscriptionName);\n+                        try {\n+                            Metadata.validateMetadata(metadata);\n+                        } catch (IllegalArgumentException iae) {\n+                            final String msg = iae.getMessage();\n+                            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n+                            return null;\n+                        }\n+                        CompletableFuture<Consumer> consumerFuture = new CompletableFuture<>();\n+                        CompletableFuture<Consumer> existingConsumerFuture = consumers.putIfAbsent(consumerId,\n+                                consumerFuture);\n+\n+                        if (existingConsumerFuture != null) {\n+                            if (existingConsumerFuture.isDone() && !existingConsumerFuture.isCompletedExceptionally()) {\n+                                Consumer consumer = existingConsumerFuture.getNow(null);\n+                                log.info(\"[{}] Consumer with the same id {} is already created: {}\", remoteAddress,\n+                                        consumerId, consumer);\n+                                ctx.writeAndFlush(Commands.newSuccess(requestId));\n+                                return null;\n+                            } else {\n+                                // There was an early request to create a consumer with same consumerId. This can happen\n+                                // when\n+                                // client timeout is lower the broker timeouts. We need to wait until the previous\n+                                // consumer\n+                                // creation request either complete or fails.\n+                                log.warn(\"[{}][{}][{}] Consumer with id {} is already present on the connection\", remoteAddress,\n+                                        topicName, subscriptionName, consumerId);\n+                                ServerError error = null;\n+                                if(!existingConsumerFuture.isDone()) {\n+                                    error = ServerError.ServiceNotReady;\n+                                }else {\n+                                    error = getErrorCode(existingConsumerFuture);\n+                                    consumers.remove(consumerId);\n+                                }\n+                                ctx.writeAndFlush(Commands.newError(requestId, error,\n+                                        \"Consumer is already present on the connection\"));\n+                                return null;\n+                            }\n+                        }\n+\n+                        boolean createTopicIfDoesNotExist = forceTopicCreation\n+                                && service.isAllowAutoTopicCreation(topicName.toString());\n+\n+                        service.getTopic(topicName.toString(), createTopicIfDoesNotExist)\n+                                .thenCompose(optTopic -> {\n+                                    if (!optTopic.isPresent()) {\n+                                        return FutureUtil\n+                                                .failedFuture(new TopicNotFoundException(\"Topic does not exist\"));\n+                                    }\n+\n+                                    Topic topic = optTopic.get();\n+\n+                                    boolean rejectSubscriptionIfDoesNotExist = isDurable\n+                                        && !service.isAllowAutoSubscriptionCreation(topicName.toString())\n+                                        && !topic.getSubscriptions().containsKey(subscriptionName);\n+\n+                                    if (rejectSubscriptionIfDoesNotExist) {\n+                                        return FutureUtil\n+                                            .failedFuture(new SubscriptionNotFoundException(\"Subscription does not exist\"));\n+                                    }\n+\n+                                    if (schema != null) {\n+                                        return topic.addSchemaIfIdleOrCheckCompatible(schema)\n+                                            .thenCompose(v -> topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n+                                                    subType, priorityLevel, consumerName, isDurable,\n+                                                    startMessageId, metadata,\n+                                                    readCompacted, initialPosition, startMessageRollbackDurationSec, isReplicated, keySharedMeta));\n+                                    } else {\n+                                        return topic.subscribe(ServerCnx.this, subscriptionName, consumerId,\n+                                            subType, priorityLevel, consumerName, isDurable,\n+                                            startMessageId, metadata, readCompacted, initialPosition,\n+                                            startMessageRollbackDurationSec, isReplicated, keySharedMeta);\n+                                    }\n+                                })\n+                                .thenAccept(consumer -> {\n+                                    if (consumerFuture.complete(consumer)) {\n+                                        log.info(\"[{}] Created subscription on topic {} / {}\", remoteAddress, topicName,\n+                                                subscriptionName);\n+                                        ctx.writeAndFlush(Commands.newSuccess(requestId), ctx.voidPromise());\n+                                    } else {\n+                                        // The consumer future was completed before by a close command\n+                                        try {\n+                                            consumer.close();\n+                                            log.info(\"[{}] Cleared consumer created after timeout on client side {}\",\n+                                                    remoteAddress, consumer);\n+                                        } catch (BrokerServiceException e) {\n+                                            log.warn(\n+                                                    \"[{}] Error closing consumer created after timeout on client side {}: {}\",\n+                                                    remoteAddress, consumer, e.getMessage());\n+                                        }\n+                                        consumers.remove(consumerId, consumerFuture);\n+                                    }\n+\n+                                }) //\n+                                .exceptionally(exception -> {\n+                                    if (exception.getCause() instanceof ConsumerBusyException) {\n+                                        if (log.isDebugEnabled()) {\n+                                            log.debug(\n+                                                    \"[{}][{}][{}] Failed to create consumer because exclusive consumer is already connected: {}\",\n+                                                    remoteAddress, topicName, subscriptionName,\n+                                                    exception.getCause().getMessage());\n+                                        }\n+                                    } else if (exception.getCause() instanceof BrokerServiceException) {\n+                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n+                                                subscriptionName, exception.getCause().getMessage());\n+                                    } else {\n+                                        log.warn(\"[{}][{}][{}] Failed to create consumer: {}\", remoteAddress, topicName,\n+                                                subscriptionName, exception.getCause().getMessage(), exception);\n+                                    }\n+\n+                                    // If client timed out, the future would have been completed by subsequent close.\n+                                    // Send error\n+                                    // back to client, only if not completed already.\n+                                    if (consumerFuture.completeExceptionally(exception)) {\n+                                        ctx.writeAndFlush(Commands.newError(requestId,\n+                                                BrokerServiceException.getClientErrorCode(exception),\n+                                                exception.getCause().getMessage()));\n+                                    }\n+                                    consumers.remove(consumerId, consumerFuture);\n+\n+                                    return null;\n+\n+                                });\n+                    } else {\n+                        String msg = \"Client is not authorized to subscribe\";\n+                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n+                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+                    }\n+                    return null;\n+                }).exceptionally(e -> {\n+                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n+                    log.warn(msg);\n+                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n+                    return null;\n+                });\n+            } else {\n+                final String msg = \"Proxy Client is not authorized to subscribe\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            }\n+            return null;\n+        }).exceptionally(ex -> {\n+            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n+            if (ex.getCause() instanceof PulsarServerException) {\n+                log.info(msg);\n+            } else {\n+                log.warn(msg);\n+            }\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    private SchemaData getSchema(PulsarApi.Schema protocolSchema) {\n+        return SchemaData.builder()\n+            .data(protocolSchema.getSchemaData().toByteArray())\n+            .isDeleted(false)\n+            .timestamp(System.currentTimeMillis())\n+            .user(Strings.nullToEmpty(originalPrincipal))\n+            .type(Commands.getSchemaType(protocolSchema.getType()))\n+            .props(protocolSchema.getPropertiesList().stream().collect(\n+                Collectors.toMap(\n+                    PulsarApi.KeyValue::getKey,\n+                    PulsarApi.KeyValue::getValue\n+                )\n+            )).build();\n+    }\n+\n+    @Override\n+    protected void handleProducer(final CommandProducer cmdProducer) {\n+        checkArgument(state == State.Connected);\n+        final long producerId = cmdProducer.getProducerId();\n+        final long requestId = cmdProducer.getRequestId();\n+        // Use producer name provided by client if present\n+        final String producerName = cmdProducer.hasProducerName() ? cmdProducer.getProducerName()\n+                : service.generateUniqueProducerName();\n+        final long epoch = cmdProducer.getEpoch();\n+        final boolean userProvidedProducerName = cmdProducer.getUserProvidedProducerName();\n+        final boolean isEncrypted = cmdProducer.getEncrypted();\n+        final Map<String, String> metadata = CommandUtils.metadataFromCommand(cmdProducer);\n+        final SchemaData schema = cmdProducer.hasSchema() ? getSchema(cmdProducer.getSchema()) : null;\n+\n+        TopicName topicName = validateTopicName(cmdProducer.getTopic(), requestId, cmdProducer);\n+        if (topicName == null) {\n+            return;\n+        }\n+\n+        if (invalidOriginalPrincipal(originalPrincipal)) {\n+            final String msg = \"Valid Proxy Client role should be provided while creating producer \";\n+            log.warn(\"[{}] {} with role {} and proxyClientAuthRole {} on topic {}\", remoteAddress, msg, authRole,\n+                    originalPrincipal, topicName);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            return;\n+        }\n+\n+        CompletableFuture<Boolean> isProxyAuthorizedFuture;\n+        if (service.isAuthorizationEnabled() && originalPrincipal != null) {\n+            isProxyAuthorizedFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                    TopicOperation.PRODUCE, originalPrincipal, authRole, authenticationData);\n+        } else {\n+            isProxyAuthorizedFuture = CompletableFuture.completedFuture(true);\n+        }\n+        isProxyAuthorizedFuture.thenApply(isProxyAuthorized -> {\n+            if (isProxyAuthorized) {\n+                CompletableFuture<Boolean> authorizationFuture;\n+                if (service.isAuthorizationEnabled()) {\n+                    authorizationFuture = service.getAuthorizationService().allowTopicOperationAsync(topicName,\n+                            TopicOperation.PRODUCE, originalPrincipal, authRole, authenticationData);\n+                } else {\n+                    authorizationFuture = CompletableFuture.completedFuture(true);\n+                }\n+\n+                authorizationFuture.thenApply(isAuthorized -> {\n+                    if (isAuthorized) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"[{}] Client is authorized to Produce with role {}\", remoteAddress, authRole);\n+                        }\n+                        CompletableFuture<Producer> producerFuture = new CompletableFuture<>();\n+                        CompletableFuture<Producer> existingProducerFuture = producers.putIfAbsent(producerId,\n+                                producerFuture);\n+\n+                        if (existingProducerFuture != null) {\n+                            if (existingProducerFuture.isDone() && !existingProducerFuture.isCompletedExceptionally()) {\n+                                Producer producer = existingProducerFuture.getNow(null);\n+                                log.info(\"[{}] Producer with the same id {} is already created: {}\", remoteAddress,\n+                                        producerId, producer);\n+                                ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producer.getProducerName(),\n+                                    producer.getSchemaVersion()));\n+                                return null;\n+                            } else {\n+                                // There was an early request to create a producer with\n+                                // same producerId. This can happen when\n+                                // client\n+                                // timeout is lower the broker timeouts. We need to wait\n+                                // until the previous producer creation\n+                                // request\n+                                // either complete or fails.\n+                                ServerError error = null;\n+                                if(!existingProducerFuture.isDone()) {\n+                                    error = ServerError.ServiceNotReady;\n+                                } else {\n+                                    error = getErrorCode(existingProducerFuture);\n+                                    // remove producer with producerId as it's already completed with exception\n+                                    producers.remove(producerId);\n+                                }\n+                                log.warn(\"[{}][{}] Producer with id {} is already present on the connection\", remoteAddress,\n+                                        producerId, topicName);\n+                                ctx.writeAndFlush(Commands.newError(requestId, error,\n+                                        \"Producer is already present on the connection\"));\n+                                return null;\n+                            }\n+                        }\n+\n+                        log.info(\"[{}][{}] Creating producer. producerId={}\", remoteAddress, topicName, producerId);\n+\n+                        service.getOrCreateTopic(topicName.toString()).thenAccept((Topic topic) -> {\n+                            // Before creating producer, check if backlog quota exceeded\n+                            // on topic\n+                            if (topic.isBacklogQuotaExceeded(producerName)) {\n+                                IllegalStateException illegalStateException = new IllegalStateException(\n+                                        \"Cannot create producer on topic with backlog quota exceeded\");\n+                                BacklogQuota.RetentionPolicy retentionPolicy = topic.getBacklogQuota().getPolicy();\n+                                if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_request_hold) {\n+                                    ctx.writeAndFlush(\n+                                            Commands.newError(requestId, ServerError.ProducerBlockedQuotaExceededError,\n+                                                    illegalStateException.getMessage()));\n+                                } else if (retentionPolicy == BacklogQuota.RetentionPolicy.producer_exception) {\n+                                    ctx.writeAndFlush(Commands.newError(requestId,\n+                                            ServerError.ProducerBlockedQuotaExceededException,\n+                                            illegalStateException.getMessage()));\n+                                }\n+                                producerFuture.completeExceptionally(illegalStateException);\n+                                producers.remove(producerId, producerFuture);\n+                                return;\n+                            }\n+\n+                            // Check whether the producer will publish encrypted messages or not\n+                            if (topic.isEncryptionRequired() && !isEncrypted) {\n+                                String msg = String.format(\"Encryption is required in %s\", topicName);\n+                                log.warn(\"[{}] {}\", remoteAddress, msg);\n+                                ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, msg));\n+                                producers.remove(producerId, producerFuture);\n+                                return;\n+                            }\n+\n+                            disableTcpNoDelayIfNeeded(topicName.toString(), producerName);\n+\n+                            CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n+\n+                            schemaVersionFuture.exceptionally(exception -> {\n+                                ctx.writeAndFlush(Commands.newError(requestId,\n+                                        BrokerServiceException.getClientErrorCode(exception),\n+                                        exception.getMessage()));\n+                                producers.remove(producerId, producerFuture);\n+                                return null;\n+                            });\n+\n+                            schemaVersionFuture.thenAccept(schemaVersion -> {\n+                                Producer producer = new Producer(topic, ServerCnx.this, producerId, producerName, authRole,\n+                                    isEncrypted, metadata, schemaVersion, epoch, userProvidedProducerName);\n+\n+                                try {\n+                                    topic.addProducer(producer);\n+\n+                                    if (isActive()) {\n+                                        if (producerFuture.complete(producer)) {\n+                                            log.info(\"[{}] Created new producer: {}\", remoteAddress, producer);\n+                                            ctx.writeAndFlush(Commands.newProducerSuccess(requestId, producerName,\n+                                                producer.getLastSequenceId(), producer.getSchemaVersion()));\n+                                            return;\n+                                        } else {\n+                                            // The producer's future was completed before by\n+                                            // a close command\n+                                            producer.closeNow(true);\n+                                            log.info(\"[{}] Cleared producer created after timeout on client side {}\",\n+                                                remoteAddress, producer);\n+                                        }\n+                                    } else {\n+                                        producer.closeNow(true);\n+                                        log.info(\"[{}] Cleared producer created after connection was closed: {}\",\n+                                            remoteAddress, producer);\n+                                        producerFuture.completeExceptionally(\n+                                            new IllegalStateException(\"Producer created after connection was closed\"));\n+                                    }\n+                                } catch (Exception ise) {\n+                                    log.error(\"[{}] Failed to add producer to topic {}: {}\", remoteAddress, topicName,\n+                                        ise.getMessage());\n+                                    ctx.writeAndFlush(Commands.newError(requestId,\n+                                        BrokerServiceException.getClientErrorCode(ise), ise.getMessage()));\n+                                    producerFuture.completeExceptionally(ise);\n+                                }\n+\n+                                producers.remove(producerId, producerFuture);\n+                            });\n+                        }).exceptionally(exception -> {\n+                            Throwable cause = exception.getCause();\n+\n+                            if (cause instanceof NoSuchElementException) {\n+                                cause = new TopicNotFoundException(\"Topic Not Found.\");\n+                            }\n+\n+                            if (!(cause instanceof ServiceUnitNotReadyException)) {\n+                                // Do not print stack traces for expected exceptions\n+                                log.error(\"[{}] Failed to create topic {}\", remoteAddress, topicName, exception);\n+                            }\n+\n+                            // If client timed out, the future would have been completed\n+                            // by subsequent close. Send error back to\n+                            // client, only if not completed already.\n+                            if (producerFuture.completeExceptionally(exception)) {\n+                                ctx.writeAndFlush(Commands.newError(requestId,\n+                                        BrokerServiceException.getClientErrorCode(cause), cause.getMessage()));\n+                            }\n+                            producers.remove(producerId, producerFuture);\n+\n+                            return null;\n+                        });\n+                    } else {\n+                        String msg = \"Client is not authorized to Produce\";\n+                        log.warn(\"[{}] {} with role {}\", remoteAddress, msg, authRole);\n+                        ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+                    }\n+                    return null;\n+                }).exceptionally(e -> {\n+                    String msg = String.format(\"[%s] %s with role %s\", remoteAddress, e.getMessage(), authRole);\n+                    log.warn(msg);\n+                    ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, e.getMessage()));\n+                    return null;\n+                });\n+            } else {\n+                final String msg = \"Proxy Client is not authorized to Produce\";\n+                log.warn(\"[{}] {} with role {} on topic {}\", remoteAddress, msg, authRole, topicName);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, msg));\n+            }\n+            return null;\n+        }).exceptionally(ex -> {\n+            String msg = String.format(\"[%s] %s with role %s\", remoteAddress, ex.getMessage(), authRole);\n+            log.warn(msg);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.AuthorizationError, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void handleSend(CommandSend send, ByteBuf headersAndPayload) {\n+        checkArgument(state == State.Connected);\n+\n+        CompletableFuture<Producer> producerFuture = producers.get(send.getProducerId());\n+\n+        if (producerFuture == null || !producerFuture.isDone() || producerFuture.isCompletedExceptionally()) {\n+            log.warn(\"[{}] Producer had already been closed: {}\", remoteAddress, send.getProducerId());\n+            return;\n+        }\n+\n+        Producer producer = producerFuture.getNow(null);\n+        if (log.isDebugEnabled()) {\n+            printSendCommandDebug(send, headersAndPayload);\n+        }\n+\n+        if (producer.isNonPersistentTopic()) {\n+            // avoid processing non-persist message if reached max concurrent-message limit\n+            if (nonPersistentPendingMessages > MaxNonPersistentPendingMessages) {\n+                final long producerId = send.getProducerId();\n+                final long sequenceId = send.getSequenceId();\n+                final long highestSequenceId = send.getHighestSequenceId();\n+                service.getTopicOrderedExecutor().executeOrdered(producer.getTopic().getName(), SafeRun.safeRun(() -> {\n+                    ctx.writeAndFlush(Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, -1, -1), ctx.voidPromise());\n+                }));\n+                producer.recordMessageDrop(send.getNumMessages());\n+                return;\n+            } else {\n+                nonPersistentPendingMessages++;\n+            }\n+        }\n+\n+        startSendOperation(producer, headersAndPayload.readableBytes(), send.getNumMessages());\n+\n+        // Persist the message\n+        if (send.hasHighestSequenceId() && send.getSequenceId() <= send.getHighestSequenceId()) {\n+            producer.publishMessage(send.getProducerId(), send.getSequenceId(), send.getHighestSequenceId(),\n+                    headersAndPayload, send.getNumMessages(), send.getIsChunk());\n+        } else {\n+            producer.publishMessage(send.getProducerId(), send.getSequenceId(), headersAndPayload,\n+                    send.getNumMessages(), send.getIsChunk());\n+        }\n+    }\n+\n+    private void printSendCommandDebug(CommandSend send, ByteBuf headersAndPayload) {\n+        headersAndPayload.markReaderIndex();\n+        MessageMetadata msgMetadata = Commands.parseMessageMetadata(headersAndPayload);\n+        headersAndPayload.resetReaderIndex();\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received send message request. producer: {}:{} {}:{} size: {}, partition key is: {}, ordering key is {}\",\n+                    remoteAddress, send.getProducerId(), send.getSequenceId(), msgMetadata.getProducerName(), msgMetadata.getSequenceId(),\n+                    headersAndPayload.readableBytes(), msgMetadata.getPartitionKey(), msgMetadata.getOrderingKey());\n+        }\n+        msgMetadata.recycle();\n+    }\n+\n+    @Override\n+    protected void handleAck(CommandAck ack) {\n+        checkArgument(state == State.Connected);\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(ack.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            consumerFuture.getNow(null).messageAcked(ack);\n+        }\n+    }\n+\n+    @Override\n+    protected void handleFlow(CommandFlow flow) {\n+        checkArgument(state == State.Connected);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received flow from consumer {} permits: {}\", remoteAddress, flow.getConsumerId(),\n+                    flow.getMessagePermits());\n+        }\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(flow.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            if (consumer != null) {\n+                consumer.flowPermits(flow.getMessagePermits());\n+            } else {\n+                log.info(\"[{}] Couldn't find consumer {}\", remoteAddress, flow.getConsumerId());\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleRedeliverUnacknowledged(CommandRedeliverUnacknowledgedMessages redeliver) {\n+        checkArgument(state == State.Connected);\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Received Resend Command from consumer {} \", remoteAddress, redeliver.getConsumerId());\n+        }\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(redeliver.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            if (redeliver.getMessageIdsCount() > 0 && Subscription.isIndividualAckMode(consumer.subType())) {\n+                consumer.redeliverUnacknowledgedMessages(redeliver.getMessageIdsList());\n+            } else {\n+                consumer.redeliverUnacknowledgedMessages();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void handleUnsubscribe(CommandUnsubscribe unsubscribe) {\n+        checkArgument(state == State.Connected);\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(unsubscribe.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            consumerFuture.getNow(null).doUnsubscribe(unsubscribe.getRequestId());\n+        } else {\n+            ctx.writeAndFlush(\n+                    Commands.newError(unsubscribe.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleSeek(CommandSeek seek) {\n+        checkArgument(state == State.Connected);\n+        final long requestId = seek.getRequestId();\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(seek.getConsumerId());\n+\n+        if (!seek.hasMessageId() && !seek.hasMessagePublishTime()) {\n+            ctx.writeAndFlush(\n+                    Commands.newError(requestId, ServerError.MetadataError, \"Message id and message publish time were not present\"));\n+            return;\n+        }\n+\n+        boolean consumerCreated = consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally();\n+\n+        if (consumerCreated && seek.hasMessageId()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            Subscription subscription = consumer.getSubscription();\n+            MessageIdData msgIdData = seek.getMessageId();\n+\n+            Position position = new PositionImpl(msgIdData.getLedgerId(), msgIdData.getEntryId());\n+\n+\n+            subscription.resetCursor(position).thenRun(() -> {\n+                log.info(\"[{}] [{}][{}] Reset subscription to message id {}\", remoteAddress,\n+                        subscription.getTopic().getName(), subscription.getName(), position);\n+                ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            }).exceptionally(ex -> {\n+                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n+                        \"Error when resetting subscription: \" + ex.getCause().getMessage()));\n+                return null;\n+            });\n+        } else if (consumerCreated && seek.hasMessagePublishTime()){\n+            Consumer consumer = consumerFuture.getNow(null);\n+            Subscription subscription = consumer.getSubscription();\n+            long timestamp = seek.getMessagePublishTime();\n+\n+            subscription.resetCursor(timestamp).thenRun(() -> {\n+                log.info(\"[{}] [{}][{}] Reset subscription to publish time {}\", remoteAddress,\n+                        subscription.getTopic().getName(), subscription.getName(), timestamp);\n+                ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            }).exceptionally(ex -> {\n+                log.warn(\"[{}][{}] Failed to reset subscription: {}\", remoteAddress, subscription, ex.getMessage(), ex);\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n+                        \"Reset subscription to publish time error: \" + ex.getCause().getMessage()));\n+                return null;\n+            });\n+        } else {\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleCloseProducer(CommandCloseProducer closeProducer) {\n+        checkArgument(state == State.Connected);\n+\n+        final long producerId = closeProducer.getProducerId();\n+        final long requestId = closeProducer.getRequestId();\n+\n+        CompletableFuture<Producer> producerFuture = producers.get(producerId);\n+        if (producerFuture == null) {\n+            log.warn(\"[{}] Producer {} was not registered on the connection\", remoteAddress, producerId);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.UnknownError,\n+                    \"Producer was not registered on the connection\"));\n+            return;\n+        }\n+\n+        if (!producerFuture.isDone() && producerFuture\n+                .completeExceptionally(new IllegalStateException(\"Closed producer before creation was complete\"))) {\n+            // We have received a request to close the producer before it was actually completed, we have marked the\n+            // producer future as failed and we can tell the client the close operation was successful.\n+            log.info(\"[{}] Closed producer {} before its creation was completed\", remoteAddress, producerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            producers.remove(producerId, producerFuture);\n+            return;\n+        } else if (producerFuture.isCompletedExceptionally()) {\n+            log.info(\"[{}] Closed producer {} that already failed to be created\", remoteAddress, producerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            producers.remove(producerId, producerFuture);\n+            return;\n+        }\n+\n+        // Proceed with normal close, the producer\n+        Producer producer = producerFuture.getNow(null);\n+        log.info(\"[{}][{}] Closing producer on cnx {}\", producer.getTopic(), producer.getProducerName(), remoteAddress);\n+\n+        producer.close(true).thenAccept(v -> {\n+            log.info(\"[{}][{}] Closed producer on cnx {}\", producer.getTopic(), producer.getProducerName(),\n+                    remoteAddress);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            producers.remove(producerId, producerFuture);\n+        });\n+    }\n+\n+    @Override\n+    protected void handleCloseConsumer(CommandCloseConsumer closeConsumer) {\n+        checkArgument(state == State.Connected);\n+        log.info(\"[{}] Closing consumer: {}\", remoteAddress, closeConsumer.getConsumerId());\n+\n+        long requestId = closeConsumer.getRequestId();\n+        long consumerId = closeConsumer.getConsumerId();\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(consumerId);\n+        if (consumerFuture == null) {\n+            log.warn(\"[{}] Consumer was not registered on the connection: {}\", consumerId, remoteAddress);\n+            ctx.writeAndFlush(Commands.newError(requestId, ServerError.MetadataError, \"Consumer not found\"));\n+            return;\n+        }\n+\n+        if (!consumerFuture.isDone() && consumerFuture\n+                .completeExceptionally(new IllegalStateException(\"Closed consumer before creation was complete\"))) {\n+            // We have received a request to close the consumer before it was actually completed, we have marked the\n+            // consumer future as failed and we can tell the client the close operation was successful. When the actual\n+            // create operation will complete, the new consumer will be discarded.\n+            log.info(\"[{}] Closed consumer {} before its creation was completed\", remoteAddress, consumerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            return;\n+        }\n+\n+        if (consumerFuture.isCompletedExceptionally()) {\n+            log.info(\"[{}] Closed consumer {} that already failed to be created\", remoteAddress, consumerId);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            return;\n+        }\n+\n+        // Proceed with normal consumer close\n+        Consumer consumer = consumerFuture.getNow(null);\n+        try {\n+            consumer.close();\n+            consumers.remove(consumerId, consumerFuture);\n+            ctx.writeAndFlush(Commands.newSuccess(requestId));\n+            log.info(\"[{}] Closed consumer {}\", remoteAddress, consumer);\n+        } catch (BrokerServiceException e) {\n+            log.warn(\"[{]] Error closing consumer {} : {}\", remoteAddress, consumer, e);\n+            ctx.writeAndFlush(\n+                    Commands.newError(requestId, BrokerServiceException.getClientErrorCode(e), e.getMessage()));\n+        }\n+    }\n+\n+    @Override\n+    protected void handleGetLastMessageId(CommandGetLastMessageId getLastMessageId) {\n+        checkArgument(state == State.Connected);\n+\n+        CompletableFuture<Consumer> consumerFuture = consumers.get(getLastMessageId.getConsumerId());\n+\n+        if (consumerFuture != null && consumerFuture.isDone() && !consumerFuture.isCompletedExceptionally()) {\n+            Consumer consumer = consumerFuture.getNow(null);\n+            long requestId = getLastMessageId.getRequestId();\n+\n+            Topic topic = consumer.getSubscription().getTopic();\n+            Position position = topic.getLastPosition();\n+            int partitionIndex = TopicName.getPartitionIndex(topic.getName());\n+\n+            getLargestBatchIndexWhenPossible(\n+                    topic,\n+                    (PositionImpl) position,\n+                    partitionIndex,\n+                    requestId,\n+                    consumer.getSubscription().getName());\n+\n+        } else {\n+            ctx.writeAndFlush(Commands.newError(getLastMessageId.getRequestId(), ServerError.MetadataError, \"Consumer not found\"));\n+        }\n+    }\n+\n+    private void getLargestBatchIndexWhenPossible(\n+            Topic topic,\n+            PositionImpl position,\n+            int partitionIndex,\n+            long requestId,\n+            String subscriptionName) {\n+\n+        PersistentTopic persistentTopic = (PersistentTopic) topic;\n+        ManagedLedgerImpl ml = (ManagedLedgerImpl) persistentTopic.getManagedLedger();\n+\n+        // If it's not pointing to a valid entry, respond messageId of the current position.\n+        if (position.getEntryId() == -1) {\n+            MessageIdData messageId = MessageIdData.newBuilder()\n+                    .setLedgerId(position.getLedgerId())\n+                    .setEntryId(position.getEntryId())\n+                    .setPartition(partitionIndex).build();\n+\n+            ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n+        }\n+\n+        // For a valid position, we read the entry out and parse the batch size from its metadata.\n+        CompletableFuture<Entry> entryFuture = new CompletableFuture<>();\n+        ml.asyncReadEntry(position, new AsyncCallbacks.ReadEntryCallback() {\n+            @Override\n+            public void readEntryComplete(Entry entry, Object ctx) {\n+                entryFuture.complete(entry);\n+            }\n+\n+            @Override\n+            public void readEntryFailed(ManagedLedgerException exception, Object ctx) {\n+                entryFuture.completeExceptionally(exception);\n+            }\n+        }, null);\n+\n+        CompletableFuture<Integer> batchSizeFuture = entryFuture.thenApply(entry -> {\n+            MessageMetadata metadata = Commands.parseMessageMetadata(entry.getDataBuffer());\n+            int batchSize = metadata.getNumMessagesInBatch();\n+            entry.release();\n+            return batchSize;\n+        });\n+\n+        batchSizeFuture.whenComplete((batchSize, e) -> {\n+            if (e != null) {\n+                ctx.writeAndFlush(Commands.newError(\n+                        requestId, ServerError.MetadataError, \"Failed to get batch size for entry \" + e.getMessage()));\n+            } else {\n+                int largestBatchIndex = batchSize > 1 ? batchSize - 1 : -1;\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"[{}] [{}][{}] Get LastMessageId {} partitionIndex {}\", remoteAddress,\n+                            topic.getName(), subscriptionName, position, partitionIndex);\n+                }\n+\n+                MessageIdData messageId = MessageIdData.newBuilder()\n+                        .setLedgerId(position.getLedgerId())\n+                        .setEntryId(position.getEntryId())\n+                        .setPartition(partitionIndex)\n+                        .setBatchIndex(largestBatchIndex).build();\n+\n+                ctx.writeAndFlush(Commands.newGetLastMessageIdResponse(requestId, messageId));\n+            }\n+        });\n+    }\n+\n+    @Override\n+    protected void handleGetTopicsOfNamespace(CommandGetTopicsOfNamespace commandGetTopicsOfNamespace) {\n+        final long requestId = commandGetTopicsOfNamespace.getRequestId();\n+        final String namespace = commandGetTopicsOfNamespace.getNamespace();\n+        final CommandGetTopicsOfNamespace.Mode mode = commandGetTopicsOfNamespace.getMode();\n+        final NamespaceName namespaceName = NamespaceName.get(namespace);\n+\n+        getBrokerService().pulsar().getNamespaceService().getListOfTopics(namespaceName, mode)\n+                .thenAccept(topics -> {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"[{}] Received CommandGetTopicsOfNamespace for namespace [//{}] by {}, size:{}\",\n+                                remoteAddress, namespace, requestId, topics.size());\n+                    }\n+\n+                    ctx.writeAndFlush(Commands.newGetTopicsOfNamespaceResponse(topics, requestId));\n+                })\n+                .exceptionally(ex -> {\n+                    log.warn(\"[{}] Error GetTopicsOfNamespace for namespace [//{}] by {}\",\n+                            remoteAddress, namespace, requestId);\n+                    ctx.writeAndFlush(\n+                            Commands.newError(requestId,\n+                                    BrokerServiceException.getClientErrorCode(new ServerMetadataException(ex)),\n+                                    ex.getMessage()));\n+\n+                    return null;\n+                });\n+    }\n+\n+    @Override\n+    protected void handleGetSchema(CommandGetSchema commandGetSchema) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CommandGetSchema call from {}, schemaVersion: {}, topic: {}, requestId: {}\",\n+                    remoteAddress, new String(commandGetSchema.getSchemaVersion().toByteArray()),\n+                    commandGetSchema.getTopic(), commandGetSchema.getRequestId());\n+        }\n+\n+        long requestId = commandGetSchema.getRequestId();\n+        SchemaVersion schemaVersion = SchemaVersion.Latest;\n+        if (commandGetSchema.hasSchemaVersion()) {\n+            schemaVersion = schemaService.versionFromBytes(commandGetSchema.getSchemaVersion().toByteArray());\n+        }\n+\n+        String schemaName;\n+        try {\n+            schemaName = TopicName.get(commandGetSchema.getTopic()).getSchemaName();\n+        } catch (Throwable t) {\n+            ctx.writeAndFlush(\n+                    Commands.newGetSchemaResponseError(requestId, ServerError.InvalidTopicName, t.getMessage()));\n+            return;\n+        }\n+\n+        schemaService.getSchema(schemaName, schemaVersion).thenAccept(schemaAndMetadata -> {\n+            if (schemaAndMetadata == null) {\n+                ctx.writeAndFlush(Commands.newGetSchemaResponseError(requestId, ServerError.TopicNotFound,\n+                        \"Topic not found or no-schema\"));\n+            } else {\n+                ctx.writeAndFlush(Commands.newGetSchemaResponse(requestId,\n+                        SchemaInfoUtil.newSchemaInfo(schemaName, schemaAndMetadata.schema), schemaAndMetadata.version));\n+            }\n+        }).exceptionally(ex -> {\n+            ctx.writeAndFlush(\n+                    Commands.newGetSchemaResponseError(requestId, ServerError.UnknownError, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void handleGetOrCreateSchema(CommandGetOrCreateSchema commandGetOrCreateSchema) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Received CommandGetOrCreateSchema call from {}\", remoteAddress);\n+        }\n+        long requestId = commandGetOrCreateSchema.getRequestId();\n+        String topicName = commandGetOrCreateSchema.getTopic();\n+        SchemaData schemaData = getSchema(commandGetOrCreateSchema.getSchema());\n+        SchemaData schema = schemaData.getType() == SchemaType.NONE ? null : schemaData;\n+        service.getTopicIfExists(topicName).thenAccept(topicOpt -> {\n+            if (topicOpt.isPresent()) {\n+                Topic topic = topicOpt.get();\n+                CompletableFuture<SchemaVersion> schemaVersionFuture = tryAddSchema(topic, schema);\n+                schemaVersionFuture.exceptionally(ex -> {\n+                    ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n+                    ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n+                            requestId, errorCode, ex.getMessage()));\n+                    return null;\n+                }).thenAccept(schemaVersion -> {\n+                        ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponse(\n+                                requestId, schemaVersion));\n+                });\n+            } else {\n+                ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n+                        requestId, ServerError.TopicNotFound, \"Topic not found\"));\n+            }\n+        }).exceptionally(ex -> {\n+            ServerError errorCode = BrokerServiceException.getClientErrorCode(ex);\n+            ctx.writeAndFlush(Commands.newGetOrCreateSchemaResponseError(\n+                    requestId, errorCode, ex.getMessage()));\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected void handleNewTxn(CommandNewTxn command) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive new txn request {} to transaction meta store {} from {}.\", command.getRequestId(), command.getTcId(), remoteAddress);\n+        }\n+        TransactionCoordinatorID tcId = TransactionCoordinatorID.get(command.getTcId());\n+        service.pulsar().getTransactionMetadataStoreService().newTransaction(tcId)\n+            .whenComplete(((txnID, ex) -> {\n+                if (ex == null) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response {} for new txn request {}\", tcId.getId(),  command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response error for new txn request {}\", command.getRequestId(), ex);\n+                    }\n+                    ctx.writeAndFlush(Commands.newTxnResponse(command.getRequestId(), tcId.getId(), BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n+                }\n+            }));\n+    }\n+\n+    @Override\n+    protected void handleAddPartitionToTxn(PulsarApi.CommandAddPartitionToTxn command) {\n+        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive add published partition to txn request {} from {} with txnId {}\", command.getRequestId(), remoteAddress, txnID);\n+        }\n+        service.pulsar().getTransactionMetadataStoreService().addProducedPartitionToTxn(txnID, command.getPartitionsList())\n+            .whenComplete(((v, ex) -> {\n+                if (ex == null) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response success for add published partition to txn request {}\",  command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(),\n+                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response error for add published partition to txn request {}\",  command.getRequestId(), ex);\n+                    }\n+                    ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n+                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n+                }\n+            }));\n+    }\n+\n+    @Override\n+    protected void handleEndTxn(PulsarApi.CommandEndTxn command) {\n+        TxnStatus newStatus = null;\n+        switch (command.getTxnAction()) {\n+            case COMMIT:\n+                newStatus = TxnStatus.COMMITTING;\n+                break;\n+            case ABORT:\n+                newStatus = TxnStatus.ABORTING;\n+                break;\n+        }\n+        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive end txn by {} request {} from {} with txnId {}\", newStatus, command.getRequestId(), remoteAddress, txnID);\n+        }\n+        service.pulsar().getTransactionMetadataStoreService().updateTxnStatus(txnID, newStatus, TxnStatus.OPEN)\n+            .whenComplete((v, ex) -> {\n+                if (ex == null) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response success for end txn request {}\", command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(),\n+                            txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                } else {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Send response error for end txn request {}\", command.getRequestId());\n+                    }\n+                    ctx.writeAndFlush(Commands.newEndTxnResponse(command.getRequestId(), txnID.getMostSigBits(),\n+                            BrokerServiceException.getClientErrorCode(ex), ex.getMessage()));\n+                }\n+            });\n+    }\n+\n+    private CompletableFuture<SchemaVersion> tryAddSchema(Topic topic, SchemaData schema) {\n+        if (schema != null) {\n+            return topic.addSchema(schema);\n+        } else {\n+            return topic.hasSchema().thenCompose((hasSchema) -> {\n+                log.info(\"[{}] {} configured with schema {}\",\n+                         remoteAddress, topic.getName(), hasSchema);\n+                CompletableFuture<SchemaVersion> result = new CompletableFuture<>();\n+                if (hasSchema && (schemaValidationEnforced || topic.getSchemaValidationEnforced())) {\n+                    result.completeExceptionally(new IncompatibleSchemaException(\n+                            \"Producers cannot connect or send message without a schema to topics with a schema\"));\n+                } else {\n+                    result.complete(SchemaVersion.Empty);\n+                }\n+                return result;\n+            });\n+        }\n+    }\n+\n+    @Override\n+    protected boolean isHandshakeCompleted() {\n+        return state == State.Connected;\n+    }\n+\n+    public void closeProducer(Producer producer) {\n+        // removes producer-connection from map and send close command to producer\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n+        }\n+        long producerId = producer.getProducerId();\n+        producers.remove(producerId);\n+        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n+            ctx.writeAndFlush(Commands.newCloseProducer(producerId, -1L));\n+        } else {\n+            close();\n+        }\n+\n+    }\n+\n+    @Override\n+    public void closeConsumer(Consumer consumer) {\n+        // removes consumer-connection from map and send close command to consumer\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n+        }\n+        long consumerId = consumer.consumerId();\n+        consumers.remove(consumerId);\n+        if (remoteEndpointProtocolVersion >= v5.getNumber()) {\n+            ctx.writeAndFlush(Commands.newCloseConsumer(consumerId, -1L));\n+        } else {\n+            close();\n+        }\n     }\n \n     /**\n-     * The security role for this connection\n-     * @return the role\n+     * It closes the connection with client which triggers {@code channelInactive()} which clears all producers and\n+     * consumers from connection-map\n      */\n-    default String getRole() {\n-        return null;\n+    protected void close() {\n+        ctx.close();\n+    }\n+\n+    @Override\n+    public SocketAddress clientAddress() {\n+        return remoteAddress;\n+    }\n+\n+    @Override\n+    public void removedConsumer(Consumer consumer) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed consumer: {}\", remoteAddress, consumer);\n+        }\n+\n+        consumers.remove(consumer.consumerId());\n+    }\n+\n+    @Override\n+    public void removedProducer(Producer producer) {\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"[{}] Removed producer: {}\", remoteAddress, producer);\n+        }\n+        producers.remove(producer.getProducerId());\n+    }\n+\n+    @Override\n+    public boolean isActive() {\n+        return isActive;\n+    }\n+\n+    @Override\n+    public boolean isWritable() {\n+        return ctx.channel().isWritable();\n     }\n \n-    default AuthenticationDataSource getAuthenticationData() {\n-        return null;\n+\n+    public void startSendOperation(Producer producer, int msgSize, int numMessages) {\n+        MSG_PUBLISH_BUFFER_SIZE_UPDATER.getAndAdd(this, msgSize);\n+        boolean isPublishRateExceeded = false;\n+        if (preciseTopicPublishRateLimitingEnable) {\n+            boolean isPreciseTopicPublishRateExceeded = producer.getTopic().isTopicPublishRateExceeded(numMessages, msgSize);\n+            if (isPreciseTopicPublishRateExceeded) {\n+                producer.getTopic().disableCnxAutoRead();\n+                return;\n+            }\n+            isPublishRateExceeded = producer.getTopic().isBrokerPublishRateExceeded();\n+        } else {\n+            isPublishRateExceeded = producer.getTopic().isPublishRateExceeded();\n+        }\n+\n+        if (++pendingSendRequest == maxPendingSendRequests || isPublishRateExceeded) {\n+            // When the quota of pending send requests is reached, stop reading from socket to cause backpressure on\n+            // client connection, possibly shared between multiple producers\n+            ctx.channel().config().setAutoRead(false);\n+            autoReadDisabledRateLimiting = isPublishRateExceeded;\n+\n+        }\n+        if (getBrokerService().isReachMessagePublishBufferThreshold()) {\n+            ctx.channel().config().setAutoRead(false);\n+            autoReadDisabledPublishBufferLimiting = true;\n+        }\n     }\n \n-    default boolean isActive() {\n-        return true;\n+    @Override\n+    public void completedSendOperation(boolean isNonPersistentTopic, int msgSize) {\n+        MSG_PUBLISH_BUFFER_SIZE_UPDATER.getAndAdd(this, -msgSize);\n+        if (--pendingSendRequest == resumeReadsThreshold) {\n+            // Resume reading from socket\n+            ctx.channel().config().setAutoRead(true);\n+            // triggers channel read if autoRead couldn't trigger it\n+            ctx.read();\n+        }\n+        if (isNonPersistentTopic) {\n+            nonPersistentPendingMessages--;\n+        }\n     }\n \n-    default boolean isWritable() {\n-        return true;\n+    @Override\n+    public AuthenticationDataSource getAuthenticationData() {\n+        return authenticationData;\n     }\n \n-    default void completedSendOperation(boolean isNonPersistentTopic, int msgSize) {\n-        // No-op\n+    @Override\n+    public void enableCnxAutoRead() {\n+        // we can add check (&& pendingSendRequest < MaxPendingSendRequests) here but then it requires\n+        // pendingSendRequest to be volatile and it can be expensive while writing. also this will be called on if\n+        // throttling is enable on the topic. so, avoid pendingSendRequest check will be fine.\n+        if (!ctx.channel().config().isAutoRead() && !autoReadDisabledRateLimiting && !autoReadDisabledPublishBufferLimiting) {\n+            // Resume reading from socket if pending-request is not reached to threshold\n+            ctx.channel().config().setAutoRead(true);\n+            // triggers channel read\n+            ctx.read();\n+        }\n     }\n \n-    default void removedProducer(Producer producer) {\n-        // No-op\n+    @Override\n+    public void disableCnxAutoRead() {\n+        if (ctx.channel().config().isAutoRead() ) {\n+            ctx.channel().config().setAutoRead(false);\n+        }\n     }\n \n-    default void closeProducer(Producer producer) {\n-        // No-op\n+    @Override\n+    public void cancelPublishRateLimiting() {\n+        if (autoReadDisabledRateLimiting) {\n+            autoReadDisabledRateLimiting = false;\n+        }\n     }\n \n-    default long getMessagePublishBufferSize() {\n-        return Long.MAX_VALUE;\n+    @Override\n+    public void cancelPublishBufferLimiting() {\n+        if (autoReadDisabledPublishBufferLimiting) {\n+            autoReadDisabledPublishBufferLimiting = false;\n+        }\n     }\n \n-    default void cancelPublishRateLimiting() {\n-        // No-op\n+    private <T> ServerError getErrorCode(CompletableFuture<T> future) {\n+        ServerError error = ServerError.UnknownError;\n+        try {\n+            future.getNow(null);\n+        } catch (Exception e) {\n+            if (e.getCause() instanceof BrokerServiceException) {\n+                error = BrokerServiceException.getClientErrorCode(e.getCause());\n+            }\n+        }\n+        return error;\n     }\n \n-    default void cancelPublishBufferLimiting() {\n-        // No-op\n+    private void disableTcpNoDelayIfNeeded(String topic, String producerName) {\n+        if (producerName != null && producerName.startsWith(replicatorPrefix)) {\n+            // Re-enable nagle algorithm on connections used for replication purposes\n+            try {\n+                if (ctx.channel().config().getOption(ChannelOption.TCP_NODELAY).booleanValue() == true) {\n+                    ctx.channel().config().setOption(ChannelOption.TCP_NODELAY, false);\n+                }\n+            } catch (Throwable t) {\n+                log.warn(\"[{}] [{}] Failed to remove TCP no-delay property on client cnx {}\", topic, producerName,\n+                        ctx.channel());\n+            }\n+        }\n     }\n \n-    default void disableCnxAutoRead() {\n-        // No-op\n+    private TopicName validateTopicName(String topic, long requestId, GeneratedMessageLite requestCommand) {\n+        try {\n+            return TopicName.get(topic);\n+        } catch (Throwable t) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"[{}] Failed to parse topic name '{}'\", remoteAddress, topic, t);\n+            }\n+\n+            if (requestCommand instanceof CommandLookupTopic) {\n+                ctx.writeAndFlush(Commands.newLookupErrorResponse(ServerError.InvalidTopicName,\n+                        \"Invalid topic name: \" + t.getMessage(), requestId));\n+            } else if (requestCommand instanceof CommandPartitionedTopicMetadata) {\n+                ctx.writeAndFlush(Commands.newPartitionMetadataResponse(ServerError.InvalidTopicName,\n+                        \"Invalid topic name: \" + t.getMessage(), requestId));\n+            } else {\n+                ctx.writeAndFlush(Commands.newError(requestId, ServerError.InvalidTopicName,\n+                        \"Invalid topic name: \" + t.getMessage()));\n+            }\n+\n+            return null;\n+        }\n     }\n \n-    default void enableCnxAutoRead() {\n-        // No-op\n+    private static final Logger log = LoggerFactory.getLogger(ServerCnx.class);\n+\n+    /**\n+     * Helper method for testability\n+     *\n+     * @return\n+     */\n+    public State getState() {\n+        return state;\n     }\n \n-    default void execute(Runnable runnable) {\n-        CompletableFuture.runAsync(runnable);\n+    public BrokerService getBrokerService() {\n+        return service;\n     }\n \n-    default void removedConsumer(Consumer consumer) {\n-        // No-op\n+    public String getRole() {\n+        return authRole;\n     }\n \n-    default void closeConsumer(Consumer consumer) {\n-        // No-op\n+    boolean hasConsumer(long consumerId) {\n+        return consumers.containsKey(consumerId);\n     }\n \n-    default void sendProducerError(long producerId, long sequenceId, ServerError serverError, String message) {\n-        // No-op\n+    @Override\n+    public boolean isBatchMessageCompatibleVersion() {\n+        return remoteEndpointProtocolVersion >= ProtocolVersion.v4.getNumber();\n     }\n \n-    default void sendProducerReceipt(long producerId, long sequenceId, long highestSequenceId, long ledgerId, long entryId) {\n-        // No-op\n+    boolean supportsAuthenticationRefresh() {\n+        return features != null && features.getSupportsAuthRefresh();\n     }\n \n-    default void sendActiveConsumerChange(long consumerId, boolean isActive) {\n-        // No-op\n+    @Override\n+    public String getClientVersion() {\n+        return clientVersion;\n     }\n \n-    default void sendSuccess(long requestId) {\n-        // No-op\n+    @Override\n+    public long getMessagePublishBufferSize() {\n+        return this.messagePublishBufferSize;\n     }\n \n-    default void sendError(long requestId, ServerError error, String message) {\n-        // No-op\n+    @VisibleForTesting\n+    void setMessagePublishBufferSize(long bufferSize) {\n+        this.messagePublishBufferSize = bufferSize;\n     }\n \n-    default void sendReachedEndOfTopic(long consumerId) {\n-        // No-op\n+    @VisibleForTesting\n+    void setAutoReadDisabledRateLimiting(boolean isLimiting) {\n+        this.autoReadDisabledRateLimiting = isLimiting;\n     }\n \n-    default CompletableFuture<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n-            int partitionIdx, final List<Entry> entries, EntryBatchSizes batchSizes,\n+    @VisibleForTesting\n+    void setCtx(ChannelHandlerContext ctx) {\n+        this.ctx = ctx;\n+    }\n+\n+    @Override\n+    public boolean isPreciseDispatcherFlowControl() {\n+        return preciseDispatcherFlowControl;\n+    }\n+\n+    @Override\n+    public void sendProducerError(long producerId, long sequenceId, PulsarApi.ServerError serverError, String message) {\n+        ctx.writeAndFlush(Commands.newSendError(producerId, sequenceId, serverError, message));\n+    }\n+\n+    @Override\n+    public void execute(Runnable runnable) {\n+        ctx.channel().eventLoop().execute(runnable);\n+    }\n+\n+    @Override\n+    public void sendProducerReceipt(long producerId, long sequenceId, long highestSequenceId, long ledgerId, long entryId) {\n+        ctx.writeAndFlush(\n+                Commands.newSendReceipt(producerId, sequenceId, highestSequenceId, ledgerId, entryId),\n+                ctx.voidPromise());\n+    }\n+\n+    @Override\n+    public void sendActiveConsumerChange(long consumerId, boolean isActive) {\n+        if (!Commands.peerSupportsActiveConsumerListener(getRemoteEndpointProtocolVersion())) {\n+            // if the client is older than `v12`, we don't need to send consumer group changes.\n+            return;\n+        }\n+        ctx.writeAndFlush(\n+                Commands.newActiveConsumerChange(consumerId, isActive),\n+                ctx.voidPromise());\n+    }\n+\n+    @Override\n+    public void sendSuccess(long requestId) {\n+        ctx.writeAndFlush(Commands.newSuccess(requestId));\n+    }\n+\n+    @Override\n+    public void sendError(long requestId, ServerError error, String message) {\n+        ctx.writeAndFlush(Commands.newError(requestId, error, message));\n+    }\n+\n+    @Override\n+    public void sendReachedEndOfTopic(long consumerId) {\n+        // Only send notification if the client understand the command\n+        if (getRemoteEndpointProtocolVersion() >= ProtocolVersion.v9_VALUE) {\n+            log.info(\"[{}] Notifying consumer that end of topic has been reached\", this);\n+            ctx.writeAndFlush(Commands.newReachedEndOfTopic(consumerId));\n+        }\n+    }\n+\n+    @Override\n+    public CompletableFuture<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n+            int partitionIdx, final List<Entry> entries, EntryBatchSizes batchSizes, EntryBatchIndexesAcks batchIndexesAcks,\n             RedeliveryTracker redeliveryTracker) {\n-        return CompletableFuture.completedFuture(null);\n+        CompletableFuture<Void> writeFuture = new CompletableFuture<>();\n+        ctx.channel().eventLoop().execute(() -> {\n+            for (int i = 0; i < entries.size(); i++) {\n+                Entry entry = entries.get(i);\n+                if (entry == null) {\n+                    // Entry was filtered out\n+                    continue;\n+                }\n+\n+                int batchSize = batchSizes.getBatchSize(i);\n+\n+                if (batchSize > 1 && !isBatchMessageCompatibleVersion()) {\n+                    log.warn(\"[{}-{}] Consumer doesn't support batch messages -  consumerId {}, msg id {}-{}\",\n+                            topicName, subscription,\n+                            consumerId, entry.getLedgerId(), entry.getEntryId());\n+                    ctx.close();\n+                    entry.release();\n+                    continue;\n+                }\n+\n+                MessageIdData.Builder messageIdBuilder = MessageIdData.newBuilder();\n+                MessageIdData messageId = messageIdBuilder\n+                    .setLedgerId(entry.getLedgerId())\n+                    .setEntryId(entry.getEntryId())\n+                    .setPartition(partitionIdx)\n+                    .build();\n+\n+                ByteBuf metadataAndPayload = entry.getDataBuffer();\n+                // increment ref-count of data and release at the end of process: so, we can get chance to call entry.release\n+                metadataAndPayload.retain();\n+                // skip checksum by incrementing reader-index if consumer-client doesn't support checksum verification\n+                if (getRemoteEndpointProtocolVersion() < ProtocolVersion.v11.getNumber()) {\n+                    Commands.skipChecksumIfPresent(metadataAndPayload);\n+                }\n+\n+                if (log.isDebugEnabled()) {\n+                    log.debug(\"[{}-{}] Sending message to consumerId {}, msg id {}-{}\", topicName, subscription,\n+                            consumerId, entry.getLedgerId(), entry.getEntryId());\n+                }\n+\n+                int redeliveryCount = 0;\n+                PositionImpl position = PositionImpl.get(messageId.getLedgerId(), messageId.getEntryId());\n+                if (redeliveryTracker.contains(position)) {\n+                    redeliveryCount = redeliveryTracker.incrementAndGetRedeliveryCount(position);\n+                }\n+                ctx.write(Commands.newMessage(consumerId, messageId, redeliveryCount, metadataAndPayload,\n+                    batchIndexesAcks == null ? null : batchIndexesAcks.getAckSet(i)), ctx.voidPromise());\n+                messageId.recycle();\n+                messageIdBuilder.recycle();\n+                entry.release();\n+            }\n+\n+            final ChannelPromise writePromise = ctx.newPromise().addListener(future -> {\n+                    if(future.isSuccess()) {\n+                        writeFuture.complete(null);\n+                    } else {\n+                        writeFuture.completeExceptionally(future.cause());\n+                    }\n+            });\n+            // Use an empty write here so that we can just tie the flush with the write promise for last entry\n+            ctx.writeAndFlush(Unpooled.EMPTY_BUFFER, writePromise);\n+            batchSizes.recyle();\n+            if (batchIndexesAcks != null) {\n+                batchIndexesAcks.recycle();\n+            }\n+        });\n+        return writeFuture;\n     }\n }\n"}}, {"oid": "9a753a66b82eda6e0ad82bf3eec2278955586ea9", "url": "https://github.com/apache/pulsar/commit/9a753a66b82eda6e0ad82bf3eec2278955586ea9", "message": "Make Consumer independent of Netty", "committedDate": "2020-04-20T21:58:17Z", "type": "forcePushed"}, {"oid": "395e6b392d6eb857dda937d6e15a1df827a2c627", "url": "https://github.com/apache/pulsar/commit/395e6b392d6eb857dda937d6e15a1df827a2c627", "message": "Make Consumer independent of Netty", "committedDate": "2020-04-21T22:10:29Z", "type": "forcePushed"}, {"oid": "09caac551ab1931972d1eee601f7f86456d8d3d3", "url": "https://github.com/apache/pulsar/commit/09caac551ab1931972d1eee601f7f86456d8d3d3", "message": "Make Consumer independent of Netty", "committedDate": "2020-04-23T15:35:58Z", "type": "forcePushed"}, {"oid": "6d6866480e10a1b465e6c6cb0ebcc2084ad290c9", "url": "https://github.com/apache/pulsar/commit/6d6866480e10a1b465e6c6cb0ebcc2084ad290c9", "message": "Make Consumer independent of Netty", "committedDate": "2020-05-11T12:14:23Z", "type": "forcePushed"}, {"oid": "44d59e268a2f4f688e3be99a635d1ffa847e6726", "url": "https://github.com/apache/pulsar/commit/44d59e268a2f4f688e3be99a635d1ffa847e6726", "message": "Make Consumer independent of Netty", "committedDate": "2020-05-12T16:09:40Z", "type": "forcePushed"}, {"oid": "12812ad1de9064a8762d3a0d10eedcd72e08b9c7", "url": "https://github.com/apache/pulsar/commit/12812ad1de9064a8762d3a0d10eedcd72e08b9c7", "message": "Make Consumer independent of Netty", "committedDate": "2020-05-26T13:54:17Z", "type": "forcePushed"}, {"oid": "551eb5a7180d9446f86d1c7eea9d2f97b02e97ce", "url": "https://github.com/apache/pulsar/commit/551eb5a7180d9446f86d1c7eea9d2f97b02e97ce", "message": "Rename ServerCnx interface and implementation to reduce braking changes", "committedDate": "2020-06-05T06:41:40Z", "type": "forcePushed"}, {"oid": "8ff2216218002479cf6c2a4d52b7b19796790e8f", "url": "https://github.com/apache/pulsar/commit/8ff2216218002479cf6c2a4d52b7b19796790e8f", "message": "Rename ServerCnx interface and implementation to reduce braking changes", "committedDate": "2020-06-05T07:00:02Z", "type": "forcePushed"}, {"oid": "9317f0b7f25d37828e74f92257808ec8c43d3166", "url": "https://github.com/apache/pulsar/commit/9317f0b7f25d37828e74f92257808ec8c43d3166", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-06-05T07:33:52Z", "type": "forcePushed"}, {"oid": "dc3f09b49285a371fad098492146aa7c537a2542", "url": "https://github.com/apache/pulsar/commit/dc3f09b49285a371fad098492146aa7c537a2542", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-06-05T08:01:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNjk0Mw==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435826943", "bodyText": "Not breaking as ServerCnx is now an impl of TransportCnx", "author": "cbornet", "createdAt": "2020-06-05T10:15:01Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -130,7 +121,7 @@\n \n     public Consumer(Subscription subscription, SubType subType, String topicName, long consumerId,\n                     int priorityLevel, String consumerName,\n-                    int maxUnackedMessages, ServerCnx cnx, String appId,\n+                    int maxUnackedMessages, TransportCnx cnx, String appId,", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c442cca86a820cc36f94627092044c45f24f1c44", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex 930ba38afbd..d5c4b1a268a 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -118,6 +122,7 @@ public class Consumer {\n \n     private static final double avgPercent = 0.9;\n     private boolean preciseDispatcherFlowControl;\n+    private PositionImpl readPositionWhenJoining;\n \n     public Consumer(Subscription subscription, SubType subType, String topicName, long consumerId,\n                     int priorityLevel, String consumerName,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyNzMwMg==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435827302", "bodyText": "Not breaking as ServerCnx is now an impl of TransportCnx", "author": "cbornet", "createdAt": "2020-06-05T10:15:47Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Producer.java", "diffHunk": "@@ -88,7 +88,7 @@\n \n     private final SchemaVersion schemaVersion;\n \n-    public Producer(Topic topic, ServerCnx cnx, long producerId, String producerName, String appId,\n+    public Producer(Topic topic, TransportCnx cnx, long producerId, String producerName, String appId,", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODEwMQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435828101", "bodyText": "Not breaking as ServerCnx is now an impl of TransportCnx", "author": "cbornet", "createdAt": "2020-06-05T10:17:31Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Topic.java", "diffHunk": "@@ -102,7 +102,7 @@ default long getOriginalHighestSequenceId() {\n      */\n     void recordAddLatency(long latency, TimeUnit unit);\n \n-    CompletableFuture<Consumer> subscribe(ServerCnx cnx, String subscriptionName, long consumerId, SubType subType,\n+    CompletableFuture<Consumer> subscribe(TransportCnx cnx, String subscriptionName, long consumerId, SubType subType,", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODMzNQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435828335", "bodyText": "Not breaking as ServerCnx is now an impl of TransportCnx", "author": "cbornet", "createdAt": "2020-06-05T10:17:58Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/nonpersistent/NonPersistentTopic.java", "diffHunk": "@@ -234,7 +234,7 @@ public void handleProducerRemoved(Producer producer) {\n     }\n \n     @Override\n-    public CompletableFuture<Consumer> subscribe(final ServerCnx cnx, String subscriptionName, long consumerId,\n+    public CompletableFuture<Consumer> subscribe(final TransportCnx cnx, String subscriptionName, long consumerId,", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyODQ1NA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435828454", "bodyText": "Not breaking as ServerCnx is now an impl of TransportCnx", "author": "cbornet", "createdAt": "2020-06-05T10:18:12Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/persistent/PersistentTopic.java", "diffHunk": "@@ -506,7 +506,7 @@ protected void handleProducerRemoved(Producer producer) {\n     }\n \n     @Override\n-    public CompletableFuture<Consumer> subscribe(final ServerCnx cnx, String subscriptionName, long consumerId,\n+    public CompletableFuture<Consumer> subscribe(final TransportCnx cnx, String subscriptionName, long consumerId,", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMTkwNA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435831904", "bodyText": "This code was already dead code. Is it a problem to remove it ?", "author": "cbornet", "createdAt": "2020-06-05T10:25:23Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -336,10 +258,6 @@ public boolean isWritable() {\n         return cnx.isWritable();\n     }\n \n-    public void sendError(ByteBuf error) {", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzMzYzNg==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r435833636", "bodyText": "This does the same thing that clientAddress(). Should I keep it for backward compat ? It would be dead code... So maybe with a deprecation annotation ?", "author": "cbornet", "createdAt": "2020-06-05T10:28:50Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -1930,10 +1943,6 @@ public State getState() {\n         return state;\n     }\n \n-    public SocketAddress getRemoteAddress() {", "originalCommit": "dc3f09b49285a371fad098492146aa7c537a2542", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "28357ea80f8c71d6c725edddcb4de8ab5b287dbd", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\nindex ce870485d8a..c4a2c9ad017 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n\n@@ -1937,12 +1939,16 @@ public class ServerCnx extends PulsarHandler implements TransportCnx {\n     /**\n      * Helper method for testability\n      *\n-     * @return\n+     * @return the connection state\n      */\n     public State getState() {\n         return state;\n     }\n \n+    public SocketAddress getRemoteAddress() {\n+        return remoteAddress;\n+    }\n+\n     public BrokerService getBrokerService() {\n         return service;\n     }\n"}}, {"oid": "28357ea80f8c71d6c725edddcb4de8ab5b287dbd", "url": "https://github.com/apache/pulsar/commit/28357ea80f8c71d6c725edddcb4de8ab5b287dbd", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-06-19T08:21:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwNTc4Ng==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r442705786", "bodyText": "package-private and not used anymore. OK to remove ?", "author": "cbornet", "createdAt": "2020-06-19T08:26:11Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java", "diffHunk": "@@ -1729,10 +1732,6 @@ protected boolean isHandshakeCompleted() {\n         return state == State.Connected;\n     }\n \n-    ChannelHandlerContext ctx() {", "originalCommit": "28357ea80f8c71d6c725edddcb4de8ab5b287dbd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3028811d07914bdd8a91adc6a263dc25bc1637d2", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\nindex c4a2c9ad017..7940a32a0dc 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/ServerCnx.java\n\n@@ -1727,6 +1764,38 @@ public class ServerCnx extends PulsarHandler implements TransportCnx {\n         }\n     }\n \n+    @Override\n+    protected void handleAddSubscriptionToTxn(PulsarApi.CommandAddSubscriptionToTxn command) {\n+        TxnID txnID = new TxnID(command.getTxnidMostBits(), command.getTxnidLeastBits());\n+        if (log.isDebugEnabled()) {\n+            log.debug(\"Receive add published partition to txn request {} from {} with txnId {}\",\n+                    command.getRequestId(), remoteAddress, txnID);\n+        }\n+        List<String> subscriptionList = command.getSubscriptionList().stream()\n+                .map(subscription -> subscription.getTopic() + \"|\" + subscription.getSubscription())\n+                .collect(Collectors.toList());\n+        service.pulsar().getTransactionMetadataStoreService().addAckedPartitionToTxn(txnID, subscriptionList)\n+                .whenComplete(((v, ex) -> {\n+                    if (ex == null) {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Send response success for add published partition to txn request {}\",\n+                                    command.getRequestId());\n+                        }\n+                        ctx.writeAndFlush(Commands.newEndTxnOnSubscriptionResponse(command.getRequestId(),\n+                                txnID.getLeastSigBits(), txnID.getMostSigBits()));\n+                        log.info(\"handle add partition to txn finish.\");\n+                    } else {\n+                        if (log.isDebugEnabled()) {\n+                            log.debug(\"Send response error for add published partition to txn request {}\",\n+                                    command.getRequestId(), ex);\n+                        }\n+                        ctx.writeAndFlush(Commands.newAddPartitionToTxnResponse(command.getRequestId(),\n+                                txnID.getMostSigBits(), BrokerServiceException.getClientErrorCode(ex),\n+                                ex.getMessage()));\n+                    }\n+                }));\n+    }\n+\n     @Override\n     protected boolean isHandshakeCompleted() {\n         return state == State.Connected;\n"}}, {"oid": "3028811d07914bdd8a91adc6a263dc25bc1637d2", "url": "https://github.com/apache/pulsar/commit/3028811d07914bdd8a91adc6a263dc25bc1637d2", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-08-28T07:57:34Z", "type": "forcePushed"}, {"oid": "c442cca86a820cc36f94627092044c45f24f1c44", "url": "https://github.com/apache/pulsar/commit/c442cca86a820cc36f94627092044c45f24f1c44", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-11-06T20:39:34Z", "type": "forcePushed"}, {"oid": "837286de9c69358c8a5239919e4e8a014e4f7aed", "url": "https://github.com/apache/pulsar/commit/837286de9c69358c8a5239919e4e8a014e4f7aed", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-11-06T20:40:21Z", "type": "forcePushed"}, {"oid": "5c36f465115bd7da7ae4a47c4cd66239bdef0431", "url": "https://github.com/apache/pulsar/commit/5c36f465115bd7da7ae4a47c4cd66239bdef0431", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-11-06T21:18:04Z", "type": "forcePushed"}, {"oid": "9a1358b99eed7eb22bef1a0013c86795e689bfd8", "url": "https://github.com/apache/pulsar/commit/9a1358b99eed7eb22bef1a0013c86795e689bfd8", "message": "Make ServerCnx Producer and Consumer independent of Netty", "committedDate": "2020-11-07T14:16:43Z", "type": "forcePushed"}, {"oid": "088ea9d226796855eba194a2e55841cc330cc013", "url": "https://github.com/apache/pulsar/commit/088ea9d226796855eba194a2e55841cc330cc013", "message": "Make Consumer and Producer use an interface instead of directly ServerCnx", "committedDate": "2020-11-12T15:04:48Z", "type": "forcePushed"}, {"oid": "539584b094952b55d3ac46c2f93d618fd7b872c6", "url": "https://github.com/apache/pulsar/commit/539584b094952b55d3ac46c2f93d618fd7b872c6", "message": "Make Consumer and Producer use an interface instead of directly ServerCnx", "committedDate": "2020-11-12T15:14:38Z", "type": "commit"}, {"oid": "539584b094952b55d3ac46c2f93d618fd7b872c6", "url": "https://github.com/apache/pulsar/commit/539584b094952b55d3ac46c2f93d618fd7b872c6", "message": "Make Consumer and Producer use an interface instead of directly ServerCnx", "committedDate": "2020-11-12T15:14:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5NzY1NQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522397655", "bodyText": "why do you change it to the default method?", "author": "sijie", "createdAt": "2020-11-12T20:19:22Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarCommandSender.java", "diffHunk": "@@ -26,39 +29,92 @@\n \n public interface PulsarCommandSender {\n \n-\n-    void sendPartitionMetadataResponse(PulsarApi.ServerError error, String errorMsg, long requestId);\n-\n-    void sendPartitionMetadataResponse(int partitions, long requestId);\n-\n-    void sendSuccessResponse(long requestId);\n-\n-    void sendErrorResponse(long requestId, PulsarApi.ServerError error, String message);\n-\n-    void sendProducerSuccessResponse(long requestId, String producerName, SchemaVersion schemaVersion);\n-\n-    void sendProducerSuccessResponse(long requestId, String producerName, long lastSequenceId,\n-                                     SchemaVersion schemaVersion);\n-\n-    void sendSendReceiptResponse(long producerId, long sequenceId, long highestId, long ledgerId,\n-                                 long entryId);\n-\n-    void sendSendError(long producerId, long sequenceId, PulsarApi.ServerError error, String errorMsg);\n-\n-    void sendGetTopicsOfNamespaceResponse(List<String> topics, long requestId);\n-\n-    void sendGetSchemaResponse(long requestId, SchemaInfo schema, SchemaVersion version);\n-\n-    void sendGetSchemaErrorResponse(long requestId, PulsarApi.ServerError error, String errorMessage);\n-\n-    void sendGetOrCreateSchemaResponse(long requestId, SchemaVersion schemaVersion);\n-\n-    void sendGetOrCreateSchemaErrorResponse(long requestId, PulsarApi.ServerError error, String errorMessage);\n-\n-    void sendConnectedResponse(int clientProtocolVersion, int maxMessageSize);\n-\n-    void sendLookupResponse(String brokerServiceUrl, String brokerServiceUrlTls, boolean authoritative,\n-                            PulsarApi.CommandLookupTopicResponse.LookupType response, long requestId, boolean proxyThroughServiceUrl);\n-\n-    void sendLookupResponse(PulsarApi.ServerError error, String errorMsg, long requestId);\n+    default void sendPartitionMetadataResponse(PulsarApi.ServerError error, String errorMsg, long requestId) {", "originalCommit": "539584b094952b55d3ac46c2f93d618fd7b872c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzY0Ng==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522497646", "bodyText": "This way a protocol may or may not implement the method. For instance if some features are not yet supported. Also if new methods are added later, if they have default impl, it will not break dependant handlers.", "author": "cbornet", "createdAt": "2020-11-12T23:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5NzY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMjA1MA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522822050", "bodyText": "I've set it back to non-default. We can see about the interest of default later.", "author": "cbornet", "createdAt": "2020-11-13T09:16:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5NzY1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "8059c2d49e63d37748c34719144ad24247b2b1fe", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarCommandSender.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarCommandSender.java\nindex 5a90a10bca7..141c7c88d0e 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarCommandSender.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/PulsarCommandSender.java\n\n@@ -29,92 +29,50 @@ import java.util.List;\n \n public interface PulsarCommandSender {\n \n-    default void sendPartitionMetadataResponse(PulsarApi.ServerError error, String errorMsg, long requestId) {\n-        // No-op\n-    }\n-\n-    default void sendPartitionMetadataResponse(int partitions, long requestId) {\n-        // No-op\n-    }\n-\n-    default void sendSuccessResponse(long requestId) {\n-        // No-op\n-    }\n-\n-    default void sendErrorResponse(long requestId, PulsarApi.ServerError error, String message) {\n-        // No-op\n-    }\n-\n-    default void sendProducerSuccessResponse(long requestId, String producerName, SchemaVersion schemaVersion) {\n-        // No-op\n-    }\n-\n-    default void sendProducerSuccessResponse(long requestId, String producerName, long lastSequenceId,\n-                                     SchemaVersion schemaVersion) {\n-        // No-op\n-    }\n-\n-    default void sendSendReceiptResponse(long producerId, long sequenceId, long highestId, long ledgerId,\n-                                 long entryId) {\n-        // No-op\n-    }\n-\n-    default void sendSendError(long producerId, long sequenceId, PulsarApi.ServerError error, String errorMsg) {\n-        // No-op\n-    }\n-\n-    default void sendGetTopicsOfNamespaceResponse(List<String> topics, long requestId) {\n-        // No-op\n-    }\n-\n-    default void sendGetSchemaResponse(long requestId, SchemaInfo schema, SchemaVersion version) {\n-        // No-op\n-    }\n-\n-    default void sendGetSchemaErrorResponse(long requestId, PulsarApi.ServerError error, String errorMessage) {\n-        // No-op\n-    }\n-\n-    default void sendGetOrCreateSchemaResponse(long requestId, SchemaVersion schemaVersion) {\n-        // No-op\n-    }\n-\n-    default void sendGetOrCreateSchemaErrorResponse(long requestId, PulsarApi.ServerError error, String errorMessage) {\n-        // No-op\n-    }\n-\n-    default void sendConnectedResponse(int clientProtocolVersion, int maxMessageSize) {\n-        // No-op\n-    }\n-\n-    default void sendLookupResponse(String brokerServiceUrl, String brokerServiceUrlTls, boolean authoritative,\n-                            PulsarApi.CommandLookupTopicResponse.LookupType response, long requestId, boolean proxyThroughServiceUrl) {\n-        // No-op\n-    }\n-\n-    default void sendLookupResponse(PulsarApi.ServerError error, String errorMsg, long requestId) {\n-        // No-op\n-    }\n-\n-    default void sendActiveConsumerChange(long consumerId, boolean isActive) {\n-        // No-op\n-    }\n-\n-    default void sendSuccess(long requestId) {\n-        // No-op\n-    }\n-\n-    default void sendError(long requestId, PulsarApi.ServerError error, String message) {\n-        // No-op\n-    }\n-\n-    default void sendReachedEndOfTopic(long consumerId) {\n-        // No-op\n-    }\n-\n-    default Future<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n+    void sendPartitionMetadataResponse(PulsarApi.ServerError error, String errorMsg, long requestId);\n+\n+    void sendPartitionMetadataResponse(int partitions, long requestId);\n+\n+    void sendSuccessResponse(long requestId);\n+\n+    void sendErrorResponse(long requestId, PulsarApi.ServerError error, String message);\n+\n+    void sendProducerSuccessResponse(long requestId, String producerName, SchemaVersion schemaVersion);\n+\n+    void sendProducerSuccessResponse(long requestId, String producerName, long lastSequenceId,\n+                                     SchemaVersion schemaVersion);\n+\n+    void sendSendReceiptResponse(long producerId, long sequenceId, long highestId, long ledgerId,\n+                                 long entryId);\n+\n+    void sendSendError(long producerId, long sequenceId, PulsarApi.ServerError error, String errorMsg);\n+\n+    void sendGetTopicsOfNamespaceResponse(List<String> topics, long requestId);\n+\n+    void sendGetSchemaResponse(long requestId, SchemaInfo schema, SchemaVersion version);\n+\n+    void sendGetSchemaErrorResponse(long requestId, PulsarApi.ServerError error, String errorMessage);\n+\n+    void sendGetOrCreateSchemaResponse(long requestId, SchemaVersion schemaVersion);\n+\n+    void sendGetOrCreateSchemaErrorResponse(long requestId, PulsarApi.ServerError error, String errorMessage);\n+\n+    void sendConnectedResponse(int clientProtocolVersion, int maxMessageSize);\n+\n+    void sendLookupResponse(String brokerServiceUrl, String brokerServiceUrlTls, boolean authoritative,\n+                            PulsarApi.CommandLookupTopicResponse.LookupType response, long requestId, boolean proxyThroughServiceUrl);\n+\n+    void sendLookupResponse(PulsarApi.ServerError error, String errorMsg, long requestId);\n+\n+    void sendActiveConsumerChange(long consumerId, boolean isActive);\n+\n+    void sendSuccess(long requestId);\n+\n+    void sendError(long requestId, PulsarApi.ServerError error, String message);\n+\n+    void sendReachedEndOfTopic(long consumerId);\n+\n+    Future<Void> sendMessagesToConsumer(long consumerId, String topicName, Subscription subscription,\n             int partitionIdx, final List<Entry> entries, EntryBatchSizes batchSizes, EntryBatchIndexesAcks batchIndexesAcks,\n-            RedeliveryTracker redeliveryTracker) {\n-        return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);\n-    }\n+            RedeliveryTracker redeliveryTracker);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5ODcxMA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522398710", "bodyText": "why do you make this a default method and return null?", "author": "sijie", "createdAt": "2020-11-12T20:20:32Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n+import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n+\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface TransportCnx {\n+\n+    default String getClientVersion() {\n+        return null;", "originalCommit": "539584b094952b55d3ac46c2f93d618fd7b872c6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8059c2d49e63d37748c34719144ad24247b2b1fe", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java\nindex 2231fb2af27..0e8690283f9 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java\n\n@@ -28,9 +28,7 @@ import java.util.concurrent.CompletableFuture;\n \n public interface TransportCnx {\n \n-    default String getClientVersion() {\n-        return null;\n-    }\n+    String getClientVersion();\n \n     SocketAddress clientAddress();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5OTkxMg==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522399912", "bodyText": "Can we please avoid default methods here? Any transport cnx implementation should implement all the following methods. I don't think we should make them default methods. Making them default methods is error-prone.", "author": "sijie", "createdAt": "2020-11-12T20:22:03Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.pulsar.broker.service;\n+\n+import org.apache.bookkeeper.mledger.Entry;\n+import org.apache.pulsar.broker.authentication.AuthenticationDataSource;\n+import org.apache.pulsar.common.api.proto.PulsarApi.ServerError;\n+\n+import java.net.SocketAddress;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface TransportCnx {", "originalCommit": "539584b094952b55d3ac46c2f93d618fd7b872c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjUwNDAyMA==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522504020", "bodyText": "It was for convenience for implementers. For instance if you implement a handler that is only a consuming one, you don't have to worry about the producer related methods. Most of the methods are actually notifications returning void.\nAnyway I can change to non default, no problem.", "author": "cbornet", "createdAt": "2020-11-12T23:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5OTkxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgyMjEyMg==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r522822122", "bodyText": "I've set it back to non-default. We can see about the interest of default later.", "author": "cbornet", "createdAt": "2020-11-13T09:16:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM5OTkxMg=="}], "type": "inlineReview", "revised_code": {"commit": "8059c2d49e63d37748c34719144ad24247b2b1fe", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java\nindex 2231fb2af27..0e8690283f9 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/TransportCnx.java\n\n@@ -28,9 +28,7 @@ import java.util.concurrent.CompletableFuture;\n \n public interface TransportCnx {\n \n-    default String getClientVersion() {\n-        return null;\n-    }\n+    String getClientVersion();\n \n     SocketAddress clientAddress();\n \n"}}, {"oid": "8059c2d49e63d37748c34719144ad24247b2b1fe", "url": "https://github.com/apache/pulsar/commit/8059c2d49e63d37748c34719144ad24247b2b1fe", "message": "Don't use default methods in interfaces", "committedDate": "2020-11-13T09:11:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3NjQ5Ng==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r524776496", "bodyText": "What is the main motivation for this change?", "author": "sijie", "createdAt": "2020-11-16T23:56:43Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java", "diffHunk": "@@ -218,24 +205,20 @@ public boolean readCompacted() {\n      *\n      * @return a SendMessageInfo object that contains the detail of what was sent to consumer\n      */\n-\n-    public ChannelPromise sendMessages(final List<Entry> entries, EntryBatchSizes batchSizes, EntryBatchIndexesAcks batchIndexesAcks,\n+    public Future<Void> sendMessages(final List<Entry> entries, EntryBatchSizes batchSizes, EntryBatchIndexesAcks batchIndexesAcks,\n                int totalMessages, long totalBytes, long totalChunkedMessages, RedeliveryTracker redeliveryTracker) {\n         this.lastConsumedTimestamp = System.currentTimeMillis();\n-        final ChannelHandlerContext ctx = cnx.ctx();\n-        final ChannelPromise writePromise = ctx.newPromise();\n \n         if (entries.isEmpty() || totalMessages == 0) {\n             if (log.isDebugEnabled()) {\n                 log.debug(\"[{}-{}] List of messages is empty, triggering write future immediately for consumerId {}\",\n                         topicName, subscription, consumerId);\n             }\n-            writePromise.setSuccess();\n             batchSizes.recyle();\n             if (batchIndexesAcks != null) {\n                 batchIndexesAcks.recycle();\n             }\n-            return writePromise;\n+            return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);", "originalCommit": "8059c2d49e63d37748c34719144ad24247b2b1fe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkxMzU2MQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r524913561", "bodyText": "It's because protocol handlers may not have a ChannelHandlerContext to create a ChannelPromise from (eg. in gRPC you don't have direct access to the Netty channel).", "author": "cbornet", "createdAt": "2020-11-17T06:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkxNTYwNQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r524915605", "bodyText": "I can move this part of code to the cnx delegate if you prefer (so there won't be any change for the regular ServerCnx/PulsarCommandSenderImpl).", "author": "cbornet", "createdAt": "2020-11-17T06:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE0MTY5MQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r525141691", "bodyText": "The code below is really tied to the Consumer so it cannot be moved to the PulsarCommandSender.", "author": "cbornet", "createdAt": "2020-11-17T13:11:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3NjQ5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2NjcxMQ==", "url": "https://github.com/apache/pulsar/pull/6720#discussion_r525166711", "bodyText": "I added a newPromise method to TransportCnx which ServerCnx implements with ctx.newPromise() so there's no change in how it works for the regular ServerCnx.", "author": "cbornet", "createdAt": "2020-11-17T13:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3NjQ5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "319b663c25bbd7de835adef2e439797cc453b8ac", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\nindex d82c6b8fbc7..ea6e215d0f9 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/service/Consumer.java\n\n@@ -218,7 +218,9 @@ public class Consumer {\n             if (batchIndexesAcks != null) {\n                 batchIndexesAcks.recycle();\n             }\n-            return ImmediateEventExecutor.INSTANCE.newSucceededFuture(null);\n+            final Promise<Void> writePromise = cnx.newPromise();\n+            writePromise.setSuccess(null);\n+            return writePromise;\n         }\n \n         // Note\n"}}, {"oid": "319b663c25bbd7de835adef2e439797cc453b8ac", "url": "https://github.com/apache/pulsar/commit/319b663c25bbd7de835adef2e439797cc453b8ac", "message": "Add newPromise method to TransportCnx", "committedDate": "2020-11-17T13:41:15Z", "type": "commit"}]}