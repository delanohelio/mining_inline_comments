{"pr_number": 6383, "pr_title": "[Issue 6043] Support force deleting subscription", "pr_createdAt": "2020-02-20T15:45:12Z", "pr_url": "https://github.com/apache/pulsar/pull/6383", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4ODg4NQ==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r382888885", "bodyText": "This will be a flaky test since the consumer can create a subscription when they reconnect to the broker.", "author": "codelipenghui", "createdAt": "2020-02-22T05:44:04Z", "path": "pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest.java", "diffHunk": "@@ -1304,6 +1304,46 @@ public void testNamespaceBundleUnload(Integer numBundles) throws Exception {\n         admin.topics().delete(\"persistent://prop-xyz/ns1-bundles/ds2\");\n     }\n \n+    @Test(dataProvider = \"topicName\")\n+    public void testDeleteSubscription(String topicName) throws Exception {\n+        final String subName = topicName;\n+        final String persistentTopicName = \"persistent://prop-xyz/ns1/\" + topicName;\n+\n+        // create a topic and produce some messages\n+        publishMessagesOnPersistentTopic(\"persistent://prop-xyz/ns1/\" + topicName, 5);\n+        assertEquals(admin.topics().getList(\"prop-xyz/ns1\"),\n+            Lists.newArrayList(\"persistent://prop-xyz/ns1/\" + topicName));\n+\n+        // create consumer and subscription\n+        PulsarClient client = PulsarClient.builder()\n+            .serviceUrl(pulsar.getWebServiceAddress())\n+            .statsInterval(0, TimeUnit.SECONDS)\n+            .build();\n+        Consumer<byte[]> consumer = client.newConsumer().topic(persistentTopicName).subscriptionName(subName)\n+            .subscriptionType(SubscriptionType.Exclusive).subscribe();\n+\n+        assertEquals(admin.topics().getSubscriptions(persistentTopicName), Lists.newArrayList(subName));\n+\n+        // try to delete the subscription with a connected consumer\n+        try {\n+            admin.topics().deleteSubscription(persistentTopicName, subName);\n+            fail(\"should have failed\");\n+        } catch (PulsarAdminException.PreconditionFailedException e) {\n+            assertEquals(e.getStatusCode(), Status.PRECONDITION_FAILED.getStatusCode());\n+        }\n+\n+        // failed to delete the subscription\n+        assertEquals(admin.topics().getSubscriptions(persistentTopicName), Lists.newArrayList(subName));\n+\n+        // try to delete the subscription with a connected consumer forcefully\n+        admin.topics().deleteSubscription(persistentTopicName, subName, true);\n+\n+        // delete the subscription successfully\n+        assertEquals(admin.topics().getSubscriptions(persistentTopicName).size(), 0);", "originalCommit": "09e62b47cc0a2cb5a3d100d26200a13a75922e46", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwMDYxOQ==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r382900619", "bodyText": "yes, maybe we can disable this line in this pr first and then refine it later when the ability to disable the subscription auto-creation is available?", "author": "murong00", "createdAt": "2020-02-22T09:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4ODg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA2Njg4NA==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r388066884", "bodyText": "I hava fixed the unit test to cover this.", "author": "murong00", "createdAt": "2020-03-05T03:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjg4ODg4NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f3265040817ac985410292ee55e86567e1f90cfc", "chunk": "diff --git a/pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest.java b/pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest.java\nindex 338dc11b6ab..970626314d0 100644\n--- a/pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest.java\n+++ b/pulsar-broker/src/test/java/org/apache/pulsar/broker/admin/AdminApiTest.java\n\n@@ -1339,7 +1339,7 @@ public class AdminApiTest extends MockedPulsarServiceBaseTest {\n         admin.topics().deleteSubscription(persistentTopicName, subName, true);\n \n         // delete the subscription successfully\n-        assertEquals(admin.topics().getSubscriptions(persistentTopicName).size(), 0);\n+        // assertEquals(admin.topics().getSubscriptions(persistentTopicName).size(), 0);\n \n         client.close();\n     }\n"}}, {"oid": "f3265040817ac985410292ee55e86567e1f90cfc", "url": "https://github.com/apache/pulsar/commit/f3265040817ac985410292ee55e86567e1f90cfc", "message": "Fix a flaky test", "committedDate": "2020-02-25T07:13:00Z", "type": "forcePushed"}, {"oid": "7ec207d019ef687e6d5540d42380635ecfa94809", "url": "https://github.com/apache/pulsar/commit/7ec207d019ef687e6d5540d42380635ecfa94809", "message": "Improve the unit test to cover force deleting", "committedDate": "2020-03-05T03:55:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3OTgwMw==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r388279803", "bodyText": "Should handle exception here since we need to resume the asyncResponse", "author": "codelipenghui", "createdAt": "2020-03-05T13:05:06Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -1032,6 +1040,73 @@ private void internalDeleteSubscriptionForNonPartitionedTopic(AsyncResponse asyn\n         }\n     }\n \n+    protected void internalDeleteSubscriptionForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n+        if (topicName.isGlobal()) {\n+            validateGlobalNamespaceOwnership(namespaceName);\n+        }\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n+            if (partitionMetadata.partitions > 0) {\n+                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                    TopicName topicNamePartition = topicName.getPartition(i);\n+                    try {\n+                        futures.add(pulsar().getAdminClient().topics()\n+                            .deleteSubscriptionAsync(topicNamePartition.toString(), subName, true));\n+                    } catch (Exception e) {\n+                        log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicNamePartition, subName,\n+                            e);\n+                        asyncResponse.resume(new RestException(e));\n+                        return;\n+                    }\n+                }\n+\n+                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                    if (exception != null) {\n+                        Throwable t = exception.getCause();\n+                        if (t instanceof NotFoundException) {\n+                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                            return null;\n+                        } else {\n+                            log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicName, subName, t);\n+                            asyncResponse.resume(new RestException(t));\n+                            return null;\n+                        }\n+                    }\n+\n+                    asyncResponse.resume(Response.noContent().build());\n+                    return null;\n+                });\n+            } else {\n+                internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n+            }\n+        }\n+    }\n+\n+    private void internalDeleteSubscriptionForNonPartitionedTopicForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n+        validateAdminAccessForSubscriber(subName, authoritative);", "originalCommit": "7ec207d019ef687e6d5540d42380635ecfa94809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM0NDA3MQ==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r389344071", "bodyText": "done.", "author": "murong00", "createdAt": "2020-03-08T07:40:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3OTgwMw=="}], "type": "inlineReview", "revised_code": {"commit": "d9b461cc771cfe485959ba8ada764858eda7a65e", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex fcf9aad8d4f..685d1952535 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -861,327 +924,304 @@ public class PersistentTopicsBase extends AdminResource {\n \n     protected void internalGetPartitionedStats(AsyncResponse asyncResponse, boolean authoritative,\n             boolean perPartition, boolean getPreciseBacklog) {\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions == 0) {\n-            throw new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\");\n-        }\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n-        }\n-        PartitionedTopicStats stats = new PartitionedTopicStats(partitionMetadata);\n-\n-        List<CompletableFuture<TopicStats>> topicStatsFutureList = Lists.newArrayList();\n-        for (int i = 0; i < partitionMetadata.partitions; i++) {\n             try {\n-                topicStatsFutureList\n-                        .add(pulsar().getAdminClient().topics().getStatsAsync((topicName.getPartition(i).toString()), getPreciseBacklog));\n-            } catch (PulsarServerException e) {\n-                asyncResponse.resume(new RestException(e));\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to get partitioned stats for {}\", clientAppId(), topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n                 return;\n             }\n         }\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+            if (partitionMetadata.partitions == 0) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\"));\n+                return;\n+            }\n+            PartitionedTopicStats stats = new PartitionedTopicStats(partitionMetadata);\n+            List<CompletableFuture<TopicStats>> topicStatsFutureList = Lists.newArrayList();\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                try {\n+                    topicStatsFutureList\n+                            .add(pulsar().getAdminClient().topics().getStatsAsync((topicName.getPartition(i).toString()), getPreciseBacklog));\n+                } catch (PulsarServerException e) {\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+            }\n \n-        FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n-            CompletableFuture<TopicStats> statFuture = null;\n-            for (int i = 0; i < topicStatsFutureList.size(); i++) {\n-                statFuture = topicStatsFutureList.get(i);\n-                if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n-                    try {\n-                        stats.add(statFuture.get());\n-                        if (perPartition) {\n-                            stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n+            FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n+                CompletableFuture<TopicStats> statFuture = null;\n+                for (int i = 0; i < topicStatsFutureList.size(); i++) {\n+                    statFuture = topicStatsFutureList.get(i);\n+                    if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n+                        try {\n+                            stats.add(statFuture.get());\n+                            if (perPartition) {\n+                                stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n+                            }\n+                        } catch (Exception e) {\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n                         }\n-                    } catch (Exception e) {\n-                        asyncResponse.resume(new RestException(e));\n-                        return null;\n                     }\n                 }\n-            }\n-            if (perPartition && stats.partitions.isEmpty()) {\n-                String path = ZkAdminPaths.partitionedTopicPath(topicName);\n-                try {\n-                    boolean zkPathExists = zkPathExists(path);\n-                    if (zkPathExists) {\n-                        stats.partitions.put(topicName.toString(), new TopicStats());\n-                    } else {\n-                        asyncResponse.resume(\n-                                new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+                if (perPartition && stats.partitions.isEmpty()) {\n+                    String path = ZkAdminPaths.partitionedTopicPath(topicName);\n+                    try {\n+                        boolean zkPathExists = zkPathExists(path);\n+                        if (zkPathExists) {\n+                            stats.partitions.put(topicName.toString(), new TopicStats());\n+                        } else {\n+                            asyncResponse.resume(\n+                                    new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+                            return null;\n+                        }\n+                    } catch (KeeperException | InterruptedException e) {\n+                        asyncResponse.resume(new RestException(e));\n                         return null;\n                     }\n-                } catch (KeeperException | InterruptedException e) {\n-                    asyncResponse.resume(new RestException(e));\n-                    return null;\n                 }\n-            }\n-            asyncResponse.resume(stats);\n+                asyncResponse.resume(stats);\n+                return null;\n+            });\n+        }).exceptionally(ex -> {\n+            log.error(\"[{}] Failed to get partitioned stats for {}\", clientAppId(), topicName, ex);\n+            resumeAsyncResponseExceptionally(asyncResponse, ex);\n             return null;\n         });\n     }\n \n     protected void internalGetPartitionedStatsInternal(AsyncResponse asyncResponse, boolean authoritative) {\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions == 0) {\n-            throw new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\");\n-        }\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n-        }\n-        PartitionedTopicInternalStats stats = new PartitionedTopicInternalStats(partitionMetadata);\n-\n-        List<CompletableFuture<PersistentTopicInternalStats>> topicStatsFutureList = Lists.newArrayList();\n-        for (int i = 0; i < partitionMetadata.partitions; i++) {\n             try {\n-                topicStatsFutureList.add(pulsar().getAdminClient().topics()\n-                        .getInternalStatsAsync((topicName.getPartition(i).toString())));\n-            } catch (PulsarServerException e) {\n-                asyncResponse.resume(new RestException(e));\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to get partitioned internal stats for {}\", clientAppId(), topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n                 return;\n             }\n         }\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+            if (partitionMetadata.partitions == 0) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\"));\n+                return;\n+            }\n \n-        FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n-            CompletableFuture<PersistentTopicInternalStats> statFuture = null;\n-            for (int i = 0; i < topicStatsFutureList.size(); i++) {\n-                statFuture = topicStatsFutureList.get(i);\n-                if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n-                    try {\n-                        stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n-                    } catch (Exception e) {\n-                        asyncResponse.resume(new RestException(e));\n-                        return null;\n-                    }\n+            PartitionedTopicInternalStats stats = new PartitionedTopicInternalStats(partitionMetadata);\n+\n+            List<CompletableFuture<PersistentTopicInternalStats>> topicStatsFutureList = Lists.newArrayList();\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                try {\n+                    topicStatsFutureList.add(pulsar().getAdminClient().topics()\n+                            .getInternalStatsAsync((topicName.getPartition(i).toString())));\n+                } catch (PulsarServerException e) {\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n                 }\n             }\n-            asyncResponse.resume(!stats.partitions.isEmpty() ? stats\n-                    : new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+\n+            FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n+                CompletableFuture<PersistentTopicInternalStats> statFuture = null;\n+                for (int i = 0; i < topicStatsFutureList.size(); i++) {\n+                    statFuture = topicStatsFutureList.get(i);\n+                    if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n+                        try {\n+                            stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n+                        } catch (Exception e) {\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n+                        }\n+                    }\n+                }\n+                asyncResponse.resume(!stats.partitions.isEmpty() ? stats\n+                        : new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+                return null;\n+            });\n+        }).exceptionally(ex -> {\n+            log.error(\"[{}] Failed to get partitioned internal stats for {}\", clientAppId(), topicName, ex);\n+            resumeAsyncResponseExceptionally(asyncResponse, ex);\n             return null;\n         });\n     }\n \n-    protected void internalDeleteSubscription(AsyncResponse asyncResponse, String subName, boolean authoritative, boolean force) {\n-        if (force) {\n-            internalDeleteSubscriptionForcefully(asyncResponse, subName, authoritative);\n-        } else {\n-            internalDeleteSubscription(asyncResponse, subName, authoritative);\n-        }\n-    }\n-\n     protected void internalDeleteSubscription(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n+            try {\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to delete subscription {} from topic {}\", clientAppId(), subName, topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n+                return;\n+            }\n         }\n         // If the topic name is a partition name, no need to get partition topic metadata again\n         if (topicName.isPartitioned()) {\n             internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n         } else {\n-            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-            if (partitionMetadata.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+            getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+                if (partitionMetadata.partitions > 0) {\n+                    final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-                for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics()\n-                            .deleteSubscriptionAsync(topicNamePartition.toString(), subName, false));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicNamePartition, subName,\n-                            e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n+                    for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                        TopicName topicNamePartition = topicName.getPartition(i);\n+                        try {\n+                            futures.add(pulsar().getAdminClient().topics()\n+                                    .deleteSubscriptionAsync(topicNamePartition.toString(), subName));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicNamePartition, subName,\n+                                    e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return;\n+                        }\n                     }\n-                }\n \n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable t = exception.getCause();\n-                        if (t instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                            return null;\n-                        } else if (t instanceof PreconditionFailedException) {\n-                            asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n-                                \"Subscription has active connected consumers\"));\n-                            return null;\n-                        } else {\n-                            log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, t);\n-                            asyncResponse.resume(new RestException(t));\n-                            return null;\n+                    FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                        if (exception != null) {\n+                            Throwable t = exception.getCause();\n+                            if (t instanceof NotFoundException) {\n+                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                                return null;\n+                            } else if (t instanceof PreconditionFailedException) {\n+                                asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n+                                        \"Subscription has active connected consumers\"));\n+                                return null;\n+                            } else {\n+                                log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, t);\n+                                asyncResponse.resume(new RestException(t));\n+                                return null;\n+                            }\n                         }\n-                    }\n \n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n-            }\n+                        asyncResponse.resume(Response.noContent().build());\n+                        return null;\n+                    });\n+                } else {\n+                    internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+                }\n+            }).exceptionally(ex -> {\n+                log.error(\"[{}] Failed to delete subscription {} from topic {}\", clientAppId(), subName, topicName, ex);\n+                resumeAsyncResponseExceptionally(asyncResponse, ex);\n+                return null;\n+            });\n         }\n     }\n \n     private void internalDeleteSubscriptionForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        validateAdminAccessForSubscriber(subName, authoritative);\n-        Topic topic = getTopicReference(topicName);\n         try {\n+            validateAdminAccessForSubscriber(subName, authoritative);\n+            Topic topic = getTopicReference(topicName);\n             Subscription sub = topic.getSubscription(subName);\n-            checkNotNull(sub);\n+            if (sub == null) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                return;\n+            }\n             sub.delete().get();\n             log.info(\"[{}][{}] Deleted subscription {}\", clientAppId(), topicName, subName);\n             asyncResponse.resume(Response.noContent().build());\n         } catch (Exception e) {\n-            Throwable t = e.getCause();\n-            if (e instanceof NullPointerException) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-            } else if (t instanceof SubscriptionBusyException) {\n+            log.error(\"[{}] Failed to delete subscription {} from topic {}\", clientAppId(), subName, topicName, e);\n+            if (e.getCause() instanceof SubscriptionBusyException) {\n                 asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n                     \"Subscription has active connected consumers\"));\n+            } else if (e instanceof WebApplicationException) {\n+                asyncResponse.resume(e);\n             } else {\n                 log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, e);\n-                asyncResponse.resume(new RestException(t));\n-            }\n-        }\n-    }\n-\n-    protected void internalDeleteSubscriptionForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n-        }\n-        // If the topic name is a partition name, no need to get partition topic metadata again\n-        if (topicName.isPartitioned()) {\n-            internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n-        } else {\n-            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-            if (partitionMetadata.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics()\n-                            .deleteSubscriptionAsync(topicNamePartition.toString(), subName, true));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicNamePartition, subName,\n-                            e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n-                    }\n-                }\n-\n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable t = exception.getCause();\n-                        if (t instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                            return null;\n-                        } else {\n-                            log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicName, subName, t);\n-                            asyncResponse.resume(new RestException(t));\n-                            return null;\n-                        }\n-                    }\n-\n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n-            }\n-        }\n-    }\n-\n-    private void internalDeleteSubscriptionForNonPartitionedTopicForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        validateAdminAccessForSubscriber(subName, authoritative);\n-        Topic topic = getTopicReference(topicName);\n-        try {\n-            Subscription sub = topic.getSubscription(subName);\n-            checkNotNull(sub);\n-            sub.deleteForcefully().get();\n-            log.info(\"[{}][{}] Deleted subscription forcefully {}\", clientAppId(), topicName, subName);\n-            asyncResponse.resume(Response.noContent().build());\n-        } catch (Exception e) {\n-            Throwable t = e.getCause();\n-            if (e instanceof NullPointerException) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-            } else {\n-                log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicName, subName, e);\n-                asyncResponse.resume(new RestException(t));\n+                asyncResponse.resume(new RestException(e));\n             }\n         }\n     }\n \n     protected void internalSkipAllMessages(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n+            try {\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to skip all messages for subscription {} on topic {}\", clientAppId(), subName, topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n+                return;\n+            }\n         }\n         // If the topic name is a partition name, no need to get partition topic metadata again\n         if (topicName.isPartitioned()) {\n             internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n-        } else {\n-            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-            if (partitionMetadata.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics().skipAllMessagesAsync(topicNamePartition.toString(),\n-                            subName));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicNamePartition, subName, e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n-                    }\n-                }\n-\n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable t = exception.getCause();\n-                        if (t instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                            return null;\n-                        } else {\n-                            log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, t);\n-                            asyncResponse.resume(new RestException(t));\n-                            return null;\n+        } else {\n+            getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+                if (partitionMetadata.partitions > 0) {\n+                    final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                    for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                        TopicName topicNamePartition = topicName.getPartition(i);\n+                        try {\n+                            futures.add(pulsar().getAdminClient().topics().skipAllMessagesAsync(topicNamePartition.toString(),\n+                                    subName));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicNamePartition, subName, e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return;\n                         }\n                     }\n \n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n-            }\n+                    FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                        if (exception != null) {\n+                            Throwable t = exception.getCause();\n+                            if (t instanceof NotFoundException) {\n+                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                                return null;\n+                            } else {\n+                                log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, t);\n+                                asyncResponse.resume(new RestException(t));\n+                                return null;\n+                            }\n+                        }\n+\n+                        asyncResponse.resume(Response.noContent().build());\n+                        return null;\n+                    });\n+                } else {\n+                    internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+                }\n+            }).exceptionally(ex -> {\n+                log.error(\"[{}] Failed to skip all messages for subscription {} on topic {}\", clientAppId(), subName, topicName, ex);\n+                resumeAsyncResponseExceptionally(asyncResponse, ex);\n+               return null;\n+            });\n         }\n     }\n \n     private void internalSkipAllMessagesForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        validateAdminAccessForSubscriber(subName, authoritative);\n-        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n-        BiConsumer<Void, Throwable> biConsumer = (v, ex) -> {\n-            if (ex != null) {\n-                asyncResponse.resume(new RestException(ex));\n-                log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, ex);\n-            } else {\n-                asyncResponse.resume(Response.noContent().build());\n-                log.info(\"[{}] Cleared backlog on {} {}\", clientAppId(), topicName, subName);\n-            }\n-        };\n         try {\n+            validateAdminAccessForSubscriber(subName, authoritative);\n+            PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n+            BiConsumer<Void, Throwable> biConsumer = (v, ex) -> {\n+                if (ex != null) {\n+                    asyncResponse.resume(new RestException(ex));\n+                    log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, ex);\n+                } else {\n+                    asyncResponse.resume(Response.noContent().build());\n+                    log.info(\"[{}] Cleared backlog on {} {}\", clientAppId(), topicName, subName);\n+                }\n+            };\n             if (subName.startsWith(topic.getReplicatorPrefix())) {\n                 String remoteCluster = PersistentReplicator.getRemoteCluster(subName);\n                 PersistentReplicator repl = (PersistentReplicator) topic.getPersistentReplicator(remoteCluster);\n-                checkNotNull(repl);\n+                if (repl == null) {\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                    return;\n+                }\n                 repl.clearBacklog().whenComplete(biConsumer);\n             } else {\n                 PersistentSubscription sub = topic.getSubscription(subName);\n-                checkNotNull(sub);\n+                if (sub == null) {\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                    return;\n+                }\n                 sub.clearBacklog().whenComplete(biConsumer);\n             }\n         } catch (Exception e) {\n-            if (e instanceof NullPointerException) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-            } else {\n-                asyncResponse.resume(new RestException(e));\n-            }\n+            log.error(\"[{}] Failed to skip all messages for subscription {} on topic {}\", clientAppId(), subName, topicName, e);\n+            resumeAsyncResponseExceptionally(asyncResponse, e);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MzUyOQ==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r388283529", "bodyText": "Should handle exception here since we need to resume the asyncResponse", "author": "codelipenghui", "createdAt": "2020-03-05T13:12:53Z", "path": "pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java", "diffHunk": "@@ -1032,6 +1040,73 @@ private void internalDeleteSubscriptionForNonPartitionedTopic(AsyncResponse asyn\n         }\n     }\n \n+    protected void internalDeleteSubscriptionForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n+        if (topicName.isGlobal()) {\n+            validateGlobalNamespaceOwnership(namespaceName);\n+        }\n+        // If the topic name is a partition name, no need to get partition topic metadata again\n+        if (topicName.isPartitioned()) {\n+            internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n+        } else {\n+            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);", "originalCommit": "7ec207d019ef687e6d5540d42380635ecfa94809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM0NDA3NQ==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r389344075", "bodyText": "done.", "author": "murong00", "createdAt": "2020-03-08T07:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI4MzUyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "d9b461cc771cfe485959ba8ada764858eda7a65e", "chunk": "diff --git a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\nindex fcf9aad8d4f..685d1952535 100644\n--- a/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n+++ b/pulsar-broker/src/main/java/org/apache/pulsar/broker/admin/impl/PersistentTopicsBase.java\n\n@@ -861,327 +924,304 @@ public class PersistentTopicsBase extends AdminResource {\n \n     protected void internalGetPartitionedStats(AsyncResponse asyncResponse, boolean authoritative,\n             boolean perPartition, boolean getPreciseBacklog) {\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions == 0) {\n-            throw new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\");\n-        }\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n-        }\n-        PartitionedTopicStats stats = new PartitionedTopicStats(partitionMetadata);\n-\n-        List<CompletableFuture<TopicStats>> topicStatsFutureList = Lists.newArrayList();\n-        for (int i = 0; i < partitionMetadata.partitions; i++) {\n             try {\n-                topicStatsFutureList\n-                        .add(pulsar().getAdminClient().topics().getStatsAsync((topicName.getPartition(i).toString()), getPreciseBacklog));\n-            } catch (PulsarServerException e) {\n-                asyncResponse.resume(new RestException(e));\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to get partitioned stats for {}\", clientAppId(), topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n                 return;\n             }\n         }\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+            if (partitionMetadata.partitions == 0) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\"));\n+                return;\n+            }\n+            PartitionedTopicStats stats = new PartitionedTopicStats(partitionMetadata);\n+            List<CompletableFuture<TopicStats>> topicStatsFutureList = Lists.newArrayList();\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                try {\n+                    topicStatsFutureList\n+                            .add(pulsar().getAdminClient().topics().getStatsAsync((topicName.getPartition(i).toString()), getPreciseBacklog));\n+                } catch (PulsarServerException e) {\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n+                }\n+            }\n \n-        FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n-            CompletableFuture<TopicStats> statFuture = null;\n-            for (int i = 0; i < topicStatsFutureList.size(); i++) {\n-                statFuture = topicStatsFutureList.get(i);\n-                if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n-                    try {\n-                        stats.add(statFuture.get());\n-                        if (perPartition) {\n-                            stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n+            FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n+                CompletableFuture<TopicStats> statFuture = null;\n+                for (int i = 0; i < topicStatsFutureList.size(); i++) {\n+                    statFuture = topicStatsFutureList.get(i);\n+                    if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n+                        try {\n+                            stats.add(statFuture.get());\n+                            if (perPartition) {\n+                                stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n+                            }\n+                        } catch (Exception e) {\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n                         }\n-                    } catch (Exception e) {\n-                        asyncResponse.resume(new RestException(e));\n-                        return null;\n                     }\n                 }\n-            }\n-            if (perPartition && stats.partitions.isEmpty()) {\n-                String path = ZkAdminPaths.partitionedTopicPath(topicName);\n-                try {\n-                    boolean zkPathExists = zkPathExists(path);\n-                    if (zkPathExists) {\n-                        stats.partitions.put(topicName.toString(), new TopicStats());\n-                    } else {\n-                        asyncResponse.resume(\n-                                new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+                if (perPartition && stats.partitions.isEmpty()) {\n+                    String path = ZkAdminPaths.partitionedTopicPath(topicName);\n+                    try {\n+                        boolean zkPathExists = zkPathExists(path);\n+                        if (zkPathExists) {\n+                            stats.partitions.put(topicName.toString(), new TopicStats());\n+                        } else {\n+                            asyncResponse.resume(\n+                                    new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+                            return null;\n+                        }\n+                    } catch (KeeperException | InterruptedException e) {\n+                        asyncResponse.resume(new RestException(e));\n                         return null;\n                     }\n-                } catch (KeeperException | InterruptedException e) {\n-                    asyncResponse.resume(new RestException(e));\n-                    return null;\n                 }\n-            }\n-            asyncResponse.resume(stats);\n+                asyncResponse.resume(stats);\n+                return null;\n+            });\n+        }).exceptionally(ex -> {\n+            log.error(\"[{}] Failed to get partitioned stats for {}\", clientAppId(), topicName, ex);\n+            resumeAsyncResponseExceptionally(asyncResponse, ex);\n             return null;\n         });\n     }\n \n     protected void internalGetPartitionedStatsInternal(AsyncResponse asyncResponse, boolean authoritative) {\n-        PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-        if (partitionMetadata.partitions == 0) {\n-            throw new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\");\n-        }\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n-        }\n-        PartitionedTopicInternalStats stats = new PartitionedTopicInternalStats(partitionMetadata);\n-\n-        List<CompletableFuture<PersistentTopicInternalStats>> topicStatsFutureList = Lists.newArrayList();\n-        for (int i = 0; i < partitionMetadata.partitions; i++) {\n             try {\n-                topicStatsFutureList.add(pulsar().getAdminClient().topics()\n-                        .getInternalStatsAsync((topicName.getPartition(i).toString())));\n-            } catch (PulsarServerException e) {\n-                asyncResponse.resume(new RestException(e));\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to get partitioned internal stats for {}\", clientAppId(), topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n                 return;\n             }\n         }\n+        getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+            if (partitionMetadata.partitions == 0) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Partitioned Topic not found\"));\n+                return;\n+            }\n \n-        FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n-            CompletableFuture<PersistentTopicInternalStats> statFuture = null;\n-            for (int i = 0; i < topicStatsFutureList.size(); i++) {\n-                statFuture = topicStatsFutureList.get(i);\n-                if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n-                    try {\n-                        stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n-                    } catch (Exception e) {\n-                        asyncResponse.resume(new RestException(e));\n-                        return null;\n-                    }\n+            PartitionedTopicInternalStats stats = new PartitionedTopicInternalStats(partitionMetadata);\n+\n+            List<CompletableFuture<PersistentTopicInternalStats>> topicStatsFutureList = Lists.newArrayList();\n+            for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                try {\n+                    topicStatsFutureList.add(pulsar().getAdminClient().topics()\n+                            .getInternalStatsAsync((topicName.getPartition(i).toString())));\n+                } catch (PulsarServerException e) {\n+                    asyncResponse.resume(new RestException(e));\n+                    return;\n                 }\n             }\n-            asyncResponse.resume(!stats.partitions.isEmpty() ? stats\n-                    : new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+\n+            FutureUtil.waitForAll(topicStatsFutureList).handle((result, exception) -> {\n+                CompletableFuture<PersistentTopicInternalStats> statFuture = null;\n+                for (int i = 0; i < topicStatsFutureList.size(); i++) {\n+                    statFuture = topicStatsFutureList.get(i);\n+                    if (statFuture.isDone() && !statFuture.isCompletedExceptionally()) {\n+                        try {\n+                            stats.partitions.put(topicName.getPartition(i).toString(), statFuture.get());\n+                        } catch (Exception e) {\n+                            asyncResponse.resume(new RestException(e));\n+                            return null;\n+                        }\n+                    }\n+                }\n+                asyncResponse.resume(!stats.partitions.isEmpty() ? stats\n+                        : new RestException(Status.NOT_FOUND, \"Internal topics have not been generated yet\"));\n+                return null;\n+            });\n+        }).exceptionally(ex -> {\n+            log.error(\"[{}] Failed to get partitioned internal stats for {}\", clientAppId(), topicName, ex);\n+            resumeAsyncResponseExceptionally(asyncResponse, ex);\n             return null;\n         });\n     }\n \n-    protected void internalDeleteSubscription(AsyncResponse asyncResponse, String subName, boolean authoritative, boolean force) {\n-        if (force) {\n-            internalDeleteSubscriptionForcefully(asyncResponse, subName, authoritative);\n-        } else {\n-            internalDeleteSubscription(asyncResponse, subName, authoritative);\n-        }\n-    }\n-\n     protected void internalDeleteSubscription(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n+            try {\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to delete subscription {} from topic {}\", clientAppId(), subName, topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n+                return;\n+            }\n         }\n         // If the topic name is a partition name, no need to get partition topic metadata again\n         if (topicName.isPartitioned()) {\n             internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n         } else {\n-            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-            if (partitionMetadata.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+            getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+                if (partitionMetadata.partitions > 0) {\n+                    final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n \n-                for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics()\n-                            .deleteSubscriptionAsync(topicNamePartition.toString(), subName, false));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicNamePartition, subName,\n-                            e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n+                    for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                        TopicName topicNamePartition = topicName.getPartition(i);\n+                        try {\n+                            futures.add(pulsar().getAdminClient().topics()\n+                                    .deleteSubscriptionAsync(topicNamePartition.toString(), subName));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicNamePartition, subName,\n+                                    e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return;\n+                        }\n                     }\n-                }\n \n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable t = exception.getCause();\n-                        if (t instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                            return null;\n-                        } else if (t instanceof PreconditionFailedException) {\n-                            asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n-                                \"Subscription has active connected consumers\"));\n-                            return null;\n-                        } else {\n-                            log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, t);\n-                            asyncResponse.resume(new RestException(t));\n-                            return null;\n+                    FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                        if (exception != null) {\n+                            Throwable t = exception.getCause();\n+                            if (t instanceof NotFoundException) {\n+                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                                return null;\n+                            } else if (t instanceof PreconditionFailedException) {\n+                                asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n+                                        \"Subscription has active connected consumers\"));\n+                                return null;\n+                            } else {\n+                                log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, t);\n+                                asyncResponse.resume(new RestException(t));\n+                                return null;\n+                            }\n                         }\n-                    }\n \n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n-            }\n+                        asyncResponse.resume(Response.noContent().build());\n+                        return null;\n+                    });\n+                } else {\n+                    internalDeleteSubscriptionForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+                }\n+            }).exceptionally(ex -> {\n+                log.error(\"[{}] Failed to delete subscription {} from topic {}\", clientAppId(), subName, topicName, ex);\n+                resumeAsyncResponseExceptionally(asyncResponse, ex);\n+                return null;\n+            });\n         }\n     }\n \n     private void internalDeleteSubscriptionForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        validateAdminAccessForSubscriber(subName, authoritative);\n-        Topic topic = getTopicReference(topicName);\n         try {\n+            validateAdminAccessForSubscriber(subName, authoritative);\n+            Topic topic = getTopicReference(topicName);\n             Subscription sub = topic.getSubscription(subName);\n-            checkNotNull(sub);\n+            if (sub == null) {\n+                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                return;\n+            }\n             sub.delete().get();\n             log.info(\"[{}][{}] Deleted subscription {}\", clientAppId(), topicName, subName);\n             asyncResponse.resume(Response.noContent().build());\n         } catch (Exception e) {\n-            Throwable t = e.getCause();\n-            if (e instanceof NullPointerException) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-            } else if (t instanceof SubscriptionBusyException) {\n+            log.error(\"[{}] Failed to delete subscription {} from topic {}\", clientAppId(), subName, topicName, e);\n+            if (e.getCause() instanceof SubscriptionBusyException) {\n                 asyncResponse.resume(new RestException(Status.PRECONDITION_FAILED,\n                     \"Subscription has active connected consumers\"));\n+            } else if (e instanceof WebApplicationException) {\n+                asyncResponse.resume(e);\n             } else {\n                 log.error(\"[{}] Failed to delete subscription {} {}\", clientAppId(), topicName, subName, e);\n-                asyncResponse.resume(new RestException(t));\n-            }\n-        }\n-    }\n-\n-    protected void internalDeleteSubscriptionForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n-        }\n-        // If the topic name is a partition name, no need to get partition topic metadata again\n-        if (topicName.isPartitioned()) {\n-            internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n-        } else {\n-            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-            if (partitionMetadata.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics()\n-                            .deleteSubscriptionAsync(topicNamePartition.toString(), subName, true));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicNamePartition, subName,\n-                            e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n-                    }\n-                }\n-\n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable t = exception.getCause();\n-                        if (t instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                            return null;\n-                        } else {\n-                            log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicName, subName, t);\n-                            asyncResponse.resume(new RestException(t));\n-                            return null;\n-                        }\n-                    }\n-\n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                internalDeleteSubscriptionForNonPartitionedTopicForcefully(asyncResponse, subName, authoritative);\n-            }\n-        }\n-    }\n-\n-    private void internalDeleteSubscriptionForNonPartitionedTopicForcefully(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        validateAdminAccessForSubscriber(subName, authoritative);\n-        Topic topic = getTopicReference(topicName);\n-        try {\n-            Subscription sub = topic.getSubscription(subName);\n-            checkNotNull(sub);\n-            sub.deleteForcefully().get();\n-            log.info(\"[{}][{}] Deleted subscription forcefully {}\", clientAppId(), topicName, subName);\n-            asyncResponse.resume(Response.noContent().build());\n-        } catch (Exception e) {\n-            Throwable t = e.getCause();\n-            if (e instanceof NullPointerException) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-            } else {\n-                log.error(\"[{}] Failed to delete subscription forcefully {} {}\", clientAppId(), topicName, subName, e);\n-                asyncResponse.resume(new RestException(t));\n+                asyncResponse.resume(new RestException(e));\n             }\n         }\n     }\n \n     protected void internalSkipAllMessages(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n         if (topicName.isGlobal()) {\n-            validateGlobalNamespaceOwnership(namespaceName);\n+            try {\n+                validateGlobalNamespaceOwnership(namespaceName);\n+            } catch (Exception e) {\n+                log.error(\"[{}] Failed to skip all messages for subscription {} on topic {}\", clientAppId(), subName, topicName, e);\n+                resumeAsyncResponseExceptionally(asyncResponse, e);\n+                return;\n+            }\n         }\n         // If the topic name is a partition name, no need to get partition topic metadata again\n         if (topicName.isPartitioned()) {\n             internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n-        } else {\n-            PartitionedTopicMetadata partitionMetadata = getPartitionedTopicMetadata(topicName, authoritative, false);\n-            if (partitionMetadata.partitions > 0) {\n-                final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n-\n-                for (int i = 0; i < partitionMetadata.partitions; i++) {\n-                    TopicName topicNamePartition = topicName.getPartition(i);\n-                    try {\n-                        futures.add(pulsar().getAdminClient().topics().skipAllMessagesAsync(topicNamePartition.toString(),\n-                            subName));\n-                    } catch (Exception e) {\n-                        log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicNamePartition, subName, e);\n-                        asyncResponse.resume(new RestException(e));\n-                        return;\n-                    }\n-                }\n-\n-                FutureUtil.waitForAll(futures).handle((result, exception) -> {\n-                    if (exception != null) {\n-                        Throwable t = exception.getCause();\n-                        if (t instanceof NotFoundException) {\n-                            asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-                            return null;\n-                        } else {\n-                            log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, t);\n-                            asyncResponse.resume(new RestException(t));\n-                            return null;\n+        } else {\n+            getPartitionedTopicMetadataAsync(topicName, authoritative, false).thenAccept(partitionMetadata -> {\n+                if (partitionMetadata.partitions > 0) {\n+                    final List<CompletableFuture<Void>> futures = Lists.newArrayList();\n+\n+                    for (int i = 0; i < partitionMetadata.partitions; i++) {\n+                        TopicName topicNamePartition = topicName.getPartition(i);\n+                        try {\n+                            futures.add(pulsar().getAdminClient().topics().skipAllMessagesAsync(topicNamePartition.toString(),\n+                                    subName));\n+                        } catch (Exception e) {\n+                            log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicNamePartition, subName, e);\n+                            asyncResponse.resume(new RestException(e));\n+                            return;\n                         }\n                     }\n \n-                    asyncResponse.resume(Response.noContent().build());\n-                    return null;\n-                });\n-            } else {\n-                internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n-            }\n+                    FutureUtil.waitForAll(futures).handle((result, exception) -> {\n+                        if (exception != null) {\n+                            Throwable t = exception.getCause();\n+                            if (t instanceof NotFoundException) {\n+                                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                                return null;\n+                            } else {\n+                                log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, t);\n+                                asyncResponse.resume(new RestException(t));\n+                                return null;\n+                            }\n+                        }\n+\n+                        asyncResponse.resume(Response.noContent().build());\n+                        return null;\n+                    });\n+                } else {\n+                    internalSkipAllMessagesForNonPartitionedTopic(asyncResponse, subName, authoritative);\n+                }\n+            }).exceptionally(ex -> {\n+                log.error(\"[{}] Failed to skip all messages for subscription {} on topic {}\", clientAppId(), subName, topicName, ex);\n+                resumeAsyncResponseExceptionally(asyncResponse, ex);\n+               return null;\n+            });\n         }\n     }\n \n     private void internalSkipAllMessagesForNonPartitionedTopic(AsyncResponse asyncResponse, String subName, boolean authoritative) {\n-        validateAdminAccessForSubscriber(subName, authoritative);\n-        PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n-        BiConsumer<Void, Throwable> biConsumer = (v, ex) -> {\n-            if (ex != null) {\n-                asyncResponse.resume(new RestException(ex));\n-                log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, ex);\n-            } else {\n-                asyncResponse.resume(Response.noContent().build());\n-                log.info(\"[{}] Cleared backlog on {} {}\", clientAppId(), topicName, subName);\n-            }\n-        };\n         try {\n+            validateAdminAccessForSubscriber(subName, authoritative);\n+            PersistentTopic topic = (PersistentTopic) getTopicReference(topicName);\n+            BiConsumer<Void, Throwable> biConsumer = (v, ex) -> {\n+                if (ex != null) {\n+                    asyncResponse.resume(new RestException(ex));\n+                    log.error(\"[{}] Failed to skip all messages {} {}\", clientAppId(), topicName, subName, ex);\n+                } else {\n+                    asyncResponse.resume(Response.noContent().build());\n+                    log.info(\"[{}] Cleared backlog on {} {}\", clientAppId(), topicName, subName);\n+                }\n+            };\n             if (subName.startsWith(topic.getReplicatorPrefix())) {\n                 String remoteCluster = PersistentReplicator.getRemoteCluster(subName);\n                 PersistentReplicator repl = (PersistentReplicator) topic.getPersistentReplicator(remoteCluster);\n-                checkNotNull(repl);\n+                if (repl == null) {\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                    return;\n+                }\n                 repl.clearBacklog().whenComplete(biConsumer);\n             } else {\n                 PersistentSubscription sub = topic.getSubscription(subName);\n-                checkNotNull(sub);\n+                if (sub == null) {\n+                    asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n+                    return;\n+                }\n                 sub.clearBacklog().whenComplete(biConsumer);\n             }\n         } catch (Exception e) {\n-            if (e instanceof NullPointerException) {\n-                asyncResponse.resume(new RestException(Status.NOT_FOUND, \"Subscription not found\"));\n-            } else {\n-                asyncResponse.resume(new RestException(e));\n-            }\n+            log.error(\"[{}] Failed to skip all messages for subscription {} on topic {}\", clientAppId(), subName, topicName, e);\n+            resumeAsyncResponseExceptionally(asyncResponse, e);\n         }\n     }\n \n"}}, {"oid": "d9b461cc771cfe485959ba8ada764858eda7a65e", "url": "https://github.com/apache/pulsar/commit/d9b461cc771cfe485959ba8ada764858eda7a65e", "message": "Support force deleting subscription.", "committedDate": "2020-03-08T06:57:40Z", "type": "commit"}, {"oid": "62924a18d4f273bb4618c4fc69376028e5f120a3", "url": "https://github.com/apache/pulsar/commit/62924a18d4f273bb4618c4fc69376028e5f120a3", "message": "Fix a unit test", "committedDate": "2020-03-08T06:58:52Z", "type": "commit"}, {"oid": "de4eb0fe429361d983366cbc26312f4c4aa606be", "url": "https://github.com/apache/pulsar/commit/de4eb0fe429361d983366cbc26312f4c4aa606be", "message": "Fix a flaky test", "committedDate": "2020-03-08T06:58:52Z", "type": "commit"}, {"oid": "7452bcab9cbc77e5dc877d22a0ea158de4ce9715", "url": "https://github.com/apache/pulsar/commit/7452bcab9cbc77e5dc877d22a0ea158de4ce9715", "message": "Improve the unit test to cover force deleting", "committedDate": "2020-03-08T06:58:53Z", "type": "commit"}, {"oid": "07a222ed9e5b9a5411325f3a30b032fe2a20c737", "url": "https://github.com/apache/pulsar/commit/07a222ed9e5b9a5411325f3a30b032fe2a20c737", "message": "Address penghui's comment", "committedDate": "2020-03-08T07:32:16Z", "type": "commit"}, {"oid": "07a222ed9e5b9a5411325f3a30b032fe2a20c737", "url": "https://github.com/apache/pulsar/commit/07a222ed9e5b9a5411325f3a30b032fe2a20c737", "message": "Address penghui's comment", "committedDate": "2020-03-08T07:32:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUwMjE4Mw==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r389502183", "bodyText": "This is an API breaking change. You can't directly change the method signature. Please add an override method.", "author": "sijie", "createdAt": "2020-03-09T07:48:14Z", "path": "pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Topics.java", "diffHunk": "@@ -801,10 +825,12 @@ PartitionedTopicInternalStats getPartitionedInternalStats(String topic)\n      *            topic name\n      * @param subName\n      *            Subscription name\n+     * @param force\n+     *            Delete topic forcefully\n      *\n      * @return a future that can be used to track when the subscription is deleted\n      */\n-    CompletableFuture<Void> deleteSubscriptionAsync(String topic, String subName);\n+    CompletableFuture<Void> deleteSubscriptionAsync(String topic, String subName, boolean force);", "originalCommit": "07a222ed9e5b9a5411325f3a30b032fe2a20c737", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzg4NA==", "url": "https://github.com/apache/pulsar/pull/6383#discussion_r389603884", "bodyText": "Added, thanks.", "author": "murong00", "createdAt": "2020-03-09T11:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTUwMjE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "221b91f97b5e88d83356e74c3c9c9215705d10de", "chunk": "diff --git a/pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Topics.java b/pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Topics.java\nindex d3a38853993..4df3c3139b6 100644\n--- a/pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Topics.java\n+++ b/pulsar-client-admin/src/main/java/org/apache/pulsar/client/admin/Topics.java\n\n@@ -813,12 +814,28 @@ public interface Topics {\n      * @throws PulsarAdminException\n      *             Unexpected error\n      */\n-    void deleteSubscription(String topic, String subName) throws PulsarAdminException;\n+    void deleteSubscription(String topic, String subName, boolean force) throws PulsarAdminException;\n+\n+    /**\n+     * Delete a subscription asynchronously.\n+     * <p>\n+     * Delete a persistent subscription from a topic. There should not be any active consumers on the subscription.\n+     * <p>\n+     *\n+     * @param topic\n+     *            topic name\n+     * @param subName\n+     *            Subscription name\n+     *\n+     * @return a future that can be used to track when the subscription is deleted\n+     */\n+    CompletableFuture<Void> deleteSubscriptionAsync(String topic, String subName);\n \n     /**\n      * Delete a subscription asynchronously.\n      * <p>\n      * Delete a persistent subscription from a topic. There should not be any active consumers on the subscription.\n+     * Force flag deletes subscription forcefully by closing all active consumers.\n      * <p>\n      *\n      * @param topic\n"}}, {"oid": "221b91f97b5e88d83356e74c3c9c9215705d10de", "url": "https://github.com/apache/pulsar/commit/221b91f97b5e88d83356e74c3c9c9215705d10de", "message": "Add an override method to avoid API breaking change", "committedDate": "2020-03-09T11:27:51Z", "type": "commit"}]}