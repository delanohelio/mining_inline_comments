{"pr_number": 2641, "pr_title": "Add conflicts-with constraint", "pr_createdAt": "2020-05-25T16:10:46Z", "pr_url": "https://github.com/OpenRefine/OpenRefine/pull/2641", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTg5Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430071897", "bodyText": "Datamodel.makeWikidataItemIdValue(\"P31\") is incorrect, you are trying to create an ItemIdValue with a property identifier.", "author": "wetneb", "createdAt": "2020-05-25T20:52:49Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -59,6 +60,11 @@\n     \n     public static PropertyIdValue propertyOnlyPid = Datamodel.makeWikidataPropertyIdValue(\"P372\");\n \n+    public static PropertyIdValue conflictsWithPid = Datamodel.makeWikidataPropertyIdValue(\"P50\");\n+    public static PropertyIdValue pidConflictingStatement = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+    public static Value conflictingStatementValue = Datamodel.makeWikidataItemIdValue(\"P31\");", "originalCommit": "058d0775ef0ba1c44981ce2c788836cfeab735cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java b/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java\nindex 1b8ed0a04..3c10ac104 100644\n--- a/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java\n+++ b/extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java\n\n@@ -60,10 +64,15 @@ public class MockConstraintFetcher implements ConstraintFetcher {\n     \n     public static PropertyIdValue propertyOnlyPid = Datamodel.makeWikidataPropertyIdValue(\"P372\");\n \n+    public static PropertyIdValue differenceWithinRangePid = Datamodel.makeWikidataPropertyIdValue(\"P570\");\n+    public static PropertyIdValue lowerBoundPid = Datamodel.makeWikidataPropertyIdValue(\"P569\");\n+    public static QuantityValue minValuePid = Datamodel.makeQuantityValue(new BigDecimal(0));\n+    public static QuantityValue maxValuePid = Datamodel.makeQuantityValue(new BigDecimal(150));\n+\n     public static PropertyIdValue conflictsWithPid = Datamodel.makeWikidataPropertyIdValue(\"P50\");\n     public static PropertyIdValue pidConflictingStatement = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n-    public static Value conflictingStatementValue = Datamodel.makeWikidataItemIdValue(\"P31\");\n-\n+    public static Value conflictingStatementValue = Datamodel.makeWikidataItemIdValue(\"Q5\");\n+    public static Value conflictsWithValue = Datamodel.makeWikidataItemIdValue(\"Q36322\");\n \n     @Override\n     public String getFormatRegex(PropertyIdValue pid) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNTUxOQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430215519", "bodyText": "If this returns a list of PropertyIdValues, the return type should probably reflect that, no? I would use List<PropertyIdValue> instead of List<Value>.", "author": "wetneb", "createdAt": "2020-05-26T07:41:47Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -134,4 +135,27 @@\n      * Can this property be used on items?\n      */\n     boolean usableOnItems(PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getConflictsWithProperties (PropertyIdValue pid);", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzY0Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432877642", "bodyText": "I did that so I can make use of findValues method else we have to create a new method doing nearly same thing.", "author": "darecoder", "createdAt": "2020-05-30T18:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNTUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODc1OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432878759", "bodyText": "I think it is better to have a clean signature for an interface: you can convert the values with a map (from the streaming API).", "author": "wetneb", "createdAt": "2020-05-30T18:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNTUxOQ=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\nindex b0d0191df..05b85f882 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\n\n@@ -137,25 +144,47 @@ public interface ConstraintFetcher {\n     boolean usableOnItems(PropertyIdValue pid);\n \n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+<<<<<<< HEAD\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return minimum value\n+     */\n+    QuantityValue getMinimumValue(PropertyIdValue pid);\n+\n+    /**\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n+     */\n+    QuantityValue getMaximumValue(PropertyIdValue pid);\n+\n+    /**\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+    PropertyIdValue getLowerPropertyId(PropertyIdValue pid);\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    boolean hasDiffWithinRange(PropertyIdValue pid);\n+\n+     /*\n+     * Returns the Map of all the conflicting pid and their item values\n      *\n      * @param pid:\n      *            the property having conflicts-with constraint\n      * @return\n      */\n-    List<Value> getItemwithConflicts (PropertyIdValue pid);\n+    Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid);\n \n-    /**\n-     * Is this property expected to have conflicts-with any other property/properties?\n-     */\n-    boolean hasConflictsWith(PropertyIdValue propertyId);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNjA3MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430216070", "bodyText": "Typo: CONFLICSTS should be CONFLICTS", "author": "wetneb", "createdAt": "2020-05-26T07:42:51Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -96,7 +86,10 @@\n     public static String ALLOWED_ENTITY_TYPES_QID = \"Q52004125\";\n     public static String ALLOWED_ITEM_TYPE_QID = \"Q29934200\";\n     public static String ALLOWED_ENTITY_TYPES_PID = \"P2305\";\n-    \n+\n+    public static String CONFLICSTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICSTS_WITH_PROPERTY_PID = \"P2306\";", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\nindex 432e5bfa0..deaeea196 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n\n@@ -87,8 +93,8 @@ public class WikidataConstraintFetcher implements ConstraintFetcher {\n     public static String ALLOWED_ITEM_TYPE_QID = \"Q29934200\";\n     public static String ALLOWED_ENTITY_TYPES_PID = \"P2305\";\n \n-    public static String CONFLICSTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n-    public static String CONFLICSTS_WITH_PROPERTY_PID = \"P2306\";\n+    public static String CONFLICTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICTS_WITH_PROPERTY_PID = \"P2306\";\n     public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";\n \n     // The following constraints still need to be implemented:\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDIxNzQzNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r430217435", "bodyText": "This method seems redundant to me: if a property does not conflict with any other, we could just represent that by getConflictsWithProperties returning an empty list.", "author": "wetneb", "createdAt": "2020-05-26T07:45:21Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -134,4 +135,27 @@\n      * Can this property be used on items?\n      */\n     boolean usableOnItems(PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getItemwithConflicts (PropertyIdValue pid);\n+\n+    /**\n+     * Is this property expected to have conflicts-with any other property/properties?\n+     */\n+    boolean hasConflictsWith(PropertyIdValue propertyId);", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\nindex b0d0191df..05b85f882 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\n\n@@ -137,25 +144,47 @@ public interface ConstraintFetcher {\n     boolean usableOnItems(PropertyIdValue pid);\n \n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+<<<<<<< HEAD\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return minimum value\n+     */\n+    QuantityValue getMinimumValue(PropertyIdValue pid);\n+\n+    /**\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n+     */\n+    QuantityValue getMaximumValue(PropertyIdValue pid);\n+\n+    /**\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+    PropertyIdValue getLowerPropertyId(PropertyIdValue pid);\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    boolean hasDiffWithinRange(PropertyIdValue pid);\n+\n+     /*\n+     * Returns the Map of all the conflicting pid and their item values\n      *\n      * @param pid:\n      *            the property having conflicts-with constraint\n      * @return\n      */\n-    List<Value> getItemwithConflicts (PropertyIdValue pid);\n+    Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid);\n \n-    /**\n-     * Is this property expected to have conflicts-with any other property/properties?\n-     */\n-    boolean hasConflictsWith(PropertyIdValue propertyId);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjU0Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432836542", "bodyText": "Style: no space between the method name and the opening parenthesis, one space between the closing parenthesis and the opening curly brace.", "author": "wetneb", "createdAt": "2020-05-30T12:12:06Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -340,4 +333,47 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<Value> getConflictsWithProperties (PropertyIdValue pid){", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNzkwNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432837907", "bodyText": "Okay, I'll do the changes.", "author": "darecoder", "createdAt": "2020-05-30T12:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjU0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\nindex 432e5bfa0..deaeea196 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n\n@@ -334,46 +345,115 @@ public class WikidataConstraintFetcher implements ConstraintFetcher {\n         return results;\n     }\n \n+    protected List<QuantityValue> getValues(List<SnakGroup> groups, String pid) {\n+        List<QuantityValue> results = new ArrayList<>();\n+        for (SnakGroup group : groups) {\n+            if (group.getProperty().getId().equals(pid)) {\n+                for (Snak snak : group.getSnaks())\n+                    results.add((QuantityValueImpl) snak.getValue());\n+            }\n+        }\n+        return results;\n+    }\n+\n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    @Override\n+    public boolean hasDiffWithinRange(PropertyIdValue pid) {\n+        return getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID) != null;\n+    }\n+\n+    /**\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    public List<Value> getConflictsWithProperties (PropertyIdValue pid){\n-        List<SnakGroup> specs = getSingleConstraint(pid, CONFLICSTS_WITH_CONSTRAINT_QID);\n+    @Override\n+    public PropertyIdValue getLowerPropertyId(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n         if (specs != null) {\n-            List<Value> conflictsWithProperties = findValues(specs, CONFLICSTS_WITH_PROPERTY_PID);\n-            if (!conflictsWithProperties.isEmpty()) {\n-                return conflictsWithProperties;\n+            List<Value> lowerValueProperty = findValues(specs, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_PID);\n+            if (!lowerValueProperty.isEmpty()) {\n+                return (PropertyIdValue) lowerValueProperty.get(0);\n             }\n         }\n+\n         return null;\n     }\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n      *\n-     * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     * @param pid\n+     * @return minimum value\n      */\n-    public List<Value> getItemwithConflicts (PropertyIdValue pid){\n-        List<SnakGroup> specs = getSingleConstraint(pid, CONFLICSTS_WITH_CONSTRAINT_QID);\n+    @Override\n+    public QuantityValue getMinimumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n         if (specs != null) {\n-            List<Value> conflictsWithProperties = findValues(specs, ITEM_OF_PROPERTY_CONSTRAINT_PID);\n-            if (!conflictsWithProperties.isEmpty()) {\n-                return conflictsWithProperties;\n+            List<QuantityValue> minValue = getValues(specs, MINIMUM_VALUE_PID);\n+            if (!minValue.isEmpty()) {\n+                return minValue.get(0);\n             }\n         }\n         return null;\n     }\n \n     /**\n-     * Is this property expected to have conflicts-with any other property/properties?\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n      */\n-    public boolean hasConflictsWith(PropertyIdValue pid){\n-        return getSingleConstraint(pid, CONFLICSTS_WITH_CONSTRAINT_QID) != null;\n+    @Override\n+    public QuantityValue getMaximumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> maxValue = getValues(specs, MAXIMUM_VALUE_PID);\n+            if (!maxValue.isEmpty()) {\n+                return maxValue.get(0);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Map of all the conflicting pid and their item values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    @Override\n+    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n+        for (Statement statement : statementList) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue conflictingPid = null;\n+            List<Value> items = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(CONFLICTS_WITH_PROPERTY_PID)){\n+                        conflictingPid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        items.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            if (conflictingPid != null) {\n+                propertyIdValueListMap.put(conflictingPid, items);\n+            }\n+        }\n+\n+        return propertyIdValueListMap;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432836641", "bodyText": "Didn't we agree that we needed two parameters here: the property on which the constraint is defined, and the property it conflicts with?", "author": "wetneb", "createdAt": "2020-05-30T12:13:20Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -134,4 +135,27 @@\n      * Can this property be used on items?\n      */\n     boolean usableOnItems(PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    List<Value> getItemwithConflicts (PropertyIdValue pid);", "originalCommit": "5d437ca2bcdec2a53e6d25658e42c6d97a38704a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNzg3Ng==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432837876", "bodyText": "That's what I want to discuss with you, that If we are following wikibase quality constraints implementation so I guess they have used the same kind of implementation, they are fetching the item list at once and then checking that if the conflicting property is having a value from that list. https://github.com/wikimedia/mediawiki-extensions-WikibaseQualityConstraints/blob/master/src/ConstraintCheck/Checker/ConflictsWithChecker.php#L119-L139", "author": "darecoder", "createdAt": "2020-05-30T12:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzOTI4OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432839289", "bodyText": "Their architecture is quite different from what we have here: yes they fetch items in a single go, but in this context they are already looking at a single constraint definition anyway. We should make sure examples like https://www.wikidata.org/wiki/Property:P4013 are handled correctly.", "author": "wetneb", "createdAt": "2020-05-30T12:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzOTMyNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432839326", "bodyText": "Happy to discuss that at our next meeting on tuesday if that helps :)", "author": "wetneb", "createdAt": "2020-05-30T12:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA4ODc4MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434088781", "bodyText": "@wetneb: I have made the changes proposed, still finding an issue. When there are multiple issues to be reported for conflicts with constraint only the one is reported at once. I have checked that the raiseWarning method is returning true for all the possible issues but still the issues are not flagged in the issues tab. Please help. Thank you.", "author": "darecoder", "createdAt": "2020-06-02T18:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNjY0MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\nindex b0d0191df..05b85f882 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java\n\n@@ -137,25 +144,47 @@ public interface ConstraintFetcher {\n     boolean usableOnItems(PropertyIdValue pid);\n \n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+<<<<<<< HEAD\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return minimum value\n+     */\n+    QuantityValue getMinimumValue(PropertyIdValue pid);\n+\n+    /**\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n+     */\n+    QuantityValue getMaximumValue(PropertyIdValue pid);\n+\n+    /**\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    List<Value> getConflictsWithProperties (PropertyIdValue pid);\n+    PropertyIdValue getLowerPropertyId(PropertyIdValue pid);\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    boolean hasDiffWithinRange(PropertyIdValue pid);\n+\n+     /*\n+     * Returns the Map of all the conflicting pid and their item values\n      *\n      * @param pid:\n      *            the property having conflicts-with constraint\n      * @return\n      */\n-    List<Value> getItemwithConflicts (PropertyIdValue pid);\n+    Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid);\n \n-    /**\n-     * Is this property expected to have conflicts-with any other property/properties?\n-     */\n-    boolean hasConflictsWith(PropertyIdValue propertyId);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcyMA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432949720", "bodyText": "Because you are using getSingleConstraint here, this means that for properties with multiple conflicts-with constraints, you will only check the first one.", "author": "wetneb", "createdAt": "2020-05-31T13:54:43Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -340,4 +333,40 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, CONFLICTS_WITH_CONSTRAINT_QID);", "originalCommit": "9e85f9851beca8b56253b80f2b8cb18f95ce0345", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk1NTYxNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r432955617", "bodyText": "Okay, let me try the alternatives. Thanks for the review. :)", "author": "darecoder", "createdAt": "2020-05-31T15:01:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk0OTcyMA=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\nindex 6ad9d709a..deaeea196 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n\n@@ -334,39 +345,115 @@ public class WikidataConstraintFetcher implements ConstraintFetcher {\n         return results;\n     }\n \n+    protected List<QuantityValue> getValues(List<SnakGroup> groups, String pid) {\n+        List<QuantityValue> results = new ArrayList<>();\n+        for (SnakGroup group : groups) {\n+            if (group.getProperty().getId().equals(pid)) {\n+                for (Snak snak : group.getSnaks())\n+                    results.add((QuantityValueImpl) snak.getValue());\n+            }\n+        }\n+        return results;\n+    }\n+\n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    @Override\n+    public boolean hasDiffWithinRange(PropertyIdValue pid) {\n+        return getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID) != null;\n+    }\n+\n+    /**\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n-        List<SnakGroup> specs = getSingleConstraint(pid, CONFLICTS_WITH_CONSTRAINT_QID);\n+    @Override\n+    public PropertyIdValue getLowerPropertyId(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n         if (specs != null) {\n-            List<Value> conflictsWithProperties = findValues(specs, CONFLICTS_WITH_PROPERTY_PID);\n-            if (!conflictsWithProperties.isEmpty()) {\n-                return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+            List<Value> lowerValueProperty = findValues(specs, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_PID);\n+            if (!lowerValueProperty.isEmpty()) {\n+                return (PropertyIdValue) lowerValueProperty.get(0);\n             }\n         }\n+\n         return null;\n     }\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return minimum value\n+     */\n+    @Override\n+    public QuantityValue getMinimumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> minValue = getValues(specs, MINIMUM_VALUE_PID);\n+            if (!minValue.isEmpty()) {\n+                return minValue.get(0);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n+     */\n+    @Override\n+    public QuantityValue getMaximumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> maxValue = getValues(specs, MAXIMUM_VALUE_PID);\n+            if (!maxValue.isEmpty()) {\n+                return maxValue.get(0);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the Map of all the conflicting pid and their item values\n      *\n      * @param pid:\n      *            the property having conflicts-with constraint\n      * @return\n      */\n-    public List<Value> getItemwithConflicts(PropertyIdValue pid) {\n-        List<SnakGroup> specs = getSingleConstraint(pid, CONFLICTS_WITH_CONSTRAINT_QID);\n-        if (specs != null) {\n-            List<Value> conflictsWithProperties = findValues(specs, ITEM_OF_PROPERTY_CONSTRAINT_PID);\n-            if (!conflictsWithProperties.isEmpty()) {\n-                return conflictsWithProperties;\n+    @Override\n+    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n+        for (Statement statement : statementList) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            PropertyIdValue conflictingPid = null;\n+            List<Value> items = new ArrayList<>();\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (group.getProperty().getId().equals(CONFLICTS_WITH_PROPERTY_PID)){\n+                        conflictingPid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        items.add(snak.getValue());\n+                    }\n+                }\n+            }\n+            if (conflictingPid != null) {\n+                propertyIdValueListMap.put(conflictingPid, items);\n             }\n         }\n-        return null;\n+\n+        return propertyIdValueListMap;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MDE3NQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434390175", "bodyText": "Should be Map<PropertyIdValue, List<Value>>", "author": "wetneb", "createdAt": "2020-06-03T08:17:32Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ConflictsWithScrutinizer extends EditScrutinizer {\n+\n+    public static final String type = \"having-conflicts-with-statements\";\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>();", "originalCommit": "efa6d47caacf24a5b62377c3065e3a0813456cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\nindex 6dbfbbfb2..77580924d 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\n\n@@ -6,9 +6,7 @@ import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n import org.wikidata.wdtk.datamodel.interfaces.Statement;\n import org.wikidata.wdtk.datamodel.interfaces.Value;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n public class ConflictsWithScrutinizer extends EditScrutinizer {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MTIxMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434391211", "bodyText": "We need to check to check what happens with no value and some value snaks.", "author": "wetneb", "createdAt": "2020-06-03T08:19:17Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ConflictsWithScrutinizer extends EditScrutinizer {\n+\n+    public static final String type = \"having-conflicts-with-statements\";\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()){\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();", "originalCommit": "efa6d47caacf24a5b62377c3065e3a0813456cf9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc0NDgwOA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434744808", "bodyText": "In the case of NoValueSnak & SomeValueSnak, it will make a call to the method implemented in SnakImpl which will return null. So, I guess it will not create any issues. If it is an issue, please let me know, I'll use some other way to implement the functionality.", "author": "darecoder", "createdAt": "2020-06-03T17:44:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MTIxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzY2Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436257662", "bodyText": "That is fine then! It would be worth adding a test case with a NoValueSnak to demonstrate that, perhaps?", "author": "wetneb", "createdAt": "2020-06-06T10:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MTIxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\nindex 6dbfbbfb2..77580924d 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\n\n@@ -6,9 +6,7 @@ import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n import org.wikidata.wdtk.datamodel.interfaces.Statement;\n import org.wikidata.wdtk.datamodel.interfaces.Value;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n public class ConflictsWithScrutinizer extends EditScrutinizer {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM5MjAzNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r434392035", "bodyText": "You will have an NPE here if the candidate conflicting value is a NoValueSnak.", "author": "wetneb", "createdAt": "2020-06-03T08:20:44Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.openrefine.wikidata.qa.scrutinizers;\n+\n+import org.openrefine.wikidata.qa.QAWarning;\n+import org.openrefine.wikidata.updates.ItemUpdate;\n+import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n+import org.wikidata.wdtk.datamodel.interfaces.Statement;\n+import org.wikidata.wdtk.datamodel.interfaces.Value;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class ConflictsWithScrutinizer extends EditScrutinizer {\n+\n+    public static final String type = \"having-conflicts-with-statements\";\n+\n+    @Override\n+    public void scrutinize(ItemUpdate update) {\n+        Map<PropertyIdValue, Value> propertyIdValueValueMap = new HashMap<>();\n+        for (Statement statement : update.getAddedStatements()){\n+            PropertyIdValue pid = statement.getClaim().getMainSnak().getPropertyId();\n+            Value value = statement.getClaim().getMainSnak().getValue();\n+            propertyIdValueValueMap.put(pid, value);\n+        }\n+\n+        for(PropertyIdValue propertyId : propertyIdValueValueMap.keySet()){\n+            List<PropertyIdValue> conflictingProperties = _fetcher.getConflictsWithProperties(propertyId);\n+            if (conflictingProperties != null){\n+                for (PropertyIdValue conflictingPid : conflictingProperties) {\n+                    if (propertyIdValueValueMap.containsKey(conflictingPid) && raiseWarning(propertyId, propertyIdValueValueMap, conflictingPid)) {\n+                        QAWarning issue = new QAWarning(type, propertyId.getId(), QAWarning.Severity.WARNING, 1);\n+                        issue.setProperty(\"property_entity\", propertyId);\n+                        issue.setProperty(\"added_property_entity\", conflictingPid);\n+                        issue.setProperty(\"example_entity\", update.getItemId());\n+                        addIssue(issue);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean raiseWarning(PropertyIdValue propertyId, Map<PropertyIdValue, Value> propertyIdValueValueMap, PropertyIdValue conflictingPid) {\n+        List<Value> conflictingValues = _fetcher.getItemWithConflicts(propertyId, conflictingPid);\n+        if (conflictingValues == null){\n+            return true;\n+        }\n+\n+        if (propertyIdValueValueMap.containsKey(conflictingPid)){\n+            for (Value value : conflictingValues) {\n+                if (propertyIdValueValueMap.get(conflictingPid).equals(value)){", "originalCommit": "efa6d47caacf24a5b62377c3065e3a0813456cf9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\nindex 6dbfbbfb2..77580924d 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/scrutinizers/ConflictsWithScrutinizer.java\n\n@@ -6,9 +6,7 @@ import org.wikidata.wdtk.datamodel.interfaces.PropertyIdValue;\n import org.wikidata.wdtk.datamodel.interfaces.Statement;\n import org.wikidata.wdtk.datamodel.interfaces.Value;\n \n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n public class ConflictsWithScrutinizer extends EditScrutinizer {\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436257551", "bodyText": "Two things: it is better to avoid referring to PropertyIdValueImpl, you can just use PropertyIdValue which is the interface. Also, this type check is actually redundant with the equality check afterwards. You should just be able to do conflictingPid.equals(snak.getValue()) (since you know conflictingPid is not null and its equals method will only return true for instances of PropertyIdValue).", "author": "wetneb", "createdAt": "2020-06-06T10:29:53Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -337,4 +342,57 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> conflictsWithProperties = new ArrayList<>();\n+        for(Statement statement : statementList){\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            if (specs != null) {\n+                conflictsWithProperties.addAll(findValues(specs, CONFLICTS_WITH_PROPERTY_PID));\n+            }\n+        }\n+\n+        if (!conflictsWithProperties.isEmpty()) {\n+            return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<Value> getItemWithConflicts(PropertyIdValue pid, PropertyIdValue conflictingPid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> itemList = new ArrayList<>();\n+        for (Statement statement : statementList) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            boolean flag = false;\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (snak.getValue() instanceof PropertyIdValueImpl && snak.getValue().equals(conflictingPid)){", "originalCommit": "0457785a0882b8610f761d3cc4c0997151d8d1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI2OTM0Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436269347", "bodyText": "Changing PropertyIdValueImpl to PropertyIdValue sounds good to me but removing that check will not be good I guess. Because I have used that as in case of Snaks we get both Property and Item so we have to update flag value only in case when we get Property as Snak. So, in the 1st if condition it will work but in 2nd else if part it will not work as expected.", "author": "darecoder", "createdAt": "2020-06-06T13:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3MzE4Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436273187", "bodyText": "Can you give me an example of a case where snak.getValue().equals(conflictingPid) evaluates to true but snak.getValue() instanceof PropertyIdValue does not?", "author": "wetneb", "createdAt": "2020-06-06T14:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3MzUyNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436273527", "bodyText": "As I mentioned, it will work for sure but in the 2nd else if condition snak.getValue() instanceof PropertyIdValue && !snak.getValue().equals(conflictingPid)  if we remove the check to check the instance class then there might be the case that it belongs to ItemIdValue and it will make get executed as this will be true in that case !snak.getValue().equals(conflictingPid).", "author": "darecoder", "createdAt": "2020-06-06T14:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3MzgyMw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436273823", "bodyText": "If snak.getValue() is an ItemIdValue then snak.getValue().equals(conflictingPid) will evaluate to false - check the equals implementation of ItemIdValue :)", "author": "wetneb", "createdAt": "2020-06-06T14:39:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDI1Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436274257", "bodyText": "I feel we both are looking at the issue differently.\n\nIf snak.getValue() is an ItemIdValue then snak.getValue().equals(conflictingPid) will evaluate to false - check the equals implementation of ItemIdValue :)\n\nI do agree with your explanation, that's why I'm saying it. If it evaluates to false for other ItemIdValue the ! at the starting !snak.getValue().equals(conflictingPid) will make it true and it will get executed which I don't want for now. I have tried to remove the instanceof comparison but it didn't worked as expected. If you are insisting I'll try it once again for sure.", "author": "darecoder", "createdAt": "2020-06-06T14:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NDgxMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436274811", "bodyText": "Could you explain what you mean by \"it didn't worked as expected\"? Perhaps the best thing to do in this case is to put a breakpoint on this if and use the debugger to find out what is happening here exactly :)", "author": "wetneb", "createdAt": "2020-06-06T14:54:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTYxNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436275616", "bodyText": "Because I want the 2nd else if condition to execute only when the case is: it is not an ItemIdValue, it is a PropertyIdValue but its value is not equal to the conflictingPid. But when I remove the instanceof check from it, the condition executes even for ItemIdValue as expected according to your explanation.\n\nIf snak.getValue() is an ItemIdValue then snak.getValue().equals(conflictingPid) will evaluate to false - check the equals implementation of ItemIdValue :)\n\nBut I want to it to execute for PropertyIdValue only when its value isn't equal to conflictingPid.\nChanging the order of conditions after removing the instanceof check might work. I'm testing it currently.", "author": "darecoder", "createdAt": "2020-06-06T15:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3OTU0Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436279543", "bodyText": "But I want to it to execute for PropertyIdValue only when its value isn't equal to conflictingPid.\n\nYes but that is not how you should do it: you should look at the property of the snak, not the type of its values (because there could potentially be some other parameter which would also have the same type of values). So: remove all instanceof checks and use snak.getProperty() to know what sort of parameter you are handling.", "author": "wetneb", "createdAt": "2020-06-06T15:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3OTk5Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436279993", "bodyText": "I have removed the instanceof checks. Is it okay now?\nOr I need to change  snak.getValue().equals(conflictingPid)  to snak.getPropertyId().equals(conflictingPid) ?", "author": "darecoder", "createdAt": "2020-06-06T16:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDAwNQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436290005", "bodyText": "It is much better! Now I guess we still have the issue that you are relying on the order of the qualifiers (you expect the property first, and then the items, but there is no reason why they should necessarily appear in this order).", "author": "wetneb", "createdAt": "2020-06-06T18:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDY3OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436290679", "bodyText": "I tried a lot of properties having conflicts-with constraint and observed this pattern, hence proceeded with this implementation. I won't say testes all of them but some of them. The item values don't seem to have anything that relates it to the conflicting Pid I guess. What else I should do? Any suggestions?", "author": "darecoder", "createdAt": "2020-06-06T18:38:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MTA3Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436291072", "bodyText": "I would do as follows:\n\ncreate a variable to store the conflicting pid and a list of conflicting values\nloop over all qualifier snaks (as you are doing)\n\nif the property of the snak is the one that specifies the conflicting pid, then set the conflicting pid to the qualifier value\nif the property of the snak is the one that specifies the conflicting values, then add the value to the list of conflicting values", "author": "wetneb", "createdAt": "2020-06-06T18:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5ODUwNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436298506", "bodyText": "Hope, I correctly understand what you tried to explain. :)", "author": "darecoder", "createdAt": "2020-06-06T20:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\nindex 59ee3948f..deaeea196 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n\n@@ -343,56 +345,115 @@ public class WikidataConstraintFetcher implements ConstraintFetcher {\n         return results;\n     }\n \n+    protected List<QuantityValue> getValues(List<SnakGroup> groups, String pid) {\n+        List<QuantityValue> results = new ArrayList<>();\n+        for (SnakGroup group : groups) {\n+            if (group.getProperty().getId().equals(pid)) {\n+                for (Snak snak : group.getSnaks())\n+                    results.add((QuantityValueImpl) snak.getValue());\n+            }\n+        }\n+        return results;\n+    }\n+\n+    /**\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    @Override\n+    public boolean hasDiffWithinRange(PropertyIdValue pid) {\n+        return getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID) != null;\n+    }\n+\n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n-        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n-        List<Value> conflictsWithProperties = new ArrayList<>();\n-        for(Statement statement : statementList){\n-            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n-            if (specs != null) {\n-                conflictsWithProperties.addAll(findValues(specs, CONFLICTS_WITH_PROPERTY_PID));\n+    @Override\n+    public PropertyIdValue getLowerPropertyId(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<Value> lowerValueProperty = findValues(specs, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_PID);\n+            if (!lowerValueProperty.isEmpty()) {\n+                return (PropertyIdValue) lowerValueProperty.get(0);\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return minimum value\n+     */\n+    @Override\n+    public QuantityValue getMinimumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> minValue = getValues(specs, MINIMUM_VALUE_PID);\n+            if (!minValue.isEmpty()) {\n+                return minValue.get(0);\n             }\n         }\n+        return null;\n+    }\n \n-        if (!conflictsWithProperties.isEmpty()) {\n-            return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+    /**\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n+     */\n+    @Override\n+    public QuantityValue getMaximumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> maxValue = getValues(specs, MAXIMUM_VALUE_PID);\n+            if (!maxValue.isEmpty()) {\n+                return maxValue.get(0);\n+            }\n         }\n         return null;\n     }\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Returns the Map of all the conflicting pid and their item values\n      *\n      * @param pid:\n      *            the property having conflicts-with constraint\n      * @return\n      */\n-    public List<Value> getItemWithConflicts(PropertyIdValue pid, PropertyIdValue conflictingPid) {\n+    @Override\n+    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n         List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n-        List<Value> itemList = new ArrayList<>();\n+        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n         for (Statement statement : statementList) {\n             List<SnakGroup> specs = statement.getClaim().getQualifiers();\n-            boolean flag = false;\n+            PropertyIdValue conflictingPid = null;\n+            List<Value> items = new ArrayList<>();\n             for(SnakGroup group : specs) {\n                 for (Snak snak : group.getSnaks()) {\n-                    if (snak.getValue() instanceof PropertyIdValueImpl && snak.getValue().equals(conflictingPid)){\n-                        flag = true;\n-                    } else if (snak.getValue() instanceof PropertyIdValueImpl && !snak.getValue().equals(conflictingPid)) {\n-                        flag = false;\n-                    } else if (flag && snak.getValue() instanceof ItemIdValueImpl\n-                            && group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n-                        itemList.add(snak.getValue());\n+                    if (group.getProperty().getId().equals(CONFLICTS_WITH_PROPERTY_PID)){\n+                        conflictingPid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        items.add(snak.getValue());\n                     }\n                 }\n             }\n+            if (conflictingPid != null) {\n+                propertyIdValueListMap.put(conflictingPid, items);\n+            }\n         }\n \n-        return itemList;\n+        return propertyIdValueListMap;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU2MQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436257561", "bodyText": "Same here.", "author": "wetneb", "createdAt": "2020-06-06T10:30:04Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -337,4 +342,57 @@ public boolean usableOnItems(PropertyIdValue pid) {\n         }\n         return results;\n     }\n+\n+    /**\n+     * Returns the list of PropertyIdValues of conflicting statements\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> conflictsWithProperties = new ArrayList<>();\n+        for(Statement statement : statementList){\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            if (specs != null) {\n+                conflictsWithProperties.addAll(findValues(specs, CONFLICTS_WITH_PROPERTY_PID));\n+            }\n+        }\n+\n+        if (!conflictsWithProperties.isEmpty()) {\n+            return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the list of all the conflicting values\n+     *\n+     * @param pid:\n+     *            the property having conflicts-with constraint\n+     * @return\n+     */\n+    public List<Value> getItemWithConflicts(PropertyIdValue pid, PropertyIdValue conflictingPid) {\n+        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n+        List<Value> itemList = new ArrayList<>();\n+        for (Statement statement : statementList) {\n+            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n+            boolean flag = false;\n+            for(SnakGroup group : specs) {\n+                for (Snak snak : group.getSnaks()) {\n+                    if (snak.getValue() instanceof PropertyIdValueImpl && snak.getValue().equals(conflictingPid)){\n+                        flag = true;\n+                    } else if (snak.getValue() instanceof PropertyIdValueImpl && !snak.getValue().equals(conflictingPid)) {", "originalCommit": "0457785a0882b8610f761d3cc4c0997151d8d1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3NTA1Mw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r436275053", "bodyText": "Here, instead of relying on the PropertyIdValue type of the snak value, you should rather rely on the snak.getProperty()'s value.", "author": "wetneb", "createdAt": "2020-06-06T14:55:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1NzU2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "chunk": "diff --git a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\nindex 59ee3948f..deaeea196 100644\n--- a/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n+++ b/extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java\n\n@@ -343,56 +345,115 @@ public class WikidataConstraintFetcher implements ConstraintFetcher {\n         return results;\n     }\n \n+    protected List<QuantityValue> getValues(List<SnakGroup> groups, String pid) {\n+        List<QuantityValue> results = new ArrayList<>();\n+        for (SnakGroup group : groups) {\n+            if (group.getProperty().getId().equals(pid)) {\n+                for (Snak snak : group.getSnaks())\n+                    results.add((QuantityValueImpl) snak.getValue());\n+            }\n+        }\n+        return results;\n+    }\n+\n+    /**\n+     * Is this property expected to have a value whose difference\n+     * with its lower bound property should be in a range?\n+     */\n+    @Override\n+    public boolean hasDiffWithinRange(PropertyIdValue pid) {\n+        return getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID) != null;\n+    }\n+\n     /**\n-     * Returns the list of PropertyIdValues of conflicting statements\n+     * Retrieves the lower value property for calculating the difference\n+     * required in difference-within-range constraint\n      *\n      * @param pid:\n-     *            the property having conflicts-with constraint\n-     * @return\n+     *            the property to calculate difference with\n+     * @return the pid of the lower bound property\n      */\n-    public List<PropertyIdValue> getConflictsWithProperties(PropertyIdValue pid) {\n-        List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n-        List<Value> conflictsWithProperties = new ArrayList<>();\n-        for(Statement statement : statementList){\n-            List<SnakGroup> specs = statement.getClaim().getQualifiers();\n-            if (specs != null) {\n-                conflictsWithProperties.addAll(findValues(specs, CONFLICTS_WITH_PROPERTY_PID));\n+    @Override\n+    public PropertyIdValue getLowerPropertyId(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<Value> lowerValueProperty = findValues(specs, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_PID);\n+            if (!lowerValueProperty.isEmpty()) {\n+                return (PropertyIdValue) lowerValueProperty.get(0);\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieves the lower bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return minimum value\n+     */\n+    @Override\n+    public QuantityValue getMinimumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> minValue = getValues(specs, MINIMUM_VALUE_PID);\n+            if (!minValue.isEmpty()) {\n+                return minValue.get(0);\n             }\n         }\n+        return null;\n+    }\n \n-        if (!conflictsWithProperties.isEmpty()) {\n-            return conflictsWithProperties.stream().map(e -> e == null ? null : (PropertyIdValue) e).collect(Collectors.toList());\n+    /**\n+     * Retrieves the upper bound of the range\n+     * required in difference-within-range constraint\n+     *\n+     * @param pid\n+     * @return maximum value\n+     */\n+    @Override\n+    public QuantityValue getMaximumValue(PropertyIdValue pid) {\n+        List<SnakGroup> specs = getSingleConstraint(pid, DIFFERENCE_WITHIN_RANGE_CONSTRAINT_QID);\n+        if (specs != null) {\n+            List<QuantityValue> maxValue = getValues(specs, MAXIMUM_VALUE_PID);\n+            if (!maxValue.isEmpty()) {\n+                return maxValue.get(0);\n+            }\n         }\n         return null;\n     }\n \n     /**\n-     * Returns the list of all the conflicting values\n+     * Returns the Map of all the conflicting pid and their item values\n      *\n      * @param pid:\n      *            the property having conflicts-with constraint\n      * @return\n      */\n-    public List<Value> getItemWithConflicts(PropertyIdValue pid, PropertyIdValue conflictingPid) {\n+    @Override\n+    public Map<PropertyIdValue, List<Value>> getParamConflictsWith(PropertyIdValue pid) {\n         List<Statement> statementList = getConstraintsByType(pid, CONFLICTS_WITH_CONSTRAINT_QID).collect(Collectors.toList());\n-        List<Value> itemList = new ArrayList<>();\n+        Map<PropertyIdValue, List<Value>> propertyIdValueListMap = new HashMap<>();\n         for (Statement statement : statementList) {\n             List<SnakGroup> specs = statement.getClaim().getQualifiers();\n-            boolean flag = false;\n+            PropertyIdValue conflictingPid = null;\n+            List<Value> items = new ArrayList<>();\n             for(SnakGroup group : specs) {\n                 for (Snak snak : group.getSnaks()) {\n-                    if (snak.getValue() instanceof PropertyIdValueImpl && snak.getValue().equals(conflictingPid)){\n-                        flag = true;\n-                    } else if (snak.getValue() instanceof PropertyIdValueImpl && !snak.getValue().equals(conflictingPid)) {\n-                        flag = false;\n-                    } else if (flag && snak.getValue() instanceof ItemIdValueImpl\n-                            && group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n-                        itemList.add(snak.getValue());\n+                    if (group.getProperty().getId().equals(CONFLICTS_WITH_PROPERTY_PID)){\n+                        conflictingPid = (PropertyIdValue) snak.getValue();\n+                    }\n+                    if (group.getProperty().getId().equals(ITEM_OF_PROPERTY_CONSTRAINT_PID)){\n+                        items.add(snak.getValue());\n                     }\n                 }\n             }\n+            if (conflictingPid != null) {\n+                propertyIdValueListMap.put(conflictingPid, items);\n+            }\n         }\n \n-        return itemList;\n+        return propertyIdValueListMap;\n     }\n }\n"}}, {"oid": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "url": "https://github.com/OpenRefine/OpenRefine/commit/3aa6e2dd6807111e843169c3b3acd88801e7314f", "message": "Added conflicts-with constraints\n\nImplemented conflicts-with scrutinizer as part of #2354", "committedDate": "2020-06-06T20:33:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg4NA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437673884", "bodyText": "This looks like a missed merge conflict", "author": "tfmorris", "createdAt": "2020-06-09T19:41:32Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/ConstraintFetcher.java", "diffHunk": "@@ -142,6 +144,7 @@\n     boolean usableOnItems(PropertyIdValue pid);\n \n     /**\n+<<<<<<< HEAD", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcyOTQ1MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437729450", "bodyText": "whoops, thanks for catching that!", "author": "wetneb", "createdAt": "2020-06-09T21:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg4NA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NDY5NQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437674695", "bodyText": "Did your IDE do this without you asking? Can you configure a higher limit for wild card imports and/or review the diff to make sure unnecessary changes aren't included?", "author": "tfmorris", "createdAt": "2020-06-09T19:43:03Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -28,9 +28,7 @@\n import org.wikidata.wdtk.datamodel.implementation.QuantityValueImpl;\n import org.wikidata.wdtk.datamodel.interfaces.*;\n \n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Set;\n+import java.util.*;", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0NDkxNw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437844917", "bodyText": "Yes, it got updated on its own by the IDE. Sorry, I'll take care of it next time onwards for sure. For now, I'll create a PR resolving all the flaws. Thanks for the review. :)", "author": "darecoder", "createdAt": "2020-06-10T03:52:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NDY5NQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3OTUyMg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437679522", "bodyText": "This appears to duplicate ALLOWED_ENTITY_TYPES_PID just above.", "author": "tfmorris", "createdAt": "2020-06-09T19:52:13Z", "path": "extensions/wikidata/src/org/openrefine/wikidata/qa/WikidataConstraintFetcher.java", "diffHunk": "@@ -94,7 +92,10 @@\n     public static String ALLOWED_ENTITY_TYPES_QID = \"Q52004125\";\n     public static String ALLOWED_ITEM_TYPE_QID = \"Q29934200\";\n     public static String ALLOWED_ENTITY_TYPES_PID = \"P2305\";\n-    \n+\n+    public static String CONFLICTS_WITH_CONSTRAINT_QID = \"Q21502838\";\n+    public static String CONFLICTS_WITH_PROPERTY_PID = \"P2306\";\n+    public static String ITEM_OF_PROPERTY_CONSTRAINT_PID = \"P2305\";", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzczMDI5Mg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437730292", "bodyText": "While these happen to have the same value for Wikidata, it might not be true of all Wikibase instances (these constants should become user-configurable once we add proper Wikibase support). That being said the name of the constant could probably be adapted to reflect that it is specifically for that constraint.", "author": "wetneb", "createdAt": "2020-06-09T21:22:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3OTUyMg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MDYyNg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2641#discussion_r437680626", "bodyText": "I recognize Q5, but the rest would have to look up. For the benefit of future readers, it might be nice to give them mnemonic variable names or to put the string values in constants.", "author": "tfmorris", "createdAt": "2020-06-09T19:54:26Z", "path": "extensions/wikidata/tests/src/org/openrefine/wikidata/qa/MockConstraintFetcher.java", "diffHunk": "@@ -66,6 +69,11 @@\n     public static QuantityValue minValuePid = Datamodel.makeQuantityValue(new BigDecimal(0));\n     public static QuantityValue maxValuePid = Datamodel.makeQuantityValue(new BigDecimal(150));\n \n+    public static PropertyIdValue conflictsWithPid = Datamodel.makeWikidataPropertyIdValue(\"P50\");\n+    public static PropertyIdValue pidConflictingStatement = Datamodel.makeWikidataPropertyIdValue(\"P31\");\n+    public static Value conflictingStatementValue = Datamodel.makeWikidataItemIdValue(\"Q5\");\n+    public static Value conflictsWithValue = Datamodel.makeWikidataItemIdValue(\"Q36322\");", "originalCommit": "3aa6e2dd6807111e843169c3b3acd88801e7314f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}