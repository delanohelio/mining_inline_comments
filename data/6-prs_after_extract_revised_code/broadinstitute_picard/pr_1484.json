{"pr_number": 1484, "pr_title": "Hardclip adapter option in MergeBamAlignments", "pr_createdAt": "2020-03-10T21:54:11Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1484", "timeline": [{"oid": "1ad177b03ef0543cdb0b4874f97cb082280407bc", "url": "https://github.com/broadinstitute/picard/commit/1ad177b03ef0543cdb0b4874f97cb082280407bc", "message": "hardclipping", "committedDate": "2020-03-10T21:47:20Z", "type": "commit"}, {"oid": "bf6f43280e9d6cc9f3fe8d110d73b15609e40d9f", "url": "https://github.com/broadinstitute/picard/commit/bf6f43280e9d6cc9f3fe8d110d73b15609e40d9f", "message": "strand flipping", "committedDate": "2020-03-10T21:47:20Z", "type": "commit"}, {"oid": "cd6bd15b2a8fb4d3b0585e88f969a0f9080859a5", "url": "https://github.com/broadinstitute/picard/commit/cd6bd15b2a8fb4d3b0585e88f969a0f9080859a5", "message": "tests", "committedDate": "2020-03-10T21:47:40Z", "type": "commit"}, {"oid": "519b1616d9e9a0a8096e761c85acf297eb19f3d7", "url": "https://github.com/broadinstitute/picard/commit/519b1616d9e9a0a8096e761c85acf297eb19f3d7", "message": "tests", "committedDate": "2020-03-10T21:47:40Z", "type": "commit"}, {"oid": "7715fd4fbbdaf34d5e7c7daf54d44706916054ef", "url": "https://github.com/broadinstitute/picard/commit/7715fd4fbbdaf34d5e7c7daf54d44706916054ef", "message": "fixing tests", "committedDate": "2020-03-11T13:48:17Z", "type": "commit"}, {"oid": "7028bccafb6bbb7442396cbe8459e7072083582b", "url": "https://github.com/broadinstitute/picard/commit/7028bccafb6bbb7442396cbe8459e7072083582b", "message": "more tests", "committedDate": "2020-03-11T21:06:36Z", "type": "commit"}, {"oid": "b76d9b6edcf2a46be58d832f1900635918927a47", "url": "https://github.com/broadinstitute/picard/commit/b76d9b6edcf2a46be58d832f1900635918927a47", "message": "mba test on sam file", "committedDate": "2020-03-13T13:36:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMjE2OQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394522169", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early sof-clipping isn't quite right\n          \n          \n            \n                                //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early soft-clipping isn't quite right", "author": "yfarjoun", "createdAt": "2020-03-18T17:31:54Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                                  final List<? extends AdapterPair> adaptersPairs) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n+\n+                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n+\n+                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped\n+                        final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                        final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                        if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                            final int clipFrom = posClipFrom;\n+\n+                            for (final AdapterPair adapterPair : adaptersPairs) {\n+                                if (basesToClipMatchAdapterPair(read1, clipFrom - 1, adapterPair, read2Structure) && basesToClipMatchAdapterPair(read2, clipFrom - 1, adapterPair, read1Structure)) {\n+                                    CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, CigarOperator.HARD_CLIP);\n+                                    CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, CigarOperator.HARD_CLIP);\n+                                    return;\n+                                }\n+                            }\n+                        }\n+                    }\n+\n+\n+                    //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early sof-clipping isn't quite right", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -756,7 +746,7 @@ public abstract class AbstractAlignmentMerger {\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUyMjcxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394522715", "bodyText": "the \"readthrough bases\"? not clear what is meant by that....", "author": "yfarjoun", "createdAt": "2020-03-18T17:32:46Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                                  final List<? extends AdapterPair> adaptersPairs) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n+\n+                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n+\n+                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -756,7 +746,7 @@ public abstract class AbstractAlignmentMerger {\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODgzMA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394568830", "bodyText": "unclear what you are trying to do here....could you put a comment in the code?", "author": "yfarjoun", "createdAt": "2020-03-18T18:50:40Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                                  final List<? extends AdapterPair> adaptersPairs) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n+\n+                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n+\n+                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped\n+                        final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                        final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                        if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                            final int clipFrom = posClipFrom;\n+", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -756,7 +746,7 @@ public abstract class AbstractAlignmentMerger {\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3NDM1NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394574354", "bodyText": "hmmm. this feels like code that already exists in htsjdk....basically you want to go from a reference position to a readoffset, right? how about htsjdk.samtools.SAMRecord#getReadPositionAtReferencePosition(htsjdk.samtools.SAMRecord, int, boolean) does that help?", "author": "yfarjoun", "createdAt": "2020-03-18T19:00:29Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -780,9 +821,154 @@ protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRe\n                         final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n                         CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n                     }\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    protected static int getReadPositionToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4OTIxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400489219", "bodyText": "comment still stands", "author": "yfarjoun", "createdAt": "2020-03-30T20:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3NDM1NA=="}], "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -785,48 +772,40 @@ public abstract class AbstractAlignmentMerger {\n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n \n-                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n-\n-                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped\n-                        final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n-                        final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n-                        if (posClipFrom == negClipFrom && posClipFrom > 0) {\n-                            final int clipFrom = posClipFrom;\n+                    //need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                        final int clipFrom = posClipFrom;\n \n-                            for (final AdapterPair adapterPair : adaptersPairs) {\n-                                if (basesToClipMatchAdapterPair(read1, clipFrom - 1, adapterPair, read2Structure) && basesToClipMatchAdapterPair(read2, clipFrom - 1, adapterPair, read1Structure)) {\n-                                    CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, CigarOperator.HARD_CLIP);\n-                                    CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, CigarOperator.HARD_CLIP);\n-                                    return;\n-                                }\n-                            }\n+                        if (clippingOperator == CigarOperator.HARD_CLIP) {\n+                            moveClippedBasesToTag(read1, clipFrom);\n+                            moveClippedBasesToTag(read2, clipFrom);\n                         }\n-                    }\n \n-\n-                    //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early sof-clipping isn't quite right\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n-\n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                        CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, clippingOperator);\n+                        CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, clippingOperator);\n                     }\n-\n                 }\n             }\n         }\n     }\n \n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        if(rec.getReadNegativeStrandFlag()) {\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1)));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1)));\n+        } else {\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities,clipFrom - 1, readLength)));\n+        }\n+    }\n+\n     protected static int getReadPositionToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {\n \n         if (refPosToClipFrom > rec.getUnclippedEnd() || refPosToClipFrom < rec.getUnclippedStart()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxNTE5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394615191", "bodyText": "the generalizability of having the clipping operator given as such seems like premature optimization...why not just a boolean hardClip ?", "author": "yfarjoun", "createdAt": "2020-03-18T20:19:27Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -742,28 +756,55 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n             SamPairUtil.setProperPairFlags(secondUnaligned, firstUnaligned, expectedOrientations);\n         }\n     }\n \n+\n+\n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator, final ReadStructure read1Structure, final ReadStructure read2Structure,", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -756,7 +746,7 @@ public abstract class AbstractAlignmentMerger {\n             transferAlignmentInfoToFragment(secondUnaligned, secondAligned, isContaminant, needsSafeReverseComplement);\n         }\n         if (isClipOverlappingReads()) {\n-            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator, read1Structure, read2Structure, adapterPairs);\n+            clipForOverlappingReads(firstUnaligned, secondUnaligned, clipOverlappingReadsOperator);\n         }\n         SamPairUtil.setMateInfo(secondUnaligned, firstUnaligned, addMateCigar);\n         if (!keepAlignerProperPairFlags) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxNzQ4Ng==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394617486", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operatore.\");\n          \n          \n            \n                        throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operator.\");", "author": "yfarjoun", "createdAt": "2020-03-18T20:23:59Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -964,8 +1150,18 @@ public boolean isClipOverlappingReads() {\n         return clipOverlappingReads;\n     }\n \n-    public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n+    public void setClipOverlappingReads(final boolean clipOverlappingReads, final CigarOperator clipOverlappingReadsOperator,\n+                                        final ReadStructure read1Structure, final ReadStructure read2Structure,\n+                                        final List<AdapterPair> adapters) {\n         this.clipOverlappingReads = clipOverlappingReads;\n+        if (clipOverlappingReads && !clipOverlappingReadsOperator.isClipping()) {\n+            throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operatore.\");", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -1150,18 +1019,13 @@ public abstract class AbstractAlignmentMerger {\n         return clipOverlappingReads;\n     }\n \n-    public void setClipOverlappingReads(final boolean clipOverlappingReads, final CigarOperator clipOverlappingReadsOperator,\n-                                        final ReadStructure read1Structure, final ReadStructure read2Structure,\n-                                        final List<AdapterPair> adapters) {\n+    public void setClipOverlappingReads(final boolean clipOverlappingReads, final CigarOperator clipOverlappingReadsOperator) {\n         this.clipOverlappingReads = clipOverlappingReads;\n         if (clipOverlappingReads && !clipOverlappingReadsOperator.isClipping()) {\n-            throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operatore.\");\n+            throw new IllegalArgumentException(\"clippingOverlappingReadsOperator \" + clipOverlappingReadsOperator + \" is not a clipping operator.\");\n         }\n \n         this.clipOverlappingReadsOperator = clipOverlappingReadsOperator;\n-        this.read1Structure = read1Structure;\n-        this.read2Structure = read2Structure;\n-        this.adapterPairs = adapters;\n     }\n \n     public boolean isKeepAlignerProperPairFlags() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MTg2NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394671864", "bodyText": "Why do we need two read structures? the read structure is something that breaks up the entire stream of cycles into various things: UMIs,  Sample BCs, Template reads, skips...it is not clear (to me!) how a single readStructure should be broken up into to.", "author": "yfarjoun", "createdAt": "2020-03-18T22:19:32Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -280,6 +301,16 @@\n             \"the result will be an invalid record. To force no change use the DO_NOT_CHANGE_INVALID strategy.\", optional = true)\n     public AbstractAlignmentMerger.UnmappingReadStrategy UNMAPPED_READ_STRATEGY = AbstractAlignmentMerger.UnmappingReadStrategy.DO_NOT_CHANGE;\n \n+    @Argument(doc = \"Structure of read 1.  If this and READ_STRUCTURE both are unspecified, will be assumed that all bases in read 1 are template. Cannot be used with READ_STRUCTURE.\", optional = true, mutex = {\"READ_STRUCTURE\"})\n+    public ReadStructure READ_1_STRUCTURE;", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/MergeBamAlignment.java b/src/main/java/picard/sam/MergeBamAlignment.java\nindex 8072a2911..3ec4c7a10 100644\n--- a/src/main/java/picard/sam/MergeBamAlignment.java\n+++ b/src/main/java/picard/sam/MergeBamAlignment.java\n\n@@ -301,16 +284,6 @@ public class MergeBamAlignment extends CommandLineProgram {\n             \"the result will be an invalid record. To force no change use the DO_NOT_CHANGE_INVALID strategy.\", optional = true)\n     public AbstractAlignmentMerger.UnmappingReadStrategy UNMAPPED_READ_STRATEGY = AbstractAlignmentMerger.UnmappingReadStrategy.DO_NOT_CHANGE;\n \n-    @Argument(doc = \"Structure of read 1.  If this and READ_STRUCTURE both are unspecified, will be assumed that all bases in read 1 are template. Cannot be used with READ_STRUCTURE.\", optional = true, mutex = {\"READ_STRUCTURE\"})\n-    public ReadStructure READ_1_STRUCTURE;\n-\n-    @Argument(doc = \"Structure of read 2.  If this and READ_STRUCTURE both are unspecified, will be assumed that all bases in read 2 are template. Cannot be used with READ_STRUCTURE.\", optional = true, mutex = {\"READ_STRUCTURE\"})\n-    public ReadStructure READ_2_STRUCTURE;\n-\n-    @Argument(doc = \"Structure shared by read 1 and read 2.  Unspecified read structures are assumed to be all template bases.  Cannot be used with either READ_1_STRUCTURE or READ_2_STRUCTURE\", optional = true,\n-            mutex = {\"READ_1_STRUCTURE\", \"READ_2_STRUCTURE\"})\n-    public ReadStructure READ_STRUCTURE;\n-\n     @Override\n     protected boolean requiresReference() {\n         return true;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MjcxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394672719", "bodyText": "This function is awfully complex....but it seems to be doing a combination of things for which other functions already exist...can you explain what it does? perhaps it needs to be broken up into a few smaller methods.", "author": "yfarjoun", "createdAt": "2020-03-18T22:21:45Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -780,9 +821,154 @@ protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRe\n                         final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n                         CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n                     }\n+\n+                }\n+            }\n+        }\n+    }\n+\n+    protected static int getReadPositionToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {\n+\n+        if (refPosToClipFrom > rec.getUnclippedEnd() || refPosToClipFrom < rec.getUnclippedStart()) {\n+            //read doesn't cover position\n+            return -1;\n+        }\n+        final Cigar cigar = rec.getCigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(cigar.getCigarElements()); //need to be modifiable\n+        if (rec.getReadNegativeStrandFlag()) {\n+            Collections.reverse(cigarElements);\n+        }\n+\n+        int currentRefPosition = rec.getReadNegativeStrandFlag()? -rec.getUnclippedEnd() : rec.getUnclippedStart();\n+        final int refPosObjective = rec.getReadNegativeStrandFlag()? -refPosToClipFrom : refPosToClipFrom;\n+\n+        int currentReadPosition = 1;\n+\n+        for (final CigarElement cigarElement : cigarElements) {\n+\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if ((op.consumesReferenceBases() || op.isClipping()) && currentRefPosition + cigarElement.getLength() >= refPosObjective) {\n+                if (op.consumesReadBases() || op == CigarOperator.SOFT_CLIP) {\n+                    return currentReadPosition + refPosObjective - currentRefPosition;\n+                } else if (op == CigarOperator.HARD_CLIP) {\n+                    //for hardclip, position is not on read\n+                    return -1;\n+                } else {\n+                    //if doesn't consume read bases and isn't clipping, return current base\n+                    return currentReadPosition;\n                 }\n             }\n+\n+            if (op.consumesReferenceBases() || op.isClipping()) {\n+                currentRefPosition += cigarElement.getLength();\n+            }\n+\n+            if (op.consumesReadBases() || op.isClipping()) {\n+                currentReadPosition += cigarElement.getLength();\n+            }\n         }\n+\n+        //if we haven't found the correct position, there is a bug\n+        throw new PicardException(\"Could not find read position for reference position \" + refPosToClipFrom + \" which should be covered by read \" + rec);\n+    }\n+\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+        clipForOverlappingReads(read1, read2, CigarOperator.SOFT_CLIP, null, null, Collections.emptyList());\n+    }\n+\n+    protected static boolean basesToClipMatchAdapterPair(final SAMRecord read, final int posToClip, final AdapterPair adapterPair,", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex cf5a1dd60..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -785,48 +772,40 @@ public abstract class AbstractAlignmentMerger {\n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n \n-                    if (clippingOperator.equals(CigarOperator.HARD_CLIP)) {\n-\n-                        //need to consider unclipped positions because often the readthrough bases have already been soft-clipped\n-                        final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n-                        final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n-                        if (posClipFrom == negClipFrom && posClipFrom > 0) {\n-                            final int clipFrom = posClipFrom;\n+                    //need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                        final int clipFrom = posClipFrom;\n \n-                            for (final AdapterPair adapterPair : adaptersPairs) {\n-                                if (basesToClipMatchAdapterPair(read1, clipFrom - 1, adapterPair, read2Structure) && basesToClipMatchAdapterPair(read2, clipFrom - 1, adapterPair, read1Structure)) {\n-                                    CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, CigarOperator.HARD_CLIP);\n-                                    CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, CigarOperator.HARD_CLIP);\n-                                    return;\n-                                }\n-                            }\n+                        if (clippingOperator == CigarOperator.HARD_CLIP) {\n+                            moveClippedBasesToTag(read1, clipFrom);\n+                            moveClippedBasesToTag(read2, clipFrom);\n                         }\n-                    }\n \n-\n-                    //if we've gotten to here, try standard soft clipping.  Here we consider clipped position because we only are correcting where early sof-clipping isn't quite right\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n-\n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                        CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, clippingOperator);\n+                        CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, clippingOperator);\n                     }\n-\n                 }\n             }\n         }\n     }\n \n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        if(rec.getReadNegativeStrandFlag()) {\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1)));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1)));\n+        } else {\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities,clipFrom - 1, readLength)));\n+        }\n+    }\n+\n     protected static int getReadPositionToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {\n \n         if (refPosToClipFrom > rec.getUnclippedEnd() || refPosToClipFrom < rec.getUnclippedStart()) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1MTY4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r391151687", "bodyText": "import picard.util.IlluminaUtil;\ncan be removed", "author": "fleharty", "createdAt": "2020-03-11T17:44:16Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -29,7 +29,13 @@\n import htsjdk.samtools.reference.ReferenceSequenceFileWalker;\n import htsjdk.samtools.SAMFileHeader.SortOrder;\n import htsjdk.samtools.util.*;\n+import htsjdk.tribble.util.ParsingUtils;\n import picard.PicardException;\n+import picard.illumina.parser.ReadDescriptor;\n+import picard.illumina.parser.ReadStructure;\n+import picard.illumina.parser.ReadType;\n+import picard.util.AdapterPair;\n+import picard.util.IlluminaUtil;", "originalCommit": "519b1616d9e9a0a8096e761c85acf297eb19f3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex b67d6ec69..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -29,13 +29,7 @@ import htsjdk.samtools.filter.SamRecordFilter;\n import htsjdk.samtools.reference.ReferenceSequenceFileWalker;\n import htsjdk.samtools.SAMFileHeader.SortOrder;\n import htsjdk.samtools.util.*;\n-import htsjdk.tribble.util.ParsingUtils;\n import picard.PicardException;\n-import picard.illumina.parser.ReadDescriptor;\n-import picard.illumina.parser.ReadStructure;\n-import picard.illumina.parser.ReadType;\n-import picard.util.AdapterPair;\n-import picard.util.IlluminaUtil;\n \n import java.io.File;\n import java.util.*;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE1Mjg1MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r391152851", "bodyText": "Are you suggesting 45 since that is what we believe PCR error to be?\nIf so, it might be useful to have a comment here explaining the justification for 45.", "author": "fleharty", "createdAt": "2020-03-11T17:46:09Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -59,6 +65,10 @@\n \n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n+    public static final int MAX_ERROR_PHRED = 45;", "originalCommit": "519b1616d9e9a0a8096e761c85acf297eb19f3d7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex b67d6ec69..d64aa5236 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -65,11 +59,10 @@ public abstract class AbstractAlignmentMerger {\n \n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n-    public static final int MAX_ERROR_PHRED = 45;\n-\n-    private static final double LIKELIHOOD_RATIO_THRESHOLD = 1e3;\n-\n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n+    static final String HARD_CLIPPED_BASES_TAG = \"XB\";\n+    static final String HARD_CLIPPED_BASE_QUALITIES_TAG = \"XQ\";\n+\n     private int crossSpeciesReads = 0;\n \n     private final Log log = Log.getInstance(AbstractAlignmentMerger.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzc4Mzk3Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r393783977", "bodyText": "If this is going to be public, then I think it should have javadoc", "author": "fleharty", "createdAt": "2020-03-17T15:53:52Z", "path": "src/main/java/picard/illumina/CustomAdapterPair.java", "diffHunk": "@@ -28,12 +28,12 @@\n import htsjdk.samtools.util.StringUtil;\n import picard.util.AdapterPair;\n \n-class CustomAdapterPair implements AdapterPair {\n+public class CustomAdapterPair implements AdapterPair {\n \n     private final String fivePrime, threePrime, fivePrimeReadOrder;\n     private final byte[] fivePrimeBytes, threePrimeBytes, fivePrimeReadOrderBytes;\n \n-    CustomAdapterPair(final String fivePrime, final String threePrime) {\n+    public CustomAdapterPair(final String fivePrime, final String threePrime) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/illumina/CustomAdapterPair.java b/src/main/java/picard/illumina/CustomAdapterPair.java\nindex 90e1e67fe..ac3e6cb78 100644\n--- a/src/main/java/picard/illumina/CustomAdapterPair.java\n+++ b/src/main/java/picard/illumina/CustomAdapterPair.java\n\n@@ -28,12 +28,12 @@ import htsjdk.samtools.util.SequenceUtil;\n import htsjdk.samtools.util.StringUtil;\n import picard.util.AdapterPair;\n \n-public class CustomAdapterPair implements AdapterPair {\n+class CustomAdapterPair implements AdapterPair {\n \n     private final String fivePrime, threePrime, fivePrimeReadOrder;\n     private final byte[] fivePrimeBytes, threePrimeBytes, fivePrimeReadOrderBytes;\n \n-    public CustomAdapterPair(final String fivePrime, final String threePrime) {\n+    CustomAdapterPair(final String fivePrime, final String threePrime) {\n         this.threePrime = threePrime;\n         this.threePrimeBytes = StringUtil.stringToBytes(threePrime);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDcyODQxMw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394728413", "bodyText": "Maybe say, \"adapter kit\", or something similar just to be more specific", "author": "fleharty", "createdAt": "2020-03-19T00:57:13Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -256,9 +261,25 @@\n             \"alignment is filtered out for some reason. For all strategies, ties are resolved arbitrarily.\")\n     public PrimaryAlignmentStrategy PRIMARY_ALIGNMENT_STRATEGY = PrimaryAlignmentStrategy.BestMapq;\n \n-    @Argument(doc = \"For paired reads, soft clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.\")\n+    @Argument(doc = \"For paired reads, clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.  Clipping will be either soft or hard clipping, depending on CLIP_OVERLAPPING_READS_OPERATOR setting.\")\n     public boolean CLIP_OVERLAPPING_READS = true;\n \n+    @Argument(doc = \"Type of clipping to used for overlapping reads.  If set to hard clip, hard clipping will only be performed if bases to be clipped match expected adapter sequences, otherwise bases will be soft clipped.\")\n+    public CigarOperator CLIP_OVERLAPPING_READS_OPERATOR = CigarOperator.SOFT_CLIP;\n+\n+    @Argument(doc = \"Which adapters to look for in the read.\")", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/MergeBamAlignment.java b/src/main/java/picard/sam/MergeBamAlignment.java\nindex 8072a2911..3ec4c7a10 100644\n--- a/src/main/java/picard/sam/MergeBamAlignment.java\n+++ b/src/main/java/picard/sam/MergeBamAlignment.java\n\n@@ -267,19 +263,6 @@ public class MergeBamAlignment extends CommandLineProgram {\n     @Argument(doc = \"Type of clipping to used for overlapping reads.  If set to hard clip, hard clipping will only be performed if bases to be clipped match expected adapter sequences, otherwise bases will be soft clipped.\")\n     public CigarOperator CLIP_OVERLAPPING_READS_OPERATOR = CigarOperator.SOFT_CLIP;\n \n-    @Argument(doc = \"Which adapters to look for in the read.\")\n-    public List<IlluminaUtil.IlluminaAdapterPair> ADAPTERS_TO_CHECK = new ArrayList<>(\n-            Arrays.asList(IlluminaUtil.IlluminaAdapterPair.INDEXED,\n-                    IlluminaUtil.IlluminaAdapterPair.DUAL_INDEXED,\n-                    IlluminaUtil.IlluminaAdapterPair.NEXTERA_V2,\n-                    IlluminaUtil.IlluminaAdapterPair.FLUIDIGM));\n-\n-    @Argument(doc = \"For specifying adapters other than standard Illumina\", optional = true)\n-    public String FIVE_PRIME_ADAPTER;\n-\n-    @Argument(doc = \"For specifying adapters other than standard Illumina\", optional = true)\n-    public String THREE_PRIME_ADAPTER;\n-\n     @Argument(doc = \"If false, do not write secondary alignments to output.\")\n     public boolean INCLUDE_SECONDARY_ALIGNMENTS = true;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczNzkxNA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394737914", "bodyText": "Should there be a check on if FIVE_PRIME_ADAPTER == null and THREE_PRIME_ADAPTER != null and\nvice versa?  Maybe throw an exception.", "author": "fleharty", "createdAt": "2020-03-19T01:26:36Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -348,7 +379,16 @@ protected int doWork() {\n                 READ1_ALIGNED_BAM, READ2_ALIGNED_BAM, EXPECTED_ORIENTATIONS, SORT_ORDER,\n                 PRIMARY_ALIGNMENT_STRATEGY.newInstance(), ADD_MATE_CIGAR, UNMAP_CONTAMINANT_READS,\n                 MIN_UNCLIPPED_BASES, UNMAPPED_READ_STRATEGY, MATCHING_DICTIONARY_TAGS);\n-        merger.setClipOverlappingReads(CLIP_OVERLAPPING_READS);\n+\n+        final List<AdapterPair> adapters = new ArrayList<>(ADAPTERS_TO_CHECK);\n+\n+        if (FIVE_PRIME_ADAPTER != null && THREE_PRIME_ADAPTER != null) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/main/java/picard/sam/MergeBamAlignment.java b/src/main/java/picard/sam/MergeBamAlignment.java\nindex 8072a2911..3ec4c7a10 100644\n--- a/src/main/java/picard/sam/MergeBamAlignment.java\n+++ b/src/main/java/picard/sam/MergeBamAlignment.java\n\n@@ -380,15 +353,7 @@ public class MergeBamAlignment extends CommandLineProgram {\n                 PRIMARY_ALIGNMENT_STRATEGY.newInstance(), ADD_MATE_CIGAR, UNMAP_CONTAMINANT_READS,\n                 MIN_UNCLIPPED_BASES, UNMAPPED_READ_STRATEGY, MATCHING_DICTIONARY_TAGS);\n \n-        final List<AdapterPair> adapters = new ArrayList<>(ADAPTERS_TO_CHECK);\n-\n-        if (FIVE_PRIME_ADAPTER != null && THREE_PRIME_ADAPTER != null) {\n-            adapters.add(new CustomAdapterPair(FIVE_PRIME_ADAPTER, THREE_PRIME_ADAPTER));\n-        }\n-\n-        merger.setClipOverlappingReads(CLIP_OVERLAPPING_READS, CLIP_OVERLAPPING_READS_OPERATOR,\n-                READ_STRUCTURE!= null ? READ_STRUCTURE : READ_1_STRUCTURE, READ_STRUCTURE!= null ? READ_STRUCTURE : READ_2_STRUCTURE,\n-                adapters);\n+        merger.setClipOverlappingReads(CLIP_OVERLAPPING_READS, CLIP_OVERLAPPING_READS_OPERATOR);\n         merger.setMaxRecordsInRam(MAX_RECORDS_IN_RAM);\n         merger.setKeepAlignerProperPairFlags(ALIGNER_PROPER_PAIR_FLAGS);\n         merger.setIncludeSecondaryAlignments(INCLUDE_SECONDARY_ALIGNMENTS);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDczOTAxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394739011", "bodyText": "A lot of code duplication here\ntesOverlappedReadClippingWithNonOverlappedReads (has misspelling in name)\ntestOverlappedReadHardClippingWithNonOverlappedReads\ntestBasicOverlappedReadClipping\nare all basically the same thing, they could be consolidated into a single test that uses a data provider.", "author": "fleharty", "createdAt": "2020-03-19T01:31:20Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -36,6 +48,22 @@\n         Assert.assertEquals(r2.getCigarString(), \"110M\");\n     }\n \n+    @Test", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\nindex ec2d819a1..d9f8ca454 100644\n--- a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n+++ b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n\n@@ -35,339 +18,143 @@ import java.util.List;\n  * Tests related to code in AbstractAlignmentMerger\n  */\n public class AbstractAlignmentMergerTest extends CommandLineProgramTest {\n-    @Test public void tesOverlappedReadClippingWithNonOverlappedReads() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 200, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"110M\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 200);\n-        Assert.assertEquals(r2.getCigarString(), \"110M\");\n-    }\n \n-    @Test\n-    public void testOverlappedReadHardClippingWithNonOverlappedReads() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 200, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, null, null, Collections.emptyList());\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"110M\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 200);\n-        Assert.assertEquals(r2.getCigarString(), \"110M\");\n-        Assert.assertEquals(r1.getReadLength(), 110);\n-        Assert.assertEquals(r2.getReadLength(), 110);\n-    }\n+    @DataProvider(name = \"overlapReadData\")\n+    public Object[][] overlapReadData() {\n+        // The spaces here are deliberate to illustrate the region the two default reads match\n+        final String default120LongR1Bases =                     \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACCAGATTCTCCTGTCAGTTTGC\";\n+        final String default120LongR2Bases = \"CGTTGGCAATGCCGGGCACAATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-    @Test public void testBasicOverlappedReadClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 90, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M10S\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n-    }\n+        final String default110LongR1Bases =           \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACCAGATTCTCCT\";\n+        final String default110LongR2Bases = \"GCCGGGCACAATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-    @DataProvider(name = \"hardClippingDataProvider\")\n-    public Object [][] getHardClippingData() {\n-\n-\n-        final List<Object[]> ret = new ArrayList<>();\n-        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n-        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n-        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n-        SequenceUtil.reverseComplement(templateBasesRC);\n-        //All Illumina barcode combinations should work\n-        \n-        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n-            final int readLength = templateBases.length + nAdapterBases;\n-            final String cigarF = readLength + \"M\";\n-            final String cigarR = readLength + \"M\";\n-            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n-            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n-\n-            for (final AdapterPair adapterPair : illuminaAdapters) {\n-                SequenceUtil.reverseComplement(templateBasesRC);\n-                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n-                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n-                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n-                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n-                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n-                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n-            }\n+        final String sharedBases = \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n-            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+        final String default120LongR1ClippedBases = \"AGATTCTCCTGTCAGTTTGC\";\n+        final String default120LongR2ClippedBases = \"CGTTGGCAATGCCGGGCACA\";\n \n-            //3' of one barcode, 5' of another, should only softclip\n-            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n-                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n-                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n-            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n-                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n-                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+        final String default110LongR1ClippedBases = \"AGATTCTCCT\";\n+        final String default110LongR2ClippedBases = \"GCCGGGCACA\";\n \n-        }\n+        final String default120LongR1BaseQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF.FFF.FFF\";\n+        final String default120LongR2BaseQualities =\"FFFFFF.FFFFF.FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n+        final String default110LongR1BaseQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF.FFF\";\n+        final String default110LongR2BaseQualities = \"FFFFFF.FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n \n-        //already soft-clipped\n-        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-        //already soft-clipped more than adapters\n-        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //already hard-clipped\n-        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //soft-clipped beginning\n-        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n-\n-\n-        //hard-clipped beginning\n-        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n-\n-        //insertion in reads\n-        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n-\n-        //insertion in adapter portion of read\n-        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //deletion in reads\n-        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n-\n-        //deletion in adapter portion of read\n-        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //Ns in adapter\n-        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n-        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n-                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n-                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //read structures and UMIs\n-        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n-            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n-                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n-                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n-                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n-                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n-\n-\n-                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n-                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n-\n-                    final String umi1String = StringUtil.bytesToString(umi1);\n-                    final String umi2String = StringUtil.bytesToString(umi2);\n-\n-                    SequenceUtil.reverseComplement(umi1);\n-                    SequenceUtil.reverseComplement(umi2);\n-\n-                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);\n-                    final byte[] templateBasesRCWithUMI = ArrayUtils.addAll(templateBasesRCClipped, umi2);\n-\n-                    final List<ReadDescriptor> readDescriptors = new ArrayList<>();\n-                    if (gapBeforeUMI > 0) {\n-                        readDescriptors.add(new ReadDescriptor(gapBeforeUMI, ReadType.Skip));\n-                    }\n-                    if (umiLength > 0) {\n-                        readDescriptors.add(new ReadDescriptor(umiLength, ReadType.MolecularIndex));\n-                    }\n-                    if (gapAfterUMI > 0) {\n-                        readDescriptors.add(new ReadDescriptor(gapAfterUMI, ReadType.Skip));\n-                    }\n-                    readDescriptors.add(new ReadDescriptor(110 - totalBasesToRemove, ReadType.Template));\n-\n-                    final ReadStructure readStructure = new ReadStructure(readDescriptors);\n-\n-                    ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                            buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                            false, true, 100, 90 - totalBasesToRemove, illuminaAdapters, (110 - totalBasesToRemove) + \"M\" + (10 + totalBasesToRemove) + \"H\", (10 + totalBasesToRemove) + \"H\" + (110 - totalBasesToRemove) + \"M\", 100, 100,\n-                            umi1String + \"-\" + umi2String, readStructure});\n-\n-                }\n-            }\n-        }\n+        final String sharedQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n \n-        return ret.toArray(new Object[][]{});\n-    }\n+        final String r1ClippedQualities10 = \"FF.FFF.FFF\";\n+        final String r2ClippedQualities10 = \"FFFFFF.FFF\";\n+        final String r1ClippedQualities20 = \"FFFFFFFF.FFF.FFF.FFF\";\n+        final String r2ClippedQualities20 = \"FFFFFF.FFFFF.FFFFFFF\";\n \n-    private byte[] buildReadBases(final byte[] templateBasesReadOrder, final byte[] adapterBasesReadOrder, final int readLength, final boolean negativeStrand) {\n-        final byte[] bases = ArrayUtils.addAll(templateBasesReadOrder, adapterBasesReadOrder);\n-        final byte[] readBases = Arrays.copyOf(bases, readLength);\n-        if (negativeStrand) {\n-            SequenceUtil.reverseComplement(readBases);\n-        }\n-        return readBases;\n-    }\n+        return new Object[][] {\n+                {110, 100, 200, \"110M\", \"110M\", false, true, 100, 200, \"110M\", \"110M\", CigarOperator.SOFT_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null}, // Non overlapping reads\n \n-    @Test (dataProvider = \"hardClippingDataProvider\")\n-    public void testOverlappedReadHardClipping(final String originalCigar1, final String originalCigar2, final byte[] read1Bases, final byte[] read2Bases, final boolean strand1, final boolean strand2,\n-                                               final int start1, final int start2, final List<AdapterPair> adapters, final String expectedCigar1, final String expectedCigar2, final int expectedStart1, final int expectedStart2,\n-                                               final String umiTag, final ReadStructure readStructure) {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, originalCigar1, originalCigar2, strand1, strand2, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n+                {110, 100, 200, \"110M\", \"110M\", false, true, 100, 200, \"110M\", \"110M\", CigarOperator.HARD_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null},\n \n-        r1.setReadBases(read1Bases);\n-        r2.setReadBases(read2Bases);\n+                {110, 100, 90, \"110M\", \"110M\", false, true, 100, 100, \"100M10S\", \"10S100M\", CigarOperator.SOFT_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null}, // Basic overlapped read\n \n-        if (umiTag != null) {\n-            r1.setAttribute(SAMTag.RX.toString(), umiTag);\n-            r2.setAttribute(SAMTag.RX.toString(), umiTag);\n-        }\n+                {110, 100, 90, \"110M\", \"110M\", false, true, 100, 100, \"100M10H\", \"10H100M\", CigarOperator.HARD_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, sharedBases, sharedBases, default110LongR1ClippedBases, default110LongR2ClippedBases,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities10, r2ClippedQualities10},\n \n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, readStructure, readStructure, adapters);\n-        Assert.assertEquals(r1.getAlignmentStart(), expectedStart1);\n-        Assert.assertEquals(r1.getCigarString(), expectedCigar1);\n+                {120, 100, 95, \"110M10S5H\", \"5H15S105M\", false, true, 100, 100, \"100M20S5H\", \"5H20S100M\", CigarOperator.SOFT_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, default120LongR1Bases, default120LongR2Bases, null, null,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, default120LongR1BaseQualities, default120LongR2BaseQualities, null, null}, // Already hard and soft clipped\n \n-        Assert.assertEquals(r2.getAlignmentStart(), expectedStart2);\n-        Assert.assertEquals(r2.getCigarString(), expectedCigar2);\n-    }\n+                {120, 100, 95, \"110M10S5H\", \"5H15S105M\", false, true, 100, 100, \"100M25H\", \"25H100M\", CigarOperator.HARD_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, sharedBases, sharedBases, default120LongR1ClippedBases, default120LongR2ClippedBases,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities20, r2ClippedQualities20},\n \n-    @DataProvider(name = \"getReadPosToClipFromDataProvider\")\n-    public Object[][] getReadPosToClipFromData() {\n-        return new Object[][] {\n-                {\"120M\", false, 450, 502, 53},\n-                {\"120M\", true, 450, 502, 68},\n-                {\"120M\", false, 450, 580, -1},\n-                {\"120M\", false, 450, 440, -1},\n-                {\"120M\", true, 450, 580, -1},\n-                {\"120M\", true, 450, 440, -1},\n-\n-                {\"100M3I100M\", false, 300, 425, 129},\n-                {\"100M3I100M\", true, 300, 425, 75},\n-\n-                {\"100M3D100M\", false, 300, 425, 123},\n-                {\"100M3D100M\", true, 300, 425, 78},\n-\n-                {\"100M16S\", false, 300, 410, 111},\n-                {\"100M16S\", true, 300, 400, 16},\n-                {\"16S100M\", false, 316, 410, 111},\n-                {\"16S100M\", true, 316, 310, 106},\n-\n-                {\"100M16H\", false, 300, 410, -1},\n-                {\"100M16H\", true, 300, 410, -1},\n-                {\"100M16H\", true, 300, 390, 26},\n-                {\"16H100M\", false, 316, 310, -1},\n-                {\"16H100M\", true, 316, 310, -1},\n-                {\"16H100M\", true, 316, 350, 66}\n-        };\n-    }\n+                {120, 100, 95, \"110M10S\", \"15S105M\", false, true, 100, 100, \"100M20S\", \"20S100M\", CigarOperator.SOFT_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, default120LongR1Bases, default120LongR2Bases, null, null,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, default120LongR1BaseQualities, default120LongR2BaseQualities, null, null}, // Already soft clipped\n \n-    @Test(dataProvider = \"getReadPosToClipFromDataProvider\")\n-    public void testGetReadPositionToClipFrom(final String cigarString, final boolean negativeStrand, final int start, final int refPosToClipFrom, final int expectedReadPosToCLipFrom) {\n-        final SAMFileHeader header = new SAMFileHeader();\n-        final SAMRecord rec = new SAMRecord(header);\n-        rec.setCigarString(cigarString);\n-        rec.setReadNegativeStrandFlag(negativeStrand);\n-        rec.setAlignmentStart(start);\n+                {120, 100, 95, \"110M10S\", \"15S105M\", false, true, 100, 100, \"100M20H\", \"20H100M\", CigarOperator.HARD_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, sharedBases, sharedBases, default120LongR1ClippedBases, default120LongR2ClippedBases,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities20, r2ClippedQualities20}\n \n-        final int readPositionToClipFrom = AbstractAlignmentMerger.getReadPositionToClipFrom(rec, refPosToClipFrom);\n-        Assert.assertEquals(readPositionToClipFrom, expectedReadPosToCLipFrom);\n+        };\n     }\n \n-    @DataProvider(name = \"basesToClipDataProvider\")\n-    public Object[][] getBasesToClipDataProvider() {\n-        final List<Object[]> ret = new ArrayList<>();\n-        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n-        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n-        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n-        SequenceUtil.reverseComplement(templateBasesRC);\n+    @Test(dataProvider = \"overlapReadData\")\n+    public void testOverlappedReadClipping(final int readLength, final int start1, final int start2, final String cigar1, final String cigar2,\n+                                           final boolean strand1, final boolean strand2,\n+                                           final int r1ExpectedAlignmentStart, final int r2ExpectedAlignmentStart,\n+                                           final String expectedR1Cigar, final String expectedR2Cigar, final CigarOperator clippingOperator,\n+                                           final String read1Bases, final String read2Bases, final String expectedR1Bases, final String expectedR2Bases,\n+                                           final String expectedR1ClippedBases, final String expectedR2ClippedBases, final String read1Qualities,\n+                                           final String read2Qualities, final String expectedR1Qualities, final String expectedR2Qualities,\n+                                           final String expectedR1ClippedQualities, final String expectedR2ClippedQualities) {\n \n-        final String threePrimeAdapterBases = \"GTCGATTACAG\";\n-        final String fivePrimeAdapterBases = \"GACGGATCAGAC\";\n+        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n+        set.setReadLength(readLength);\n+        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, cigar1, cigar2, strand1, strand2, 30);\n+        final SAMRecord r1 = recs.get(0);\n+        final SAMRecord r2 = recs.get(1);\n \n+        r1.setReadBases(StringUtil.stringToBytes(read1Bases));\n+        r2.setReadBases(StringUtil.stringToBytes(read2Bases));\n \n-        final byte[] q30Quals = new byte[120];\n-        Arrays.fill(q30Quals, (byte)30);\n+        r1.setBaseQualities(SAMUtils.fastqToPhred(read1Qualities));\n+        r2.setBaseQualities(SAMUtils.fastqToPhred(read2Qualities));\n \n-        final CustomAdapterPair adapterPair = new CustomAdapterPair(fivePrimeAdapterBases, threePrimeAdapterBases);\n-        ret.add(new Object[] {buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), 120, false), q30Quals, adapterPair, true});\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, clippingOperator);\n+        Assert.assertEquals(r1.getAlignmentStart(), r1ExpectedAlignmentStart);\n+        Assert.assertEquals(r1.getCigarString(), expectedR1Cigar);\n+        Assert.assertEquals(r2.getAlignmentStart(), r2ExpectedAlignmentStart);\n+        Assert.assertEquals(r2.getCigarString(), expectedR2Cigar);\n+        Assert.assertEquals(r1.getReadString(), expectedR1Bases);\n+        Assert.assertEquals(r2.getReadString(), expectedR2Bases);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r1.getBaseQualities()), expectedR1Qualities);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r2.getBaseQualities()), expectedR2Qualities);\n \n+        Assert.assertEquals(r1.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR1ClippedBases);\n+        Assert.assertEquals(r2.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR2ClippedBases);\n \n-        final String threePrimeAdapterBasesOneError = \"GTGGATTACAG\";\n-        final String threePrimeAdapterBasesTwoError = \"GTGGCTTACAG\";\n-        final String threePrimeAdapterBasesThreeError = \"GTGGCATACAG\";\n+        Assert.assertEquals(r1.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR1ClippedQualities);\n+        Assert.assertEquals(r2.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR2ClippedQualities);\n \n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesOneError), 120, false), q30Quals, adapterPair, true}); //one error still matches\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesTwoError), 120, false), q30Quals, adapterPair, true}); //two errors still matches\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesThreeError), 120, false), q30Quals, adapterPair, false}); //three errors in first six bases fails\n \n-        final byte[] q30TemplateQuals = new byte[110];\n-        Arrays.fill(q30Quals, (byte)30);\n-        final byte[] lowQErrorAdapterQuals = new byte[]{30, 30, 6, 30, 6, 6, 30, 30, 30, 30};\n-        final byte[] lowQErrorQuals = ArrayUtils.addAll(q30TemplateQuals, lowQErrorAdapterQuals);\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesThreeError), 120, false), lowQErrorQuals, adapterPair, true}); //mismatches at low quality bases still match\n+        // Swap first and second read to ensure logic is correct for both F1R2 and F2R1\n+        final SAMRecordSetBuilder setSwapped = new SAMRecordSetBuilder();\n+        setSwapped.setReadLength(readLength);\n+        final List<SAMRecord> recsSwapped = set.addPair(\"q1\", 0, start2, start1, false, false, cigar2, cigar1, strand2, strand1, 30);\n+        final SAMRecord r1Swapped = recsSwapped.get(0);\n+        final SAMRecord r2Swapped = recsSwapped.get(1);\n \n+        r1Swapped.setReadBases(StringUtil.stringToBytes(read2Bases));\n+        r2Swapped.setReadBases(StringUtil.stringToBytes(read1Bases));\n \n-        return ret.toArray(new Object[][]{});\n-    }\n+        r1Swapped.setBaseQualities(SAMUtils.fastqToPhred(read2Qualities));\n+        r2Swapped.setBaseQualities(SAMUtils.fastqToPhred(read1Qualities));\n \n-    @Test(dataProvider = \"basesToClipDataProvider\")\n-    public void testBasesToClipMatchAdapterPair(final byte[] bases, final byte[] quals, final AdapterPair adapterPair, final boolean expectToMatch) {\n-        final SAMFileHeader header = new SAMFileHeader();\n-        final SAMRecord rec = new SAMRecord(header);\n-        rec.setReadPairedFlag(true);\n-        rec.setFirstOfPairFlag(true);\n-        rec.setReadBases(bases);\n-        rec.setBaseQualities(quals);\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1Swapped, r2Swapped, clippingOperator);\n+        Assert.assertEquals(r1Swapped.getAlignmentStart(), r2ExpectedAlignmentStart);\n+        Assert.assertEquals(r1Swapped.getCigarString(), expectedR2Cigar);\n+        Assert.assertEquals(r2Swapped.getAlignmentStart(), r1ExpectedAlignmentStart);\n+        Assert.assertEquals(r2Swapped.getCigarString(), expectedR1Cigar);\n+        Assert.assertEquals(r1Swapped.getReadString(), expectedR2Bases);\n+        Assert.assertEquals(r2Swapped.getReadString(), expectedR1Bases);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r1Swapped.getBaseQualities()), expectedR2Qualities);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r2Swapped.getBaseQualities()), expectedR1Qualities);\n \n-        final boolean basesMatch = AbstractAlignmentMerger.basesToClipMatchAdapterPair(rec, 110, adapterPair, null);\n-        Assert.assertEquals(basesMatch, expectToMatch);\n+        Assert.assertEquals(r1Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR2ClippedBases);\n+        Assert.assertEquals(r2Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR1ClippedBases);\n \n-    }\n+        Assert.assertEquals(r1Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR2ClippedQualities);\n+        Assert.assertEquals(r2Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR1ClippedQualities);\n \n-    @Test public void testOverlappedReadClippingWithExistingSoftClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(120);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 95, false, false, \"110M10S\", \"15S105M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M20S\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"20S100M\");\n     }\n \n-    @Test public void testOverlappedReadClippingWithExistingSoftClippingAndHardClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(120);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 95, false, false, \"110M10S5H\", \"5H15S105M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M20S5H\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"5H20S100M\");\n-    }\n+\n \n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NDc1MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394754751", "bodyText": "expectedReadPosToCLipFrom - funny capitalization in CLip", "author": "fleharty", "createdAt": "2020-03-19T02:22:44Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -49,6 +77,272 @@\n         Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n     }\n \n+    @DataProvider(name = \"hardClippingDataProvider\")\n+    public Object [][] getHardClippingData() {\n+\n+\n+        final List<Object[]> ret = new ArrayList<>();\n+        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n+        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n+        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n+        SequenceUtil.reverseComplement(templateBasesRC);\n+        //All Illumina barcode combinations should work\n+        \n+        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n+            final int readLength = templateBases.length + nAdapterBases;\n+            final String cigarF = readLength + \"M\";\n+            final String cigarR = readLength + \"M\";\n+            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n+            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n+\n+            for (final AdapterPair adapterPair : illuminaAdapters) {\n+                SequenceUtil.reverseComplement(templateBasesRC);\n+                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n+                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n+            }\n+\n+            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n+            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+\n+            //3' of one barcode, 5' of another, should only softclip\n+            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n+            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+\n+        }\n+\n+        //already soft-clipped\n+        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+        //already soft-clipped more than adapters\n+        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //already hard-clipped\n+        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //soft-clipped beginning\n+        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n+\n+\n+        //hard-clipped beginning\n+        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n+\n+        //insertion in reads\n+        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n+\n+        //insertion in adapter portion of read\n+        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //deletion in reads\n+        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n+\n+        //deletion in adapter portion of read\n+        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //Ns in adapter\n+        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n+        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n+                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n+                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //read structures and UMIs\n+        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n+            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n+                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n+                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n+                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n+                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n+\n+\n+                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n+                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n+\n+                    final String umi1String = StringUtil.bytesToString(umi1);\n+                    final String umi2String = StringUtil.bytesToString(umi2);\n+\n+                    SequenceUtil.reverseComplement(umi1);\n+                    SequenceUtil.reverseComplement(umi2);\n+\n+                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);\n+                    final byte[] templateBasesRCWithUMI = ArrayUtils.addAll(templateBasesRCClipped, umi2);\n+\n+                    final List<ReadDescriptor> readDescriptors = new ArrayList<>();\n+                    if (gapBeforeUMI > 0) {\n+                        readDescriptors.add(new ReadDescriptor(gapBeforeUMI, ReadType.Skip));\n+                    }\n+                    if (umiLength > 0) {\n+                        readDescriptors.add(new ReadDescriptor(umiLength, ReadType.MolecularIndex));\n+                    }\n+                    if (gapAfterUMI > 0) {\n+                        readDescriptors.add(new ReadDescriptor(gapAfterUMI, ReadType.Skip));\n+                    }\n+                    readDescriptors.add(new ReadDescriptor(110 - totalBasesToRemove, ReadType.Template));\n+\n+                    final ReadStructure readStructure = new ReadStructure(readDescriptors);\n+\n+                    ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                            buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                            false, true, 100, 90 - totalBasesToRemove, illuminaAdapters, (110 - totalBasesToRemove) + \"M\" + (10 + totalBasesToRemove) + \"H\", (10 + totalBasesToRemove) + \"H\" + (110 - totalBasesToRemove) + \"M\", 100, 100,\n+                            umi1String + \"-\" + umi2String, readStructure});\n+\n+                }\n+            }\n+        }\n+\n+        return ret.toArray(new Object[][]{});\n+    }\n+\n+    private byte[] buildReadBases(final byte[] templateBasesReadOrder, final byte[] adapterBasesReadOrder, final int readLength, final boolean negativeStrand) {\n+        final byte[] bases = ArrayUtils.addAll(templateBasesReadOrder, adapterBasesReadOrder);\n+        final byte[] readBases = Arrays.copyOf(bases, readLength);\n+        if (negativeStrand) {\n+            SequenceUtil.reverseComplement(readBases);\n+        }\n+        return readBases;\n+    }\n+\n+    @Test (dataProvider = \"hardClippingDataProvider\")\n+    public void testOverlappedReadHardClipping(final String originalCigar1, final String originalCigar2, final byte[] read1Bases, final byte[] read2Bases, final boolean strand1, final boolean strand2,\n+                                               final int start1, final int start2, final List<AdapterPair> adapters, final String expectedCigar1, final String expectedCigar2, final int expectedStart1, final int expectedStart2,\n+                                               final String umiTag, final ReadStructure readStructure) {\n+        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n+        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, originalCigar1, originalCigar2, strand1, strand2, 30);\n+        final SAMRecord r1 = recs.get(0);\n+        final SAMRecord r2 = recs.get(1);\n+\n+        r1.setReadBases(read1Bases);\n+        r2.setReadBases(read2Bases);\n+\n+        if (umiTag != null) {\n+            r1.setAttribute(SAMTag.RX.toString(), umiTag);\n+            r2.setAttribute(SAMTag.RX.toString(), umiTag);\n+        }\n+\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, readStructure, readStructure, adapters);\n+        Assert.assertEquals(r1.getAlignmentStart(), expectedStart1);\n+        Assert.assertEquals(r1.getCigarString(), expectedCigar1);\n+\n+        Assert.assertEquals(r2.getAlignmentStart(), expectedStart2);\n+        Assert.assertEquals(r2.getCigarString(), expectedCigar2);\n+    }\n+\n+    @DataProvider(name = \"getReadPosToClipFromDataProvider\")\n+    public Object[][] getReadPosToClipFromData() {\n+        return new Object[][] {\n+                {\"120M\", false, 450, 502, 53},\n+                {\"120M\", true, 450, 502, 68},\n+                {\"120M\", false, 450, 580, -1},\n+                {\"120M\", false, 450, 440, -1},\n+                {\"120M\", true, 450, 580, -1},\n+                {\"120M\", true, 450, 440, -1},\n+\n+                {\"100M3I100M\", false, 300, 425, 129},\n+                {\"100M3I100M\", true, 300, 425, 75},\n+\n+                {\"100M3D100M\", false, 300, 425, 123},\n+                {\"100M3D100M\", true, 300, 425, 78},\n+\n+                {\"100M16S\", false, 300, 410, 111},\n+                {\"100M16S\", true, 300, 400, 16},\n+                {\"16S100M\", false, 316, 410, 111},\n+                {\"16S100M\", true, 316, 310, 106},\n+\n+                {\"100M16H\", false, 300, 410, -1},\n+                {\"100M16H\", true, 300, 410, -1},\n+                {\"100M16H\", true, 300, 390, 26},\n+                {\"16H100M\", false, 316, 310, -1},\n+                {\"16H100M\", true, 316, 310, -1},\n+                {\"16H100M\", true, 316, 350, 66}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"getReadPosToClipFromDataProvider\")\n+    public void testGetReadPositionToClipFrom(final String cigarString, final boolean negativeStrand, final int start, final int refPosToClipFrom, final int expectedReadPosToCLipFrom) {", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\nindex ec2d819a1..d9f8ca454 100644\n--- a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n+++ b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n\n@@ -35,339 +18,143 @@ import java.util.List;\n  * Tests related to code in AbstractAlignmentMerger\n  */\n public class AbstractAlignmentMergerTest extends CommandLineProgramTest {\n-    @Test public void tesOverlappedReadClippingWithNonOverlappedReads() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 200, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"110M\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 200);\n-        Assert.assertEquals(r2.getCigarString(), \"110M\");\n-    }\n \n-    @Test\n-    public void testOverlappedReadHardClippingWithNonOverlappedReads() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 200, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, null, null, Collections.emptyList());\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"110M\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 200);\n-        Assert.assertEquals(r2.getCigarString(), \"110M\");\n-        Assert.assertEquals(r1.getReadLength(), 110);\n-        Assert.assertEquals(r2.getReadLength(), 110);\n-    }\n+    @DataProvider(name = \"overlapReadData\")\n+    public Object[][] overlapReadData() {\n+        // The spaces here are deliberate to illustrate the region the two default reads match\n+        final String default120LongR1Bases =                     \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACCAGATTCTCCTGTCAGTTTGC\";\n+        final String default120LongR2Bases = \"CGTTGGCAATGCCGGGCACAATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-    @Test public void testBasicOverlappedReadClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 90, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M10S\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n-    }\n+        final String default110LongR1Bases =           \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACCAGATTCTCCT\";\n+        final String default110LongR2Bases = \"GCCGGGCACAATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-    @DataProvider(name = \"hardClippingDataProvider\")\n-    public Object [][] getHardClippingData() {\n-\n-\n-        final List<Object[]> ret = new ArrayList<>();\n-        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n-        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n-        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n-        SequenceUtil.reverseComplement(templateBasesRC);\n-        //All Illumina barcode combinations should work\n-        \n-        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n-            final int readLength = templateBases.length + nAdapterBases;\n-            final String cigarF = readLength + \"M\";\n-            final String cigarR = readLength + \"M\";\n-            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n-            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n-\n-            for (final AdapterPair adapterPair : illuminaAdapters) {\n-                SequenceUtil.reverseComplement(templateBasesRC);\n-                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n-                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n-                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n-                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n-                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n-                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n-            }\n+        final String sharedBases = \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n-            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+        final String default120LongR1ClippedBases = \"AGATTCTCCTGTCAGTTTGC\";\n+        final String default120LongR2ClippedBases = \"CGTTGGCAATGCCGGGCACA\";\n \n-            //3' of one barcode, 5' of another, should only softclip\n-            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n-                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n-                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n-            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n-                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n-                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+        final String default110LongR1ClippedBases = \"AGATTCTCCT\";\n+        final String default110LongR2ClippedBases = \"GCCGGGCACA\";\n \n-        }\n+        final String default120LongR1BaseQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF.FFF.FFF\";\n+        final String default120LongR2BaseQualities =\"FFFFFF.FFFFF.FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n+        final String default110LongR1BaseQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF.FFF\";\n+        final String default110LongR2BaseQualities = \"FFFFFF.FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n \n-        //already soft-clipped\n-        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-        //already soft-clipped more than adapters\n-        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //already hard-clipped\n-        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //soft-clipped beginning\n-        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n-\n-\n-        //hard-clipped beginning\n-        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n-\n-        //insertion in reads\n-        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n-\n-        //insertion in adapter portion of read\n-        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //deletion in reads\n-        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n-\n-        //deletion in adapter portion of read\n-        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //Ns in adapter\n-        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n-        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n-                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n-                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //read structures and UMIs\n-        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n-            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n-                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n-                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n-                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n-                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n-\n-\n-                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n-                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n-\n-                    final String umi1String = StringUtil.bytesToString(umi1);\n-                    final String umi2String = StringUtil.bytesToString(umi2);\n-\n-                    SequenceUtil.reverseComplement(umi1);\n-                    SequenceUtil.reverseComplement(umi2);\n-\n-                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);\n-                    final byte[] templateBasesRCWithUMI = ArrayUtils.addAll(templateBasesRCClipped, umi2);\n-\n-                    final List<ReadDescriptor> readDescriptors = new ArrayList<>();\n-                    if (gapBeforeUMI > 0) {\n-                        readDescriptors.add(new ReadDescriptor(gapBeforeUMI, ReadType.Skip));\n-                    }\n-                    if (umiLength > 0) {\n-                        readDescriptors.add(new ReadDescriptor(umiLength, ReadType.MolecularIndex));\n-                    }\n-                    if (gapAfterUMI > 0) {\n-                        readDescriptors.add(new ReadDescriptor(gapAfterUMI, ReadType.Skip));\n-                    }\n-                    readDescriptors.add(new ReadDescriptor(110 - totalBasesToRemove, ReadType.Template));\n-\n-                    final ReadStructure readStructure = new ReadStructure(readDescriptors);\n-\n-                    ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                            buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                            false, true, 100, 90 - totalBasesToRemove, illuminaAdapters, (110 - totalBasesToRemove) + \"M\" + (10 + totalBasesToRemove) + \"H\", (10 + totalBasesToRemove) + \"H\" + (110 - totalBasesToRemove) + \"M\", 100, 100,\n-                            umi1String + \"-\" + umi2String, readStructure});\n-\n-                }\n-            }\n-        }\n+        final String sharedQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n \n-        return ret.toArray(new Object[][]{});\n-    }\n+        final String r1ClippedQualities10 = \"FF.FFF.FFF\";\n+        final String r2ClippedQualities10 = \"FFFFFF.FFF\";\n+        final String r1ClippedQualities20 = \"FFFFFFFF.FFF.FFF.FFF\";\n+        final String r2ClippedQualities20 = \"FFFFFF.FFFFF.FFFFFFF\";\n \n-    private byte[] buildReadBases(final byte[] templateBasesReadOrder, final byte[] adapterBasesReadOrder, final int readLength, final boolean negativeStrand) {\n-        final byte[] bases = ArrayUtils.addAll(templateBasesReadOrder, adapterBasesReadOrder);\n-        final byte[] readBases = Arrays.copyOf(bases, readLength);\n-        if (negativeStrand) {\n-            SequenceUtil.reverseComplement(readBases);\n-        }\n-        return readBases;\n-    }\n+        return new Object[][] {\n+                {110, 100, 200, \"110M\", \"110M\", false, true, 100, 200, \"110M\", \"110M\", CigarOperator.SOFT_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null}, // Non overlapping reads\n \n-    @Test (dataProvider = \"hardClippingDataProvider\")\n-    public void testOverlappedReadHardClipping(final String originalCigar1, final String originalCigar2, final byte[] read1Bases, final byte[] read2Bases, final boolean strand1, final boolean strand2,\n-                                               final int start1, final int start2, final List<AdapterPair> adapters, final String expectedCigar1, final String expectedCigar2, final int expectedStart1, final int expectedStart2,\n-                                               final String umiTag, final ReadStructure readStructure) {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, originalCigar1, originalCigar2, strand1, strand2, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n+                {110, 100, 200, \"110M\", \"110M\", false, true, 100, 200, \"110M\", \"110M\", CigarOperator.HARD_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null},\n \n-        r1.setReadBases(read1Bases);\n-        r2.setReadBases(read2Bases);\n+                {110, 100, 90, \"110M\", \"110M\", false, true, 100, 100, \"100M10S\", \"10S100M\", CigarOperator.SOFT_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null}, // Basic overlapped read\n \n-        if (umiTag != null) {\n-            r1.setAttribute(SAMTag.RX.toString(), umiTag);\n-            r2.setAttribute(SAMTag.RX.toString(), umiTag);\n-        }\n+                {110, 100, 90, \"110M\", \"110M\", false, true, 100, 100, \"100M10H\", \"10H100M\", CigarOperator.HARD_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, sharedBases, sharedBases, default110LongR1ClippedBases, default110LongR2ClippedBases,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities10, r2ClippedQualities10},\n \n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, readStructure, readStructure, adapters);\n-        Assert.assertEquals(r1.getAlignmentStart(), expectedStart1);\n-        Assert.assertEquals(r1.getCigarString(), expectedCigar1);\n+                {120, 100, 95, \"110M10S5H\", \"5H15S105M\", false, true, 100, 100, \"100M20S5H\", \"5H20S100M\", CigarOperator.SOFT_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, default120LongR1Bases, default120LongR2Bases, null, null,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, default120LongR1BaseQualities, default120LongR2BaseQualities, null, null}, // Already hard and soft clipped\n \n-        Assert.assertEquals(r2.getAlignmentStart(), expectedStart2);\n-        Assert.assertEquals(r2.getCigarString(), expectedCigar2);\n-    }\n+                {120, 100, 95, \"110M10S5H\", \"5H15S105M\", false, true, 100, 100, \"100M25H\", \"25H100M\", CigarOperator.HARD_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, sharedBases, sharedBases, default120LongR1ClippedBases, default120LongR2ClippedBases,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities20, r2ClippedQualities20},\n \n-    @DataProvider(name = \"getReadPosToClipFromDataProvider\")\n-    public Object[][] getReadPosToClipFromData() {\n-        return new Object[][] {\n-                {\"120M\", false, 450, 502, 53},\n-                {\"120M\", true, 450, 502, 68},\n-                {\"120M\", false, 450, 580, -1},\n-                {\"120M\", false, 450, 440, -1},\n-                {\"120M\", true, 450, 580, -1},\n-                {\"120M\", true, 450, 440, -1},\n-\n-                {\"100M3I100M\", false, 300, 425, 129},\n-                {\"100M3I100M\", true, 300, 425, 75},\n-\n-                {\"100M3D100M\", false, 300, 425, 123},\n-                {\"100M3D100M\", true, 300, 425, 78},\n-\n-                {\"100M16S\", false, 300, 410, 111},\n-                {\"100M16S\", true, 300, 400, 16},\n-                {\"16S100M\", false, 316, 410, 111},\n-                {\"16S100M\", true, 316, 310, 106},\n-\n-                {\"100M16H\", false, 300, 410, -1},\n-                {\"100M16H\", true, 300, 410, -1},\n-                {\"100M16H\", true, 300, 390, 26},\n-                {\"16H100M\", false, 316, 310, -1},\n-                {\"16H100M\", true, 316, 310, -1},\n-                {\"16H100M\", true, 316, 350, 66}\n-        };\n-    }\n+                {120, 100, 95, \"110M10S\", \"15S105M\", false, true, 100, 100, \"100M20S\", \"20S100M\", CigarOperator.SOFT_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, default120LongR1Bases, default120LongR2Bases, null, null,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, default120LongR1BaseQualities, default120LongR2BaseQualities, null, null}, // Already soft clipped\n \n-    @Test(dataProvider = \"getReadPosToClipFromDataProvider\")\n-    public void testGetReadPositionToClipFrom(final String cigarString, final boolean negativeStrand, final int start, final int refPosToClipFrom, final int expectedReadPosToCLipFrom) {\n-        final SAMFileHeader header = new SAMFileHeader();\n-        final SAMRecord rec = new SAMRecord(header);\n-        rec.setCigarString(cigarString);\n-        rec.setReadNegativeStrandFlag(negativeStrand);\n-        rec.setAlignmentStart(start);\n+                {120, 100, 95, \"110M10S\", \"15S105M\", false, true, 100, 100, \"100M20H\", \"20H100M\", CigarOperator.HARD_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, sharedBases, sharedBases, default120LongR1ClippedBases, default120LongR2ClippedBases,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities20, r2ClippedQualities20}\n \n-        final int readPositionToClipFrom = AbstractAlignmentMerger.getReadPositionToClipFrom(rec, refPosToClipFrom);\n-        Assert.assertEquals(readPositionToClipFrom, expectedReadPosToCLipFrom);\n+        };\n     }\n \n-    @DataProvider(name = \"basesToClipDataProvider\")\n-    public Object[][] getBasesToClipDataProvider() {\n-        final List<Object[]> ret = new ArrayList<>();\n-        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n-        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n-        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n-        SequenceUtil.reverseComplement(templateBasesRC);\n+    @Test(dataProvider = \"overlapReadData\")\n+    public void testOverlappedReadClipping(final int readLength, final int start1, final int start2, final String cigar1, final String cigar2,\n+                                           final boolean strand1, final boolean strand2,\n+                                           final int r1ExpectedAlignmentStart, final int r2ExpectedAlignmentStart,\n+                                           final String expectedR1Cigar, final String expectedR2Cigar, final CigarOperator clippingOperator,\n+                                           final String read1Bases, final String read2Bases, final String expectedR1Bases, final String expectedR2Bases,\n+                                           final String expectedR1ClippedBases, final String expectedR2ClippedBases, final String read1Qualities,\n+                                           final String read2Qualities, final String expectedR1Qualities, final String expectedR2Qualities,\n+                                           final String expectedR1ClippedQualities, final String expectedR2ClippedQualities) {\n \n-        final String threePrimeAdapterBases = \"GTCGATTACAG\";\n-        final String fivePrimeAdapterBases = \"GACGGATCAGAC\";\n+        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n+        set.setReadLength(readLength);\n+        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, cigar1, cigar2, strand1, strand2, 30);\n+        final SAMRecord r1 = recs.get(0);\n+        final SAMRecord r2 = recs.get(1);\n \n+        r1.setReadBases(StringUtil.stringToBytes(read1Bases));\n+        r2.setReadBases(StringUtil.stringToBytes(read2Bases));\n \n-        final byte[] q30Quals = new byte[120];\n-        Arrays.fill(q30Quals, (byte)30);\n+        r1.setBaseQualities(SAMUtils.fastqToPhred(read1Qualities));\n+        r2.setBaseQualities(SAMUtils.fastqToPhred(read2Qualities));\n \n-        final CustomAdapterPair adapterPair = new CustomAdapterPair(fivePrimeAdapterBases, threePrimeAdapterBases);\n-        ret.add(new Object[] {buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), 120, false), q30Quals, adapterPair, true});\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, clippingOperator);\n+        Assert.assertEquals(r1.getAlignmentStart(), r1ExpectedAlignmentStart);\n+        Assert.assertEquals(r1.getCigarString(), expectedR1Cigar);\n+        Assert.assertEquals(r2.getAlignmentStart(), r2ExpectedAlignmentStart);\n+        Assert.assertEquals(r2.getCigarString(), expectedR2Cigar);\n+        Assert.assertEquals(r1.getReadString(), expectedR1Bases);\n+        Assert.assertEquals(r2.getReadString(), expectedR2Bases);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r1.getBaseQualities()), expectedR1Qualities);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r2.getBaseQualities()), expectedR2Qualities);\n \n+        Assert.assertEquals(r1.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR1ClippedBases);\n+        Assert.assertEquals(r2.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR2ClippedBases);\n \n-        final String threePrimeAdapterBasesOneError = \"GTGGATTACAG\";\n-        final String threePrimeAdapterBasesTwoError = \"GTGGCTTACAG\";\n-        final String threePrimeAdapterBasesThreeError = \"GTGGCATACAG\";\n+        Assert.assertEquals(r1.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR1ClippedQualities);\n+        Assert.assertEquals(r2.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR2ClippedQualities);\n \n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesOneError), 120, false), q30Quals, adapterPair, true}); //one error still matches\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesTwoError), 120, false), q30Quals, adapterPair, true}); //two errors still matches\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesThreeError), 120, false), q30Quals, adapterPair, false}); //three errors in first six bases fails\n \n-        final byte[] q30TemplateQuals = new byte[110];\n-        Arrays.fill(q30Quals, (byte)30);\n-        final byte[] lowQErrorAdapterQuals = new byte[]{30, 30, 6, 30, 6, 6, 30, 30, 30, 30};\n-        final byte[] lowQErrorQuals = ArrayUtils.addAll(q30TemplateQuals, lowQErrorAdapterQuals);\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesThreeError), 120, false), lowQErrorQuals, adapterPair, true}); //mismatches at low quality bases still match\n+        // Swap first and second read to ensure logic is correct for both F1R2 and F2R1\n+        final SAMRecordSetBuilder setSwapped = new SAMRecordSetBuilder();\n+        setSwapped.setReadLength(readLength);\n+        final List<SAMRecord> recsSwapped = set.addPair(\"q1\", 0, start2, start1, false, false, cigar2, cigar1, strand2, strand1, 30);\n+        final SAMRecord r1Swapped = recsSwapped.get(0);\n+        final SAMRecord r2Swapped = recsSwapped.get(1);\n \n+        r1Swapped.setReadBases(StringUtil.stringToBytes(read2Bases));\n+        r2Swapped.setReadBases(StringUtil.stringToBytes(read1Bases));\n \n-        return ret.toArray(new Object[][]{});\n-    }\n+        r1Swapped.setBaseQualities(SAMUtils.fastqToPhred(read2Qualities));\n+        r2Swapped.setBaseQualities(SAMUtils.fastqToPhred(read1Qualities));\n \n-    @Test(dataProvider = \"basesToClipDataProvider\")\n-    public void testBasesToClipMatchAdapterPair(final byte[] bases, final byte[] quals, final AdapterPair adapterPair, final boolean expectToMatch) {\n-        final SAMFileHeader header = new SAMFileHeader();\n-        final SAMRecord rec = new SAMRecord(header);\n-        rec.setReadPairedFlag(true);\n-        rec.setFirstOfPairFlag(true);\n-        rec.setReadBases(bases);\n-        rec.setBaseQualities(quals);\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1Swapped, r2Swapped, clippingOperator);\n+        Assert.assertEquals(r1Swapped.getAlignmentStart(), r2ExpectedAlignmentStart);\n+        Assert.assertEquals(r1Swapped.getCigarString(), expectedR2Cigar);\n+        Assert.assertEquals(r2Swapped.getAlignmentStart(), r1ExpectedAlignmentStart);\n+        Assert.assertEquals(r2Swapped.getCigarString(), expectedR1Cigar);\n+        Assert.assertEquals(r1Swapped.getReadString(), expectedR2Bases);\n+        Assert.assertEquals(r2Swapped.getReadString(), expectedR1Bases);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r1Swapped.getBaseQualities()), expectedR2Qualities);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r2Swapped.getBaseQualities()), expectedR1Qualities);\n \n-        final boolean basesMatch = AbstractAlignmentMerger.basesToClipMatchAdapterPair(rec, 110, adapterPair, null);\n-        Assert.assertEquals(basesMatch, expectToMatch);\n+        Assert.assertEquals(r1Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR2ClippedBases);\n+        Assert.assertEquals(r2Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR1ClippedBases);\n \n-    }\n+        Assert.assertEquals(r1Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR2ClippedQualities);\n+        Assert.assertEquals(r2Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR1ClippedQualities);\n \n-    @Test public void testOverlappedReadClippingWithExistingSoftClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(120);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 95, false, false, \"110M10S\", \"15S105M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M20S\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"20S100M\");\n     }\n \n-    @Test public void testOverlappedReadClippingWithExistingSoftClippingAndHardClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(120);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 95, false, false, \"110M10S5H\", \"5H15S105M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M20S5H\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"5H20S100M\");\n-    }\n+\n \n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDc1NjA3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r394756073", "bodyText": "I don't think templateBasesWithUMI or templateBasesRCWithUMI are used.", "author": "fleharty", "createdAt": "2020-03-19T02:27:04Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -49,6 +77,272 @@\n         Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n     }\n \n+    @DataProvider(name = \"hardClippingDataProvider\")\n+    public Object [][] getHardClippingData() {\n+\n+\n+        final List<Object[]> ret = new ArrayList<>();\n+        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n+        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n+        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n+        SequenceUtil.reverseComplement(templateBasesRC);\n+        //All Illumina barcode combinations should work\n+        \n+        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n+            final int readLength = templateBases.length + nAdapterBases;\n+            final String cigarF = readLength + \"M\";\n+            final String cigarR = readLength + \"M\";\n+            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n+            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n+\n+            for (final AdapterPair adapterPair : illuminaAdapters) {\n+                SequenceUtil.reverseComplement(templateBasesRC);\n+                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n+                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n+            }\n+\n+            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n+            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+\n+            //3' of one barcode, 5' of another, should only softclip\n+            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n+            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n+                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n+                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+\n+        }\n+\n+        //already soft-clipped\n+        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+        //already soft-clipped more than adapters\n+        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //already hard-clipped\n+        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //soft-clipped beginning\n+        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n+\n+\n+        //hard-clipped beginning\n+        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n+\n+        //insertion in reads\n+        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n+\n+        //insertion in adapter portion of read\n+        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //deletion in reads\n+        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n+\n+        //deletion in adapter portion of read\n+        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n+                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n+                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //Ns in adapter\n+        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n+        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n+                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n+                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n+\n+        //read structures and UMIs\n+        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n+            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n+                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n+                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n+                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n+                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n+\n+\n+                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n+                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n+\n+                    final String umi1String = StringUtil.bytesToString(umi1);\n+                    final String umi2String = StringUtil.bytesToString(umi2);\n+\n+                    SequenceUtil.reverseComplement(umi1);\n+                    SequenceUtil.reverseComplement(umi2);\n+\n+                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);", "originalCommit": "b76d9b6edcf2a46be58d832f1900635918927a47", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f7d94668099e260e0feee530cd477a0af09c3319", "chunk": "diff --git a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\nindex ec2d819a1..d9f8ca454 100644\n--- a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n+++ b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n\n@@ -35,339 +18,143 @@ import java.util.List;\n  * Tests related to code in AbstractAlignmentMerger\n  */\n public class AbstractAlignmentMergerTest extends CommandLineProgramTest {\n-    @Test public void tesOverlappedReadClippingWithNonOverlappedReads() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 200, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"110M\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 200);\n-        Assert.assertEquals(r2.getCigarString(), \"110M\");\n-    }\n \n-    @Test\n-    public void testOverlappedReadHardClippingWithNonOverlappedReads() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 200, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, null, null, Collections.emptyList());\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"110M\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 200);\n-        Assert.assertEquals(r2.getCigarString(), \"110M\");\n-        Assert.assertEquals(r1.getReadLength(), 110);\n-        Assert.assertEquals(r2.getReadLength(), 110);\n-    }\n+    @DataProvider(name = \"overlapReadData\")\n+    public Object[][] overlapReadData() {\n+        // The spaces here are deliberate to illustrate the region the two default reads match\n+        final String default120LongR1Bases =                     \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACCAGATTCTCCTGTCAGTTTGC\";\n+        final String default120LongR2Bases = \"CGTTGGCAATGCCGGGCACAATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-    @Test public void testBasicOverlappedReadClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(110);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 90, false, false, \"110M\", \"110M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M10S\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"10S100M\");\n-    }\n+        final String default110LongR1Bases =           \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACCAGATTCTCCT\";\n+        final String default110LongR2Bases = \"GCCGGGCACAATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-    @DataProvider(name = \"hardClippingDataProvider\")\n-    public Object [][] getHardClippingData() {\n-\n-\n-        final List<Object[]> ret = new ArrayList<>();\n-        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n-        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n-        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n-        SequenceUtil.reverseComplement(templateBasesRC);\n-        //All Illumina barcode combinations should work\n-        \n-        for (int nAdapterBases = 1; nAdapterBases <= 10; nAdapterBases+=3) {\n-            final int readLength = templateBases.length + nAdapterBases;\n-            final String cigarF = readLength + \"M\";\n-            final String cigarR = readLength + \"M\";\n-            final String expectedCigarF = templateBases.length + \"M\" + nAdapterBases + \"H\";\n-            final String expectedCigarR = nAdapterBases + \"H\" + templateBases.length + \"M\";\n-\n-            for (final AdapterPair adapterPair : illuminaAdapters) {\n-                SequenceUtil.reverseComplement(templateBasesRC);\n-                ret.add(new Object[]{cigarF, cigarR, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n-                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n-                        false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarF, expectedCigarR, 100, 100, null, null}); //F1R2\n-                ret.add(new Object[]{cigarR, cigarF, buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n-                        buildReadBases(templateBasesRC, adapterPair.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n-                        true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarR, expectedCigarF, 100, 100, null, null}); //F2R1\n-            }\n+        final String sharedBases = \"ATCACACCAGTGTCTGCGTTCACAGCAGGCATCATCAGTAGCCTCCAGAGGCCTCAGGTCCAGTCTCTAAAAATATCTCAGGAGGCTGCAGTGGCTGACC\";\n \n-            final String expectedCigarSoftF = templateBases.length + \"M\" + nAdapterBases + \"S\";\n-            final String expectedCigarSoftR = nAdapterBases +\"S\" + templateBases.length +\"M\";\n+        final String default120LongR1ClippedBases = \"AGATTCTCCTGTCAGTTTGC\";\n+        final String default120LongR2ClippedBases = \"CGTTGGCAATGCCGGGCACA\";\n \n-            //3' of one barcode, 5' of another, should only softclip\n-            ret.add(new Object[] {cigarF, cigarR, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, false),\n-                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, true),\n-                    false, true, 100, 100 - nAdapterBases, illuminaAdapters, expectedCigarSoftF, expectedCigarSoftR, 100, 100, null, null}); //F1R2\n-            ret.add(new Object[] {cigarR, cigarF, buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), readLength, true),\n-                    buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.NEXTERA_V1.get5PrimeAdapterBytesInReadOrder(), readLength, false),\n-                    true, false, 100 - nAdapterBases, 100, illuminaAdapters, expectedCigarSoftR, expectedCigarSoftF, 100, 100, null, null}); //F2R1\n+        final String default110LongR1ClippedBases = \"AGATTCTCCT\";\n+        final String default110LongR2ClippedBases = \"GCCGGGCACA\";\n \n-        }\n+        final String default120LongR1BaseQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF.FFF.FFF\";\n+        final String default120LongR2BaseQualities =\"FFFFFF.FFFFF.FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n+        final String default110LongR1BaseQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF.FFF.FFF\";\n+        final String default110LongR2BaseQualities = \"FFFFFF.FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n \n-        //already soft-clipped\n-        ret.add(new Object[] {\"118M2S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-        //already soft-clipped more than adapters\n-        ret.add(new Object[] {\"108M12S\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"108M2S10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //already hard-clipped\n-        ret.add(new Object[] {\"118M2H\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //soft-clipped beginning\n-        ret.add(new Object[] {\"2S118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 102, 90, illuminaAdapters, \"2S108M10H\", \"10H110M\", 102, 100, null, null});\n-\n-\n-        //hard-clipped beginning\n-        ret.add(new Object[]{\"2H118M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 118, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 102, 90, illuminaAdapters, \"2H110M8H\", \"10H110M\", 102, 100, null, null});\n-\n-        //insertion in reads\n-        ret.add(new Object[]{\"50M2I68M\", \"50M2I68M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"50M2I58M10H\", \"10H40M2I68M\", 100, 100, null, null});\n-\n-        //insertion in adapter portion of read\n-        ret.add(new Object[]{\"114M2I4M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //deletion in reads\n-        ret.add(new Object[]{\"50M2D70M\", \"50M2D70M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"50M2D60M10H\", \"10H40M2D70M\", 100, 100, null, null});\n-\n-        //deletion in adapter portion of read\n-        ret.add(new Object[]{\"114M2D6M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                false, true, 100, 90, illuminaAdapters, \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //Ns in adapter\n-        final CustomAdapterPair customAdapterPair = new CustomAdapterPair(\"GTGCTTGCANNN\", \"NNNNAGTCGATTGC\");\n-        ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, StringUtil.stringToBytes(\"ACGTAGTCGATTGC\"), 120, false),\n-                buildReadBases(templateBasesRC, StringUtil.stringToBytes(\"ACGTGCAAGCAC\"), 120, true),\n-                false, true, 100, 90, Collections.singletonList(customAdapterPair), \"110M10H\", \"10H110M\", 100, 100, null, null});\n-\n-        //read structures and UMIs\n-        for(int umiLength = 0; umiLength<=6; umiLength+=3) {\n-            for (int gapBeforeUMI = 0; gapBeforeUMI<3; gapBeforeUMI++) {\n-                for (int gapAfterUMI = 0; gapAfterUMI<3 && gapAfterUMI<umiLength; gapAfterUMI++) {\n-                    final int totalBasesToRemove = umiLength + gapAfterUMI + gapBeforeUMI;\n-                    final byte[] templateBasesClipped = Arrays.copyOfRange(templateBases, totalBasesToRemove, templateBases.length);\n-                    final byte[] templateBasesRCClipped = Arrays.copyOfRange(templateBasesRC, totalBasesToRemove, templateBasesRC.length);\n-\n-\n-                    final byte[] umi1 = Arrays.copyOfRange(templateBases, gapBeforeUMI, gapBeforeUMI + umiLength);\n-                    final byte[] umi2 = Arrays.copyOfRange(templateBasesRC, gapBeforeUMI, gapBeforeUMI + umiLength);\n-\n-                    final String umi1String = StringUtil.bytesToString(umi1);\n-                    final String umi2String = StringUtil.bytesToString(umi2);\n-\n-                    SequenceUtil.reverseComplement(umi1);\n-                    SequenceUtil.reverseComplement(umi2);\n-\n-                    final byte[] templateBasesWithUMI = ArrayUtils.addAll(templateBasesClipped, umi1);\n-                    final byte[] templateBasesRCWithUMI = ArrayUtils.addAll(templateBasesRCClipped, umi2);\n-\n-                    final List<ReadDescriptor> readDescriptors = new ArrayList<>();\n-                    if (gapBeforeUMI > 0) {\n-                        readDescriptors.add(new ReadDescriptor(gapBeforeUMI, ReadType.Skip));\n-                    }\n-                    if (umiLength > 0) {\n-                        readDescriptors.add(new ReadDescriptor(umiLength, ReadType.MolecularIndex));\n-                    }\n-                    if (gapAfterUMI > 0) {\n-                        readDescriptors.add(new ReadDescriptor(gapAfterUMI, ReadType.Skip));\n-                    }\n-                    readDescriptors.add(new ReadDescriptor(110 - totalBasesToRemove, ReadType.Template));\n-\n-                    final ReadStructure readStructure = new ReadStructure(readDescriptors);\n-\n-                    ret.add(new Object[] {\"120M\", \"120M\", buildReadBases(templateBases, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get3PrimeAdapterBytesInReadOrder(), 120, false),\n-                            buildReadBases(templateBasesRC, IlluminaUtil.IlluminaAdapterPair.PAIRED_END.get5PrimeAdapterBytesInReadOrder(), 120, true),\n-                            false, true, 100, 90 - totalBasesToRemove, illuminaAdapters, (110 - totalBasesToRemove) + \"M\" + (10 + totalBasesToRemove) + \"H\", (10 + totalBasesToRemove) + \"H\" + (110 - totalBasesToRemove) + \"M\", 100, 100,\n-                            umi1String + \"-\" + umi2String, readStructure});\n-\n-                }\n-            }\n-        }\n+        final String sharedQualities = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n \n-        return ret.toArray(new Object[][]{});\n-    }\n+        final String r1ClippedQualities10 = \"FF.FFF.FFF\";\n+        final String r2ClippedQualities10 = \"FFFFFF.FFF\";\n+        final String r1ClippedQualities20 = \"FFFFFFFF.FFF.FFF.FFF\";\n+        final String r2ClippedQualities20 = \"FFFFFF.FFFFF.FFFFFFF\";\n \n-    private byte[] buildReadBases(final byte[] templateBasesReadOrder, final byte[] adapterBasesReadOrder, final int readLength, final boolean negativeStrand) {\n-        final byte[] bases = ArrayUtils.addAll(templateBasesReadOrder, adapterBasesReadOrder);\n-        final byte[] readBases = Arrays.copyOf(bases, readLength);\n-        if (negativeStrand) {\n-            SequenceUtil.reverseComplement(readBases);\n-        }\n-        return readBases;\n-    }\n+        return new Object[][] {\n+                {110, 100, 200, \"110M\", \"110M\", false, true, 100, 200, \"110M\", \"110M\", CigarOperator.SOFT_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null}, // Non overlapping reads\n \n-    @Test (dataProvider = \"hardClippingDataProvider\")\n-    public void testOverlappedReadHardClipping(final String originalCigar1, final String originalCigar2, final byte[] read1Bases, final byte[] read2Bases, final boolean strand1, final boolean strand2,\n-                                               final int start1, final int start2, final List<AdapterPair> adapters, final String expectedCigar1, final String expectedCigar2, final int expectedStart1, final int expectedStart2,\n-                                               final String umiTag, final ReadStructure readStructure) {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, originalCigar1, originalCigar2, strand1, strand2, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n+                {110, 100, 200, \"110M\", \"110M\", false, true, 100, 200, \"110M\", \"110M\", CigarOperator.HARD_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null},\n \n-        r1.setReadBases(read1Bases);\n-        r2.setReadBases(read2Bases);\n+                {110, 100, 90, \"110M\", \"110M\", false, true, 100, 100, \"100M10S\", \"10S100M\", CigarOperator.SOFT_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, default110LongR1Bases, default110LongR2Bases, null, null,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, default110LongR1BaseQualities, default110LongR2BaseQualities, null, null}, // Basic overlapped read\n \n-        if (umiTag != null) {\n-            r1.setAttribute(SAMTag.RX.toString(), umiTag);\n-            r2.setAttribute(SAMTag.RX.toString(), umiTag);\n-        }\n+                {110, 100, 90, \"110M\", \"110M\", false, true, 100, 100, \"100M10H\", \"10H100M\", CigarOperator.HARD_CLIP,\n+                        default110LongR1Bases, default110LongR2Bases, sharedBases, sharedBases, default110LongR1ClippedBases, default110LongR2ClippedBases,\n+                        default110LongR1BaseQualities, default110LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities10, r2ClippedQualities10},\n \n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, CigarOperator.HARD_CLIP, readStructure, readStructure, adapters);\n-        Assert.assertEquals(r1.getAlignmentStart(), expectedStart1);\n-        Assert.assertEquals(r1.getCigarString(), expectedCigar1);\n+                {120, 100, 95, \"110M10S5H\", \"5H15S105M\", false, true, 100, 100, \"100M20S5H\", \"5H20S100M\", CigarOperator.SOFT_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, default120LongR1Bases, default120LongR2Bases, null, null,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, default120LongR1BaseQualities, default120LongR2BaseQualities, null, null}, // Already hard and soft clipped\n \n-        Assert.assertEquals(r2.getAlignmentStart(), expectedStart2);\n-        Assert.assertEquals(r2.getCigarString(), expectedCigar2);\n-    }\n+                {120, 100, 95, \"110M10S5H\", \"5H15S105M\", false, true, 100, 100, \"100M25H\", \"25H100M\", CigarOperator.HARD_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, sharedBases, sharedBases, default120LongR1ClippedBases, default120LongR2ClippedBases,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities20, r2ClippedQualities20},\n \n-    @DataProvider(name = \"getReadPosToClipFromDataProvider\")\n-    public Object[][] getReadPosToClipFromData() {\n-        return new Object[][] {\n-                {\"120M\", false, 450, 502, 53},\n-                {\"120M\", true, 450, 502, 68},\n-                {\"120M\", false, 450, 580, -1},\n-                {\"120M\", false, 450, 440, -1},\n-                {\"120M\", true, 450, 580, -1},\n-                {\"120M\", true, 450, 440, -1},\n-\n-                {\"100M3I100M\", false, 300, 425, 129},\n-                {\"100M3I100M\", true, 300, 425, 75},\n-\n-                {\"100M3D100M\", false, 300, 425, 123},\n-                {\"100M3D100M\", true, 300, 425, 78},\n-\n-                {\"100M16S\", false, 300, 410, 111},\n-                {\"100M16S\", true, 300, 400, 16},\n-                {\"16S100M\", false, 316, 410, 111},\n-                {\"16S100M\", true, 316, 310, 106},\n-\n-                {\"100M16H\", false, 300, 410, -1},\n-                {\"100M16H\", true, 300, 410, -1},\n-                {\"100M16H\", true, 300, 390, 26},\n-                {\"16H100M\", false, 316, 310, -1},\n-                {\"16H100M\", true, 316, 310, -1},\n-                {\"16H100M\", true, 316, 350, 66}\n-        };\n-    }\n+                {120, 100, 95, \"110M10S\", \"15S105M\", false, true, 100, 100, \"100M20S\", \"20S100M\", CigarOperator.SOFT_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, default120LongR1Bases, default120LongR2Bases, null, null,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, default120LongR1BaseQualities, default120LongR2BaseQualities, null, null}, // Already soft clipped\n \n-    @Test(dataProvider = \"getReadPosToClipFromDataProvider\")\n-    public void testGetReadPositionToClipFrom(final String cigarString, final boolean negativeStrand, final int start, final int refPosToClipFrom, final int expectedReadPosToCLipFrom) {\n-        final SAMFileHeader header = new SAMFileHeader();\n-        final SAMRecord rec = new SAMRecord(header);\n-        rec.setCigarString(cigarString);\n-        rec.setReadNegativeStrandFlag(negativeStrand);\n-        rec.setAlignmentStart(start);\n+                {120, 100, 95, \"110M10S\", \"15S105M\", false, true, 100, 100, \"100M20H\", \"20H100M\", CigarOperator.HARD_CLIP,\n+                        default120LongR1Bases, default120LongR2Bases, sharedBases, sharedBases, default120LongR1ClippedBases, default120LongR2ClippedBases,\n+                        default120LongR1BaseQualities, default120LongR2BaseQualities, sharedQualities, sharedQualities, r1ClippedQualities20, r2ClippedQualities20}\n \n-        final int readPositionToClipFrom = AbstractAlignmentMerger.getReadPositionToClipFrom(rec, refPosToClipFrom);\n-        Assert.assertEquals(readPositionToClipFrom, expectedReadPosToCLipFrom);\n+        };\n     }\n \n-    @DataProvider(name = \"basesToClipDataProvider\")\n-    public Object[][] getBasesToClipDataProvider() {\n-        final List<Object[]> ret = new ArrayList<>();\n-        final List<AdapterPair> illuminaAdapters = Arrays.asList(IlluminaUtil.IlluminaAdapterPair.values());\n-        final byte[] templateBases = StringUtil.stringToBytes(\"ACTGCATGCTAGCTTAGGACAGATACGATAGCTAGACAGACATAATTTAGCGGATGACATTCGGACAGATCGGACGAGCTAGACAGACTGAGACAGCTAGCAGATCGAGG\");\n-        final byte[] templateBasesRC = Arrays.copyOf(templateBases, templateBases.length);\n-        SequenceUtil.reverseComplement(templateBasesRC);\n+    @Test(dataProvider = \"overlapReadData\")\n+    public void testOverlappedReadClipping(final int readLength, final int start1, final int start2, final String cigar1, final String cigar2,\n+                                           final boolean strand1, final boolean strand2,\n+                                           final int r1ExpectedAlignmentStart, final int r2ExpectedAlignmentStart,\n+                                           final String expectedR1Cigar, final String expectedR2Cigar, final CigarOperator clippingOperator,\n+                                           final String read1Bases, final String read2Bases, final String expectedR1Bases, final String expectedR2Bases,\n+                                           final String expectedR1ClippedBases, final String expectedR2ClippedBases, final String read1Qualities,\n+                                           final String read2Qualities, final String expectedR1Qualities, final String expectedR2Qualities,\n+                                           final String expectedR1ClippedQualities, final String expectedR2ClippedQualities) {\n \n-        final String threePrimeAdapterBases = \"GTCGATTACAG\";\n-        final String fivePrimeAdapterBases = \"GACGGATCAGAC\";\n+        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n+        set.setReadLength(readLength);\n+        final List<SAMRecord> recs = set.addPair(\"q1\", 0, start1, start2, false, false, cigar1, cigar2, strand1, strand2, 30);\n+        final SAMRecord r1 = recs.get(0);\n+        final SAMRecord r2 = recs.get(1);\n \n+        r1.setReadBases(StringUtil.stringToBytes(read1Bases));\n+        r2.setReadBases(StringUtil.stringToBytes(read2Bases));\n \n-        final byte[] q30Quals = new byte[120];\n-        Arrays.fill(q30Quals, (byte)30);\n+        r1.setBaseQualities(SAMUtils.fastqToPhred(read1Qualities));\n+        r2.setBaseQualities(SAMUtils.fastqToPhred(read2Qualities));\n \n-        final CustomAdapterPair adapterPair = new CustomAdapterPair(fivePrimeAdapterBases, threePrimeAdapterBases);\n-        ret.add(new Object[] {buildReadBases(templateBases, adapterPair.get3PrimeAdapterBytesInReadOrder(), 120, false), q30Quals, adapterPair, true});\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2, clippingOperator);\n+        Assert.assertEquals(r1.getAlignmentStart(), r1ExpectedAlignmentStart);\n+        Assert.assertEquals(r1.getCigarString(), expectedR1Cigar);\n+        Assert.assertEquals(r2.getAlignmentStart(), r2ExpectedAlignmentStart);\n+        Assert.assertEquals(r2.getCigarString(), expectedR2Cigar);\n+        Assert.assertEquals(r1.getReadString(), expectedR1Bases);\n+        Assert.assertEquals(r2.getReadString(), expectedR2Bases);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r1.getBaseQualities()), expectedR1Qualities);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r2.getBaseQualities()), expectedR2Qualities);\n \n+        Assert.assertEquals(r1.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR1ClippedBases);\n+        Assert.assertEquals(r2.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR2ClippedBases);\n \n-        final String threePrimeAdapterBasesOneError = \"GTGGATTACAG\";\n-        final String threePrimeAdapterBasesTwoError = \"GTGGCTTACAG\";\n-        final String threePrimeAdapterBasesThreeError = \"GTGGCATACAG\";\n+        Assert.assertEquals(r1.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR1ClippedQualities);\n+        Assert.assertEquals(r2.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR2ClippedQualities);\n \n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesOneError), 120, false), q30Quals, adapterPair, true}); //one error still matches\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesTwoError), 120, false), q30Quals, adapterPair, true}); //two errors still matches\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesThreeError), 120, false), q30Quals, adapterPair, false}); //three errors in first six bases fails\n \n-        final byte[] q30TemplateQuals = new byte[110];\n-        Arrays.fill(q30Quals, (byte)30);\n-        final byte[] lowQErrorAdapterQuals = new byte[]{30, 30, 6, 30, 6, 6, 30, 30, 30, 30};\n-        final byte[] lowQErrorQuals = ArrayUtils.addAll(q30TemplateQuals, lowQErrorAdapterQuals);\n-        ret.add(new Object[] {buildReadBases(templateBases, StringUtil.stringToBytes(threePrimeAdapterBasesThreeError), 120, false), lowQErrorQuals, adapterPair, true}); //mismatches at low quality bases still match\n+        // Swap first and second read to ensure logic is correct for both F1R2 and F2R1\n+        final SAMRecordSetBuilder setSwapped = new SAMRecordSetBuilder();\n+        setSwapped.setReadLength(readLength);\n+        final List<SAMRecord> recsSwapped = set.addPair(\"q1\", 0, start2, start1, false, false, cigar2, cigar1, strand2, strand1, 30);\n+        final SAMRecord r1Swapped = recsSwapped.get(0);\n+        final SAMRecord r2Swapped = recsSwapped.get(1);\n \n+        r1Swapped.setReadBases(StringUtil.stringToBytes(read2Bases));\n+        r2Swapped.setReadBases(StringUtil.stringToBytes(read1Bases));\n \n-        return ret.toArray(new Object[][]{});\n-    }\n+        r1Swapped.setBaseQualities(SAMUtils.fastqToPhred(read2Qualities));\n+        r2Swapped.setBaseQualities(SAMUtils.fastqToPhred(read1Qualities));\n \n-    @Test(dataProvider = \"basesToClipDataProvider\")\n-    public void testBasesToClipMatchAdapterPair(final byte[] bases, final byte[] quals, final AdapterPair adapterPair, final boolean expectToMatch) {\n-        final SAMFileHeader header = new SAMFileHeader();\n-        final SAMRecord rec = new SAMRecord(header);\n-        rec.setReadPairedFlag(true);\n-        rec.setFirstOfPairFlag(true);\n-        rec.setReadBases(bases);\n-        rec.setBaseQualities(quals);\n+        AbstractAlignmentMerger.clipForOverlappingReads(r1Swapped, r2Swapped, clippingOperator);\n+        Assert.assertEquals(r1Swapped.getAlignmentStart(), r2ExpectedAlignmentStart);\n+        Assert.assertEquals(r1Swapped.getCigarString(), expectedR2Cigar);\n+        Assert.assertEquals(r2Swapped.getAlignmentStart(), r1ExpectedAlignmentStart);\n+        Assert.assertEquals(r2Swapped.getCigarString(), expectedR1Cigar);\n+        Assert.assertEquals(r1Swapped.getReadString(), expectedR2Bases);\n+        Assert.assertEquals(r2Swapped.getReadString(), expectedR1Bases);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r1Swapped.getBaseQualities()), expectedR2Qualities);\n+        Assert.assertEquals(SAMUtils.phredToFastq(r2Swapped.getBaseQualities()), expectedR1Qualities);\n \n-        final boolean basesMatch = AbstractAlignmentMerger.basesToClipMatchAdapterPair(rec, 110, adapterPair, null);\n-        Assert.assertEquals(basesMatch, expectToMatch);\n+        Assert.assertEquals(r1Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR2ClippedBases);\n+        Assert.assertEquals(r2Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG), expectedR1ClippedBases);\n \n-    }\n+        Assert.assertEquals(r1Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR2ClippedQualities);\n+        Assert.assertEquals(r2Swapped.getAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG), expectedR1ClippedQualities);\n \n-    @Test public void testOverlappedReadClippingWithExistingSoftClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(120);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 95, false, false, \"110M10S\", \"15S105M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M20S\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"20S100M\");\n     }\n \n-    @Test public void testOverlappedReadClippingWithExistingSoftClippingAndHardClipping() {\n-        final SAMRecordSetBuilder set = new SAMRecordSetBuilder();\n-        set.setReadLength(120);\n-        final List<SAMRecord> recs = set.addPair(\"q1\", 0, 100, 95, false, false, \"110M10S5H\", \"5H15S105M\", false, true, 30);\n-        final SAMRecord r1 = recs.get(0);\n-        final SAMRecord r2 = recs.get(1);\n-        AbstractAlignmentMerger.clipForOverlappingReads(r1, r2);\n-        Assert.assertEquals(r1.getAlignmentStart(), 100);\n-        Assert.assertEquals(r1.getCigarString(), \"100M20S5H\");\n-        Assert.assertEquals(r2.getAlignmentStart(), 100);\n-        Assert.assertEquals(r2.getCigarString(), \"5H20S100M\");\n-    }\n+\n \n \n     @Test\n"}}, {"oid": "f7d94668099e260e0feee530cd477a0af09c3319", "url": "https://github.com/broadinstitute/picard/commit/f7d94668099e260e0feee530cd477a0af09c3319", "message": "Doing simplified hard-clipping and refactoring tests.", "committedDate": "2020-03-26T18:48:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzA0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400487042", "bodyText": "perhaps let's use non-X (but lowercase) tag, so that we can try to make it a real (upper-cased) tag in hts-specs later. look for a reasonable two-caracter tag name...perhaps cb and cq is not taken? also, need to think what to do if it's clipped from both ends....or perhaps we assert that these bases are only from the end of the read.", "author": "yfarjoun", "createdAt": "2020-03-30T20:53:41Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -60,6 +60,9 @@\n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n+    static final String HARD_CLIPPED_BASES_TAG = \"XB\";", "originalCommit": "f7d94668099e260e0feee530cd477a0af09c3319", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "482c78d70ac057856f7e97fabe75ae6d19b0744a", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex d64aa5236..c41faa95b 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -60,8 +60,8 @@ public abstract class AbstractAlignmentMerger {\n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n-    static final String HARD_CLIPPED_BASES_TAG = \"XB\";\n-    static final String HARD_CLIPPED_BASE_QUALITIES_TAG = \"XQ\";\n+    static final String HARD_CLIPPED_BASES_TAG = \"hB\";\n+    static final String HARD_CLIPPED_BASE_QUALITIES_TAG = \"hQ\";\n \n     private int crossSpeciesReads = 0;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzgzNg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400487836", "bodyText": "I think it's better to use a boolean as there are only 2 resaonable operators here....SOFT and HARD.", "author": "yfarjoun", "createdAt": "2020-03-30T20:55:00Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,105 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator) {", "originalCommit": "f7d94668099e260e0feee530cd477a0af09c3319", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4Nzk4NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400487985", "bodyText": "(and then the sanity checks below will not be needed)", "author": "yfarjoun", "createdAt": "2020-03-30T20:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4NzgzNg=="}], "type": "inlineReview", "revised_code": {"commit": "482c78d70ac057856f7e97fabe75ae6d19b0744a", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex d64aa5236..c41faa95b 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -758,12 +758,8 @@ public abstract class AbstractAlignmentMerger {\n      * Checks to see whether the ends of the reads overlap and clips reads\n      * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n-        if (!clippingOperator.isClipping()) {\n-            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n-        }\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4ODk4Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r400488982", "bodyText": "I think that the bases should be stored in original read order, so that in order to revert, you just need to stick these on the ends of the reverted records.", "author": "yfarjoun", "createdAt": "2020-03-30T20:57:10Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,105 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator) {\n         // If both reads are mapped, see if we need to clip the ends due to small\n         // insert size\n+        if (!clippingOperator.isClipping()) {\n+            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n+        }\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    //need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getReadPositionToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getReadPositionToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    if (posClipFrom == negClipFrom && posClipFrom > 0) {\n+                        final int clipFrom = posClipFrom;\n+\n+                        if (clippingOperator == CigarOperator.HARD_CLIP) {\n+                            moveClippedBasesToTag(read1, clipFrom);\n+                            moveClippedBasesToTag(read2, clipFrom);\n+                        }\n+\n+                        CigarUtil.clip3PrimeEndOfRead(read1, clipFrom, clippingOperator);\n+                        CigarUtil.clip3PrimeEndOfRead(read2, clipFrom, clippingOperator);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        if(rec.getReadNegativeStrandFlag()) {", "originalCommit": "f7d94668099e260e0feee530cd477a0af09c3319", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "482c78d70ac057856f7e97fabe75ae6d19b0744a", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex d64aa5236..c41faa95b 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -758,12 +758,8 @@ public abstract class AbstractAlignmentMerger {\n      * Checks to see whether the ends of the reads overlap and clips reads\n      * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final CigarOperator clippingOperator) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n-        if (!clippingOperator.isClipping()) {\n-            throw new PicardException(\"Cannot use non-clipping operator \" + clippingOperator + \" to clip overlapping reads\");\n-        }\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n"}}, {"oid": "482c78d70ac057856f7e97fabe75ae6d19b0744a", "url": "https://github.com/broadinstitute/picard/commit/482c78d70ac057856f7e97fabe75ae6d19b0744a", "message": "Broke tests somehow", "committedDate": "2020-04-08T17:55:53Z", "type": "commit"}, {"oid": "e21a98c77debb37bbc64d5c65601ebb2233f473d", "url": "https://github.com/broadinstitute/picard/commit/e21a98c77debb37bbc64d5c65601ebb2233f473d", "message": "Responding to Yossi's comments, getDistanceFrom3PromeEndToClipFrom needs fixing before his rereview.", "committedDate": "2020-04-10T18:45:21Z", "type": "commit"}, {"oid": "c7659b7f5c1556bb5db0e3b3b0428169289ec4e0", "url": "https://github.com/broadinstitute/picard/commit/c7659b7f5c1556bb5db0e3b3b0428169289ec4e0", "message": "Fixes two broken tests", "committedDate": "2020-04-14T22:38:51Z", "type": "commit"}, {"oid": "2af405160b031288b96ea2bf78d26015c4df694c", "url": "https://github.com/broadinstitute/picard/commit/2af405160b031288b96ea2bf78d26015c4df694c", "message": "This commit is a test", "committedDate": "2020-04-22T23:08:56Z", "type": "commit"}, {"oid": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "url": "https://github.com/broadinstitute/picard/commit/c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "message": "Small refactoring to get rid of duplicated code.", "committedDate": "2020-04-23T02:20:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5ODU0OQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414698549", "bodyText": "since soft-clipped bases are not removed, I think that the \"h\" is superfluous. how about EB and EQ (for End Bases, and End Quality) since in theory, bases could also be (hard-)clipped off of the start of a read..", "author": "yfarjoun", "createdAt": "2020-04-24T16:17:15Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -60,6 +60,9 @@\n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n+    static final String HARD_CLIPPED_BASES_TAG = \"hB\";", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5OTAzNw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414699037", "bodyText": "also, as a //Todo item here to switch to using the htsjdk version if it gets into hts-spec and implemented", "author": "yfarjoun", "createdAt": "2020-04-24T16:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY5ODU0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex a806973f7..89a2be8c6 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -60,8 +68,10 @@ public abstract class AbstractAlignmentMerger {\n     public static final int MAX_RECORDS_IN_RAM = 500000;\n \n     private static final char[] RESERVED_ATTRIBUTE_STARTS = {'X', 'Y', 'Z'};\n-    static final String HARD_CLIPPED_BASES_TAG = \"hB\";\n-    static final String HARD_CLIPPED_BASE_QUALITIES_TAG = \"hQ\";\n+\n+    // TODO: Switch to using HTSJDK tags if this gets into hts-spec and implemented\n+    static final String HARD_CLIPPED_BASES_TAG = \"eB\";\n+    static final String HARD_CLIPPED_BASE_QUALITIES_TAG = \"eQ\";\n \n     private int crossSpeciesReads = 0;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMDM0MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414700341", "bodyText": "is clippingOperator used elsewhere?", "author": "yfarjoun", "createdAt": "2020-04-24T16:20:17Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex a806973f7..89a2be8c6 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -771,7 +781,6 @@ public abstract class AbstractAlignmentMerger {\n                     // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n                     final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n                     final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n-                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n \n                     if(posClipFrom > 0) {\n                         clipRead(pos, posClipFrom, useHardClipping);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwMzA4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414703087", "bodyText": "add a sanity check that the tags are not already in use. at this point I think it's OK to break if they are in use, but losing data due to overwriting old tags would not be good.", "author": "yfarjoun", "createdAt": "2020-04-24T16:24:37Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n+\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            final byte[] bases = rec.getReadBases();\n+            final byte[] baseQualities = rec.getBaseQualities();\n+            final int readLength = rec.getReadLength();\n+", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex a806973f7..89a2be8c6 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -771,7 +781,6 @@ public abstract class AbstractAlignmentMerger {\n                     // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n                     final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n                     final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n-                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n \n                     if(posClipFrom > 0) {\n                         clipRead(pos, posClipFrom, useHardClipping);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNDMxNg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414704316", "bodyText": "could you split this into three parts:\n\nextract the required bases/qualities\noptionally reverse/rev-comp the arrays\nset the attributes\n\nwhile it takes up more lines of code, there's less code duplication.", "author": "yfarjoun", "createdAt": "2020-04-24T16:26:33Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n+\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            final byte[] bases = rec.getReadBases();\n+            final byte[] baseQualities = rec.getBaseQualities();\n+            final int readLength = rec.getReadLength();\n+\n+            if (rec.getReadNegativeStrandFlag()) {", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNTM0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414705342", "bodyText": "also, you defined a method to \"move bases to tag\" so perhaps you should be using it... :-)", "author": "yfarjoun", "createdAt": "2020-04-24T16:28:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwNDMxNg=="}], "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex a806973f7..89a2be8c6 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -771,7 +781,6 @@ public abstract class AbstractAlignmentMerger {\n                     // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n                     final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n                     final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n-                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n \n                     if(posClipFrom > 0) {\n                         clipRead(pos, posClipFrom, useHardClipping);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcwODE1Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414708153", "bodyText": "please add a test that has an expected sam file with the tags", "author": "yfarjoun", "createdAt": "2020-04-24T16:32:39Z", "path": "src/test/java/picard/sam/MergeBamAlignmentTest.java", "diffHunk": "@@ -1206,6 +1206,50 @@ public void testShortFragmentClipping() throws Exception {\n         result.close();\n     }\n \n+    @Test\n+    public void testShortFragmentHardClipping() throws IOException {\n+        final File output = File.createTempFile(\"testShortFragmentClipping\", \".sam\");", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/test/java/picard/sam/MergeBamAlignmentTest.java b/src/test/java/picard/sam/MergeBamAlignmentTest.java\nindex 6c125c0b6..81c2575f5 100644\n--- a/src/test/java/picard/sam/MergeBamAlignmentTest.java\n+++ b/src/test/java/picard/sam/MergeBamAlignmentTest.java\n\n@@ -1242,6 +1242,14 @@ public class MergeBamAlignmentTest extends CommandLineProgramTest {\n                 if (readNameFields[0].equals(\"FR_clip\")) {\n                     Assert.assertEquals(rec.getCigarString(), rec.getReadNegativeStrandFlag()? \"20H56M\" : \"56M20H\");\n                     Assert.assertEquals(otherEnd.getCigarString(), otherEnd.getReadNegativeStrandFlag()? \"20H56M\" : \"56M20H\");\n+\n+                    if (!rec.getReadNegativeStrandFlag()) {\n+                        Assert.assertEquals(rec.getAttribute(\"eB\"), \"AGATCGGAAGAGCACACGTC\");\n+                        Assert.assertEquals(rec.getAttribute(\"eQ\"), \"BBBBB?BBB?<?A?<7<<=9\");\n+                    } else {\n+                        Assert.assertEquals(rec.getAttribute(\"eB\"), \"AGATCGGAAGAGCGTCGTGT\");\n+                        Assert.assertEquals(rec.getAttribute(\"eQ\"), \"BCFD=@CBBADCF=CC:CCD\");\n+                    }\n                 } else {\n                     Assert.assertEquals(rec.getCigarString(), \"76M\");\n                     Assert.assertEquals(otherEnd.getCigarString(), \"76M\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcxMDk5MA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414710990", "bodyText": "This method seems overly complicated and doesn't make enough use of existing coordinate switching code like htsjdk.samtools.SAMRecord#getReadPositionAtReferencePosition(htsjdk.samtools.SAMRecord, int, boolean)\nif you really need it, it needs to be heavily documented and tested.", "author": "yfarjoun", "createdAt": "2020-04-24T16:36:56Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +755,121 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n+                    final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n+                    final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n+                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n+\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            final byte[] bases = rec.getReadBases();\n+            final byte[] baseQualities = rec.getBaseQualities();\n+            final int readLength = rec.getReadLength();\n+\n+            if (rec.getReadNegativeStrandFlag()) {\n+                // Ensures that bases are reverse complemented and base qualities are reversed\n+                rec.setAttribute(HARD_CLIPPED_BASES_TAG, SequenceUtil.reverseComplement(StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1))));\n+                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, new StringBuilder(SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1))).reverse().toString());\n+            } else {\n+                rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n+                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities, clipFrom - 1, readLength)));\n+            }\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        if (rec.getReadNegativeStrandFlag()) {\n+            // Ensures that bases are reverse complemented and base qualities are reversed\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, SequenceUtil.reverseComplement(StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1))));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, new StringBuilder(SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1))).reverse().toString());\n+        } else {\n+            rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n+            rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities,clipFrom - 1, readLength)));\n+        }\n+    }\n+\n+    protected static int getDistanceFrom3PrimeEndToClipFrom(final SAMRecord rec, final int refPosToClipFrom) {", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex a806973f7..89a2be8c6 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -771,7 +781,6 @@ public abstract class AbstractAlignmentMerger {\n                     // Need to consider unclipped positions because often the read through bases have already been soft-clipped\n                     final int posClipFrom = getDistanceFrom3PrimeEndToClipFrom(pos, neg.getUnclippedEnd() + 1);\n                     final int negClipFrom = getDistanceFrom3PrimeEndToClipFrom(neg, pos.getUnclippedStart() - 1);\n-                    final CigarOperator clippingOperator = useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP;\n \n                     if(posClipFrom > 0) {\n                         clipRead(pos, posClipFrom, useHardClipping);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNjUzMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414726531", "bodyText": "as a change in public API, this is annoying. perhaps you should leave the previous method with a default of false?", "author": "yfarjoun", "createdAt": "2020-04-24T17:02:00Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -964,8 +1035,9 @@ public boolean isClipOverlappingReads() {\n         return clipOverlappingReads;\n     }\n \n-    public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n+    public void setClipOverlappingReads(final boolean clipOverlappingReads, final boolean hardClipOverlappingReads) {", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex a806973f7..89a2be8c6 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -1035,6 +1048,11 @@ public abstract class AbstractAlignmentMerger {\n         return clipOverlappingReads;\n     }\n \n+    public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n+        this.clipOverlappingReads = clipOverlappingReads;\n+        this.hardClipOverlappingReads = false;\n+    }\n+\n     public void setClipOverlappingReads(final boolean clipOverlappingReads, final boolean hardClipOverlappingReads) {\n         this.clipOverlappingReads = clipOverlappingReads;\n         this.hardClipOverlappingReads = hardClipOverlappingReads;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNzA3NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414727075", "bodyText": "docuement where the clipped bases/qualities go to", "author": "yfarjoun", "createdAt": "2020-04-24T17:02:58Z", "path": "src/main/java/picard/sam/MergeBamAlignment.java", "diffHunk": "@@ -256,9 +257,12 @@\n             \"alignment is filtered out for some reason. For all strategies, ties are resolved arbitrarily.\")\n     public PrimaryAlignmentStrategy PRIMARY_ALIGNMENT_STRATEGY = PrimaryAlignmentStrategy.BestMapq;\n \n-    @Argument(doc = \"For paired reads, soft clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.\")\n+    @Argument(doc = \"For paired reads, clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.  Clipping will be either soft or hard clipping, depending on CLIP_OVERLAPPING_READS_OPERATOR setting.\")\n     public boolean CLIP_OVERLAPPING_READS = true;\n \n+    @Argument(doc = \"If true, hard clipping will be applied to overlapping reads.  By default, soft clipping is used.\")", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "c36152e97fc74246396b725a4df10776f29002c1", "chunk": "diff --git a/src/main/java/picard/sam/MergeBamAlignment.java b/src/main/java/picard/sam/MergeBamAlignment.java\nindex 07d99c984..695bb9944 100644\n--- a/src/main/java/picard/sam/MergeBamAlignment.java\n+++ b/src/main/java/picard/sam/MergeBamAlignment.java\n\n@@ -257,7 +257,9 @@ public class MergeBamAlignment extends CommandLineProgram {\n             \"alignment is filtered out for some reason. For all strategies, ties are resolved arbitrarily.\")\n     public PrimaryAlignmentStrategy PRIMARY_ALIGNMENT_STRATEGY = PrimaryAlignmentStrategy.BestMapq;\n \n-    @Argument(doc = \"For paired reads, clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.  Clipping will be either soft or hard clipping, depending on CLIP_OVERLAPPING_READS_OPERATOR setting.\")\n+    @Argument(doc = \"For paired reads, clip the 3' end of each read if necessary so that it does not extend past the 5' end of its mate.  \" +\n+            \"Clipping will be either soft or hard clipping, depending on CLIP_OVERLAPPING_READS_OPERATOR setting. \" +\n+            \"Hard clipped bases and their qualities will be stored in the eB and eQ tags respectively.\")\n     public boolean CLIP_OVERLAPPING_READS = true;\n \n     @Argument(doc = \"If true, hard clipping will be applied to overlapping reads.  By default, soft clipping is used.\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNzY4MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r414727681", "bodyText": "there seems to be a preference for explicit imports rather than wildcard. you can change your intelliJ settings for that.", "author": "yfarjoun", "createdAt": "2020-04-24T17:03:55Z", "path": "src/test/java/picard/sam/AbstractAlignmentMergerTest.java", "diffHunk": "@@ -1,15 +1,10 @@\n package picard.sam;\n \n-import htsjdk.samtools.SAMFileHeader;\n-import htsjdk.samtools.SAMFileWriter;\n-import htsjdk.samtools.SAMFileWriterFactory;\n-import htsjdk.samtools.SAMRecord;\n-import htsjdk.samtools.SAMRecordIterator;\n-import htsjdk.samtools.SAMRecordSetBuilder;\n-import htsjdk.samtools.SamReader;\n-import htsjdk.samtools.SamReaderFactory;\n-import htsjdk.samtools.ValidationStringency;\n+import htsjdk.samtools.*;", "originalCommit": "c563d32a2092cd6c6e315fe9b7d1de4195170d4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0MDI3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423940273", "bodyText": "this.", "author": "yfarjoun", "createdAt": "2020-05-12T18:19:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDcyNzY4MQ=="}], "type": "inlineReview", "revised_code": {"commit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "chunk": "diff --git a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\nindex dd78384f5..f0acb06d0 100644\n--- a/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n+++ b/src/test/java/picard/sam/AbstractAlignmentMergerTest.java\n\n@@ -1,7 +1,13 @@\n package picard.sam;\n \n-import htsjdk.samtools.*;\n-import htsjdk.samtools.util.SequenceUtil;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMFileWriter;\n+import htsjdk.samtools.SAMFileWriterFactory;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordSetBuilder;\n+import htsjdk.samtools.SAMUtils;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n import htsjdk.samtools.util.StringUtil;\n import org.testng.Assert;\n import org.testng.annotations.DataProvider;\n"}}, {"oid": "c36152e97fc74246396b725a4df10776f29002c1", "url": "https://github.com/broadinstitute/picard/commit/c36152e97fc74246396b725a4df10776f29002c1", "message": "Responding to all but one of Yossi's comments", "committedDate": "2020-05-01T15:35:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYwMTE4MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r418601181", "bodyText": "single line } else {", "author": "yfarjoun", "createdAt": "2020-05-01T15:47:54Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -788,38 +797,42 @@ private static void clipRead(final SAMRecord rec, final int clipFrom, final bool\n \n         // If we are using hard clips, add bases and qualities to SAM tag.\n         if (useHardClipping) {\n-            final byte[] bases = rec.getReadBases();\n-            final byte[] baseQualities = rec.getBaseQualities();\n-            final int readLength = rec.getReadLength();\n-\n-            if (rec.getReadNegativeStrandFlag()) {\n-                // Ensures that bases are reverse complemented and base qualities are reversed\n-                rec.setAttribute(HARD_CLIPPED_BASES_TAG, SequenceUtil.reverseComplement(StringUtil.bytesToString(Arrays.copyOf(bases, bases.length - clipFrom + 1))));\n-                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, new StringBuilder(SAMUtils.phredToFastq(Arrays.copyOf(baseQualities, baseQualities.length - clipFrom + 1))).reverse().toString());\n-            } else {\n-                rec.setAttribute(HARD_CLIPPED_BASES_TAG, StringUtil.bytesToString(Arrays.copyOfRange(bases, clipFrom - 1, readLength)));\n-                rec.setAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG, SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities, clipFrom - 1, readLength)));\n-            }\n+            moveClippedBasesToTag(rec, clipFrom);\n         }\n \n         // Actually clip the read\n         CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n     }\n \n     private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record already contains tags for restoring hard clipped bases.  This operation will permanently erase information if it proceeds.\");\n+        }\n \n         final byte[] bases = rec.getReadBases();\n         final byte[] baseQualities = rec.getBaseQualities();\n         final int readLength = rec.getReadLength();\n \n+        final int clipPositionFrom, clipPositionTo;\n+        if (rec.getReadNegativeStrandFlag()) {\n+            clipPositionFrom = 0;\n+            clipPositionTo = bases.length - clipFrom + 1;\n+        }", "originalCommit": "c36152e97fc74246396b725a4df10776f29002c1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6713891198a795f619079d84bf0f8be5dd30eae5", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex 89a2be8c6..fa077fb0d 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -793,8 +797,26 @@ public abstract class AbstractAlignmentMerger {\n         }\n     }\n \n-    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int p;\n+        final Cigar cigar = rec.getCigar();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(cigar.getCigarElements()); //need to be modifiable\n+        for (final CigarElement cigarElement : cigarElements) {\n+            CigarOperator op = cigarElement.getOperator();\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                op = CigarOperator.MATCH_OR_MISMATCH;\n+            }\n+            newCigar.add(new CigarElement(cigarElement.getLength(), op));\n+        }\n+\n+        rec.setCigar(newCigar);\n \n+        p = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false, false);\n+        return p;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n         // If we are using hard clips, add bases and qualities to SAM tag.\n         if (useHardClipping) {\n             moveClippedBasesToTag(rec, clipFrom);\n"}}, {"oid": "6713891198a795f619079d84bf0f8be5dd30eae5", "url": "https://github.com/broadinstitute/picard/commit/6713891198a795f619079d84bf0f8be5dd30eae5", "message": "Experimenting with different methods of getting read position at reference position including soft clips", "committedDate": "2020-05-03T03:38:40Z", "type": "commit"}, {"oid": "20f92b0ec2be41663c6d57a80350a7116ea1c1b1", "url": "https://github.com/broadinstitute/picard/commit/20f92b0ec2be41663c6d57a80350a7116ea1c1b1", "message": "Running this through the test suite, do not review or merge.  Testing alternative usage of getReadPositionAtReferencePosition", "committedDate": "2020-05-03T15:12:30Z", "type": "commit"}, {"oid": "361e25c47a629dcf554ad7dba7fa5a96ac05ad70", "url": "https://github.com/broadinstitute/picard/commit/361e25c47a629dcf554ad7dba7fa5a96ac05ad70", "message": "Reverting htsjdk version to released version", "committedDate": "2020-05-03T15:20:37Z", "type": "commit"}, {"oid": "7f5c73403f1f0d32325c777cbf7c4f52e7b2ff97", "url": "https://github.com/broadinstitute/picard/commit/7f5c73403f1f0d32325c777cbf7c4f52e7b2ff97", "message": "Adding tests, and ability to revert hard-clipped reads", "committedDate": "2020-05-07T00:53:51Z", "type": "commit"}, {"oid": "dc2d098e741fb32e0726814f8e2154cde3210964", "url": "https://github.com/broadinstitute/picard/commit/dc2d098e741fb32e0726814f8e2154cde3210964", "message": "Fixing issue with import", "committedDate": "2020-05-07T01:29:05Z", "type": "commit"}, {"oid": "bf4ce44e4353f80863cca180bc4a421ee99fcce5", "url": "https://github.com/broadinstitute/picard/commit/bf4ce44e4353f80863cca180bc4a421ee99fcce5", "message": "Using XB and XQ instead of eB and eQ and a few minor clean ups", "committedDate": "2020-05-07T02:54:22Z", "type": "commit"}, {"oid": "2a8822c1991fa3d7c28350115d139460cbe35d5a", "url": "https://github.com/broadinstitute/picard/commit/2a8822c1991fa3d7c28350115d139460cbe35d5a", "message": "Updated hard-cliped test sam file to use correct tags in test", "committedDate": "2020-05-07T14:37:50Z", "type": "commit"}, {"oid": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "url": "https://github.com/broadinstitute/picard/commit/bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "message": "Fixed some sam tags in a test", "committedDate": "2020-05-07T15:09:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczMTkwMg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421731902", "bodyText": "cigarElements can still be final, right?", "author": "yfarjoun", "createdAt": "2020-05-07T19:10:37Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -782,10 +782,10 @@ public abstract class AbstractAlignmentMerger {\n                     negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n                     if(posClipFrom > 0) {\n-                        clipRead(pos, posClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n                     }\n                     if(negClipFrom > 0) {\n-                        clipRead(neg, negClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNTYzMA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421735630", "bodyText": "I think some comments about what's happening here would be appreciated by a future developer...", "author": "yfarjoun", "createdAt": "2020-05-07T19:17:30Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -782,10 +782,10 @@ public abstract class AbstractAlignmentMerger {\n                     negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n                     if(posClipFrom > 0) {\n-                        clipRead(pos, posClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n                     }\n                     if(negClipFrom > 0) {\n-                        clipRead(neg, negClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNTk3NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421735975", "bodyText": "what if this is negative?", "author": "yfarjoun", "createdAt": "2020-05-07T19:18:04Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -782,10 +782,10 @@ public abstract class AbstractAlignmentMerger {\n                     negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n                     if(posClipFrom > 0) {\n-                        clipRead(pos, posClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n                     }\n                     if(negClipFrom > 0) {\n-                        clipRead(neg, negClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNzA3NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421737074", "bodyText": "I would include 3primeEnd in the names of the methods here..", "author": "yfarjoun", "createdAt": "2020-05-07T19:20:04Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        rec.setAlignmentStart(oldStart);\n+        return readPosition;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -782,10 +782,10 @@ public abstract class AbstractAlignmentMerger {\n                     negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n                     if(posClipFrom > 0) {\n-                        clipRead(pos, posClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n                     }\n                     if(negClipFrom > 0) {\n-                        clipRead(neg, negClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczNzc2MQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421737761", "bodyText": "make sure you include the name of the offending record, and the names of the tags that you need...otherwise, debugging this might be tough.", "author": "yfarjoun", "createdAt": "2020-05-07T19:21:28Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        rec.setAlignmentStart(oldStart);\n+        return readPosition;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            moveClippedBasesToTag(rec, clipFrom);\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record already contains tags for restoring hard clipped bases.  This operation will permanently erase information if it proceeds.\");", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -782,10 +782,10 @@ public abstract class AbstractAlignmentMerger {\n                     negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n                     if(posClipFrom > 0) {\n-                        clipRead(pos, posClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n                     }\n                     if(negClipFrom > 0) {\n-                        clipRead(neg, negClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTczOTA5OA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421739098", "bodyText": "\"ensures that the qualities and bases in the tags are stored in their original order, as produced by the sequencer\"", "author": "yfarjoun", "createdAt": "2020-05-07T19:23:55Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,103 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clipRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clipRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements()); //need to be modifiable\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        rec.setAlignmentStart(rec.getAlignmentStart() - posShift);\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        rec.setAlignmentStart(oldStart);\n+        return readPosition;\n+    }\n+\n+    private static void clipRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            moveClippedBasesToTag(rec, clipFrom);\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record already contains tags for restoring hard clipped bases.  This operation will permanently erase information if it proceeds.\");\n+        }\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        final int clipPositionFrom, clipPositionTo;\n+        if (rec.getReadNegativeStrandFlag()) {\n+            clipPositionFrom = 0;\n+            clipPositionTo = bases.length - clipFrom + 1;\n+        } else {\n+            clipPositionFrom = clipFrom - 1;\n+            clipPositionTo = readLength;\n+        }\n+\n+        String basesToKeepInTag = StringUtil.bytesToString(Arrays.copyOfRange(bases, clipPositionFrom, clipPositionTo));\n+        String qualitiesToKeepInTag = SAMUtils.phredToFastq(Arrays.copyOfRange(baseQualities, clipPositionFrom, clipPositionTo));\n+\n+        if (rec.getReadNegativeStrandFlag()) {\n+            // Ensures that bases are reverse complemented and base qualities are reversed", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -782,10 +782,10 @@ public abstract class AbstractAlignmentMerger {\n                     negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n                     if(posClipFrom > 0) {\n-                        clipRead(pos, posClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n                     }\n                     if(negClipFrom > 0) {\n-                        clipRead(neg, negClipFrom, useHardClipping);\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MTE5OA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421741198", "bodyText": "I know I said this is better than changing a public API...but it's still not good. set* methods should only change the variable they are named for. why not add a setClipWithHardClips method and avoid changing two things in one method?", "author": "yfarjoun", "createdAt": "2020-05-07T19:27:44Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -966,6 +1029,12 @@ public boolean isClipOverlappingReads() {\n \n     public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n         this.clipOverlappingReads = clipOverlappingReads;\n+        this.hardClipOverlappingReads = false;", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex c83eee1af..aa8136551 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -1029,11 +1030,9 @@ public abstract class AbstractAlignmentMerger {\n \n     public void setClipOverlappingReads(final boolean clipOverlappingReads) {\n         this.clipOverlappingReads = clipOverlappingReads;\n-        this.hardClipOverlappingReads = false;\n     }\n \n-    public void setClipOverlappingReads(final boolean clipOverlappingReads, final boolean hardClipOverlappingReads) {\n-        this.clipOverlappingReads = clipOverlappingReads;\n+    public void setHardClipOverlappingReads(final boolean hardClipOverlappingReads) {\n         this.hardClipOverlappingReads = hardClipOverlappingReads;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MTU4OA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421741588", "bodyText": "hi mark", "author": "yfarjoun", "createdAt": "2020-05-07T19:28:26Z", "path": "src/main/java/picard/sam/RevertSam.java", "diffHunk": "@@ -373,6 +366,10 @@ public void revertSamRecord(final SAMRecord rec) {\n             rec.setDuplicateReadFlag(false);\n         }\n \n+        if (RESTORE_HARDCLIPS && !REMOVE_ALIGNMENT_INFORMATION) {\n+            throw new PicardException(\"hi mom\");", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/main/java/picard/sam/RevertSam.java b/src/main/java/picard/sam/RevertSam.java\nindex 0588b9ae4..2056f5d05 100644\n--- a/src/main/java/picard/sam/RevertSam.java\n+++ b/src/main/java/picard/sam/RevertSam.java\n\n@@ -366,10 +370,6 @@ public class RevertSam extends CommandLineProgram {\n             rec.setDuplicateReadFlag(false);\n         }\n \n-        if (RESTORE_HARDCLIPS && !REMOVE_ALIGNMENT_INFORMATION) {\n-            throw new PicardException(\"hi mom\");\n-        }\n-\n         if (REMOVE_ALIGNMENT_INFORMATION) {\n             if (rec.getReadNegativeStrandFlag()) {\n                 rec.reverseComplement(true);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MjI0Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421742247", "bodyText": "please verify your assumption (and throw otherwise)", "author": "yfarjoun", "createdAt": "2020-05-07T19:29:35Z", "path": "src/main/java/picard/sam/RevertSam.java", "diffHunk": "@@ -396,6 +393,20 @@ public void revertSamRecord(final SAMRecord rec) {\n             rec.setMateReferenceIndex(SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX);\n             rec.setMateUnmappedFlag(rec.getReadPairedFlag());\n \n+            if (RESTORE_HARDCLIPS) {\n+                String hardClippedBases = rec.getStringAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASES_TAG);\n+                String hardClippedQualities = rec.getStringAttribute(AbstractAlignmentMerger.HARD_CLIPPED_BASE_QUALITIES_TAG);\n+                if (hardClippedBases != null && hardClippedQualities != null) {\n+                    // Record has already been reverse complemented if this was on the negative strand\n+                    rec.setReadString(rec.getReadString() + hardClippedBases);", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNDM1NQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423834355", "bodyText": "nm.", "author": "yfarjoun", "createdAt": "2020-05-12T15:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MjI0Nw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzcyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421743721", "bodyText": "update comment with actual tag name", "author": "yfarjoun", "createdAt": "2020-05-07T19:32:26Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +539,26 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClippedRecovery() throws Exception {\n+        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNTExNw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423835117", "bodyText": "tB and tQ tags?", "author": "yfarjoun", "createdAt": "2020-05-12T15:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzcyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzNzUxNw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423937517", "bodyText": "why does the comment keep saying tB and tQ?", "author": "yfarjoun", "createdAt": "2020-05-12T18:15:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzcyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex faa193fb3..815a23dbc 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -541,24 +544,46 @@ public class RevertSamTest extends CommandLineProgramTest {\n     }\n \n     @Test\n-    public void testHardClippedRecovery() throws Exception {\n-        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n         // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n-        final String [] args = new String[]{\n-                \"I=\" + hardClippedSamToRevert,\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n                 \"RESTORE_HARDCLIPS=true\",\n-                \"O=\" + outputFile.getAbsolutePath()\n+                \"O=\" + outputRevert.getAbsolutePath()\n         };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n \n-        // Ensure that the reverted reads and qualities match the tB and tQ tags\n-        final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputFile);\n-        for (final SAMRecord rec : reader) {\n-            Assert.assertEquals(rec.getReadString(), rec.getStringAttribute(\"tB\"), \"read string\");\n-            Assert.assertEquals(SAMUtils.phredToFastq(rec.getBaseQualities()), rec.getStringAttribute(\"tQ\"), \"hi\");\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();\n+            SAMRecord unmapped = unmappedIterator.next();\n+\n+            Assert.assertEquals(reverted.getReadString(), unmapped.getReadString());\n+            Assert.assertEquals(SAMUtils.phredToFastq(reverted.getBaseQualities()), SAMUtils.phredToFastq(unmapped.getBaseQualities()));\n+        }\n+        if (revertedIterator.hasNext() || unmappedIterator.hasNext()) {\n+            Assert.fail(\"Reverted sam file should be identical in length to unmapped sam file in test, but was not.\");\n         }\n-        reader.close();\n \n+        revertedReader.close();\n+        unmappedReader.close();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0MzgxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421743811", "bodyText": "comment", "author": "yfarjoun", "createdAt": "2020-05-07T19:32:35Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +539,26 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClippedRecovery() throws Exception {\n+        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] args = new String[]{\n+                \"I=\" + hardClippedSamToRevert,\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputFile.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(args), 0);\n+\n+        // Ensure that the reverted reads and qualities match the tB and tQ tags", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex faa193fb3..815a23dbc 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -541,24 +544,46 @@ public class RevertSamTest extends CommandLineProgramTest {\n     }\n \n     @Test\n-    public void testHardClippedRecovery() throws Exception {\n-        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n         // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n-        final String [] args = new String[]{\n-                \"I=\" + hardClippedSamToRevert,\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n                 \"RESTORE_HARDCLIPS=true\",\n-                \"O=\" + outputFile.getAbsolutePath()\n+                \"O=\" + outputRevert.getAbsolutePath()\n         };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n \n-        // Ensure that the reverted reads and qualities match the tB and tQ tags\n-        final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputFile);\n-        for (final SAMRecord rec : reader) {\n-            Assert.assertEquals(rec.getReadString(), rec.getStringAttribute(\"tB\"), \"read string\");\n-            Assert.assertEquals(SAMUtils.phredToFastq(rec.getBaseQualities()), rec.getStringAttribute(\"tQ\"), \"hi\");\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();\n+            SAMRecord unmapped = unmappedIterator.next();\n+\n+            Assert.assertEquals(reverted.getReadString(), unmapped.getReadString());\n+            Assert.assertEquals(SAMUtils.phredToFastq(reverted.getBaseQualities()), SAMUtils.phredToFastq(unmapped.getBaseQualities()));\n+        }\n+        if (revertedIterator.hasNext() || unmappedIterator.hasNext()) {\n+            Assert.fail(\"Reverted sam file should be identical in length to unmapped sam file in test, but was not.\");\n         }\n-        reader.close();\n \n+        revertedReader.close();\n+        unmappedReader.close();\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc0NDcxMg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r421744712", "bodyText": "Could you add around-tripping test, that merges and then restores?", "author": "yfarjoun", "createdAt": "2020-05-07T19:34:13Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +539,26 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test", "originalCommit": "bcd656a9fd34538fbc75f5111d6a00a6d08ef490", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex faa193fb3..815a23dbc 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -541,24 +544,46 @@ public class RevertSamTest extends CommandLineProgramTest {\n     }\n \n     @Test\n-    public void testHardClippedRecovery() throws Exception {\n-        final File outputFile = File.createTempFile(\"test-output-hard-clipped-recovery\", \".sam\");\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n         // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n-        final String [] args = new String[]{\n-                \"I=\" + hardClippedSamToRevert,\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n                 \"RESTORE_HARDCLIPS=true\",\n-                \"O=\" + outputFile.getAbsolutePath()\n+                \"O=\" + outputRevert.getAbsolutePath()\n         };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n \n-        // Ensure that the reverted reads and qualities match the tB and tQ tags\n-        final SamReader reader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputFile);\n-        for (final SAMRecord rec : reader) {\n-            Assert.assertEquals(rec.getReadString(), rec.getStringAttribute(\"tB\"), \"read string\");\n-            Assert.assertEquals(SAMUtils.phredToFastq(rec.getBaseQualities()), rec.getStringAttribute(\"tQ\"), \"hi\");\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();\n+            SAMRecord unmapped = unmappedIterator.next();\n+\n+            Assert.assertEquals(reverted.getReadString(), unmapped.getReadString());\n+            Assert.assertEquals(SAMUtils.phredToFastq(reverted.getBaseQualities()), SAMUtils.phredToFastq(unmapped.getBaseQualities()));\n+        }\n+        if (revertedIterator.hasNext() || unmappedIterator.hasNext()) {\n+            Assert.fail(\"Reverted sam file should be identical in length to unmapped sam file in test, but was not.\");\n         }\n-        reader.close();\n \n+        revertedReader.close();\n+        unmappedReader.close();\n     }\n }\n"}}, {"oid": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "url": "https://github.com/broadinstitute/picard/commit/2d2ccf1d274316b3e89a3d49f3ad416943a55896", "message": "Responding to Yossi's comments again", "committedDate": "2020-05-12T13:21:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NDg0OQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423754849", "bodyText": "// instead of setting back the position of the read by posShift, which could create a negative start position, we add posShift the final position in the read.", "author": "yfarjoun", "createdAt": "2020-05-12T13:57:33Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,104 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        final List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements());\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            // Replace SOFT_CLIPs in the oldCigar with MATCH_OR_MISMATCH in newCigar\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        // Temporarily use the newCigar that has SOFT_CLIPs replaced with MATCH_OR_MISMATCH to get read position at reference, but ignore existence of soft-clips\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        return readPosition + posShift;", "originalCommit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b9796be81b5adf7800685e5f19526ba496ae256", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex aa8136551..bb3c9ee88 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -822,6 +822,7 @@ public abstract class AbstractAlignmentMerger {\n         rec.setCigar(newCigar);\n         readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n         rec.setCigar(oldCigar);\n+        // instead of setting back the position of the read by posShift, which could create a negative start position, we add posShift the final position in the read.\n         return readPosition + posShift;\n     }\n \n"}}, {"oid": "1b9796be81b5adf7800685e5f19526ba496ae256", "url": "https://github.com/broadinstitute/picard/commit/1b9796be81b5adf7800685e5f19526ba496ae256", "message": "Adding comment about posShiftt so we don't accidently create a negative start position", "committedDate": "2020-05-12T15:30:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NTg3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423755873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        clipPositionTo = bases.length - clipFrom + 1;\n          \n          \n            \n                        clipPositionTo = readLength - clipFrom + 1;", "author": "yfarjoun", "createdAt": "2020-05-12T13:58:50Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -751,54 +765,104 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n     }\n \n     /**\n-     * Checks to see whether the ends of the reads overlap and soft clips reads\n-     * them if necessary.\n+     * Checks to see whether the ends of the reads overlap and clips reads\n+     * if necessary.\n      */\n-    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2) {\n-        // If both reads are mapped, see if we need to clip the ends due to small\n-        // insert size\n+    protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n+        // If both reads are mapped, see if we need to clip the ends due to small insert size\n         if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n             if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n                 final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n                 final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n \n                 // Innies only -- do we need to do anything else about jumping libraries?\n                 if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    final int posDiff = pos.getAlignmentEnd() - neg.getAlignmentEnd();\n-                    final int negDiff = pos.getAlignmentStart() - neg.getAlignmentStart();\n-\n-                    if (posDiff > 0) {\n-                        final List<CigarElement> elems = new ArrayList<>(pos.getCigar().getCigarElements());\n-                        Collections.reverse(elems);\n-                        final int clipped = lengthOfSoftClipping(elems.iterator());\n-                        final int clipFrom = pos.getReadLength() - posDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(pos, Math.min(pos.getReadLength(), clipFrom));\n-                    }\n+                    final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, neg.getUnclippedEnd() + 1);\n+                    int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, pos.getUnclippedStart() - 1);\n+                    negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n \n-                    if (negDiff > 0) {\n-                        final int clipped = lengthOfSoftClipping(neg.getCigar().getCigarElements().iterator());\n-                        final int clipFrom = neg.getReadLength() - negDiff - clipped + 1;\n-                        CigarUtil.softClip3PrimeEndOfRead(neg, Math.min(neg.getReadLength(), clipFrom));\n+                    if(posClipFrom > 0) {\n+                        clip3PrimeEndOfRead(pos, posClipFrom, useHardClipping);\n+                    }\n+                    if(negClipFrom > 0) {\n+                        clip3PrimeEndOfRead(neg, negClipFrom, useHardClipping);\n                     }\n                 }\n             }\n         }\n     }\n \n-    /** Returns the number of soft-clipped bases until a non-soft-clipping element is encountered. */\n-    private static int lengthOfSoftClipping(Iterator<CigarElement> iterator) {\n-        int clipped = 0;\n-        while (iterator.hasNext()) {\n-            final CigarElement elem = iterator.next();\n-            if (elem.getOperator() != CigarOperator.SOFT_CLIP && elem.getOperator() != CigarOperator.HARD_CLIP) {\n-                break;\n-            }\n-            if (elem.getOperator() == CigarOperator.SOFT_CLIP) {\n-                clipped = elem.getLength();\n+    private static int getReadPositionAtReferencePositionIgnoreSoftClips(final SAMRecord rec, final int pos) {\n+        final int readPosition;\n+        final Cigar oldCigar = rec.getCigar();\n+        final int oldStart = rec.getAlignmentStart();\n+        final Cigar newCigar = new Cigar();\n+        final List<CigarElement> cigarElements = new ArrayList<>(oldCigar.getCigarElements());\n+        int posShift = 0;\n+        boolean foundNonClip = false;\n+\n+        for (final CigarElement cigarElement : cigarElements) {\n+            final CigarOperator op = cigarElement.getOperator();\n+\n+            // Replace SOFT_CLIPs in the oldCigar with MATCH_OR_MISMATCH in newCigar\n+            if (op == CigarOperator.SOFT_CLIP) {\n+                newCigar.add(new CigarElement(cigarElement.getLength(), CigarOperator.MATCH_OR_MISMATCH));\n+                if (!foundNonClip) {\n+                    posShift += cigarElement.getLength();\n+                }\n+            } else {\n+                if (!op.isClipping()) {\n+                    foundNonClip = true;\n+                }\n+                newCigar.add(new CigarElement(cigarElement.getLength(), op));\n             }\n         }\n \n-        return clipped;\n+        // Temporarily use the newCigar that has SOFT_CLIPs replaced with MATCH_OR_MISMATCH to get read position at reference, but ignore existence of soft-clips\n+        rec.setCigar(newCigar);\n+        readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n+        rec.setCigar(oldCigar);\n+        return readPosition + posShift;\n+    }\n+\n+    private static void clip3PrimeEndOfRead(final SAMRecord rec, final int clipFrom, final boolean useHardClipping) {\n+        // If we are using hard clips, add bases and qualities to SAM tag.\n+        if (useHardClipping) {\n+            moveClippedBasesToTag(rec, clipFrom);\n+        }\n+\n+        // Actually clip the read\n+        CigarUtil.clip3PrimeEndOfRead(rec, clipFrom, useHardClipping ? CigarOperator.HARD_CLIP : CigarOperator.SOFT_CLIP);\n+    }\n+\n+    private static void moveClippedBasesToTag(final SAMRecord rec, final int clipFrom) {\n+        if (rec.getAttribute(HARD_CLIPPED_BASES_TAG) != null || rec.getAttribute(HARD_CLIPPED_BASE_QUALITIES_TAG) != null) {\n+            throw new PicardException(\"Record \" + rec.getReadName() + \" already contains tags for restoring hard-clipped bases.  This operation will permanently erase information if it proceeds.\");\n+        }\n+\n+        final byte[] bases = rec.getReadBases();\n+        final byte[] baseQualities = rec.getBaseQualities();\n+        final int readLength = rec.getReadLength();\n+\n+        final int clipPositionFrom, clipPositionTo;\n+        if (rec.getReadNegativeStrandFlag()) {\n+            clipPositionFrom = 0;\n+            clipPositionTo = bases.length - clipFrom + 1;", "originalCommit": "2d2ccf1d274316b3e89a3d49f3ad416943a55896", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1b9796be81b5adf7800685e5f19526ba496ae256", "chunk": "diff --git a/src/main/java/picard/sam/AbstractAlignmentMerger.java b/src/main/java/picard/sam/AbstractAlignmentMerger.java\nindex aa8136551..bb3c9ee88 100644\n--- a/src/main/java/picard/sam/AbstractAlignmentMerger.java\n+++ b/src/main/java/picard/sam/AbstractAlignmentMerger.java\n\n@@ -822,6 +822,7 @@ public abstract class AbstractAlignmentMerger {\n         rec.setCigar(newCigar);\n         readPosition = SAMRecord.getReadPositionAtReferencePosition(rec, pos, false);\n         rec.setCigar(oldCigar);\n+        // instead of setting back the position of the read by posShift, which could create a negative start position, we add posShift the final position in the read.\n         return readPosition + posShift;\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzMDc3NA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423830774", "bodyText": "do explicit imports please.", "author": "yfarjoun", "createdAt": "2020-05-12T15:34:08Z", "path": "src/main/java/picard/sam/RevertSam.java", "diffHunk": "@@ -24,18 +24,8 @@\n \n package picard.sam;\n \n-import htsjdk.samtools.BAMRecordCodec;\n-import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.*;", "originalCommit": "1b9796be81b5adf7800685e5f19526ba496ae256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "chunk": "diff --git a/src/main/java/picard/sam/RevertSam.java b/src/main/java/picard/sam/RevertSam.java\nindex 2056f5d05..a43debca1 100644\n--- a/src/main/java/picard/sam/RevertSam.java\n+++ b/src/main/java/picard/sam/RevertSam.java\n\n@@ -24,8 +24,19 @@\n \n package picard.sam;\n \n-import htsjdk.samtools.*;\n+import htsjdk.samtools.BAMRecordCodec;\n+import htsjdk.samtools.SAMFileHeader;\n import htsjdk.samtools.SAMFileHeader.SortOrder;\n+import htsjdk.samtools.SAMFileWriter;\n+import htsjdk.samtools.SAMFileWriterFactory;\n+import htsjdk.samtools.SAMReadGroupRecord;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SAMRecordQueryNameComparator;\n+import htsjdk.samtools.SAMTag;\n+import htsjdk.samtools.SAMUtils;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.ValidationStringency;\n import htsjdk.samtools.filter.FilteringSamIterator;\n import htsjdk.samtools.filter.SamRecordFilter;\n import htsjdk.samtools.util.CloserUtil;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgzNTQ4Mg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423835482", "bodyText": "why split this line?", "author": "yfarjoun", "createdAt": "2020-05-12T15:40:19Z", "path": "src/test/java/picard/sam/MergeSamFilesTest.java", "diffHunk": "@@ -37,7 +37,8 @@\n \n import java.io.File;\n \n-public class MergeSamFilesTest extends CommandLineProgramTest {\n+public class", "originalCommit": "1b9796be81b5adf7800685e5f19526ba496ae256", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "chunk": "diff --git a/src/test/java/picard/sam/MergeSamFilesTest.java b/src/test/java/picard/sam/MergeSamFilesTest.java\nindex 19dfd922f..880753281 100644\n--- a/src/test/java/picard/sam/MergeSamFilesTest.java\n+++ b/src/test/java/picard/sam/MergeSamFilesTest.java\n\n@@ -37,8 +37,7 @@ import picard.sam.testers.ValidateSamTester;\n \n import java.io.File;\n \n-public class\n-MergeSamFilesTest extends CommandLineProgramTest {\n+public class MergeSamFilesTest extends CommandLineProgramTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/MergeSamFiles\");\n \n     public String getCommandLineProgramName() {\n"}}, {"oid": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "url": "https://github.com/broadinstitute/picard/commit/9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "message": "Fixing a few nits", "committedDate": "2020-05-12T16:06:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzODgxMg==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423938812", "bodyText": "final", "author": "yfarjoun", "createdAt": "2020-05-12T18:17:08Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,48 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputRevert.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n+\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex 815a23dbc..78a852407 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -549,7 +549,6 @@ public class RevertSamTest extends CommandLineProgramTest {\n         // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n         final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n-        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n         final String [] mergeBamAlignmentsArgs = new String[] {\n            \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n            \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzODg2Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423938867", "bodyText": "final", "author": "yfarjoun", "createdAt": "2020-05-12T18:17:14Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,48 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputRevert.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n+\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);\n+        final SamReader unmappedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(hardClippedUnmappedSam);\n+        final SAMRecordIterator revertedIterator = revertedReader.iterator();\n+        final SAMRecordIterator unmappedIterator = unmappedReader.iterator();\n+\n+        while (revertedIterator.hasNext() && unmappedIterator.hasNext()) {\n+            SAMRecord reverted = revertedIterator.next();\n+            SAMRecord unmapped = unmappedIterator.next();", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex 815a23dbc..78a852407 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -549,7 +549,6 @@ public class RevertSamTest extends CommandLineProgramTest {\n         // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n         final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n-        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n         final String [] mergeBamAlignmentsArgs = new String[] {\n            \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n            \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzOTcxOA==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423939718", "bodyText": "convert to try-with-resources to assure closing the readers", "author": "yfarjoun", "createdAt": "2020-05-12T18:18:33Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,48 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");\n+        final String [] revertSamArgs = new String[] {\n+                \"I=\" + outputMBA.getAbsolutePath(),\n+                \"RESTORE_HARDCLIPS=true\",\n+                \"O=\" + outputRevert.getAbsolutePath()\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"RevertSam\", revertSamArgs), 0);\n+\n+        final SamReader revertedReader = SamReaderFactory.makeDefault().referenceSequence(referenceFasta).open(outputRevert);", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex 815a23dbc..78a852407 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -549,7 +549,6 @@ public class RevertSamTest extends CommandLineProgramTest {\n         // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n         final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n-        // hardClippedSamToRevert is a sam file with the expected reverted reads and base qualities stored in the tB and tQ tags respectively\n         final String [] mergeBamAlignmentsArgs = new String[] {\n            \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n            \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzk0MDMyMw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r423940323", "bodyText": "remove extra NLs", "author": "yfarjoun", "createdAt": "2020-05-12T18:19:39Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -54,7 +59,13 @@ public int runPicardCommandLine(final String[] args) {\n         return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(args));\n     }\n \n+    public int runPicardCommandLine(final String programName, final String[] args) {\n+        return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(programName, Arrays.asList(args)));\n+    }\n+\n     public int runPicardCommandLine(final Map<String, String> kwargs) {\n         return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(kwargs));\n     }\n+", "originalCommit": "9df6c1c0169de5da2d9f85180fb9d5f1031cf6bd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "chunk": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 3640db1b0..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n\n@@ -66,6 +66,4 @@ public abstract class CommandLineProgramTest {\n     public int runPicardCommandLine(final Map<String, String> kwargs) {\n         return new PicardCommandLine().instanceMain(makePicardCommandLineArgs(kwargs));\n     }\n-\n-\n }\n"}}, {"oid": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "url": "https://github.com/broadinstitute/picard/commit/f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "message": "Try with resources, removing vestigal comment, and whitespace fix", "committedDate": "2020-05-12T18:57:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyMzg0Nw==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r424023847", "bodyText": "delete on exit", "author": "yfarjoun", "createdAt": "2020-05-12T20:48:03Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,45 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");", "originalCommit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f39e69e289632591a0fb9656158679ee71e7aea0", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex 78a852407..1f81afb92 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -549,6 +549,7 @@ public class RevertSamTest extends CommandLineProgramTest {\n         // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n         final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        outputMBA.deleteOnExit();\n         final String [] mergeBamAlignmentsArgs = new String[] {\n            \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n            \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAyNDAxNQ==", "url": "https://github.com/broadinstitute/picard/pull/1484#discussion_r424024015", "bodyText": "delete on exit", "author": "yfarjoun", "createdAt": "2020-05-12T20:48:18Z", "path": "src/test/java/picard/sam/RevertSamTest.java", "diffHunk": "@@ -538,4 +542,45 @@ public void testSanitizeAndDeduplicateRecords() throws Exception {\n         Assert.assertEquals(runPicardCommandLine(args), 0);\n         verifyPositiveResults(output, new RevertSam(), true, true, false, false, null, 8, null, null);\n     }\n+\n+    @Test\n+    public void testHardClipRoundTrip() throws Exception {\n+        // Runs sam files through MergeBamAlignment using hard clipping on overlapping reads.\n+        // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n+\n+        final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        final String [] mergeBamAlignmentsArgs = new String[] {\n+           \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n+           \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n+           \"OUTPUT=\" + outputMBA.getAbsolutePath(),\n+           \"REFERENCE_SEQUENCE=\" + hardClipFasta.getAbsolutePath(),\n+           \"HARD_CLIP_OVERLAPPING_READS=true\"\n+        };\n+        Assert.assertEquals(runPicardCommandLine(\"MergeBamAlignment\", mergeBamAlignmentsArgs), 0);\n+\n+        final File outputRevert = File.createTempFile(\"test-output-hard-clipped-round-trip-reverted\", \".sam\");", "originalCommit": "f4cadcd5d480a2db359aa534fee10ea8135f6f2b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f39e69e289632591a0fb9656158679ee71e7aea0", "chunk": "diff --git a/src/test/java/picard/sam/RevertSamTest.java b/src/test/java/picard/sam/RevertSamTest.java\nindex 78a852407..1f81afb92 100755\n--- a/src/test/java/picard/sam/RevertSamTest.java\n+++ b/src/test/java/picard/sam/RevertSamTest.java\n\n@@ -549,6 +549,7 @@ public class RevertSamTest extends CommandLineProgramTest {\n         // Tests to ensure that RevertSam can reconstruct the reads and base qualities from reads that have been hard clipped.\n \n         final File outputMBA = File.createTempFile(\"test-output-hard-clipped-round-trip-mba\", \".sam\");\n+        outputMBA.deleteOnExit();\n         final String [] mergeBamAlignmentsArgs = new String[] {\n            \"UNMAPPED_BAM=\" + hardClippedUnmappedSam.getAbsolutePath(),\n            \"ALIGNED_BAM=\" + hardClippedAlignedSam.getAbsolutePath(),\n"}}, {"oid": "f2ff19940c20862ff653094c9e76877f5408f541", "url": "https://github.com/broadinstitute/picard/commit/f2ff19940c20862ff653094c9e76877f5408f541", "message": "Merge branch 'master' into ck_hardclip_merge_bam_alignments", "committedDate": "2020-05-12T20:50:03Z", "type": "commit"}, {"oid": "f39e69e289632591a0fb9656158679ee71e7aea0", "url": "https://github.com/broadinstitute/picard/commit/f39e69e289632591a0fb9656158679ee71e7aea0", "message": "Added deleteOnExit to files generated during tests", "committedDate": "2020-05-12T21:20:00Z", "type": "commit"}]}