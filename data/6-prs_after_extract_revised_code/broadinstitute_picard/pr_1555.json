{"pr_number": 1555, "pr_title": "Several changes to metrics collections (AlignmentSummaryMetrics and WgsMetrics) + some fluff", "pr_createdAt": "2020-07-31T21:04:26Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1555", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzA1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464463056", "bodyText": "Is there any reason to not use RuntimeException() here?", "author": "pshapiro4broad", "createdAt": "2020-08-03T14:49:00Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n+            TEMP_OUTPUT_DIR.delete();\n+            TEMP_OUTPUT_DIR.mkdir();\n+        } catch (IOException e) {\n+            throw new PicardException(\"Couldn't create temp directory\") ;", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMjAwOQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465132009", "bodyText": "Well...PicardException is a RuntimeException...but this was it's more clear that it comes from Picard...I don't mind either way....what's the argument for RuntimeException?", "author": "yfarjoun", "createdAt": "2020-08-04T15:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzA1Ng=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n\n@@ -20,24 +15,6 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n-\n-    // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n-        }\n-    }\n-\n-    @AfterClass\n-    final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n-    }\n-\n     public abstract String getCommandLineProgramName();\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NDQyNw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464464427", "bodyText": "This is OK, an improvement would be to make this lazy, as not every test needs to create temp output. E.g.,\nprotected File getTempDir() {\n    if (TEMP_OUTPUT_DIR == null) {\n    ...\n}", "author": "pshapiro4broad", "createdAt": "2020-08-03T14:51:08Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n\n@@ -20,24 +15,6 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n-\n-    // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n-        }\n-    }\n-\n-    @AfterClass\n-    final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n-    }\n-\n     public abstract String getCommandLineProgramName();\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NDQ1Nw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464474457", "bodyText": "Why not\nTEMP_OUTPUT_DIR = Files.createTempDirectory(getClass().getName()).toFile();", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:06:23Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjkyOA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465136928", "bodyText": "\ud83d\udc4d", "author": "yfarjoun", "createdAt": "2020-08-04T15:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NDQ1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/cmdline/CommandLineProgramTest.java b/src/test/java/picard/cmdline/CommandLineProgramTest.java\nindex 5691e51cb..09d2d7578 100644\n--- a/src/test/java/picard/cmdline/CommandLineProgramTest.java\n+++ b/src/test/java/picard/cmdline/CommandLineProgramTest.java\n\n@@ -20,24 +15,6 @@ public abstract class CommandLineProgramTest {\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n-\n-    // A per-test-class directory that will be deleted after the tests are complete.\n-    final protected File TEMP_OUTPUT_DIR;\n-    {\n-        try {\n-            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n-            TEMP_OUTPUT_DIR.delete();\n-            TEMP_OUTPUT_DIR.mkdir();\n-        } catch (IOException e) {\n-            throw new PicardException(\"Couldn't create temp directory\") ;\n-        }\n-    }\n-\n-    @AfterClass\n-    final void cleanup_temp_dir() throws IOException {\n-        FileUtils.deleteDirectory(TEMP_OUTPUT_DIR);\n-    }\n-\n     public abstract String getCommandLineProgramName();\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUwNA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464479504", "bodyText": "It looks like this is a common case. You could add createTempFile to CommandLineProgramTest to avoid some typing.", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:14:45Z", "path": "src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java", "diffHunk": "@@ -51,8 +55,7 @@ public String getCommandLineProgramName() {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n-        outfile.deleteOnExit();\n+        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDk4Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465144986", "bodyText": "not much less typing...but OK.", "author": "yfarjoun", "createdAt": "2020-08-04T15:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex 00864efac..d5e132b3e 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n\n@@ -55,7 +51,8 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);\n+        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n+        outfile.deleteOnExit();\n         final String[] args = new String[]{\n                 \"INPUT=\" + input.getAbsolutePath(),\n                 \"OUTPUT=\" + outfile.getAbsolutePath(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MjMyNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464482326", "bodyText": "unnecessary array new: {{true}, {false}} should work here", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:19:26Z", "path": "src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java", "diffHunk": "@@ -642,4 +645,79 @@ public void testAdapterReads() throws IOException {\n             }\n         }\n     }\n+\n+    @DataProvider()\n+    Object[][] TrueFalse() {\n+        return new Object[][]{\n+                new Object[]{true},", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\nindex 00864efac..d5e132b3e 100644\n--- a/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java\n\n@@ -645,79 +642,4 @@ public class CollectAlignmentSummaryMetricsTest extends CommandLineProgramTest {\n             }\n         }\n     }\n-\n-    @DataProvider()\n-    Object[][] TrueFalse() {\n-        return new Object[][]{\n-                new Object[]{true},\n-                new Object[]{false},\n-        };\n-    }\n-\n-    @Test(dataProvider = \"TrueFalse\")\n-    public void testReadLengthHistogram(final boolean plotChart) throws IOException {\n-        final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test3.sam\");\n-        final File outFile = File.createTempFile(\"testReadLengthHistogram\", \".txt\", TEMP_OUTPUT_DIR);\n-\n-        final List<String> argsList = new ArrayList<>();\n-        argsList.add(\"INPUT=\" + input.getAbsolutePath());\n-        argsList.add(\"OUTPUT=\" + outFile.getAbsolutePath());\n-        final File outHist;\n-\n-        if (plotChart) {\n-            outHist = File.createTempFile(\"testReadLengthHistogram\", \".pdf\", TEMP_OUTPUT_DIR);\n-            argsList.add(\"HISTOGRAM_FILE=\" + outHist);\n-        } else {\n-            outHist = null;\n-        }\n-\n-        final String[] args = argsList.toArray(new String[0]);\n-\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        if (plotChart) {\n-            Assert.assertTrue(outHist.exists());\n-        }\n-\n-        final MetricsFile<AlignmentSummaryMetrics, Integer> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outFile)) {\n-            output.read(reader);\n-        }\n-\n-        Assert.assertFalse(output.getMetrics().isEmpty());\n-        for (final AlignmentSummaryMetrics metrics : output.getMetrics()) {\n-            if (metrics.CATEGORY != AlignmentSummaryMetrics.Category.SECOND_OF_PAIR) {\n-                Assert.assertEquals(metrics.PCT_HARDCLIP, 10 / (double) metrics.PF_ALIGNED_BASES,0.0001);\n-                Assert.assertEquals(metrics.PCT_SOFTCLIP, 23 / (double) metrics.PF_ALIGNED_BASES,0.0001);\n-            } else {\n-                Assert.assertEquals(metrics.PCT_HARDCLIP, 0D);\n-                Assert.assertEquals(metrics.PCT_SOFTCLIP, 0D);\n-            }\n-        }\n-\n-        Assert.assertFalse(output.getAllHistograms().isEmpty());\n-\n-        for (final Histogram<Integer> histogram : output.getAllHistograms()) {\n-\n-            Assert.assertFalse(histogram.isEmpty());\n-            if (histogram.getValueLabel().equals(\"PAIRED_TOTAL_LENGTH_COUNT\")) {\n-                for (int i = 0; i < histogram.getMax(); i++) {\n-                    switch (i) {\n-                        case 1:\n-                        case 2:\n-                        case 10:\n-                        case 11:\n-                        case 42:\n-                            Assert.assertEquals(histogram.get(i).getValue(), 1D);\n-                            break;\n-                        default:\n-                            Assert.assertTrue(\n-                                    histogram.get(i) == null ||\n-                                            histogram.get(i).getValue() == 0D);\n-                            break;\n-                    }\n-                }\n-            }\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjMwMw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464486303", "bodyText": "unnecessary array creation\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = new String[] {\n          \n          \n            \n                    final String[] args = {", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:25:33Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -239,10 +300,49 @@ public void testLargeIntervals(final String useFastAlgorithm) throws IOException\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final String reference_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File ref = new File(reference_name);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[] {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjEwNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465146106", "bodyText": "\ud83e\udd2f", "author": "yfarjoun", "createdAt": "2020-08-04T15:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjMwMw=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n\n@@ -300,49 +239,10 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         }\n     }\n \n-    @Test(dataProvider = \"wgsDataProvider\")\n-    public void testSmallIntervals(final File input, final String reference_name,\n-                                   final String useFastAlgorithm) throws IOException {\n-        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n-        final File ref = new File(reference_name);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[] {\n-                \"INPUT=\" + input.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                // the fast and regular algorithms differ in how the cap coverage, so in order to avoid getting different result\n-                // due to that, the coverage cap is raise high for this test.\n-                \"COVERAGE_CAP=\" + 40000,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.0);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, 1727.6, .1);\n-            Assert.assertEquals(metrics.SD_COVERAGE, 695.68, 0.1);\n-            Assert.assertEquals(metrics.FOLD_80_BASE_PENALTY, 1.59, 0.01);\n-            Assert.assertEquals(metrics.FOLD_90_BASE_PENALTY, 3.36, 0.01);\n-            Assert.assertTrue(Double.isNaN(metrics.FOLD_95_BASE_PENALTY));\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n-        final File reference = new File(TEST_DIR, \"merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n+        final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectWgsMetrics\", \".bam\");\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjcwNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464486706", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n          \n          \n            \n                    final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\", TEMP_OUTPUT_DIR);", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:26:08Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -239,10 +300,49 @@ public void testLargeIntervals(final String useFastAlgorithm) throws IOException\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final String reference_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n\n@@ -300,49 +239,10 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         }\n     }\n \n-    @Test(dataProvider = \"wgsDataProvider\")\n-    public void testSmallIntervals(final File input, final String reference_name,\n-                                   final String useFastAlgorithm) throws IOException {\n-        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n-        final File ref = new File(reference_name);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[] {\n-                \"INPUT=\" + input.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                // the fast and regular algorithms differ in how the cap coverage, so in order to avoid getting different result\n-                // due to that, the coverage cap is raise high for this test.\n-                \"COVERAGE_CAP=\" + 40000,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0.0);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0.0);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, 1727.6, .1);\n-            Assert.assertEquals(metrics.SD_COVERAGE, 695.68, 0.1);\n-            Assert.assertEquals(metrics.FOLD_80_BASE_PENALTY, 1.59, 0.01);\n-            Assert.assertEquals(metrics.FOLD_90_BASE_PENALTY, 3.36, 0.01);\n-            Assert.assertTrue(Double.isNaN(metrics.FOLD_95_BASE_PENALTY));\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testExclusions(final String useFastAlgorithm) throws IOException {\n-        final File reference = new File(TEST_DIR, \"merger.fasta\");\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testExclusions\", \".bam\", TEMP_OUTPUT_DIR);\n+        final File reference = new File(\"testdata/picard/sam/merger.fasta\");\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"CollectWgsMetrics\", \".bam\");\n \n         final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(reference, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NzcxMw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464487713", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n          \n          \n            \n                    setBuilder.addPair(\"all_in\", 0, 200, 200, false, false, \"100M\", \"100M\", true, false, 30);", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:27:37Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -208,11 +214,66 @@ void setupBuilder() throws IOException {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n\n@@ -214,66 +208,11 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         };\n     }\n \n-    @Test(dataProvider = \"wgsAlgorithm\")\n-    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n-\n-        final File ref = CHR_M_REFERENCE;\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n-\n-        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n-\n-        setBuilder.setReadLength(100);\n-\n-        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n-\n-        final SamReader samReader = setBuilder.getSamReader();\n-\n-        // Write SAM file\n-        try (SAMFileWriter writer = new SAMFileWriterFactory()\n-                .setCreateIndex(true)\n-                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n-            for (final SAMRecord record : samReader) {\n-                writer.addAlignment(record);\n-            }\n-        }\n-\n-        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[]{\n-                \"INPUT=\" + tempSamFile.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0D);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, .152);\n-            Assert.assertEquals(metrics.SD_COVERAGE, .361977);\n-            Assert.assertEquals(metrics.PCT_1X, .151);\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n+        outfile.deleteOnExit();\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4ODY5MA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464488690", "bodyText": "unnecessary new\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = new String[]{\n          \n          \n            \n                    final String[] args = {", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:29:07Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -208,11 +214,66 @@ void setupBuilder() throws IOException {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n+\n+        final SamReader samReader = setBuilder.getSamReader();\n+\n+        // Write SAM file\n+        try (SAMFileWriter writer = new SAMFileWriterFactory()\n+                .setCreateIndex(true)\n+                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n+            for (final SAMRecord record : samReader) {\n+                writer.addAlignment(record);\n+            }\n+        }\n+\n+        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectWgsMetricsTest.java b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\nindex 195ff9465..e75d12191 100644\n--- a/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectWgsMetricsTest.java\n\n@@ -214,66 +208,11 @@ public class CollectWgsMetricsTest extends CommandLineProgramTest {\n         };\n     }\n \n-    @Test(dataProvider = \"wgsAlgorithm\")\n-    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n-\n-        final File ref = CHR_M_REFERENCE;\n-        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n-\n-        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n-\n-        setBuilder.setReadLength(100);\n-\n-        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n-        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n-\n-        final SamReader samReader = setBuilder.getSamReader();\n-\n-        // Write SAM file\n-        try (SAMFileWriter writer = new SAMFileWriterFactory()\n-                .setCreateIndex(true)\n-                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n-            for (final SAMRecord record : samReader) {\n-                writer.addAlignment(record);\n-            }\n-        }\n-\n-        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n-        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n-        final int sampleSize = 1000;\n-        final String[] args = new String[]{\n-                \"INPUT=\" + tempSamFile.getAbsolutePath(),\n-                \"OUTPUT=\" + outfile.getAbsolutePath(),\n-                \"REFERENCE_SEQUENCE=\" + ref.getAbsolutePath(),\n-                \"INTERVALS=\" + intervals.getAbsolutePath(),\n-                \"SAMPLE_SIZE=\" + sampleSize,\n-                \"USE_FAST_ALGORITHM=\" + useFastAlgorithm\n-        };\n-        Assert.assertEquals(runPicardCommandLine(args), 0);\n-\n-        final MetricsFile<WgsMetrics, Comparable<?>> output = new MetricsFile<>();\n-        try (FileReader reader = new FileReader(outfile)) {\n-            output.read(reader);\n-        }\n-        for (final WgsMetrics metrics : output.getMetrics()) {\n-            Assert.assertEquals(metrics.GENOME_TERRITORY, 1000);\n-            Assert.assertEquals(metrics.PCT_EXC_ADAPTER, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_MAPQ, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_DUPE, 0D);\n-            Assert.assertEquals(metrics.PCT_EXC_UNPAIRED, 0D);\n-            Assert.assertEquals(metrics.MEAN_COVERAGE, .152);\n-            Assert.assertEquals(metrics.SD_COVERAGE, .361977);\n-            Assert.assertEquals(metrics.PCT_1X, .151);\n-        }\n-    }\n-\n-\n     @Test(dataProvider = \"wgsAlgorithm\")\n     public void testLargeIntervals(final String useFastAlgorithm) throws IOException {\n         final File input = new File(TEST_DIR, \"forMetrics.sam\");\n-        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File outfile = File.createTempFile(\"test\", \".wgs_metrics\");\n+        outfile.deleteOnExit();\n         final File ref = new File(TEST_DIR, \"merger.fasta\");\n         final File intervals = new File(TEST_DIR, \"largeIntervals.interval_list\");\n         final int sampleSize = 1000;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MTQwNw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464491407", "bodyText": "This seems like it could lead to problems, if someone changed the file while editing the other test but didn't realize the file was used here as well. If you made a separate constant for each file shared like this (e.g., build the path to the file in CollectAlignmentSummaryMetricsTest as a constant), that would at least make it easier to find other tests that depended on that file.", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:33:19Z", "path": "src/test/java/picard/analysis/CollectOxoGMetricsTest.java", "diffHunk": "@@ -12,7 +12,7 @@\n \n public class CollectOxoGMetricsTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/\");\n-    private static final File SAM_FILE = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n+    private static final File SAM_FILE = new File(CollectAlignmentSummaryMetricsTest.TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODY3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465148673", "bodyText": "This is no different than what it was (regarding someone changing the file) but at least now there's a variable that is traced to where it's being used...I fail to see how building the path from scratch helps...I moved the files into a subdirectory and suddenly other tests started failing....with this construction it will not happen...", "author": "yfarjoun", "createdAt": "2020-08-04T15:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MTQwNw=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/test/java/picard/analysis/CollectOxoGMetricsTest.java b/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\nindex 87fe9da77..c39504cea 100644\n--- a/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\n+++ b/src/test/java/picard/analysis/CollectOxoGMetricsTest.java\n\n@@ -12,7 +12,7 @@ import java.util.HashSet;\n \n public class CollectOxoGMetricsTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/\");\n-    private static final File SAM_FILE = new File(CollectAlignmentSummaryMetricsTest.TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n+    private static final File SAM_FILE = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n     private static final File REFERENCE_SEQUENCE = new File(TEST_DATA_DIR, \"merger.fasta\");\n \n     @Test\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464492774", "bodyText": "Why remove this null check? If this is null, it will cause TheoreticalSensitivity.normalizeHistogram to throw a PicardException.", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:35:39Z", "path": "src/main/java/picard/analysis/WgsMetrics.java", "diffHunk": "@@ -290,23 +302,35 @@ public void calculateDerivedFields() {\n         MEDIAN_COVERAGE  = highQualityDepthHistogram.getMedian();\n         MAD_COVERAGE     = highQualityDepthHistogram.getMedianAbsoluteDeviation();\n \n-        PCT_1X    = MathUtil.sum(depthHistogramArray, 1, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n-        PCT_5X    = MathUtil.sum(depthHistogramArray, 5, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n-        PCT_10X   = MathUtil.sum(depthHistogramArray, 10, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_15X   = MathUtil.sum(depthHistogramArray, 15, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_20X   = MathUtil.sum(depthHistogramArray, 20, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_25X   = MathUtil.sum(depthHistogramArray, 25, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_30X   = MathUtil.sum(depthHistogramArray, 30, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_40X   = MathUtil.sum(depthHistogramArray, 40, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_50X   = MathUtil.sum(depthHistogramArray, 50, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_60X   = MathUtil.sum(depthHistogramArray, 60, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_70X   = MathUtil.sum(depthHistogramArray, 70, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_80X   = MathUtil.sum(depthHistogramArray, 80, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_90X   = MathUtil.sum(depthHistogramArray, 90, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_100X  = MathUtil.sum(depthHistogramArray, 100, depthHistogramArray.length) / (double) GENOME_TERRITORY;\n+        PCT_1X   = MathUtil.sum(depthHistogramArray, 1, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n+        PCT_5X   = MathUtil.sum(depthHistogramArray, 5, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n+        PCT_10X  = MathUtil.sum(depthHistogramArray, 10, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_15X  = MathUtil.sum(depthHistogramArray, 15, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_20X  = MathUtil.sum(depthHistogramArray, 20, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_25X  = MathUtil.sum(depthHistogramArray, 25, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_30X  = MathUtil.sum(depthHistogramArray, 30, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_40X  = MathUtil.sum(depthHistogramArray, 40, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_50X  = MathUtil.sum(depthHistogramArray, 50, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_60X  = MathUtil.sum(depthHistogramArray, 60, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_70X  = MathUtil.sum(depthHistogramArray, 70, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_80X  = MathUtil.sum(depthHistogramArray, 80, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_90X  = MathUtil.sum(depthHistogramArray, 90, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_100X = MathUtil.sum(depthHistogramArray, 100, depthHistogramArray.length) / (double) GENOME_TERRITORY;\n+\n+\n+        // This roughly measures by how much we must over-sequence so that xx% of bases have coverage at least as deep as the current mean coverage:\n+        if (highQualityDepthHistogram.getCount() > 0) {\n+            FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n+            FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n+            FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n+        } else {\n+            FOLD_80_BASE_PENALTY = 0;\n+            FOLD_90_BASE_PENALTY = 0;\n+            FOLD_95_BASE_PENALTY = 0;\n+        }\n \n         // Get Theoretical Het SNP Sensitivity\n-        if (unfilteredBaseQHistogram != null && unfilteredDepthHistogram != null) {\n+        if (unfilteredBaseQHistogram != null) {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTUyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465149521", "bodyText": "", "author": "yfarjoun", "createdAt": "2020-08-04T15:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTk1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465149956", "bodyText": "already checked in the first line of test", "author": "yfarjoun", "createdAt": "2020-08-04T15:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/WgsMetrics.java b/src/main/java/picard/analysis/WgsMetrics.java\nindex a6e6296ed..06732655b 100644\n--- a/src/main/java/picard/analysis/WgsMetrics.java\n+++ b/src/main/java/picard/analysis/WgsMetrics.java\n\n@@ -319,15 +319,9 @@ public class WgsMetrics extends MergeableMetricBase {\n \n \n         // This roughly measures by how much we must over-sequence so that xx% of bases have coverage at least as deep as the current mean coverage:\n-        if (highQualityDepthHistogram.getCount() > 0) {\n-            FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n-            FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n-            FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n-        } else {\n-            FOLD_80_BASE_PENALTY = 0;\n-            FOLD_90_BASE_PENALTY = 0;\n-            FOLD_95_BASE_PENALTY = 0;\n-        }\n+        FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n+        FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n+        FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n \n         // Get Theoretical Het SNP Sensitivity\n         if (unfilteredBaseQHistogram != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTcxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464581711", "bodyText": "= 0 initializers unnecessary", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:13:57Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 89a9f8e63..f4a128ace 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n\n@@ -104,206 +103,148 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n+            final SAMRecord rec         = args.getSamRecord();\n+            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (args.getSamRecord().getReadPairedFlag()) {\n-                if (args.getSamRecord().getFirstOfPairFlag()) {\n-                    firstOfPairCollector.acceptRecord(args);\n+            if (rec.getReadPairedFlag()) {\n+                if (rec.getFirstOfPairFlag()) {\n+                    firstOfPairCollector.addRecord(rec, ref);\n                 } else {\n-                    secondOfPairCollector.acceptRecord(args);\n+                    secondOfPairCollector.addRecord(rec, ref);\n                 }\n \n-                pairCollector.acceptRecord(args);\n+                pairCollector.addRecord(rec, ref);\n             } else {\n-                unpairedCollector.acceptRecord(args);\n+                unpairedCollector.addRecord(rec, ref);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.finish();\n-            firstOfPairCollector.finish();\n-            secondOfPairCollector.finish();\n-            pairCollector.finish();\n+            unpairedCollector.onComplete();\n+            firstOfPairCollector.onComplete();\n+            secondOfPairCollector.onComplete();\n+            pairCollector.onComplete();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                firstOfPairCollector.addMetricsToFile(file);\n-                secondOfPairCollector.addMetricsToFile(file);\n-                pairCollector.addMetricsToFile(file);\n+                file.addMetric(firstOfPairCollector.getMetrics());\n+                file.addMetric(secondOfPairCollector.getMetrics());\n+                file.addMetric(pairCollector.getMetrics());\n             }\n \n-            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                unpairedCollector.addMetricsToFile(file);\n+                file.addMetric(unpairedCollector.getMetrics());\n             }\n         }\n-    }\n-\n-    /**\n-     * Class that counts reads that match various conditions\n-     */\n-    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n-        private long numPositiveStrand = 0;\n-        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n-        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n-\n-        private AlignmentSummaryMetrics metrics;\n-        private long chimeras;\n-        private long chimerasDenominator;\n-        private long adapterReads;\n-        private long indels;\n-\n-        private long numSoftClipped;\n-        private long numHardClipped;\n-\n-        private long nonBisulfiteAlignedBases = 0;\n-        private long hqNonBisulfiteAlignedBases = 0;\n-        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                          final String sample,\n-                                                          final String library,\n-                                                          final String readGroup) {\n-            metrics = new AlignmentSummaryMetrics();\n-            metrics.CATEGORY = pairingCategory;\n-            metrics.SAMPLE = sample;\n-            metrics.LIBRARY = library;\n-            metrics.READ_GROUP = readGroup;\n-        }\n \n-        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n-            final SAMRecord record = samRecordAndReference.getSamRecord();\n-            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n-\n-            if (record.isSecondaryAlignment()) {\n-                // only want 1 count per read so skip non-primary alignments\n-                return;\n+        /**\n+         * Class that counts reads that match various conditions\n+         */\n+        private class IndividualAlignmentSummaryMetricsCollector {\n+            private long numPositiveStrand = 0;\n+            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n+            private AlignmentSummaryMetrics metrics;\n+            private long chimeras;\n+            private long chimerasDenominator;\n+            private long adapterReads;\n+            private long indels;\n+\n+            private long nonBisulfiteAlignedBases = 0;\n+            private long hqNonBisulfiteAlignedBases = 0;\n+            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                              final String sample,\n+                                                              final String library,\n+                                                              final String readGroup) {\n+                metrics = new AlignmentSummaryMetrics();\n+                metrics.CATEGORY = pairingCategory;\n+                metrics.SAMPLE = sample;\n+                metrics.LIBRARY = library;\n+                metrics.READ_GROUP = readGroup;\n             }\n \n-            collectReadData(record);\n-            collectQualityData(record, ref);\n-        }\n-\n-        @Override\n-        public void finish() {\n-            //summarize read data\n-            if (metrics.TOTAL_READS > 0) {\n-                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                //Calculate BAD_CYCLES\n-                metrics.BAD_CYCLES = 0;\n-                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                    if (badCyclePercentage >= 0.8) {\n-                        metrics.BAD_CYCLES++;\n-                    }\n+            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n+                if (record.getNotPrimaryAlignmentFlag()) {\n+                    // only want 1 count per read so skip non primary alignments\n+                    return;\n                 }\n \n-                if (doRefMetrics) {\n-                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                    metrics.PCT_HARDCLIP = this.numHardClipped / (double) metrics.PF_ALIGNED_BASES;\n-                    metrics.PCT_SOFTCLIP = this.numSoftClipped / (double) metrics.PF_ALIGNED_BASES;\n-\n-                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n-                }\n+                collectReadData(record);\n+                collectQualityData(record, ref);\n             }\n-        }\n-\n-        @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n-            file.addMetric(metrics);\n-        }\n \n-        /**\n-         * returns The number of read bases that are not clipped, from the cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @return Number of read bases that are not clipped\n-         */\n-        private int getUnclippedBaseCount(final Cigar cigar) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().consumesReadBases())\n-                    .filter(e -> !e.getOperator().isClipping())\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n-\n-        /**\n-         * returns The sum of lengths of a particular cigar operator in the provided cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @param op The operator that is being looked for\n-         * @return Sum of lengths of the Cigar elements in cigar that are of the operator op\n-         */\n-        private int getTotalCigarOperatorCount(final Cigar cigar, final CigarOperator op) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().equals(op))\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n+            public void onComplete() {\n+                //summarize read data\n+                if (metrics.TOTAL_READS > 0)\n+                {\n+                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                    //Calculate BAD_CYCLES\n+                    metrics.BAD_CYCLES = 0;\n+                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                        if (badCyclePercentage >= 0.8) {\n+                            metrics.BAD_CYCLES++;\n+                        }\n+                    }\n \n-        private void collectReadData(final SAMRecord record) {\n-            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-            if (record.getSupplementaryAlignmentFlag()) {\n-                return;\n+                    if(doRefMetrics) {\n+                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                    }\n+                }\n             }\n \n-            metrics.TOTAL_READS++;\n-\n-            if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                metrics.PF_READS++;\n-                if (isNoiseRead(record)) {\n-                    metrics.PF_NOISE_READS++;\n-                }\n+            private void collectReadData(final SAMRecord record) {\n+                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+                if (record.getSupplementaryAlignmentFlag()) return;\n \n+                metrics.TOTAL_READS++;\n                 readLengthHistogram.increment(record.getReadBases().length);\n-                alignedReadLengthHistogram.increment(getUnclippedBaseCount(record.getCigar()));\n \n-                // See if the read is an adapter sequence\n-                if (adapterUtility.isAdapter(record)) {\n-                    this.adapterReads++;\n-                }\n-                // count clipped bases\n-                numHardClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.HARD_CLIP);\n+                if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                    metrics.PF_READS++;\n+                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n \n-                if (!record.getReadUnmappedFlag()) {\n-                    numSoftClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.SOFT_CLIP);\n-                    if (doRefMetrics) {\n+                    // See if the read is an adapter sequence\n+                    if (adapterUtility.isAdapter(record)) {\n+                        this.adapterReads++;\n+                    }\n \n+                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n                         metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n-                            metrics.PF_READS_IMPROPER_PAIRS++;\n-                        }\n-                        if (!record.getReadNegativeStrandFlag()) {\n-                            numPositiveStrand++;\n-                        }\n+                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n+                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n                         if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n                             metrics.READS_ALIGNED_IN_PAIRS++;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTc5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464581791", "bodyText": "can be final, I think", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:14:08Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 89a9f8e63..f4a128ace 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n\n@@ -104,206 +103,148 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n+            final SAMRecord rec         = args.getSamRecord();\n+            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (args.getSamRecord().getReadPairedFlag()) {\n-                if (args.getSamRecord().getFirstOfPairFlag()) {\n-                    firstOfPairCollector.acceptRecord(args);\n+            if (rec.getReadPairedFlag()) {\n+                if (rec.getFirstOfPairFlag()) {\n+                    firstOfPairCollector.addRecord(rec, ref);\n                 } else {\n-                    secondOfPairCollector.acceptRecord(args);\n+                    secondOfPairCollector.addRecord(rec, ref);\n                 }\n \n-                pairCollector.acceptRecord(args);\n+                pairCollector.addRecord(rec, ref);\n             } else {\n-                unpairedCollector.acceptRecord(args);\n+                unpairedCollector.addRecord(rec, ref);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.finish();\n-            firstOfPairCollector.finish();\n-            secondOfPairCollector.finish();\n-            pairCollector.finish();\n+            unpairedCollector.onComplete();\n+            firstOfPairCollector.onComplete();\n+            secondOfPairCollector.onComplete();\n+            pairCollector.onComplete();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                firstOfPairCollector.addMetricsToFile(file);\n-                secondOfPairCollector.addMetricsToFile(file);\n-                pairCollector.addMetricsToFile(file);\n+                file.addMetric(firstOfPairCollector.getMetrics());\n+                file.addMetric(secondOfPairCollector.getMetrics());\n+                file.addMetric(pairCollector.getMetrics());\n             }\n \n-            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                unpairedCollector.addMetricsToFile(file);\n+                file.addMetric(unpairedCollector.getMetrics());\n             }\n         }\n-    }\n-\n-    /**\n-     * Class that counts reads that match various conditions\n-     */\n-    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n-        private long numPositiveStrand = 0;\n-        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n-        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n-\n-        private AlignmentSummaryMetrics metrics;\n-        private long chimeras;\n-        private long chimerasDenominator;\n-        private long adapterReads;\n-        private long indels;\n-\n-        private long numSoftClipped;\n-        private long numHardClipped;\n-\n-        private long nonBisulfiteAlignedBases = 0;\n-        private long hqNonBisulfiteAlignedBases = 0;\n-        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                          final String sample,\n-                                                          final String library,\n-                                                          final String readGroup) {\n-            metrics = new AlignmentSummaryMetrics();\n-            metrics.CATEGORY = pairingCategory;\n-            metrics.SAMPLE = sample;\n-            metrics.LIBRARY = library;\n-            metrics.READ_GROUP = readGroup;\n-        }\n \n-        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n-            final SAMRecord record = samRecordAndReference.getSamRecord();\n-            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n-\n-            if (record.isSecondaryAlignment()) {\n-                // only want 1 count per read so skip non-primary alignments\n-                return;\n+        /**\n+         * Class that counts reads that match various conditions\n+         */\n+        private class IndividualAlignmentSummaryMetricsCollector {\n+            private long numPositiveStrand = 0;\n+            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n+            private AlignmentSummaryMetrics metrics;\n+            private long chimeras;\n+            private long chimerasDenominator;\n+            private long adapterReads;\n+            private long indels;\n+\n+            private long nonBisulfiteAlignedBases = 0;\n+            private long hqNonBisulfiteAlignedBases = 0;\n+            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                              final String sample,\n+                                                              final String library,\n+                                                              final String readGroup) {\n+                metrics = new AlignmentSummaryMetrics();\n+                metrics.CATEGORY = pairingCategory;\n+                metrics.SAMPLE = sample;\n+                metrics.LIBRARY = library;\n+                metrics.READ_GROUP = readGroup;\n             }\n \n-            collectReadData(record);\n-            collectQualityData(record, ref);\n-        }\n-\n-        @Override\n-        public void finish() {\n-            //summarize read data\n-            if (metrics.TOTAL_READS > 0) {\n-                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                //Calculate BAD_CYCLES\n-                metrics.BAD_CYCLES = 0;\n-                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                    if (badCyclePercentage >= 0.8) {\n-                        metrics.BAD_CYCLES++;\n-                    }\n+            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n+                if (record.getNotPrimaryAlignmentFlag()) {\n+                    // only want 1 count per read so skip non primary alignments\n+                    return;\n                 }\n \n-                if (doRefMetrics) {\n-                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                    metrics.PCT_HARDCLIP = this.numHardClipped / (double) metrics.PF_ALIGNED_BASES;\n-                    metrics.PCT_SOFTCLIP = this.numSoftClipped / (double) metrics.PF_ALIGNED_BASES;\n-\n-                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n-                }\n+                collectReadData(record);\n+                collectQualityData(record, ref);\n             }\n-        }\n-\n-        @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n-            file.addMetric(metrics);\n-        }\n \n-        /**\n-         * returns The number of read bases that are not clipped, from the cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @return Number of read bases that are not clipped\n-         */\n-        private int getUnclippedBaseCount(final Cigar cigar) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().consumesReadBases())\n-                    .filter(e -> !e.getOperator().isClipping())\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n-\n-        /**\n-         * returns The sum of lengths of a particular cigar operator in the provided cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @param op The operator that is being looked for\n-         * @return Sum of lengths of the Cigar elements in cigar that are of the operator op\n-         */\n-        private int getTotalCigarOperatorCount(final Cigar cigar, final CigarOperator op) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().equals(op))\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n+            public void onComplete() {\n+                //summarize read data\n+                if (metrics.TOTAL_READS > 0)\n+                {\n+                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                    //Calculate BAD_CYCLES\n+                    metrics.BAD_CYCLES = 0;\n+                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                        if (badCyclePercentage >= 0.8) {\n+                            metrics.BAD_CYCLES++;\n+                        }\n+                    }\n \n-        private void collectReadData(final SAMRecord record) {\n-            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-            if (record.getSupplementaryAlignmentFlag()) {\n-                return;\n+                    if(doRefMetrics) {\n+                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                    }\n+                }\n             }\n \n-            metrics.TOTAL_READS++;\n-\n-            if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                metrics.PF_READS++;\n-                if (isNoiseRead(record)) {\n-                    metrics.PF_NOISE_READS++;\n-                }\n+            private void collectReadData(final SAMRecord record) {\n+                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+                if (record.getSupplementaryAlignmentFlag()) return;\n \n+                metrics.TOTAL_READS++;\n                 readLengthHistogram.increment(record.getReadBases().length);\n-                alignedReadLengthHistogram.increment(getUnclippedBaseCount(record.getCigar()));\n \n-                // See if the read is an adapter sequence\n-                if (adapterUtility.isAdapter(record)) {\n-                    this.adapterReads++;\n-                }\n-                // count clipped bases\n-                numHardClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.HARD_CLIP);\n+                if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                    metrics.PF_READS++;\n+                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n \n-                if (!record.getReadUnmappedFlag()) {\n-                    numSoftClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.SOFT_CLIP);\n-                    if (doRefMetrics) {\n+                    // See if the read is an adapter sequence\n+                    if (adapterUtility.isAdapter(record)) {\n+                        this.adapterReads++;\n+                    }\n \n+                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n                         metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n-                            metrics.PF_READS_IMPROPER_PAIRS++;\n-                        }\n-                        if (!record.getReadNegativeStrandFlag()) {\n-                            numPositiveStrand++;\n-                        }\n+                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n+                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n                         if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n                             metrics.READS_ALIGNED_IN_PAIRS++;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MzU5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464583593", "bodyText": "I wouldn't normally comment on this. but the code is inconsistent in its use. Why do these use this. but no other fields do? I think it would be better to omit them completely unless necessary for disambiguation purposes.", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:17:41Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;\n+        private long chimeras;\n+        private long chimerasDenominator;\n+        private long adapterReads;\n+        private long indels;\n+\n+        private long numSoftClipped;\n+        private long numHardClipped;\n+\n+        private long nonBisulfiteAlignedBases = 0;\n+        private long hqNonBisulfiteAlignedBases = 0;\n+        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                          final String sample,\n+                                                          final String library,\n+                                                          final String readGroup) {\n+            metrics = new AlignmentSummaryMetrics();\n+            metrics.CATEGORY = pairingCategory;\n+            metrics.SAMPLE = sample;\n+            metrics.LIBRARY = library;\n+            metrics.READ_GROUP = readGroup;\n+        }\n \n-            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n-                if (record.getNotPrimaryAlignmentFlag()) {\n-                    // only want 1 count per read so skip non primary alignments\n-                    return;\n-                }\n+        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n+            final SAMRecord record = samRecordAndReference.getSamRecord();\n+            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n \n-                collectReadData(record);\n-                collectQualityData(record, ref);\n+            if (record.isSecondaryAlignment()) {\n+                // only want 1 count per read so skip non-primary alignments\n+                return;\n             }\n \n-            public void onComplete() {\n-                //summarize read data\n-                if (metrics.TOTAL_READS > 0)\n-                {\n-                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                    //Calculate BAD_CYCLES\n-                    metrics.BAD_CYCLES = 0;\n-                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                        if (badCyclePercentage >= 0.8) {\n-                            metrics.BAD_CYCLES++;\n-                        }\n-                    }\n+            collectReadData(record);\n+            collectQualityData(record, ref);\n+        }\n \n-                    if(doRefMetrics) {\n-                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+        @Override\n+        public void finish() {\n+            //summarize read data\n+            if (metrics.TOTAL_READS > 0) {\n+                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                //Calculate BAD_CYCLES\n+                metrics.BAD_CYCLES = 0;\n+                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                    if (badCyclePercentage >= 0.8) {\n+                        metrics.BAD_CYCLES++;\n                     }\n                 }\n+\n+                if (doRefMetrics) {\n+                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\nindex 89a9f8e63..f4a128ace 100644\n--- a/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n+++ b/src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java\n\n@@ -104,206 +103,148 @@ public class AlignmentSummaryMetricsCollector extends SAMRecordAndReferenceMulti\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n+            final SAMRecord rec         = args.getSamRecord();\n+            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (args.getSamRecord().getReadPairedFlag()) {\n-                if (args.getSamRecord().getFirstOfPairFlag()) {\n-                    firstOfPairCollector.acceptRecord(args);\n+            if (rec.getReadPairedFlag()) {\n+                if (rec.getFirstOfPairFlag()) {\n+                    firstOfPairCollector.addRecord(rec, ref);\n                 } else {\n-                    secondOfPairCollector.acceptRecord(args);\n+                    secondOfPairCollector.addRecord(rec, ref);\n                 }\n \n-                pairCollector.acceptRecord(args);\n+                pairCollector.addRecord(rec, ref);\n             } else {\n-                unpairedCollector.acceptRecord(args);\n+                unpairedCollector.addRecord(rec, ref);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.finish();\n-            firstOfPairCollector.finish();\n-            secondOfPairCollector.finish();\n-            pairCollector.finish();\n+            unpairedCollector.onComplete();\n+            firstOfPairCollector.onComplete();\n+            secondOfPairCollector.onComplete();\n+            pairCollector.onComplete();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                firstOfPairCollector.addMetricsToFile(file);\n-                secondOfPairCollector.addMetricsToFile(file);\n-                pairCollector.addMetricsToFile(file);\n+                file.addMetric(firstOfPairCollector.getMetrics());\n+                file.addMetric(secondOfPairCollector.getMetrics());\n+                file.addMetric(pairCollector.getMetrics());\n             }\n \n-            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                unpairedCollector.addMetricsToFile(file);\n+                file.addMetric(unpairedCollector.getMetrics());\n             }\n         }\n-    }\n-\n-    /**\n-     * Class that counts reads that match various conditions\n-     */\n-    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n-        private long numPositiveStrand = 0;\n-        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n-        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n-\n-        private AlignmentSummaryMetrics metrics;\n-        private long chimeras;\n-        private long chimerasDenominator;\n-        private long adapterReads;\n-        private long indels;\n-\n-        private long numSoftClipped;\n-        private long numHardClipped;\n-\n-        private long nonBisulfiteAlignedBases = 0;\n-        private long hqNonBisulfiteAlignedBases = 0;\n-        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                          final String sample,\n-                                                          final String library,\n-                                                          final String readGroup) {\n-            metrics = new AlignmentSummaryMetrics();\n-            metrics.CATEGORY = pairingCategory;\n-            metrics.SAMPLE = sample;\n-            metrics.LIBRARY = library;\n-            metrics.READ_GROUP = readGroup;\n-        }\n \n-        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n-            final SAMRecord record = samRecordAndReference.getSamRecord();\n-            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n-\n-            if (record.isSecondaryAlignment()) {\n-                // only want 1 count per read so skip non-primary alignments\n-                return;\n+        /**\n+         * Class that counts reads that match various conditions\n+         */\n+        private class IndividualAlignmentSummaryMetricsCollector {\n+            private long numPositiveStrand = 0;\n+            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n+            private AlignmentSummaryMetrics metrics;\n+            private long chimeras;\n+            private long chimerasDenominator;\n+            private long adapterReads;\n+            private long indels;\n+\n+            private long nonBisulfiteAlignedBases = 0;\n+            private long hqNonBisulfiteAlignedBases = 0;\n+            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                              final String sample,\n+                                                              final String library,\n+                                                              final String readGroup) {\n+                metrics = new AlignmentSummaryMetrics();\n+                metrics.CATEGORY = pairingCategory;\n+                metrics.SAMPLE = sample;\n+                metrics.LIBRARY = library;\n+                metrics.READ_GROUP = readGroup;\n             }\n \n-            collectReadData(record);\n-            collectQualityData(record, ref);\n-        }\n-\n-        @Override\n-        public void finish() {\n-            //summarize read data\n-            if (metrics.TOTAL_READS > 0) {\n-                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                //Calculate BAD_CYCLES\n-                metrics.BAD_CYCLES = 0;\n-                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                    if (badCyclePercentage >= 0.8) {\n-                        metrics.BAD_CYCLES++;\n-                    }\n+            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n+                if (record.getNotPrimaryAlignmentFlag()) {\n+                    // only want 1 count per read so skip non primary alignments\n+                    return;\n                 }\n \n-                if (doRefMetrics) {\n-                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                    metrics.PF_INDEL_RATE = MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                    metrics.PF_MISMATCH_RATE = MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                    metrics.PF_HQ_ERROR_RATE = MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                    metrics.PCT_HARDCLIP = this.numHardClipped / (double) metrics.PF_ALIGNED_BASES;\n-                    metrics.PCT_SOFTCLIP = this.numSoftClipped / (double) metrics.PF_ALIGNED_BASES;\n-\n-                    metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n-                }\n+                collectReadData(record);\n+                collectQualityData(record, ref);\n             }\n-        }\n-\n-        @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n-            file.addMetric(metrics);\n-        }\n \n-        /**\n-         * returns The number of read bases that are not clipped, from the cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @return Number of read bases that are not clipped\n-         */\n-        private int getUnclippedBaseCount(final Cigar cigar) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().consumesReadBases())\n-                    .filter(e -> !e.getOperator().isClipping())\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n-\n-        /**\n-         * returns The sum of lengths of a particular cigar operator in the provided cigar\n-         *\n-         * @param cigar The input Cigar of the read\n-         * @param op The operator that is being looked for\n-         * @return Sum of lengths of the Cigar elements in cigar that are of the operator op\n-         */\n-        private int getTotalCigarOperatorCount(final Cigar cigar, final CigarOperator op) {\n-            return cigar.getCigarElements().stream()\n-                    .filter(e -> e.getOperator().equals(op))\n-                    .mapToInt(CigarElement::getLength)\n-                    .reduce(Integer::sum).orElse(0);\n-        }\n+            public void onComplete() {\n+                //summarize read data\n+                if (metrics.TOTAL_READS > 0)\n+                {\n+                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                    //Calculate BAD_CYCLES\n+                    metrics.BAD_CYCLES = 0;\n+                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                        if (badCyclePercentage >= 0.8) {\n+                            metrics.BAD_CYCLES++;\n+                        }\n+                    }\n \n-        private void collectReadData(final SAMRecord record) {\n-            // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n-            if (record.getSupplementaryAlignmentFlag()) {\n-                return;\n+                    if(doRefMetrics) {\n+                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n+                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n+                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n+                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n+\n+                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+                    }\n+                }\n             }\n \n-            metrics.TOTAL_READS++;\n-\n-            if (!record.getReadFailsVendorQualityCheckFlag()) {\n-                metrics.PF_READS++;\n-                if (isNoiseRead(record)) {\n-                    metrics.PF_NOISE_READS++;\n-                }\n+            private void collectReadData(final SAMRecord record) {\n+                // NB: for read count metrics, do not include supplementary records, but for base count metrics, do include supplementary records.\n+                if (record.getSupplementaryAlignmentFlag()) return;\n \n+                metrics.TOTAL_READS++;\n                 readLengthHistogram.increment(record.getReadBases().length);\n-                alignedReadLengthHistogram.increment(getUnclippedBaseCount(record.getCigar()));\n \n-                // See if the read is an adapter sequence\n-                if (adapterUtility.isAdapter(record)) {\n-                    this.adapterReads++;\n-                }\n-                // count clipped bases\n-                numHardClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.HARD_CLIP);\n+                if (!record.getReadFailsVendorQualityCheckFlag()) {\n+                    metrics.PF_READS++;\n+                    if (isNoiseRead(record)) metrics.PF_NOISE_READS++;\n \n-                if (!record.getReadUnmappedFlag()) {\n-                    numSoftClipped += getTotalCigarOperatorCount(record.getCigar(), CigarOperator.SOFT_CLIP);\n-                    if (doRefMetrics) {\n+                    // See if the read is an adapter sequence\n+                    if (adapterUtility.isAdapter(record)) {\n+                        this.adapterReads++;\n+                    }\n \n+                    if (!record.getReadUnmappedFlag() && doRefMetrics) {\n                         metrics.PF_READS_ALIGNED++;\n-                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) {\n-                            metrics.PF_READS_IMPROPER_PAIRS++;\n-                        }\n-                        if (!record.getReadNegativeStrandFlag()) {\n-                            numPositiveStrand++;\n-                        }\n+                        if (record.getReadPairedFlag() && !record.getProperPairFlag()) metrics.PF_READS_IMPROPER_PAIRS++;\n+                        if (!record.getReadNegativeStrandFlag()) numPositiveStrand++;\n                         if (record.getReadPairedFlag() && !record.getMateUnmappedFlag()) {\n                             metrics.READS_ALIGNED_IN_PAIRS++;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NjY0NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464586644", "bodyText": "unnecessary ;\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    };\n          \n          \n            \n                    }", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:23:52Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -432,17 +555,19 @@ public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final File refflat,\n                                                      final Set<String> ignoreSequence) {\n                 final CollectQualityYieldMetrics program = new CollectQualityYieldMetrics();\n-                program.output = new RequiredOutputArgumentCollection(new File(outbase + \".quality_yield_metrics\" + outext));\n+                program.output = new RequiredOutputArgumentCollection(new File(outbase + METRIC_EXTENSION + outext));\n                 // Generally programs should not be accessing these directly but it might make things smoother\n                 // to just set them anyway. These are set here to make sure that in case of a the derived class\n                 // overrides\n                 program.INPUT = input;\n \n                 return program;\n             }\n-        }\n+        };", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNjg2NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465306864", "bodyText": "", "author": "yfarjoun", "createdAt": "2020-08-04T20:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NjY0NA=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n\n@@ -555,7 +432,7 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n                                                      final File refflat,\n                                                      final Set<String> ignoreSequence) {\n                 final CollectQualityYieldMetrics program = new CollectQualityYieldMetrics();\n-                program.output = new RequiredOutputArgumentCollection(new File(outbase + METRIC_EXTENSION + outext));\n+                program.output = new RequiredOutputArgumentCollection(new File(outbase + \".quality_yield_metrics\" + outext));\n                 // Generally programs should not be accessing these directly but it might make things smoother\n                 // to just set them anyway. These are set here to make sure that in case of a the derived class\n                 // overrides\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4OTI2OA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464589268", "bodyText": "why makeList instead of Arrays.asList?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n          \n          \n            \n                        final List<String> OUTPUT_EXTENSIONS = Arrays.asList(", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:29:06Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -194,6 +209,19 @@ public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".insert_size_metrics\";\n+            final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n\n@@ -209,19 +194,6 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n                 return true;\n             }\n \n-            final String METRICS_EXTENSION = \".insert_size_metrics\";\n-            final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n-\n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n-\n-            @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n-            }\n-\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MDg0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464590842", "bodyText": "It looks like this is the same for most (all?) subclasses. If you make USAGE_SUMMARY and OUTPUT_EXTENSIONS either constructor arguments or abstract methods then the duplicate code can be removed.", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:32:20Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -157,13 +156,28 @@ default boolean supportsMetricAccumulationLevel() {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n\n@@ -156,28 +157,13 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n         }\n     }\n \n-    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n-\n+    public enum Program implements ProgramInterface {\n         CollectAlignmentSummaryMetrics {\n-\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n-            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n-            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n-\n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n-\n-            @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n-            }\n-\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTAyNQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464591025", "bodyText": "I think this should be CollectAlignmentSummaryMetrics.USAGE_SUMMARY", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:32:47Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -157,13 +156,28 @@ default boolean supportsMetricAccumulationLevel() {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2NTg5NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465165894", "bodyText": "oops. good catch.", "author": "yfarjoun", "createdAt": "2020-08-04T16:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTAyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "chunk": "diff --git a/src/main/java/picard/analysis/CollectMultipleMetrics.java b/src/main/java/picard/analysis/CollectMultipleMetrics.java\nindex f40b2fb23..f64645d3c 100644\n--- a/src/main/java/picard/analysis/CollectMultipleMetrics.java\n+++ b/src/main/java/picard/analysis/CollectMultipleMetrics.java\n\n@@ -156,28 +157,13 @@ public class CollectMultipleMetrics extends CommandLineProgram {\n         }\n     }\n \n-    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n-\n+    public enum Program implements ProgramInterface {\n         CollectAlignmentSummaryMetrics {\n-\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n-            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n-            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n-\n-            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n-                    METRICS_EXTENSION,\n-                    PDF_EXTENSION);\n-\n-            @Override\n-            public String getHelpDoc() {\n-                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +\n-                        \"Creates output with \\\"\" + String.join(\"\\\", \\\"\", OUTPUT_EXTENSIONS) + \"\\\" appended to OUTPUT.\";\n-            }\n-\n             @Override\n             public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final String outext,\n"}}, {"oid": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "url": "https://github.com/broadinstitute/picard/commit/b92438175bcb131ae681e3e3f362714c0f9d0cd1", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "690fdc6532393877c3a6b04dffad0eee688223d6", "url": "https://github.com/broadinstitute/picard/commit/690fdc6532393877c3a6b04dffad0eee688223d6", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "6cc4f7e319f7b89abdfafe494e17930ceefcb659", "url": "https://github.com/broadinstitute/picard/commit/6cc4f7e319f7b89abdfafe494e17930ceefcb659", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "url": "https://github.com/broadinstitute/picard/commit/70768b2f7a2e6ac0d05bf84805ef1159ff428372", "message": "Several changes to metrics collections:\n\n- Added Clips (Soft and Hard) to AlignmentSummaryMetrics\n- Added read-length histogram and pdf output to AlignmentSummaryMetrics\n- Added Tests\n- Added a TEMP_OUTPUT_DIR to CommandLineProgramTest.java which is delete once the derived class is done testing\n- Modified Two test classes to use TEMP_OUTPUT_DIR\n- Modified enum in CollectMultipleMetrics so that it will display what the options are and what each program does in the help.", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "c515e9b634464d0ef8943e2f95bf8097b849c7db", "url": "https://github.com/broadinstitute/picard/commit/c515e9b634464d0ef8943e2f95bf8097b849c7db", "message": "- fixed failing tests (moved files)\n- fixed fialing test (protect against empty histogram)", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "215e12c2b44dc6741692d7f9b79c631b62bc3c80", "url": "https://github.com/broadinstitute/picard/commit/215e12c2b44dc6741692d7f9b79c631b62bc3c80", "message": "- testing failures (ggplot2?)\n- fixing other tests failures", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "64f74350f783534af23e030e0a0a4dfdb4edb7d0", "url": "https://github.com/broadinstitute/picard/commit/64f74350f783534af23e030e0a0a4dfdb4edb7d0", "message": "- test that one can load the reshape library in R in the test env", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "8891b58d1f994cd189997156ca43c82be0c0368b", "url": "https://github.com/broadinstitute/picard/commit/8891b58d1f994cd189997156ca43c82be0c0368b", "message": "- add test with library in R", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "05d03a38f6f8ff2280532846e2417c8fbdd744d7", "url": "https://github.com/broadinstitute/picard/commit/05d03a38f6f8ff2280532846e2417c8fbdd744d7", "message": "- now plotting like a champ...no ggplot, no reshape2....", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d3c121a38e71b082868514291b0baffd91544644", "url": "https://github.com/broadinstitute/picard/commit/d3c121a38e71b082868514291b0baffd91544644", "message": "- responding to review comments", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "8e5b875089475c999ffec862886d9fb2868049bf", "url": "https://github.com/broadinstitute/picard/commit/8e5b875089475c999ffec862886d9fb2868049bf", "message": "remove r_packages test since we do not have these packages in the r distribution we use.", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d1d17547088339055368553a9411cee98dd9fcae", "url": "https://github.com/broadinstitute/picard/commit/d1d17547088339055368553a9411cee98dd9fcae", "message": "- updated the javaDoc", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d1d17547088339055368553a9411cee98dd9fcae", "url": "https://github.com/broadinstitute/picard/commit/d1d17547088339055368553a9411cee98dd9fcae", "message": "- updated the javaDoc", "committedDate": "2020-08-04T20:30:38Z", "type": "forcePushed"}]}