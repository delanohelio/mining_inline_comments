{"pr_number": 2006, "pr_title": "[CALCITE-4015] Pass through parent collation request on subset or sup\u2026", "pr_createdAt": "2020-06-07T09:01:36Z", "pr_url": "https://github.com/apache/calcite/pull/2006", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r436386235", "bodyText": "I will probably add more comments to these new methods to explain what they are doing.", "author": "amaliujia", "createdAt": "2020-06-07T17:48:24Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MjM1OA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062358", "bodyText": "Can you rebase on master? I just updated this file.\nUse ImmutableIntList.incr instead.", "author": "hsyuan", "createdAt": "2020-06-08T23:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM4NjIzNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -250,25 +265,18 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n-  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {\n-    ArrayList<Integer> arrayList = new ArrayList<>(intList.size());\n-    for (int i : intList) {\n-      arrayList.add(i + offset);\n+  private Mappings.TargetMapping buildMapping(boolean left2Right) {\n+    ImmutableIntList sourceKeys = left2Right ? joinInfo.leftKeys : joinInfo.rightKeys;\n+    ImmutableIntList targetKeys = left2Right ? joinInfo.rightKeys : joinInfo.leftKeys;\n+    Map<Integer, Integer> keyMap = new HashMap<>();\n+    for (int i = 0; i < joinInfo.leftKeys.size(); i++) {\n+      keyMap.put(sourceKeys.get(i), targetKeys.get(i));\n     }\n-    return arrayList;\n-  }\n \n-  private boolean isSubset(List<Integer> a, List<Integer> b) {\n-    if (a.size() > b.size()) {\n-      return false;\n-    }\n-    Set<Integer> set = new HashSet<>(b);\n-    for (int i = 0; i < a.size(); i++) {\n-      if (!set.contains(a.get(i))) {\n-        return false;\n-      }\n-    }\n-    return true;\n+    Mappings.TargetMapping mapping = Mappings.target(keyMap,\n+        (left2Right ? left : right).getRowType().getFieldCount(),\n+        (left2Right ? right : left).getRowType().getFieldCount());\n+    return mapping;\n   }\n \n   private boolean isPrefixOrderingNotRequired(List<Integer> a, List<Integer> b) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2Mjg1Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437062856", "bodyText": "See RelCollations.containsOrderless, you can make the private one public is necessary.", "author": "hsyuan", "createdAt": "2020-06-08T23:54:16Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -194,6 +250,81 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n+  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {\n+    ArrayList<Integer> arrayList = new ArrayList<>(intList.size());\n+    for (int i : intList) {\n+      arrayList.add(i + offset);\n+    }\n+    return arrayList;\n+  }\n+\n+  private boolean isSubset(List<Integer> a, List<Integer> b) {\n+    if (a.size() > b.size()) {\n+      return false;\n+    }\n+    Set<Integer> set = new HashSet<>(b);\n+    for (int i = 0; i < a.size(); i++) {\n+      if (!set.contains(a.get(i))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private boolean isPrefixOrderingNotRequired(List<Integer> a, List<Integer> b) {", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -250,25 +265,18 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return DeriveMode.BOTH;\n   }\n \n-  private List<Integer> immutableIntListToList(ImmutableIntList intList, int offset) {\n-    ArrayList<Integer> arrayList = new ArrayList<>(intList.size());\n-    for (int i : intList) {\n-      arrayList.add(i + offset);\n+  private Mappings.TargetMapping buildMapping(boolean left2Right) {\n+    ImmutableIntList sourceKeys = left2Right ? joinInfo.leftKeys : joinInfo.rightKeys;\n+    ImmutableIntList targetKeys = left2Right ? joinInfo.rightKeys : joinInfo.leftKeys;\n+    Map<Integer, Integer> keyMap = new HashMap<>();\n+    for (int i = 0; i < joinInfo.leftKeys.size(); i++) {\n+      keyMap.put(sourceKeys.get(i), targetKeys.get(i));\n     }\n-    return arrayList;\n-  }\n \n-  private boolean isSubset(List<Integer> a, List<Integer> b) {\n-    if (a.size() > b.size()) {\n-      return false;\n-    }\n-    Set<Integer> set = new HashSet<>(b);\n-    for (int i = 0; i < a.size(); i++) {\n-      if (!set.contains(a.get(i))) {\n-        return false;\n-      }\n-    }\n-    return true;\n+    Mappings.TargetMapping mapping = Mappings.target(keyMap,\n+        (left2Right ? left : right).getRowType().getFieldCount(),\n+        (left2Right ? right : left).getRowType().getFieldCount());\n+    return mapping;\n   }\n \n   private boolean isPrefixOrderingNotRequired(List<Integer> a, List<Integer> b) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNTgxOA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437115818", "bodyText": "nice catch. in case the keys are 1,1,2,2. IMHO, we shouldn't see duplicate join keys in physical merge/hash join operators. They should be optimized away, because that means the predicate is not pushed down at all.\nlike foo.a = bar.b and foo.a=bar.c. The predicate bar.b=bar.c should be pushed down for table bar.", "author": "hsyuan", "createdAt": "2020-06-09T03:21:06Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -101,48 +137,42 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n   @Override public Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n-    RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n+    RelCollation collation = required.getCollation();\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n     // need to copy reqKeys because it is not sortable.\n     reqKeys = new ArrayList<>(reqKeys);\n-    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n-    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n-        left.getRowType().getFieldCount());\n-    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n     ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n-\n-    Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeys.size();\n-    for (int i = 0; i < keyCount; i++) {\n-      keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n-    }\n-    Mappings.TargetMapping mapping = Mappings.target(keyMap,\n-        left.getRowType().getFieldCount(),\n-        right.getRowType().getFieldCount());\n-\n+        .shift(leftInputFieldCount);\n \n     if (reqKeySet.equals(leftKeySet)) {\n       // if sort keys equal to left join keys, we can pass through all collations directly.\n-      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      Mappings.TargetMapping mapping = buildMapping(true);\n+      RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n-    } else if (isSubset(reqKeys, leftKeys)) {\n+    } else if (containsOrderless(collation, leftKeys)) {\n       // if sort keys are subset of left join keys, we can extend collations to make sure all join\n       // keys are sorted.\n       collation = extendCollation(collation, leftKeys);\n-      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      Mappings.TargetMapping mapping = buildMapping(true);\n+      RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required.replace(collation),\n               required.replace(rightCollation)));\n     } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)\n-        && allElementsLt(reqKeys, getLeft().getRowType().getFieldCount())) {\n+        && reqKeys.stream().allMatch(i -> i < leftInputFieldCount)) {\n       // if sort keys are superset of left join keys, and left join keys is prefix of sort keys\n       // (order not matter ), also sort keys are all from left join input.\n+      Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation =\n           RexUtil.apply(\n               mapping,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437116546", "bodyText": "why do you want to sort it?", "author": "hsyuan", "createdAt": "2020-06-09T03:24:13Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEyNjg1NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437126855", "bodyText": "isPrefixOrderingNotRequired sorts its input, and reqKeys is used as this function's parameter below.\nBut since you have suggested RelCollations.containsOrderless, I might not need this anymore.", "author": "amaliujia", "createdAt": "2020-06-09T04:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjU0Ng=="}], "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -101,48 +137,42 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n   @Override public Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n-    RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n+    RelCollation collation = required.getCollation();\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n     // need to copy reqKeys because it is not sortable.\n     reqKeys = new ArrayList<>(reqKeys);\n-    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n-    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n-        left.getRowType().getFieldCount());\n-    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n     ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n-\n-    Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeys.size();\n-    for (int i = 0; i < keyCount; i++) {\n-      keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n-    }\n-    Mappings.TargetMapping mapping = Mappings.target(keyMap,\n-        left.getRowType().getFieldCount(),\n-        right.getRowType().getFieldCount());\n-\n+        .shift(leftInputFieldCount);\n \n     if (reqKeySet.equals(leftKeySet)) {\n       // if sort keys equal to left join keys, we can pass through all collations directly.\n-      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      Mappings.TargetMapping mapping = buildMapping(true);\n+      RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n-    } else if (isSubset(reqKeys, leftKeys)) {\n+    } else if (containsOrderless(collation, leftKeys)) {\n       // if sort keys are subset of left join keys, we can extend collations to make sure all join\n       // keys are sorted.\n       collation = extendCollation(collation, leftKeys);\n-      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      Mappings.TargetMapping mapping = buildMapping(true);\n+      RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required.replace(collation),\n               required.replace(rightCollation)));\n     } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)\n-        && allElementsLt(reqKeys, getLeft().getRowType().getFieldCount())) {\n+        && reqKeys.stream().allMatch(i -> i < leftInputFieldCount)) {\n       // if sort keys are superset of left join keys, and left join keys is prefix of sort keys\n       // (order not matter ), also sort keys are all from left join input.\n+      Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation =\n           RexUtil.apply(\n               mapping,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437117015", "bodyText": "You can use RelCollations.containsOrderless", "author": "hsyuan", "createdAt": "2020-06-09T03:26:14Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -101,28 +103,55 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    // need to copy reqKeys because it is not sortable.\n+    reqKeys = new ArrayList<>(reqKeys);\n+    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n+    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n+        left.getRowType().getFieldCount());\n+    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n         .shift(left.getRowType().getFieldCount());\n \n     Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeySet.cardinality();\n+    final int keyCount = leftKeys.size();\n     for (int i = 0; i < keyCount; i++) {\n       keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n     }\n     Mappings.TargetMapping mapping = Mappings.target(keyMap,\n         left.getRowType().getFieldCount(),\n         right.getRowType().getFieldCount());\n \n-    // Only consider exact key match for now\n+\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       RelCollation rightCollation = RexUtil.apply(mapping, collation);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, leftKeys)) {\n+      // if sort keys are subset of left join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, leftKeys);\n+      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      return Pair.of(\n+          required, ImmutableList.of(required.replace(collation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4OTAzMg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437889032", "bodyText": "isPrefixOrderingNotRequired probably is the one I cannot use RelCollations.containsOrderless. It is designed for superset case. In which join keys should be 1) an orderless subset 2) prefix of required collations.\nRelCollations.containsOrderless does not consider prefix requirement.\nAlternatively, I am ok to move isPrefixOrderingNotRequired to RelCollations as a util function.", "author": "amaliujia", "createdAt": "2020-06-10T06:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg5MDEyMg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437890122", "bodyText": "For supset case, for example if required collation is [d, b, a ,c]\nthen join keys [d, b, a] is valid\njoin keys [d,a,c] is not (if push down [d,b,a,c], it does not guarantee the ordering of [d,a,c]", "author": "amaliujia", "createdAt": "2020-06-10T06:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0ODQ0Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438448447", "bodyText": "can you explain RelCollations.containsOrderless does not consider prefix requirement.?", "author": "hsyuan", "createdAt": "2020-06-10T22:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNDI5OQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438534299", "bodyText": "containsOrderless only consider if one is another's subset, for example:\n[1, 2, 3] is [2, 3, 4, 1]'s subset\n[3, 2, 1] is [2, 1, 3, 4] 's subset\nThe prefix requirement is, still use examples above, but apply sublist:\n[2,3,4,1] -> [2,3,4], then containsOrderless([1,2,3]) = false.\n[2,1,3,4] ->[2,1,3], then containsOrderless([3,2,1]) = true.", "author": "amaliujia", "createdAt": "2020-06-11T04:20:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNzk3Mg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r438537972", "bodyText": "In fact, I mis-read how containsOrderless is implemented. It actually meets the need here.\nHave changed to containsOrderless and dropped unused code.", "author": "amaliujia", "createdAt": "2020-06-11T04:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzAxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -101,48 +137,42 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n   @Override public Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n-    RelCollation collation = required.getTrait(RelCollationTraitDef.INSTANCE);\n+    RelCollation collation = required.getCollation();\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n     // need to copy reqKeys because it is not sortable.\n     reqKeys = new ArrayList<>(reqKeys);\n-    List<Integer> leftKeys = immutableIntListToList(joinInfo.leftKeys, 0);\n-    List<Integer> rightKeys = immutableIntListToList(joinInfo.rightKeys,\n-        left.getRowType().getFieldCount());\n-    List<Integer> rightKeysNotShifted = immutableIntListToList(joinInfo.rightKeys, 0);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n     ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n-\n-    Map<Integer, Integer> keyMap = new HashMap<>();\n-    final int keyCount = leftKeys.size();\n-    for (int i = 0; i < keyCount; i++) {\n-      keyMap.put(joinInfo.leftKeys.get(i), joinInfo.rightKeys.get(i));\n-    }\n-    Mappings.TargetMapping mapping = Mappings.target(keyMap,\n-        left.getRowType().getFieldCount(),\n-        right.getRowType().getFieldCount());\n-\n+        .shift(leftInputFieldCount);\n \n     if (reqKeySet.equals(leftKeySet)) {\n       // if sort keys equal to left join keys, we can pass through all collations directly.\n-      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      Mappings.TargetMapping mapping = buildMapping(true);\n+      RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n-    } else if (isSubset(reqKeys, leftKeys)) {\n+    } else if (containsOrderless(collation, leftKeys)) {\n       // if sort keys are subset of left join keys, we can extend collations to make sure all join\n       // keys are sorted.\n       collation = extendCollation(collation, leftKeys);\n-      RelCollation rightCollation = RexUtil.apply(mapping, collation);\n+      Mappings.TargetMapping mapping = buildMapping(true);\n+      RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required.replace(collation),\n               required.replace(rightCollation)));\n     } else if (isPrefixOrderingNotRequired(leftKeys, reqKeys)\n-        && allElementsLt(reqKeys, getLeft().getRowType().getFieldCount())) {\n+        && reqKeys.stream().allMatch(i -> i < leftInputFieldCount)) {\n       // if sort keys are superset of left join keys, and left join keys is prefix of sort keys\n       // (order not matter ), also sort keys are all from left join input.\n+      Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation =\n           RexUtil.apply(\n               mapping,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NDYyMA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437684620", "bodyText": "let's use a var to store left.getRowType().getFieldCount().", "author": "hsyuan", "createdAt": "2020-06-09T20:01:41Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {\n+      // if sort keys are superset of right join keys, and right join keys is prefix of sort keys\n+      // (order not matter), also sort keys are all from right join input.\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -152,36 +182,33 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n               required.replace(rightCollation)));\n     } else if (reqKeySet.equals(rightKeySet)) {\n       // if sort keys equal to right join keys, we can pass through all collations directly.\n-      RelCollation rightCollation = RelCollations.shift(collation,\n-          -left.getRowType().getFieldCount());\n-      Mappings.TargetMapping invMapping = mapping.inverse();\n-      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      RelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\n+      Mappings.TargetMapping mapping = buildMapping(false);\n+      RelCollation leftCollation = rightCollation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n-    } else if (isSubset(reqKeys, rightKeys)) {\n+    } else if (containsOrderless(collation, rightKeys)) {\n       // if sort keys are subset of right join keys, we can extend collations to make sure all join\n       // keys are sorted.\n       collation = extendCollation(collation, rightKeys);\n-      RelCollation rightCollation = RelCollations.shift(collation,\n-          -left.getRowType().getFieldCount());\n-      Mappings.TargetMapping invMapping = mapping.inverse();\n-      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      RelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\n+      Mappings.TargetMapping mapping = buildMapping(false);\n+      RelCollation leftCollation = RexUtil.apply(mapping, rightCollation);\n       return Pair.of(\n           required, ImmutableList.of(\n               required.replace(leftCollation),\n               required.replace(rightCollation)));\n     } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n-        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {\n+        && reqKeys.stream().allMatch(i -> i >= leftInputFieldCount)) {\n       // if sort keys are superset of right join keys, and right join keys is prefix of sort keys\n       // (order not matter), also sort keys are all from right join input.\n-      RelCollation rightCollation = RelCollations.shift(collation,\n-          -left.getRowType().getFieldCount());\n-      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\n+      Mappings.TargetMapping mapping = buildMapping(false);\n       RelCollation leftCollation =\n           RexUtil.apply(\n-              invMapping,\n+              mapping,\n               removeCollationFieldsNotOnJoinKey(rightCollation, rightKeysNotShifted));\n       return Pair.of(\n           required, ImmutableList.of(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437685863", "bodyText": "can we use reqKeys.stream().allMatch()?", "author": "hsyuan", "createdAt": "2020-06-09T20:04:14Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -131,8 +160,35 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n+    } else if (isSubset(reqKeys, rightKeys)) {\n+      // if sort keys are subset of right join keys, we can extend collations to make sure all join\n+      // keys are sorted.\n+      collation = extendCollation(collation, rightKeys);\n+      RelCollation rightCollation = RelCollations.shift(collation,\n+          -left.getRowType().getFieldCount());\n+      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      return Pair.of(\n+          required, ImmutableList.of(\n+              required.replace(leftCollation),\n+              required.replace(rightCollation)));\n+    } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n+        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {", "originalCommit": "995031ec5b29a425abb1f09ad5bb33c767334386", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg4Njg4NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r437886885", "bodyText": "Done! Thanks!", "author": "amaliujia", "createdAt": "2020-06-10T06:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4NTg2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "5c09c3695883b67f056179caa06441100360ac5e", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 3608b2e40..914e9d289 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -152,36 +182,33 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n               required.replace(rightCollation)));\n     } else if (reqKeySet.equals(rightKeySet)) {\n       // if sort keys equal to right join keys, we can pass through all collations directly.\n-      RelCollation rightCollation = RelCollations.shift(collation,\n-          -left.getRowType().getFieldCount());\n-      Mappings.TargetMapping invMapping = mapping.inverse();\n-      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      RelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\n+      Mappings.TargetMapping mapping = buildMapping(false);\n+      RelCollation leftCollation = rightCollation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(\n           required.replace(leftCollation),\n           required.replace(rightCollation)));\n-    } else if (isSubset(reqKeys, rightKeys)) {\n+    } else if (containsOrderless(collation, rightKeys)) {\n       // if sort keys are subset of right join keys, we can extend collations to make sure all join\n       // keys are sorted.\n       collation = extendCollation(collation, rightKeys);\n-      RelCollation rightCollation = RelCollations.shift(collation,\n-          -left.getRowType().getFieldCount());\n-      Mappings.TargetMapping invMapping = mapping.inverse();\n-      RelCollation leftCollation = RexUtil.apply(invMapping, rightCollation);\n+      RelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\n+      Mappings.TargetMapping mapping = buildMapping(false);\n+      RelCollation leftCollation = RexUtil.apply(mapping, rightCollation);\n       return Pair.of(\n           required, ImmutableList.of(\n               required.replace(leftCollation),\n               required.replace(rightCollation)));\n     } else if (isPrefixOrderingNotRequired(rightKeys, reqKeys)\n-        && allElementsGe(reqKeys, getLeft().getRowType().getFieldCount())) {\n+        && reqKeys.stream().allMatch(i -> i >= leftInputFieldCount)) {\n       // if sort keys are superset of right join keys, and right join keys is prefix of sort keys\n       // (order not matter), also sort keys are all from right join input.\n-      RelCollation rightCollation = RelCollations.shift(collation,\n-          -left.getRowType().getFieldCount());\n-      Mappings.TargetMapping invMapping = mapping.inverse();\n+      RelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\n+      Mappings.TargetMapping mapping = buildMapping(false);\n       RelCollation leftCollation =\n           RexUtil.apply(\n-              invMapping,\n+              mapping,\n               removeCollationFieldsNotOnJoinKey(rightCollation, rightKeysNotShifted));\n       return Pair.of(\n           required, ImmutableList.of(\n"}}, {"oid": "5c09c3695883b67f056179caa06441100360ac5e", "url": "https://github.com/apache/calcite/commit/5c09c3695883b67f056179caa06441100360ac5e", "message": "fixup! address comments", "committedDate": "2020-06-10T06:28:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782274", "bodyText": "Why toIntegerList?", "author": "hsyuan", "createdAt": "2020-06-14T01:19:04Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MzU3Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439783577", "bodyText": "To this specific case, toIntegerList to get a list of key indexes (not shifted, so index from 0). Then, later, in superset cases, we can use this list to remove collations that are not on keys. Use this query as an example:\nselect * from foo join bar on foo.a=bar.a and foo.b=bar.b order by bar.a, bar.b, bar.c; \nwe can push\ncollation a b to left\ncollation a, b, c to right\nThus the output of join should still be sorted by a, b, c.\nThen, the toIntegerList helps to to that only a, b needs to pushed to left.  It works along with\nRelCollation rightCollation = RelCollations.shift(collation, -leftInputFieldCount);\nMappings.TargetMapping mapping = buildMapping(false);\nRelCollation leftCollation =\n          RexUtil.apply(\n              mapping,\n              removeCollationFieldsNotOnJoinKey(rightCollation, rightKeysNotShifted));", "author": "amaliujia", "createdAt": "2020-06-14T01:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MzczNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439783735", "bodyText": "why ImmutableIntList is not suitable?", "author": "hsyuan", "createdAt": "2020-06-14T01:54:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDc3MA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784770", "bodyText": "Let me check if this process can be simplified somehow.\nFor the example above, I am only looking for a way to\nleftCollation = requiredCollation.apply(join keys) // only need collation defined on keys for left input,", "author": "amaliujia", "createdAt": "2020-06-14T02:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4OTc4Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439789787", "bodyText": "I still don't understand, why can't just use joinInfo.rightKeys, instead use joinInfo.rightKeys. toIntegerList?", "author": "hsyuan", "createdAt": "2020-06-14T04:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTg2Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791866", "bodyText": "yes joinInfo.rightKeys can be used because ImmutableIntList implements IndexOf. I will change it to joinInfo.rightKeys", "author": "amaliujia", "createdAt": "2020-06-14T04:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjI3NA=="}], "type": "inlineReview", "revised_code": {"commit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 553d727e3..c13702afc 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -143,7 +144,6 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n     List<Integer> rightKeys =\n         joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n-    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n     ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782315", "bodyText": "It is not obvious to get the meaning from method name. An example and comment will help.", "author": "hsyuan", "createdAt": "2020-06-14T01:20:02Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);\n+    for (RelFieldCollation rf : collation.getFieldCollations()) {\n+      keySet.remove(rf.getFieldIndex());\n+    }\n+    for (Integer i : keySet) {\n+      fieldsForNewCollation.add(new RelFieldCollation(i));\n+    }\n+    return RelCollations.of(fieldsForNewCollation);\n+  }\n+\n+  private RelCollation removeCollationFieldsNotOnJoinKey(", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDE0Ng==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784146", "bodyText": "Let me add some comments with an example (a little bit complicated but let me try).", "author": "amaliujia", "createdAt": "2020-06-14T02:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwNjI2NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473006265", "bodyText": "I also think the method name is counter-intuitive. It is actually not removing anything, it just builds a new collation based on a \"source\" collation, considering only the fields which are part of the joinKeys. I would propose as name e.g. reduceCollation, intersect, or something like that..", "author": "rubenada", "createdAt": "2020-08-19T12:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0OTMzMA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475449330", "bodyText": "friendly reminder about these comments", "author": "rubenada", "createdAt": "2020-08-24T09:09:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTYyNg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475759626", "bodyText": "oops. I have missed this comment.\nWill address this one and another comment.", "author": "amaliujia", "createdAt": "2020-08-24T16:57:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc2NzA1Nw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475767057", "bodyText": "intersectCollationAndJoinKey is a reasonable name for me.", "author": "amaliujia", "createdAt": "2020-08-24T17:11:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjMxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 553d727e3..c13702afc 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -277,21 +277,39 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  /**\n+   * This function extends collation by appending new collation fields defiend on keys.\n+   */\n   private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n     List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n     fieldsForNewCollation.addAll(collation.getFieldCollations());\n-    Set<Integer> keySet = new HashSet<>(keys);\n-    for (RelFieldCollation rf : collation.getFieldCollations()) {\n-      keySet.remove(rf.getFieldIndex());\n-    }\n-    for (Integer i : keySet) {\n+\n+    ImmutableBitSet keysBitset = ImmutableBitSet.of(keys);\n+    ImmutableBitSet colKeysBitset = ImmutableBitSet.of(collation.getKeys());\n+    ImmutableBitSet exceptBitset = keysBitset.except(colKeysBitset);\n+    for (Integer i : exceptBitset.toList()) {\n       fieldsForNewCollation.add(new RelFieldCollation(i));\n     }\n     return RelCollations.of(fieldsForNewCollation);\n   }\n \n+  /**\n+   * This function will remove collations that are not defined on join keys.\n+   * For example:\n+   *    select * from\n+   *    foo join bar\n+   *    on foo.a = bar.a and foo.c=bar.c\n+   *    order by bar.a, bar.c, bar.b;\n+   *\n+   * The collation [bar.a, bar.c, bar.b] can be pushed down to bar. However, only\n+   * [a, c] can be pushed down to foo. This function will help create [a, c] for foo by removing\n+   * b from the required collation, because b is not defined on join keys.\n+   *\n+   * @param collation collation defined on the JOIN\n+   * @param joinKeys  the join keys\n+   */\n   private RelCollation removeCollationFieldsNotOnJoinKey(\n-      RelCollation collation, List<Integer> joinKeys) {\n+      RelCollation collation, ImmutableIntList joinKeys) {\n     List<RelFieldCollation> fieldCollations = new ArrayList<>();\n     for (RelFieldCollation rf : collation.getFieldCollations()) {\n       if (joinKeys.contains(rf.getFieldIndex())) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439782434", "bodyText": "Do we need to keep the keys order?", "author": "hsyuan", "createdAt": "2020-06-14T01:23:33Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,30 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n+    List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n+    fieldsForNewCollation.addAll(collation.getFieldCollations());\n+    Set<Integer> keySet = new HashSet<>(keys);", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDEyMQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784121", "bodyText": "No for subset cases. For example, required collation [foo.a, foo.b] defined on foo.a=bar.a and foo.b=bar.b and foo.c=bar.c and foo.d=bar.d, either pass down [foo.a, foo.b, foo.c, foo.d] or pass down [foo.a, foo.b, foo.d, foo.c] will give correct answer (same to push the same collations to right join input).\nIt is because, for MergeJoin implementation, the pointers moves when left tuple not equals to right tuple, and the only requirement is next tuple should be bigger than previous ones.\nStill use example above:\nleft join input and right join input both are sorted by [a, b, d, c]. So\n\nleft_tuple.compare(right_tuple) < 0, move left pointer, of course next tuple will be both bigger than a) the previous left tuple b) the current right tuple (due to they are all sorted by [a, b]).\nsame for ``left_tuple.compare(right_tuple) > 0` case.", "author": "amaliujia", "createdAt": "2020-06-14T02:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4NDI0OA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439784248", "bodyText": "to add a bit explanation on the example above, the only usefulness of pushed collocations on [d, c], is just to maintain increasing order when move left pointer on left join input during merging. Thus [c, d] will achieve the same thing.", "author": "amaliujia", "createdAt": "2020-06-14T02:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDIzNg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790236", "bodyText": "Why not just use bitset.except to compute the diff keys?", "author": "hsyuan", "createdAt": "2020-06-14T04:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTcyNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791727", "bodyText": "Will check how to use bitset.except.\nMeanwhile, in fact, the ordering does matter for EnumerableMergeJoin, it is because key selector and key comparator are constructed by join key ordering.\nThus we have to follow join key ordering to extend required collations.", "author": "amaliujia", "createdAt": "2020-06-14T04:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyODQ2Mw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439928463", "bodyText": "Use bitset.except now to compute diff.", "author": "amaliujia", "createdAt": "2020-06-15T04:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc4MjQzNA=="}], "type": "inlineReview", "revised_code": {"commit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 553d727e3..c13702afc 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -277,21 +277,39 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  /**\n+   * This function extends collation by appending new collation fields defiend on keys.\n+   */\n   private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n     List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n     fieldsForNewCollation.addAll(collation.getFieldCollations());\n-    Set<Integer> keySet = new HashSet<>(keys);\n-    for (RelFieldCollation rf : collation.getFieldCollations()) {\n-      keySet.remove(rf.getFieldIndex());\n-    }\n-    for (Integer i : keySet) {\n+\n+    ImmutableBitSet keysBitset = ImmutableBitSet.of(keys);\n+    ImmutableBitSet colKeysBitset = ImmutableBitSet.of(collation.getKeys());\n+    ImmutableBitSet exceptBitset = keysBitset.except(colKeysBitset);\n+    for (Integer i : exceptBitset.toList()) {\n       fieldsForNewCollation.add(new RelFieldCollation(i));\n     }\n     return RelCollations.of(fieldsForNewCollation);\n   }\n \n+  /**\n+   * This function will remove collations that are not defined on join keys.\n+   * For example:\n+   *    select * from\n+   *    foo join bar\n+   *    on foo.a = bar.a and foo.c=bar.c\n+   *    order by bar.a, bar.c, bar.b;\n+   *\n+   * The collation [bar.a, bar.c, bar.b] can be pushed down to bar. However, only\n+   * [a, c] can be pushed down to foo. This function will help create [a, c] for foo by removing\n+   * b from the required collation, because b is not defined on join keys.\n+   *\n+   * @param collation collation defined on the JOIN\n+   * @param joinKeys  the join keys\n+   */\n   private RelCollation removeCollationFieldsNotOnJoinKey(\n-      RelCollation collation, List<Integer> joinKeys) {\n+      RelCollation collation, ImmutableIntList joinKeys) {\n     List<RelFieldCollation> fieldCollations = new ArrayList<>();\n     for (RelFieldCollation rf : collation.getFieldCollations()) {\n       if (joinKeys.contains(rf.getFieldIndex())) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439790064", "bodyText": "How can it be true if sort keys are subset of left join keys?", "author": "hsyuan", "createdAt": "2020-06-14T04:19:53Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +137,83 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n+    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(collation, leftKeys)) {", "originalCommit": "fee95d236a1042baa7672bf74b764e82f8465717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTY4NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791684", "bodyText": "You might not notice, I have changed the code of containsOrderless and added this\n    if (colKeys.size() < distinctKeys.size()) {\n      return containsOrderlessSubset(collation.getKeys().toIntegerList(), distinctKeys);\n    } else {\n\nSo firstly, collations contains fields less than join keys is allowed. Then, it is only legal if collations follows the ordering of sort keys (and later at runtime, key selector and key comparator are constructed by sort key ordering).", "author": "amaliujia", "createdAt": "2020-06-14T04:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTkwMg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791902", "bodyText": "This breaks the definition of the method name. containsOrderless means the former contains the latter. We can create another method containsOrderless(List<Integer>, List<Integer>) if necessary.", "author": "hsyuan", "createdAt": "2020-06-14T04:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTk1OQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439791959", "bodyText": "I need to update containsOrderlessSubset to make it consider list ordering.", "author": "amaliujia", "createdAt": "2020-06-14T04:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkyODUyNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r439928527", "bodyText": "Add containsOrderless(List<Integer>, List<Integer>) now to obey the naming convention.", "author": "amaliujia", "createdAt": "2020-06-15T04:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MDA2NA=="}], "type": "inlineReview", "revised_code": {"commit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex 553d727e3..c13702afc 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -143,7 +144,6 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n     List<Integer> rightKeys =\n         joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n-    List<Integer> rightKeysNotShifted = joinInfo.rightKeys.toIntegerList();\n \n     ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n"}}, {"oid": "003479ad81f463ff120a987c349ccc6c2e9396e9", "url": "https://github.com/apache/calcite/commit/003479ad81f463ff120a987c349ccc6c2e9396e9", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side.", "committedDate": "2020-06-20T20:17:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472863817", "bodyText": "I would name this method (and the following one) just containsOrderless, i.e. provide 4 overloaded methods with that name.", "author": "rubenada", "createdAt": "2020-08-19T08:42:38Z", "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -199,25 +199,45 @@ public static boolean contains(List<RelCollation> collations,\n    * @param keys List of keys\n    * @return Whether the collection contains the given keys\n    */\n-  private static boolean containsOrderless(RelCollation collation,\n+  public static boolean containsOrderless(RelCollation collation,\n       List<Integer> keys) {\n     final List<Integer> distinctKeys = Util.distinctList(keys);\n     final ImmutableBitSet keysBitSet = ImmutableBitSet.of(distinctKeys);\n     List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n     if (colKeys.size() < distinctKeys.size()) {\n       return false;\n+    } else {\n+      ImmutableBitSet bitset = ImmutableBitSet.of(\n+          colKeys.subList(0, distinctKeys.size()));\n+      return bitset.equals(keysBitSet);\n+    }\n+  }\n+\n+  /** Returns whether a collation is contained by a given list of keys regardless ordering.\n+   *\n+   * @param collation Collation\n+   * @param keys List of keys\n+   * @return Whether the collection contains the given keys\n+   */\n+  public static boolean containsOrderless(\n+      List<Integer> keys, RelCollation collation) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);\n+    List<Integer> colKeys = Util.distinctList(collation.getKeys());\n+\n+    if (colKeys.size() > distinctKeys.size()) {\n+      return false;\n+    } else {\n+      return colKeys.stream().allMatch(i -> distinctKeys.contains(i));\n     }\n-    ImmutableBitSet bitset = ImmutableBitSet.of(\n-        colKeys.subList(0, distinctKeys.size()));\n-    return bitset.equals(keysBitSet);\n   }\n \n   /**\n    * Returns whether one of a list of collations contains the given list of keys\n    * regardless the order.\n    */\n-  public static boolean containsOrderless(List<RelCollation> collations,\n-      List<Integer> keys) {\n+  public static boolean collationsContainKeysOrderless(", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMxNjcyNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473316727", "bodyText": "The reasons that I didn't use overloaded approach\n\nthese names are in the format of A verb B, means the first parameter contains the second parameter. And arguments of these functions have an ordering of A and B. I think this is more readable.\nFor Java, List is the same type. For example, List<Integer>  and List<Collation> are both List<T> thus List<Object>. So we cannot overload, for example collationsContainKeysOrderless and keysContainCollationsOrderless", "author": "amaliujia", "createdAt": "2020-08-19T21:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzMDMxOA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473930318", "bodyText": "Ok, I understand, thanks for the explanation.", "author": "rubenada", "createdAt": "2020-08-20T12:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2MzgxNw=="}], "type": "inlineReview", "revised_code": {"commit": "b3af0bb59afb080641b10455804ef65847e09800", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/rel/RelCollations.java b/core/src/main/java/org/apache/calcite/rel/RelCollations.java\nindex 322c5db1f..863327926 100644\n--- a/core/src/main/java/org/apache/calcite/rel/RelCollations.java\n+++ b/core/src/main/java/org/apache/calcite/rel/RelCollations.java\n\n@@ -238,9 +238,8 @@ public static boolean containsOrderless(\n    */\n   public static boolean collationsContainKeysOrderless(\n       List<RelCollation> collations, List<Integer> keys) {\n-    final List<Integer> distinctKeys = Util.distinctList(keys);\n     for (RelCollation collation : collations) {\n-      if (containsOrderless(collation, distinctKeys)) {\n+      if (containsOrderless(collation, keys)) {\n         return true;\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg2NTI0NQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472865245", "bodyText": "minor: typo in 'defiend'", "author": "rubenada", "createdAt": "2020-08-19T08:44:54Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -222,6 +277,48 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n     return mapping;\n   }\n \n+  /**\n+   * This function extends collation by appending new collation fields defiend on keys.", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3af0bb59afb080641b10455804ef65847e09800", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex c13702afc..822f44f7d 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -278,7 +317,7 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n   }\n \n   /**\n-   * This function extends collation by appending new collation fields defiend on keys.\n+   * This function extends collation by appending new collation fields defined on keys.\n    */\n   private RelCollation extendCollation(RelCollation collation, List<Integer> keys) {\n     List<RelFieldCollation> fieldsForNewCollation = new ArrayList<>(keys.size());\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0MTE3OQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r472941179", "bodyText": "Given that containsOrderless already does a Util.distinctList(keys), we could skip it here.\nThe same applies to collationsContainKeysOrderless", "author": "rubenada", "createdAt": "2020-08-19T10:55:25Z", "path": "core/src/main/java/org/apache/calcite/rel/RelCollations.java", "diffHunk": "@@ -227,6 +247,21 @@ public static boolean containsOrderless(List<RelCollation> collations,\n     return false;\n   }\n \n+  /**\n+   * Returns whether one of a list of collations is contained by the given list of keys\n+   * regardless the order.\n+   */\n+  public static boolean keysContainCollationsOrderless(\n+      List<Integer> keys,  List<RelCollation> collations) {\n+    final List<Integer> distinctKeys = Util.distinctList(keys);", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "b3af0bb59afb080641b10455804ef65847e09800", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/rel/RelCollations.java b/core/src/main/java/org/apache/calcite/rel/RelCollations.java\nindex 322c5db1f..863327926 100644\n--- a/core/src/main/java/org/apache/calcite/rel/RelCollations.java\n+++ b/core/src/main/java/org/apache/calcite/rel/RelCollations.java\n\n@@ -238,9 +238,8 @@ public static boolean containsOrderless(\n    */\n   public static boolean collationsContainKeysOrderless(\n       List<RelCollation> collations, List<Integer> keys) {\n-    final List<Integer> distinctKeys = Util.distinctList(keys);\n     for (RelCollation collation : collations) {\n-      if (containsOrderless(collation, distinctKeys)) {\n+      if (containsOrderless(collation, keys)) {\n         return true;\n       }\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473001005", "bodyText": "I think it would be helpful to describe the general logic and all the different cases in a javadoc on passThroughTraits", "author": "rubenada", "createdAt": "2020-08-19T12:46:29Z", "path": "core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java", "diffHunk": "@@ -134,31 +138,82 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n     RelCollation collation = required.getCollation();\n+    int leftInputFieldCount = left.getRowType().getFieldCount();\n+\n     List<Integer> reqKeys = RelCollations.ordinals(collation);\n-    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n+    List<Integer> leftKeys = joinInfo.leftKeys.toIntegerList();\n+    List<Integer> rightKeys =\n+        joinInfo.rightKeys.incr(leftInputFieldCount).toIntegerList();\n \n+    ImmutableBitSet reqKeySet = ImmutableBitSet.of(reqKeys);\n     ImmutableBitSet leftKeySet = ImmutableBitSet.of(joinInfo.leftKeys);\n     ImmutableBitSet rightKeySet = ImmutableBitSet.of(joinInfo.rightKeys)\n-        .shift(left.getRowType().getFieldCount());\n+        .shift(leftInputFieldCount);\n \n-    // Only consider exact key match for now\n     if (reqKeySet.equals(leftKeySet)) {\n+      // if sort keys equal to left join keys, we can pass through all collations directly.\n       Mappings.TargetMapping mapping = buildMapping(true);\n       RelCollation rightCollation = collation.apply(mapping);\n       return Pair.of(\n           required, ImmutableList.of(required,\n           required.replace(rightCollation)));\n+    } else if (containsOrderless(leftKeys, collation)) {", "originalCommit": "003479ad81f463ff120a987c349ccc6c2e9396e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE5MzY3OA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473193678", "bodyText": "Got it. Will give a summary as java doc.", "author": "amaliujia", "createdAt": "2020-08-19T17:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzMzODg0Mg==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r473338842", "bodyText": "Added a summary.", "author": "amaliujia", "createdAt": "2020-08-19T21:27:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzAwMTAwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "b3af0bb59afb080641b10455804ef65847e09800", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\nindex c13702afc..822f44f7d 100644\n--- a/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n+++ b/core/src/main/java/org/apache/calcite/adapter/enumerable/EnumerableMergeJoin.java\n\n@@ -134,6 +134,45 @@ public static boolean isMergeJoinSupported(JoinRelType joinType) {\n         CorrelationId.setOf(variablesStopped), joinType);\n   }\n \n+  /**\n+   * Pass collations through can have three cases:\n+   * 1. If sort keys are equal to either left join keys, or right join keys,\n+   * collations can be pushed to both join sides with correct mappings.\n+   * For example, for the query\n+   *    select * from foo join bar on foo.a=bar.b order by foo.a desc\n+   * after traits pass through it will be equivalent to\n+   *    select * from\n+   *        (select * from foo order by foo.a desc)\n+   *        join\n+   *        (select * from bar order by bar.b desc)\n+   *\n+   * 2. If sort keys are sub-set of either left join keys, or right join keys,\n+   * collations have to be extended to cover all joins keys before passing through,\n+   * because merge join requires all join keys are sorted.\n+   * For example, for the query\n+   *    select * from foo join bar\n+   *        on foo.a=bar.b and foo.c=bar.d\n+   *        order by foo.a desc\n+   * after traits pass through it will be equivalent to\n+   *    select * from\n+   *        (select * from foo order by foo.a desc, foo.c)\n+   *        join\n+   *        (select * from bar order by bar.b desc, bar.d)\n+   *\n+   * 2. If sort keys are super-set of either left join keys, or right join keys,\n+   * but not both, collations can be completely passed to the join key whose join\n+   * keys match the prefix of collations. Meanwhile, partial mapped collations can\n+   * be passed to another join side to make sure join keys are sorted.\n+   * For example, for the query\n+   *    select * from foo join bar\n+   *        on foo.a=bar.b and foo.c=bar.d\n+   *        order by foo.a desc, foo.c desc, foo.e\n+   * after traits pass through it will be equivalent to\n+   *    select * from\n+   *        (select * from foo order by foo.a desc, foo.c desc, foo.e)\n+   *        join\n+   *        (select * from bar order by bar.b desc, bar.d desc)\n+   */\n   @Override public Pair<RelTraitSet, List<RelTraitSet>> passThroughTraits(\n       final RelTraitSet required) {\n     // Required collation keys can be subset or superset of merge join keys.\n"}}, {"oid": "b3af0bb59afb080641b10455804ef65847e09800", "url": "https://github.com/apache/calcite/commit/b3af0bb59afb080641b10455804ef65847e09800", "message": "fixup! address comment", "committedDate": "2020-08-19T21:27:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475448937", "bodyText": "maybe we could also add some unit tests for the new method keysContainCollationsOrderless?", "author": "rubenada", "createdAt": "2020-08-24T09:08:53Z", "path": "core/src/test/java/org/apache/calcite/rel/RelCollationTest.java", "diffHunk": "@@ -84,18 +84,36 @@\n         is(true));\n   }\n \n-  /** Unit test for {@link RelCollations#containsOrderless(List, List)}. */\n+  /** Unit test for {@link RelCollations#collationsContainKeysOrderless(List, List)}. */", "originalCommit": "9cbb7c31d1e0b616792f15abf6c46646a1c61a1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyOTg2NA==", "url": "https://github.com/apache/calcite/pull/2006#discussion_r475829864", "bodyText": "Makes sense. Added the test.", "author": "amaliujia", "createdAt": "2020-08-24T19:00:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0ODkzNw=="}], "type": "inlineReview", "revised_code": {"commit": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "chunk": "diff --git a/core/src/test/java/org/apache/calcite/rel/RelCollationTest.java b/core/src/test/java/org/apache/calcite/rel/RelCollationTest.java\nindex 8fa9d8b21..703b2bd38 100644\n--- a/core/src/test/java/org/apache/calcite/rel/RelCollationTest.java\n+++ b/core/src/test/java/org/apache/calcite/rel/RelCollationTest.java\n\n@@ -85,7 +85,7 @@\n   }\n \n   /** Unit test for {@link RelCollations#collationsContainKeysOrderless(List, List)}. */\n-  @Test void testCollationContainsOrderless() {\n+  @Test void testCollationsContainKeysOrderless() {\n     final List<RelCollation> collations = Lists.newArrayList(collation(2, 3, 1));\n     assertThat(\n         RelCollations.collationsContainKeysOrderless(\n"}}, {"oid": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "url": "https://github.com/apache/calcite/commit/a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side.", "committedDate": "2020-08-24T22:12:44Z", "type": "commit"}, {"oid": "a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "url": "https://github.com/apache/calcite/commit/a1bbb09a5eee38621cf1bf8b1448a9f9f7255fa6", "message": "[CALCITE-4015] Pass through parent collation request on subset or superset of join keys for EnumerableMergeJoin.\n\nCollations can pass through even when required collations are subset or superset on join keys.\n\nFor subset case, collations must be extended to make sure join keys are all sorted. Collations must be the prefix of sort keys.\n\nFor superset case, collations must be either all defined on left join input, or right join input. Collations must be prefix of join keys. All collations can be pushed down to the side on which collations are fully defiend. Only collations that are defined on join keys can be pushed down to another side.", "committedDate": "2020-08-24T22:12:44Z", "type": "forcePushed"}]}