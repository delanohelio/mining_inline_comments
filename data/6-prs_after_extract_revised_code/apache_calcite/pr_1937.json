{"pr_number": 1937, "pr_title": "[CALCITE-3951] Support different string comparison based on SqlCollation", "pr_createdAt": "2020-04-22T10:20:07Z", "pr_url": "https://github.com/apache/calcite/pull/1937", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjg1OTc3OA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r412859778", "bodyText": "Not sure if there is a way to express String.CASE_INSENSITIVE_ORDER as an Expression... (for the moment using \"\".CASE_INSENSITIVE_ORDER as workaround)", "author": "rubenada", "createdAt": "2020-04-22T10:22:18Z", "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java", "diffHunk": "@@ -258,6 +264,85 @@\n         .returnsUnordered(\"empid=100\\nempid=110\\nempid=150\\nempid=200\");\n   }\n \n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),", "originalCommit": "df564c0ed2780784b61c25c81f567e18c14577b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java b/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java\nindex 79e798ad3..c8a20bcc3 100644\n--- a/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java\n+++ b/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableJoinTest.java\n\n@@ -264,85 +258,6 @@\n         .returnsUnordered(\"empid=100\\nempid=110\\nempid=150\\nempid=200\");\n   }\n \n-  private static final SqlCollation NO_CASE =\n-      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n-          SqlCollation.Coercibility.IMPLICIT) {\n-        @Override public Comparator getComparator() {\n-          return String.CASE_INSENSITIVE_ORDER;\n-        }\n-        @Override public Expression getComparatorExpression() {\n-          return Expressions.field(Expressions.constant(\"\", String.class),\n-              \"CASE_INSENSITIVE_ORDER\");\n-        }\n-      };\n-\n-  @Test void testSortNoCase() {\n-    tester(false, new JdbcTest.HrSchema())\n-        .query(\"?\")\n-        .withRel(builder -> builder\n-            .values(\n-                builder.getTypeFactory().builder()\n-                    .add(\n-                        \"name\",\n-                        builder.getTypeFactory().createTypeWithCharsetAndCollation(\n-                            builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n-                            builder.getTypeFactory().getDefaultCharset(),\n-                            NO_CASE))\n-                    .build(),\n-                \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\")\n-            .sort(\n-                builder.field(1, 0, \"name\"))\n-            .build())\n-        .explainHookMatches(\"\"\n-            + \"EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n-            + \"  EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\")\n-        .returnsOrdered(\"name=Administration\\n\"\n-            + \"name=hr\\n\"\n-            + \"name=Legal\\n\"\n-            + \"name=MARKETING\\n\"\n-            + \"name=presales\");\n-  }\n-\n-  @Test void testSortMergeJoinOnStringNoCase() {\n-    tester(false, new JdbcTest.HrSchema())\n-        .query(\"?\")\n-        .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {\n-          planner.addRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n-          planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);\n-        })\n-        .withRel(builder -> builder\n-            .values(\n-                builder.getTypeFactory().builder()\n-                    .add(\n-                        \"name\",\n-                        builder.getTypeFactory().createTypeWithCharsetAndCollation(\n-                            builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n-                            builder.getTypeFactory().getDefaultCharset(),\n-                            NO_CASE))\n-                    .build(),\n-                \"Administration\", \"MARKETING\", \"Legal\", \"hr\", \"presales\")\n-            .scan(\"s\", \"depts\")\n-            .join(JoinRelType.INNER,\n-                builder.equals(\n-                    builder.field(2, 0, \"name\"),\n-                    builder.field(2, 1, \"name\")))\n-            .project(\n-                builder.field(1, 0, \"name\"),\n-                builder.alias(builder.field(1, \"depts\", \"name\"), \"dept_name\"),\n-                builder.field(1, \"depts\", \"deptno\"))\n-            .build())\n-        .explainHookMatches(\"\" // It is important that we have MergeJoin in the plan\n-            + \"EnumerableCalc(expr#0..2=[{inputs}], name=[$t0], dept_name=[$t2], deptno=[$t1])\\n\"\n-            + \"  EnumerableMergeJoin(condition=[=($0, $2)], joinType=[inner])\\n\"\n-            + \"    EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n-            + \"      EnumerableValues(tuples=[[{ 'Administration' }, { 'MARKETING' }, { 'Legal' }, { 'hr' }, { 'presales' }]])\\n\"\n-            + \"    EnumerableSort(sort0=[$1], dir0=[ASC])\\n\"\n-            + \"      EnumerableCalc(expr#0..3=[{inputs}], proj#0..1=[{exprs}])\\n\"\n-            + \"        EnumerableTableScan(table=[[s, depts]])\\n\")\n-        .returnsOrdered(\"name=hr; dept_name=HR; deptno=40\\n\"\n-            + \"name=MARKETING; dept_name=Marketing; deptno=30\");\n-  }\n-\n   /** Test case for\n    * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3820\">[CALCITE-3820]\n    * EnumerableDefaults#orderBy should be lazily computed + support enumerator\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415611799", "bodyText": "Having a linq4j.tree.Expression in this level seems a bit weird. I don't remember any other class in the sql package having dependencies to linq4j. Moreover, for those projects that do not rely on Enumerable this method is a bit useless.", "author": "zabetak", "createdAt": "2020-04-27T08:24:12Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {\n+    return null;\n+  }\n+\n+  /**\n+   * @return Comparator expression to be used, or null if no special comparator is required.\n+   */\n+  public Expression getComparatorExpression() {", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyMTM1Ng==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415721356", "bodyText": "I agree. I guess a cleaner solution would be having an EnumerableSqlCollation extends SqlCollation and having this method in there?", "author": "rubenada", "createdAt": "2020-04-27T11:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NTY1Nw==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416155657", "bodyText": "@zabetak I removed the Expression dependency and created an auxiliary method in EnumUtils to generate the expression for a certain SqlCollation's collator", "author": "rubenada", "createdAt": "2020-04-27T21:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxMTc5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\nindex 3ecd06386..f1e336645 100644\n--- a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n\n@@ -282,17 +296,16 @@ public final String getCollationName() {\n     return coercibility;\n   }\n \n-  /**\n-   * @return Comparator to be used, or null if no special comparator is required.\n-   */\n-  public Comparator<String> getComparator() {\n-    return null;\n+  public final Locale getLocale() {\n+    return locale;\n   }\n \n   /**\n-   * @return Comparator expression to be used, or null if no special comparator is required.\n+   * @return the {@link Collator} to compare values having the current collation,\n+   * or {@code null} if no specific {@link Collator} is needed, in which case\n+   * {@link String#compareTo} will be used.\n    */\n-  public Expression getComparatorExpression() {\n+  public Collator getCollator() {\n     return null;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxNDAyMw==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415614023", "bodyText": "Is it better to return a Comparator or Collator? If we need to generate collation keys in other places then maybe the second option is preferable.", "author": "zabetak", "createdAt": "2020-04-27T08:27:18Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+\n+  /**\n+   * @return Comparator to be used, or null if no special comparator is required.\n+   */\n+  public Comparator<String> getComparator() {", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NTk4NQ==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416155985", "bodyText": "Collator will give us more possibilities. Changed into Collator.", "author": "rubenada", "createdAt": "2020-04-27T21:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxNDAyMw=="}], "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\nindex 3ecd06386..f1e336645 100644\n--- a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n\n@@ -282,17 +296,16 @@ public final String getCollationName() {\n     return coercibility;\n   }\n \n-  /**\n-   * @return Comparator to be used, or null if no special comparator is required.\n-   */\n-  public Comparator<String> getComparator() {\n-    return null;\n+  public final Locale getLocale() {\n+    return locale;\n   }\n \n   /**\n-   * @return Comparator expression to be used, or null if no special comparator is required.\n+   * @return the {@link Collator} to compare values having the current collation,\n+   * or {@code null} if no specific {@link Collator} is needed, in which case\n+   * {@link String#compareTo} will be used.\n    */\n-  public Expression getComparatorExpression() {\n+  public Collator getCollator() {\n     return null;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415619166", "bodyText": "The newly added method indicate that projects should rely on inheritance to define a new collation but the documentation doesn't say so. Moreover, I get the feeling that this information is not an extension but really part of this class.\nUsing inheritance brings up questions like what happens with equals and hashCode? Should the comparator be part of it?", "author": "zabetak", "createdAt": "2020-04-27T08:34:54Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -279,4 +281,18 @@ public final String getCollationName() {\n   public final SqlCollation.Coercibility getCoercibility() {\n     return coercibility;\n   }\n+", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NjYyMg==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416156622", "bodyText": "Refactored, inheritance no longer needed.\nCollator is now extracted from Locale and strength (so it implicitly becomes part of the equals / hashCode)", "author": "rubenada", "createdAt": "2020-04-27T21:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODk0Ng==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r417928946", "bodyText": "Re-refactored, and back to inheritance (JavaCollation extends SqlCollation), but equals/hashCode should work fine in that case too.", "author": "rubenada", "createdAt": "2020-04-30T11:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYxOTE2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\nindex 3ecd06386..f1e336645 100644\n--- a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n\n@@ -282,17 +296,16 @@ public final String getCollationName() {\n     return coercibility;\n   }\n \n-  /**\n-   * @return Comparator to be used, or null if no special comparator is required.\n-   */\n-  public Comparator<String> getComparator() {\n-    return null;\n+  public final Locale getLocale() {\n+    return locale;\n   }\n \n   /**\n-   * @return Comparator expression to be used, or null if no special comparator is required.\n+   * @return the {@link Collator} to compare values having the current collation,\n+   * or {@code null} if no specific {@link Collator} is needed, in which case\n+   * {@link String#compareTo} will be used.\n    */\n-  public Expression getComparatorExpression() {\n+  public Collator getCollator() {\n     return null;\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyNjExMg==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415626112", "bodyText": "This test is similar to the logic of SqlOperatorBaseTest. Could we move things there? Are there things that we could reuse?", "author": "zabetak", "createdAt": "2020-04-27T08:44:53Z", "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.test.enumerable;\n+\n+import org.apache.calcite.adapter.enumerable.EnumerableRules;\n+import org.apache.calcite.adapter.java.ReflectiveSchema;\n+import org.apache.calcite.config.CalciteConnectionProperty;\n+import org.apache.calcite.config.CalciteSystemProperty;\n+import org.apache.calcite.config.Lex;\n+import org.apache.calcite.linq4j.tree.Expression;\n+import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.runtime.Hook;\n+import org.apache.calcite.sql.SqlCollation;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.fun.SqlStdOperatorTable;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.test.CalciteAssert;\n+import org.apache.calcite.test.JdbcTest;\n+import org.apache.calcite.tools.RelBuilder;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Test cases for\n+ * <a href=\"https://issues.apache.org/jira/browse/CALCITE-3951\">[CALCITE-3951]\n+ * Support different string comparison based on SqlCollation</a>.\n+ */\n+class EnumerableStringComparisonTest {\n+\n+  private static final SqlCollation NO_CASE =\n+      new SqlCollation(CalciteSystemProperty.DEFAULT_COLLATION.value() + \"-NO_CASE\",\n+          SqlCollation.Coercibility.IMPLICIT) {\n+        @Override public Comparator<String> getComparator() {\n+          return String.CASE_INSENSITIVE_ORDER;\n+        }\n+        @Override public Expression getComparatorExpression() {\n+          return Expressions.field(Expressions.constant(\"\", String.class),\n+              \"CASE_INSENSITIVE_ORDER\");\n+        }\n+  };\n+\n+  private RelDataType createRecordVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().builder()\n+        .add(\n+            \"name\",\n+            builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+                builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+                builder.getTypeFactory().getDefaultCharset(),\n+                NO_CASE))\n+        .build();\n+  }\n+\n+  private RelDataType createVarcharNoCase(RelBuilder builder) {\n+    return builder.getTypeFactory().createTypeWithCharsetAndCollation(\n+        builder.getTypeFactory().createSqlType(SqlTypeName.VARCHAR),\n+        builder.getTypeFactory().getDefaultCharset(),\n+        NO_CASE);\n+  }\n+\n+  @Test void testSortNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withRel(builder -> builder\n+            .values(\n+                createRecordVarcharNoCase(builder),\n+                \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\")\n+            .sort(\n+                builder.field(1, 0, \"name\"))\n+            .build())\n+        .explainHookMatches(\"\"\n+            + \"EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"  EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\")\n+        .returnsOrdered(\"name=Administration\\n\"\n+            + \"name=hr\\n\"\n+            + \"name=Legal\\n\"\n+            + \"name=MARKETING\\n\"\n+            + \"name=presales\");\n+  }\n+\n+  @Test void testMergeJoinOnStringNoCase() {\n+    tester()\n+        .query(\"?\")\n+        .withHook(Hook.PLANNER, (Consumer<RelOptPlanner>) planner -> {\n+          planner.addRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n+          planner.removeRule(EnumerableRules.ENUMERABLE_JOIN_RULE);\n+        })\n+        .withRel(builder -> builder\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Legal\", \"presales\", \"hr\", \"Administration\", \"MARKETING\").as(\"v1\")\n+              .values(createRecordVarcharNoCase(builder),\n+                  \"Marketing\", \"bureaucracy\", \"Sales\", \"HR\").as(\"v2\")\n+              .join(JoinRelType.INNER,\n+                  builder.equals(\n+                      builder.field(2, 0, \"name\"),\n+                      builder.field(2, 1, \"name\")))\n+              .project(\n+                  builder.field(\"v1\", \"name\"),\n+                  builder.field(\"v2\", \"name\"))\n+              .build())\n+        .explainHookMatches(\"\" // It is important that we have MergeJoin in the plan\n+            + \"EnumerableMergeJoin(condition=[=($0, $1)], joinType=[inner])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Legal' }, { 'presales' }, { 'hr' }, { 'Administration' }, { 'MARKETING' }]])\\n\"\n+            + \"  EnumerableSort(sort0=[$0], dir0=[ASC])\\n\"\n+            + \"    EnumerableValues(tuples=[[{ 'Marketing' }, { 'bureaucracy' }, { 'Sales' }, { 'HR' }]])\\n\")\n+        .returnsOrdered(\"name=hr; name0=HR\\n\"\n+            + \"name=MARKETING; name0=Marketing\");\n+  }\n+\n+  @Test void testStringComparison() {", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODIxOA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r417928218", "bodyText": "SqlOperatorBaseTest is based on Sql strings, this tests requires RelBuilder (since JavaCollation cannot be extracted from sql string), so for the moment it cannot be moved there.", "author": "rubenada", "createdAt": "2020-04-30T11:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYyNjExMg=="}], "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java b/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java\nindex 54c1071ec..102780779 100644\n--- a/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java\n+++ b/core/src/test/java/org/apache/calcite/test/enumerable/EnumerableStringComparisonTest.java\n\n@@ -19,10 +19,8 @@\n import org.apache.calcite.adapter.enumerable.EnumerableRules;\n import org.apache.calcite.adapter.java.ReflectiveSchema;\n import org.apache.calcite.config.CalciteConnectionProperty;\n-import org.apache.calcite.config.CalciteSystemProperty;\n import org.apache.calcite.config.Lex;\n-import org.apache.calcite.linq4j.tree.Expression;\n-import org.apache.calcite.linq4j.tree.Expressions;\n+import org.apache.calcite.jdbc.JavaCollation;\n import org.apache.calcite.plan.RelOptPlanner;\n import org.apache.calcite.rel.core.JoinRelType;\n import org.apache.calcite.rel.type.RelDataType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTIxNg==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415631216", "bodyText": "Collations are compared with equals but is the Comparator part of the equals? Should it be?", "author": "zabetak", "createdAt": "2020-04-27T08:52:06Z", "path": "core/src/main/java/org/apache/calcite/rex/RexBuilder.java", "diffHunk": "@@ -919,9 +919,12 @@ protected RexLiteral makeLiteral(\n       // from the type if necessary.\n       assert o instanceof NlsString;\n       NlsString nlsString = (NlsString) o;\n-      if ((nlsString.getCollation() == null)\n-          || (nlsString.getCharset() == null)) {\n-        assert type.getSqlTypeName() == SqlTypeName.CHAR;\n+      if (nlsString.getCollation() == null\n+          || nlsString.getCharset() == null\n+          || !nlsString.getCharset().equals(type.getCharset())\n+          || !nlsString.getCollation().equals(type.getCollation())) {", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NzQ3NA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416157474", "bodyText": "Collator is now extracted from SqlCollation's Locale and strength (so it implicitly becomes part of the equals / hashCode)", "author": "rubenada", "createdAt": "2020-04-27T21:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzMTIxNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTI5OA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415639298", "bodyText": "Possibly we could deprecate/remove the old methods (e.g., le(String b0, String b1) and always use the new alternatives with the Comparator. When we don't have one we could use String::compareTo or Comparator.naturalOrder to have the same behavior as before.", "author": "zabetak", "createdAt": "2020-04-27T09:03:21Z", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -730,6 +743,11 @@ public static boolean le(String b0, String b1) {\n     return b0.compareTo(b1) <= 0;\n   }\n \n+  /** SQL <code>&le;</code> operator applied to String values. */", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyODQxNA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r417928414", "bodyText": "I prefer to leave them for backwards compatibility", "author": "rubenada", "createdAt": "2020-04-30T11:00:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTYzOTI5OA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MDMzOQ==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415640339", "bodyText": "Normally we should call this method only with parameters of type String. Why do we need Object?", "author": "zabetak", "createdAt": "2020-04-27T09:04:50Z", "path": "core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java", "diffHunk": "@@ -638,6 +639,13 @@ public static boolean eq(Object b0, Object b1) {\n     return b0.equals(b1);\n   }\n \n+  /** SQL <code>=</code> operator applied to Object values (including String;\n+   * neither side may be null). */\n+  public static boolean eq(Object b0, Object b1, Comparator comparator) {", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1NzA2MA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416157060", "bodyText": "Parameters modified.", "author": "rubenada", "createdAt": "2020-04-27T21:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY0MDMzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java b/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java\nindex eaa8cc92d..04e7b60d8 100644\n--- a/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java\n+++ b/core/src/main/java/org/apache/calcite/runtime/SqlFunctions.java\n\n@@ -639,11 +639,9 @@ public static boolean eq(Object b0, Object b1) {\n     return b0.equals(b1);\n   }\n \n-  /** SQL <code>=</code> operator applied to Object values (including String;\n-   * neither side may be null). */\n-  public static boolean eq(Object b0, Object b1, Comparator comparator) {\n-    //noinspection unchecked\n-    return comparator.compare(b0, b1) == 0;\n+  /** SQL <code>=</code> operator applied to String values with a certain Comparator. */\n+  public static boolean eq(String s0, String s1, Comparator<String> comparator) {\n+    return comparator.compare(s0, s1) == 0;\n   }\n \n   /** SQL <code>=</code> operator applied to Object values (at least one operand\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MjY0MA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r415652640", "bodyText": "Do we need all this new variants? Note that there are also the standard java methods Comparator.nullsFirst and Comparator.nullsLast.\nIf we have a Comparator at hand then we could directly generate the code:\nComparator nfc = Comparator.nullsFirst(comparator);\nnfc.compare(v0, v1);\n\nI don't see clearly why we need to use the Utilties redirection in this case.", "author": "zabetak", "createdAt": "2020-04-27T09:22:51Z", "path": "core/src/main/java/org/apache/calcite/runtime/Utilities.java", "diffHunk": "@@ -212,6 +213,27 @@ public static int compareNullsLast(Comparable v0, Comparable v1) {\n                 : v0.compareTo(v1);\n   }\n \n+  public static int compare(Comparable v0, Comparable v1, Comparator comparator) {", "originalCommit": "9d76a623a142ce92366bcf345c4e39c7097ba4d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjE1OTQ5NQ==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r416159495", "bodyText": "These methods help us to have a compact and homogeneous code in PhysTypeImpl.java, where \"complex\" comparator expressions can be generated, combining e.g. numeric keys (without comparator), with String keys (with comparator).", "author": "rubenada", "createdAt": "2020-04-27T21:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY1MjY0MA=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzA2OA==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r418453068", "bodyText": "The description here needs some modifications.", "author": "XuQianJin-Stars", "createdAt": "2020-05-01T07:57:18Z", "path": "core/src/main/java/org/apache/calcite/sql/SqlCollation.java", "diffHunk": "@@ -356,8 +302,9 @@ public final Locale getLocale() {\n \n   /**\n    * @return Collator to be used for comparison, or null if no specific collator is defined", "originalCommit": "6858b37421c9fa6502fb11b7f75303bc86ccd605", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY3NTI5Mg==", "url": "https://github.com/apache/calcite/pull/1937#discussion_r418675292", "bodyText": "Thanks for your feedback @XuQianJin-Stars , you are right.\nI have re-worked the javadoc, let me know what you think.", "author": "rubenada", "createdAt": "2020-05-01T18:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ1MzA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\nindex d38e92c4e..f1e336645 100644\n--- a/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n+++ b/core/src/main/java/org/apache/calcite/sql/SqlCollation.java\n\n@@ -301,8 +301,9 @@ public final Locale getLocale() {\n   }\n \n   /**\n-   * @return Collator to be used for comparison, or null if no specific collator is defined\n-   * (in which case {@link String#compareTo} will be used).\n+   * @return the {@link Collator} to compare values having the current collation,\n+   * or {@code null} if no specific {@link Collator} is needed, in which case\n+   * {@link String#compareTo} will be used.\n    */\n   public Collator getCollator() {\n     return null;\n"}}, {"oid": "9c1943c5403b2c2d29390e6a29036166208f9ca6", "url": "https://github.com/apache/calcite/commit/9c1943c5403b2c2d29390e6a29036166208f9ca6", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation", "committedDate": "2020-05-11T11:09:58Z", "type": "forcePushed"}, {"oid": "d1968a0753fe8dfbf12b695799df22b07d957337", "url": "https://github.com/apache/calcite/commit/d1968a0753fe8dfbf12b695799df22b07d957337", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation", "committedDate": "2020-06-02T15:09:22Z", "type": "forcePushed"}, {"oid": "5f79a6bf801a17b8517f845230426f84014c992d", "url": "https://github.com/apache/calcite/commit/5f79a6bf801a17b8517f845230426f84014c992d", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation", "committedDate": "2020-06-03T07:46:44Z", "type": "commit"}, {"oid": "5f79a6bf801a17b8517f845230426f84014c992d", "url": "https://github.com/apache/calcite/commit/5f79a6bf801a17b8517f845230426f84014c992d", "message": "[CALCITE-3951] Support different string comparison based on SqlCollation", "committedDate": "2020-06-03T07:46:44Z", "type": "forcePushed"}]}