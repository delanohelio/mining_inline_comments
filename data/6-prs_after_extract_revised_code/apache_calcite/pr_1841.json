{"pr_number": 1841, "pr_title": "Following CALCITE-3769: Add BindableTableScanRule into the default ru\u2026", "pr_createdAt": "2020-03-02T06:58:25Z", "pr_url": "https://github.com/apache/calcite/pull/1841", "timeline": [{"oid": "f4fd221c6b6f6322b1c07796b3e7d6acea8aba11", "url": "https://github.com/apache/calcite/commit/f4fd221c6b6f6322b1c07796b3e7d6acea8aba11", "message": "Following CALCITE-3769: Add BindableTableScanRule into the default ruleset\n\n* Add BindableTableScanRule into the default ruleset, so there are 2\ntable implementations, the planner would choose the one with cheaper\ncost\n* Fix the cost estimation of BindableTableScan if there are no pushings\n* Allows the Scannable table to have the EnumerableTableScan as impl", "committedDate": "2020-03-02T07:04:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNjAxMA==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386226010", "bodyText": "Is this indentation change required?", "author": "vlsi", "createdAt": "2020-03-02T07:12:26Z", "path": "core/src/test/java/org/apache/calcite/test/StreamTest.java", "diffHunk": "@@ -286,12 +286,11 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz\n             + \"      LogicalTableScan(table=[[STREAM_JOINS, PRODUCTS]])\\n\")\n         .explainContains(\"\"\n             + \"EnumerableCalc(expr#0..6=[{inputs}], proj#0..1=[{exprs}], SUPPLIERID=[$t6])\\n\"\n-            + \"  EnumerableHashJoin(condition=[=($4, $5)], joinType=[inner])\\n\"\n-            + \"    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) NOT NULL], proj#0..4=[{exprs}])\\n\"\n-            + \"      EnumerableInterpreter\\n\"\n-            + \"        BindableTableScan(table=[[STREAM_JOINS, ORDERS, (STREAM)]])\\n\"\n-            + \"    EnumerableInterpreter\\n\"\n-            + \"      BindableTableScan(table=[[STREAM_JOINS, PRODUCTS]])\")\n+                + \"  EnumerableHashJoin(condition=[=($4, $5)], joinType=[inner])\\n\"", "originalCommit": "f4fd221c6b6f6322b1c07796b3e7d6acea8aba11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyOTY2MQ==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386229661", "bodyText": "No, would fire a fix", "author": "danny0405", "createdAt": "2020-03-02T07:25:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNjAxMA=="}], "type": "inlineReview", "revised_code": {"commit": "7cb4f44e291386430ca41972e57470d67f7c8fe2", "chunk": "diff --git a/core/src/test/java/org/apache/calcite/test/StreamTest.java b/core/src/test/java/org/apache/calcite/test/StreamTest.java\nindex 971aac15e..9f9326f87 100644\n--- a/core/src/test/java/org/apache/calcite/test/StreamTest.java\n+++ b/core/src/test/java/org/apache/calcite/test/StreamTest.java\n\n@@ -286,11 +286,11 @@ private static String schemaFor(String name, Class<? extends TableFactory> clazz\n             + \"      LogicalTableScan(table=[[STREAM_JOINS, PRODUCTS]])\\n\")\n         .explainContains(\"\"\n             + \"EnumerableCalc(expr#0..6=[{inputs}], proj#0..1=[{exprs}], SUPPLIERID=[$t6])\\n\"\n-                + \"  EnumerableHashJoin(condition=[=($4, $5)], joinType=[inner])\\n\"\n-                + \"    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) NOT NULL], proj#0..4=[{exprs}])\\n\"\n-                + \"      EnumerableInterpreter\\n\"\n-                + \"        BindableTableScan(table=[[STREAM_JOINS, ORDERS, (STREAM)]])\\n\"\n-                + \"    EnumerableTableScan(table=[[STREAM_JOINS, PRODUCTS]])\")\n+            + \"  EnumerableHashJoin(condition=[=($4, $5)], joinType=[inner])\\n\"\n+            + \"    EnumerableCalc(expr#0..3=[{inputs}], expr#4=[CAST($t2):VARCHAR(32) NOT NULL], proj#0..4=[{exprs}])\\n\"\n+            + \"      EnumerableInterpreter\\n\"\n+            + \"        BindableTableScan(table=[[STREAM_JOINS, ORDERS, (STREAM)]])\\n\"\n+            + \"    EnumerableTableScan(table=[[STREAM_JOINS, PRODUCTS]])\")\n         .returns(\n             startsWith(\"ROWTIME=2015-02-15 10:15:00; ORDERID=1; SUPPLIERID=1\",\n                 \"ROWTIME=2015-02-15 10:24:15; ORDERID=2; SUPPLIERID=0\",\n"}}, {"oid": "7cb4f44e291386430ca41972e57470d67f7c8fe2", "url": "https://github.com/apache/calcite/commit/7cb4f44e291386430ca41972e57470d67f7c8fe2", "message": "Following CALCITE-3769: Add BindableTableScanRule into the default ruleset\n\n* Add BindableTableScanRule into the default ruleset, so there are 2\ntable implementations, the planner would choose the one with cheaper\ncost\n* Fix the cost estimation of BindableTableScan if there are no pushings\n* Allows the Scannable table to have the EnumerableTableScan as impl", "committedDate": "2020-03-02T07:41:21Z", "type": "forcePushed"}, {"oid": "656896ca9a28b5649742d55eb2635e1f7a0f0499", "url": "https://github.com/apache/calcite/commit/656896ca9a28b5649742d55eb2635e1f7a0f0499", "message": "Following CALCITE-3769: Add BindableTableScanRule into the default ruleset\n\n* Add BindableTableScanRule into the default ruleset, so there are 2\ntable implementations, the planner would choose the one with cheaper\ncost\n* Fix the cost estimation of BindableTableScan if there are no pushings\n* Allows the Scannable table to have the EnumerableTableScan as impl\n* For CsvTable and JsonTable in the example module, decoupling the logic\nof runtime from Table#getRowType, so that these tables can implement as\nENUMERABLE convention(when there are no pushings)", "committedDate": "2020-03-02T10:13:47Z", "type": "commit"}, {"oid": "656896ca9a28b5649742d55eb2635e1f7a0f0499", "url": "https://github.com/apache/calcite/commit/656896ca9a28b5649742d55eb2635e1f7a0f0499", "message": "Following CALCITE-3769: Add BindableTableScanRule into the default ruleset\n\n* Add BindableTableScanRule into the default ruleset, so there are 2\ntable implementations, the planner would choose the one with cheaper\ncost\n* Fix the cost estimation of BindableTableScan if there are no pushings\n* Allows the Scannable table to have the EnumerableTableScan as impl\n* For CsvTable and JsonTable in the example module, decoupling the logic\nof runtime from Table#getRowType, so that these tables can implement as\nENUMERABLE convention(when there are no pushings)", "committedDate": "2020-03-02T10:13:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMxMjk5MQ==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386312991", "bodyText": "Instead of adding this code snippet, wouldn't be sufficient to just remove the factor 0.01d from the multiplier in line 253?", "author": "zabetak", "createdAt": "2020-03-02T10:33:57Z", "path": "core/src/main/java/org/apache/calcite/interpreter/Bindables.java", "diffHunk": "@@ -234,6 +234,11 @@ public static BindableTableScan create(RelOptCluster cluster,\n \n     @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n         RelMetadataQuery mq) {\n+      boolean noPushing = filters.isEmpty()\n+              && projects.size() == table.getRowType().getFieldCount();\n+      if (noPushing) {\n+        return super.computeSelfCost(planner, mq);\n+      }", "originalCommit": "656896ca9a28b5649742d55eb2635e1f7a0f0499", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMxNTk2Mg==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386315962", "bodyText": "No, we should give a preference though, so that the planner would choose BindableTableScan instead of EnumerabeTableScan, without this factor(0.01d), the BindableTableScan would never be choosed if the BindableTableScan has an expression and also pushings.", "author": "danny0405", "createdAt": "2020-03-02T10:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMxMjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MDg5Ng==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386340896", "bodyText": "Aren't the factors f and p sufficient for achieving this?", "author": "zabetak", "createdAt": "2020-03-02T11:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMxMjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MjYxNw==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386352617", "bodyText": "Yes, the 0.01d factor would ensure that we choose the BindableTableScan if we have any pushing projects or filter. The EnumerableInterpreter has another 0.5 overhead of the input table.", "author": "danny0405", "createdAt": "2020-03-02T12:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMxMjk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MzMzNA==", "url": "https://github.com/apache/calcite/pull/1841#discussion_r386353334", "bodyText": "This is our current choice, the cost estimation is not that accurate and we would rather to give some preference.\nFor example, why the factor of EnumerableInterpreter  is 0.5 ?", "author": "danny0405", "createdAt": "2020-03-02T12:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMxMjk5MQ=="}], "type": "inlineReview", "revised_code": null}]}