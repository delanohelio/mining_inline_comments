{"pr_number": 2016, "pr_title": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equa\u2026", "pr_createdAt": "2020-06-09T13:21:55Z", "pr_url": "https://github.com/apache/calcite/pull/2016", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDgxNw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r437420817", "bodyText": "This seems to be resource-consuming. Should the result is not cached in the constructor?", "author": "vlsi", "createdAt": "2020-06-09T13:34:46Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents));\n+  }\n+\n+  private static Object[] collect(RelNode rel, List<Pair<String, Object>> contents) {", "originalCommit": "2039685a7280cf647f194fca9784ae9879560d19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwNTkwOA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r437505908", "bodyText": "This is used to resolve the hash code conflict, which expects to be rare case,  the cache would not bring much.", "author": "danny0405", "createdAt": "2020-06-09T15:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczMDE3Mg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r438730172", "bodyText": "equals is always executed (== in case hashCode matches), and equals would be called multiple times in case of a hash collision, so it is worth making both equals and hashCode fast.", "author": "vlsi", "createdAt": "2020-06-11T11:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNDA4Ng==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r438734086", "bodyText": "I run all the cases and there are only 8 tests that have hash conflict, i would try to promote.", "author": "danny0405", "createdAt": "2020-06-11T12:04:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI4MDMwMA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439280300", "bodyText": "Finally i decide to keep it as is, because the conflict is very few, i also remove the row type when computing hashcode, because row type diff for equiv node is also rare case(usually because of nullability changes).", "author": "danny0405", "createdAt": "2020-06-12T08:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQyMDgxNw=="}], "type": "inlineReview", "revised_code": {"commit": "545743d9db35eaeb45e8310ae050d3891c8602de", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/plan/Digest.java b/core/src/main/java/org/apache/calcite/plan/Digest.java\nindex ab197fd43..dba48017e 100644\n--- a/core/src/main/java/org/apache/calcite/plan/Digest.java\n+++ b/core/src/main/java/org/apache/calcite/plan/Digest.java\n\n@@ -88,10 +88,27 @@ private Digest(RelNode rel, String digest) {\n \n   /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n   private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n-    return Objects.hash(collect(rel, contents));\n+    return Objects.hash(collect(rel, contents, false));\n   }\n \n-  private static Object[] collect(RelNode rel, List<Pair<String, Object>> contents) {\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n     List<Object> hashCodeItems = new ArrayList<>();\n     // The type name.\n     hashCodeItems.add(rel.getRelTypeName());\n"}}, {"oid": "828435697ce7679736aff2824d7e6f184903e3b7", "url": "https://github.com/apache/calcite/commit/828435697ce7679736aff2824d7e6f184903e3b7", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;", "committedDate": "2020-06-12T04:12:03Z", "type": "forcePushed"}, {"oid": "a51dc0709518d8626d48dede830589f5254dfcd3", "url": "https://github.com/apache/calcite/commit/a51dc0709518d8626d48dede830589f5254dfcd3", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;", "committedDate": "2020-06-12T05:39:14Z", "type": "forcePushed"}, {"oid": "02eebf905cc0689f684fad3a3bab8ec6da040abe", "url": "https://github.com/apache/calcite/commit/02eebf905cc0689f684fad3a3bab8ec6da040abe", "message": "Change RexCall to use object#equals instead of pure string digest compare\n\n* We only support RexInputRef and RexLiteral normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing comlicated,\nRexNode can always be normalized;", "committedDate": "2020-06-12T07:41:16Z", "type": "forcePushed"}, {"oid": "545743d9db35eaeb45e8310ae050d3891c8602de", "url": "https://github.com/apache/calcite/commit/545743d9db35eaeb45e8310ae050d3891c8602de", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-12T08:22:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439504428", "bodyText": "This breaks the contract that if 2 objects are equal, then the method should return 0.", "author": "laurentgo", "createdAt": "2020-06-12T15:57:40Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {\n+      RelSubset subset = (RelSubset) rel;\n+      digest.append(subset.getSetId());\n+      for (RelTrait trait : subset.getTraitSet()) {\n+        digest.append('.').append(trait);\n+      }\n+    } else if (rel instanceof HepRelVertex) {\n+      digest.append(((HepRelVertex) rel).getCurrentRel().getId());\n+    } else {\n+      digest.append(rel.getId());\n+    }\n+    return digest.toString();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(Digest other) {\n+    return this.rel.getId() - other.rel.getId();", "originalCommit": "545743d9db35eaeb45e8310ae050d3891c8602de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjQ4OA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439692488", "bodyText": "This is only for debugging, strictly to say, i have no idea how to compare 2 nodes that are semantically equivalent (#equals) while have different members.", "author": "danny0405", "createdAt": "2020-06-13T00:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MzYxNA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439693614", "bodyText": "why is Comparable needed for debugging? Right now, I don't see how debuggability can justify breaking the contract", "author": "laurentgo", "createdAt": "2020-06-13T00:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwOTg5Mw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439909893", "bodyText": "Well, i have fixed the consistency of #equals.", "author": "danny0405", "createdAt": "2020-06-15T03:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5OTE0Nw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440999147", "bodyText": "Maybe it would have been simpler not to implement Comparable? You didn't clarify why this is needed for debugging purposes...", "author": "laurentgo", "createdAt": "2020-06-16T16:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMzM0OA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442113348", "bodyText": "That was proposed initially by Julian in the issue, i think it is needed when we want to sort on that.", "author": "danny0405", "createdAt": "2020-06-18T10:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDQyOA=="}], "type": "inlineReview", "revised_code": {"commit": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/plan/Digest.java b/core/src/main/java/org/apache/calcite/plan/Digest.java\nindex dba48017e..4525226d4 100644\n--- a/core/src/main/java/org/apache/calcite/plan/Digest.java\n+++ b/core/src/main/java/org/apache/calcite/plan/Digest.java\n\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import javax.annotation.Nonnull;\n \n /**\n  * A short description of relational expression's type, inputs, and\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439506332", "bodyText": "The whole check + loop could be replaced with Arrays.equals(Object[], Object[])", "author": "laurentgo", "createdAt": "2020-06-12T16:01:17Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {\n+      RelSubset subset = (RelSubset) rel;\n+      digest.append(subset.getSetId());\n+      for (RelTrait trait : subset.getTraitSet()) {\n+        digest.append('.').append(trait);\n+      }\n+    } else if (rel instanceof HepRelVertex) {\n+      digest.append(((HepRelVertex) rel).getCurrentRel().getId());\n+    } else {\n+      digest.append(rel.getId());\n+    }\n+    return digest.toString();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(Digest other) {\n+    return this.rel.getId() - other.rel.getId();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Digest that = (Digest) o;\n+    return hashCode == that.hashCode && deepEquals(that);\n+  }\n+\n+  /**\n+   * The method is used to resolve hash conflict, in current 6000+ tests, there are about 8\n+   * tests with conflict, so we do not cache the hash code items in order to\n+   * reduce mem consumption.\n+   */\n+  private boolean deepEquals(Digest other) {\n+    Object[] thisItems = collect(this.rel, this.items, true);\n+    Object[] thatItems = collect(other.rel, other.items, true);\n+    if (thisItems.length != thatItems.length) {", "originalCommit": "545743d9db35eaeb45e8310ae050d3891c8602de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjYyMg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439692622", "bodyText": "Sorry, i would choose current code because it's simpler.", "author": "danny0405", "createdAt": "2020-06-13T00:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MzcxNQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439693715", "bodyText": "are you telling that 9 lines are simpler that one line of code which is return Arrays.equals(thisItems, thatItems)?", "author": "laurentgo", "createdAt": "2020-06-13T00:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg5Nzg0Nw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439897847", "bodyText": "Did you see the code in Arrays.equals(thisItems, thatItems) ? Here the thisItems and thatItems are both never null.", "author": "danny0405", "createdAt": "2020-06-15T02:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MTU0Mw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440571543", "bodyText": "Considering null checks are often optimized out by the JVM, I'm not sure that the possible extra optimization is worth the extra code you wrote...", "author": "laurentgo", "createdAt": "2020-06-16T03:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTYzNA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440675634", "bodyText": "It is often but not always, if you are not sure also, let's keep it as it is, which is also straight-forward code.", "author": "danny0405", "createdAt": "2020-06-16T08:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDk5NzA3NQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440997075", "bodyText": "Sorry, I am at a loss for arguments. The original reply was that the code was simpler than Arrays.equals(Object[], Object[]), a standard JDK method, whereas in fact, it is basically the same code, except for the check for null, which is often suppressed by the JVM compiler (cf https://shipilev.net/jvm/anatomy-quarks/25-implicit-null-checks/) and even so has minimal impact compared to the two calls to the #collect method where a list is created and converted later into an array...", "author": "laurentgo", "createdAt": "2020-06-16T16:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNTU0NQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442105545", "bodyText": "The test here #2034 shows that there is negligible performance affect with ArrayList.toArray, so still, i would not follow you.", "author": "danny0405", "createdAt": "2020-06-18T09:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNjMzMg=="}], "type": "inlineReview", "revised_code": {"commit": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/plan/Digest.java b/core/src/main/java/org/apache/calcite/plan/Digest.java\nindex dba48017e..4525226d4 100644\n--- a/core/src/main/java/org/apache/calcite/plan/Digest.java\n+++ b/core/src/main/java/org/apache/calcite/plan/Digest.java\n\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import javax.annotation.Nonnull;\n \n /**\n  * A short description of relational expression's type, inputs, and\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439507991", "bodyText": "should Arrays.deepEquals be used if thisItems[i] is an array?", "author": "laurentgo", "createdAt": "2020-06-12T16:04:32Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {\n+      RelSubset subset = (RelSubset) rel;\n+      digest.append(subset.getSetId());\n+      for (RelTrait trait : subset.getTraitSet()) {\n+        digest.append('.').append(trait);\n+      }\n+    } else if (rel instanceof HepRelVertex) {\n+      digest.append(((HepRelVertex) rel).getCurrentRel().getId());\n+    } else {\n+      digest.append(rel.getId());\n+    }\n+    return digest.toString();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(Digest other) {\n+    return this.rel.getId() - other.rel.getId();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Digest that = (Digest) o;\n+    return hashCode == that.hashCode && deepEquals(that);\n+  }\n+\n+  /**\n+   * The method is used to resolve hash conflict, in current 6000+ tests, there are about 8\n+   * tests with conflict, so we do not cache the hash code items in order to\n+   * reduce mem consumption.\n+   */\n+  private boolean deepEquals(Digest other) {\n+    Object[] thisItems = collect(this.rel, this.items, true);\n+    Object[] thatItems = collect(other.rel, other.items, true);\n+    if (thisItems.length != thatItems.length) {\n+      return false;\n+    }\n+    for (int i = 0; i < thisItems.length; i++) {\n+      if (!Objects.equals(thisItems[i], thatItems[i])) {", "originalCommit": "545743d9db35eaeb45e8310ae050d3891c8602de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MzcwOA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439693708", "bodyText": "I checked all the rels, they all have no array attributes in the digest, even it has, the #equals would output false which does not affect the semantics. So i choose current impl.", "author": "danny0405", "createdAt": "2020-06-13T00:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MTYyMg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440571622", "bodyText": "for now? what about external rels?", "author": "laurentgo", "createdAt": "2020-06-16T03:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3ODE1Mg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440678152", "bodyText": "I said outputs false does not affect the semantics, then what's the problem there, i do not want to make the logic a mess just for a non-sure assumption.\nIf you have strong opinion, please give specific cases, only assumption makes no sense to me.", "author": "danny0405", "createdAt": "2020-06-16T08:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMjYwMg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r441022602", "bodyText": "Yes, there has some \"ifs\" there. There are 2 assumptions here as well:\n\nthere's no rel node using an array as a digest field, which is true for Calcite code, and probably true for code using the library although it's harder to verify\neven so, return false when 2 array contents are identical has no impact on the semantic.\n\nFor the first point, maybe a more opinionated choice could be to disallow arrays as digest item?\nFor the second point, I'm not sure that the assumption holds: if planner cannot identify that 2 rel nodes are identical (and so collapse them), it might cause some kind of infinite loop/plan explosion where the same node is created over and over.", "author": "laurentgo", "createdAt": "2020-06-16T17:30:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMTQ2Mg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442111462", "bodyText": "I don't think we should have any limitation on what should be a digest item just because of the digest code implementation\nDid we encounter any case that has infinite loop just because of an array item there ? I need to see the case to make decision, not an assumption. I prefer to fix that when we really encounter that,  i think such case would be very rare.", "author": "danny0405", "createdAt": "2020-06-18T09:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzk5MQ=="}], "type": "inlineReview", "revised_code": {"commit": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/plan/Digest.java b/core/src/main/java/org/apache/calcite/plan/Digest.java\nindex dba48017e..4525226d4 100644\n--- a/core/src/main/java/org/apache/calcite/plan/Digest.java\n+++ b/core/src/main/java/org/apache/calcite/plan/Digest.java\n\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import javax.annotation.Nonnull;\n \n /**\n  * A short description of relational expression's type, inputs, and\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439510726", "bodyText": "Why not let the rel node itself handle how to create the digest vs having a non-extendable/overridable method using different behaviors based on the type of rel to do it? This looks like an anti design pattern.", "author": "laurentgo", "createdAt": "2020-06-12T16:09:54Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.plan.hep.HepRelVertex;\n+import org.apache.calcite.plan.volcano.RelSubset;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  final int hashCode;\n+  final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>There are three kinds of nodes we need to handle:\n+   *\n+   * <ul>\n+   * <li>RelSubset: composition of class name, set id and traits;</li>\n+   * <li>HepRelVertex: composition of class name and current rel id;</li>\n+   * <li>Normal rel: composition of class name and id.</li>\n+   * </ul>\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    StringBuilder digest = new StringBuilder(rel.getRelTypeName());\n+    digest.append('#');\n+    if (rel instanceof RelSubset) {", "originalCommit": "545743d9db35eaeb45e8310ae050d3891c8602de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5MjMxMA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439692310", "bodyText": "For current impl, the digest is handled by each rel node. Split the code everywhere is hard to maintain, let the Digest take care how the digest should be generated but the invoker is still each node.", "author": "danny0405", "createdAt": "2020-06-13T00:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY5NDM1NQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439694355", "bodyText": "Considering that method, the digest takes care how the digest should be generated for nodes it already knows about. Based on the current approach, if I create a new RelNode subclass in my project which has a very natural/efficient way of creating a digest, I would have no choice than to fork the Calcite project to modify that method.\nI would favor an approach which would let HepRelVertex itself decides what to use for its digest instead of hardcoding in this method that the current rel should be chosen.", "author": "laurentgo", "createdAt": "2020-06-13T01:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg5NzYzNg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r439897636", "bodyText": "RelNode subclass in my project which has a very natural/efficient way of creating a digest, I would have no choice than to fork the Calcite project to modify that method\n\nDid you notice that the #computeDigest and #explainTerms are both API for overriding the digest ?\nHepRelVertex is not a public API, i don't think there is necessity to customize its digest, if you have a sub-class, override the #computeDigest is till feasible.", "author": "danny0405", "createdAt": "2020-06-15T02:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MzM2MQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440573361", "bodyText": "why not using the #computeDigest with the vertex id then?\nAlso it is not possible to \"substract\" to the default digest. One can only add. The patch you proposed has some behavior which is not possible to change", "author": "laurentgo", "createdAt": "2020-06-16T04:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4MDExMA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r440680110", "bodyText": "The current patch also supports pure string digest, which is same as before, if you think it is impossible, please give an example.\nThe digest of HepRelVertex and RelSubSet are the same as before, what do you mean by using the #computeDigest with the vertex id then ?", "author": "danny0405", "createdAt": "2020-06-16T08:33:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNzE0Nw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r441027147", "bodyText": "I guess I missed some update to your change (or missed the second constructor), but it looks like the choice is either:\n\nprovide rel + a list of extra items, and the logic to create the hashcode + digest is totally controlled by the digest class\nprovide rel + digest string to skip the whole hash computation logic\n\nI guess nothing in-between...\n\nThe digest of HepRelVertex and RelSubSet are the same as before, what do you mean by using the #computeDigest with the vertex id then ?\nIt's back to my comment about having the logic hardcoded into a single private static method which goes against OOP practices whereas instructing HelpRexVertex and RelSubSet instructing digest that the only field to consider for digest should be id", "author": "laurentgo", "createdAt": "2020-06-16T17:38:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMjY2MA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442112660", "bodyText": "Use the digest string to compute hashcode works well then the string is short, you can use the benchmark #2034 to see the diff. The performance diff is negligible.", "author": "danny0405", "createdAt": "2020-06-18T10:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxMDcyNg=="}], "type": "inlineReview", "revised_code": {"commit": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/plan/Digest.java b/core/src/main/java/org/apache/calcite/plan/Digest.java\nindex dba48017e..4525226d4 100644\n--- a/core/src/main/java/org/apache/calcite/plan/Digest.java\n+++ b/core/src/main/java/org/apache/calcite/plan/Digest.java\n\n@@ -27,6 +27,7 @@\n import java.util.Collections;\n import java.util.List;\n import java.util.Objects;\n+import javax.annotation.Nonnull;\n \n /**\n  * A short description of relational expression's type, inputs, and\n"}}, {"oid": "ef321d8643a8b449ec5da33952e9f661273d7a8f", "url": "https://github.com/apache/calcite/commit/ef321d8643a8b449ec5da33952e9f661273d7a8f", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-15T03:08:31Z", "type": "forcePushed"}, {"oid": "36f5bbd4b6a3a2816ad8f4bb839f0d80c611fb9f", "url": "https://github.com/apache/calcite/commit/36f5bbd4b6a3a2816ad8f4bb839f0d80c611fb9f", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-15T03:43:05Z", "type": "forcePushed"}, {"oid": "09bd6945f49b5d199a1488c70a511763d947efbc", "url": "https://github.com/apache/calcite/commit/09bd6945f49b5d199a1488c70a511763d947efbc", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-15T03:56:17Z", "type": "forcePushed"}, {"oid": "ba5d9470e43cbdd3f31d21e52c0fd63e5b4eb7b3", "url": "https://github.com/apache/calcite/commit/ba5d9470e43cbdd3f31d21e52c0fd63e5b4eb7b3", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-16T02:29:28Z", "type": "forcePushed"}, {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5", "url": "https://github.com/apache/calcite/commit/380cc446c24dd0d50198508a626f80b306d9b9b5", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-16T02:33:49Z", "type": "commit"}, {"oid": "380cc446c24dd0d50198508a626f80b306d9b9b5", "url": "https://github.com/apache/calcite/commit/380cc446c24dd0d50198508a626f80b306d9b9b5", "message": "[CALCITE-3786] Add Digest interface to enable efficient hashCode(equals) for RexNode and RelNode\n\n* Add class Digest used to identify the node;\n* There is a pre-computed hashcode to speedup #hashCode and #equals;\n* Change RexCall to use object#equals instead of pure string digest\ncomparison;\n* We only support RexInputRef normalization which is the most common\ncase;\n* Remove RexNode#toStringRaw because it makes the thing complicated,\nRexNode can always be normalized(default true).", "committedDate": "2020-06-16T02:33:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODE0MQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442598141", "bodyText": "Why do you use getRelTypeName() rather than \"HepRelVertex\"?", "author": "chunweilei", "createdAt": "2020-06-19T02:29:02Z", "path": "core/src/main/java/org/apache/calcite/plan/hep/HepRelVertex.java", "diffHunk": "@@ -75,8 +76,8 @@\n     return currentRel.getRowType();\n   }\n \n-  @Override protected String computeDigest() {\n-    return \"HepRelVertex(\" + currentRel + \")\";\n+  @Override protected Digest computeDigest() {\n+    return Digest.create(this, getRelTypeName() + '#' + getCurrentRel().getId());\n   }\n ", "originalCommit": "380cc446c24dd0d50198508a626f80b306d9b9b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwODg4Ng==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442608886", "bodyText": "To unify the logic, we can switch to \"HepRelVertex\", that's a preference.", "author": "danny0405", "createdAt": "2020-06-19T03:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5ODE0MQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442601203", "bodyText": "It's weird to add PALN= just for the two cases. It's better to have the same format for all the cases.", "author": "chunweilei", "createdAt": "2020-06-19T02:41:43Z", "path": "core/src/test/java/org/apache/calcite/test/enumerable/EnumerableCorrelateTest.java", "diffHunk": "@@ -96,11 +96,11 @@\n           planner.removeRule(EnumerableRules.ENUMERABLE_MERGE_JOIN_RULE);\n         })\n         .explainContains(\"\"\n-            + \"EnumerableCalc(expr#0..3=[{inputs}], empid=[$t1], name=[$t3])\\n\"\n+            + \"PLAN=EnumerableCalc(expr#0..3=[{inputs}], empid=[$t1], name=[$t3])\\n\"\n             + \"  EnumerableCorrelate(correlation=[$cor1], joinType=[inner], requiredColumns=[{0}])\\n\"\n             + \"    EnumerableAggregate(group=[{0}])\\n\"\n             + \"      EnumerableTableScan(table=[[s, depts]])\\n\"", "originalCommit": "380cc446c24dd0d50198508a626f80b306d9b9b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwOTMwNg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442609306", "bodyText": "I think we could, thanks ~", "author": "danny0405", "createdAt": "2020-06-19T03:17:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwMTIwMw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTgyOQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442605829", "bodyText": "What's the difference between Digest#create and Digest#initial ? Their results seem the same.", "author": "chunweilei", "createdAt": "2020-06-19T03:01:24Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  private final int hashCode;\n+  private final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>Currently, returns composition of class name and id.\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    return rel.getRelTypeName() + '#' + rel.getId();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+\n+    sb.append('(');\n+    int j = 0;\n+    for (Pair<String, Object> item : items) {\n+      if (j++ > 0) {\n+        sb.append(',');\n+      }\n+      sb.append(item.left);\n+      sb.append('=');\n+      sb.append(item.right);\n+    }\n+    sb.append(')');\n+    digest = sb.toString();\n+    return digest;\n+  }\n+\n+  @Override public int compareTo(@Nonnull Digest other) {\n+    return this.equals(other) ? 0 : this.rel.getId() - other.rel.getId();\n+  }\n+\n+  @Override public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Digest that = (Digest) o;\n+    return hashCode == that.hashCode && deepEquals(that);\n+  }\n+\n+  /**\n+   * The method is used to resolve hash conflict, in current 6000+ tests, there are about 8\n+   * tests with conflict, so we do not cache the hash code items in order to\n+   * reduce mem consumption.\n+   */\n+  private boolean deepEquals(Digest other) {\n+    Object[] thisItems = collect(this.rel, this.items, true);\n+    Object[] thatItems = collect(other.rel, other.items, true);\n+    if (thisItems.length != thatItems.length) {\n+      return false;\n+    }\n+    for (int i = 0; i < thisItems.length; i++) {\n+      if (!Objects.equals(thisItems[i], thatItems[i])) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Override public int hashCode() {\n+    return hashCode;\n+  }\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   */\n+  public static Digest create(RelNode rel, List<Pair<String, Object>> contents) {\n+    return new Digest(rel, contents);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel.\n+   */\n+  public static Digest create(RelNode rel) {\n+    return new Digest(rel);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel and string format digest\n+   */\n+  public static Digest create(RelNode rel, String digest) {\n+    return new Digest(rel, digest);\n+  }\n+\n+  /**\n+   * Instantiates a digest with solid string format digest, this digest should only\n+   * be used as a initial.\n+   */\n+  public static Digest initial(RelNode rel) {\n+    return new Digest(rel, simpleRelDigest(rel));\n+  }\n+}", "originalCommit": "380cc446c24dd0d50198508a626f80b306d9b9b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwOTY3Nw==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442609677", "bodyText": "To distinguish that the digest is just as a initial which should only be used once in the constructor.", "author": "danny0405", "createdAt": "2020-06-19T03:19:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxMzg0MQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442613841", "bodyText": "It's really hard to distinguish these two methods. Is it possible to remove Digest#create which seems useless?", "author": "chunweilei", "createdAt": "2020-06-19T03:37:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTgyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNjExNQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442616115", "bodyText": "I can remove the #initial and we use the #create uniformly.", "author": "danny0405", "createdAt": "2020-06-19T03:48:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTgyOQ=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNzczNg==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442607736", "bodyText": "As you said \"List<Pair<String, Object>> items are the properties, e.g. the inputs, the type, the traits and so on\", why should we still have to append trait?", "author": "chunweilei", "createdAt": "2020-06-19T03:09:59Z", "path": "core/src/main/java/org/apache/calcite/plan/Digest.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to you under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.calcite.plan;\n+\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.hint.Hintable;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import javax.annotation.Nonnull;\n+\n+/**\n+ * A short description of relational expression's type, inputs, and\n+ * other properties. The digest uniquely identifies the node; another node\n+ * is equivalent if and only if it has the same value.\n+ *\n+ * <p>Row type is part of the digest for the rare occasion that similar\n+ * expressions have different types, e.g. variants of\n+ * {@code Project(child=rel#1, a=null)} where a is a null INTEGER or a\n+ * null VARCHAR(10). Row type is represented as fieldTypes only, so {@code RelNode}\n+ * that differ with field names only are treated equal.\n+ * For instance, {@code Project(input=rel#1,empid=$0)} and {@code Project(input=rel#1,deptno=$0)}\n+ * are equal.\n+ *\n+ * <p>Computed by {@code org.apache.calcite.rel.AbstractRelNode#computeDigest},\n+ * assigned by {@link org.apache.calcite.rel.AbstractRelNode#onRegister},\n+ * returned by {@link org.apache.calcite.rel.AbstractRelNode#getDigest()}.\n+ */\n+public class Digest implements Comparable<Digest> {\n+\n+  //~ Instance fields --------------------------------------------------------\n+\n+  private final int hashCode;\n+  private final List<Pair<String, Object>> items;\n+  private final RelNode rel;\n+\n+  // Used for debugging, computed lazily.\n+  private String digest = null;\n+\n+  //~ Constructors -----------------------------------------------------------\n+\n+  /**\n+   * Creates a digest with given rel and properties.\n+   *\n+   * @param rel   The rel\n+   * @param items The properties, e.g. the inputs, the type, the traits and so on\n+   */\n+  private Digest(RelNode rel, List<Pair<String, Object>> items) {\n+    this.rel = rel;\n+    this.items = normalizeContents(items);\n+    this.hashCode = computeIdentity(rel, this.items);\n+  }\n+\n+  /**\n+   * Creates a digest with given rel, the digest is computed as simple,\n+   * see {@link #simpleRelDigest(RelNode)}.\n+   */\n+  private Digest(RelNode rel) {\n+    this(rel, simpleRelDigest(rel));\n+  }\n+\n+  /** Creates a digest with given rel and string format digest. */\n+  private Digest(RelNode rel, String digest) {\n+    this.rel = rel;\n+    this.items = Collections.emptyList();\n+    this.digest = digest;\n+    this.hashCode = this.digest.hashCode();\n+  }\n+\n+  /** Returns the identity of this digest which is used to speedup hashCode and equals. */\n+  private static int computeIdentity(RelNode rel, List<Pair<String, Object>> contents) {\n+    return Objects.hash(collect(rel, contents, false));\n+  }\n+\n+  /**\n+   * Collects the items used for {@link #hashCode} and {@link #equals}.\n+   *\n+   * <p>Generally, the items used for hashCode and equals should be the same. The exception\n+   * is the row type of the relational expression: the row type is needed because during\n+   * planning, new equivalent rels may be produced with changed fields nullability\n+   * (i.e. most of them comes from the rex simplify or constant reduction).\n+   * This expects to be rare case, so the hashcode is computed without row type\n+   * but when it conflicts, we compare with the row type involved(sans field names).\n+   *\n+   * @param rel      The rel to compute digest\n+   * @param contents The rel properties should be considered in digest\n+   * @param withType Whether to involve the row type\n+   */\n+  private static Object[] collect(\n+      RelNode rel,\n+      List<Pair<String, Object>> contents,\n+      boolean withType) {\n+    List<Object> hashCodeItems = new ArrayList<>();\n+    // The type name.\n+    hashCodeItems.add(rel.getRelTypeName());\n+    // The traits.\n+    hashCodeItems.addAll(rel.getTraitSet());\n+    // The hints.\n+    if (rel instanceof Hintable) {\n+      hashCodeItems.addAll(((Hintable) rel).getHints());\n+    }\n+    if (withType) {\n+      // The row type sans field names.\n+      RelDataType relType = rel.getRowType();\n+      if (relType.isStruct()) {\n+        hashCodeItems.addAll(Pair.right(relType.getFieldList()));\n+      } else {\n+        // Make a decision here because\n+        // some downstream projects have custom rel type which has no explicit fields.\n+        hashCodeItems.add(relType);\n+      }\n+    }\n+    // The rel node contents(e.g. the inputs or exprs).\n+    hashCodeItems.addAll(contents);\n+    return hashCodeItems.toArray();\n+  }\n+\n+  /** Normalizes the rel node properties, currently, just to replace the\n+   * {@link RelNode} with a simple string format digest. **/\n+  private static List<Pair<String, Object>> normalizeContents(\n+      List<Pair<String, Object>> items) {\n+    List<Pair<String, Object>> normalized = new ArrayList<>();\n+    for (Pair<String, Object> item : items) {\n+      if (item.right instanceof RelNode) {\n+        RelNode input = (RelNode) item.right;\n+        normalized.add(Pair.of(item.left, simpleRelDigest(input)));\n+      } else {\n+        normalized.add(item);\n+      }\n+    }\n+    return normalized;\n+  }\n+\n+  /**\n+   * Returns a simple string format digest.\n+   *\n+   * <p>Currently, returns composition of class name and id.\n+   *\n+   * @param rel The rel\n+   */\n+  private static String simpleRelDigest(RelNode rel) {\n+    return rel.getRelTypeName() + '#' + rel.getId();\n+  }\n+\n+  @Override public String toString() {\n+    if (null != digest) {\n+      return digest;\n+    }\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(rel.getRelTypeName());\n+\n+    for (RelTrait trait : rel.getTraitSet()) {\n+      sb.append('.');\n+      sb.append(trait.toString());\n+    }\n+", "originalCommit": "380cc446c24dd0d50198508a626f80b306d9b9b5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxMDA3MA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442610070", "bodyText": "The properties do not include traits, the Digest does.", "author": "danny0405", "createdAt": "2020-06-19T03:20:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNzczNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxMDU0MQ==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442610541", "bodyText": "Please correct the comment.", "author": "chunweilei", "createdAt": "2020-06-19T03:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNzczNg=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwOTk4MA==", "url": "https://github.com/apache/calcite/pull/2016#discussion_r442609980", "bodyText": "Nice catch.", "author": "chunweilei", "createdAt": "2020-06-19T03:20:17Z", "path": "core/src/main/java/org/apache/calcite/rel/core/Window.java", "diffHunk": "@@ -394,16 +394,24 @@ public RexWinAggCall(\n       this.ignoreNulls = ignoreNulls;\n     }\n \n-    /** {@inheritDoc}\n-     *\n-     * <p>Override {@link RexCall}, defining equality based on identity.\n-     */\n-    @Override public boolean equals(Object obj) {\n-      return this == obj;\n+    @Override public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+      if (!super.equals(o)) {\n+        return false;\n+      }\n+      RexWinAggCall that = (RexWinAggCall) o;\n+      return ordinal == that.ordinal\n+          && distinct == that.distinct\n+          && ignoreNulls == that.ignoreNulls;\n     }\n \n     @Override public int hashCode() {\n-      return Objects.hash(digest, ordinal, distinct);\n+      return Objects.hash(super.hashCode(), ordinal, distinct, ignoreNulls);\n     }", "originalCommit": "380cc446c24dd0d50198508a626f80b306d9b9b5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}