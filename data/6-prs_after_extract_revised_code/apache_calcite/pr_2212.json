{"pr_number": 2212, "pr_title": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL", "pr_createdAt": "2020-10-13T22:29:12Z", "pr_url": "https://github.com/apache/calcite/pull/2212", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NzcxMA==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504297710", "bodyText": "Should this be int complexity = rangeSet.asRanges().size(), and then if (...) { complexity = 1;}?", "author": "vlsi", "createdAt": "2020-10-13T22:36:34Z", "path": "core/src/main/java/org/apache/calcite/util/Sarg.java", "diffHunk": "@@ -149,4 +150,33 @@ public boolean isComplementedPoints() {\n         && rangeSet.complement().asRanges().stream()\n             .allMatch(RangeSets::isPoint);\n   }\n+\n+  /** Returns a measure of the complexity of this expression.\n+   *\n+   * <p>It is basically the number of values that need to be checked against\n+   * (including NULL).\n+   *\n+   * <p>Examples:\n+   * <ul>\n+   *   <li>{@code x = 1}, {@code x <> 1}, {@code x > 1} have complexity 1\n+   *   <li>{@code x > 1 or x is null} has complexity 2\n+   *   <li>{@code x in (2, 4, 6) or x > 20} has complexity 4\n+   *   <li>{@code x between 3 and 8 or x between 10 and 20} has complexity 2\n+   * </ul>\n+   */\n+  public int complexity() {\n+    int complexity;\n+    if (rangeSet.asRanges().size() == 2\n+        && rangeSet.complement().asRanges().size() == 1\n+        && RangeSets.isPoint(\n+            Iterables.getOnlyElement(rangeSet.complement().asRanges()))) {\n+      complexity = 1;\n+    } else {\n+      complexity = rangeSet.asRanges().size();", "originalCommit": "ecf7a8d25157dda11f6c295b066f9337076e5c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwMDg3Mw==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504300873", "bodyText": "It's a matter of taste. I prefer not to re-assign variables.", "author": "julianhyde", "createdAt": "2020-10-13T22:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NzcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNjI0Ng==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504306246", "bodyText": "Then please avoid re-computing the same things again and again.\nIt is hard to review and analyze how these .asRanges().size() differ.", "author": "vlsi", "createdAt": "2020-10-13T23:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI5NzcxMA=="}], "type": "inlineReview", "revised_code": {"commit": "d25d75f787dfdd74be8398e66d2f29ef51f73e4a", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/util/Sarg.java b/core/src/main/java/org/apache/calcite/util/Sarg.java\nindex c9522b66d..b356b1e8c 100644\n--- a/core/src/main/java/org/apache/calcite/util/Sarg.java\n+++ b/core/src/main/java/org/apache/calcite/util/Sarg.java\n\n@@ -170,6 +170,9 @@ public int complexity() {\n         && rangeSet.complement().asRanges().size() == 1\n         && RangeSets.isPoint(\n             Iterables.getOnlyElement(rangeSet.complement().asRanges()))) {\n+      // The complement of a point is a range set with two elements.\n+      // For example, \"x <> 1\" is \"[(-inf, 1), (1, inf)]\".\n+      // We want this to have complexity 1.\n       complexity = 1;\n     } else {\n       complexity = rangeSet.asRanges().size();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzA2Mw==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504307063", "bodyText": "Is this computation important for something?\nPlease add the relevant comment: if it is important, then clarify so. If it is just a fine detail, then comment so. The intention behind the conditions is not really visible.", "author": "vlsi", "createdAt": "2020-10-13T23:02:52Z", "path": "core/src/main/java/org/apache/calcite/util/Sarg.java", "diffHunk": "@@ -149,4 +150,33 @@ public boolean isComplementedPoints() {\n         && rangeSet.complement().asRanges().stream()\n             .allMatch(RangeSets::isPoint);\n   }\n+\n+  /** Returns a measure of the complexity of this expression.\n+   *\n+   * <p>It is basically the number of values that need to be checked against\n+   * (including NULL).\n+   *\n+   * <p>Examples:\n+   * <ul>\n+   *   <li>{@code x = 1}, {@code x <> 1}, {@code x > 1} have complexity 1\n+   *   <li>{@code x > 1 or x is null} has complexity 2\n+   *   <li>{@code x in (2, 4, 6) or x > 20} has complexity 4\n+   *   <li>{@code x between 3 and 8 or x between 10 and 20} has complexity 2\n+   * </ul>\n+   */\n+  public int complexity() {\n+    int complexity;\n+    if (rangeSet.asRanges().size() == 2\n+        && rangeSet.complement().asRanges().size() == 1\n+        && RangeSets.isPoint(\n+            Iterables.getOnlyElement(rangeSet.complement().asRanges()))) {", "originalCommit": "ecf7a8d25157dda11f6c295b066f9337076e5c5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzQ0OQ==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504307449", "bodyText": "Oh, this code already existed. Then I'm puzzled.", "author": "vlsi", "createdAt": "2020-10-13T23:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwODY5OQ==", "url": "https://github.com/apache/calcite/pull/2212#discussion_r504308699", "bodyText": "Yeah, there aren't many comments in the code. But there are reasonable method javadoc comments. Also a test, testSargComplexity. Run the test, and all will become clear.\nI moved the code so that I could add a test.", "author": "julianhyde", "createdAt": "2020-10-13T23:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMwNzA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "d25d75f787dfdd74be8398e66d2f29ef51f73e4a", "chunk": "diff --git a/core/src/main/java/org/apache/calcite/util/Sarg.java b/core/src/main/java/org/apache/calcite/util/Sarg.java\nindex c9522b66d..b356b1e8c 100644\n--- a/core/src/main/java/org/apache/calcite/util/Sarg.java\n+++ b/core/src/main/java/org/apache/calcite/util/Sarg.java\n\n@@ -170,6 +170,9 @@ public int complexity() {\n         && rangeSet.complement().asRanges().size() == 1\n         && RangeSets.isPoint(\n             Iterables.getOnlyElement(rangeSet.complement().asRanges()))) {\n+      // The complement of a point is a range set with two elements.\n+      // For example, \"x <> 1\" is \"[(-inf, 1), (1, inf)]\".\n+      // We want this to have complexity 1.\n       complexity = 1;\n     } else {\n       complexity = rangeSet.asRanges().size();\n"}}, {"oid": "d25d75f787dfdd74be8398e66d2f29ef51f73e4a", "url": "https://github.com/apache/calcite/commit/d25d75f787dfdd74be8398e66d2f29ef51f73e4a", "message": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL\n\nImprove how class Sarg handles IS NULL and IS NOT NULL\nconditions. They are now handled symmetrically, using fields\nnullCount and notNullCount, whereas previously we used\ncontainsNull, which could handle IS NULL only in certain\ncircumstances and IS NOT NULL not at all.", "committedDate": "2020-10-14T20:37:58Z", "type": "forcePushed"}, {"oid": "8c6957d3659a7f9f791ddde99a7ca30b26ff2082", "url": "https://github.com/apache/calcite/commit/8c6957d3659a7f9f791ddde99a7ca30b26ff2082", "message": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL\n\nImprove how class Sarg handles IS NULL and IS NOT NULL\nconditions. They are now handled symmetrically, using fields\nnullCount and notNullCount, whereas previously we used\ncontainsNull, which could handle IS NULL only in certain\ncircumstances and IS NOT NULL not at all.\n\nIn CalciteAssert, correct rounding floating point rounding\nerrors before comparing SQL column values. For example,\n'236.55000000000007' becomes '236.55'. This fixes some\nintermittent Druid test failures.", "committedDate": "2020-10-15T00:15:04Z", "type": "forcePushed"}, {"oid": "ee5c78444558117c71cc7058a79bc920a52cad59", "url": "https://github.com/apache/calcite/commit/ee5c78444558117c71cc7058a79bc920a52cad59", "message": "[CALCITE-4325] RexSimplify incorrectly simplifies complex expressions that contain Sarg and IS NULL\n\nImprove how class Sarg handles IS NULL and IS NOT NULL\nconditions. They are now handled symmetrically, using fields\nnullCount and notNullCount, whereas previously we used\ncontainsNull, which could handle IS NULL only in certain\ncircumstances and IS NOT NULL not at all.\n\nIn CalciteAssert, correct rounding floating point rounding\nerrors before comparing SQL column values. For example,\n'236.55000000000007' becomes '236.55'. This fixes some\nintermittent Druid test failures.", "committedDate": "2020-10-15T01:15:13Z", "type": "commit"}, {"oid": "10c80d61c074214963e2c2541ab584f6d74064e6", "url": "https://github.com/apache/calcite/commit/10c80d61c074214963e2c2541ab584f6d74064e6", "message": "more 4204", "committedDate": "2020-10-15T02:08:11Z", "type": "forcePushed"}, {"oid": "ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "url": "https://github.com/apache/calcite/commit/ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "message": "Make progress on [CALCITE-4204] Intermittent precision in Druid results when using aggregation functions over columns of type DOUBLE\n\nIf a query returns a column value that has at least four\nzeros or nines after the decimal point (indicating that\nrounding has occurred) clean up the rounding. For example,\n'12.3449999962' becomes '12.345'. Most queries have a result\nthat is decimal exact to a small number of decimal places;\nsuch queries are re-enabled in this change, because they are\nnow deterministic. There are still a few queries whose\ndecimal does not terminate (perhaps it is a rational number)\nand therefore [CALCITE-4204] remains open.", "committedDate": "2020-10-15T19:18:56Z", "type": "commit"}, {"oid": "ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "url": "https://github.com/apache/calcite/commit/ffc1e3b05e7f920d95c48f7c75fd48372684b8e7", "message": "Make progress on [CALCITE-4204] Intermittent precision in Druid results when using aggregation functions over columns of type DOUBLE\n\nIf a query returns a column value that has at least four\nzeros or nines after the decimal point (indicating that\nrounding has occurred) clean up the rounding. For example,\n'12.3449999962' becomes '12.345'. Most queries have a result\nthat is decimal exact to a small number of decimal places;\nsuch queries are re-enabled in this change, because they are\nnow deterministic. There are still a few queries whose\ndecimal does not terminate (perhaps it is a rational number)\nand therefore [CALCITE-4204] remains open.", "committedDate": "2020-10-15T19:18:56Z", "type": "forcePushed"}]}