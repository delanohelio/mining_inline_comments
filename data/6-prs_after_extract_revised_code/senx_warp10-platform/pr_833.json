{"pr_number": 833, "pr_title": "Make POW work on GTSs and Lists the same way numerical functions do", "pr_createdAt": "2020-09-17T15:16:35Z", "pr_url": "https://github.com/senx/warp10-platform/pull/833", "timeline": [{"oid": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "url": "https://github.com/senx/warp10-platform/commit/b1133aa1b60e5595b041544aa367c8b9a9a2d468", "message": "Make POW work on GTSs and Lists the same way numerical functions do", "committedDate": "2020-09-17T15:16:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0MDMwMQ==", "url": "https://github.com/senx/warp10-platform/pull/833#discussion_r490340301", "bodyText": "This does not depend on the operands, can it be instantiated once and reused?", "author": "hbs", "createdAt": "2020-09-17T15:24:06Z", "path": "warp10/src/main/java/io/warp10/script/binary/POW.java", "diffHunk": "@@ -16,35 +16,138 @@\n \n package io.warp10.script.binary;\n \n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GTSOpsHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n- * Raise the first operand to the power of the second\n+ * Raise the first operand to the power of the second.\n  */\n public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n \n+  private final String typeCheckErrorMsg;\n+\n   public POW(String name) {\n     super(name);\n+    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object op2 = stack.pop();\n     Object op1 = stack.pop();\n-    \n+\n     if (op2 instanceof Number && op1 instanceof Number) {\n+      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n       if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue()));\n+        stack.push(pow);\n       } else {\n-        stack.push((long) Math.pow(((Number) op1).longValue(), ((Number) op2).longValue()));        \n+        stack.push((long) pow);\n+      }\n+    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n+      List list = op1 instanceof List ? (List) op1 : (List) op2;\n+      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n+      double operandD = operand.doubleValue();\n+\n+      ArrayList<Object> result = new ArrayList<Object>(list.size());\n+\n+      for (Object element: list) {\n+        if (!(element instanceof Number)) {\n+          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n+        }\n+\n+        // Compute the power, taking into account parameter order.\n+        double pow;\n+        if (op1 instanceof List) {\n+          pow = Math.pow(((Number) element).doubleValue(), operandD);\n+        } else {\n+          pow = Math.pow(operandD, ((Number) element).doubleValue());\n+        }\n+\n+        // Cast result to long if both operands are not floating-point values.\n+        if (element instanceof Double || operand instanceof Double) {\n+          result.add(pow);\n+        } else {\n+          result.add((long) pow);\n+        }\n+      }\n+\n+      stack.push(result);\n+    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n+      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n+      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n+\n+      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n+      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n+      result.setType(type);\n+\n+      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {", "originalCommit": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "33e50423d61d04f7c0ff265a474e78aed059d581", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/binary/POW.java b/warp10/src/main/java/io/warp10/script/binary/POW.java\ndeleted file mode 100644\nindex 2c731d34..00000000\n--- a/warp10/src/main/java/io/warp10/script/binary/POW.java\n+++ /dev/null\n\n@@ -1,153 +0,0 @@\n-//\n-//   Copyright 2018-2020  SenX S.A.S.\n-//\n-//   Licensed under the Apache License, Version 2.0 (the \"License\");\n-//   you may not use this file except in compliance with the License.\n-//   You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-//   Unless required by applicable law or agreed to in writing, software\n-//   distributed under the License is distributed on an \"AS IS\" BASIS,\n-//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-//   See the License for the specific language governing permissions and\n-//   limitations under the License.\n-//\n-\n-package io.warp10.script.binary;\n-\n-import io.warp10.continuum.gts.GTSHelper;\n-import io.warp10.continuum.gts.GTSOpsHelper;\n-import io.warp10.continuum.gts.GeoTimeSerie;\n-import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptException;\n-import io.warp10.script.WarpScriptStack;\n-import io.warp10.script.WarpScriptStackFunction;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * Raise the first operand to the power of the second.\n- */\n-public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-\n-  private final String typeCheckErrorMsg;\n-\n-  public POW(String name) {\n-    super(name);\n-    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n-  }\n-\n-  @Override\n-  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n-    Object op2 = stack.pop();\n-    Object op1 = stack.pop();\n-\n-    if (op2 instanceof Number && op1 instanceof Number) {\n-      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n-      if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(pow);\n-      } else {\n-        stack.push((long) pow);\n-      }\n-    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n-      List list = op1 instanceof List ? (List) op1 : (List) op2;\n-      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n-      double operandD = operand.doubleValue();\n-\n-      ArrayList<Object> result = new ArrayList<Object>(list.size());\n-\n-      for (Object element: list) {\n-        if (!(element instanceof Number)) {\n-          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n-        }\n-\n-        // Compute the power, taking into account parameter order.\n-        double pow;\n-        if (op1 instanceof List) {\n-          pow = Math.pow(((Number) element).doubleValue(), operandD);\n-        } else {\n-          pow = Math.pow(operandD, ((Number) element).doubleValue());\n-        }\n-\n-        // Cast result to long if both operands are not floating-point values.\n-        if (element instanceof Double || operand instanceof Double) {\n-          result.add(pow);\n-        } else {\n-          result.add((long) pow);\n-        }\n-      }\n-\n-      stack.push(result);\n-    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n-      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n-      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n-\n-      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n-        throw new WarpScriptException(typeCheckErrorMsg);\n-      }\n-\n-      // The result type is LONG if both inputs are LONG.\n-      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n-      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n-      result.setType(type);\n-\n-      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n-        @Override\n-        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n-          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n-        }\n-      };\n-\n-      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n-\n-      // If result is empty, set type and sizehint to default.\n-      if (0 == result.size()) {\n-        result = result.cloneEmpty();\n-      }\n-\n-      stack.push(result);\n-    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n-      boolean op1gts = op1 instanceof GeoTimeSerie;\n-\n-      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n-\n-      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();\n-      GeoTimeSerie gts = op1gts ? (GeoTimeSerie) op1 : (GeoTimeSerie) op2;\n-\n-      // Returns immediately a new clone if gts is empty.\n-      if (0 == n) {\n-        stack.push(result);\n-        return stack;\n-      }\n-\n-      if (!(gts.getType() == GeoTimeSerie.TYPE.LONG || gts.getType() == GeoTimeSerie.TYPE.DOUBLE)) {\n-        throw new WarpScriptException(typeCheckErrorMsg);\n-      }\n-\n-      Number op = op1gts ? (Number) op2 : (Number) op1;\n-\n-      // The result type is LONG if both inputs are LONG.\n-      GeoTimeSerie.TYPE type = (gts.getType() == GeoTimeSerie.TYPE.LONG && op instanceof Long) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n-      result.setType(type);\n-\n-      double opDouble = op.doubleValue();\n-      for (int i = 0; i < n; i++) {\n-        double value;\n-        if (op1gts) {\n-          value = Math.pow(((Number) GTSHelper.valueAtIndex(gts, i)).doubleValue(), opDouble);\n-        } else {\n-          value = Math.pow(opDouble, ((Number) GTSHelper.valueAtIndex(gts, i)).doubleValue());\n-        }\n-        GTSHelper.setValue(result, GTSHelper.tickAtIndex(gts, i), GTSHelper.locationAtIndex(gts, i), GTSHelper.elevationAtIndex(gts, i), value, false);\n-      }\n-\n-      stack.push(result);\n-    } else {\n-      throw new WarpScriptException(getName() + \" can only operate on numeric values.\");\n-    }\n-\n-    return stack;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0MDg2OQ==", "url": "https://github.com/senx/warp10-platform/pull/833#discussion_r490340869", "bodyText": "missing hint if op2 is a GTS", "author": "hbs", "createdAt": "2020-09-17T15:24:52Z", "path": "warp10/src/main/java/io/warp10/script/binary/POW.java", "diffHunk": "@@ -16,35 +16,138 @@\n \n package io.warp10.script.binary;\n \n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GTSOpsHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n- * Raise the first operand to the power of the second\n+ * Raise the first operand to the power of the second.\n  */\n public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n \n+  private final String typeCheckErrorMsg;\n+\n   public POW(String name) {\n     super(name);\n+    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object op2 = stack.pop();\n     Object op1 = stack.pop();\n-    \n+\n     if (op2 instanceof Number && op1 instanceof Number) {\n+      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n       if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue()));\n+        stack.push(pow);\n       } else {\n-        stack.push((long) Math.pow(((Number) op1).longValue(), ((Number) op2).longValue()));        \n+        stack.push((long) pow);\n+      }\n+    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n+      List list = op1 instanceof List ? (List) op1 : (List) op2;\n+      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n+      double operandD = operand.doubleValue();\n+\n+      ArrayList<Object> result = new ArrayList<Object>(list.size());\n+\n+      for (Object element: list) {\n+        if (!(element instanceof Number)) {\n+          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n+        }\n+\n+        // Compute the power, taking into account parameter order.\n+        double pow;\n+        if (op1 instanceof List) {\n+          pow = Math.pow(((Number) element).doubleValue(), operandD);\n+        } else {\n+          pow = Math.pow(operandD, ((Number) element).doubleValue());\n+        }\n+\n+        // Cast result to long if both operands are not floating-point values.\n+        if (element instanceof Double || operand instanceof Double) {\n+          result.add(pow);\n+        } else {\n+          result.add((long) pow);\n+        }\n+      }\n+\n+      stack.push(result);\n+    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n+      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n+      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n+\n+      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n+      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n+      result.setType(type);\n+\n+      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n+        @Override\n+        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n+          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n+        }\n+      };\n+\n+      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n+\n+      // If result is empty, set type and sizehint to default.\n+      if (0 == result.size()) {\n+        result = result.cloneEmpty();\n+      }\n+\n+      stack.push(result);\n+    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n+      boolean op1gts = op1 instanceof GeoTimeSerie;\n+\n+      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n+\n+      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();", "originalCommit": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "33e50423d61d04f7c0ff265a474e78aed059d581", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/binary/POW.java b/warp10/src/main/java/io/warp10/script/binary/POW.java\ndeleted file mode 100644\nindex 2c731d34..00000000\n--- a/warp10/src/main/java/io/warp10/script/binary/POW.java\n+++ /dev/null\n\n@@ -1,153 +0,0 @@\n-//\n-//   Copyright 2018-2020  SenX S.A.S.\n-//\n-//   Licensed under the Apache License, Version 2.0 (the \"License\");\n-//   you may not use this file except in compliance with the License.\n-//   You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-//   Unless required by applicable law or agreed to in writing, software\n-//   distributed under the License is distributed on an \"AS IS\" BASIS,\n-//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-//   See the License for the specific language governing permissions and\n-//   limitations under the License.\n-//\n-\n-package io.warp10.script.binary;\n-\n-import io.warp10.continuum.gts.GTSHelper;\n-import io.warp10.continuum.gts.GTSOpsHelper;\n-import io.warp10.continuum.gts.GeoTimeSerie;\n-import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptException;\n-import io.warp10.script.WarpScriptStack;\n-import io.warp10.script.WarpScriptStackFunction;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * Raise the first operand to the power of the second.\n- */\n-public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-\n-  private final String typeCheckErrorMsg;\n-\n-  public POW(String name) {\n-    super(name);\n-    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n-  }\n-\n-  @Override\n-  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n-    Object op2 = stack.pop();\n-    Object op1 = stack.pop();\n-\n-    if (op2 instanceof Number && op1 instanceof Number) {\n-      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n-      if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(pow);\n-      } else {\n-        stack.push((long) pow);\n-      }\n-    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n-      List list = op1 instanceof List ? (List) op1 : (List) op2;\n-      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n-      double operandD = operand.doubleValue();\n-\n-      ArrayList<Object> result = new ArrayList<Object>(list.size());\n-\n-      for (Object element: list) {\n-        if (!(element instanceof Number)) {\n-          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n-        }\n-\n-        // Compute the power, taking into account parameter order.\n-        double pow;\n-        if (op1 instanceof List) {\n-          pow = Math.pow(((Number) element).doubleValue(), operandD);\n-        } else {\n-          pow = Math.pow(operandD, ((Number) element).doubleValue());\n-        }\n-\n-        // Cast result to long if both operands are not floating-point values.\n-        if (element instanceof Double || operand instanceof Double) {\n-          result.add(pow);\n-        } else {\n-          result.add((long) pow);\n-        }\n-      }\n-\n-      stack.push(result);\n-    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n-      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n-      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n-\n-      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n-        throw new WarpScriptException(typeCheckErrorMsg);\n-      }\n-\n-      // The result type is LONG if both inputs are LONG.\n-      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n-      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n-      result.setType(type);\n-\n-      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n-        @Override\n-        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n-          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n-        }\n-      };\n-\n-      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n-\n-      // If result is empty, set type and sizehint to default.\n-      if (0 == result.size()) {\n-        result = result.cloneEmpty();\n-      }\n-\n-      stack.push(result);\n-    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n-      boolean op1gts = op1 instanceof GeoTimeSerie;\n-\n-      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n-\n-      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();\n-      GeoTimeSerie gts = op1gts ? (GeoTimeSerie) op1 : (GeoTimeSerie) op2;\n-\n-      // Returns immediately a new clone if gts is empty.\n-      if (0 == n) {\n-        stack.push(result);\n-        return stack;\n-      }\n-\n-      if (!(gts.getType() == GeoTimeSerie.TYPE.LONG || gts.getType() == GeoTimeSerie.TYPE.DOUBLE)) {\n-        throw new WarpScriptException(typeCheckErrorMsg);\n-      }\n-\n-      Number op = op1gts ? (Number) op2 : (Number) op1;\n-\n-      // The result type is LONG if both inputs are LONG.\n-      GeoTimeSerie.TYPE type = (gts.getType() == GeoTimeSerie.TYPE.LONG && op instanceof Long) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n-      result.setType(type);\n-\n-      double opDouble = op.doubleValue();\n-      for (int i = 0; i < n; i++) {\n-        double value;\n-        if (op1gts) {\n-          value = Math.pow(((Number) GTSHelper.valueAtIndex(gts, i)).doubleValue(), opDouble);\n-        } else {\n-          value = Math.pow(opDouble, ((Number) GTSHelper.valueAtIndex(gts, i)).doubleValue());\n-        }\n-        GTSHelper.setValue(result, GTSHelper.tickAtIndex(gts, i), GTSHelper.locationAtIndex(gts, i), GTSHelper.elevationAtIndex(gts, i), value, false);\n-      }\n-\n-      stack.push(result);\n-    } else {\n-      throw new WarpScriptException(getName() + \" can only operate on numeric values.\");\n-    }\n-\n-    return stack;\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDM0MTM4Mw==", "url": "https://github.com/senx/warp10-platform/pull/833#discussion_r490341383", "bodyText": "GeoTimeSerie.TYPE.LONG == gts.getType()", "author": "hbs", "createdAt": "2020-09-17T15:25:34Z", "path": "warp10/src/main/java/io/warp10/script/binary/POW.java", "diffHunk": "@@ -16,35 +16,138 @@\n \n package io.warp10.script.binary;\n \n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GTSOpsHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptStackFunction;\n import io.warp10.script.WarpScriptException;\n import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n \n /**\n- * Raise the first operand to the power of the second\n+ * Raise the first operand to the power of the second.\n  */\n public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n \n+  private final String typeCheckErrorMsg;\n+\n   public POW(String name) {\n     super(name);\n+    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n   }\n-  \n+\n   @Override\n   public Object apply(WarpScriptStack stack) throws WarpScriptException {\n     Object op2 = stack.pop();\n     Object op1 = stack.pop();\n-    \n+\n     if (op2 instanceof Number && op1 instanceof Number) {\n+      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n       if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue()));\n+        stack.push(pow);\n       } else {\n-        stack.push((long) Math.pow(((Number) op1).longValue(), ((Number) op2).longValue()));        \n+        stack.push((long) pow);\n+      }\n+    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n+      List list = op1 instanceof List ? (List) op1 : (List) op2;\n+      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n+      double operandD = operand.doubleValue();\n+\n+      ArrayList<Object> result = new ArrayList<Object>(list.size());\n+\n+      for (Object element: list) {\n+        if (!(element instanceof Number)) {\n+          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n+        }\n+\n+        // Compute the power, taking into account parameter order.\n+        double pow;\n+        if (op1 instanceof List) {\n+          pow = Math.pow(((Number) element).doubleValue(), operandD);\n+        } else {\n+          pow = Math.pow(operandD, ((Number) element).doubleValue());\n+        }\n+\n+        // Cast result to long if both operands are not floating-point values.\n+        if (element instanceof Double || operand instanceof Double) {\n+          result.add(pow);\n+        } else {\n+          result.add((long) pow);\n+        }\n+      }\n+\n+      stack.push(result);\n+    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n+      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n+      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n+\n+      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n+      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n+      result.setType(type);\n+\n+      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n+        @Override\n+        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n+          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n+        }\n+      };\n+\n+      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n+\n+      // If result is empty, set type and sizehint to default.\n+      if (0 == result.size()) {\n+        result = result.cloneEmpty();\n+      }\n+\n+      stack.push(result);\n+    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n+      boolean op1gts = op1 instanceof GeoTimeSerie;\n+\n+      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n+\n+      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();\n+      GeoTimeSerie gts = op1gts ? (GeoTimeSerie) op1 : (GeoTimeSerie) op2;\n+\n+      // Returns immediately a new clone if gts is empty.\n+      if (0 == n) {\n+        stack.push(result);\n+        return stack;\n       }\n+\n+      if (!(gts.getType() == GeoTimeSerie.TYPE.LONG || gts.getType() == GeoTimeSerie.TYPE.DOUBLE)) {\n+        throw new WarpScriptException(typeCheckErrorMsg);\n+      }\n+\n+      Number op = op1gts ? (Number) op2 : (Number) op1;\n+\n+      // The result type is LONG if both inputs are LONG.\n+      GeoTimeSerie.TYPE type = (gts.getType() == GeoTimeSerie.TYPE.LONG && op instanceof Long) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;", "originalCommit": "b1133aa1b60e5595b041544aa367c8b9a9a2d468", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "33e50423d61d04f7c0ff265a474e78aed059d581", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/binary/POW.java b/warp10/src/main/java/io/warp10/script/binary/POW.java\ndeleted file mode 100644\nindex 2c731d34..00000000\n--- a/warp10/src/main/java/io/warp10/script/binary/POW.java\n+++ /dev/null\n\n@@ -1,153 +0,0 @@\n-//\n-//   Copyright 2018-2020  SenX S.A.S.\n-//\n-//   Licensed under the Apache License, Version 2.0 (the \"License\");\n-//   you may not use this file except in compliance with the License.\n-//   You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-//   Unless required by applicable law or agreed to in writing, software\n-//   distributed under the License is distributed on an \"AS IS\" BASIS,\n-//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-//   See the License for the specific language governing permissions and\n-//   limitations under the License.\n-//\n-\n-package io.warp10.script.binary;\n-\n-import io.warp10.continuum.gts.GTSHelper;\n-import io.warp10.continuum.gts.GTSOpsHelper;\n-import io.warp10.continuum.gts.GeoTimeSerie;\n-import io.warp10.script.NamedWarpScriptFunction;\n-import io.warp10.script.WarpScriptException;\n-import io.warp10.script.WarpScriptStack;\n-import io.warp10.script.WarpScriptStackFunction;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-/**\n- * Raise the first operand to the power of the second.\n- */\n-public class POW extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n-\n-  private final String typeCheckErrorMsg;\n-\n-  public POW(String name) {\n-    super(name);\n-    typeCheckErrorMsg = getName() + \" can only operate on numeric values, vectors and numeric Geo Time Series.\";\n-  }\n-\n-  @Override\n-  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n-    Object op2 = stack.pop();\n-    Object op1 = stack.pop();\n-\n-    if (op2 instanceof Number && op1 instanceof Number) {\n-      double pow = Math.pow(((Number) op1).doubleValue(), ((Number) op2).doubleValue());\n-      if (op1 instanceof Double || op2 instanceof Double) {\n-        stack.push(pow);\n-      } else {\n-        stack.push((long) pow);\n-      }\n-    } else if ((op1 instanceof Number && op2 instanceof List) || (op1 instanceof List && op2 instanceof Number)) {\n-      List list = op1 instanceof List ? (List) op1 : (List) op2;\n-      Number operand = op1 instanceof Number ? (Number) op1 : (Number) op2;\n-      double operandD = operand.doubleValue();\n-\n-      ArrayList<Object> result = new ArrayList<Object>(list.size());\n-\n-      for (Object element: list) {\n-        if (!(element instanceof Number)) {\n-          throw new WarpScriptException(getName() + \" expects lists to contain numerical values.\");\n-        }\n-\n-        // Compute the power, taking into account parameter order.\n-        double pow;\n-        if (op1 instanceof List) {\n-          pow = Math.pow(((Number) element).doubleValue(), operandD);\n-        } else {\n-          pow = Math.pow(operandD, ((Number) element).doubleValue());\n-        }\n-\n-        // Cast result to long if both operands are not floating-point values.\n-        if (element instanceof Double || operand instanceof Double) {\n-          result.add(pow);\n-        } else {\n-          result.add((long) pow);\n-        }\n-      }\n-\n-      stack.push(result);\n-    } else if (op1 instanceof GeoTimeSerie && op2 instanceof GeoTimeSerie) {\n-      GeoTimeSerie gts1 = (GeoTimeSerie) op1;\n-      GeoTimeSerie gts2 = (GeoTimeSerie) op2;\n-\n-      if (!(gts1.getType() == GeoTimeSerie.TYPE.DOUBLE || gts1.getType() == GeoTimeSerie.TYPE.LONG) || !(gts2.getType() == GeoTimeSerie.TYPE.DOUBLE || gts2.getType() == GeoTimeSerie.TYPE.LONG)) {\n-        throw new WarpScriptException(typeCheckErrorMsg);\n-      }\n-\n-      // The result type is LONG if both inputs are LONG.\n-      GeoTimeSerie result = new GeoTimeSerie(Math.max(GTSHelper.nvalues(gts1), GTSHelper.nvalues(gts2)));\n-      GeoTimeSerie.TYPE type = (gts1.getType() == GeoTimeSerie.TYPE.LONG && gts2.getType() == GeoTimeSerie.TYPE.LONG) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n-      result.setType(type);\n-\n-      GTSOpsHelper.GTSBinaryOp op = new GTSOpsHelper.GTSBinaryOp() {\n-        @Override\n-        public Object op(GeoTimeSerie gtsa, GeoTimeSerie gtsb, int idxa, int idxb) {\n-          return Math.pow(((Number) GTSHelper.valueAtIndex(gtsa, idxa)).doubleValue(), ((Number) GTSHelper.valueAtIndex(gtsb, idxb)).doubleValue());\n-        }\n-      };\n-\n-      GTSOpsHelper.applyBinaryOp(result, gts1, gts2, op);\n-\n-      // If result is empty, set type and sizehint to default.\n-      if (0 == result.size()) {\n-        result = result.cloneEmpty();\n-      }\n-\n-      stack.push(result);\n-    } else if ((op1 instanceof GeoTimeSerie && op2 instanceof Number) || (op1 instanceof Number && op2 instanceof GeoTimeSerie)) {\n-      boolean op1gts = op1 instanceof GeoTimeSerie;\n-\n-      int n = op1gts ? GTSHelper.nvalues((GeoTimeSerie) op1) : GTSHelper.nvalues((GeoTimeSerie) op2);\n-\n-      GeoTimeSerie result = op1gts ? ((GeoTimeSerie) op1).cloneEmpty(n) : ((GeoTimeSerie) op2).cloneEmpty();\n-      GeoTimeSerie gts = op1gts ? (GeoTimeSerie) op1 : (GeoTimeSerie) op2;\n-\n-      // Returns immediately a new clone if gts is empty.\n-      if (0 == n) {\n-        stack.push(result);\n-        return stack;\n-      }\n-\n-      if (!(gts.getType() == GeoTimeSerie.TYPE.LONG || gts.getType() == GeoTimeSerie.TYPE.DOUBLE)) {\n-        throw new WarpScriptException(typeCheckErrorMsg);\n-      }\n-\n-      Number op = op1gts ? (Number) op2 : (Number) op1;\n-\n-      // The result type is LONG if both inputs are LONG.\n-      GeoTimeSerie.TYPE type = (gts.getType() == GeoTimeSerie.TYPE.LONG && op instanceof Long) ? GeoTimeSerie.TYPE.LONG : GeoTimeSerie.TYPE.DOUBLE;\n-      result.setType(type);\n-\n-      double opDouble = op.doubleValue();\n-      for (int i = 0; i < n; i++) {\n-        double value;\n-        if (op1gts) {\n-          value = Math.pow(((Number) GTSHelper.valueAtIndex(gts, i)).doubleValue(), opDouble);\n-        } else {\n-          value = Math.pow(opDouble, ((Number) GTSHelper.valueAtIndex(gts, i)).doubleValue());\n-        }\n-        GTSHelper.setValue(result, GTSHelper.tickAtIndex(gts, i), GTSHelper.locationAtIndex(gts, i), GTSHelper.elevationAtIndex(gts, i), value, false);\n-      }\n-\n-      stack.push(result);\n-    } else {\n-      throw new WarpScriptException(getName() + \" can only operate on numeric values.\");\n-    }\n-\n-    return stack;\n-  }\n-}\n"}}, {"oid": "33e50423d61d04f7c0ff265a474e78aed059d581", "url": "https://github.com/senx/warp10-platform/commit/33e50423d61d04f7c0ff265a474e78aed059d581", "message": "Remove POW and use NumericalBinaryFunction for **", "committedDate": "2020-09-18T08:17:27Z", "type": "commit"}]}