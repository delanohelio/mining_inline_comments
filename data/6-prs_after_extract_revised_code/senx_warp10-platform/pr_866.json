{"pr_number": 866, "pr_title": "Fix concurrency in StandaloneDirectoryClient", "pr_createdAt": "2020-11-06T10:52:05Z", "pr_url": "https://github.com/senx/warp10-platform/pull/866", "timeline": [{"oid": "3486fa759524409e23e0b6d0f6c2103ad777663c", "url": "https://github.com/senx/warp10-platform/commit/3486fa759524409e23e0b6d0f6c2103ad777663c", "message": "Make classids able to handle concurrent reads/writes", "committedDate": "2020-11-06T10:19:47Z", "type": "commit"}, {"oid": "cd9448e3cec1283caa1cbe9c29560862a80fb7b6", "url": "https://github.com/senx/warp10-platform/commit/cd9448e3cec1283caa1cbe9c29560862a80fb7b6", "message": "Unsync unregister and sync on metadata the critical part", "committedDate": "2020-11-06T10:45:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY5NTI0NQ==", "url": "https://github.com/senx/warp10-platform/pull/866#discussion_r518695245", "bodyText": "Why compute the labels id before it is needed? This is a costly operation.", "author": "hbs", "createdAt": "2020-11-06T11:34:51Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java", "diffHunk": "@@ -680,19 +681,22 @@ public void register(Metadata metadata) throws IOException {\n     }\n   }\n \n-  public synchronized void unregister(Metadata metadata) {\n-    if (!classids.containsKey(metadata.getName())) {\n-      return;\n-    }\n+  public void unregister(Metadata metadata) {\n     // 128BITS\n     long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());", "originalCommit": "cd9448e3cec1283caa1cbe9c29560862a80fb7b6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0e09ecfa9e195c36877e5bd0973d4502c43bbd47", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\nindex 22b49ac4..f9dea002 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\n\n@@ -622,73 +631,84 @@ public class StandaloneDirectoryClient implements DirectoryClient {\n     // If the metadata are not known, register them\n     //\n \n-    if (Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource()) && !classids.containsKey(metadata.getName())) {\n-      store(metadata);\n-    } else if (Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource())) {\n-      // Compute labelsId\n-      // 128BITS\n-      long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n-\n-      if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n-        // Metadata is unknown so we know the Metadata should be stored\n-        store(metadata);\n-      } else {\n-        // Check that we do not have a collision\n-        if (!metadatas.get(metadata.getName()).get(labelsId).getLabels().equals(metadata.getLabels())) {\n-          LOG.warn(\"LabelsId collision under class '\" + metadata.getName() + \"' \" + metadata.getLabels() + \" and \" + metadatas.get(metadata.getName()).get(labelsId).getLabels());\n-          Sensision.update(SensisionConstants.CLASS_WARP_DIRECTORY_LABELS_COLLISIONS, Sensision.EMPTY_LABELS, 1);\n-        }\n-\n-        //\n-        // Check activity of the GTS, storing it if the activity window has passed\n-        if (activityWindow > 0) {\n-          //\n-          // If the currently stored lastactivity is more than 'activityWindow' before the one in 'metadata',\n-          // store the metadata\n-          //\n-          long currentLastActivity = metadatas.get(metadata.getName()).get(labelsId).getLastActivity();\n-          if (metadata.getLastActivity() - currentLastActivity >= activityWindow) {\n-            store(metadata);\n-          }\n-        }\n-      }\n-    } else if (!Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource())) {\n-      //\n-      // Metadata registration is not from Ingress, this means we can update the value as it comes from the directory service or a metadata update\n-      //\n+    boolean mustStore = false;\n \n-      // When it is a metadata update request, only store the metadata if the GTS is already known\n-      if (Configuration.INGRESS_METADATA_UPDATE_ENDPOINT.equals(metadata.getSource())\n-          || Configuration.INGRESS_METADATA_UPDATE_DELTA_ENDPOINT.equals(metadata.getSource())) {\n-        if (classids.containsKey(metadata.getName())) {\n+    synchronized(metadatas) {\n+      if (Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource())) {\n+        if (!classids.containsKey(metadata.getName())) {\n+          mustStore = true;\n+        } else {\n+          // Compute labelsId\n           // 128BITS\n           long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n-          if (metadatas.get(metadata.getName()).containsKey(labelsId)) {\n-            // Check the activity so we only increase it\n-            // 128 bits\n-            Metadata meta = metadatas.get(metadata.getName()).get(labelsId);\n-            long currentLastActivity = meta.getLastActivity();\n-            if (metadata.getLastActivity() < currentLastActivity) {\n-              metadata.setLastActivity(currentLastActivity);\n+\n+          if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n+            // Metadata is unknown so we know the Metadata should be stored\n+            mustStore = true;\n+          } else {\n+            // Check that we do not have a collision\n+            if (!metadatas.get(metadata.getName()).get(labelsId).getLabels().equals(metadata.getLabels())) {\n+              LOG.warn(\"LabelsId collision under class '\" + metadata.getName() + \"' \" + metadata.getLabels() + \" and \" + metadatas.get(metadata.getName()).get(labelsId).getLabels());\n+              Sensision.update(SensisionConstants.CLASS_WARP_DIRECTORY_LABELS_COLLISIONS, Sensision.EMPTY_LABELS, 1);\n             }\n \n-            store(metadata);\n+            //\n+            // Check activity of the GTS, storing it if the activity window has passed\n+            if (activityWindow > 0) {\n+              //\n+              // If the currently stored lastactivity is more than 'activityWindow' before the one in 'metadata',\n+              // store the metadata\n+              //\n+              long currentLastActivity = metadatas.get(metadata.getName()).get(labelsId).getLastActivity();\n+              if (metadata.getLastActivity() - currentLastActivity >= activityWindow) {\n+                mustStore = true;\n+              }\n+            }\n           }\n         }\n       } else {\n-        store(metadata);\n+        //\n+        // Metadata registration is not from Ingress, this means we can update the value as it comes from the directory service or a metadata update\n+        //\n+\n+        // When it is a metadata update request, only store the metadata if the GTS is already known\n+        if (Configuration.INGRESS_METADATA_UPDATE_ENDPOINT.equals(metadata.getSource())\n+            || Configuration.INGRESS_METADATA_UPDATE_DELTA_ENDPOINT.equals(metadata.getSource())) {\n+          if (classids.containsKey(metadata.getName())) {\n+            // 128BITS\n+            long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n+            if (metadatas.get(metadata.getName()).containsKey(labelsId)) {\n+              // Check the activity so we only increase it\n+              // 128 bits\n+              Metadata meta = metadatas.get(metadata.getName()).get(labelsId);\n+              long currentLastActivity = meta.getLastActivity();\n+              if (metadata.getLastActivity() < currentLastActivity) {\n+                metadata.setLastActivity(currentLastActivity);\n+              }\n+\n+              mustStore = true;\n+            }\n+          }\n+        } else {\n+          mustStore = true;\n+        }\n       }\n     }\n+\n+    if(mustStore) {\n+      store(metadata);\n+    }\n   }\n \n   public void unregister(Metadata metadata) {\n     // 128BITS\n-    long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n+    long labelsId;\n \n     synchronized (metadatas) {\n       if (!classids.containsKey(metadata.getName())) {\n         return;\n       }\n+      labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n       if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n         return;\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjk0Nw==", "url": "https://github.com/senx/warp10-platform/pull/866#discussion_r518722947", "bodyText": "On line 632 (in register), the call to metadatas.get() could throw an NPE if the entry for that class name is removed on line 598. The solution would be to protect the part in register with a syncrhonized block on metadatas", "author": "hbs", "createdAt": "2020-11-06T12:34:00Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java", "diffHunk": "@@ -680,19 +681,22 @@ public void register(Metadata metadata) throws IOException {\n     }\n   }\n \n-  public synchronized void unregister(Metadata metadata) {\n-    if (!classids.containsKey(metadata.getName())) {\n-      return;\n-    }\n+  public void unregister(Metadata metadata) {\n     // 128BITS\n     long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n-    if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n-      return;\n-    }\n-    metadatas.get(metadata.getName()).remove(labelsId);\n-    if (metadatas.get(metadata.getName()).isEmpty()) {\n-      metadatas.remove(metadata.getName());\n-      classids.remove(metadata.getName());\n+\n+    synchronized (metadatas) {\n+      if (!classids.containsKey(metadata.getName())) {\n+        return;\n+      }\n+      if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n+        return;\n+      }\n+      metadatas.get(metadata.getName()).remove(labelsId);\n+      if (metadatas.get(metadata.getName()).isEmpty()) {\n+        metadatas.remove(metadata.getName());\n+        classids.remove(metadata.getName());", "originalCommit": "cd9448e3cec1283caa1cbe9c29560862a80fb7b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyODg3NQ==", "url": "https://github.com/senx/warp10-platform/pull/866#discussion_r518728875", "bodyText": "So register and unregister might have to be mutually exclusive, hence maybe both synchronized", "author": "hbs", "createdAt": "2020-11-06T12:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTg5Mzk3OA==", "url": "https://github.com/senx/warp10-platform/pull/866#discussion_r519893978", "bodyText": "I tried to reduce at the minimum synchronization, avoiding making method synchronized.", "author": "ftence", "createdAt": "2020-11-09T15:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODcyMjk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "0e09ecfa9e195c36877e5bd0973d4502c43bbd47", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\nindex 22b49ac4..f9dea002 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\n\n@@ -622,73 +631,84 @@ public class StandaloneDirectoryClient implements DirectoryClient {\n     // If the metadata are not known, register them\n     //\n \n-    if (Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource()) && !classids.containsKey(metadata.getName())) {\n-      store(metadata);\n-    } else if (Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource())) {\n-      // Compute labelsId\n-      // 128BITS\n-      long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n-\n-      if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n-        // Metadata is unknown so we know the Metadata should be stored\n-        store(metadata);\n-      } else {\n-        // Check that we do not have a collision\n-        if (!metadatas.get(metadata.getName()).get(labelsId).getLabels().equals(metadata.getLabels())) {\n-          LOG.warn(\"LabelsId collision under class '\" + metadata.getName() + \"' \" + metadata.getLabels() + \" and \" + metadatas.get(metadata.getName()).get(labelsId).getLabels());\n-          Sensision.update(SensisionConstants.CLASS_WARP_DIRECTORY_LABELS_COLLISIONS, Sensision.EMPTY_LABELS, 1);\n-        }\n-\n-        //\n-        // Check activity of the GTS, storing it if the activity window has passed\n-        if (activityWindow > 0) {\n-          //\n-          // If the currently stored lastactivity is more than 'activityWindow' before the one in 'metadata',\n-          // store the metadata\n-          //\n-          long currentLastActivity = metadatas.get(metadata.getName()).get(labelsId).getLastActivity();\n-          if (metadata.getLastActivity() - currentLastActivity >= activityWindow) {\n-            store(metadata);\n-          }\n-        }\n-      }\n-    } else if (!Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource())) {\n-      //\n-      // Metadata registration is not from Ingress, this means we can update the value as it comes from the directory service or a metadata update\n-      //\n+    boolean mustStore = false;\n \n-      // When it is a metadata update request, only store the metadata if the GTS is already known\n-      if (Configuration.INGRESS_METADATA_UPDATE_ENDPOINT.equals(metadata.getSource())\n-          || Configuration.INGRESS_METADATA_UPDATE_DELTA_ENDPOINT.equals(metadata.getSource())) {\n-        if (classids.containsKey(metadata.getName())) {\n+    synchronized(metadatas) {\n+      if (Configuration.INGRESS_METADATA_SOURCE.equals(metadata.getSource())) {\n+        if (!classids.containsKey(metadata.getName())) {\n+          mustStore = true;\n+        } else {\n+          // Compute labelsId\n           // 128BITS\n           long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n-          if (metadatas.get(metadata.getName()).containsKey(labelsId)) {\n-            // Check the activity so we only increase it\n-            // 128 bits\n-            Metadata meta = metadatas.get(metadata.getName()).get(labelsId);\n-            long currentLastActivity = meta.getLastActivity();\n-            if (metadata.getLastActivity() < currentLastActivity) {\n-              metadata.setLastActivity(currentLastActivity);\n+\n+          if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n+            // Metadata is unknown so we know the Metadata should be stored\n+            mustStore = true;\n+          } else {\n+            // Check that we do not have a collision\n+            if (!metadatas.get(metadata.getName()).get(labelsId).getLabels().equals(metadata.getLabels())) {\n+              LOG.warn(\"LabelsId collision under class '\" + metadata.getName() + \"' \" + metadata.getLabels() + \" and \" + metadatas.get(metadata.getName()).get(labelsId).getLabels());\n+              Sensision.update(SensisionConstants.CLASS_WARP_DIRECTORY_LABELS_COLLISIONS, Sensision.EMPTY_LABELS, 1);\n             }\n \n-            store(metadata);\n+            //\n+            // Check activity of the GTS, storing it if the activity window has passed\n+            if (activityWindow > 0) {\n+              //\n+              // If the currently stored lastactivity is more than 'activityWindow' before the one in 'metadata',\n+              // store the metadata\n+              //\n+              long currentLastActivity = metadatas.get(metadata.getName()).get(labelsId).getLastActivity();\n+              if (metadata.getLastActivity() - currentLastActivity >= activityWindow) {\n+                mustStore = true;\n+              }\n+            }\n           }\n         }\n       } else {\n-        store(metadata);\n+        //\n+        // Metadata registration is not from Ingress, this means we can update the value as it comes from the directory service or a metadata update\n+        //\n+\n+        // When it is a metadata update request, only store the metadata if the GTS is already known\n+        if (Configuration.INGRESS_METADATA_UPDATE_ENDPOINT.equals(metadata.getSource())\n+            || Configuration.INGRESS_METADATA_UPDATE_DELTA_ENDPOINT.equals(metadata.getSource())) {\n+          if (classids.containsKey(metadata.getName())) {\n+            // 128BITS\n+            long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n+            if (metadatas.get(metadata.getName()).containsKey(labelsId)) {\n+              // Check the activity so we only increase it\n+              // 128 bits\n+              Metadata meta = metadatas.get(metadata.getName()).get(labelsId);\n+              long currentLastActivity = meta.getLastActivity();\n+              if (metadata.getLastActivity() < currentLastActivity) {\n+                metadata.setLastActivity(currentLastActivity);\n+              }\n+\n+              mustStore = true;\n+            }\n+          }\n+        } else {\n+          mustStore = true;\n+        }\n       }\n     }\n+\n+    if(mustStore) {\n+      store(metadata);\n+    }\n   }\n \n   public void unregister(Metadata metadata) {\n     // 128BITS\n-    long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n+    long labelsId;\n \n     synchronized (metadatas) {\n       if (!classids.containsKey(metadata.getName())) {\n         return;\n       }\n+      labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n       if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n         return;\n       }\n"}}, {"oid": "0e09ecfa9e195c36877e5bd0973d4502c43bbd47", "url": "https://github.com/senx/warp10-platform/commit/0e09ecfa9e195c36877e5bd0973d4502c43bbd47", "message": "Tighter synchronisation to avoid NPE due to concurrent modifications", "committedDate": "2020-11-06T17:14:23Z", "type": "commit"}, {"oid": "3904cea71e545067a6a7aedd8423a67ade85824b", "url": "https://github.com/senx/warp10-platform/commit/3904cea71e545067a6a7aedd8423a67ade85824b", "message": "More checks to avoid NPEs", "committedDate": "2020-11-09T14:18:51Z", "type": "commit"}, {"oid": "909377a3ad61179aed22ee5d359978e613654719", "url": "https://github.com/senx/warp10-platform/commit/909377a3ad61179aed22ee5d359978e613654719", "message": "Finer synchronization", "committedDate": "2020-11-09T15:20:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTc5Nzc1OA==", "url": "https://github.com/senx/warp10-platform/pull/866#discussion_r531797758", "bodyText": "Actually second thoughts about where labelsId is computed. If it is occasional to call unregister for a GTS whose class is  no longer known it might be better to always compute labelsId where labelsId is declared rather than in the synchronized block since the computation is CPU heavy and therefore would extend the time spent in the syncrhonized block which would block all threads attempting to synchronize on metadatas. So probably better to always compute labelsId and do so outside of the synchronized block.", "author": "hbs", "createdAt": "2020-11-27T22:18:40Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java", "diffHunk": "@@ -680,19 +706,23 @@ public void register(Metadata metadata) throws IOException {\n     }\n   }\n \n-  public synchronized void unregister(Metadata metadata) {\n-    if (!classids.containsKey(metadata.getName())) {\n-      return;\n-    }\n+  public void unregister(Metadata metadata) {\n     // 128BITS\n-    long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n-    if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n-      return;\n-    }\n-    metadatas.get(metadata.getName()).remove(labelsId);\n-    if (metadatas.get(metadata.getName()).isEmpty()) {\n-      metadatas.remove(metadata.getName());\n-      classids.remove(metadata.getName());\n+    long labelsId;\n+\n+    synchronized(metadatas) {\n+      if (!classids.containsKey(metadata.getName())) {\n+        return;\n+      }\n+      labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());", "originalCommit": "909377a3ad61179aed22ee5d359978e613654719", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "03b12ec232e31778305146fd3fb78e06de64a1d0", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\nindex b2d8e219..e3f7daf2 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneDirectoryClient.java\n\n@@ -707,14 +707,16 @@ public class StandaloneDirectoryClient implements DirectoryClient {\n   }\n \n   public void unregister(Metadata metadata) {\n+    // Always compute the labelsId, even if the method early returns before needing it. This is because this operation\n+    // can be CPU-intensive and if done inside the synchronized(metadatas) block, would block other threads also\n+    // synchronizing on metadatas. As unregistering unknown metadata should be rare, this is an acceptable compromise.\n     // 128BITS\n-    long labelsId;\n+    long labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n \n     synchronized(metadatas) {\n       if (!classids.containsKey(metadata.getName())) {\n         return;\n       }\n-      labelsId = GTSHelper.labelsId(this.labelsLongs, metadata.getLabels());\n       if (!metadatas.get(metadata.getName()).containsKey(labelsId)) {\n         return;\n       }\n"}}, {"oid": "03b12ec232e31778305146fd3fb78e06de64a1d0", "url": "https://github.com/senx/warp10-platform/commit/03b12ec232e31778305146fd3fb78e06de64a1d0", "message": "Compute labelsId outside synchronized block", "committedDate": "2020-12-02T10:52:36Z", "type": "commit"}]}