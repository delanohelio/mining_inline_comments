{"pr_number": 772, "pr_title": "Initial commit of step and timestep support for data retrieval", "pr_createdAt": "2020-06-05T21:26:03Z", "pr_url": "https://github.com/senx/warp10-platform/pull/772", "timeline": [{"oid": "590b26d2cbe9c6cbd9e134169a3eb34c7e59f79c", "url": "https://github.com/senx/warp10-platform/commit/590b26d2cbe9c6cbd9e134169a3eb34c7e59f79c", "message": "Initial commit of step and timestep support for data retrieval", "committedDate": "2020-06-05T21:25:29Z", "type": "commit"}, {"oid": "f898837edfc47f079963b72bf9e5dcf223773a39", "url": "https://github.com/senx/warp10-platform/commit/f898837edfc47f079963b72bf9e5dcf223773a39", "message": "Fixed stepping", "committedDate": "2020-06-05T21:57:47Z", "type": "commit"}, {"oid": "c8bfc3d7553dee6c470c06f08cd609e23014f2ed", "url": "https://github.com/senx/warp10-platform/commit/c8bfc3d7553dee6c470c06f08cd609e23014f2ed", "message": "Added unconditional seek when applying timestep", "committedDate": "2020-06-05T22:09:46Z", "type": "commit"}, {"oid": "dfd6e2f4e27c476f431638e3fe5b52d541af13f7", "url": "https://github.com/senx/warp10-platform/commit/dfd6e2f4e27c476f431638e3fe5b52d541af13f7", "message": "Refactored to introduce FetchRequest to simplify signatures", "committedDate": "2020-06-06T07:28:59Z", "type": "commit"}, {"oid": "845eb5f6c87f71e59c19b2331ef453a1d9f34fc0", "url": "https://github.com/senx/warp10-platform/commit/845eb5f6c87f71e59c19b2331ef453a1d9f34fc0", "message": "Added comments", "committedDate": "2020-06-06T07:31:24Z", "type": "commit"}, {"oid": "5126dc10079ad11bd4b5c7492f155a6a37dbbcb6", "url": "https://github.com/senx/warp10-platform/commit/5126dc10079ad11bd4b5c7492f155a6a37dbbcb6", "message": "Commented FetchRequest fields", "committedDate": "2020-06-06T07:48:45Z", "type": "commit"}, {"oid": "3e372e39ca060fae471a41649d37145f2ebabf81", "url": "https://github.com/senx/warp10-platform/commit/3e372e39ca060fae471a41649d37145f2ebabf81", "message": "Added TODO", "committedDate": "2020-06-06T14:54:51Z", "type": "commit"}, {"oid": "54d9d3342ac97883b72d0272709c77d58d347b62", "url": "https://github.com/senx/warp10-platform/commit/54d9d3342ac97883b72d0272709c77d58d347b62", "message": "Added support for step/timestep/sample/skip in SlicedRowFilterGTSDecoderIterator", "committedDate": "2020-06-07T13:54:38Z", "type": "commit"}, {"oid": "ee091ddcdc596477e812058c73a376097f4f42b6", "url": "https://github.com/senx/warp10-platform/commit/ee091ddcdc596477e812058c73a376097f4f42b6", "message": "Cleaned imports", "committedDate": "2020-06-07T13:55:58Z", "type": "commit"}, {"oid": "b6ca925b699873c98a623266908a564b16c613bb", "url": "https://github.com/senx/warp10-platform/commit/b6ca925b699873c98a623266908a564b16c613bb", "message": "Disabled use of filter when fetching by count with step/timestep/skip/sample", "committedDate": "2020-06-07T14:01:10Z", "type": "commit"}, {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958", "url": "https://github.com/senx/warp10-platform/commit/e07598603051ad7fa838f08bfec01a2aa247f958", "message": "Added support for advanced fetch parameters in Warp10InputFormat", "committedDate": "2020-06-09T21:01:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MDA0OA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441380048", "bodyText": "1 is a valid value, although it does nothing different than not specifying step at all.", "author": "ftence", "createdAt": "2020-06-17T08:39:58Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "diffHunk": "@@ -314,6 +343,38 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H\n         skip = Long.parseLong(skipParam);        \n       }\n       \n+      if (null != stepParam) {\n+        step = Long.parseLong(stepParam);\n+        if (step <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        }", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java b/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\nindex 0a3de908..3023566c 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\n\n@@ -345,33 +347,29 @@ public class EgressFetchHandler extends AbstractHandler {\n       \n       if (null != stepParam) {\n         step = Long.parseLong(stepParam);\n-        if (step <= 1) {\n-          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        if (step < 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be < 1.\");\n         }\n       }\n       \n       if (null != timestepParam) {\n         if (timestepParam.startsWith(\"P\")) {\n-          // Should be a ISO8601 duration\n-          ReadWritablePeriod period = new MutablePeriod();\n-\n-          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n-\n-          Period p = period.toPeriod();\n+          \n+          ADDDURATION.ReadWritablePeriodWithSubSecondOffset periodWithSubSec = ADDDURATION.durationToPeriod(timestepParam);\n+          \n+          ReadWritablePeriod p = periodWithSubSec.getPeriod();\n \n-          if (p.getMonths() != 0 || p.getYears() != 0) {\n+          if (p.get(DurationFieldType.months()) != 0 || p.get(DurationFieldType.years()) != 0) {\n             throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n           }\n \n-          Duration duration = p.toDurationFrom(new Instant());\n-\n-          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;\n+          timestep = periodWithSubSec.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + periodWithSubSec.getOffset();\n         } else {\n           timestep = Long.parseLong(timestepParam);\n         }\n         \n-        if (timestep <= 1) {\n-          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+        if (timestep < 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be < 1.\");\n         }\n       }\n       \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MjA3Mw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441382073", "bodyText": "1 is valid.", "author": "ftence", "createdAt": "2020-06-17T08:43:04Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "diffHunk": "@@ -314,6 +343,38 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H\n         skip = Long.parseLong(skipParam);        \n       }\n       \n+      if (null != stepParam) {\n+        step = Long.parseLong(stepParam);\n+        if (step <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        }\n+      }\n+      \n+      if (null != timestepParam) {\n+        if (timestepParam.startsWith(\"P\")) {\n+          // Should be a ISO8601 duration\n+          ReadWritablePeriod period = new MutablePeriod();\n+\n+          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n+\n+          Period p = period.toPeriod();\n+\n+          if (p.getMonths() != 0 || p.getYears() != 0) {\n+            throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n+          }\n+\n+          Duration duration = p.toDurationFrom(new Instant());\n+\n+          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;\n+        } else {\n+          timestep = Long.parseLong(timestepParam);\n+        }\n+        \n+        if (timestep <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+        }", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java b/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\nindex 0a3de908..3023566c 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\n\n@@ -345,33 +347,29 @@ public class EgressFetchHandler extends AbstractHandler {\n       \n       if (null != stepParam) {\n         step = Long.parseLong(stepParam);\n-        if (step <= 1) {\n-          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        if (step < 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be < 1.\");\n         }\n       }\n       \n       if (null != timestepParam) {\n         if (timestepParam.startsWith(\"P\")) {\n-          // Should be a ISO8601 duration\n-          ReadWritablePeriod period = new MutablePeriod();\n-\n-          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n-\n-          Period p = period.toPeriod();\n+          \n+          ADDDURATION.ReadWritablePeriodWithSubSecondOffset periodWithSubSec = ADDDURATION.durationToPeriod(timestepParam);\n+          \n+          ReadWritablePeriod p = periodWithSubSec.getPeriod();\n \n-          if (p.getMonths() != 0 || p.getYears() != 0) {\n+          if (p.get(DurationFieldType.months()) != 0 || p.get(DurationFieldType.years()) != 0) {\n             throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n           }\n \n-          Duration duration = p.toDurationFrom(new Instant());\n-\n-          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;\n+          timestep = periodWithSubSec.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + periodWithSubSec.getOffset();\n         } else {\n           timestep = Long.parseLong(timestepParam);\n         }\n         \n-        if (timestep <= 1) {\n-          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+        if (timestep < 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be < 1.\");\n         }\n       }\n       \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQwMDQ2Nw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441400467", "bodyText": "Better use\nADDDURATION.ReadWritablePeriodWithSubSecondOffset periodWithSubSec = ADDDURATION.durationToPeriod(timestepParam);\n// Check that the period does not have months or year\ntimestep = periodWithSubSec.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + periodWithSubSec.getOffset();\n\nto allow sub-millisecond precision with ISO 8601 representation.", "author": "ftence", "createdAt": "2020-06-17T09:12:09Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "diffHunk": "@@ -314,6 +343,38 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H\n         skip = Long.parseLong(skipParam);        \n       }\n       \n+      if (null != stepParam) {\n+        step = Long.parseLong(stepParam);\n+        if (step <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        }\n+      }\n+      \n+      if (null != timestepParam) {\n+        if (timestepParam.startsWith(\"P\")) {\n+          // Should be a ISO8601 duration\n+          ReadWritablePeriod period = new MutablePeriod();\n+\n+          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n+\n+          Period p = period.toPeriod();\n+\n+          if (p.getMonths() != 0 || p.getYears() != 0) {\n+            throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n+          }\n+\n+          Duration duration = p.toDurationFrom(new Instant());\n+\n+          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java b/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\nindex 0a3de908..3023566c 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java\n\n@@ -345,33 +347,29 @@ public class EgressFetchHandler extends AbstractHandler {\n       \n       if (null != stepParam) {\n         step = Long.parseLong(stepParam);\n-        if (step <= 1) {\n-          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        if (step < 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be < 1.\");\n         }\n       }\n       \n       if (null != timestepParam) {\n         if (timestepParam.startsWith(\"P\")) {\n-          // Should be a ISO8601 duration\n-          ReadWritablePeriod period = new MutablePeriod();\n-\n-          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n-\n-          Period p = period.toPeriod();\n+          \n+          ADDDURATION.ReadWritablePeriodWithSubSecondOffset periodWithSubSec = ADDDURATION.durationToPeriod(timestepParam);\n+          \n+          ReadWritablePeriod p = periodWithSubSec.getPeriod();\n \n-          if (p.getMonths() != 0 || p.getYears() != 0) {\n+          if (p.get(DurationFieldType.months()) != 0 || p.get(DurationFieldType.years()) != 0) {\n             throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n           }\n \n-          Duration duration = p.toDurationFrom(new Instant());\n-\n-          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;\n+          timestep = periodWithSubSec.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + periodWithSubSec.getOffset();\n         } else {\n           timestep = Long.parseLong(timestepParam);\n         }\n         \n-        if (timestep <= 1) {\n-          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+        if (timestep < 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be < 1.\");\n         }\n       }\n       \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQwODMzOA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441408338", "bodyText": "Update the javadoc to reflect that this function takes only one parameter, leaving the description of its fields.\nAlso change then to thents.", "author": "ftence", "createdAt": "2020-06-17T09:24:49Z", "path": "warp10/src/main/java/io/warp10/continuum/store/StoreClient.java", "diffHunk": "@@ -36,13 +35,15 @@\n    * @param then Start timestamp (included)\n    * @param count Number of datapoints to fetch. 0 is a valid value if you want to fetch only boundaries. Use -1 to specify you are not fetching by count.\n    * @param skip Number of datapoints to skip before returning values\n+   * @param step Index offset between two datapoints, defaults to 1, i.e. return every data point\n+   * @param timestep Minimum time offset between datapoints, defaults to 1 time unit\n    * @param sample Double value representing the sampling rate. Use 1.0D for returning all values. Valid values are ] 0.0D, 1.0D ]\n    * @param writeTimestamp Flag indicating we are interested in the HBase cell timestamp\n    * @param preBoundary Size of the pre boundary in number of values\n    * @param postBoundary Size of the post boundary in number of values\n    * @return\n    * @throws IOException\n    */\n-  public GTSDecoderIterator fetch(ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) throws IOException;\n+  public GTSDecoderIterator fetch(FetchRequest req) throws IOException; //ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, long step, long timestep, double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) throws IOException;", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/StoreClient.java b/warp10/src/main/java/io/warp10/continuum/store/StoreClient.java\nindex 5385eb5c..8066f5d0 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/StoreClient.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/StoreClient.java\n\n@@ -28,22 +28,22 @@ public interface StoreClient {\n   public void store(GTSEncoder encoder) throws IOException;\n   public long delete(WriteToken token, Metadata metadata, long start, long end) throws IOException;\n   /**\n-   * \n-   * @param token Read token to use for reading data\n-   * @param metadatas List of Metadata for the GTS to fetch\n-   * @param now End timestamp (included)\n-   * @param then Start timestamp (included)\n-   * @param count Number of datapoints to fetch. 0 is a valid value if you want to fetch only boundaries. Use -1 to specify you are not fetching by count.\n-   * @param skip Number of datapoints to skip before returning values\n-   * @param step Index offset between two datapoints, defaults to 1, i.e. return every data point\n-   * @param timestep Minimum time offset between datapoints, defaults to 1 time unit\n-   * @param sample Double value representing the sampling rate. Use 1.0D for returning all values. Valid values are ] 0.0D, 1.0D ]\n-   * @param writeTimestamp Flag indicating we are interested in the HBase cell timestamp\n-   * @param preBoundary Size of the pre boundary in number of values\n-   * @param postBoundary Size of the post boundary in number of values\n+   * @param req FetchRequest instance containing the following elements:\n+   *   token Read token to use for reading data\n+   *   metadatas List of Metadata for the GTS to fetch\n+   *   now End timestamp (included)\n+   *   thents Start timestamp (included)\n+   *   count Number of datapoints to fetch. 0 is a valid value if you want to fetch only boundaries. Use -1 to specify you are not fetching by count.\n+   *   skip Number of datapoints to skip before returning values\n+   *   step Index offset between two datapoints, defaults to 1, i.e. return every data point\n+   *   timestep Minimum time offset between datapoints, defaults to 1 time unit\n+   *   sample Double value representing the sampling rate. Use 1.0D for returning all values. Valid values are ] 0.0D, 1.0D ]\n+   *   writeTimestamp Flag indicating we are interested in the HBase cell timestamp\n+   *   preBoundary Size of the pre boundary in number of values\n+   *   postBoundary Size of the post boundary in number of values\n    * @return\n    * @throws IOException\n    */\n-  public GTSDecoderIterator fetch(FetchRequest req) throws IOException; //ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, long step, long timestep, double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) throws IOException;\n+  public GTSDecoderIterator fetch(FetchRequest req) throws IOException;\n   public void addPlasmaHandler(StandalonePlasmaHandlerInterface handler);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5NzQ5Mg==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441497492", "bodyText": "You should factorize the FetchRequest construction, making sure to use the copy constructor.\nOnly preBoundary, postBoundary, step, timestep, sample, skip and count may have been modified, so setting the other fields after the copy constructor is not necessary.", "author": "ftence", "createdAt": "2020-06-17T12:12:25Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\nindex 8957b5c5..78df4efe 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n\n@@ -235,50 +233,25 @@ public class HBaseStoreClient implements StoreClient {\n       optimized = false;\n     }\n     \n+    FetchRequest freq = new FetchRequest(req);\n+    freq.setCount(count);\n+    freq.setSkip(skip);\n+    freq.setStep(step);\n+    freq.setTimestep(timestep);\n+    freq.setSample(sample);\n+    freq.setPreBoundary(preBoundary);\n+    freq.setPostBoundary(postBoundary);\n+\n+    boolean useBlockCache = metadatas.size() <= blockcacheThreshold;\n+\n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        FetchRequest freq = new FetchRequest(req);\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, useBlockCache);\n       } else {\n-        FetchRequest freq = new FetchRequest();\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, useBlockCache);      \n       }      \n     } else {\n-      FetchRequest freq = new FetchRequest();\n-      freq.setToken(req.getToken());\n-      freq.setNow(now);\n-      freq.setThents(then);\n-      freq.setCount(count);\n-      freq.setSkip(skip);\n-      freq.setStep(step);\n-      freq.setTimestep(timestep);\n-      freq.setSample(sample);\n-      freq.setMetadatas(metadatas);\n-      freq.setPreBoundary(preBoundary);\n-      freq.setPostBoundary(postBoundary);\n-      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, useBlockCache);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODE1MQ==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498151", "bodyText": "blockcacheThreshold comparison is not the exactly the same as the one used in OptimizedSlicedRowFilterGTSDecoderIterator.", "author": "ftence", "createdAt": "2020-06-17T12:13:40Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      ", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\nindex 8957b5c5..78df4efe 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n\n@@ -235,50 +233,25 @@ public class HBaseStoreClient implements StoreClient {\n       optimized = false;\n     }\n     \n+    FetchRequest freq = new FetchRequest(req);\n+    freq.setCount(count);\n+    freq.setSkip(skip);\n+    freq.setStep(step);\n+    freq.setTimestep(timestep);\n+    freq.setSample(sample);\n+    freq.setPreBoundary(preBoundary);\n+    freq.setPostBoundary(postBoundary);\n+\n+    boolean useBlockCache = metadatas.size() <= blockcacheThreshold;\n+\n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        FetchRequest freq = new FetchRequest(req);\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, useBlockCache);\n       } else {\n-        FetchRequest freq = new FetchRequest();\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, useBlockCache);      \n       }      \n     } else {\n-      FetchRequest freq = new FetchRequest();\n-      freq.setToken(req.getToken());\n-      freq.setNow(now);\n-      freq.setThents(then);\n-      freq.setCount(count);\n-      freq.setSkip(skip);\n-      freq.setStep(step);\n-      freq.setTimestep(timestep);\n-      freq.setSample(sample);\n-      freq.setMetadatas(metadatas);\n-      freq.setPreBoundary(preBoundary);\n-      freq.setPostBoundary(postBoundary);\n-      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, useBlockCache);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODIwNw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498207", "bodyText": "blockcacheThreshold comparison is not the exactly the same as the one used in OptimizedSlicedRowFilterGTSDecoderIterator.", "author": "ftence", "createdAt": "2020-06-17T12:13:46Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n       }      \n     } else {\n-      return new ParallelGTSDecoderIteratorWrapper(optimized, token, now, then, count, skip, sample, metadatas, keystore, this.conn, this.tableName, this.colfam, writeTimestamp, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);\n+      FetchRequest freq = new FetchRequest();\n+      freq.setToken(req.getToken());\n+      freq.setNow(now);\n+      freq.setThents(then);\n+      freq.setCount(count);\n+      freq.setSkip(skip);\n+      freq.setStep(step);\n+      freq.setTimestep(timestep);\n+      freq.setSample(sample);\n+      freq.setMetadatas(metadatas);\n+      freq.setPreBoundary(preBoundary);\n+      freq.setPostBoundary(postBoundary);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\nindex 8957b5c5..78df4efe 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n\n@@ -235,50 +233,25 @@ public class HBaseStoreClient implements StoreClient {\n       optimized = false;\n     }\n     \n+    FetchRequest freq = new FetchRequest(req);\n+    freq.setCount(count);\n+    freq.setSkip(skip);\n+    freq.setStep(step);\n+    freq.setTimestep(timestep);\n+    freq.setSample(sample);\n+    freq.setPreBoundary(preBoundary);\n+    freq.setPostBoundary(postBoundary);\n+\n+    boolean useBlockCache = metadatas.size() <= blockcacheThreshold;\n+\n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        FetchRequest freq = new FetchRequest(req);\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, useBlockCache);\n       } else {\n-        FetchRequest freq = new FetchRequest();\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, useBlockCache);      \n       }      \n     } else {\n-      FetchRequest freq = new FetchRequest();\n-      freq.setToken(req.getToken());\n-      freq.setNow(now);\n-      freq.setThents(then);\n-      freq.setCount(count);\n-      freq.setSkip(skip);\n-      freq.setStep(step);\n-      freq.setTimestep(timestep);\n-      freq.setSample(sample);\n-      freq.setMetadatas(metadatas);\n-      freq.setPreBoundary(preBoundary);\n-      freq.setPostBoundary(postBoundary);\n-      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, useBlockCache);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODU0Nw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498547", "bodyText": "Factorize or use copy constructor because writeTimestamp is not copied.", "author": "ftence", "createdAt": "2020-06-17T12:14:28Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\nindex 8957b5c5..78df4efe 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n\n@@ -235,50 +233,25 @@ public class HBaseStoreClient implements StoreClient {\n       optimized = false;\n     }\n     \n+    FetchRequest freq = new FetchRequest(req);\n+    freq.setCount(count);\n+    freq.setSkip(skip);\n+    freq.setStep(step);\n+    freq.setTimestep(timestep);\n+    freq.setSample(sample);\n+    freq.setPreBoundary(preBoundary);\n+    freq.setPostBoundary(postBoundary);\n+\n+    boolean useBlockCache = metadatas.size() <= blockcacheThreshold;\n+\n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        FetchRequest freq = new FetchRequest(req);\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, useBlockCache);\n       } else {\n-        FetchRequest freq = new FetchRequest();\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, useBlockCache);      \n       }      \n     } else {\n-      FetchRequest freq = new FetchRequest();\n-      freq.setToken(req.getToken());\n-      freq.setNow(now);\n-      freq.setThents(then);\n-      freq.setCount(count);\n-      freq.setSkip(skip);\n-      freq.setStep(step);\n-      freq.setTimestep(timestep);\n-      freq.setSample(sample);\n-      freq.setMetadatas(metadatas);\n-      freq.setPreBoundary(preBoundary);\n-      freq.setPostBoundary(postBoundary);\n-      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, useBlockCache);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODYwMg==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498602", "bodyText": "Factorize or use copy constructor because writeTimestamp is not copied.", "author": "ftence", "createdAt": "2020-06-17T12:14:33Z", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n       }      \n     } else {\n-      return new ParallelGTSDecoderIteratorWrapper(optimized, token, now, then, count, skip, sample, metadatas, keystore, this.conn, this.tableName, this.colfam, writeTimestamp, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);\n+      FetchRequest freq = new FetchRequest();", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\nindex 8957b5c5..78df4efe 100644\n--- a/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java\n\n@@ -235,50 +233,25 @@ public class HBaseStoreClient implements StoreClient {\n       optimized = false;\n     }\n     \n+    FetchRequest freq = new FetchRequest(req);\n+    freq.setCount(count);\n+    freq.setSkip(skip);\n+    freq.setStep(step);\n+    freq.setTimestep(timestep);\n+    freq.setSample(sample);\n+    freq.setPreBoundary(preBoundary);\n+    freq.setPostBoundary(postBoundary);\n+\n+    boolean useBlockCache = metadatas.size() <= blockcacheThreshold;\n+\n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        FetchRequest freq = new FetchRequest(req);\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, useBlockCache);\n       } else {\n-        FetchRequest freq = new FetchRequest();\n-        freq.setToken(req.getToken());\n-        freq.setNow(now);\n-        freq.setThents(then);\n-        freq.setCount(count);\n-        freq.setSkip(skip);\n-        freq.setStep(step);\n-        freq.setTimestep(timestep);\n-        freq.setSample(sample);\n-        freq.setMetadatas(metadatas);\n-        freq.setPreBoundary(preBoundary);\n-        freq.setPostBoundary(postBoundary);\n-        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, useBlockCache);      \n       }      \n     } else {\n-      FetchRequest freq = new FetchRequest();\n-      freq.setToken(req.getToken());\n-      freq.setNow(now);\n-      freq.setThents(then);\n-      freq.setCount(count);\n-      freq.setSkip(skip);\n-      freq.setStep(step);\n-      freq.setTimestep(timestep);\n-      freq.setSample(sample);\n-      freq.setMetadatas(metadatas);\n-      freq.setPreBoundary(preBoundary);\n-      freq.setPostBoundary(postBoundary);\n-      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, useBlockCache);\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwMDAzMA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441500030", "bodyText": "Is there a reason not to use the 1L default value?", "author": "ftence", "createdAt": "2020-06-17T12:17:13Z", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -94,25 +95,36 @@\n   private long count = -1;\n   private long skip = 0;\n   private double sample = 1.0D;\n+  private long step = -1L;\n+  private long timestep = -1L;", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\nindex 3329a8ee..5030cf55 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n\n@@ -95,8 +95,8 @@ public class MultiScanGTSDecoderIterator extends GTSDecoderIterator {\n   private long count = -1;\n   private long skip = 0;\n   private double sample = 1.0D;\n-  private long step = -1L;\n-  private long timestep = -1L;\n+  private long step = 1L;\n+  private long timestep = 1L;\n   \n   private long nextTimestamp = Long.MAX_VALUE;\n   private long steps = 0L;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMDQyNw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441510427", "bodyText": "Typo.", "author": "ftence", "createdAt": "2020-06-17T12:35:42Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -426,6 +514,7 @@ public boolean hasNext() {\n             return false;\n           }\n \n+          // 128buts", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\nindex b08de148..a976cc72 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n\n@@ -514,7 +515,7 @@ public class StandaloneStoreClient implements StoreClient {\n             return false;\n           }\n \n-          // 128buts\n+          // 128bits\n           startrow = new byte[Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 8 + 8 + 8];\n           ByteBuffer bb = ByteBuffer.wrap(startrow).order(ByteOrder.BIG_ENDIAN);\n           bb.put(Constants.HBASE_RAW_DATA_KEY_PREFIX);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjUzOQ==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441516539", "bodyText": "Shouldn't it be timestamp instead of basets?", "author": "ftence", "createdAt": "2020-06-17T12:45:58Z", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMzE1NQ==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r442913155", "bodyText": "They are actually the same when DEFAULT_MODULUS==1", "author": "hbs", "createdAt": "2020-06-19T15:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\nindex 3329a8ee..5030cf55 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n\n@@ -422,43 +408,47 @@ public class MultiScanGTSDecoderIterator extends GTSDecoderIterator {\n                         \n             if (preBoundaryScan || postBoundaryScan || (timestamp <= now && timestamp >= then)) {\n               try {\n-                // Skip\n-                if (toskip > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  toskip--;\n-                  continue;\n-                }\n-                \n-                // The timestamp is still after the one we expect\n-                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n-                  continue;\n-                }\n+                if (!preBoundaryScan && !postBoundaryScan) {\n+                  // Skip\n+                  if (toskip > 0) {\n+                    toskip--;\n+                    continue;\n+                  }\n \n-                //\n-                // Compute the new value of nextTimestamp if timestep is set\n-                //\n-                if (hasTimestep) {\n-                  try {\n-                    nextTimestamp = Math.addExact(basets, -timestep);\n-                  } catch (ArithmeticException ae) {\n-                    nextTimestamp = Long.MIN_VALUE;\n-                  }                 \n-                }\n+                  // The timestamp is still after the one we expect\n+                  if (timestamp > nextTimestamp) {\n+                    continue;\n+                  }\n+                  \n+                  //\n+                  // Compute the new value of nextTimestamp if timestep is set\n+                  //\n+                  if (hasTimestep) {\n+                    try {\n+                      nextTimestamp = Math.subtractExact(timestamp, timestep);\n+                    } catch (ArithmeticException ae) {\n+                      nextTimestamp = Long.MIN_VALUE;\n+                      // set nvalues to 0 so we stop after the current value\n+                      nvalues = 0L;\n+                    }\n+                  }\n+                  \n+                  // We have not yet stepped over enough entries\n+                  if (steps > 0) {\n+                    steps--;\n+                    continue;\n+                  }\n+                  \n+                  if (hasStep) {\n+                    steps = step - 1L;\n+                  }\n \n-                // We have not yet stepped over enough entries\n-                if (steps > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  steps--;\n-                  continue;\n+                  // Sample if we have to\n+                  if (1.0D != sample && prng.nextDouble() > sample) {\n+                    continue;\n+                  }                               \n                 }\n-                \n-                if (hasStep) {\n-                  steps = step - 1L;\n-                }\n-\n-                // Sample if we have to\n-                if (1.0D != sample && !preBoundaryScan && !postBoundaryScan && prng.nextDouble() > sample) {\n-                  continue;\n-                }                               \n-                \n+                                \n                 if (writeTimestamp) {\n                   encoder.addValue(timestamp, decoder.getLocation(), decoder.getElevation(), cell.getTimestamp() * Constants.TIME_UNITS_PER_MS);\n                 } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjg1Nw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441516857", "bodyText": "Shouldn't it be timestamp instead of basets?\nAlso why not use subtractExact?", "author": "ftence", "createdAt": "2020-06-17T12:46:28Z", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n+                  continue;\n+                }\n+\n+                //\n+                // Compute the new value of nextTimestamp if timestep is set\n+                //\n+                if (hasTimestep) {\n+                  try {\n+                    nextTimestamp = Math.addExact(basets, -timestep);", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\nindex 3329a8ee..5030cf55 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n\n@@ -422,43 +408,47 @@ public class MultiScanGTSDecoderIterator extends GTSDecoderIterator {\n                         \n             if (preBoundaryScan || postBoundaryScan || (timestamp <= now && timestamp >= then)) {\n               try {\n-                // Skip\n-                if (toskip > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  toskip--;\n-                  continue;\n-                }\n-                \n-                // The timestamp is still after the one we expect\n-                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n-                  continue;\n-                }\n+                if (!preBoundaryScan && !postBoundaryScan) {\n+                  // Skip\n+                  if (toskip > 0) {\n+                    toskip--;\n+                    continue;\n+                  }\n \n-                //\n-                // Compute the new value of nextTimestamp if timestep is set\n-                //\n-                if (hasTimestep) {\n-                  try {\n-                    nextTimestamp = Math.addExact(basets, -timestep);\n-                  } catch (ArithmeticException ae) {\n-                    nextTimestamp = Long.MIN_VALUE;\n-                  }                 \n-                }\n+                  // The timestamp is still after the one we expect\n+                  if (timestamp > nextTimestamp) {\n+                    continue;\n+                  }\n+                  \n+                  //\n+                  // Compute the new value of nextTimestamp if timestep is set\n+                  //\n+                  if (hasTimestep) {\n+                    try {\n+                      nextTimestamp = Math.subtractExact(timestamp, timestep);\n+                    } catch (ArithmeticException ae) {\n+                      nextTimestamp = Long.MIN_VALUE;\n+                      // set nvalues to 0 so we stop after the current value\n+                      nvalues = 0L;\n+                    }\n+                  }\n+                  \n+                  // We have not yet stepped over enough entries\n+                  if (steps > 0) {\n+                    steps--;\n+                    continue;\n+                  }\n+                  \n+                  if (hasStep) {\n+                    steps = step - 1L;\n+                  }\n \n-                // We have not yet stepped over enough entries\n-                if (steps > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  steps--;\n-                  continue;\n+                  // Sample if we have to\n+                  if (1.0D != sample && prng.nextDouble() > sample) {\n+                    continue;\n+                  }                               \n                 }\n-                \n-                if (hasStep) {\n-                  steps = step - 1L;\n-                }\n-\n-                // Sample if we have to\n-                if (1.0D != sample && !preBoundaryScan && !postBoundaryScan && prng.nextDouble() > sample) {\n-                  continue;\n-                }                               \n-                \n+                                \n                 if (writeTimestamp) {\n                   encoder.addValue(timestamp, decoder.getLocation(), decoder.getElevation(), cell.getTimestamp() * Constants.TIME_UNITS_PER_MS);\n                 } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMDIzNg==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441520236", "bodyText": "This is a valid timestamp, should we set nvalues to 0 to avoid returning the data at Long.MIN_VALUE timestamp?", "author": "ftence", "createdAt": "2020-06-17T12:52:06Z", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n+                  continue;\n+                }\n+\n+                //\n+                // Compute the new value of nextTimestamp if timestep is set\n+                //\n+                if (hasTimestep) {\n+                  try {\n+                    nextTimestamp = Math.addExact(basets, -timestep);\n+                  } catch (ArithmeticException ae) {\n+                    nextTimestamp = Long.MIN_VALUE;", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\nindex 3329a8ee..5030cf55 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n\n@@ -422,43 +408,47 @@ public class MultiScanGTSDecoderIterator extends GTSDecoderIterator {\n                         \n             if (preBoundaryScan || postBoundaryScan || (timestamp <= now && timestamp >= then)) {\n               try {\n-                // Skip\n-                if (toskip > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  toskip--;\n-                  continue;\n-                }\n-                \n-                // The timestamp is still after the one we expect\n-                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n-                  continue;\n-                }\n+                if (!preBoundaryScan && !postBoundaryScan) {\n+                  // Skip\n+                  if (toskip > 0) {\n+                    toskip--;\n+                    continue;\n+                  }\n \n-                //\n-                // Compute the new value of nextTimestamp if timestep is set\n-                //\n-                if (hasTimestep) {\n-                  try {\n-                    nextTimestamp = Math.addExact(basets, -timestep);\n-                  } catch (ArithmeticException ae) {\n-                    nextTimestamp = Long.MIN_VALUE;\n-                  }                 \n-                }\n+                  // The timestamp is still after the one we expect\n+                  if (timestamp > nextTimestamp) {\n+                    continue;\n+                  }\n+                  \n+                  //\n+                  // Compute the new value of nextTimestamp if timestep is set\n+                  //\n+                  if (hasTimestep) {\n+                    try {\n+                      nextTimestamp = Math.subtractExact(timestamp, timestep);\n+                    } catch (ArithmeticException ae) {\n+                      nextTimestamp = Long.MIN_VALUE;\n+                      // set nvalues to 0 so we stop after the current value\n+                      nvalues = 0L;\n+                    }\n+                  }\n+                  \n+                  // We have not yet stepped over enough entries\n+                  if (steps > 0) {\n+                    steps--;\n+                    continue;\n+                  }\n+                  \n+                  if (hasStep) {\n+                    steps = step - 1L;\n+                  }\n \n-                // We have not yet stepped over enough entries\n-                if (steps > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  steps--;\n-                  continue;\n+                  // Sample if we have to\n+                  if (1.0D != sample && prng.nextDouble() > sample) {\n+                    continue;\n+                  }                               \n                 }\n-                \n-                if (hasStep) {\n-                  steps = step - 1L;\n-                }\n-\n-                // Sample if we have to\n-                if (1.0D != sample && !preBoundaryScan && !postBoundaryScan && prng.nextDouble() > sample) {\n-                  continue;\n-                }                               \n-                \n+                                \n                 if (writeTimestamp) {\n                   encoder.addValue(timestamp, decoder.getLocation(), decoder.getElevation(), cell.getTimestamp() * Constants.TIME_UNITS_PER_MS);\n                 } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMjQ2Mw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441522463", "bodyText": "I think && !preBoundaryScan && !postBoundaryScan should be added. Better, enclose the few conditionals sharing this.", "author": "ftence", "createdAt": "2020-06-17T12:55:37Z", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n+                  continue;\n+                }\n+\n+                //\n+                // Compute the new value of nextTimestamp if timestep is set\n+                //\n+                if (hasTimestep) {", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\nindex 3329a8ee..5030cf55 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n\n@@ -422,43 +408,47 @@ public class MultiScanGTSDecoderIterator extends GTSDecoderIterator {\n                         \n             if (preBoundaryScan || postBoundaryScan || (timestamp <= now && timestamp >= then)) {\n               try {\n-                // Skip\n-                if (toskip > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  toskip--;\n-                  continue;\n-                }\n-                \n-                // The timestamp is still after the one we expect\n-                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n-                  continue;\n-                }\n+                if (!preBoundaryScan && !postBoundaryScan) {\n+                  // Skip\n+                  if (toskip > 0) {\n+                    toskip--;\n+                    continue;\n+                  }\n \n-                //\n-                // Compute the new value of nextTimestamp if timestep is set\n-                //\n-                if (hasTimestep) {\n-                  try {\n-                    nextTimestamp = Math.addExact(basets, -timestep);\n-                  } catch (ArithmeticException ae) {\n-                    nextTimestamp = Long.MIN_VALUE;\n-                  }                 \n-                }\n+                  // The timestamp is still after the one we expect\n+                  if (timestamp > nextTimestamp) {\n+                    continue;\n+                  }\n+                  \n+                  //\n+                  // Compute the new value of nextTimestamp if timestep is set\n+                  //\n+                  if (hasTimestep) {\n+                    try {\n+                      nextTimestamp = Math.subtractExact(timestamp, timestep);\n+                    } catch (ArithmeticException ae) {\n+                      nextTimestamp = Long.MIN_VALUE;\n+                      // set nvalues to 0 so we stop after the current value\n+                      nvalues = 0L;\n+                    }\n+                  }\n+                  \n+                  // We have not yet stepped over enough entries\n+                  if (steps > 0) {\n+                    steps--;\n+                    continue;\n+                  }\n+                  \n+                  if (hasStep) {\n+                    steps = step - 1L;\n+                  }\n \n-                // We have not yet stepped over enough entries\n-                if (steps > 0 && !preBoundaryScan && !postBoundaryScan) {\n-                  steps--;\n-                  continue;\n+                  // Sample if we have to\n+                  if (1.0D != sample && prng.nextDouble() > sample) {\n+                    continue;\n+                  }                               \n                 }\n-                \n-                if (hasStep) {\n-                  steps = step - 1L;\n-                }\n-\n-                // Sample if we have to\n-                if (1.0D != sample && !preBoundaryScan && !postBoundaryScan && prng.nextDouble() > sample) {\n-                  continue;\n-                }                               \n-                \n+                                \n                 if (writeTimestamp) {\n                   encoder.addValue(timestamp, decoder.getLocation(), decoder.getElevation(), cell.getTimestamp() * Constants.TIME_UNITS_PER_MS);\n                 } else {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzODExNw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441538117", "bodyText": "this.count >= 0 ?", "author": "ftence", "createdAt": "2020-06-17T13:19:39Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -93,24 +107,39 @@\n   private static byte[] prefix = Constants.HBASE_RAW_DATA_KEY_PREFIX;\n \n   private final boolean writeTimestamp;\n+  private final boolean hasStep;\n+  private final boolean hasTimestep;\n+  private final boolean hasSample;\n+  private long skip = 0L;\n+  private long steps = 0L;\n+  private final long step;\n+  private final long timestep;\n+  private long nextTimestamp = Long.MAX_VALUE;\n+  private final double sample;\n   \n-  public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata> metadatas, Connection conn, TableName tableName, byte[] colfam, boolean writeTimestamp, KeyStore keystore, boolean useBlockCache) {\n+  private Random prng = null;\n+\n+  public SlicedRowFilterGTSDecoderIterator(FetchRequest req, Connection conn, TableName tableName, byte[] colfam, KeyStore keystore, boolean useBlockCache) {\n       \n+    this.request = req;\n     this.keystore = keystore;\n-    this.now = now;\n-    this.timespan = timespan;\n+    this.now = req.getNow();\n+    this.then = req.getThents();\n+    this.count = req.getCount();\n+    this.sample = req.getSample();\n+    this.hasSample = this.sample < 1.0D;\n+    this.prng = hasSample ? new Random() : null;\n+    this.hasStep = req.getStep() > 1L;\n+    this.steps = req.getStep() - 1L;\n+    this.step = hasStep ? req.getStep() : 1L;\n+    this.hasTimestep = req.getTimestep() > 1L;\n+    this.timestep = this.hasTimestep ? req.getTimestep() : 1L;\n+    this.nextTimestamp = Long.MAX_VALUE;\n+    this.skip = req.getSkip();\n+    this.nvalues = this.count > 0 ? this.count : Long.MAX_VALUE;", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex c033518d..f7c6ffe3 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -101,9 +101,6 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n    */\n   private Result pendingresult = null;\n   \n-  private static final byte[] ZERO_BYTES = Longs.toByteArray(0L);\n-  private static final byte[] ONES_BYTES = Longs.toByteArray(0xffffffffffffffffL);\n-  \n   private static byte[] prefix = Constants.HBASE_RAW_DATA_KEY_PREFIX;\n \n   private final boolean writeTimestamp;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU0MTA5Ng==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441541096", "bodyText": "count >= 0 ?", "author": "ftence", "createdAt": "2020-06-17T13:23:48Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -131,18 +160,19 @@ public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata>\n     List<Pair<byte[], byte[]>> ranges = new ArrayList<Pair<byte[], byte[]>>();\n     \n     for (Metadata metadata: metadatas) {\n-      byte[][] keys = getKeys(metadata, now, timespan);\n+      byte[][] keys = getKeys(metadata, now, then);\n       byte[] lower = keys[0];\n       byte[] upper = keys[1];\n       \n-      this.metadatas.put(new String(Arrays.copyOfRange(lower, prefix.length, prefix.length + 16), StandardCharsets.ISO_8859_1), metadata);\n+      // Store the Metadata under a key containing both class and labels id in a 16 character string\n+      this.metadatas.put(new String(lower, prefix.length, 16, StandardCharsets.ISO_8859_1), metadata);\n       \n       Pair<byte[],byte[]> range = new Pair<byte[],byte[]>(lower, upper);\n       \n       ranges.add(range);\n     }\n                 \n-    SlicedRowFilter filter = new SlicedRowFilter(bounds, ranges, timespan < 0 ? -timespan : Long.MAX_VALUE);\n+    SlicedRowFilter filter = new SlicedRowFilter(bounds, ranges, count > 0 ? count : Long.MAX_VALUE);", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex c033518d..f7c6ffe3 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -172,7 +169,7 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n       ranges.add(range);\n     }\n                 \n-    SlicedRowFilter filter = new SlicedRowFilter(bounds, ranges, count > 0 ? count : Long.MAX_VALUE);\n+    SlicedRowFilter filter = new SlicedRowFilter(bounds, ranges, count >= 0 ? count : Long.MAX_VALUE);\n \n     //\n     // Create scanner. The start key is the lower bound of the first range\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU0MjM0Mw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441542343", "bodyText": "ZERO_BYTES and ONES_BYTES fields can now be removed.", "author": "ftence", "createdAt": "2020-06-17T13:25:25Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -192,21 +222,9 @@ public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata>\n     // Set lower/upper timestamps\n     //\n     \n-    long modulus = Constants.DEFAULT_MODULUS;\n-  \n-    if (Long.MAX_VALUE == now) {\n-      System.arraycopy(ZERO_BYTES, 0, lower, prefix.length + 16, 8);\n-    } else {\n-      System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - (now - (now % modulus))), 0, lower, prefix.length + 16, 8);        \n-    }\n-    \n-    if (timespan < 0) {\n-      System.arraycopy(ONES_BYTES, 0, upper, prefix.length + 16, 8);                \n-    } else {\n-      // Last timestamp does not need to be offset by modulus as it is the case when using a scanner, because\n-      // SlicedRowFilter upper bound is included, not excluded.\n-      System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - ((now - timespan) - ((now - timespan) % modulus))), 0, upper, prefix.length + 16, 8);        \n-    }\n+    System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - now), 0, lower, prefix.length + 8 + 8, 8);        \n+    // SlicedRowFilter upper bound is included\n+    System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - then), 0, upper, prefix.length + 8 + 8, 8);        ", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4Mzk5NA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441583994", "bodyText": "this.count >= 0 ?", "author": "ftence", "createdAt": "2020-06-17T14:21:58Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +269,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;\n-        return encoder.getDecoder();\n+        //\n+        // Reset fetch parameters\n+        //\n+        this.nvalues = this.count > 0 ? this.count : Long.MAX_VALUE;", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex c033518d..f7c6ffe3 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -298,7 +295,7 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n         //\n         // Reset fetch parameters\n         //\n-        this.nvalues = this.count > 0 ? this.count : Long.MAX_VALUE;\n+        this.nvalues = this.count >= 0 ? this.count : Long.MAX_VALUE;\n         this.skip = this.request.getSkip();\n         this.steps = this.hasStep ? this.request.getStep() - 1 : 0L;\n         this.nextTimestamp = Long.MAX_VALUE;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwMDU0OA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441600548", "bodyText": "If you want to remove this kind of code, you left it in MultiScanGTSDecoderIterator, lines 385-410.", "author": "ftence", "createdAt": "2020-06-17T14:43:51Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -276,40 +322,28 @@ public GTSDecoder next() {\n           Cell cell = cscanner.current();\n           cellCount++;\n           \n+          // Simply ignore the values if we already collected enough\n+          if (nvalues <= 0) {\n+            continue;\n+          }\n+          \n           //\n-          // Extract timestamp base from column qualifier\n-          // This is true even for packed readings, those have a base timestamp of 0L\n+          // Extract timestamp from row key\n           //\n \n-          long basets = Long.MAX_VALUE;\n-          \n-          if (1 == Constants.DEFAULT_MODULUS) {\n-            // 128BITS\n-            byte[] data = cell.getRowArray();\n-            int offset = cell.getRowOffset();\n-            offset += Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 8 + 8; // Add 'prefix' + 'classId' + 'labelsId' to row key offset\n-            long delta = data[offset] & 0xFF;\n-            delta <<= 8; delta |= (data[offset + 1] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 2] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 3] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 4] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 5] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 6] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 7] & 0xFFL);\n-            basets -= delta;              \n-          } else {\n-            byte[] data = cell.getQualifierArray();\n-            int offset = cell.getQualifierOffset();\n-            long delta = data[offset] & 0xFFL;\n-            delta <<= 8; delta |= (data[offset + 1] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 2] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 3] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 4] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 5] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 6] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 7] & 0xFFL);\n-            basets -= delta;                            \n-          }\n+          // 128BITS\n+          byte[] data = cell.getRowArray();\n+          int offset = cell.getRowOffset();\n+          offset += Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 8 + 8; // Add 'prefix' + 'classId' + 'labelsId' to row key offset\n+          long delta = data[offset] & 0xFF;\n+          delta <<= 8; delta |= (data[offset + 1] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 2] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 3] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 4] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 5] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 6] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 7] & 0xFFL);\n+          long basets = Long.MAX_VALUE - delta;              ", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxNDQ2OA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441614468", "bodyText": "Same comments:\n\nbasets vs timestamp\naddExact vs subtractExact\nLong.MIN_VALUE is a valid timestamp", "author": "ftence", "createdAt": "2020-06-17T15:01:31Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -321,7 +355,63 @@ public GTSDecoder next() {\n                     \n           while(decoder.next() && nvalues > 0) {\n             long timestamp = decoder.getTimestamp();\n-            if (timestamp <= now && (timespan < 0 || (timestamp > (now - timespan)))) {\n+            \n+            //\n+            // Only consider values if they are within the requested range\n+            // This should always be the case but better err on the side of caution sometimes\n+            //\n+            if (timestamp <= now && timestamp >= then) {\n+\n+              //\n+              // Skip datapoints\n+              //\n+              \n+              if (this.skip > 0) {\n+                this.skip--;\n+                continue;\n+              }\n+              \n+              //\n+              // Check that the datapoint timestamp is compatible with the timestep parameter, i.e. it is at least\n+              // 'timestep' time units before the previous one we selected\n+              //\n+              \n+              if (basets > nextTimestamp) {\n+                continue;\n+              }\n+\n+              //\n+              // Compute the new value of nextTimestamp if timestep is set\n+              //\n+              if (hasTimestep) {\n+                try {\n+                  nextTimestamp = Math.addExact(basets, -this.timestep);\n+                } catch (ArithmeticException ae) {\n+                  nextTimestamp = Long.MIN_VALUE;\n+                }\n+              }", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex c033518d..f7c6ffe3 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -376,7 +373,7 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n               // 'timestep' time units before the previous one we selected\n               //\n               \n-              if (basets > nextTimestamp) {\n+              if (timestamp > nextTimestamp) {\n                 continue;\n               }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0NjA3MA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441646070", "bodyText": "Already tested in paramsFromMap.\n(Also used timestep instead of step).", "author": "ftence", "createdAt": "2020-06-17T15:44:50Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -446,7 +449,24 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n         }\n \n         long then = (long) params.get(PARAM_START);\n-        long skip = (long) params.getOrDefault(PARAM_SKIP, 0L);        \n+        long skip = (long) params.getOrDefault(PARAM_SKIP, 0L);\n+        long timestep = 1L;\n+        long step = 1L;\n+        \n+        if (params.containsKey(PARAM_TIMESTEP)) {\n+          timestep = (long) params.get(PARAM_TIMESTEP);\n+          if (timestep <= 1) {\n+            throw new WarpScriptException(getName() + \" parameter '\" + PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+          }\n+        }\n+        \n+        if (params.containsKey(PARAM_STEP)) {\n+          step = (long) params.get(PARAM_STEP);\n+          \n+          if (timestep <= 1) {\n+            throw new WarpScriptException(getName() + \" parameter '\" + PARAM_STEP + \"' cannot be <= 1.\");            \n+          }\n+        }", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex 363c70ca..781e6347 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -455,18 +455,12 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n         \n         if (params.containsKey(PARAM_TIMESTEP)) {\n           timestep = (long) params.get(PARAM_TIMESTEP);\n-          if (timestep <= 1) {\n-            throw new WarpScriptException(getName() + \" parameter '\" + PARAM_TIMESTEP + \"' cannot be <= 1.\");\n-          }\n         }\n         \n         if (params.containsKey(PARAM_STEP)) {\n           step = (long) params.get(PARAM_STEP);\n-          \n-          if (timestep <= 1) {\n-            throw new WarpScriptException(getName() + \" parameter '\" + PARAM_STEP + \"' cannot be <= 1.\");            \n-          }\n         }\n+\n         double sample = (double) params.getOrDefault(PARAM_SAMPLE, 1.0D);\n         \n         TYPE type = (TYPE) params.get(PARAM_TYPE);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0OTQ3Mg==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441649472", "bodyText": "step < 1L", "author": "ftence", "createdAt": "2020-06-17T15:49:51Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -127,6 +140,21 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n       throw new RuntimeException(\"No support for write timestamp retrieval.\");\n     }\n     \n+    if (step <= 1L) {", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\nindex b08de148..a976cc72 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n\n@@ -140,11 +140,11 @@ public class StandaloneStoreClient implements StoreClient {\n       throw new RuntimeException(\"No support for write timestamp retrieval.\");\n     }\n     \n-    if (step <= 1L) {\n+    if (step < 1L) {\n       step = 1L;\n     }\n     \n-    if (timestep <= 1L) {\n+    if (timestep < 1L) {\n       timestep = 1L;\n     }\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0OTc1Nw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441649757", "bodyText": "timestep < 1L", "author": "ftence", "createdAt": "2020-06-17T15:50:15Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -127,6 +140,21 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n       throw new RuntimeException(\"No support for write timestamp retrieval.\");\n     }\n     \n+    if (step <= 1L) {\n+      step = 1L;\n+    }\n+    \n+    if (timestep <= 1L) {", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\nindex b08de148..a976cc72 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n\n@@ -140,11 +140,11 @@ public class StandaloneStoreClient implements StoreClient {\n       throw new RuntimeException(\"No support for write timestamp retrieval.\");\n     }\n     \n-    if (step <= 1L) {\n+    if (step < 1L) {\n       step = 1L;\n     }\n     \n-    if (timestep <= 1L) {\n+    if (timestep < 1L) {\n       timestep = 1L;\n     }\n     \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTE3OA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441655178", "bodyText": "Same comments:\n\nsubtractExact\nLong.MIN_VALUE is a valid timestamp", "author": "ftence", "createdAt": "2020-06-17T15:58:16Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -323,6 +355,62 @@ public GTSDecoder next() {\n               continue;\n             }\n             \n+            //\n+            // Check that the datapoint timestamp is compatible with the timestep parameter, i.e. it is at least\n+            // 'timestep' time units before the previous one we selected\n+            //\n+            \n+            if (basets > nextTimestamp) {\n+              continue;\n+            }\n+\n+            //\n+            // Compute the new value of nextTimestamp if timestep is set\n+            //\n+            if (hasTimestep) {\n+              try {\n+                nextTimestamp = Math.addExact(basets, -timestep);\n+              } catch (ArithmeticException ae) {\n+                nextTimestamp = Long.MIN_VALUE;\n+              }", "originalCommit": "e07598603051ad7fa838f08bfec01a2aa247f958", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\nindex b08de148..a976cc72 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n\n@@ -369,9 +369,10 @@ public class StandaloneStoreClient implements StoreClient {\n             //\n             if (hasTimestep) {\n               try {\n-                nextTimestamp = Math.addExact(basets, -timestep);\n+                nextTimestamp = Math.subtractExact(basets, timestep);\n               } catch (ArithmeticException ae) {\n                 nextTimestamp = Long.MIN_VALUE;\n+                nvalues = 0L;\n               }\n              \n               // TODO(hbs): should we apply a heuristics to determine if we should seek or not?\n"}}, {"oid": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "url": "https://github.com/senx/warp10-platform/commit/879ad4092491eda3b08f942710d5bdc6b1e90c69", "message": "Addressed PR comments", "committedDate": "2020-06-19T17:06:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkyNzQ3OA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r448927478", "bodyText": "Should be initialized to 0L, else it will skip the first step - 1 points found.", "author": "ftence", "createdAt": "2020-07-02T11:14:04Z", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -230,6 +242,8 @@ public boolean hasNext() {\n     \n     nvalues = count >= 0 ? count : Long.MAX_VALUE;\n     toskip = skip;\n+    steps = hasStep ? step - 1L : 0L;", "originalCommit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\nindex 5030cf55..55f1ea0a 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java\n\n@@ -242,7 +242,7 @@ public class MultiScanGTSDecoderIterator extends GTSDecoderIterator {\n     \n     nvalues = count >= 0 ? count : Long.MAX_VALUE;\n     toskip = skip;\n-    steps = hasStep ? step - 1L : 0L;\n+    steps = 0L;\n     nextTimestamp = Long.MAX_VALUE;\n     \n     Scan scan = new Scan();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MTk4Nw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r448971987", "bodyText": "Change getSkip to getStep.", "author": "ftence", "createdAt": "2020-07-02T12:41:35Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -88,8 +89,20 @@ public StandaloneStoreClient(DB db, KeyStore keystore, Properties properties) {\n   }\n   \n   @Override\n-  public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, double sample, boolean writeTimestamp, long preBoundary, long postBoundary) {\n-\n+  public GTSDecoderIterator fetch(FetchRequest req) {\n+    final ReadToken token = req.getToken();\n+    final List<Metadata> metadatas = req.getMetadatas();\n+    final long now = req.getNow();\n+    final long then = req.getThents();\n+    long count = req.getCount();\n+    long skip = req.getSkip();\n+    long step = req.getSkip();", "originalCommit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\nindex a976cc72..dedaf065 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java\n\n@@ -96,7 +96,7 @@ public class StandaloneStoreClient implements StoreClient {\n     final long then = req.getThents();\n     long count = req.getCount();\n     long skip = req.getSkip();\n-    long step = req.getSkip();\n+    long step = req.getStep();\n     long timestep = req.getTimestep();\n     double sample = req.getSample();\n     long preBoundary = req.getPreBoundary();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5NzY5MA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r449097690", "bodyText": "Initialize it to 0L else the first this.request.getStep() - 1 will be stepped over.", "author": "ftence", "createdAt": "2020-07-02T15:38:57Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +266,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;\n-        return encoder.getDecoder();\n+        //\n+        // Reset fetch parameters\n+        //\n+        this.nvalues = this.count >= 0 ? this.count : Long.MAX_VALUE;\n+        this.skip = this.request.getSkip();\n+        this.steps = this.hasStep ? this.request.getStep() - 1 : 0L;", "originalCommit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex f7c6ffe3..b003357d 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -290,16 +290,16 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n       // update the metadata\n       //      \n       if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n-        // Save result in pendingresult as we have not yet read the associated cells\n-        this.pendingresult = result;\n         //\n         // Reset fetch parameters\n         //\n         this.nvalues = this.count >= 0 ? this.count : Long.MAX_VALUE;\n         this.skip = this.request.getSkip();\n-        this.steps = this.hasStep ? this.request.getStep() - 1 : 0L;\n+        this.steps = 0L;\n         this.nextTimestamp = Long.MAX_VALUE;\n         if (encoder.size() > 0) {\n+          // Save result in pendingresult as we have not yet read the associated cells\n+          this.pendingresult = result;\n           return encoder.getDecoder();\n         }\n       }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNjY0Mw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r449106643", "bodyText": "Do that only if encoder.size() > 0 ie. move that in the if few lines below.\nThis one is tricky and took me a lot of time to debug:\nIf encoder has empty metadata (first metadata in the list) it is considered as a change of metadata. Thus it will not trigger the return in the if below and result will be processed. However, result will be also stored in pendingresult so it will be reprocessed, resulting in duplicate datapoints in the resulting decoder.", "author": "ftence", "createdAt": "2020-07-02T15:46:16Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +266,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;", "originalCommit": "879ad4092491eda3b08f942710d5bdc6b1e90c69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMzIxNw==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r449203217", "bodyText": "Comment is for line this.pendingresult = result;, GitHub messed this up.", "author": "ftence", "createdAt": "2020-07-02T18:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNjY0Mw=="}], "type": "inlineReview", "revised_code": {"commit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex f7c6ffe3..b003357d 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -290,16 +290,16 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n       // update the metadata\n       //      \n       if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n-        // Save result in pendingresult as we have not yet read the associated cells\n-        this.pendingresult = result;\n         //\n         // Reset fetch parameters\n         //\n         this.nvalues = this.count >= 0 ? this.count : Long.MAX_VALUE;\n         this.skip = this.request.getSkip();\n-        this.steps = this.hasStep ? this.request.getStep() - 1 : 0L;\n+        this.steps = 0L;\n         this.nextTimestamp = Long.MAX_VALUE;\n         if (encoder.size() > 0) {\n+          // Save result in pendingresult as we have not yet read the associated cells\n+          this.pendingresult = result;\n           return encoder.getDecoder();\n         }\n       }\n"}}, {"oid": "335b626c2012946bb076b0943e41bdfdae1a58e9", "url": "https://github.com/senx/warp10-platform/commit/335b626c2012946bb076b0943e41bdfdae1a58e9", "message": "Merge branch 'master' of github.com:senx/warp10-platform into step-timestep", "committedDate": "2020-07-06T12:40:14Z", "type": "commit"}, {"oid": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "url": "https://github.com/senx/warp10-platform/commit/abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "message": "Addressed PR comments", "committedDate": "2020-07-06T12:58:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyOTkwMg==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r450829902", "bodyText": "I forgot this one, initialize to 0L to avoid stepping over the first values, even if it's not used yet.", "author": "ftence", "createdAt": "2020-07-07T12:35:34Z", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -87,30 +101,42 @@\n    */\n   private Result pendingresult = null;\n   \n-  private static final byte[] ZERO_BYTES = Longs.toByteArray(0L);\n-  private static final byte[] ONES_BYTES = Longs.toByteArray(0xffffffffffffffffL);\n-  \n   private static byte[] prefix = Constants.HBASE_RAW_DATA_KEY_PREFIX;\n \n   private final boolean writeTimestamp;\n+  private final boolean hasStep;\n+  private final boolean hasTimestep;\n+  private final boolean hasSample;\n+  private long skip = 0L;\n+  private long steps = 0L;\n+  private final long step;\n+  private final long timestep;\n+  private long nextTimestamp = Long.MAX_VALUE;\n+  private final double sample;\n   \n-  public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata> metadatas, Connection conn, TableName tableName, byte[] colfam, boolean writeTimestamp, KeyStore keystore, boolean useBlockCache) {\n+  private Random prng = null;\n+\n+  public SlicedRowFilterGTSDecoderIterator(FetchRequest req, Connection conn, TableName tableName, byte[] colfam, KeyStore keystore, boolean useBlockCache) {\n       \n+    this.request = req;\n     this.keystore = keystore;\n-    this.now = now;\n-    this.timespan = timespan;\n+    this.now = req.getNow();\n+    this.then = req.getThents();\n+    this.count = req.getCount();\n+    this.sample = req.getSample();\n+    this.hasSample = this.sample < 1.0D;\n+    this.prng = hasSample ? new Random() : null;\n+    this.hasStep = req.getStep() > 1L;\n+    this.steps = req.getStep() - 1L;", "originalCommit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40b530a5da3c781394f6518b678b8935f53d58a0", "chunk": "diff --git a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\nindex b003357d..a20d2102 100644\n--- a/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n+++ b/warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java\n\n@@ -127,7 +127,7 @@ public class SlicedRowFilterGTSDecoderIterator extends GTSDecoderIterator implem\n     this.hasSample = this.sample < 1.0D;\n     this.prng = hasSample ? new Random() : null;\n     this.hasStep = req.getStep() > 1L;\n-    this.steps = req.getStep() - 1L;\n+    this.steps = 0L;\n     this.step = hasStep ? req.getStep() : 1L;\n     this.hasTimestep = req.getTimestep() > 1L;\n     this.timestep = this.hasTimestep ? req.getTimestep() : 1L;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMjkzOA==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r450832938", "bodyText": "getStep instead of getSkip.", "author": "ftence", "createdAt": "2020-07-07T12:40:48Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java", "diffHunk": "@@ -146,8 +146,22 @@ public void run() {\n   }\n   \n   @Override\n-  public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> metadatas, final long now, final long then, final long count, final long skip, final double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) {\n-\n+  public GTSDecoderIterator fetch(FetchRequest req) {\n+    final List<Metadata> metadatas = req.getMetadatas();\n+    final long now = req.getNow();\n+    final long then = req.getThents();\n+    final long count = req.getCount();\n+    final long skip = req.getSkip();\n+    long step = req.getSkip();", "originalCommit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40b530a5da3c781394f6518b678b8935f53d58a0", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java b/warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java\nindex ab1ba50d..bb55083e 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java\n\n@@ -152,7 +152,7 @@ public class StandaloneChunkedMemoryStore extends Thread implements StoreClient\n     final long then = req.getThents();\n     final long count = req.getCount();\n     final long skip = req.getSkip();\n-    long step = req.getSkip();\n+    long step = req.getStep();\n     long timestep = req.getTimestep();\n     final double sample = req.getSample();\n     final long preBoundary = req.getPreBoundary();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzNDk3OQ==", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r450834979", "bodyText": "getStep instead of getSkip.", "author": "ftence", "createdAt": "2020-07-07T12:44:11Z", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java", "diffHunk": "@@ -134,7 +134,17 @@ public void run() {\n   }\n   \n   @Override\n-  public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> metadatas, final long now, final long then, final long count, final long skip, final double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) {\n+  public GTSDecoderIterator fetch(FetchRequest req) {\n+    final List<Metadata> metadatas = req.getMetadatas();\n+    final long now = req.getNow();\n+    final long then = req.getThents();\n+    final long count = req.getCount();\n+    final long skip = req.getSkip();\n+    long step = req.getSkip();", "originalCommit": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "40b530a5da3c781394f6518b678b8935f53d58a0", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java b/warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java\nindex 67387e1b..a48aa1ef 100644\n--- a/warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java\n+++ b/warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java\n\n@@ -140,7 +140,7 @@ public class StandaloneMemoryStore extends Thread implements StoreClient {\n     final long then = req.getThents();\n     final long count = req.getCount();\n     final long skip = req.getSkip();\n-    long step = req.getSkip();\n+    long step = req.getStep();\n     long timestep = req.getTimestep();\n     final double sample = req.getSample();\n     final long preBoundary = req.getPreBoundary();\n"}}, {"oid": "40b530a5da3c781394f6518b678b8935f53d58a0", "url": "https://github.com/senx/warp10-platform/commit/40b530a5da3c781394f6518b678b8935f53d58a0", "message": "Addressed PR comments", "committedDate": "2020-07-07T14:22:39Z", "type": "commit"}]}