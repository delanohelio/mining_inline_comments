{"pr_number": 700, "pr_title": "Initial commit of Java version of leveldb repair", "pr_createdAt": "2020-03-23T16:46:08Z", "pr_url": "https://github.com/senx/warp10-platform/pull/700", "timeline": [{"oid": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "url": "https://github.com/senx/warp10-platform/commit/5efe8e624a60b0aff8e755fc697bf216d53c2112", "message": "Initial commit of Java version of leveldb repair", "committedDate": "2020-03-23T16:45:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MDIxMw==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397240213", "bodyText": "Only one case in this switch, change to if?", "author": "ftence", "createdAt": "2020-03-24T15:25:18Z", "path": "warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java", "diffHunk": "@@ -0,0 +1,431 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.standalone;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.impl.DbLock;\n+import org.iq80.leveldb.impl.FileMetaData;\n+import org.iq80.leveldb.impl.Filename;\n+import org.iq80.leveldb.impl.Filename.FileInfo;\n+import org.iq80.leveldb.impl.InternalKey;\n+import org.iq80.leveldb.impl.InternalKeyComparator;\n+import org.iq80.leveldb.impl.InternalUserComparator;\n+import org.iq80.leveldb.impl.LogMonitor;\n+import org.iq80.leveldb.impl.LogMonitors;\n+import org.iq80.leveldb.impl.LogReader;\n+import org.iq80.leveldb.impl.LogWriter;\n+import org.iq80.leveldb.impl.Logs;\n+import org.iq80.leveldb.impl.MemTable;\n+import org.iq80.leveldb.impl.SeekingIterable;\n+import org.iq80.leveldb.impl.TableCache;\n+import org.iq80.leveldb.impl.ValueType;\n+import org.iq80.leveldb.impl.VersionEdit;\n+import org.iq80.leveldb.impl.VersionSet;\n+import org.iq80.leveldb.impl.WriteBatchImpl;\n+import org.iq80.leveldb.impl.WriteBatchImpl.Handler;\n+import org.iq80.leveldb.table.BytewiseComparator;\n+import org.iq80.leveldb.table.TableBuilder;\n+import org.iq80.leveldb.util.InternalIterator;\n+import org.iq80.leveldb.util.Slice;\n+import org.iq80.leveldb.util.SliceInput;\n+import org.iq80.leveldb.util.Slices;\n+\n+public class LevelDBRepair {\n+  \n+  private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n+\n+  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  \n+  public static synchronized void repair(File path, Options options) throws IOException {\n+    //\n+    // Lock the DB\n+    //\n+    \n+    DbLock dbLock = new DbLock(new File(path, Filename.lockFileName()));\n+    \n+    List<File> files = Filename.listFiles(path);\n+    \n+    nextFileNumber.set(Long.MIN_VALUE);\n+\n+    List<Long> logs = new ArrayList<Long>();\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case DESCRIPTOR:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        case LOG:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          logs.add(fileInfo.getFileNumber());\n+          break;\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+    \n+    //\n+    // Convert log files to SST\n+    //\n+\n+    // Sort log files per increasing number\n+    Collections.sort(logs);\n+    \n+    long maxSequence = Long.MIN_VALUE;\n+    \n+    for (long fileno: logs) {\n+      System.out.println(\"LOG #\" + fileno + \" - SCAN\");\n+      long maxSeq = recoverLogFile(path, fileno, options);\n+      \n+      if (maxSeq > maxSequence) {\n+        maxSequence = maxSeq;\n+      }\n+    }\n+    \n+    //\n+    // Scan each SST to identify smallest/largest keys and largest sequence number\n+    //\n+    files = Filename.listFiles(path);\n+    \n+    TableCache tcache = new TableCache(path, 1, new InternalUserComparator(internalKeyComparator), true);\n+\n+    List<FileMetaData> meta = new ArrayList<FileMetaData>();\n+\n+    long totalSize = 0;\n+    long totalCount = 0;\n+    long totalFiles = 0;\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {", "originalCommit": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzkzMDcyNQ==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397930725", "bodyText": "There might be a need to handle other files in the future, so leaving it as a case.", "author": "hbs", "createdAt": "2020-03-25T15:09:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MDIxMw=="}], "type": "inlineReview", "revised_code": {"commit": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\nindex 866932a2..f4ef2114 100644\n--- a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n+++ b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n\n@@ -60,7 +60,7 @@ public class LevelDBRepair {\n   \n   private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n \n-  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  private static final AtomicLong nextFileNumber = new AtomicLong(0L);\n   \n   public static synchronized void repair(File path, Options options) throws IOException {\n     //\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MTI3OQ==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397241279", "bodyText": "DESCRIPTOR and TABLE cases can be merged.", "author": "ftence", "createdAt": "2020-03-24T15:26:37Z", "path": "warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java", "diffHunk": "@@ -0,0 +1,431 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.standalone;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.impl.DbLock;\n+import org.iq80.leveldb.impl.FileMetaData;\n+import org.iq80.leveldb.impl.Filename;\n+import org.iq80.leveldb.impl.Filename.FileInfo;\n+import org.iq80.leveldb.impl.InternalKey;\n+import org.iq80.leveldb.impl.InternalKeyComparator;\n+import org.iq80.leveldb.impl.InternalUserComparator;\n+import org.iq80.leveldb.impl.LogMonitor;\n+import org.iq80.leveldb.impl.LogMonitors;\n+import org.iq80.leveldb.impl.LogReader;\n+import org.iq80.leveldb.impl.LogWriter;\n+import org.iq80.leveldb.impl.Logs;\n+import org.iq80.leveldb.impl.MemTable;\n+import org.iq80.leveldb.impl.SeekingIterable;\n+import org.iq80.leveldb.impl.TableCache;\n+import org.iq80.leveldb.impl.ValueType;\n+import org.iq80.leveldb.impl.VersionEdit;\n+import org.iq80.leveldb.impl.VersionSet;\n+import org.iq80.leveldb.impl.WriteBatchImpl;\n+import org.iq80.leveldb.impl.WriteBatchImpl.Handler;\n+import org.iq80.leveldb.table.BytewiseComparator;\n+import org.iq80.leveldb.table.TableBuilder;\n+import org.iq80.leveldb.util.InternalIterator;\n+import org.iq80.leveldb.util.Slice;\n+import org.iq80.leveldb.util.SliceInput;\n+import org.iq80.leveldb.util.Slices;\n+\n+public class LevelDBRepair {\n+  \n+  private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n+\n+  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  \n+  public static synchronized void repair(File path, Options options) throws IOException {\n+    //\n+    // Lock the DB\n+    //\n+    \n+    DbLock dbLock = new DbLock(new File(path, Filename.lockFileName()));\n+    \n+    List<File> files = Filename.listFiles(path);\n+    \n+    nextFileNumber.set(Long.MIN_VALUE);\n+\n+    List<Long> logs = new ArrayList<Long>();\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case DESCRIPTOR:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        case LOG:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          logs.add(fileInfo.getFileNumber());\n+          break;\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        default:", "originalCommit": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\nindex 866932a2..f4ef2114 100644\n--- a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n+++ b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n\n@@ -60,7 +60,7 @@ public class LevelDBRepair {\n   \n   private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n \n-  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  private static final AtomicLong nextFileNumber = new AtomicLong(0L);\n   \n   public static synchronized void repair(File path, Options options) throws IOException {\n     //\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MTU5NQ==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397241595", "bodyText": "Unused.", "author": "ftence", "createdAt": "2020-03-24T15:27:01Z", "path": "warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java", "diffHunk": "@@ -0,0 +1,431 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.standalone;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.impl.DbLock;\n+import org.iq80.leveldb.impl.FileMetaData;\n+import org.iq80.leveldb.impl.Filename;\n+import org.iq80.leveldb.impl.Filename.FileInfo;\n+import org.iq80.leveldb.impl.InternalKey;\n+import org.iq80.leveldb.impl.InternalKeyComparator;\n+import org.iq80.leveldb.impl.InternalUserComparator;\n+import org.iq80.leveldb.impl.LogMonitor;\n+import org.iq80.leveldb.impl.LogMonitors;\n+import org.iq80.leveldb.impl.LogReader;\n+import org.iq80.leveldb.impl.LogWriter;\n+import org.iq80.leveldb.impl.Logs;\n+import org.iq80.leveldb.impl.MemTable;\n+import org.iq80.leveldb.impl.SeekingIterable;\n+import org.iq80.leveldb.impl.TableCache;\n+import org.iq80.leveldb.impl.ValueType;\n+import org.iq80.leveldb.impl.VersionEdit;\n+import org.iq80.leveldb.impl.VersionSet;\n+import org.iq80.leveldb.impl.WriteBatchImpl;\n+import org.iq80.leveldb.impl.WriteBatchImpl.Handler;\n+import org.iq80.leveldb.table.BytewiseComparator;\n+import org.iq80.leveldb.table.TableBuilder;\n+import org.iq80.leveldb.util.InternalIterator;\n+import org.iq80.leveldb.util.Slice;\n+import org.iq80.leveldb.util.SliceInput;\n+import org.iq80.leveldb.util.Slices;\n+\n+public class LevelDBRepair {\n+  \n+  private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n+\n+  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  \n+  public static synchronized void repair(File path, Options options) throws IOException {\n+    //\n+    // Lock the DB\n+    //\n+    \n+    DbLock dbLock = new DbLock(new File(path, Filename.lockFileName()));\n+    \n+    List<File> files = Filename.listFiles(path);\n+    \n+    nextFileNumber.set(Long.MIN_VALUE);\n+\n+    List<Long> logs = new ArrayList<Long>();\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case DESCRIPTOR:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        case LOG:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          logs.add(fileInfo.getFileNumber());\n+          break;\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+    \n+    //\n+    // Convert log files to SST\n+    //\n+\n+    // Sort log files per increasing number\n+    Collections.sort(logs);\n+    \n+    long maxSequence = Long.MIN_VALUE;\n+    \n+    for (long fileno: logs) {\n+      System.out.println(\"LOG #\" + fileno + \" - SCAN\");\n+      long maxSeq = recoverLogFile(path, fileno, options);\n+      \n+      if (maxSeq > maxSequence) {\n+        maxSequence = maxSeq;\n+      }\n+    }\n+    \n+    //\n+    // Scan each SST to identify smallest/largest keys and largest sequence number\n+    //\n+    files = Filename.listFiles(path);\n+    \n+    TableCache tcache = new TableCache(path, 1, new InternalUserComparator(internalKeyComparator), true);\n+\n+    List<FileMetaData> meta = new ArrayList<FileMetaData>();\n+\n+    long totalSize = 0;\n+    long totalCount = 0;\n+    long totalFiles = 0;\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+\n+          long number = fileInfo.getFileNumber();\n+          long fileSize = file.length();\n+          \n+          InternalKey smallest = null;\n+          InternalKey largest = null;\n+\n+          try {\n+            InternalIterator iter = tcache.newIterator(number);\n+            \n+            long count = 0;\n+            \n+            while(iter.hasNext()) {\n+              Entry<InternalKey, Slice> entry = iter.next();\n+            \n+              Slice slice = entry.getValue();", "originalCommit": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\nindex 866932a2..f4ef2114 100644\n--- a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n+++ b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n\n@@ -60,7 +60,7 @@ public class LevelDBRepair {\n   \n   private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n \n-  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  private static final AtomicLong nextFileNumber = new AtomicLong(0L);\n   \n   public static synchronized void repair(File path, Options options) throws IOException {\n     //\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzI0MzY1MA==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397243650", "bodyText": "Can be replaced by return Long.compare(o1.getNumber(), o2.getNumber());.", "author": "ftence", "createdAt": "2020-03-24T15:29:36Z", "path": "warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java", "diffHunk": "@@ -0,0 +1,431 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.standalone;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.impl.DbLock;\n+import org.iq80.leveldb.impl.FileMetaData;\n+import org.iq80.leveldb.impl.Filename;\n+import org.iq80.leveldb.impl.Filename.FileInfo;\n+import org.iq80.leveldb.impl.InternalKey;\n+import org.iq80.leveldb.impl.InternalKeyComparator;\n+import org.iq80.leveldb.impl.InternalUserComparator;\n+import org.iq80.leveldb.impl.LogMonitor;\n+import org.iq80.leveldb.impl.LogMonitors;\n+import org.iq80.leveldb.impl.LogReader;\n+import org.iq80.leveldb.impl.LogWriter;\n+import org.iq80.leveldb.impl.Logs;\n+import org.iq80.leveldb.impl.MemTable;\n+import org.iq80.leveldb.impl.SeekingIterable;\n+import org.iq80.leveldb.impl.TableCache;\n+import org.iq80.leveldb.impl.ValueType;\n+import org.iq80.leveldb.impl.VersionEdit;\n+import org.iq80.leveldb.impl.VersionSet;\n+import org.iq80.leveldb.impl.WriteBatchImpl;\n+import org.iq80.leveldb.impl.WriteBatchImpl.Handler;\n+import org.iq80.leveldb.table.BytewiseComparator;\n+import org.iq80.leveldb.table.TableBuilder;\n+import org.iq80.leveldb.util.InternalIterator;\n+import org.iq80.leveldb.util.Slice;\n+import org.iq80.leveldb.util.SliceInput;\n+import org.iq80.leveldb.util.Slices;\n+\n+public class LevelDBRepair {\n+  \n+  private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n+\n+  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  \n+  public static synchronized void repair(File path, Options options) throws IOException {\n+    //\n+    // Lock the DB\n+    //\n+    \n+    DbLock dbLock = new DbLock(new File(path, Filename.lockFileName()));\n+    \n+    List<File> files = Filename.listFiles(path);\n+    \n+    nextFileNumber.set(Long.MIN_VALUE);\n+\n+    List<Long> logs = new ArrayList<Long>();\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case DESCRIPTOR:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        case LOG:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          logs.add(fileInfo.getFileNumber());\n+          break;\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+    \n+    //\n+    // Convert log files to SST\n+    //\n+\n+    // Sort log files per increasing number\n+    Collections.sort(logs);\n+    \n+    long maxSequence = Long.MIN_VALUE;\n+    \n+    for (long fileno: logs) {\n+      System.out.println(\"LOG #\" + fileno + \" - SCAN\");\n+      long maxSeq = recoverLogFile(path, fileno, options);\n+      \n+      if (maxSeq > maxSequence) {\n+        maxSequence = maxSeq;\n+      }\n+    }\n+    \n+    //\n+    // Scan each SST to identify smallest/largest keys and largest sequence number\n+    //\n+    files = Filename.listFiles(path);\n+    \n+    TableCache tcache = new TableCache(path, 1, new InternalUserComparator(internalKeyComparator), true);\n+\n+    List<FileMetaData> meta = new ArrayList<FileMetaData>();\n+\n+    long totalSize = 0;\n+    long totalCount = 0;\n+    long totalFiles = 0;\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+\n+          long number = fileInfo.getFileNumber();\n+          long fileSize = file.length();\n+          \n+          InternalKey smallest = null;\n+          InternalKey largest = null;\n+\n+          try {\n+            InternalIterator iter = tcache.newIterator(number);\n+            \n+            long count = 0;\n+            \n+            while(iter.hasNext()) {\n+              Entry<InternalKey, Slice> entry = iter.next();\n+            \n+              Slice slice = entry.getValue();\n+\n+              if (null == smallest) {\n+                smallest = entry.getKey();\n+              }\n+              largest = entry.getKey();\n+              count++;\n+            }\n+            \n+            meta.add(new FileMetaData(number, fileSize, smallest, largest));\n+            \n+            totalSize += fileSize;\n+            totalCount += count;\n+            totalFiles++;\n+            System.out.println(\"SST #\" + number + \" - \" + count + \" entries, \" + fileSize + \" bytes.\");            \n+          } catch (Exception ioe) {\n+            //\n+            // Ignore the current SST file\n+            //\n+            file.renameTo(new File(file.getAbsolutePath() + \".corrupt\"));\n+            System.out.println(\"SST #\" + number + \" - CORRUPTED [\" + (null != smallest ? smallest.getUserKey() : \"-\") + \"]-[\" + (null != largest ? largest.getUserKey() : \"-\") + \"]\");\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+    System.out.println(\"------------------------\");\n+    System.out.println(\"Scanned \" + totalFiles + \" SST files - \" + totalCount + \" entries, \" + totalSize + \" bytes.\");\n+    \n+    //\n+    // Sort the files by increasing sequence number\n+    //\n+    \n+    Collections.sort(meta, new Comparator<FileMetaData>() {\n+      @Override\n+      public int compare(FileMetaData o1, FileMetaData o2) {\n+        if (o1.getNumber() < o2.getNumber()) {\n+          return -1;\n+        } else if (o1.getNumber() > o2.getNumber()) {\n+          return 1;\n+        } else {\n+          return 0;\n+        }", "originalCommit": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\nindex 866932a2..f4ef2114 100644\n--- a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n+++ b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n\n@@ -60,7 +60,7 @@ public class LevelDBRepair {\n   \n   private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n \n-  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  private static final AtomicLong nextFileNumber = new AtomicLong(0L);\n   \n   public static synchronized void repair(File path, Options options) throws IOException {\n     //\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NzI4Mw==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397867283", "bodyText": "Can be final.", "author": "ftence", "createdAt": "2020-03-25T13:49:15Z", "path": "warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java", "diffHunk": "@@ -0,0 +1,431 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.standalone;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.impl.DbLock;\n+import org.iq80.leveldb.impl.FileMetaData;\n+import org.iq80.leveldb.impl.Filename;\n+import org.iq80.leveldb.impl.Filename.FileInfo;\n+import org.iq80.leveldb.impl.InternalKey;\n+import org.iq80.leveldb.impl.InternalKeyComparator;\n+import org.iq80.leveldb.impl.InternalUserComparator;\n+import org.iq80.leveldb.impl.LogMonitor;\n+import org.iq80.leveldb.impl.LogMonitors;\n+import org.iq80.leveldb.impl.LogReader;\n+import org.iq80.leveldb.impl.LogWriter;\n+import org.iq80.leveldb.impl.Logs;\n+import org.iq80.leveldb.impl.MemTable;\n+import org.iq80.leveldb.impl.SeekingIterable;\n+import org.iq80.leveldb.impl.TableCache;\n+import org.iq80.leveldb.impl.ValueType;\n+import org.iq80.leveldb.impl.VersionEdit;\n+import org.iq80.leveldb.impl.VersionSet;\n+import org.iq80.leveldb.impl.WriteBatchImpl;\n+import org.iq80.leveldb.impl.WriteBatchImpl.Handler;\n+import org.iq80.leveldb.table.BytewiseComparator;\n+import org.iq80.leveldb.table.TableBuilder;\n+import org.iq80.leveldb.util.InternalIterator;\n+import org.iq80.leveldb.util.Slice;\n+import org.iq80.leveldb.util.SliceInput;\n+import org.iq80.leveldb.util.Slices;\n+\n+public class LevelDBRepair {\n+  \n+  private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n+\n+  private static AtomicLong nextFileNumber = new AtomicLong(0L);", "originalCommit": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\nindex 866932a2..f4ef2114 100644\n--- a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n+++ b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n\n@@ -60,7 +60,7 @@ public class LevelDBRepair {\n   \n   private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n \n-  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  private static final AtomicLong nextFileNumber = new AtomicLong(0L);\n   \n   public static synchronized void repair(File path, Options options) throws IOException {\n     //\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg3NzY2OA==", "url": "https://github.com/senx/warp10-platform/pull/700#discussion_r397877668", "bodyText": "This parameter does not exist, remove or update.", "author": "ftence", "createdAt": "2020-03-25T14:02:38Z", "path": "warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java", "diffHunk": "@@ -0,0 +1,431 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.standalone;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.iq80.leveldb.Options;\n+import org.iq80.leveldb.impl.DbLock;\n+import org.iq80.leveldb.impl.FileMetaData;\n+import org.iq80.leveldb.impl.Filename;\n+import org.iq80.leveldb.impl.Filename.FileInfo;\n+import org.iq80.leveldb.impl.InternalKey;\n+import org.iq80.leveldb.impl.InternalKeyComparator;\n+import org.iq80.leveldb.impl.InternalUserComparator;\n+import org.iq80.leveldb.impl.LogMonitor;\n+import org.iq80.leveldb.impl.LogMonitors;\n+import org.iq80.leveldb.impl.LogReader;\n+import org.iq80.leveldb.impl.LogWriter;\n+import org.iq80.leveldb.impl.Logs;\n+import org.iq80.leveldb.impl.MemTable;\n+import org.iq80.leveldb.impl.SeekingIterable;\n+import org.iq80.leveldb.impl.TableCache;\n+import org.iq80.leveldb.impl.ValueType;\n+import org.iq80.leveldb.impl.VersionEdit;\n+import org.iq80.leveldb.impl.VersionSet;\n+import org.iq80.leveldb.impl.WriteBatchImpl;\n+import org.iq80.leveldb.impl.WriteBatchImpl.Handler;\n+import org.iq80.leveldb.table.BytewiseComparator;\n+import org.iq80.leveldb.table.TableBuilder;\n+import org.iq80.leveldb.util.InternalIterator;\n+import org.iq80.leveldb.util.Slice;\n+import org.iq80.leveldb.util.SliceInput;\n+import org.iq80.leveldb.util.Slices;\n+\n+public class LevelDBRepair {\n+  \n+  private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n+\n+  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  \n+  public static synchronized void repair(File path, Options options) throws IOException {\n+    //\n+    // Lock the DB\n+    //\n+    \n+    DbLock dbLock = new DbLock(new File(path, Filename.lockFileName()));\n+    \n+    List<File> files = Filename.listFiles(path);\n+    \n+    nextFileNumber.set(Long.MIN_VALUE);\n+\n+    List<Long> logs = new ArrayList<Long>();\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case DESCRIPTOR:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        case LOG:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          logs.add(fileInfo.getFileNumber());\n+          break;\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+    \n+    //\n+    // Convert log files to SST\n+    //\n+\n+    // Sort log files per increasing number\n+    Collections.sort(logs);\n+    \n+    long maxSequence = Long.MIN_VALUE;\n+    \n+    for (long fileno: logs) {\n+      System.out.println(\"LOG #\" + fileno + \" - SCAN\");\n+      long maxSeq = recoverLogFile(path, fileno, options);\n+      \n+      if (maxSeq > maxSequence) {\n+        maxSequence = maxSeq;\n+      }\n+    }\n+    \n+    //\n+    // Scan each SST to identify smallest/largest keys and largest sequence number\n+    //\n+    files = Filename.listFiles(path);\n+    \n+    TableCache tcache = new TableCache(path, 1, new InternalUserComparator(internalKeyComparator), true);\n+\n+    List<FileMetaData> meta = new ArrayList<FileMetaData>();\n+\n+    long totalSize = 0;\n+    long totalCount = 0;\n+    long totalFiles = 0;\n+    \n+    for (File file: files) {\n+      FileInfo fileInfo = Filename.parseFileName(file);\n+      \n+      if (null == fileInfo) {\n+        continue;\n+      }\n+      \n+      switch (fileInfo.getFileType()) {\n+        case TABLE:\n+          if (fileInfo.getFileNumber() > nextFileNumber.get()) {\n+            nextFileNumber.set(fileInfo.getFileNumber());\n+          }\n+\n+          long number = fileInfo.getFileNumber();\n+          long fileSize = file.length();\n+          \n+          InternalKey smallest = null;\n+          InternalKey largest = null;\n+\n+          try {\n+            InternalIterator iter = tcache.newIterator(number);\n+            \n+            long count = 0;\n+            \n+            while(iter.hasNext()) {\n+              Entry<InternalKey, Slice> entry = iter.next();\n+            \n+              Slice slice = entry.getValue();\n+\n+              if (null == smallest) {\n+                smallest = entry.getKey();\n+              }\n+              largest = entry.getKey();\n+              count++;\n+            }\n+            \n+            meta.add(new FileMetaData(number, fileSize, smallest, largest));\n+            \n+            totalSize += fileSize;\n+            totalCount += count;\n+            totalFiles++;\n+            System.out.println(\"SST #\" + number + \" - \" + count + \" entries, \" + fileSize + \" bytes.\");            \n+          } catch (Exception ioe) {\n+            //\n+            // Ignore the current SST file\n+            //\n+            file.renameTo(new File(file.getAbsolutePath() + \".corrupt\"));\n+            System.out.println(\"SST #\" + number + \" - CORRUPTED [\" + (null != smallest ? smallest.getUserKey() : \"-\") + \"]-[\" + (null != largest ? largest.getUserKey() : \"-\") + \"]\");\n+          }\n+          break;\n+        default:\n+      }\n+    }\n+    System.out.println(\"------------------------\");\n+    System.out.println(\"Scanned \" + totalFiles + \" SST files - \" + totalCount + \" entries, \" + totalSize + \" bytes.\");\n+    \n+    //\n+    // Sort the files by increasing sequence number\n+    //\n+    \n+    Collections.sort(meta, new Comparator<FileMetaData>() {\n+      @Override\n+      public int compare(FileMetaData o1, FileMetaData o2) {\n+        if (o1.getNumber() < o2.getNumber()) {\n+          return -1;\n+        } else if (o1.getNumber() > o2.getNumber()) {\n+          return 1;\n+        } else {\n+          return 0;\n+        }\n+      }\n+    });\n+\n+    //\n+    // Now generate the MANIFEST file, putting all files at level 0\n+    //\n+    \n+    // Remove CURRENT file\n+    \n+    File currentFile = new File(path, Filename.currentFileName());\n+    currentFile.delete();\n+    \n+    //\n+    // Initialize a MANIFEST (from VersionSet constructor)\n+    //\n+    \n+    long manifestFileNumber = nextFileNumber.addAndGet(1);\n+    VersionEdit edit = new VersionEdit();\n+    edit.setComparatorName(internalKeyComparator.name());\n+    edit.setLogNumber(nextFileNumber.addAndGet(1));\n+    edit.setNextFileNumber(nextFileNumber.addAndGet(1));\n+    edit.setLastSequenceNumber(maxSequence);\n+\n+    LogWriter log = Logs.createLogWriter(new File(path, Filename.descriptorFileName(manifestFileNumber)), manifestFileNumber);\n+    \n+    try {\n+      log.addRecord(edit.encode(), false);\n+    } finally {\n+      log.close();\n+    }\n+\n+    Filename.setCurrentFile(path, log.getFileNumber());\n+\n+    VersionSet set = new VersionSet(path, tcache, internalKeyComparator);\n+    set.recover();\n+    \n+    edit = new VersionEdit();\n+    \n+    for (FileMetaData f: meta) {\n+      edit.addFile(0, f);\n+    }\n+\n+    set.logAndApply(edit);\n+    set.destroy();\n+    \n+    tcache.close();\n+    \n+    dbLock.release();\n+  }\n+  \n+  private static class InsertIntoHandler implements Handler {\n+    private long sequence;\n+    private final MemTable memTable;\n+\n+    public InsertIntoHandler(MemTable memTable, long sequenceBegin) {\n+      this.memTable = memTable;\n+      this.sequence = sequenceBegin;\n+    }\n+\n+    @Override\n+    public void put(Slice key, Slice value) {\n+      memTable.add(sequence++, ValueType.VALUE, key, value);\n+    }\n+\n+    @Override\n+    public void delete(Slice key) {\n+      memTable.add(sequence++, ValueType.DELETION, key, Slices.EMPTY_SLICE);\n+    }\n+  }\n+\n+  /**\n+   * Convert a log file to a table\n+   * This is adapted from org.iq80.leveldb.impl.DbImpl#recoverLogFile\n+   * @param fileno", "originalCommit": "5efe8e624a60b0aff8e755fc697bf216d53c2112", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "chunk": "diff --git a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\nindex 866932a2..f4ef2114 100644\n--- a/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n+++ b/warp10/src/main/java/io/warp10/standalone/LevelDBRepair.java\n\n@@ -60,7 +60,7 @@ public class LevelDBRepair {\n   \n   private static final InternalKeyComparator internalKeyComparator = new InternalKeyComparator(new BytewiseComparator());\n \n-  private static AtomicLong nextFileNumber = new AtomicLong(0L);\n+  private static final AtomicLong nextFileNumber = new AtomicLong(0L);\n   \n   public static synchronized void repair(File path, Options options) throws IOException {\n     //\n"}}, {"oid": "87544f9e73a519feae66a3b9fcdc541cc931e80c", "url": "https://github.com/senx/warp10-platform/commit/87544f9e73a519feae66a3b9fcdc541cc931e80c", "message": "Addressed PR comments", "committedDate": "2020-03-25T15:12:41Z", "type": "commit"}]}