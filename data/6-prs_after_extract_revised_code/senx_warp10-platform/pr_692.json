{"pr_number": 692, "pr_title": "Modified validation of GTS list.", "pr_createdAt": "2020-03-11T18:33:13Z", "pr_url": "https://github.com/senx/warp10-platform/pull/692", "timeline": [{"oid": "4aa12bbe40e2a81fbce5bb44a7479715de49f662", "url": "https://github.com/senx/warp10-platform/commit/4aa12bbe40e2a81fbce5bb44a7479715de49f662", "message": "Modified validation of GTS list.", "committedDate": "2020-03-11T18:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNzU4MA==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395317580", "bodyText": "You can't use that because it will add a = before each label value, which won't be overridden in case there is a producer and no owner or no producer and an owner.\nAt the end the labelID will be wrong.", "author": "ftence", "createdAt": "2020-03-19T21:02:03Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,83 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+          m.getLabels().putAll(tokenSelectors);", "originalCommit": "4aa12bbe40e2a81fbce5bb44a7479715de49f662", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "6e32a9dc19a61642762cd025744461ca7c908eec", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex e34eff7d..79dad0c8 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -303,13 +303,15 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n             // If the token has a single producer but no owner, use the producer as the owner, this would\n             // lead to a narrower scope than what the token would actually select so it is fine.\n             //\n-            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));                        \n+            m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        \n           } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n             //\n             // If the token has a single owner but no producer, use the owner as the producer, again this would\n             // lead to a narrower scope than what the token can actually access so it is fine too.\n             //\n-            m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));            \n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));            \n+            m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.OWNER_LABEL));            \n           } else {\n             throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer and/or single owner.\");            \n           }\n"}}, {"oid": "6e32a9dc19a61642762cd025744461ca7c908eec", "url": "https://github.com/senx/warp10-platform/commit/6e32a9dc19a61642762cd025744461ca7c908eec", "message": "Added missing substringing of producer/owner", "committedDate": "2020-03-20T08:52:42Z", "type": "commit"}, {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "url": "https://github.com/senx/warp10-platform/commit/4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "message": "Removed useless code", "committedDate": "2020-03-20T09:01:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjIwNw==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522207", "bodyText": "I understand that this is for clarity and safeness but as they are always overridden, this is not needed.", "author": "ftence", "createdAt": "2020-03-20T09:33:20Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);", "originalCommit": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a175742399dba49e8e27a74bb618cf8321f3a", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex e379d898..c6958770 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -276,9 +276,9 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n         //\n         \n         if (!matches) {\n-          m.getLabels().remove(Constants.PRODUCER_LABEL);\n-          m.getLabels().remove(Constants.OWNER_LABEL);\n-          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+          //\n+          // We will now set producer/owner/application\n+          //\n               \n           //\n           // If the token doesn't contain a single app we abort the selection as we cannot\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjQ5Mg==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522492", "bodyText": "Using a variable containing tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1) would be better IMHO.", "author": "ftence", "createdAt": "2020-03-20T09:33:57Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        ", "originalCommit": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a175742399dba49e8e27a74bb618cf8321f3a", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex e379d898..c6958770 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -276,9 +276,9 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n         //\n         \n         if (!matches) {\n-          m.getLabels().remove(Constants.PRODUCER_LABEL);\n-          m.getLabels().remove(Constants.OWNER_LABEL);\n-          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+          //\n+          // We will now set producer/owner/application\n+          //\n               \n           //\n           // If the token doesn't contain a single app we abort the selection as we cannot\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjYzMw==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522633", "bodyText": "Same thing with tokenSelectors.get(Constants.OWNER_LABEL).substring(1).", "author": "ftence", "createdAt": "2020-03-20T09:34:13Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        \n+          } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n+            //\n+            // If the token has a single owner but no producer, use the owner as the producer, again this would\n+            // lead to a narrower scope than what the token can actually access so it is fine too.\n+            //\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+            m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.OWNER_LABEL));            ", "originalCommit": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "216a175742399dba49e8e27a74bb618cf8321f3a", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex e379d898..c6958770 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -276,9 +276,9 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n         //\n         \n         if (!matches) {\n-          m.getLabels().remove(Constants.PRODUCER_LABEL);\n-          m.getLabels().remove(Constants.OWNER_LABEL);\n-          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+          //\n+          // We will now set producer/owner/application\n+          //\n               \n           //\n           // If the token doesn't contain a single app we abort the selection as we cannot\n"}}, {"oid": "216a175742399dba49e8e27a74bb618cf8321f3a", "url": "https://github.com/senx/warp10-platform/commit/216a175742399dba49e8e27a74bb618cf8321f3a", "message": "Addressed PR comments", "committedDate": "2020-03-20T11:02:21Z", "type": "commit"}, {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e", "url": "https://github.com/senx/warp10-platform/commit/a67c285c079f42129521c3ba998fb36a6c95334e", "message": "Reverted incorrect commit", "committedDate": "2020-03-20T11:03:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NjkzMA==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395646930", "bodyText": "Can be defined outside the loop.", "author": "ftence", "createdAt": "2020-03-20T13:47:39Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            String producer = tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1);", "originalCommit": "a67c285c079f42129521c3ba998fb36a6c95334e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex c6958770..2648cbf5 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -243,6 +243,10 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n       boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n       boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n \n+      String application = singleApp ? tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1) : null;\n+      String owner = singleOwner ? tokenSelectors.get(Constants.OWNER_LABEL).substring(1) : null;\n+      String producer = singleProducer ? tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1) : null;\n+      \n       Metadata tmeta = new Metadata();\n       tmeta.setName(\"\");\n       tmeta.setLabels(tokenSelectors);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NzAzNA==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395647034", "bodyText": "Ditto.", "author": "ftence", "createdAt": "2020-03-20T13:47:48Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            String producer = tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1);\n+            m.getLabels().put(Constants.PRODUCER_LABEL, producer);\n+            m.getLabels().put(Constants.OWNER_LABEL, producer);                        \n+          } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n+            //\n+            // If the token has a single owner but no producer, use the owner as the producer, again this would\n+            // lead to a narrower scope than what the token can actually access so it is fine too.\n+            //\n+            String owner = tokenSelectors.get(Constants.OWNER_LABEL).substring(1);", "originalCommit": "a67c285c079f42129521c3ba998fb36a6c95334e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex c6958770..2648cbf5 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -243,6 +243,10 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n       boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n       boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n \n+      String application = singleApp ? tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1) : null;\n+      String owner = singleOwner ? tokenSelectors.get(Constants.OWNER_LABEL).substring(1) : null;\n+      String producer = singleProducer ? tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1) : null;\n+      \n       Metadata tmeta = new Metadata();\n       tmeta.setName(\"\");\n       tmeta.setLabels(tokenSelectors);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0ODg0MA==", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395648840", "bodyText": "Use the variables which will be defined because of the comments below.", "author": "ftence", "createdAt": "2020-03-20T13:50:31Z", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            ", "originalCommit": "a67c285c079f42129521c3ba998fb36a6c95334e", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "chunk": "diff --git a/warp10/src/main/java/io/warp10/script/functions/FETCH.java b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\nindex c6958770..2648cbf5 100644\n--- a/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n+++ b/warp10/src/main/java/io/warp10/script/functions/FETCH.java\n\n@@ -243,6 +243,10 @@ public class FETCH extends NamedWarpScriptFunction implements WarpScriptStackFun\n       boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n       boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n \n+      String application = singleApp ? tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1) : null;\n+      String owner = singleOwner ? tokenSelectors.get(Constants.OWNER_LABEL).substring(1) : null;\n+      String producer = singleProducer ? tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1) : null;\n+      \n       Metadata tmeta = new Metadata();\n       tmeta.setName(\"\");\n       tmeta.setLabels(tokenSelectors);\n"}}, {"oid": "0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "url": "https://github.com/senx/warp10-platform/commit/0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "message": "Addressed more PR comments", "committedDate": "2020-03-20T14:17:08Z", "type": "commit"}]}