{"pr_number": 4714, "pr_title": "[JENKINS-62181] Fix for a deadlock involving custom loggers during agent startup (regression in 2.231)", "pr_createdAt": "2020-05-07T15:04:05Z", "pr_url": "https://github.com/jenkinsci/jenkins/pull/4714", "timeline": [{"oid": "44048365d7efb5e640c22d6c427a4d3013b84c97", "url": "https://github.com/jenkinsci/jenkins/commit/44048365d7efb5e640c22d6c427a4d3013b84c97", "message": "[JENKINS-62181] Deadlock during log formatting", "committedDate": "2020-05-07T15:00:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3NzA5Ng==", "url": "https://github.com/jenkinsci/jenkins/pull/4714#discussion_r421577096", "bodyText": "Note that the super call is still synchronized.", "author": "jglick", "createdAt": "2020-05-07T15:04:35Z", "path": "core/src/main/java/hudson/slaves/SlaveComputer.java", "diffHunk": "@@ -1022,7 +1022,7 @@ public Void call() {\n             SLAVE_LOG_HANDLER = new RingBufferLogHandler(ringBufferSize) {\n                 Formatter dummy = new SimpleFormatter();\n                 @Override\n-                public synchronized void publish(LogRecord record) {\n+                public /* not synchronized */ void publish(LogRecord record) {", "originalCommit": "44048365d7efb5e640c22d6c427a4d3013b84c97", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1NzMwOQ==", "url": "https://github.com/jenkinsci/jenkins/pull/4714#discussion_r421657309", "bodyText": "I am not really sure this will solve the problem, because, as you say, the super is still synchronized. The deadlock is caused by both the RemoteClassLoader that is involved by loading the new overloaded RingBufferLogHandler and the publish synchronized call. Perhaps if a separate  new FormattedRingBufferLogHandler was loaded earlier, then the lock RemoteClassLoader would not be at the same time as the publish synchronized lock.", "author": "bheupers", "createdAt": "2020-05-07T17:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTcxMjYyNQ==", "url": "https://github.com/jenkinsci/jenkins/pull/4714#discussion_r421712625", "bodyText": "AFAICT from the thread dump the deadlock is caused by the following line of code forcing some class loading, so this should bypass the issue. There is not enough information in a thread dump to tell which class needed to be loaded and thus what the real problem was.", "author": "jglick", "createdAt": "2020-05-07T18:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDk4MQ==", "url": "https://github.com/jenkinsci/jenkins/pull/4714#discussion_r425060981", "bodyText": "To add a bit to that: \n  \n    \n      jenkins/core/src/main/java/hudson/slaves/SlaveComputer.java\n    \n    \n         Line 1026\n      in\n      6ede8db\n    \n    \n    \n    \n\n        \n          \n           if (record.getMessage() != null && record.getParameters() != null && Stream.of(record.getParameters()).anyMatch(p -> p != null && !(p instanceof String))) { \n        \n    \n  \n\n is apparently triggering class loading\n\"Channel reader thread: channel\":\n  waiting to lock monitor 0x00007fbd9401aed8 (object 0x000000076ded1cc8, a hudson.remoting.RemoteClassLoader),\n\u2026\n\"Channel reader thread: channel\":\n\tat hudson.slaves.SlaveComputer$SlaveInitializer$1.publish(SlaveComputer.java:1026)\n\nbut the JVM thread dump does not indicate what the initiating class loader was, what class name is being loaded, which subexpression is forcing class loading, etc. In non-deadlock situations, IIRC, you would see a call stack frame from a ClassLoader.loadClass override directly above the familiar source code line, as if it were loading classes reflectively.", "author": "jglick", "createdAt": "2020-05-14T11:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5MTgzNg==", "url": "https://github.com/jenkinsci/jenkins/pull/4714#discussion_r425091836", "bodyText": "I think that the class loaded is the dynamically overrided RingBufferLogHandler or only the new overrided publish method for this class. It could very well be that this will indeed fix the problem because now synchronized for the publish is only in the parent class , and that is already loaded, and it does not need to load and synchronize at the same time. So, lets hope that this will work and thanks for your  efforts.", "author": "bheupers", "createdAt": "2020-05-14T12:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3NzA5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTE3MzYyMA==", "url": "https://github.com/jenkinsci/jenkins/pull/4714#discussion_r425173620", "bodyText": "I think that the class loaded is the dynamically overrided RingBufferLogHandler\n\nSlaveComputer$SlaveInitializer$1? But that is clearly already loaded, because we are running a method on it.\nIt is possible Stream or similar is being loaded for the first time. That is the sort of weird problem I recall from the code link in the PR description.\nInitially I thought that it might be some class linked to one of the record parameters\u2014not p.getClass() itself, which is clearly loaded since we have created the parameter, but a dependency of that parameter class needed to run some methods on it such as toString(). But that cannot be right because in the line 1026 mentioned in the report we are not calling any methods on p; that would come in the next line \n  \n    \n      jenkins/core/src/main/java/hudson/slaves/SlaveComputer.java\n    \n    \n         Line 1027\n      in\n      6ede8db\n    \n    \n    \n    \n\n        \n          \n           record.setMessage(dummy.formatMessage(record)); \n        \n    \n  \n\n and we would expect to see some more stack frames where SimpleFormatter.formatMessage is being called and then calling SomeRemotelyLoadedPluginType.toString.", "author": "jglick", "createdAt": "2020-05-14T14:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU3NzA5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "a01810e7d5096eadeeb061a94107f8f219296d69", "chunk": "diff --git a/core/src/main/java/hudson/slaves/SlaveComputer.java b/core/src/main/java/hudson/slaves/SlaveComputer.java\nindex 4acb106bf0..c6d1c56019 100644\n--- a/core/src/main/java/hudson/slaves/SlaveComputer.java\n+++ b/core/src/main/java/hudson/slaves/SlaveComputer.java\n\n@@ -1020,12 +1020,12 @@ public class SlaveComputer extends Computer {\n \n         public Void call() {\n             SLAVE_LOG_HANDLER = new RingBufferLogHandler(ringBufferSize) {\n-                Formatter dummy = new SimpleFormatter();\n+                ThreadLocal<Formatter> dummy = ThreadLocal.withInitial(() -> new SimpleFormatter());\n                 @Override\n                 public /* not synchronized */ void publish(LogRecord record) {\n                     // see LogRecord.writeObject for dangers of serializing non-String/null parameters\n                     if (record.getMessage() != null && record.getParameters() != null && Stream.of(record.getParameters()).anyMatch(p -> p != null && !(p instanceof String))) {\n-                        record.setMessage(dummy.formatMessage(record));\n+                        record.setMessage(dummy.get().formatMessage(record));\n                         record.setParameters(null);\n                     }\n                     super.publish(record);\n"}}, {"oid": "22f0692bec725ac5823a56904a8a6ca7edb4a258", "url": "https://github.com/jenkinsci/jenkins/commit/22f0692bec725ac5823a56904a8a6ca7edb4a258", "message": "Merge branch 'master' of github.com:jenkinsci/jenkins into deadlock-JENKINS-62181", "committedDate": "2020-05-15T15:38:45Z", "type": "commit"}, {"oid": "a01810e7d5096eadeeb061a94107f8f219296d69", "url": "https://github.com/jenkinsci/jenkins/commit/a01810e7d5096eadeeb061a94107f8f219296d69", "message": "Keep a ThreadLocal for the SimpleFormatter", "committedDate": "2020-05-15T15:44:15Z", "type": "commit"}]}