{"pr_number": 1986, "pr_title": "PLANNER-1627: Planning Server iteration #2 (target architecture)", "pr_createdAt": "2020-01-19T17:47:28Z", "pr_url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODU0OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318548", "bodyText": "I'm not sure why this class is necessary. The same effect should be achievable by adding the following to package-info.java:\n@XmlJavaTypeAdapters({\n    @XmlJavaTypeAdapter(type = LocalDateTime.class, value = LocalDateTimeXmlAdapter.class)\n})", "author": "triceo", "createdAt": "2020-01-19T20:09:58Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.time.LocalDateTime;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import org.kie.internal.jaxb.LocalDateTimeXmlAdapter;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"local-date-time-value\")\n+public class LocalDateTimeValue {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java b/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java\nindex 0a5f77d14..4366f4e4e 100644\n--- a/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java\n+++ b/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java\n\n@@ -17,6 +17,7 @@\n package org.kie.server.api.model.taskassigning;\n \n import java.time.LocalDateTime;\n+import java.util.Objects;\n \n import javax.xml.bind.annotation.XmlAccessType;\n import javax.xml.bind.annotation.XmlAccessorType;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODY0Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318647", "bodyText": "10 minutes seems to me to be far too long for anything.", "author": "triceo", "createdAt": "2020-01-19T20:11:54Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+    }\n+\n+    static KieServicesClient createKieServicesClient(final String endpoint,\n+                                                     final String login,\n+                                                     final String password) {\n+\n+        final KieServicesConfiguration configuration = KieServicesFactory.newRestConfiguration(endpoint, login, password);\n+        configuration.setTimeout(600000);", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNjg2OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368406869", "bodyText": "good catch, it's a 60.000 instead of 600.000", "author": "wmedvede", "createdAt": "2020-01-20T07:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODY0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "e3481e09293a730bebdaa38e8399cf36fefe4916", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\nindex 5c72e2711..2b12b814b 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\n\n@@ -20,7 +20,6 @@ import java.util.Arrays;\n import java.util.HashSet;\n import java.util.Set;\n \n-import org.kie.server.api.KieServerConstants;\n import org.kie.server.api.marshalling.MarshallingFormat;\n import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODcxMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318710", "bodyText": "I think you can use Collections.singletonMap().", "author": "triceo", "createdAt": "2020-01-19T20:13:02Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.helper;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.kie.server.client.KieServicesConfiguration;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+import org.kie.server.client.impl.TaskAssigningRuntimeClientImpl;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeServicesClientBuilder implements KieServicesClientBuilder {\n+\n+    @Override\n+    public String getImplementedCapability() {\n+        return CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+    }\n+\n+    @Override\n+    public Map<Class<?>, Object> build(KieServicesConfiguration configuration, ClassLoader classLoader) {\n+        final Map<Class<?>, Object> services = new HashMap<>();", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java\nindex 2d8554ee4..4805fde0d 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java\n\n@@ -16,7 +16,7 @@\n \n package org.kie.server.client.helper;\n \n-import java.util.HashMap;\n+import java.util.Collections;\n import java.util.Map;\n \n import org.kie.server.client.KieServicesConfiguration;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODc3MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318771", "bodyText": "Can we get away with this? Is it normal that some KIE server components would not implement JMS, only REST?", "author": "triceo", "createdAt": "2020-01-19T20:13:53Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.impl;\n+\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.kie.server.api.exception.KieServicesException;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.api.rest.RestURI;\n+import org.kie.server.client.KieServicesConfiguration;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_EXECUTE_PLANNING_URI;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_QUERIES_TASK_DATA_URI;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_RUNTIME_URI;\n+\n+public class TaskAssigningRuntimeClientImpl extends AbstractKieServicesClientImpl implements TaskAssigningRuntimeClient {\n+\n+    public TaskAssigningRuntimeClientImpl(KieServicesConfiguration config) {\n+        super(config);\n+    }\n+\n+    public TaskAssigningRuntimeClientImpl(KieServicesConfiguration config, ClassLoader classLoader) {\n+        super(config, classLoader);\n+    }\n+\n+    @Override\n+    public ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId) {\n+        if (config.isRest()) {\n+            final String uri = TASK_ASSIGNING_RUNTIME_URI + \"/\" + TASK_ASSIGNING_EXECUTE_PLANNING_URI + \"?user=\" + userId;\n+            return makeHttpPostRequestAndCreateCustomResponse(RestURI.build(loadBalancer.getUrl(),\n+                                                                            uri,\n+                                                                            Collections.emptyMap()),\n+                                                              planningItemList,\n+                                                              ExecutePlanningResult.class);\n+        } else {\n+            throw new KieServicesException(\"JMS protocol is not implemented for this service.\");", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwODM1Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368408357", "bodyText": "at this point the only protocol that is being used is REST and so will probalby happen with 95% probability for the rest of the life of this API.  Note that is api is used for consuming the tasks information and executing the plan from the KieServerPlanningExtension, and here we don't want/need JMS invocation.\nIn general I'd say that this also the for 90% of the uses of the kie-server apis, and only a reduced set of use cases/customers use JMS.\nSo by now we can live with that, but yes, in future iteration JMS alternative can be added with no problem.", "author": "wmedvede", "createdAt": "2020-01-20T08:01:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODc3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java\nindex bfc977bc2..4d2c5002b 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java\n\n@@ -23,7 +23,7 @@ import java.util.List;\n import java.util.Map;\n \n import org.kie.server.api.exception.KieServicesException;\n-import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningExecutionResult;\n import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n import org.kie.server.api.model.taskassigning.PlanningItemList;\n import org.kie.server.api.model.taskassigning.TaskDataList;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODk0Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318947", "bodyText": "Would you please explain (possibly in comments) the logic of this loop?", "author": "triceo", "createdAt": "2020-01-19T20:16:09Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.util;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+public class TaskDataReader {\n+\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    private TaskDataReader(TaskAssigningRuntimeClient runtimeClient) {\n+        this.runtimeClient = runtimeClient;\n+    }\n+\n+    public static class Result {\n+\n+        LocalDateTime queryTime;\n+\n+        List<TaskData> tasks;\n+\n+        private Result(LocalDateTime queryTime, List<TaskData> tasks) {\n+            this.queryTime = queryTime;\n+            this.tasks = tasks;\n+        }\n+\n+        public LocalDateTime getQueryTime() {\n+            return queryTime;\n+        }\n+\n+        public List<TaskData> getTasks() {\n+            return tasks;\n+        }\n+    }\n+\n+    public static TaskDataReader from(TaskAssigningRuntimeClient runtimeClient) {\n+        return new TaskDataReader(runtimeClient);\n+    }\n+\n+    public Result readTasks(long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n+                            int pageSize, TaskInputVariablesReadMode taskInputVariablesReadMode) {\n+        final List<TaskData> result = new ArrayList<>();\n+        boolean finished = false;\n+        List<TaskData> partialResult;\n+        TaskDataList taskDataList;\n+        TaskData lastItem = null;\n+        LocalDateTime queryTime = null;\n+\n+        long taskId = fromTaskId;\n+        int nextPageSize = pageSize;\n+        while (!finished) {\n+            taskDataList = runtimeClient.findTasks(taskId, status, fromLastModificationDate,\n+                                                   0, nextPageSize, taskInputVariablesReadMode);\n+            partialResult = new ArrayList<>(taskDataList.getItems());", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwOTQ4OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368409488", "bodyText": "yes, in general the kie-server queries related APIs that iterates server side datasets are based on a paging reading. By passing the pageNumber and pageSize.\nBut here I need to read all the values, but, doing a paging reading.\nSo this loop implements \"read all values\" by getting chunks in a paged reading fashion.\nNote the for feeding the solver e.g. for creating the initial solution, we need to consume all the tasks, and not only a page.", "author": "wmedvede", "createdAt": "2020-01-20T08:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODk0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java\nindex 026855e71..c3bc21c4a 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java\n\n@@ -25,6 +25,10 @@ import org.kie.server.api.model.taskassigning.TaskDataList;\n import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n import org.kie.server.client.TaskAssigningRuntimeClient;\n \n+/**\n+ * Helper class for reading all the elements returned by the {@link TaskAssigningRuntimeClient#findTasks} methods.\n+ * This class manages the required pagination for getting all the results.\n+ */\n public class TaskDataReader {\n \n     private TaskAssigningRuntimeClient runtimeClient;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTYxMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319610", "bodyText": "This method is very long. I think it would be good to split it into a couple sub-methods.", "author": "triceo", "createdAt": "2020-01-19T20:23:48Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.DUMMY_TASK_PLANNER_241;\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.PLANNING_USER;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Completed;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Error;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Exited;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Failed;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Obsolete;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.server.services.taskassigning.planning.SolutionBuilder.addInOrder;\n+import static org.kie.server.services.taskassigning.planning.SolutionBuilder.fromTaskData;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.fromExternalUser;\n+\n+/**\n+ * This class performs the calculation of the impact (i.e. the set of changes to be applied) on a solution given the\n+ * updated information about the tasks in the jBPM runtime.\n+ */\n+public class SolutionChangesBuilder {\n+\n+    private static Logger LOGGER = LoggerFactory.getLogger(SolutionChangesBuilder.class);\n+\n+    private TaskAssigningSolution solution;\n+\n+    private List<TaskData> taskDataList;\n+\n+    private UserSystemService systemService;\n+\n+    private SolverHandlerContext context;\n+\n+    public SolutionChangesBuilder() {\n+    }\n+\n+    public SolutionChangesBuilder withSolution(TaskAssigningSolution solution) {\n+        this.solution = solution;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withTasks(List<TaskData> taskDataList) {\n+        this.taskDataList = taskDataList;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withUserSystem(UserSystemService userSystemService) {\n+        this.systemService = userSystemService;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withContext(SolverHandlerContext context) {\n+        this.context = context;\n+        return this;\n+    }\n+\n+    public List<ProblemFactChange<TaskAssigningSolution>> build() {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java\nindex 53bc60efc..ba248a917 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java\n\n@@ -25,6 +25,7 @@ import java.util.Set;\n import java.util.function.Function;\n import java.util.stream.Collectors;\n \n+import org.kie.api.task.model.Status;\n import org.kie.server.services.taskassigning.core.model.Task;\n import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n import org.kie.server.services.taskassigning.core.model.User;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTc1Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319756", "bodyText": "Another very long and cryptic method.", "author": "triceo", "createdAt": "2020-01-19T20:25:26Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.Consumer;\n+\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manages the periodical reading (polling strategy) of current tasks from the jBPM runtime and depending\n+ * on the \"action\" INIT_SOLVER_EXECUTOR / SYNCHRONIZE_SOLUTION determines if the solver executor must be restarted with\n+ * a fully recovered solution or instead the tasks updated information is used for calculating the required changes\n+ * for the proper solution update. If any changes are calculated they are notified to the resultConsumer.\n+ * This class implements proper retries in case of connection issues with the target jBPM runtime, etc.\n+ */\n+public class SolutionSynchronizer extends RunnableBase {\n+\n+    public static final int INIT_SOLVER_EXECUTOR = 0;\n+    public static final int SYNCHRONIZE_SOLUTION = 1;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionSynchronizer.class);\n+\n+    private final SolverExecutor solverExecutor;\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final UserSystemService userSystemService;\n+    private final long syncInterval;\n+    private final SolverHandlerContext context;\n+    private final Consumer<Result> resultConsumer;\n+    private int solverExecutorStarts = 0;\n+    private TaskAssigningSolution solution;\n+    private LocalDateTime fromLastModificationDate;\n+    private int action = INIT_SOLVER_EXECUTOR;\n+\n+    private final Semaphore startPermit = new Semaphore(0);\n+\n+    public static class Result {\n+\n+        private List<ProblemFactChange<TaskAssigningSolution>> changes;\n+\n+        public Result(List<ProblemFactChange<TaskAssigningSolution>> changes) {\n+            this.changes = changes;\n+        }\n+\n+        public List<ProblemFactChange<TaskAssigningSolution>> getChanges() {\n+            return changes;\n+        }\n+    }\n+\n+    public SolutionSynchronizer(final SolverExecutor solverExecutor,\n+                                final TaskAssigningRuntimeDelegate delegate,\n+                                final UserSystemService userSystem,\n+                                final long syncInterval,\n+                                final SolverHandlerContext context,\n+                                final Consumer<Result> resultConsumer) {\n+        checkNotNull(\"solverExecutor\", solverExecutor);\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"userSystem\", userSystem);\n+        checkCondition(\"syncInterval\", syncInterval > 0);\n+        checkNotNull(\"context\", context);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+\n+        this.solverExecutor = solverExecutor;\n+        this.delegate = delegate;\n+        this.userSystemService = userSystem;\n+        this.syncInterval = syncInterval;\n+        this.context = context;\n+        this.resultConsumer = resultConsumer;\n+    }\n+\n+    public void initSolverExecutor() {\n+        this.action = INIT_SOLVER_EXECUTOR;\n+        startPermit.release();\n+    }\n+\n+    public void synchronizeSolution(TaskAssigningSolution solution, LocalDateTime fromLastModificationDate) {\n+        this.solution = solution;\n+        this.fromLastModificationDate = fromLastModificationDate;\n+        this.action = SYNCHRONIZE_SOLUTION;\n+        LOGGER.debug(\"Start synchronizeSolution fromLastModificationDate: \" + fromLastModificationDate);\n+        startPermit.release();\n+    }\n+\n+    /**\n+     * Starts the synchronizing finalization, that will be produced as soon as possible.\n+     * It's a non thread-safe method, but only first invocation has effect.\n+     */\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        startPermit.release(); //in case it's waiting for start.\n+    }\n+\n+    @Override\n+    public void run() {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java\nindex 31091dcb8..d7b82e1c9 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java\n\n@@ -20,21 +20,24 @@ import java.time.LocalDateTime;\n import java.util.Arrays;\n import java.util.List;\n import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicReference;\n import java.util.function.Consumer;\n \n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n import org.kie.server.api.model.taskassigning.TaskData;\n import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n import org.kie.server.services.taskassigning.user.system.api.User;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n import org.optaplanner.core.impl.solver.ProblemFactChange;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.api.task.model.Status.InProgress;\n+import static org.kie.api.task.model.Status.Ready;\n+import static org.kie.api.task.model.Status.Reserved;\n+import static org.kie.api.task.model.Status.Suspended;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTED;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STOPPED;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319852", "bodyText": "Have you considered using the new SolverManager API? It was designed for use cases such as yours, and I think it would save you a lot of code in the parts where you run/synchronize the solver.", "author": "triceo", "createdAt": "2020-01-19T20:26:42Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQ3MjYyNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368472627", "bodyText": "SolverManager API wasn't available/delivered at the time this development started and don't know if it's production ready right now. So it wasn't included as part of this development, and I don't see this as a priority right know. When this this version is stable, etc, I'll take a look and evaluate the benefits/drawbacks of adding it.", "author": "wmedvede", "createdAt": "2020-01-20T10:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3OTI0Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369579243", "bodyText": "It has a potential to help you get rid of a lot of code, including testing.", "author": "rsynek", "createdAt": "2020-01-22T14:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxMDk0Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370510943", "bodyText": "Guys, as I mentioned before, it took too long to setup this initial \"running\" version, and priority now is to have this version closed, ideally in this sprint. After this, improvements ad-dings are welcome, but will be incorporated in separate JIRAs, I want to have more control on this.\nThe following JIRA will track this adding\nhttps://issues.redhat.com/browse/PLANNER-1805\nThanks.", "author": "wmedvede", "createdAt": "2020-01-24T08:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java\nindex a25b11402..5d83f0a4e 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java\n\n@@ -19,16 +19,55 @@ package org.kie.server.client;\n import java.time.LocalDateTime;\n import java.util.List;\n \n-import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningExecutionResult;\n import org.kie.server.api.model.taskassigning.PlanningItemList;\n import org.kie.server.api.model.taskassigning.TaskDataList;\n import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n \n public interface TaskAssigningRuntimeClient {\n \n-    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);\n+    PlanningExecutionResult executePlanning(PlanningItemList planningItemList, String userId);\n \n+    /**\n+     * Executes a parametrized query over the jBPM tasks. This method is intended for the tasks assigning integration\n+     * implementation internal use. Third parties interested in consuming the information type returned by this method\n+     * should use the simplified variant of this of this method {@link #findTasks(Long, List, LocalDateTime, Integer, Integer)}\n+     * or any other of the jBPM runtime client/queries methods, etc.\n+     * <p>\n+     * @param fromTaskId filters the tasks with taskId >= fromTaskId. If null no filtering is applied.\n+     * @param status filters the tasks that are in one of the following status. If null or the empty list no filtering\n+     * is applied.\n+     * @param fromLastModificationDate filters the tasks with lastModificationDate >= fromLastModificationDate. If null\n+     * no filtering is applied.\n+     * @param page sets the starting page for the paged reading.\n+     * @param pageSize sets the pageSize for the paged reading.\n+     * @param taskInputVariablesReadMode establishes the tasks input variables reading mode.\n+     * @return a list of TaskData with the jBPM tasks that met the filtering conditions. The potential owners of the task\n+     * are always loaded but there's no warranty that the potential owners of the last consumed task fits the page/pageSize\n+     * configuration. The task inputs data is loaded accordingly with the selected taskInputVariablesReadMode.\n+     * @see TaskInputVariablesReadMode\n+     */\n     TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n                            Integer page, Integer pageSize,\n                            TaskInputVariablesReadMode taskInputVariablesReadMode);\n+\n+    /**\n+     * Executes a parametrized query over the jBPM tasks. This method is intended for the tasks assigning integration\n+     * implementation. Third parties that might use this method must be aware that no task inputs data is loaded. If this\n+     * information is needed the standard jBPM runtime client/queries must be used instead.\n+     * <p>\n+     * @param fromTaskId filters the tasks with taskId >= fromTaskId. If null no filtering is applied.\n+     * @param status filters the tasks that are in one of the following status. If null or the empty list no filtering\n+     * is applied.\n+     * @param fromLastModificationDate filters the tasks with lastModificationDate >= fromLastModificationDate. If null\n+     * no filtering is applied.\n+     * @param page sets the starting page for the paged reading.\n+     * @param pageSize sets the pageSize for the paged reading.\n+     * @return a list of TaskData with the jBPM tasks that met the filtering conditions. The potential owners of the task\n+     * is always loaded but there's no warranty that the potential owners of the last consumed taks fits the page/pageSize\n+     * configuration. NO task inputs data is loaded by this method.\n+     * @see TaskInputVariablesReadMode\n+     */\n+    TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n+                           Integer page, Integer pageSize);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyMDQwNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368320405", "bodyText": "Did we ever consider what happens on Websphere, Weblogic and Tomcat?\n(I'm not sure we're being asked to deliver those. Traditionally, we would have been. A question for PM, perhaps?)", "author": "triceo", "createdAt": "2020-01-19T20:32:39Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.user.system.simple;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.kie.server.services.taskassigning.user.system.api.Group;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+public class WildflyUtil {", "originalCommit": "64260a2898b6386a3da061fdf31cf36d7775d6be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQwNTUwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368405506", "bodyText": "I'm still pending to send the document with the configuration options, etc. Will have today.\nBut the name WildlfyUtil in this context means that the \"UserSystemServiceSimple\" implementation is a \"simple\" one, that reads the users definitions from a file with the format\nuserA=group1,group2\nuserB=group1,group3\nand so on, it's a kind of \"development\" mode user system service implementation.\nBut is not tight to any particular container.\nDeployments in other containers than WF can still use this format for \"development\", \"testing\" or even production (this last option is less likely). The only thing they have to do is to copy the configuration file in a directory that can be accessed by kie-server webapp  and configure the \"UserSystemServiceSimple\" with the parameter\n\nAs long the kie-server webapp can access the directory XXXXX it'll work.", "author": "wmedvede", "createdAt": "2020-01-20T07:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyMDQwNQ=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java\nindex 12ff2b313..cc1080069 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java\n\n@@ -38,6 +38,9 @@ import static org.apache.commons.lang3.StringUtils.isEmpty;\n \n public class WildflyUtil {\n \n+    private WildflyUtil() {\n+    }\n+\n     public static UserGroupInfo buildInfo(URI uri) throws IOException {\n         try (InputStream in = Files.newInputStream(Paths.get(uri))) {\n             return buildInfo(in);\n"}}, {"oid": "e3481e09293a730bebdaa38e8399cf36fefe4916", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e3481e09293a730bebdaa38e8399cf36fefe4916", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-20T16:00:56Z", "type": "forcePushed"}, {"oid": "15d5275064a5fb2238fdf246bb7a52e5ff186bba", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/15d5275064a5fb2238fdf246bb7a52e5ff186bba", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-21T09:15:59Z", "type": "forcePushed"}, {"oid": "3971a9e009547e449964d8c4a91f669111db24ce", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/3971a9e009547e449964d8c4a91f669111db24ce", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-21T20:20:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTA1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369491058", "bodyText": "This is a bit confusing. Constants names are usually all upper case.", "author": "yurloc", "createdAt": "2020-01-22T10:52:09Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,", "originalCommit": "3971a9e009547e449964d8c4a91f669111db24ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NzkyMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369967921", "bodyText": "+1 and my apologizes, this test is not part or the product code, just a local test I run for playing a bit. Will be removed as part of the review.", "author": "wmedvede", "createdAt": "2020-01-23T07:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTA1OA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java\ndeleted file mode 100644\nindex adbf15bbb..000000000\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java\n+++ /dev/null\n\n@@ -1,247 +0,0 @@\n-/*\n- * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.client;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import org.apache.commons.lang3.time.StopWatch;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.kie.server.api.model.instance.ProcessInstance;\n-import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.api.model.taskassigning.PlanningItemList;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n-import org.kie.server.api.model.taskassigning.TaskData;\n-import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n-import org.kie.server.client.util.TaskDataReader;\n-\n-import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n-\n-public class IntegrationTests {\n-\n-    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n-    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n-\n-    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n-    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n-\n-    private static List<Integer> pageSizes = Arrays.asList(3000);\n-\n-    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n-\n-    private TaskAssigningRuntimeClient client;\n-\n-    @Before\n-    public void setUp() {\n-        timeRegistry.clear();\n-        client = newTaskAssigningRuntimeClient();\n-    }\n-\n-    @Test\n-    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n-        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n-    }\n-\n-    @Test\n-    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n-        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n-    }\n-\n-    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n-        List<String> status = Arrays.asList(Ready,\n-                                            Reserved,\n-                                            InProgress,\n-                                            Suspended);\n-\n-        registerStartTime(\"findTasks\");\n-        List<TaskData> list = client.findTasks(0L, status, null, 0, pageSize, inputVariablesReadMode).getItems();\n-        StopWatch stopWatch = registerEndTime(\"findTasks\");\n-        System.out.println(\"Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime((stopWatch)));\n-    }\n-\n-    @Test\n-    public void findTasksWithTasksReaderAllVariablesReadTime() {\n-        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n-    }\n-\n-    @Test\n-    public void findTasksWithTasksReaderVariablesWhenPlanningTaskIsNull() {\n-        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n-    }\n-\n-    @Test\n-    public void findTasksWithTasksReaderNoVariables() {\n-        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.DONT_READ));\n-    }\n-\n-    private void findTasksWithTasksReaderTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n-        List<String> status = Arrays.asList(Ready,\n-                                            Reserved,\n-                                            InProgress,\n-                                            Suspended);\n-\n-        registerStartTime(\"findTasks\");\n-        List<TaskData> list = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, inputVariablesReadMode).getTasks();\n-        StopWatch stopWatch = registerEndTime(\"findTasks\");\n-        System.out.println(\"With TaskDataReader, Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime(stopWatch));\n-    }\n-\n-    private static String printTime(StopWatch stopWatch) {\n-        return stopWatch.toString();\n-    }\n-\n-    @Test\n-    public void createProcessInstances() {\n-\n-        int processInstancesSize = 5;\n-        List<Long> processInstances = new ArrayList<>();\n-\n-        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n-\n-        long processInstanceId;\n-        for (int i = 0; i < processInstancesSize; i++) {\n-            HashMap inputParams = new HashMap();\n-            inputParams.put(\"processVar1\", \"generatedValue.for.taskInput1_\" + i);\n-            inputParams.put(\"processVar2\", \"generatedValue.for.taskInput2_\" + i);\n-            processInstanceId = processServices.startProcess(CONTAINER_ID, PROCESS_ID);\n-            processInstances.add(processInstanceId);\n-        }\n-        String ids = processInstances.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n-        System.out.println(\"Created process instances: [\" + ids + \"]\");\n-    }\n-\n-    @Test\n-    public void destroyProcessInstances() {\n-        List<Long> processInstanceIds = new ArrayList<>();\n-\n-        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n-\n-        List<ProcessInstance> processInstances = processServices.findProcessInstances(CONTAINER_ID, 0, 10000);\n-        processInstances.forEach(processInstance -> {\n-            if (PROCESS_ID.equals(processInstance.getProcessId()) &&\n-                    processInstance.getState() == org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE) {\n-                processInstanceIds.add(processInstance.getId());\n-                processServices.abortProcessInstance(CONTAINER_ID, processInstance.getId());\n-            }\n-        });\n-        String ids = processInstanceIds.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n-        System.out.println(\"Destroyed process instances: [\" + ids + \"]\");\n-    }\n-\n-    @Test\n-    public void executePlanning() {\n-        List<String> status = Arrays.asList(Ready,\n-                                            Reserved,\n-                                            InProgress,\n-                                            Suspended);\n-        int pageSize = 3000;\n-\n-        registerStartTime(\"readTasks\");\n-        List<TaskData> taskList = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, TaskInputVariablesReadMode.DONT_READ).getTasks();\n-        StopWatch readTasksStopWatch = registerEndTime(\"readTasks\");\n-\n-        String[] potentialOwners = {\"user0\", \"user1\", \"user2\", \"user3\", \"user4\", \"user5\"};\n-        int publishWindowSize = 2;\n-\n-        Map<String, List<PlanningItem>> userIdToPlanningItems = new HashMap<>();\n-        List<PlanningItem> userPlanningItems;\n-\n-        int userIndex = -1;\n-        String userId;\n-        int i = 0;\n-        for (TaskData taskData : taskList) {\n-            userIndex = (userIndex + 1) % potentialOwners.length;\n-            userId = potentialOwners[userIndex];\n-            userPlanningItems = userIdToPlanningItems.computeIfAbsent(userId, s -> new ArrayList<>());\n-\n-            PlanningItem planningItem = PlanningItem.builder()\n-                    .taskId(taskData.getTaskId())\n-                    .processInstanceId(taskData.getProcessInstanceId())\n-                    .containerId(taskData.getContainerId())\n-                    .planningTask(PlanningTask.builder()\n-                                          .taskId(taskData.getTaskId())\n-                                          .assignedUser(userId)\n-                                          .index(userPlanningItems.size())\n-                                          .published(userPlanningItems.size() < publishWindowSize)\n-                                          .build())\n-                    .build();\n-            if (i++ < 10000) {\n-                userPlanningItems.add(planningItem);\n-            }\n-        }\n-        List<PlanningItem> planningItems = userIdToPlanningItems.values().stream()\n-                .flatMap(Collection::stream)\n-                .collect(Collectors.toList());\n-        registerStartTime(\"executePlanning\");\n-        client.executePlanning(new PlanningItemList(planningItems), \"wbadmin\");\n-        StopWatch executePlanningStopWatch = registerEndTime(\"executePlanning\");\n-\n-        System.out.println(taskList.size() + \" tasks were read with the TaskDataReader and a pageSize: \" + pageSize + \" in: \" + printTime(readTasksStopWatch));\n-        System.out.println(\"Planning with \" + planningItems.size() + \" items and \" + potentialOwners.length + \" assigned users items was executed in: \" + printTime(executePlanningStopWatch));\n-    }\n-\n-    @Test\n-    public void testExecutePlanningFailure() {\n-        List<PlanningItem> planningItems = new ArrayList<>();\n-        planningItems.add(PlanningItem.builder().taskId((long) 1)\n-                                  .containerId(CONTAINER_ID)\n-                                  .processInstanceId((long) 1)\n-                                  .planningTask(PlanningTask.builder()\n-                                                        .assignedUser(\"rollback\")\n-                                                        .taskId((long) 1)\n-                                                        .index(3333)\n-                                                        .published(false)\n-                                                        .build()).build());\n-        PlanningItemList planningItemList = new PlanningItemList();\n-        planningItemList.setPlanningItems(planningItems.toArray(new PlanningItem[0]));\n-        client.executePlanning(planningItemList, \"wbadmin\");\n-    }\n-\n-    private KieServicesClient newKieServicesClient() {\n-        return TaskAssigningRuntimeClientFactory.createKieServicesClient(SERVER_URL,\n-                                                                         \"wbadmin\",\n-                                                                         \"wbadmin\");\n-    }\n-\n-    private TaskAssigningRuntimeClient newTaskAssigningRuntimeClient() {\n-        KieServicesClient servicesClient = TaskAssigningRuntimeClientFactory.createKieServicesClient(SERVER_URL,\n-                                                                                                     \"wbadmin\",\n-                                                                                                     \"wbadmin\");\n-        return servicesClient.getServicesClient(TaskAssigningRuntimeClient.class);\n-    }\n-\n-    private void registerStartTime(String timeId) {\n-        StopWatch stopWatch = new StopWatch();\n-        stopWatch.start();\n-        timeRegistry.put(timeId, stopWatch);\n-    }\n-\n-    private StopWatch registerEndTime(String timeId) {\n-        StopWatch stopWatch = timeRegistry.get(timeId);\n-        stopWatch.stop();\n-        return stopWatch;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTYxNA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369491614", "bodyText": "Could be an enum. Btw, isn't this already available somewhere in jBPM API?", "author": "yurloc", "createdAt": "2020-01-22T10:53:20Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class UserType {", "originalCommit": "3971a9e009547e449964d8c4a91f669111db24ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjAyNTM5Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382025392", "bodyText": "I've looked, but no definition exists in jBPM API. Constants where upper-cased.", "author": "wmedvede", "createdAt": "2020-02-20T14:16:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTYxNA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java\nindex 1b3899ad1..dd703d2e5 100644\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java\n+++ b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java\n\n@@ -18,6 +18,9 @@ package org.kie.server.api.model.taskassigning;\n \n public class UserType {\n \n+    private UserType() {\n+    }\n+\n     public static final String User = \"User\";\n     public static final String Group = \"Group\";\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MjU0Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369492542", "bodyText": "Import property name from org.kie.server.api.KieServerConstants?", "author": "yurloc", "createdAt": "2020-01-22T10:55:31Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());", "originalCommit": "3971a9e009547e449964d8c4a91f669111db24ce", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\nindex 2b12b814b..7d8291e5b 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\n\n@@ -25,13 +25,17 @@ import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n \n import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+import static org.kie.server.api.KieServerConstants.CFG_BYPASS_AUTH_USER;\n \n public class TaskAssigningRuntimeClientFactory {\n \n     static {\n         // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n         // of other users\n-        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+        System.setProperty(CFG_BYPASS_AUTH_USER, Boolean.TRUE.toString());\n+    }\n+\n+    private TaskAssigningRuntimeClientFactory() {\n     }\n \n     static KieServicesClient createKieServicesClient(final String endpoint,\n"}}, {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-01-22T10:30:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369512358", "bodyText": "inputParams is unused. Maybe it should be passed here?\nBtw, how do I run IntegrationTests? If I run it from IDEA I get this:\n\norg.kie.server.common.rest.NoEndpointFoundException: No available endpoints found\n\nIf I do mvn clean install the test doesn't seem to be run at all.", "author": "yurloc", "createdAt": "2020-01-22T11:42:31Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = client.findTasks(0L, status, null, 0, pageSize, inputVariablesReadMode).getItems();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime((stopWatch)));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderNoVariables() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.DONT_READ));\n+    }\n+\n+    private void findTasksWithTasksReaderTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, inputVariablesReadMode).getTasks();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"With TaskDataReader, Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime(stopWatch));\n+    }\n+\n+    private static String printTime(StopWatch stopWatch) {\n+        return stopWatch.toString();\n+    }\n+\n+    @Test\n+    public void createProcessInstances() {\n+\n+        int processInstancesSize = 5;\n+        List<Long> processInstances = new ArrayList<>();\n+\n+        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n+\n+        long processInstanceId;\n+        for (int i = 0; i < processInstancesSize; i++) {\n+            HashMap inputParams = new HashMap();\n+            inputParams.put(\"processVar1\", \"generatedValue.for.taskInput1_\" + i);\n+            inputParams.put(\"processVar2\", \"generatedValue.for.taskInput2_\" + i);\n+            processInstanceId = processServices.startProcess(CONTAINER_ID, PROCESS_ID);", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNDE1Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369634156", "bodyText": "The same for me.", "author": "rsynek", "createdAt": "2020-01-22T15:38:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2ODE4MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369968181", "bodyText": "same here, this class will be removed.", "author": "wmedvede", "createdAt": "2020-01-23T07:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java\ndeleted file mode 100644\nindex adbf15bbb..000000000\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java\n+++ /dev/null\n\n@@ -1,247 +0,0 @@\n-/*\n- * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.client;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-\n-import org.apache.commons.lang3.time.StopWatch;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.kie.server.api.model.instance.ProcessInstance;\n-import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.api.model.taskassigning.PlanningItemList;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n-import org.kie.server.api.model.taskassigning.TaskData;\n-import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n-import org.kie.server.client.util.TaskDataReader;\n-\n-import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n-import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n-\n-public class IntegrationTests {\n-\n-    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n-    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n-\n-    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n-    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n-\n-    private static List<Integer> pageSizes = Arrays.asList(3000);\n-\n-    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n-\n-    private TaskAssigningRuntimeClient client;\n-\n-    @Before\n-    public void setUp() {\n-        timeRegistry.clear();\n-        client = newTaskAssigningRuntimeClient();\n-    }\n-\n-    @Test\n-    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n-        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n-    }\n-\n-    @Test\n-    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n-        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n-    }\n-\n-    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n-        List<String> status = Arrays.asList(Ready,\n-                                            Reserved,\n-                                            InProgress,\n-                                            Suspended);\n-\n-        registerStartTime(\"findTasks\");\n-        List<TaskData> list = client.findTasks(0L, status, null, 0, pageSize, inputVariablesReadMode).getItems();\n-        StopWatch stopWatch = registerEndTime(\"findTasks\");\n-        System.out.println(\"Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime((stopWatch)));\n-    }\n-\n-    @Test\n-    public void findTasksWithTasksReaderAllVariablesReadTime() {\n-        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n-    }\n-\n-    @Test\n-    public void findTasksWithTasksReaderVariablesWhenPlanningTaskIsNull() {\n-        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n-    }\n-\n-    @Test\n-    public void findTasksWithTasksReaderNoVariables() {\n-        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.DONT_READ));\n-    }\n-\n-    private void findTasksWithTasksReaderTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n-        List<String> status = Arrays.asList(Ready,\n-                                            Reserved,\n-                                            InProgress,\n-                                            Suspended);\n-\n-        registerStartTime(\"findTasks\");\n-        List<TaskData> list = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, inputVariablesReadMode).getTasks();\n-        StopWatch stopWatch = registerEndTime(\"findTasks\");\n-        System.out.println(\"With TaskDataReader, Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime(stopWatch));\n-    }\n-\n-    private static String printTime(StopWatch stopWatch) {\n-        return stopWatch.toString();\n-    }\n-\n-    @Test\n-    public void createProcessInstances() {\n-\n-        int processInstancesSize = 5;\n-        List<Long> processInstances = new ArrayList<>();\n-\n-        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n-\n-        long processInstanceId;\n-        for (int i = 0; i < processInstancesSize; i++) {\n-            HashMap inputParams = new HashMap();\n-            inputParams.put(\"processVar1\", \"generatedValue.for.taskInput1_\" + i);\n-            inputParams.put(\"processVar2\", \"generatedValue.for.taskInput2_\" + i);\n-            processInstanceId = processServices.startProcess(CONTAINER_ID, PROCESS_ID);\n-            processInstances.add(processInstanceId);\n-        }\n-        String ids = processInstances.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n-        System.out.println(\"Created process instances: [\" + ids + \"]\");\n-    }\n-\n-    @Test\n-    public void destroyProcessInstances() {\n-        List<Long> processInstanceIds = new ArrayList<>();\n-\n-        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n-\n-        List<ProcessInstance> processInstances = processServices.findProcessInstances(CONTAINER_ID, 0, 10000);\n-        processInstances.forEach(processInstance -> {\n-            if (PROCESS_ID.equals(processInstance.getProcessId()) &&\n-                    processInstance.getState() == org.kie.api.runtime.process.ProcessInstance.STATE_ACTIVE) {\n-                processInstanceIds.add(processInstance.getId());\n-                processServices.abortProcessInstance(CONTAINER_ID, processInstance.getId());\n-            }\n-        });\n-        String ids = processInstanceIds.stream().map(Object::toString).collect(Collectors.joining(\", \"));\n-        System.out.println(\"Destroyed process instances: [\" + ids + \"]\");\n-    }\n-\n-    @Test\n-    public void executePlanning() {\n-        List<String> status = Arrays.asList(Ready,\n-                                            Reserved,\n-                                            InProgress,\n-                                            Suspended);\n-        int pageSize = 3000;\n-\n-        registerStartTime(\"readTasks\");\n-        List<TaskData> taskList = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, TaskInputVariablesReadMode.DONT_READ).getTasks();\n-        StopWatch readTasksStopWatch = registerEndTime(\"readTasks\");\n-\n-        String[] potentialOwners = {\"user0\", \"user1\", \"user2\", \"user3\", \"user4\", \"user5\"};\n-        int publishWindowSize = 2;\n-\n-        Map<String, List<PlanningItem>> userIdToPlanningItems = new HashMap<>();\n-        List<PlanningItem> userPlanningItems;\n-\n-        int userIndex = -1;\n-        String userId;\n-        int i = 0;\n-        for (TaskData taskData : taskList) {\n-            userIndex = (userIndex + 1) % potentialOwners.length;\n-            userId = potentialOwners[userIndex];\n-            userPlanningItems = userIdToPlanningItems.computeIfAbsent(userId, s -> new ArrayList<>());\n-\n-            PlanningItem planningItem = PlanningItem.builder()\n-                    .taskId(taskData.getTaskId())\n-                    .processInstanceId(taskData.getProcessInstanceId())\n-                    .containerId(taskData.getContainerId())\n-                    .planningTask(PlanningTask.builder()\n-                                          .taskId(taskData.getTaskId())\n-                                          .assignedUser(userId)\n-                                          .index(userPlanningItems.size())\n-                                          .published(userPlanningItems.size() < publishWindowSize)\n-                                          .build())\n-                    .build();\n-            if (i++ < 10000) {\n-                userPlanningItems.add(planningItem);\n-            }\n-        }\n-        List<PlanningItem> planningItems = userIdToPlanningItems.values().stream()\n-                .flatMap(Collection::stream)\n-                .collect(Collectors.toList());\n-        registerStartTime(\"executePlanning\");\n-        client.executePlanning(new PlanningItemList(planningItems), \"wbadmin\");\n-        StopWatch executePlanningStopWatch = registerEndTime(\"executePlanning\");\n-\n-        System.out.println(taskList.size() + \" tasks were read with the TaskDataReader and a pageSize: \" + pageSize + \" in: \" + printTime(readTasksStopWatch));\n-        System.out.println(\"Planning with \" + planningItems.size() + \" items and \" + potentialOwners.length + \" assigned users items was executed in: \" + printTime(executePlanningStopWatch));\n-    }\n-\n-    @Test\n-    public void testExecutePlanningFailure() {\n-        List<PlanningItem> planningItems = new ArrayList<>();\n-        planningItems.add(PlanningItem.builder().taskId((long) 1)\n-                                  .containerId(CONTAINER_ID)\n-                                  .processInstanceId((long) 1)\n-                                  .planningTask(PlanningTask.builder()\n-                                                        .assignedUser(\"rollback\")\n-                                                        .taskId((long) 1)\n-                                                        .index(3333)\n-                                                        .published(false)\n-                                                        .build()).build());\n-        PlanningItemList planningItemList = new PlanningItemList();\n-        planningItemList.setPlanningItems(planningItems.toArray(new PlanningItem[0]));\n-        client.executePlanning(planningItemList, \"wbadmin\");\n-    }\n-\n-    private KieServicesClient newKieServicesClient() {\n-        return TaskAssigningRuntimeClientFactory.createKieServicesClient(SERVER_URL,\n-                                                                         \"wbadmin\",\n-                                                                         \"wbadmin\");\n-    }\n-\n-    private TaskAssigningRuntimeClient newTaskAssigningRuntimeClient() {\n-        KieServicesClient servicesClient = TaskAssigningRuntimeClientFactory.createKieServicesClient(SERVER_URL,\n-                                                                                                     \"wbadmin\",\n-                                                                                                     \"wbadmin\");\n-        return servicesClient.getServicesClient(TaskAssigningRuntimeClient.class);\n-    }\n-\n-    private void registerStartTime(String timeId) {\n-        StopWatch stopWatch = new StopWatch();\n-        stopWatch.start();\n-        timeRegistry.put(timeId, stopWatch);\n-    }\n-\n-    private StopWatch registerEndTime(String timeId) {\n-        StopWatch stopWatch = timeRegistry.get(timeId);\n-        stopWatch.stop();\n-        return stopWatch;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzY2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369577668", "bodyText": "As a part of API, would be good to put there javadoc explaining what individual values mean.", "author": "rsynek", "createdAt": "2020-01-22T14:06:15Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public enum TaskInputVariablesReadMode {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MDg5NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382090895", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T15:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzY2OA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java b/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java\nindex 487368235..f3e569570 100644\n--- a/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java\n+++ b/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java\n\n@@ -17,7 +17,17 @@\n package org.kie.server.api.model.taskassigning;\n \n public enum TaskInputVariablesReadMode {\n+    /**\n+     * Don't load the task variables.\n+     */\n     DONT_READ,\n+    /**\n+     * Load the task variables for all the returned tasks.\n+     */\n     READ_FOR_ALL,\n-    READ_WHEN_PLANNING_TASK_IS_NULL\n+    /**\n+     * Optimization, read the task variables only for the tasks that aren't in a sink status and hasn't an associated planning task.\n+     * This option is intended for internal use.\n+     */\n+    READ_FOR_ACTIVE_TASKS_WITH_NO_PLANNING_ENTITY\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MjM0Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369582347", "bodyText": "Thinking aloud: if we wrap the kie server client, does it make sense to make the timeout configurable?", "author": "rsynek", "createdAt": "2020-01-22T14:14:34Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+    }\n+\n+    static KieServicesClient createKieServicesClient(final String endpoint,\n+                                                     final String login,\n+                                                     final String password) {\n+\n+        final KieServicesConfiguration configuration = KieServicesFactory.newRestConfiguration(endpoint, login, password);\n+        configuration.setTimeout(90000);", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MTEyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382091120", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T15:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MjM0Nw=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\nindex 2b12b814b..7d8291e5b 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java\n\n@@ -25,13 +25,17 @@ import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n \n import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+import static org.kie.server.api.KieServerConstants.CFG_BYPASS_AUTH_USER;\n \n public class TaskAssigningRuntimeClientFactory {\n \n     static {\n         // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n         // of other users\n-        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+        System.setProperty(CFG_BYPASS_AUTH_USER, Boolean.TRUE.toString());\n+    }\n+\n+    private TaskAssigningRuntimeClientFactory() {\n     }\n \n     static KieServicesClient createKieServicesClient(final String endpoint,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MDUzOQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369590539", "bodyText": "The method is rather complex and sonarcloud complains about cognitive complexity going over a threshold too [1].\nThere are no tests for this method and with its complicated logic it will be very difficult to write them.\n[1] https://sonarcloud.io/component_measures?id=org.drools%3Adroolsjbpm-integration&metric=new_coverage&pullRequest=1986&selected=org.drools%3Adroolsjbpm-integration%3Ajbpm-task-assigning%2Fkie-server-client-task-assigning%2Fsrc%2Fmain%2Fjava%2Forg%2Fkie%2Fserver%2Fclient%2Futil%2FTaskDataReader.java&view=treemap", "author": "rsynek", "createdAt": "2020-01-22T14:27:46Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.util;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+public class TaskDataReader {\n+\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    private TaskDataReader(TaskAssigningRuntimeClient runtimeClient) {\n+        this.runtimeClient = runtimeClient;\n+    }\n+\n+    public static class Result {\n+\n+        LocalDateTime queryTime;\n+\n+        List<TaskData> tasks;\n+\n+        private Result(LocalDateTime queryTime, List<TaskData> tasks) {\n+            this.queryTime = queryTime;\n+            this.tasks = tasks;\n+        }\n+\n+        public LocalDateTime getQueryTime() {\n+            return queryTime;\n+        }\n+\n+        public List<TaskData> getTasks() {\n+            return tasks;\n+        }\n+    }\n+\n+    public static TaskDataReader from(TaskAssigningRuntimeClient runtimeClient) {\n+        return new TaskDataReader(runtimeClient);\n+    }\n+\n+    public Result readTasks(long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA5MTQ3Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382091472", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T15:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MDUzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java\nindex 026855e71..c3bc21c4a 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java\n\n@@ -25,6 +25,10 @@ import org.kie.server.api.model.taskassigning.TaskDataList;\n import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n import org.kie.server.client.TaskAssigningRuntimeClient;\n \n+/**\n+ * Helper class for reading all the elements returned by the {@link TaskAssigningRuntimeClient#findTasks} methods.\n+ * This class manages the required pagination for getting all the results.\n+ */\n public class TaskDataReader {\n \n     private TaskAssigningRuntimeClient runtimeClient;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMzQ4MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369613480", "bodyText": "If there is no need to re-throw the InterruptedException, let's set the interrupted flag via Thread.interrupt().\nSee e.g. https://dzone.com/articles/understanding-thread-interruption-in-java", "author": "rsynek", "createdAt": "2020-01-22T15:04:52Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDE4NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369980184", "bodyText": "I'll restore the interrupted status as suggested by zonar, but I believe the flag by zonar is a \"false positive\".\nThis is what the code is doing.\n    while (isAlive()) {\n           //do something\n        } catch (InterruptedException e) {\n         //so here the code sets it self in super.destory() that will cause the \n         //the thread to have a graceful and controlled die. The interruption is  thus not hiden,\n         // and imediatelly when the whild(isAlive()) condition is checked the result is \n         // false. No risks to enter in a neverending loop ingnoring the interrupted status.\n\n            super.destroy();\n            \n            LOGGER.error(\"Solution Processor was interrupted\", e);\n        }\n    }", "author": "wmedvede", "createdAt": "2020-01-23T08:21:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMzQ4MA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\nindex 977eb67a0..2d88736a8 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\n\n@@ -16,25 +16,21 @@\n \n package org.kie.server.services.taskassigning.planning;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.concurrent.Semaphore;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n \n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.core.model.User;\n import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n-import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTED;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTING;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STOPPED;\n+import static org.kie.server.services.taskassigning.planning.TraceHelper.tracePublishedTasks;\n+import static org.kie.server.services.taskassigning.planning.TraceHelper.traceSolution;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNDgxMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369614813", "bodyText": "Every call to LOGGER.trace will print a new trace message - with a new timestamp. I suspect we should rather format the entire solution string first and then just print it once.", "author": "rsynek", "createdAt": "2020-01-22T15:07:03Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                LOGGER.error(\"Solution Processor was interrupted\", e);\n+            }\n+        }\n+        LOGGER.debug(\"Solution Processor finished\");\n+    }\n+\n+    private void doProcess(final TaskAssigningSolution solution) {\n+        LOGGER.debug(\"Starting processing of solution: \" + solution);\n+        final List<PlanningItem> planningItems = new ArrayList<>(solution.getTaskList().size());\n+        List<PlanningItem> userPlanningItems;\n+        Iterator<PlanningItem> userPlanningItemsIt;\n+        PlanningItem planningItem;\n+        int index;\n+        int publishedCount;\n+        for (User user : solution.getUserList()) {\n+            userPlanningItems = new ArrayList<>();\n+            index = 0;\n+            publishedCount = 0;\n+            Task nextTask = user.getNextTask();\n+\n+            while (nextTask != null) {\n+                if (IS_NOT_DUMMY.test(nextTask)) {\n+                    //dummy tasks has nothing to with the jBPM runtime, don't process them\n+                    planningItem = PlanningItem.builder()\n+                            .containerId(nextTask.getContainerId())\n+                            .taskId(nextTask.getId())\n+                            .processInstanceId(nextTask.getProcessInstanceId())\n+                            .planningTask(PlanningTask.builder()\n+                                                  .taskId(nextTask.getId())\n+                                                  .published(nextTask.isPinned())\n+                                                  .assignedUser(user.getUser().getEntityId())\n+                                                  .index(index++)\n+                                                  .build())\n+                            .build();\n+\n+                    userPlanningItems.add(planningItem);\n+                    publishedCount += planningItem.getPlanningTask().isPublished() ? 1 : 0;\n+                }\n+                nextTask = nextTask.getNextTask();\n+            }\n+            if (!IS_PLANNING_USER.test(user.getEntityId())) {\n+                userPlanningItemsIt = userPlanningItems.iterator();\n+                while (userPlanningItemsIt.hasNext() && publishedCount < publishWindowSize) {\n+                    planningItem = userPlanningItemsIt.next();\n+                    if (!planningItem.getPlanningTask().isPublished()) {\n+                        planningItem.getPlanningTask().setPublished(true);\n+                        publishedCount++;\n+                    }\n+                }\n+            }\n+            planningItems.addAll(userPlanningItems);\n+        }\n+\n+        final List<PlanningItem> publishedTasks = planningItems.stream().filter(item -> item.getPlanningTask().isPublished()).collect(Collectors.toList());\n+\n+        if (LOGGER.isTraceEnabled()) {\n+            traceSolution(solution);\n+            tracePublishedTasks(publishedTasks);\n+        }\n+\n+        Result result;\n+        try {\n+            ExecutePlanningResult executeResult = delegate.executePlanning(publishedTasks, targetUserId);\n+            result = new Result(executeResult);\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during solution processing, planning execution failed.\", e);\n+            result = new Result(e);\n+        }\n+\n+        LOGGER.debug(\"Solution processing finished: \" + solution);\n+        processing.set(false);\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void traceSolution(TaskAssigningSolution solution) {\n+        LOGGER.trace(\"\\n\");", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\nindex 977eb67a0..2d88736a8 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\n\n@@ -16,25 +16,21 @@\n \n package org.kie.server.services.taskassigning.planning;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.concurrent.Semaphore;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n \n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.core.model.User;\n import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n-import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTED;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTING;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STOPPED;\n+import static org.kie.server.services.taskassigning.planning.TraceHelper.tracePublishedTasks;\n+import static org.kie.server.services.taskassigning.planning.TraceHelper.traceSolution;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNDk1NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369614954", "bodyText": "ditto", "author": "rsynek", "createdAt": "2020-01-22T15:07:16Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                LOGGER.error(\"Solution Processor was interrupted\", e);\n+            }\n+        }\n+        LOGGER.debug(\"Solution Processor finished\");\n+    }\n+\n+    private void doProcess(final TaskAssigningSolution solution) {\n+        LOGGER.debug(\"Starting processing of solution: \" + solution);\n+        final List<PlanningItem> planningItems = new ArrayList<>(solution.getTaskList().size());\n+        List<PlanningItem> userPlanningItems;\n+        Iterator<PlanningItem> userPlanningItemsIt;\n+        PlanningItem planningItem;\n+        int index;\n+        int publishedCount;\n+        for (User user : solution.getUserList()) {\n+            userPlanningItems = new ArrayList<>();\n+            index = 0;\n+            publishedCount = 0;\n+            Task nextTask = user.getNextTask();\n+\n+            while (nextTask != null) {\n+                if (IS_NOT_DUMMY.test(nextTask)) {\n+                    //dummy tasks has nothing to with the jBPM runtime, don't process them\n+                    planningItem = PlanningItem.builder()\n+                            .containerId(nextTask.getContainerId())\n+                            .taskId(nextTask.getId())\n+                            .processInstanceId(nextTask.getProcessInstanceId())\n+                            .planningTask(PlanningTask.builder()\n+                                                  .taskId(nextTask.getId())\n+                                                  .published(nextTask.isPinned())\n+                                                  .assignedUser(user.getUser().getEntityId())\n+                                                  .index(index++)\n+                                                  .build())\n+                            .build();\n+\n+                    userPlanningItems.add(planningItem);\n+                    publishedCount += planningItem.getPlanningTask().isPublished() ? 1 : 0;\n+                }\n+                nextTask = nextTask.getNextTask();\n+            }\n+            if (!IS_PLANNING_USER.test(user.getEntityId())) {\n+                userPlanningItemsIt = userPlanningItems.iterator();\n+                while (userPlanningItemsIt.hasNext() && publishedCount < publishWindowSize) {\n+                    planningItem = userPlanningItemsIt.next();\n+                    if (!planningItem.getPlanningTask().isPublished()) {\n+                        planningItem.getPlanningTask().setPublished(true);\n+                        publishedCount++;\n+                    }\n+                }\n+            }\n+            planningItems.addAll(userPlanningItems);\n+        }\n+\n+        final List<PlanningItem> publishedTasks = planningItems.stream().filter(item -> item.getPlanningTask().isPublished()).collect(Collectors.toList());\n+\n+        if (LOGGER.isTraceEnabled()) {\n+            traceSolution(solution);\n+            tracePublishedTasks(publishedTasks);\n+        }\n+\n+        Result result;\n+        try {\n+            ExecutePlanningResult executeResult = delegate.executePlanning(publishedTasks, targetUserId);\n+            result = new Result(executeResult);\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during solution processing, planning execution failed.\", e);\n+            result = new Result(e);\n+        }\n+\n+        LOGGER.debug(\"Solution processing finished: \" + solution);\n+        processing.set(false);\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void traceSolution(TaskAssigningSolution solution) {\n+        LOGGER.trace(\"\\n\");\n+        LOGGER.trace(\"*** Start of solution trace, with users = {} and tasks = {} ***\", solution.getUserList().size(), solution.getTaskList().size());\n+        for (User user : solution.getUserList()) {\n+            Task nextTask = user.getNextTask();\n+            while (nextTask != null) {\n+                LOGGER.trace(user.getEntityId() + \" -> \" + nextTask.getId() + \", pinned: \" + nextTask.isPinned() + \" priority: \" + nextTask.getPriority() + \", status: \" + nextTask.getStatus());\n+                nextTask = nextTask.getNextTask();\n+            }\n+        }\n+        LOGGER.trace(\"*** End of solution trace ***\");\n+        LOGGER.trace(\"\\n\");\n+    }\n+\n+    private void tracePublishedTasks(List<PlanningItem> publishedTasks) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\nindex 977eb67a0..2d88736a8 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java\n\n@@ -16,25 +16,21 @@\n \n package org.kie.server.services.taskassigning.planning;\n \n-import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import java.util.concurrent.Semaphore;\n-import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.Consumer;\n-import java.util.stream.Collectors;\n \n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.core.model.User;\n import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n-import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTED;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STARTING;\n+import static org.kie.server.services.taskassigning.planning.RunnableBase.Status.STOPPED;\n+import static org.kie.server.services.taskassigning.planning.TraceHelper.tracePublishedTasks;\n+import static org.kie.server.services.taskassigning.planning.TraceHelper.traceSolution;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369622744", "bodyText": "It's more readable to invert the logic, so that you just:\nif (true.equals(...)) { return; } and the rest of the method keeps the original level of indentation.", "author": "rsynek", "createdAt": "2020-01-22T15:19:54Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java", "diffHunk": "@@ -787,6 +790,37 @@ protected EntityManagerFactory build(Map<String, String> properties) {\n         }\n     }\n \n+    private void checkAndAddTaskAssigningEntities(PersistenceUnitInfo info) {\n+        if (\"false\".equals(System.getProperty(KIE_TASK_ASSIGNING_RUNTIME_EXT_DISABLED))) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDEwMTg2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370101868", "bodyText": "Inverting the condition would make it more complex because you'd have to return if the property was \"true\" or unset.\nThe way it's written now means the task assigning extension is disabled by default and must be enabled explicitly (that's probably wanted). Wouldn't be more natural to enable it like this:\n-Dorg.kie.server.taskAssigning.runtime.ext.enabled=true\n\nrather than\n-Dorg.kie.server.taskAssigning.runtime.ext.disabled=false\n\nThe double negative is a bit difficult to understand. It makes better sense to me to use a *.disabled property to disable an extension that is enabled by default and, conversely, use a *.enabled property to enable an extension that is disabled by default.\nAlso I'd suggest to use Boolean.parseBoolean() consistently because it's used on other places to parse properties. Boolean.parseBoolean() is case insensitive and so while *.disabled=FALSE might work for other properties elsewhere, it wouldn't work here, which would be surprising.", "author": "yurloc", "createdAt": "2020-01-23T12:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUzNDkzNw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r379534937", "bodyText": "The standard mechanism for enabling disabling extensions is\norg.kie.server.XXX.XXX.ext.disabled so I'd prefer to keep it to this extension too. Otherwise it's not straight ahead to understand how to enable/disable a particular extension.\nSo I basically vote for keeping the standard nomeclature\norg.kie.server.taskAssigning.runtime.ext.disabled\nAnd finally with the code\n\"false\".equals(System.getProperty(KIE_TASK_ASSIGNING_RUNTIME_EXT_DISABLED)\nSince this is not let's say a standard extension, I want be sure to enable it exactly when the user typed the word \"false\".\nOtherwise if we do Boolean.parse(\"truee\") we could enable the extension just because of type mistake.", "author": "wmedvede", "createdAt": "2020-02-14T16:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEwMzI0Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380103242", "bodyText": "OK, I understand your reasons for using the disabled=false form to activate the extension and agree with your approach.", "author": "yurloc", "createdAt": "2020-02-17T10:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java b/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java\nindex 3aba3d847..97466db31 100644\n--- a/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java\n+++ b/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java\n\n@@ -815,7 +815,7 @@ public class JbpmKieServerExtension implements KieServerExtension {\n                     }\n                     logger.debug(\"Task assigning entities where successfully added.\");\n                 } else {\n-                    logger.error(\"Unexpected error, it was not possible to get resource for: \" + classResource);\n+                    logger.error(\"Unexpected error, it was not possible to get resource for: {}\", classResource);\n                 }\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369631960", "bodyText": "What is the purpose of this method? Is it required to register task planning JPA entities into the PersistenceContext to make them writeable into database together with jBPM classes?\nIn other words, does it serve the purpose of saving the task assignment at a safe point in a jBPM process?", "author": "rsynek", "createdAt": "2020-01-22T15:34:26Z", "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java", "diffHunk": "@@ -787,6 +790,37 @@ protected EntityManagerFactory build(Map<String, String> properties) {\n         }\n     }\n \n+    private void checkAndAddTaskAssigningEntities(PersistenceUnitInfo info) {", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2OTY0MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369969641", "bodyText": "yes, tasks assigning incorporates one entity that we need to have in the same persistence unit as the jBPM ones. But I don't want to add it to the core jBPM entities to not add this such specific stuff there. So basically this entity is incorporated only on servers that has the tasks assigning enabled.", "author": "wmedvede", "createdAt": "2020-01-23T07:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA1MzA5MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370053090", "bodyText": "Would you please point me to a piece of code which effectively saves the planning model in DB?\nI doubt we should leak the task assignment implementation classes into jBPM KIE extension like here.", "author": "rsynek", "createdAt": "2020-01-23T10:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUwNzc5Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370507796", "bodyText": "sure, see here\n\n  \n    \n      droolsjbpm-integration/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/main/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceBase.java\n    \n    \n         Line 389\n      in\n      842cdd7\n    \n    \n    \n    \n\n        \n          \n           persistenceContext.merge(new PlanningTaskImpl(planningItem.getTaskId(),", "author": "wmedvede", "createdAt": "2020-01-24T07:55:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzM5MTE5OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r373391198", "bodyText": "Thanks, let's talk about it in today's meeting - I don't think we should couple the persistence of jBPM and task assignment so closely.", "author": "rsynek", "createdAt": "2020-01-31T09:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA=="}], "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java b/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java\nindex 3aba3d847..97466db31 100644\n--- a/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java\n+++ b/kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java\n\n@@ -815,7 +815,7 @@ public class JbpmKieServerExtension implements KieServerExtension {\n                     }\n                     logger.debug(\"Task assigning entities where successfully added.\");\n                 } else {\n-                    logger.error(\"Unexpected error, it was not possible to get resource for: \" + classResource);\n+                    logger.error(\"Unexpected error, it was not possible to get resource for: {}\", classResource);\n                 }\n             }\n         }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzNjE3Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370036173", "bodyText": "Should be upper case and maybe an enum.", "author": "yurloc", "createdAt": "2020-01-23T10:22:30Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/TaskStatus.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class TaskStatus {\n+\n+    public static final String Created = \"Created\";", "originalCommit": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/TaskStatus.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/TaskStatus.java\ndeleted file mode 100644\nindex 4858f9651..000000000\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/TaskStatus.java\n+++ /dev/null\n\n@@ -1,31 +0,0 @@\n-/*\n- * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.api.model.taskassigning;\n-\n-public class TaskStatus {\n-\n-    public static final String Created = \"Created\";\n-    public static final String Ready = \"Ready\";\n-    public static final String Reserved = \"Reserved\";\n-    public static final String InProgress = \"InProgress\";\n-    public static final String Suspended = \"Suspended\";\n-    public static final String Completed = \"Completed\";\n-    public static final String Failed = \"Failed\";\n-    public static final String Error = \"Error\";\n-    public static final String Exited = \"Exited\";\n-    public static final String Obsolete = \"Obsolete\";\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0NjAxMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370746012", "bodyText": "This is where we typically throw an exception - that's defensive programming. If, in the future, you add another value and forget to change it here, that's how you'll find out.", "author": "triceo", "createdAt": "2020-01-24T17:14:36Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java", "diffHunk": "@@ -127,6 +131,10 @@ public TaskAssigningSolution build() {\n                             addTaskToUser(assignedTasksByUserId, task, taskData.getActualOwner(), -1, pinned);\n                         }\n                     }\n+                    break;\n+                default:\n+                    //no other cases exists, sonar required.\n+                    break;", "originalCommit": "a31167c12ed4a67d20c60824cb8bef850b79d499", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java\nindex 3e32c6eda..6b4351c68 100644\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java\n+++ b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java\n\n@@ -122,19 +98,19 @@ public class SolutionBuilder {\n                         tasks.add(task);\n                         final PlanningTask planningTask = taskData.getPlanningTask();\n                         if (planningTask != null && taskData.getActualOwner().equals(planningTask.getAssignedUser())) {\n-                            boolean pinned = InProgress.equals(taskData.getStatus()) || Suspended.equals(taskData.getStatus()) ||\n+                            boolean pinned = InProgress == status || Suspended == status ||\n                                     planningTask.getPublished() || !usersById.containsKey(taskData.getActualOwner());\n                             addTaskToUser(assignedTasksByUserId, task, planningTask.getAssignedUser(), planningTask.getIndex(), pinned);\n                         } else {\n-                            boolean pinned = (Reserved.equals(taskData.getStatus()) && !IS_PLANNING_USER.test(taskData.getActualOwner())) ||\n-                                    InProgress.equals(taskData.getStatus()) || Suspended.equals(taskData.getStatus());\n+                            boolean pinned = (Reserved == status && !IS_PLANNING_USER.test(taskData.getActualOwner())) ||\n+                                    InProgress == status || Suspended == status;\n                             addTaskToUser(assignedTasksByUserId, task, taskData.getActualOwner(), -1, pinned);\n                         }\n                     }\n                     break;\n                 default:\n                     //no other cases exists, sonar required.\n-                    break;\n+                    throw new IndexOutOfBoundsException(\"Value: \" + taskData.getStatus() + \" is out of range in current switch\");\n             }\n         });\n \n"}}, {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II", "committedDate": "2020-02-14T17:57:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0ODk2OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380048968", "bodyText": "typo", "author": "rsynek", "createdAt": "2020-02-17T08:51:06Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/util/TaskUtil.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning.util;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.services.taskassigning.core.model.Group;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TypedLabel;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.isUser;\n+\n+public class TaskUtil {\n+\n+    private TaskUtil() {\n+    }\n+\n+    public static Task fromTaskData(TaskData taskData) {\n+        final Task task = new Task(taskData.getTaskId(),\n+                                   taskData.getProcessInstanceId(),\n+                                   taskData.getProcessId(),\n+                                   taskData.getContainerId(),\n+                                   taskData.getName(),\n+                                   taskData.getPriority(),\n+                                   taskData.getStatus(),\n+                                   taskData.getInputData());\n+        if (taskData.getPotentialOwners() != null) {\n+            taskData.getPotentialOwners().forEach(potentialOwner -> {\n+                if (isUser(potentialOwner.getType())) {\n+                    task.getPotentialOwners().add(new User(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n+                } else {\n+                    task.getPotentialOwners().add(new Group(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n+                }\n+            });\n+        }\n+        //TODO expermiental for the demo", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/util/TaskUtil.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/util/TaskUtil.java\ndeleted file mode 100644\nindex 001b1f981..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/util/TaskUtil.java\n+++ /dev/null\n\n@@ -1,59 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.planning.util;\n-\n-import org.kie.server.api.model.taskassigning.TaskData;\n-import org.kie.server.services.taskassigning.core.model.Group;\n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TypedLabel;\n-import org.kie.server.services.taskassigning.core.model.User;\n-\n-import static org.kie.server.services.taskassigning.planning.util.UserUtil.isUser;\n-\n-public class TaskUtil {\n-\n-    private TaskUtil() {\n-    }\n-\n-    public static Task fromTaskData(TaskData taskData) {\n-        final Task task = new Task(taskData.getTaskId(),\n-                                   taskData.getProcessInstanceId(),\n-                                   taskData.getProcessId(),\n-                                   taskData.getContainerId(),\n-                                   taskData.getName(),\n-                                   taskData.getPriority(),\n-                                   taskData.getStatus(),\n-                                   taskData.getInputData());\n-        if (taskData.getPotentialOwners() != null) {\n-            taskData.getPotentialOwners().forEach(potentialOwner -> {\n-                if (isUser(potentialOwner.getType())) {\n-                    task.getPotentialOwners().add(new User(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n-                } else {\n-                    task.getPotentialOwners().add(new Group(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n-                }\n-            });\n-        }\n-        //TODO expermiental for the demo\n-        if (taskData.getInputData() != null) {\n-            Object skill = taskData.getInputData().get(\"skills\");\n-            if (skill != null) {\n-                task.getTypedLabels().add(TypedLabel.newSkill(skill.toString()));\n-            }\n-        }\n-        return task;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0OTg1NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380049855", "bodyText": "This is a candidate for a parametrized test:\nhttps://github.com/junit-team/junit4/wiki/Parameterized-tests", "author": "rsynek", "createdAt": "2020-02-17T08:53:02Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/PlanningBuilderTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.initializeUser;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.mockUser;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n+\n+public class PlanningBuilderTest {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MTc2MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382261761", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:15:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0OTg1NQ=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/PlanningBuilderTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/PlanningBuilderTest.java\ndeleted file mode 100644\nindex 26959cfc5..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/PlanningBuilderTest.java\n+++ /dev/null\n\n@@ -1,219 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.planning;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import org.junit.Test;\n-import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.core.model.User;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.fail;\n-import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n-import static org.kie.server.services.taskassigning.planning.TestUtil.initializeUser;\n-import static org.kie.server.services.taskassigning.planning.TestUtil.mockUser;\n-import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n-\n-public class PlanningBuilderTest {\n-\n-    private static final int USER1_TOTAL_TASKS = 5;\n-    private static final int USER1_PINNED_TASKS = 3;\n-\n-    private static final int USER2_TOTAL_TASKS = 5;\n-    private static final int USER2_PINNED_TASKS = 2;\n-\n-    private static final int USER3_TOTAL_TASKS = 5;\n-    private static final int USER3_PINNED_TASKS = 1;\n-\n-    private static final int USER4_TOTAL_TASKS = 10;\n-    private static final int USER4_PINNED_TASKS = 0;\n-\n-    private static final int USER5_TOTAL_TASKS = 10;\n-    private static final int USER5_PINNED_TASKS = 0;\n-\n-    private static final int USER6_TOTAL_TASKS = 0;\n-    private static final int USER6_PINNED_TASKS = 0;\n-\n-    private static final int PLANNING_USER_TASKS = 6;\n-\n-    private long ids = 0;\n-\n-    @Test\n-    public void buildForPublishWindowSize0() {\n-        build(0);\n-    }\n-\n-    @Test\n-    public void buildForPublishWindowSize1() {\n-        build(1);\n-    }\n-\n-    @Test\n-    public void buildForPublishWindowSize2() {\n-        build(2);\n-    }\n-\n-    @Test\n-    public void buildForPublishWindowSize3() {\n-        build(3);\n-    }\n-\n-    @Test\n-    public void buildForPublishWindowSize4() {\n-        build(4);\n-    }\n-\n-    @Test\n-    public void buildForPublishWindowSize5() {\n-        build(5);\n-    }\n-\n-    @Test\n-    public void buildForPublishWindowSize6() {\n-        build(6);\n-    }\n-\n-    private void build(int publishWindowSize) {\n-        List<Task> user1Tasks = mockTasks(USER1_TOTAL_TASKS, USER1_PINNED_TASKS, \"container1\", 1L);\n-        User user1 = mockUser(1, user1Tasks);\n-\n-        List<Task> user2Tasks = mockTasks(USER2_TOTAL_TASKS, USER2_PINNED_TASKS, \"container2\", 2L);\n-        User user2 = mockUser(2, user2Tasks);\n-\n-        List<Task> user3Tasks = mockTasks(USER3_TOTAL_TASKS, USER3_PINNED_TASKS, \"container3\", 3L);\n-        User user3 = mockUser(3, user3Tasks);\n-\n-        List<Task> user4Tasks = mockTasks(USER4_TOTAL_TASKS, USER4_PINNED_TASKS, \"container4\", 4L);\n-        User user4 = mockUser(4, user4Tasks);\n-\n-        List<Task> user5Tasks = mockTasks(USER5_TOTAL_TASKS, USER5_PINNED_TASKS, \"container5\", 5L);\n-        User user5 = mockUser(5, user5Tasks);\n-\n-        List<Task> user6Tasks = mockTasks(USER6_TOTAL_TASKS, USER6_PINNED_TASKS, \"container6\", 6L);\n-        User user6 = mockUser(6, user6Tasks);\n-\n-        List<Task> planningUserTasks = mockTasks(PLANNING_USER_TASKS, 0, \"container7\", 7L);\n-        User planningUser = initializeUser(new User(-1, PLANNING_USER_ID), planningUserTasks);\n-\n-        List<Task> totalTasks = new ArrayList<>();\n-        totalTasks.addAll(user1Tasks);\n-        totalTasks.addAll(user2Tasks);\n-        totalTasks.addAll(user3Tasks);\n-        totalTasks.addAll(user4Tasks);\n-        totalTasks.addAll(user5Tasks);\n-        totalTasks.addAll(user6Tasks);\n-        totalTasks.addAll(planningUserTasks);\n-\n-        List<User> totalUsers = Arrays.asList(user1, user2, user3, user4, user5, user6, planningUser);\n-\n-        TaskAssigningSolution solution = new TaskAssigningSolution(1, totalUsers, totalTasks);\n-\n-        List<PlanningItem> planningItems = PlanningBuilder.create()\n-                .withPublishWindowSize(publishWindowSize)\n-                .withSolution(solution)\n-                .build();\n-\n-        assertPlanningItems(user1, publishWindowSize, planningItems);\n-        assertPlanningItems(user2, publishWindowSize, planningItems);\n-        assertPlanningItems(user3, publishWindowSize, planningItems);\n-        assertPlanningItems(user4, publishWindowSize, planningItems);\n-        assertPlanningItems(user5, publishWindowSize, planningItems);\n-        assertPlanningItems(user6, publishWindowSize, planningItems);\n-        assertPlanningUserPlanningItems(planningUser, publishWindowSize, planningItems);\n-    }\n-\n-    private void assertPlanningItems(User user, int publishWindowSize, List<PlanningItem> planningItems) {\n-        List<Task> nonPinnedTasks = extractTasks(user, task -> !task.isPinned());\n-        List<Task> pinnedTasks = extractTasks(user, Task::isPinned);\n-\n-        List<PlanningItem> userPlanningItems = planningItems.stream()\n-                .filter(item -> user.getEntityId().equals(item.getPlanningTask().getAssignedUser()))\n-                .collect(Collectors.toList());\n-\n-        // 1) all the tasks that where pinned must necessary be present.\n-        assertTasksArePlanned(pinnedTasks, userPlanningItems);\n-\n-        // 2) if the publishWindowsSize is greater that the pinnedTasks it must be completed with non pinned tasks.\n-        int publishWindowSizeFreeRoom = publishWindowSize - pinnedTasks.size();\n-        List<Task> additionalTasks = new ArrayList<>();\n-        for (int i = 0; publishWindowSizeFreeRoom > 0 && i < nonPinnedTasks.size(); i++) {\n-            publishWindowSizeFreeRoom--;\n-            additionalTasks.add(nonPinnedTasks.get(i));\n-        }\n-        assertTasksArePlanned(additionalTasks, userPlanningItems);\n-\n-        // 3) finally the total planningItems for the user must be exactly pinnedTasks.size() + additionalTasks.size();\n-        assertEquals(\"The total planningItems for user: \" + user.getId() + \" is not the expected value\",\n-                     userPlanningItems.size(), pinnedTasks.size() + additionalTasks.size());\n-    }\n-\n-    private void assertPlanningUserPlanningItems(User user, int publishWindowSize, List<PlanningItem> planningItems) {\n-        List<PlanningItem> userPlanningItems = planningItems.stream()\n-                .filter(item -> user.getEntityId().equals(item.getPlanningTask().getAssignedUser()))\n-                .collect(Collectors.toList());\n-        List<Task> tasks = extractTasks(user, (task) -> true);\n-        // all the tasks assigned to the planning user are published no matter the publishWidowSize.\n-        assertTasksArePlanned(tasks, userPlanningItems);\n-\n-        assertEquals(\"The total planningItems for user: \" + user.getId() + \" is not the expected value\",\n-                     userPlanningItems.size(), tasks.size());\n-    }\n-\n-    private void assertTasksArePlanned(List<Task> tasks, List<PlanningItem> planningItems) {\n-        for (Task task : tasks) {\n-            PlanningItem peerItem = planningItems.stream()\n-                    .filter(item -> item.getTaskId().equals(task.getId()))\n-                    .findFirst().orElse(null);\n-            if (peerItem == null) {\n-                fail(\"Task: \" + task.getId() + \" for user: \" + task.getUser().getId() + \" must be part of the generated planning\");\n-            }\n-            assertEquals(\"PlanningItem containerId for task: \" + task.getId() + \" and user: \" + task.getUser().getId() + \" don't have the expected value.\",\n-                         task.getContainerId(), peerItem.getContainerId());\n-            assertEquals(\"PlanningItem processInstanceId for task: \" + task.getId() + \" and user: \" + task.getUser().getId() + \" don't have the expected value.\",\n-                         task.getProcessInstanceId(), task.getProcessInstanceId());\n-            assertEquals(\"PlanningItem assignedUser for task: \" + task.getId() + \" and user: \" + task.getUser().getId() + \" don't have the expected value.\",\n-                         task.getUser().getEntityId(), peerItem.getPlanningTask().getAssignedUser());\n-        }\n-    }\n-\n-    private List<Task> mockTasks(int totalTasks, int totalPinnedTasks, String containerId, long processInstanceId) {\n-        List<Task> tasks = new ArrayList<>();\n-        int pinnedTasks = 0;\n-        for (int i = 0; i < totalTasks; i++) {\n-            tasks.add(mockTask(nextId(), pinnedTasks++ < totalPinnedTasks, containerId, processInstanceId));\n-        }\n-        return tasks;\n-    }\n-\n-    private Task mockTask(long taskId, boolean pinned, String containerId, long processInstanceId) {\n-        Task result = new Task(taskId, \"Task_\" + taskId, 0);\n-        result.setContainerId(containerId);\n-        result.setProcessInstanceId(processInstanceId);\n-        result.setPinned(pinned);\n-        return result;\n-    }\n-\n-    private long nextId() {\n-        return ids++;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTgyMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380055820", "bodyText": "Is this delay really needed? Could the mock just do nothing?", "author": "rsynek", "createdAt": "2020-02-17T09:04:54Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionProcessorTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class SolutionProcessorTest extends RunnableBaseTest<SolutionProcessor> {\n+\n+    private static final String TARGET_USER_ID = \"TARGET_USER_ID\";\n+    private static final int PUBLISH_WINDOW_SIZE = 2;\n+\n+    private TaskAssigningRuntimeDelegate delegate;\n+\n+    @Mock\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    @Mock\n+    private Consumer<SolutionProcessor.Result> resultConsumer;\n+\n+    @Mock\n+    private ExecutePlanningResult result;\n+\n+    @Captor\n+    private ArgumentCaptor<SolutionProcessor.Result> resultCaptor;\n+\n+    @Mock\n+    private List<PlanningItem> generatedPlan;\n+\n+    @Override\n+    protected SolutionProcessor createRunnableBase() {\n+        delegate = spy(new TaskAssigningRuntimeDelegateMock(runtimeClient));\n+        SolutionProcessor processor = spy(new SolutionProcessor(delegate, resultConsumer, TARGET_USER_ID, PUBLISH_WINDOW_SIZE));\n+        doReturn(generatedPlan).when(processor).buildPlanning(any(), anyInt());\n+        return processor;\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void process() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+        runnableBase.process(solution);\n+        assertTrue(runnableBase.isProcessing());\n+\n+        // wait while the processing is occurring.\n+        while (runnableBase.isProcessing()) {\n+            Thread.sleep(100);\n+        }\n+\n+        verify(delegate).executePlanning(generatedPlan, TARGET_USER_ID);\n+        verify(resultConsumer).accept(resultCaptor.capture());\n+        assertEquals(result, resultCaptor.getValue().getExecuteResult());\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void processWithFailure() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+        runnableBase.process(solution);\n+        Assertions.assertThatThrownBy(() -> runnableBase.process(solution))\n+                .hasMessage(\"SolutionProcessor process method can only be invoked when the status is STOPPED\");\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void processWithDelegateError() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+\n+        RuntimeException generatedError = new RuntimeException(\"Emulate a service invocation error.\");\n+        when(delegate.executePlanning(generatedPlan, TARGET_USER_ID)).thenThrow(generatedError);\n+\n+        runnableBase.process(solution);\n+\n+        // wait while the processing is occurring.\n+        while (runnableBase.isProcessing()) {\n+            Thread.sleep(100);\n+        }\n+\n+        verify(resultConsumer).accept(resultCaptor.capture());\n+        assertTrue(resultCaptor.getValue().hasException());\n+        assertEquals(generatedError, resultCaptor.getValue().getException());\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    private class TaskAssigningRuntimeDelegateMock extends TaskAssigningRuntimeDelegate {\n+\n+        public TaskAssigningRuntimeDelegateMock(TaskAssigningRuntimeClient runtimeClient) {\n+            super(runtimeClient);\n+        }\n+\n+        @Override\n+        public ExecutePlanningResult executePlanning(List<PlanningItem> planningItems, String userId) {\n+            try {\n+                // emulate some time to finish\n+                Thread.sleep(500);", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MjI5OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382262298", "bodyText": "done, moved to CountDownLatch", "author": "wmedvede", "createdAt": "2020-02-20T21:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTgyMA=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionProcessorTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionProcessorTest.java\ndeleted file mode 100644\nindex 128e314b1..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionProcessorTest.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.planning;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.function.Consumer;\n-\n-import org.assertj.core.api.Assertions;\n-import org.junit.Test;\n-import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n-import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.client.TaskAssigningRuntimeClient;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Captor;\n-import org.mockito.Mock;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.anyInt;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-public class SolutionProcessorTest extends RunnableBaseTest<SolutionProcessor> {\n-\n-    private static final String TARGET_USER_ID = \"TARGET_USER_ID\";\n-    private static final int PUBLISH_WINDOW_SIZE = 2;\n-\n-    private TaskAssigningRuntimeDelegate delegate;\n-\n-    @Mock\n-    private TaskAssigningRuntimeClient runtimeClient;\n-\n-    @Mock\n-    private Consumer<SolutionProcessor.Result> resultConsumer;\n-\n-    @Mock\n-    private ExecutePlanningResult result;\n-\n-    @Captor\n-    private ArgumentCaptor<SolutionProcessor.Result> resultCaptor;\n-\n-    @Mock\n-    private List<PlanningItem> generatedPlan;\n-\n-    @Override\n-    protected SolutionProcessor createRunnableBase() {\n-        delegate = spy(new TaskAssigningRuntimeDelegateMock(runtimeClient));\n-        SolutionProcessor processor = spy(new SolutionProcessor(delegate, resultConsumer, TARGET_USER_ID, PUBLISH_WINDOW_SIZE));\n-        doReturn(generatedPlan).when(processor).buildPlanning(any(), anyInt());\n-        return processor;\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    public void process() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n-        runnableBase.process(solution);\n-        assertTrue(runnableBase.isProcessing());\n-\n-        // wait while the processing is occurring.\n-        while (runnableBase.isProcessing()) {\n-            Thread.sleep(100);\n-        }\n-\n-        verify(delegate).executePlanning(generatedPlan, TARGET_USER_ID);\n-        verify(resultConsumer).accept(resultCaptor.capture());\n-        assertEquals(result, resultCaptor.getValue().getExecuteResult());\n-\n-        runnableBase.destroy();\n-        assertTrue(runnableBase.isDestroyed());\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    public void processWithFailure() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n-        runnableBase.process(solution);\n-        Assertions.assertThatThrownBy(() -> runnableBase.process(solution))\n-                .hasMessage(\"SolutionProcessor process method can only be invoked when the status is STOPPED\");\n-\n-        runnableBase.destroy();\n-        assertTrue(runnableBase.isDestroyed());\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    public void processWithDelegateError() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n-\n-        RuntimeException generatedError = new RuntimeException(\"Emulate a service invocation error.\");\n-        when(delegate.executePlanning(generatedPlan, TARGET_USER_ID)).thenThrow(generatedError);\n-\n-        runnableBase.process(solution);\n-\n-        // wait while the processing is occurring.\n-        while (runnableBase.isProcessing()) {\n-            Thread.sleep(100);\n-        }\n-\n-        verify(resultConsumer).accept(resultCaptor.capture());\n-        assertTrue(resultCaptor.getValue().hasException());\n-        assertEquals(generatedError, resultCaptor.getValue().getException());\n-\n-        runnableBase.destroy();\n-        assertTrue(runnableBase.isDestroyed());\n-        future.get();\n-    }\n-\n-    private class TaskAssigningRuntimeDelegateMock extends TaskAssigningRuntimeDelegate {\n-\n-        public TaskAssigningRuntimeDelegateMock(TaskAssigningRuntimeClient runtimeClient) {\n-            super(runtimeClient);\n-        }\n-\n-        @Override\n-        public ExecutePlanningResult executePlanning(List<PlanningItem> planningItems, String userId) {\n-            try {\n-                // emulate some time to finish\n-                Thread.sleep(500);\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                LOGGER.debug(e.getMessage());\n-            }\n-            return result;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NzcwNg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380057706", "bodyText": "Once the test is active, this Thread.sleep possibly becomes a cause of instability.", "author": "rsynek", "createdAt": "2020-02-17T09:08:59Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverExecutorTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.optaplanner.core.api.score.Score;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.event.BestSolutionChangedEvent;\n+import org.optaplanner.core.api.solver.event.SolverEventListener;\n+import org.optaplanner.core.impl.score.director.ScoreDirectorFactory;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+public class SolverExecutorTest extends RunnableBaseTest<SolverExecutor> {\n+\n+    @Mock\n+    private SolverDef solverDef;\n+\n+    @Mock\n+    private KieServerRegistry registry;\n+\n+    private Solver<TaskAssigningSolution> solver;\n+\n+    @Mock\n+    private TaskAssigningSolution solution;\n+\n+    @Mock\n+    private SolverEventListener<TaskAssigningSolution> eventListener;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverEventListener<TaskAssigningSolution>> eventListenerCaptor;\n+\n+    @Mock\n+    private BestSolutionChangedEvent<TaskAssigningSolution> event;\n+\n+    @Override\n+    protected SolverExecutor createRunnableBase() {\n+        solver = spy(new SolverMock());\n+        return new SolverExecutorMock(solverDef, registry, eventListener);\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n+    @Ignore\n+    public void start() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        runnableBase.start(solution);\n+        // give some time for the start method to execute.\n+        Thread.sleep(1000);", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MzI5Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263296", "bodyText": "in product, e.g. kie-server there are currently an important quantity of tests doing Thread.sleep. In general I believe this shouldn't a problem if the code is done well.\nBut anyway, this was moved to CountDownLatch", "author": "wmedvede", "createdAt": "2020-02-20T21:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NzcwNg=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverExecutorTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverExecutorTest.java\ndeleted file mode 100644\nindex 0b27bf24f..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverExecutorTest.java\n+++ /dev/null\n\n@@ -1,300 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.planning;\n-\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Semaphore;\n-\n-import org.assertj.core.api.Assertions;\n-import org.junit.Ignore;\n-import org.junit.Test;\n-import org.kie.server.services.api.KieServerRegistry;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Captor;\n-import org.mockito.Mock;\n-import org.optaplanner.core.api.score.Score;\n-import org.optaplanner.core.api.solver.Solver;\n-import org.optaplanner.core.api.solver.event.BestSolutionChangedEvent;\n-import org.optaplanner.core.api.solver.event.SolverEventListener;\n-import org.optaplanner.core.impl.score.director.ScoreDirectorFactory;\n-import org.optaplanner.core.impl.solver.ProblemFactChange;\n-\n-import static org.junit.Assert.assertFalse;\n-import static org.junit.Assert.assertTrue;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.times;\n-import static org.mockito.Mockito.verify;\n-\n-public class SolverExecutorTest extends RunnableBaseTest<SolverExecutor> {\n-\n-    @Mock\n-    private SolverDef solverDef;\n-\n-    @Mock\n-    private KieServerRegistry registry;\n-\n-    private Solver<TaskAssigningSolution> solver;\n-\n-    @Mock\n-    private TaskAssigningSolution solution;\n-\n-    @Mock\n-    private SolverEventListener<TaskAssigningSolution> eventListener;\n-\n-    @Captor\n-    private ArgumentCaptor<SolverEventListener<TaskAssigningSolution>> eventListenerCaptor;\n-\n-    @Mock\n-    private BestSolutionChangedEvent<TaskAssigningSolution> event;\n-\n-    @Override\n-    protected SolverExecutor createRunnableBase() {\n-        solver = spy(new SolverMock());\n-        return new SolverExecutorMock(solverDef, registry, eventListener);\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n-    @Ignore\n-    public void start() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        runnableBase.start(solution);\n-        // give some time for the start method to execute.\n-        Thread.sleep(1000);\n-\n-        assertTrue(runnableBase.isStarted());\n-\n-        verify(solver).addEventListener(eventListenerCaptor.capture());\n-        eventListenerCaptor.getValue().bestSolutionChanged(event);\n-        verify(eventListener).bestSolutionChanged(event);\n-\n-        runnableBase.destroy();\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n-    @Ignore\n-    public void startWithFailure() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        runnableBase.start(solution);\n-        Assertions.assertThatThrownBy(() -> runnableBase.start(solution))\n-                .hasMessage(\"SolverExecutor start method can only be invoked when the status is STOPPED\");\n-\n-        runnableBase.destroy();\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n-    @Ignore\n-    public void startWithBuildFailure() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        RuntimeException error = new RuntimeException(\"An error was produced...!\");\n-        ((SolverExecutorMock) runnableBase).setBuildError(error);\n-        Assertions.assertThatThrownBy(() -> runnableBase.start(solution))\n-                .hasMessage(error.getMessage());\n-\n-        assertTrue(runnableBase.isStopped());\n-        runnableBase.destroy();\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n-    @Ignore\n-    public void stop() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        // give some time for the start method to execute.\n-        runnableBase.start(solution);\n-        Thread.sleep(1000);\n-        assertTrue(runnableBase.isStarted());\n-\n-        runnableBase.stop();\n-        assertFalse(runnableBase.isStopped());\n-        // give some time for the stop method to execute.\n-        Thread.sleep(1000);\n-        assertTrue(runnableBase.isStopped());\n-\n-        runnableBase.start(solution);\n-        // give some time for the start method to execute.\n-        Thread.sleep(1000);\n-        assertTrue(runnableBase.isStarted());\n-\n-        verify(solver, times(2)).addEventListener(eventListenerCaptor.capture());\n-        eventListenerCaptor.getAllValues().get(0).bestSolutionChanged(event);\n-        eventListenerCaptor.getAllValues().get(1).bestSolutionChanged(event);\n-        verify(eventListener, times(2)).bestSolutionChanged(event);\n-\n-        runnableBase.destroy();\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n-    @Ignore\n-    public void addProblemFactChanges() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        runnableBase.start(solution);\n-        // give some time for the start method to execute.\n-        Thread.sleep(1000);\n-        List<ProblemFactChange<TaskAssigningSolution>> changes = Collections.emptyList();\n-        runnableBase.addProblemFactChanges(changes);\n-        verify(solver).addProblemFactChanges(changes);\n-\n-        runnableBase.destroy();\n-        future.get();\n-    }\n-\n-    @Test(timeout = TEST_TIMEOUT)\n-    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n-    @Ignore\n-    public void addProblemFactChangesWithFailure() throws Exception {\n-        CompletableFuture future = startRunnableBase();\n-        List<ProblemFactChange<TaskAssigningSolution>> changes = Collections.emptyList();\n-\n-        Assertions.assertThatThrownBy(() -> runnableBase.addProblemFactChanges(changes))\n-                .hasMessage(\"SolverExecutor has not been started. Be sure it's started and not stopped or destroyed prior to executing this method\");\n-\n-        runnableBase.destroy();\n-        future.get();\n-    }\n-\n-    private class SolverExecutorMock extends SolverExecutor {\n-\n-        private RuntimeException buildError;\n-\n-        public SolverExecutorMock(SolverDef solverDef,\n-                                  KieServerRegistry registry,\n-                                  SolverEventListener<TaskAssigningSolution> eventListener) {\n-            super(solverDef, registry, eventListener);\n-        }\n-\n-        public void setBuildError(RuntimeException buildError) {\n-            this.buildError = buildError;\n-        }\n-\n-        @Override\n-        protected Solver<TaskAssigningSolution> buildSolver(SolverDef solverDef, KieServerRegistry registry) {\n-            if (buildError != null) {\n-                throw buildError;\n-            }\n-            return solver;\n-        }\n-    }\n-\n-    private class SolverMock implements Solver<TaskAssigningSolution> {\n-\n-        private final Semaphore finishSolverWork = new Semaphore(0);\n-        private CompletableFuture action;\n-\n-        @Override\n-        public TaskAssigningSolution solve(TaskAssigningSolution problem) {\n-            action = CompletableFuture.runAsync(() -> {\n-                try {\n-                    // emulate a solver working in demon mode.\n-                    finishSolverWork.acquire();\n-                    // emulate some time to finish\n-                    Thread.sleep(100);\n-                } catch (InterruptedException e) {\n-                    Thread.currentThread().interrupt();\n-                    LOGGER.debug(e.getMessage());\n-                }\n-            });\n-            try {\n-                action.get();\n-            } catch (ExecutionException e) {\n-                LOGGER.debug(e.getMessage());\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                LOGGER.debug(e.getMessage());\n-            }\n-            return null;\n-        }\n-\n-        @Override\n-        public boolean terminateEarly() {\n-            // emulate solver termination.\n-            finishSolverWork.release();\n-            return true;\n-        }\n-\n-        @Override\n-        public TaskAssigningSolution getBestSolution() {\n-            return null;\n-        }\n-\n-        @Override\n-        public Score getBestScore() {\n-            return null;\n-        }\n-\n-        @Override\n-        public String explainBestScore() {\n-            return null;\n-        }\n-\n-        @Override\n-        public long getTimeMillisSpent() {\n-            return 0;\n-        }\n-\n-        @Override\n-        public boolean isSolving() {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isTerminateEarly() {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean addProblemFactChange(ProblemFactChange<TaskAssigningSolution> problemFactChange) {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>> problemFactChanges) {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean isEveryProblemFactChangeProcessed() {\n-            return false;\n-        }\n-\n-        @Override\n-        public void addEventListener(SolverEventListener<TaskAssigningSolution> eventListener) {\n-\n-        }\n-\n-        @Override\n-        public void removeEventListener(SolverEventListener<TaskAssigningSolution> eventListener) {\n-\n-        }\n-\n-        @Override\n-        public ScoreDirectorFactory<TaskAssigningSolution> getScoreDirectorFactory() {\n-            return null;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2NjI4NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380066284", "bodyText": "I wonder if we could rather create some Task instances with these properties instead of creating tenths of the fields directly in the test and having methods with 8+ parameters.", "author": "rsynek", "createdAt": "2020-02-17T09:26:03Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/query/AbstractTaskAssigningDataQueryMapperTest.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.runtime.query;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.dashbuilder.dataset.DataColumn;\n+import org.dashbuilder.dataset.DataSet;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public abstract class AbstractTaskAssigningDataQueryMapperTest<T extends AbstractTaskAssigningQueryMapper<?>> {\n+\n+    /**\n+     * Task1 has planning task and potential owners.\n+     */\n+    static final Long TASK1_ID = 1L;", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/query/AbstractTaskAssigningDataQueryMapperTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/query/AbstractTaskAssigningDataQueryMapperTest.java\ndeleted file mode 100644\nindex 0708f447c..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/query/AbstractTaskAssigningDataQueryMapperTest.java\n+++ /dev/null\n\n@@ -1,314 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.runtime.query;\n-\n-import java.time.LocalDateTime;\n-import java.time.ZoneId;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import org.apache.commons.lang3.tuple.Pair;\n-import org.dashbuilder.dataset.DataColumn;\n-import org.dashbuilder.dataset.DataSet;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n-\n-public abstract class AbstractTaskAssigningDataQueryMapperTest<T extends AbstractTaskAssigningQueryMapper<?>> {\n-\n-    /**\n-     * Task1 has planning task and potential owners.\n-     */\n-    static final Long TASK1_ID = 1L;\n-    static final Date TASK1_CREATED_ON = new Date();\n-    static final String TASK1_ACTUAL_OWNER = \"TASK1_ACTUAL_OWNER\";\n-    static final String TASK1_DEPLOYMENT_ID = \"TASK1_DEPLOYMENT_ID\";\n-    static final String TASK1_NAME = \"TASK1_NAME\";\n-    static final Integer TASK1_PRIORITY = 1;\n-    static final String TASK1_PROCESS_ID = \"TASK1_PROCESS_ID\";\n-    static final Long TASK1_PROCESS_INSTANCE_ID = 1L;\n-    static final String TASK1_STATUS = \"TASK1_STATUS\";\n-    static final Date TASK1_LAST_MODIFICATION_DATE = new Date();\n-    static final Long TASK1_PLANNING_TASK_ID = 1L;\n-    static final String TASK1_PLANNING_TASK_ASSIGNED_USER = \"TASK1_PLANNING_ASSIGNED_USER\";\n-    static final Boolean TASK1_PLANNING_TASK_PUBLISHED = true;\n-    static final Integer TASK1_PLANNING_TASK_INDEX = 1;\n-\n-    static final String TASK1_PO_1_ID = \"TASK1_PO_1_ID\";\n-    static final String TASK1_PO_1_TYPE = \"User\";\n-    static final String TASK1_PO_2_ID = \"TASK1_PO_2_ID\";\n-    static final String TASK1_PO_2_TYPE = \"Group\";\n-\n-    /**\n-     * Task2 has planning task and no potential owners.\n-     */\n-    static final Long TASK2_ID = 2L;\n-    static final Date TASK2_CREATED_ON = new Date();\n-    static final String TASK2_ACTUAL_OWNER = \"TASK2_ACTUAL_OWNER\";\n-    static final String TASK2_DEPLOYMENT_ID = \"TASK2_DEPLOYMENT_ID\";\n-    static final String TASK2_NAME = \"TASK2_NAME\";\n-    static final Integer TASK2_PRIORITY = 2;\n-    static final String TASK2_PROCESS_ID = \"TASK2_PROCESS_ID\";\n-    static final Long TASK2_PROCESS_INSTANCE_ID = 2L;\n-    static final String TASK2_STATUS = \"TASK2_STATUS\";\n-    static final Date TASK2_LAST_MODIFICATION_DATE = new Date();\n-    static final Long TASK2_PLANNING_TASK_ID = 2L;\n-    static final String TASK2_PLANNING_TASK_ASSIGNED_USER = \"TASK2_PLANNING_ASSIGNED_USER\";\n-    static final Boolean TASK2_PLANNING_TASK_PUBLISHED = false;\n-    static final Integer TASK2_PLANNING_TASK_INDEX = 2;\n-\n-    /**\n-     * Task3 has potential owners and no planning task.\n-     */\n-    static final Long TASK3_ID = 3L;\n-    static final Date TASK3_CREATED_ON = new Date();\n-    static final String TASK3_ACTUAL_OWNER = \"TASK3_ACTUAL_OWNER\";\n-    static final String TASK3_DEPLOYMENT_ID = \"TASK3_DEPLOYMENT_ID\";\n-    static final String TASK3_NAME = \"TASK3_NAME\";\n-    static final Integer TASK3_PRIORITY = 3;\n-    static final String TASK3_PROCESS_ID = \"TASK3_PROCESS_ID\";\n-    static final Long TASK3_PROCESS_INSTANCE_ID = 3L;\n-    static final String TASK3_STATUS = \"TASK3_STATUS\";\n-    static final Date TASK3_LAST_MODIFICATION_DATE = new Date();\n-\n-    static final String TASK3_PO_1_ID = \"TASK3_PO_1_ID\";\n-    static final String TASK3_PO_1_TYPE = \"User\";\n-    static final String TASK3_PO_2_ID = \"TASK3_PO_2_ID\";\n-    static final String TASK3_PO_2_TYPE = \"Group\";\n-\n-    T queryMapper;\n-\n-    @Before\n-    public void setUp() {\n-        queryMapper = createQueryMapper();\n-    }\n-\n-    protected abstract T createQueryMapper();\n-\n-    protected abstract void verifyResult(List<?> result);\n-\n-    protected abstract String getExpectedName();\n-\n-    @Test\n-    public void map() {\n-        List<List<Object>> rawValues = createTestValues();\n-        DataSet dataSet = mockDataSet(rawValues);\n-        List<?> result = queryMapper.map(dataSet);\n-        verifyResult(result);\n-    }\n-\n-    @Test\n-    public void getName() {\n-        assertEquals(getExpectedName(), queryMapper.getName());\n-    }\n-\n-    @Test\n-    public void toLocalDateTimeNull() {\n-        assertNull(null, TaskAssigningTaskDataQueryMapper.toLocalDateTime(null));\n-    }\n-\n-    @Test\n-    public void toLocalDateTimeFromDate() {\n-        Date date = new Date();\n-        LocalDateTime expectedValue = LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());\n-        assertEquals(expectedValue, TaskAssigningTaskDataQueryMapper.toLocalDateTime(date));\n-    }\n-\n-    @Test\n-    public void toLocalDateTimeFromLocalDateTime() {\n-        LocalDateTime value = LocalDateTime.now();\n-        assertEquals(value, TaskAssigningTaskDataQueryMapper.toLocalDateTime(value));\n-    }\n-\n-    protected List<List<Object>> createTestValues() {\n-        PlanningTask task1PlanningTask = PlanningTask.builder()\n-                .taskId(TASK1_PLANNING_TASK_ID)\n-                .assignedUser(TASK1_PLANNING_TASK_ASSIGNED_USER)\n-                .index(TASK1_PLANNING_TASK_INDEX)\n-                .published(TASK1_PLANNING_TASK_PUBLISHED)\n-                .build();\n-        List<Pair<String, String>> task1PotentialOwners = Arrays.asList(Pair.of(TASK1_PO_1_ID, TASK1_PO_1_TYPE),\n-                                                                        Pair.of(TASK1_PO_2_ID, TASK1_PO_2_TYPE));\n-\n-        List<List<Object>> task1RawValues = mockRawValues(TASK1_ID,\n-                                                          TASK1_CREATED_ON,\n-                                                          TASK1_ACTUAL_OWNER,\n-                                                          TASK1_DEPLOYMENT_ID,\n-                                                          TASK1_NAME,\n-                                                          TASK1_PRIORITY,\n-                                                          TASK1_PROCESS_ID,\n-                                                          TASK1_PROCESS_INSTANCE_ID,\n-                                                          TASK1_STATUS,\n-                                                          TASK1_LAST_MODIFICATION_DATE,\n-                                                          task1PlanningTask,\n-                                                          task1PotentialOwners);\n-\n-        PlanningTask task2PlanningTask = PlanningTask.builder()\n-                .taskId(TASK2_PLANNING_TASK_ID)\n-                .assignedUser(TASK2_PLANNING_TASK_ASSIGNED_USER)\n-                .index(TASK2_PLANNING_TASK_INDEX)\n-                .published(TASK2_PLANNING_TASK_PUBLISHED)\n-                .build();\n-\n-        List<List<Object>> task2RawValues = mockRawValues(TASK2_ID,\n-                                                          TASK2_CREATED_ON,\n-                                                          TASK2_ACTUAL_OWNER,\n-                                                          TASK2_DEPLOYMENT_ID,\n-                                                          TASK2_NAME,\n-                                                          TASK2_PRIORITY,\n-                                                          TASK2_PROCESS_ID,\n-                                                          TASK2_PROCESS_INSTANCE_ID,\n-                                                          TASK2_STATUS,\n-                                                          TASK2_LAST_MODIFICATION_DATE,\n-                                                          task2PlanningTask,\n-                                                          Collections.emptyList());\n-\n-        List<Pair<String, String>> task3PotentialOwners = Arrays.asList(Pair.of(TASK3_PO_1_ID, TASK3_PO_1_TYPE),\n-                                                                        Pair.of(TASK3_PO_2_ID, TASK3_PO_2_TYPE));\n-\n-        List<List<Object>> task3RawValues = mockRawValues(TASK3_ID,\n-                                                          TASK3_CREATED_ON,\n-                                                          TASK3_ACTUAL_OWNER,\n-                                                          TASK3_DEPLOYMENT_ID,\n-                                                          TASK3_NAME,\n-                                                          TASK3_PRIORITY,\n-                                                          TASK3_PROCESS_ID,\n-                                                          TASK3_PROCESS_INSTANCE_ID,\n-                                                          TASK3_STATUS,\n-                                                          TASK3_LAST_MODIFICATION_DATE,\n-                                                          null,\n-                                                          task3PotentialOwners);\n-\n-        List<List<Object>> rawValues = new ArrayList<>();\n-        rawValues.addAll(task1RawValues);\n-        rawValues.addAll(task2RawValues);\n-        rawValues.addAll(task3RawValues);\n-        return rawValues;\n-    }\n-\n-    protected List<List<Object>> mockRawValues(Long taskId, Date createdOn, String actualOwner, String deploymentId, String taskName,\n-                                               Integer priority, String processId, Long processInstanceId, String status, Date lastModificationDate,\n-                                               PlanningTask planningTask,\n-                                               List<Pair<String, String>> potentialOwners) {\n-        List<List<Object>> result = new ArrayList<>();\n-\n-        if (!potentialOwners.isEmpty()) {\n-            potentialOwners.forEach(potentialOwner -> {\n-                result.add(mockRawValues(taskId, createdOn, actualOwner, deploymentId, taskName, priority, processId, processInstanceId,\n-                                         status, lastModificationDate, planningTask, potentialOwner.getLeft(), potentialOwner.getRight()));\n-            });\n-        } else {\n-            result.add(mockRawValues(taskId, createdOn, actualOwner, deploymentId, taskName, priority, processId, processInstanceId,\n-                                     status, lastModificationDate, planningTask, null, null));\n-        }\n-        return result;\n-    }\n-\n-    protected List<Object> mockRawValues(Long taskId, Date createdOn, String actualOwner, String deploymentId, String taskName,\n-                                         Integer priority, String processId, Long processInstanceId, String status, Date lastModificationDate,\n-                                         PlanningTask planningTask, String potentialOwnerId, String potentialOwnerType) {\n-\n-        return mockRawValues(taskId, createdOn, actualOwner, deploymentId, taskName, priority, processId, processInstanceId,\n-                             status, lastModificationDate,\n-                             planningTask != null ? planningTask.getTaskId() : null,\n-                             planningTask != null ? planningTask.getAssignedUser() : null,\n-                             planningTask != null ? planningTask.getIndex() : null,\n-                             planningTask != null ? toInteger(planningTask.getPublished()) : null,\n-                             potentialOwnerId,\n-                             potentialOwnerType);\n-    }\n-\n-    protected List<Object> mockRawValues(Long taskId, Date createdOn, String actualOwner, String deploymentId, String taskName,\n-                                         Integer priority, String processId, Long processInstanceId, String status, Date lastModificationDate,\n-                                         Long planningTaskId, String planningTaskAssignedUser, Integer planningTaskIndex, Integer planningTaskPublished,\n-                                         String potentialOwnerId, String potentialOwnerType) {\n-        List<Object> row = new ArrayList<>();\n-        row.add(taskId);\n-        row.add(createdOn);\n-        row.add(actualOwner);\n-        row.add(deploymentId);\n-        row.add(taskName);\n-        row.add(priority);\n-        row.add(processId);\n-        row.add(processInstanceId);\n-        row.add(status);\n-        row.add(lastModificationDate);\n-        row.add(planningTaskId);\n-        row.add(planningTaskAssignedUser);\n-        row.add(planningTaskIndex);\n-        row.add(planningTaskPublished);\n-        row.add(potentialOwnerId);\n-        row.add(potentialOwnerType);\n-        return row;\n-    }\n-\n-    protected Integer toInteger(Boolean value) {\n-        return value != null && value ? 1 : 0;\n-    }\n-\n-    protected DataSet mockDataSet(List<List<Object>> dbRows) {\n-\n-        DataSet dataSet = mock(DataSet.class);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.TASK_ID.columnName(), dbRows, 0);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.CREATED_ON.columnName(), dbRows, 1);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.ACTUAL_OWNER.columnName(), dbRows, 2);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.DEPLOYMENT_ID.columnName(), dbRows, 3);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.TASK_NAME.columnName(), dbRows, 4);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PRIORITY.columnName(), dbRows, 5);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PROCESS_ID.columnName(), dbRows, 6);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PROCESS_INSTANCE_ID.columnName(), dbRows, 7);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.STATUS.columnName(), dbRows, 8);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.LAST_MODIFICATION_DATE.columnName(), dbRows, 9);\n-\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PLANNING_TASK_TASK_ID.columnName(), dbRows, 10);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PLANNING_TASK_ASSIGNED_USER.columnName(), dbRows, 11);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PLANNING_TASK_INDEX.columnName(), dbRows, 12);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.PLANNING_TASK_PUBLISHED.columnName(), dbRows, 13);\n-\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.POTENTIAL_OWNER_ID.columnName(), dbRows, 14);\n-        addColumn(dataSet, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.POTENTIAL_OWNER_TYPE.columnName(), dbRows, 15);\n-\n-        when(dataSet.getRowCount()).thenReturn(dbRows.size());\n-        return dataSet;\n-    }\n-\n-    protected void addColumn(DataSet dataSetMock, String columnId, List<List<Object>> dbRows, int columnIndex) {\n-        DataColumn dataColumn = mockColumn(columnId, dbRows, columnIndex);\n-        when(dataSetMock.getColumnById(columnId)).thenReturn(dataColumn);\n-    }\n-\n-    protected DataColumn mockColumn(String columnId, List<List<Object>> dbRows, int columnIndex) {\n-        DataColumn column = mock(DataColumn.class);\n-        when(column.getId()).thenReturn(columnId);\n-        List<Object> columnValues = buildColumnValues(dbRows, columnIndex);\n-        when(column.getValues()).thenReturn(columnValues);\n-        return column;\n-    }\n-\n-    protected List<Object> buildColumnValues(List<List<Object>> dbRows, int column) {\n-        return dbRows.stream().map(row -> row.get(column)).collect(Collectors.toList());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NTc4Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380085783", "bodyText": "Does the test call this mock 3 times that it returns 3 different answers?", "author": "rsynek", "createdAt": "2020-02-17T10:01:26Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceQueryHelperTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.runtime;\n+\n+import java.sql.Date;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.UserTaskService;\n+import org.jbpm.services.api.query.QueryService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.Status;\n+import org.kie.server.api.model.KieContainerStatus;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.kie.server.services.taskassigning.runtime.query.AbstractTaskAssigningQueryMapper;\n+import org.kie.server.services.taskassigning.runtime.query.TaskAssigningTaskDataQueryMapper;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TO_TASK_ID;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class TaskAssigningRuntimeServiceQueryHelperTest {\n+\n+    private static final String GREATER_OR_EQUALS_TO = \"GREATER_OR_EQUALS_TO\";\n+    private static final String LOWER_OR_EQUALS_TO = \"LOWER_OR_EQUALS_TO\";\n+    private static final String EQUALS_TO = \"EQUALS_TO\";\n+\n+    private static final String FROM_LAST_MODIFICATION_STR_VALUE = \"2020-02-11T16:07:34.332\";\n+    private static final LocalDateTime FROM_LAST_MODIFICATION_VALUE = LocalDateTime.parse(FROM_LAST_MODIFICATION_STR_VALUE);\n+    private static final List<String> STATUS_VALUE = Arrays.asList(\"Ready\", \"Reserved\");\n+\n+    private static final Long FROM_TASK_ID_VALUE = 1L;\n+    private static final Long TO_TASK_ID_VALUE = 2L;\n+    private static final Integer PAGE_VALUE = 3;\n+    private static final Integer PAGE_SIZE_VALUE = 4;\n+\n+    //  Task1 is Ready and has PlanningTask\n+    private static final Long TASK1_ID = 1L;\n+    // Task2 is Reserved and doesn't have PlanningTask\n+    private static final Long TASK2_ID = 2L;\n+    // Task3 is Completed\n+    private static final Long TASK3_ID = 3L;\n+\n+    private static final Map<String, Object> TASK1_INPUTS = new HashMap<>();\n+    private static final Map<String, Object> TASK2_INPUTS = new HashMap<>();\n+    private static final Map<String, Object> TASK3_INPUTS = new HashMap<>();\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+\n+    @Mock\n+    private KieServerRegistry registry;\n+\n+    @Mock\n+    private QueryService queryService;\n+\n+    @Mock\n+    private UserTaskService userTaskService;\n+\n+    private TaskAssigningRuntimeServiceQueryHelper helper;\n+\n+    @Captor\n+    private ArgumentCaptor<QueryParam[]> paramsCaptor;\n+\n+    @Captor\n+    private ArgumentCaptor<QueryContext> contextCaptor;\n+\n+    @Before\n+    public void setUp() {\n+        this.helper = spy(new TaskAssigningRuntimeServiceQueryHelper(registry, userTaskService, queryService));\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadNoInputs() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.DONT_READ);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // no inputs were loaded\n+        assertNull(result.get(0).getInputData());\n+        assertNull(result.get(1).getInputData());\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadNoInputsByDefault() {\n+        Map<String, Object> params = prepareQuery(null);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // no inputs were loaded\n+        assertNull(result.get(0).getInputData());\n+        assertNull(result.get(1).getInputData());\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadInputsForAll() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ALL);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // all the inputs were loaded\n+        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n+        assertEquals(TASK2_INPUTS, result.get(1).getInputData());\n+        assertEquals(TASK3_INPUTS, result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadInputsForActiveTasks() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ACTIVE_TASKS_WITH_NO_PLANNING_ENTITY);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // task1 is Ready and has PlanningTask\n+        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n+        // task2 is Reserved but hasn't PlanningTask\n+        assertNull(result.get(1).getInputData());\n+        // task3 is not active.\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void readTaskDataSummary() {\n+        List<TaskData> invocation0 = mockTasks();\n+        List<TaskData> invocation1 = Arrays.asList(mockTaskData(4L), mockTaskData(5L));\n+        List<TaskData> invocation2 = Collections.singletonList(mockTaskData(6L));\n+        doAnswer(new Answer() {\n+            private int invocations = 0;\n+\n+            public Object answer(InvocationOnMock invocation) {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwNTk5MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382105990", "bodyText": "yes, it basically emulates the consumption of all the tasks but in a paged basis", "author": "wmedvede", "createdAt": "2020-02-20T16:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NTc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceQueryHelperTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceQueryHelperTest.java\ndeleted file mode 100644\nindex 3f60ee246..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceQueryHelperTest.java\n+++ /dev/null\n\n@@ -1,289 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.runtime;\n-\n-import java.sql.Date;\n-import java.time.LocalDateTime;\n-import java.time.ZoneId;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import org.jbpm.services.api.UserTaskService;\n-import org.jbpm.services.api.query.QueryService;\n-import org.jbpm.services.api.query.model.QueryParam;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.kie.api.runtime.query.QueryContext;\n-import org.kie.api.task.model.Status;\n-import org.kie.server.api.model.KieContainerStatus;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n-import org.kie.server.api.model.taskassigning.TaskData;\n-import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n-import org.kie.server.services.api.KieServerRegistry;\n-import org.kie.server.services.impl.KieContainerInstanceImpl;\n-import org.kie.server.services.taskassigning.runtime.query.AbstractTaskAssigningQueryMapper;\n-import org.kie.server.services.taskassigning.runtime.query.TaskAssigningTaskDataQueryMapper;\n-import org.mockito.ArgumentCaptor;\n-import org.mockito.Captor;\n-import org.mockito.Mock;\n-import org.mockito.invocation.InvocationOnMock;\n-import org.mockito.runners.MockitoJUnitRunner;\n-import org.mockito.stubbing.Answer;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n-import static org.kie.server.api.model.taskassigning.QueryParamName.TO_TASK_ID;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.anyString;\n-import static org.mockito.Matchers.eq;\n-import static org.mockito.Mockito.doAnswer;\n-import static org.mockito.Mockito.doReturn;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.spy;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.when;\n-\n-@RunWith(MockitoJUnitRunner.class)\n-public class TaskAssigningRuntimeServiceQueryHelperTest {\n-\n-    private static final String GREATER_OR_EQUALS_TO = \"GREATER_OR_EQUALS_TO\";\n-    private static final String LOWER_OR_EQUALS_TO = \"LOWER_OR_EQUALS_TO\";\n-    private static final String EQUALS_TO = \"EQUALS_TO\";\n-\n-    private static final String FROM_LAST_MODIFICATION_STR_VALUE = \"2020-02-11T16:07:34.332\";\n-    private static final LocalDateTime FROM_LAST_MODIFICATION_VALUE = LocalDateTime.parse(FROM_LAST_MODIFICATION_STR_VALUE);\n-    private static final List<String> STATUS_VALUE = Arrays.asList(\"Ready\", \"Reserved\");\n-\n-    private static final Long FROM_TASK_ID_VALUE = 1L;\n-    private static final Long TO_TASK_ID_VALUE = 2L;\n-    private static final Integer PAGE_VALUE = 3;\n-    private static final Integer PAGE_SIZE_VALUE = 4;\n-\n-    //  Task1 is Ready and has PlanningTask\n-    private static final Long TASK1_ID = 1L;\n-    // Task2 is Reserved and doesn't have PlanningTask\n-    private static final Long TASK2_ID = 2L;\n-    // Task3 is Completed\n-    private static final Long TASK3_ID = 3L;\n-\n-    private static final Map<String, Object> TASK1_INPUTS = new HashMap<>();\n-    private static final Map<String, Object> TASK2_INPUTS = new HashMap<>();\n-    private static final Map<String, Object> TASK3_INPUTS = new HashMap<>();\n-\n-    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n-\n-    @Mock\n-    private KieServerRegistry registry;\n-\n-    @Mock\n-    private QueryService queryService;\n-\n-    @Mock\n-    private UserTaskService userTaskService;\n-\n-    private TaskAssigningRuntimeServiceQueryHelper helper;\n-\n-    @Captor\n-    private ArgumentCaptor<QueryParam[]> paramsCaptor;\n-\n-    @Captor\n-    private ArgumentCaptor<QueryContext> contextCaptor;\n-\n-    @Before\n-    public void setUp() {\n-        this.helper = spy(new TaskAssigningRuntimeServiceQueryHelper(registry, userTaskService, queryService));\n-    }\n-\n-    @Test\n-    public void executeFindTaskQueryReadNoInputs() {\n-        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.DONT_READ);\n-\n-        List<TaskData> result = helper.executeFindTasksQuery(params);\n-\n-        verifyQueryWasExecuted();\n-\n-        // no inputs were loaded\n-        assertNull(result.get(0).getInputData());\n-        assertNull(result.get(1).getInputData());\n-        assertNull(result.get(2).getInputData());\n-    }\n-\n-    @Test\n-    public void executeFindTaskQueryReadNoInputsByDefault() {\n-        Map<String, Object> params = prepareQuery(null);\n-\n-        List<TaskData> result = helper.executeFindTasksQuery(params);\n-\n-        verifyQueryWasExecuted();\n-\n-        // no inputs were loaded\n-        assertNull(result.get(0).getInputData());\n-        assertNull(result.get(1).getInputData());\n-        assertNull(result.get(2).getInputData());\n-    }\n-\n-    @Test\n-    public void executeFindTaskQueryReadInputsForAll() {\n-        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ALL);\n-\n-        List<TaskData> result = helper.executeFindTasksQuery(params);\n-\n-        verifyQueryWasExecuted();\n-\n-        // all the inputs were loaded\n-        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n-        assertEquals(TASK2_INPUTS, result.get(1).getInputData());\n-        assertEquals(TASK3_INPUTS, result.get(2).getInputData());\n-    }\n-\n-    @Test\n-    public void executeFindTaskQueryReadInputsForActiveTasks() {\n-        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ACTIVE_TASKS_WITH_NO_PLANNING_ENTITY);\n-\n-        List<TaskData> result = helper.executeFindTasksQuery(params);\n-\n-        verifyQueryWasExecuted();\n-\n-        // task1 is Ready and has PlanningTask\n-        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n-        // task2 is Reserved but hasn't PlanningTask\n-        assertNull(result.get(1).getInputData());\n-        // task3 is not active.\n-        assertNull(result.get(2).getInputData());\n-    }\n-\n-    @Test\n-    public void readTaskDataSummary() {\n-        List<TaskData> invocation0 = mockTasks();\n-        List<TaskData> invocation1 = Arrays.asList(mockTaskData(4L), mockTaskData(5L));\n-        List<TaskData> invocation2 = Collections.singletonList(mockTaskData(6L));\n-        doAnswer(new Answer() {\n-            private int invocations = 0;\n-\n-            public Object answer(InvocationOnMock invocation) {\n-                switch (invocations++) {\n-                    case 0:\n-                        return invocation0;\n-                    case 1:\n-                        return invocation1;\n-                    case 2:\n-                        return invocation2;\n-                    default:\n-                        return Collections.emptyList();\n-                }\n-            }\n-        }).when(helper).executeQuery(eq(queryService), anyString(), any(TaskAssigningTaskDataQueryMapper.class), any(), any());\n-        List<TaskData> result = helper.readTasksDataSummary(0, Collections.emptyList(), 10);\n-        assertEquals(TASK1_ID, result.get(0).getTaskId(), 0);\n-        assertEquals(TASK2_ID, result.get(1).getTaskId(), 0);\n-        assertEquals(TASK3_ID, result.get(2).getTaskId(), 0);\n-        assertEquals(4L, result.get(3).getTaskId(), 0);\n-        assertEquals(5L, result.get(4).getTaskId(), 0);\n-        assertEquals(6L, result.get(5).getTaskId(), 0);\n-    }\n-\n-    private Map<String, Object> prepareQuery(TaskInputVariablesReadMode readMode) {\n-        Map<String, Object> params = mockQueryParams(readMode);\n-        List<TaskData> taskDataList = mockTasks();\n-        doReturn(taskDataList).when(helper)\n-                .executeQuery(eq(queryService), anyString(), any(TaskAssigningTaskDataQueryMapper.class), any(), any());\n-        KieContainerInstanceImpl container = mock(KieContainerInstanceImpl.class);\n-        when(container.getStatus()).thenReturn(KieContainerStatus.STARTED);\n-        when(registry.getContainer(CONTAINER_ID)).thenReturn(container);\n-        return params;\n-    }\n-\n-    private void verifyQueryWasExecuted() {\n-        verify(helper).executeQuery(eq(queryService), anyString(), any(TaskAssigningTaskDataQueryMapper.class), contextCaptor.capture(), paramsCaptor.capture());\n-        QueryParam[] queryParams = paramsCaptor.getValue();\n-        assertContainsParam(queryParams, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.TASK_ID.columnName(), GREATER_OR_EQUALS_TO, FROM_TASK_ID_VALUE, 0);\n-        assertContainsParam(queryParams, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.TASK_ID.columnName(), LOWER_OR_EQUALS_TO, TO_TASK_ID_VALUE, 1);\n-        assertContainsParam(queryParams, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.LAST_MODIFICATION_DATE.columnName(), GREATER_OR_EQUALS_TO, Date.from(FROM_LAST_MODIFICATION_VALUE.atZone(ZoneId.systemDefault()).toInstant()), 2);\n-        assertContainsParam(queryParams, AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.STATUS.columnName(), EQUALS_TO, STATUS_VALUE, 3);\n-\n-        QueryContext context = contextCaptor.getValue();\n-        assertEquals(AbstractTaskAssigningQueryMapper.TASK_QUERY_COLUMN.TASK_ID.columnName(), context.getOrderBy());\n-        assertEquals(PAGE_SIZE_VALUE, context.getCount(), 0);\n-        assertEquals(PAGE_VALUE * PAGE_SIZE_VALUE, context.getOffset(), 0);\n-        assertTrue(context.isAscending());\n-    }\n-\n-    private void assertContainsParam(QueryParam[] params, String columnName, String operation, Object value, int index) {\n-        QueryParam param = params[index];\n-        assertEquals(columnName, param.getColumn());\n-    }\n-\n-    private List<TaskData> mockTasks() {\n-        TaskData task1 = mockTaskData(TASK1_ID, Status.Ready, false, CONTAINER_ID);\n-        TaskData task2 = mockTaskData(TASK2_ID, Status.Reserved, true, CONTAINER_ID);\n-        TaskData task3 = mockTaskData(TASK3_ID, Status.Completed, true, CONTAINER_ID);\n-\n-        TASK1_INPUTS.put(\"task1.param\", \"task1.param.value\");\n-        TASK2_INPUTS.put(\"task2.param\", \"task2.param.value\");\n-        TASK3_INPUTS.put(\"task3.param\", \"task3.param.value\");\n-\n-        when(userTaskService.getTaskInputContentByTaskId(any(), eq(TASK1_ID))).thenReturn(TASK1_INPUTS);\n-        when(userTaskService.getTaskInputContentByTaskId(any(), eq(TASK2_ID))).thenReturn(TASK2_INPUTS);\n-        when(userTaskService.getTaskInputContentByTaskId(any(), eq(TASK3_ID))).thenReturn(TASK3_INPUTS);\n-\n-        return Arrays.asList(task1, task2, task3);\n-    }\n-\n-    private Map<String, Object> mockQueryParams(TaskInputVariablesReadMode readMode) {\n-        Map<String, Object> params = new HashMap<>();\n-        params.put(FROM_TASK_ID, FROM_TASK_ID_VALUE);\n-        params.put(TO_TASK_ID, TO_TASK_ID_VALUE);\n-        params.put(FROM_LAST_MODIFICATION_DATE, FROM_LAST_MODIFICATION_VALUE);\n-        params.put(STATUS, STATUS_VALUE);\n-        params.put(PAGE, PAGE_VALUE);\n-        params.put(PAGE_SIZE, PAGE_SIZE_VALUE);\n-        if (readMode != null) {\n-            params.put(TASK_INPUT_VARIABLES_MODE, readMode.name());\n-        }\n-        return params;\n-    }\n-\n-    private TaskData mockTaskData(Long taskId) {\n-        return TaskData.builder().taskId(taskId).build();\n-    }\n-\n-    private TaskData mockTaskData(Long taskId, Status status, boolean hasPlanningTask, String containerId) {\n-        TaskData taskData = TaskData.builder()\n-                .taskId(taskId)\n-                .status(status.name())\n-                .containerId(containerId)\n-                .build();\n-        if (hasPlanningTask) {\n-            PlanningTask planningTask = PlanningTask.builder()\n-                    .taskId(taskId)\n-                    .build();\n-            taskData.setPlanningTask(planningTask);\n-        }\n-        return taskData;\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzc4MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380137781", "bodyText": "This should be rather a single trace message. In such a case, StringBuilder could be more suitable for preparing the message than the BREAK function.", "author": "rsynek", "createdAt": "2020-02-17T11:51:01Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TraceHelper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n+import org.kie.server.services.taskassigning.planning.util.IndexedElement;\n+import org.slf4j.Logger;\n+\n+public class TraceHelper {\n+\n+    private static final Function<String, String> BREAK = (s) -> System.lineSeparator() + s;\n+    private static final String TASK_WITH_NAME_FORMAT = \" -> ({}, {})\";\n+\n+    private TraceHelper() {\n+    }\n+\n+    static void traceProgrammedChanges(Logger logger, List<RemoveTaskProblemFactChange> removedTasksChanges,\n+                                       List<ReleaseTaskProblemFactChange> releasedTasksChanges,\n+                                       Map<String, List<IndexedElement<AssignTaskProblemFactChange>>> changesByUserId,\n+                                       List<TaskPropertyChangeProblemFactChange> propertyChanges,\n+                                       List<AddTaskProblemFactChange> newTaskChanges) {\n+\n+        logger.trace(BREAK.apply(\"*** Removed tasks ***\"));\n+        logger.trace(\"Total tasks removed from solution is {}\", removedTasksChanges.size());\n+        removedTasksChanges.forEach(change -> logger.trace(TASK_WITH_NAME_FORMAT, change.getTask().getId(), change.getTask().getName()));\n+        logger.trace(\"*** End of Removed tasks ***\");", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TraceHelper.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TraceHelper.java\ndeleted file mode 100644\nindex 3eaecd1c9..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TraceHelper.java\n+++ /dev/null\n\n@@ -1,125 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.planning;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Function;\n-\n-import org.kie.server.api.model.taskassigning.PlanningItem;\n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.core.model.User;\n-import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n-import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n-import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n-import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n-import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n-import org.kie.server.services.taskassigning.planning.util.IndexedElement;\n-import org.slf4j.Logger;\n-\n-public class TraceHelper {\n-\n-    private static final Function<String, String> BREAK = (s) -> System.lineSeparator() + s;\n-    private static final String TASK_WITH_NAME_FORMAT = \" -> ({}, {})\";\n-\n-    private TraceHelper() {\n-    }\n-\n-    static void traceProgrammedChanges(Logger logger, List<RemoveTaskProblemFactChange> removedTasksChanges,\n-                                       List<ReleaseTaskProblemFactChange> releasedTasksChanges,\n-                                       Map<String, List<IndexedElement<AssignTaskProblemFactChange>>> changesByUserId,\n-                                       List<TaskPropertyChangeProblemFactChange> propertyChanges,\n-                                       List<AddTaskProblemFactChange> newTaskChanges) {\n-\n-        logger.trace(BREAK.apply(\"*** Removed tasks ***\"));\n-        logger.trace(\"Total tasks removed from solution is {}\", removedTasksChanges.size());\n-        removedTasksChanges.forEach(change -> logger.trace(TASK_WITH_NAME_FORMAT, change.getTask().getId(), change.getTask().getName()));\n-        logger.trace(\"*** End of Removed tasks ***\");\n-\n-        logger.trace(BREAK.apply(\"*** Released tasks ***\"));\n-        logger.trace(\"Total tasks released from solution is {}\", releasedTasksChanges.size());\n-        releasedTasksChanges.forEach(change -> logger.trace(TASK_WITH_NAME_FORMAT, change.getTask().getId(), change.getTask().getName()));\n-        logger.trace(\"*** End of Released tasks ***\");\n-\n-        logger.trace(BREAK.apply(\"*** Changes per user ***\"));\n-        logger.trace(\"Total users with programmed changes is {}\", changesByUserId.size());\n-        changesByUserId.forEach((key, userChanges) -> {\n-            if (userChanges != null) {\n-                userChanges.forEach(change -> {\n-                    logger.trace(BREAK.apply(\"  AssignTaskToUserChanges for user: {}\"), key);\n-\n-                    logger.trace(BREAK.apply(\"   -> taskId: {}, pinned: {}, index: {}, status: {}\"),\n-                                 change.getElement().getTask().getId(),\n-                                 change.isPinned(),\n-                                 change.getIndex(),\n-                                 change.getElement().getTask().getStatus());\n-                    logger.trace(\"  End of AssignTaskToUserChanges for user: {}\", key);\n-                });\n-            }\n-        });\n-        logger.trace(\"*** End of Changes per user ***\");\n-\n-        logger.trace(BREAK.apply(\"*** Property changes ***\"));\n-        logger.trace(\"Total tasks with property changes is {}\", propertyChanges.size());\n-\n-        propertyChanges.forEach(change -> {\n-            String changeDesc = \"\";\n-            if (change.getPriority() != null) {\n-                changeDesc = \" setPriority = \" + change.getPriority();\n-            }\n-            if (change.getStatus() != null) {\n-                changeDesc = \" setStatus = \" + change.getStatus();\n-            }\n-            logger.trace(TASK_WITH_NAME_FORMAT + \" {}\", change.getTask().getId(), change.getTask().getName(), changeDesc);\n-        });\n-        logger.trace(\"*** End of Property changes ***\");\n-\n-        logger.trace(BREAK.apply(\"*** New tasks ***\"));\n-        logger.trace(\"Total new tasks added to solution is {}\", newTaskChanges.size());\n-        newTaskChanges.forEach(change -> logger.trace(TASK_WITH_NAME_FORMAT, change.getTask().getId(), change.getTask().getName()));\n-        logger.trace(\"*** End of New tasks ***\");\n-    }\n-\n-    static void traceSolution(Logger logger, TaskAssigningSolution solution) {\n-        logger.trace(BREAK.apply(\"*** Start of solution trace, with users = {} and tasks = {} ***\"), solution.getUserList().size(), solution.getTaskList().size());\n-        for (User user : solution.getUserList()) {\n-            Task nextTask = user.getNextTask();\n-            while (nextTask != null) {\n-                logger.trace(\"{} -> {}, pinned: {}, priority: {}, status: {}\",\n-                             user.getEntityId(),\n-                             nextTask.getId(),\n-                             nextTask.isPinned(),\n-                             nextTask.getPriority(),\n-                             nextTask.getStatus());\n-\n-                nextTask = nextTask.getNextTask();\n-            }\n-        }\n-        logger.trace(\"*** End of solution trace ***\");\n-    }\n-\n-    static void tracePublishedTasks(Logger logger, List<PlanningItem> publishedTasks) {\n-        logger.trace(BREAK.apply(\"*** Start of published tasks trace with {} published tasks ***\"), publishedTasks.size());\n-        publishedTasks.forEach(item -> logger.trace(\"{} -> {}, index: {}, published: {}\",\n-                                                    item.getPlanningTask().getAssignedUser(),\n-                                                    item.getTaskId(),\n-                                                    item.getPlanningTask().getIndex(),\n-                                                    item.getPlanningTask().isPublished()));\n-        logger.trace(\"*** End of published trace ***\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380141800", "bodyText": "There are no assertions; is the test supposed to only check that no exception is thrown?", "author": "rsynek", "createdAt": "2020-02-17T12:00:29Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/test/java/org/kie/server/services/taskassigning/user/system/simple/SimpleUserSystemServiceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.user.system.simple;\n+\n+import java.net.URL;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.services.taskassigning.user.system.api.Group;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_LOADING_ERROR;\n+import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_NOT_CONFIGURED_ERROR;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP1;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP2;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP3;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER1;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER2;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER3;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER4;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER5;\n+\n+public class SimpleUserSystemServiceTest {\n+\n+    private SimpleUserSystemService userSystem;\n+    private static final List<String> USERS = Arrays.asList(USER1, USER2, USER3, USER4, USER5);\n+    private static final List<String> GROUPS = Arrays.asList(GROUP1, GROUP2, GROUP3);\n+\n+    @Before\n+    public void setUp() {\n+        URL url = SimpleUserSystemServiceTest.class.getResource(WildflyUtilTest.USERS_FILE);\n+        String path = Paths.get(url.getPath()).toUri().toString();\n+        System.setProperty(SimpleUserSystemService.USERS_FILE, path);\n+        userSystem = new SimpleUserSystemService();\n+    }\n+\n+    @After\n+    public void cleanUp() {\n+        System.clearProperty(SimpleUserSystemService.USERS_FILE);\n+    }\n+\n+    @Test\n+    public void start() {\n+        userSystem.start();", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEwOTI3NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382109275", "bodyText": "yes, start() checks the non failing case anyway, renamed to startSuccess\nthen we have other startXXX for testing potential failing use cases.", "author": "wmedvede", "createdAt": "2020-02-20T16:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2MzY2MQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263661", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:19:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/test/java/org/kie/server/services/taskassigning/user/system/simple/SimpleUserSystemServiceTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/test/java/org/kie/server/services/taskassigning/user/system/simple/SimpleUserSystemServiceTest.java\ndeleted file mode 100644\nindex 6d73b894e..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/test/java/org/kie/server/services/taskassigning/user/system/simple/SimpleUserSystemServiceTest.java\n+++ /dev/null\n\n@@ -1,128 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.user.system.simple;\n-\n-import java.net.URL;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import org.assertj.core.api.Assertions;\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.kie.server.services.taskassigning.user.system.api.Group;\n-import org.kie.server.services.taskassigning.user.system.api.User;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertTrue;\n-import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_LOADING_ERROR;\n-import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_NOT_CONFIGURED_ERROR;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP1;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP2;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP3;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER1;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER2;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER3;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER4;\n-import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER5;\n-\n-public class SimpleUserSystemServiceTest {\n-\n-    private SimpleUserSystemService userSystem;\n-    private static final List<String> USERS = Arrays.asList(USER1, USER2, USER3, USER4, USER5);\n-    private static final List<String> GROUPS = Arrays.asList(GROUP1, GROUP2, GROUP3);\n-\n-    @Before\n-    public void setUp() {\n-        URL url = SimpleUserSystemServiceTest.class.getResource(WildflyUtilTest.USERS_FILE);\n-        String path = Paths.get(url.getPath()).toUri().toString();\n-        System.setProperty(SimpleUserSystemService.USERS_FILE, path);\n-        userSystem = new SimpleUserSystemService();\n-    }\n-\n-    @After\n-    public void cleanUp() {\n-        System.clearProperty(SimpleUserSystemService.USERS_FILE);\n-    }\n-\n-    @Test\n-    public void start() {\n-        userSystem.start();\n-    }\n-\n-    @Test\n-    public void startWithFileNotConfiguredError() {\n-        System.clearProperty(SimpleUserSystemService.USERS_FILE);\n-        String expectedMessage = String.format(USERS_FILE_NOT_CONFIGURED_ERROR, SimpleUserSystemService.USERS_FILE);\n-        Assertions.assertThatThrownBy(() -> userSystem.start())\n-                .hasMessage(expectedMessage);\n-    }\n-\n-    @Test\n-    public void startWithFileLoadingError() {\n-        String nonExistingPath = \"a_path_that_dont_exists\";\n-        System.setProperty(SimpleUserSystemService.USERS_FILE, nonExistingPath);\n-        String expectedMessage = String.format(USERS_FILE_LOADING_ERROR, nonExistingPath);\n-        Assertions.assertThatThrownBy(() -> userSystem.start())\n-                .hasMessage(expectedMessage);\n-    }\n-\n-    @Test\n-    public void getName() {\n-        assertEquals(SimpleUserSystemService.NAME, userSystem.getName());\n-    }\n-\n-    @Test\n-    public void test() {\n-        userSystem.test();\n-    }\n-\n-    @Test\n-    public void findUser() {\n-        userSystem.start();\n-        for (String user : USERS) {\n-            assertNotNull(\"User: \" + user + \" was not found\", userSystem.findUser(user));\n-        }\n-    }\n-\n-    @Test\n-    public void findAllUsers() {\n-        userSystem.start();\n-        List<String> userIds = userSystem.findAllUsers().stream()\n-                .map(User::getId)\n-                .collect(Collectors.toList());\n-\n-        for (String user : USERS) {\n-            assertTrue(\"User: \" + user + \" was not found\", userIds.contains(user));\n-        }\n-    }\n-\n-    @Test\n-    public void findAllGroups() {\n-        userSystem.start();\n-        List<String> groupIds = userSystem.findAllGroups().stream()\n-                .map(Group::getId)\n-                .collect(Collectors.toList());\n-\n-        for (String user : GROUPS) {\n-            assertTrue(\"Group: \" + user + \" was not found\", groupIds.contains(user));\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzkxMQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380143911", "bodyText": "The constants should be in upper case; but an enum, as @yurloc suggested, is definitely preferable.", "author": "rsynek", "createdAt": "2020-02-17T12:05:18Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class UserType {\n+\n+    private UserType() {\n+    }\n+\n+    public static final String User = \"User\";", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2Mzc0OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263748", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzkxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java\nindex dd703d2e5..1b3899ad1 100644\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java\n+++ b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java\n\n@@ -18,9 +18,6 @@ package org.kie.server.api.model.taskassigning;\n \n public class UserType {\n \n-    private UserType() {\n-    }\n-\n     public static final String User = \"User\";\n     public static final String Group = \"Group\";\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMDQ1Mw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380120453", "bodyText": "Unused imports.", "author": "yurloc", "createdAt": "2020-02-17T11:09:48Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/test/java/org/kie/server/api/model/taskassigning/util/StatusConverterTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning.util;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.Test;\n+import org.kie.api.task.model.Status;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.kie.api.task.model.Status.Completed;\n+import static org.kie.api.task.model.Status.Ready;", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2Mzg2NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382263864", "bodyText": "good catch.\ndone", "author": "wmedvede", "createdAt": "2020-02-20T21:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMDQ1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-api-task-assigning/src/test/java/org/kie/server/api/model/taskassigning/util/StatusConverterTest.java b/jbpm-task-assigning/kie-server-api-task-assigning/src/test/java/org/kie/server/api/model/taskassigning/util/StatusConverterTest.java\ndeleted file mode 100644\nindex 68042e5ba..000000000\n--- a/jbpm-task-assigning/kie-server-api-task-assigning/src/test/java/org/kie/server/api/model/taskassigning/util/StatusConverterTest.java\n+++ /dev/null\n\n@@ -1,58 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.api.model.taskassigning.util;\n-\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import org.junit.Test;\n-import org.kie.api.task.model.Status;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.kie.api.task.model.Status.Completed;\n-import static org.kie.api.task.model.Status.Ready;\n-\n-public class StatusConverterTest {\n-\n-    @Test\n-    public void convertFromString() {\n-        for (Status status : Status.values()) {\n-            assertEquals(status, StatusConverter.convertFromString(status.name()));\n-        }\n-    }\n-\n-    @Test\n-    public void convertToString() {\n-        for (Status status : Status.values()) {\n-            assertEquals(status.name(), StatusConverter.convertToString(status));\n-        }\n-    }\n-\n-    @Test\n-    public void convertToStringListEllipsis() {\n-        List<String> result = Stream.of(Status.values()).map(Status::name).collect(Collectors.toList());\n-        assertEquals(result, StatusConverter.convertToStringList(Status.values()));\n-    }\n-\n-    @Test\n-    public void convertToStringList() {\n-        List<String> result = Stream.of(Status.values()).map(Status::name).collect(Collectors.toList());\n-        assertEquals(result, StatusConverter.convertToStringList(Arrays.asList(Status.values())));\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380130622", "bodyText": "Javadoc please \ud83d\ude42. Please explain what fromTaskId and fromLastModificationDate do.\nQuestions:\n\nWhy toTaskId is not here (but QueryParamName.TO_TASK_ID exists)?\nCan we use List<Status> status? Otherwise how does the user know what are the possible string values?", "author": "yurloc", "createdAt": "2020-02-17T11:33:27Z", "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);\n+\n+    TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDA4Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264087", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYwOTk0Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r384609946", "bodyText": "Exellent! Thanks.", "author": "yurloc", "createdAt": "2020-02-26T16:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java\nindex a25b11402..5d83f0a4e 100644\n--- a/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java\n+++ b/jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java\n\n@@ -19,16 +19,55 @@ package org.kie.server.client;\n import java.time.LocalDateTime;\n import java.util.List;\n \n-import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningExecutionResult;\n import org.kie.server.api.model.taskassigning.PlanningItemList;\n import org.kie.server.api.model.taskassigning.TaskDataList;\n import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n \n public interface TaskAssigningRuntimeClient {\n \n-    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);\n+    PlanningExecutionResult executePlanning(PlanningItemList planningItemList, String userId);\n \n+    /**\n+     * Executes a parametrized query over the jBPM tasks. This method is intended for the tasks assigning integration\n+     * implementation internal use. Third parties interested in consuming the information type returned by this method\n+     * should use the simplified variant of this of this method {@link #findTasks(Long, List, LocalDateTime, Integer, Integer)}\n+     * or any other of the jBPM runtime client/queries methods, etc.\n+     * <p>\n+     * @param fromTaskId filters the tasks with taskId >= fromTaskId. If null no filtering is applied.\n+     * @param status filters the tasks that are in one of the following status. If null or the empty list no filtering\n+     * is applied.\n+     * @param fromLastModificationDate filters the tasks with lastModificationDate >= fromLastModificationDate. If null\n+     * no filtering is applied.\n+     * @param page sets the starting page for the paged reading.\n+     * @param pageSize sets the pageSize for the paged reading.\n+     * @param taskInputVariablesReadMode establishes the tasks input variables reading mode.\n+     * @return a list of TaskData with the jBPM tasks that met the filtering conditions. The potential owners of the task\n+     * are always loaded but there's no warranty that the potential owners of the last consumed task fits the page/pageSize\n+     * configuration. The task inputs data is loaded accordingly with the selected taskInputVariablesReadMode.\n+     * @see TaskInputVariablesReadMode\n+     */\n     TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n                            Integer page, Integer pageSize,\n                            TaskInputVariablesReadMode taskInputVariablesReadMode);\n+\n+    /**\n+     * Executes a parametrized query over the jBPM tasks. This method is intended for the tasks assigning integration\n+     * implementation. Third parties that might use this method must be aware that no task inputs data is loaded. If this\n+     * information is needed the standard jBPM runtime client/queries must be used instead.\n+     * <p>\n+     * @param fromTaskId filters the tasks with taskId >= fromTaskId. If null no filtering is applied.\n+     * @param status filters the tasks that are in one of the following status. If null or the empty list no filtering\n+     * is applied.\n+     * @param fromLastModificationDate filters the tasks with lastModificationDate >= fromLastModificationDate. If null\n+     * no filtering is applied.\n+     * @param page sets the starting page for the paged reading.\n+     * @param pageSize sets the pageSize for the paged reading.\n+     * @return a list of TaskData with the jBPM tasks that met the filtering conditions. The potential owners of the task\n+     * is always loaded but there's no warranty that the potential owners of the last consumed taks fits the page/pageSize\n+     * configuration. NO task inputs data is loaded by this method.\n+     * @see TaskInputVariablesReadMode\n+     */\n+    TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n+                           Integer page, Integer pageSize);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MDk3Mg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380140972", "bodyText": "Classes in the same package are already in kie-server-parent/kie-server-api. Why is the package split between two modules? Maybe the package in this module (jbpm-task-assigning/kie-server-api-task-assigning) is some kind of internal API or data model for the remote API whereas kie-serve-api is the Java client API? Not sure but I would recommend not to use same package name in different modules unless necessary.", "author": "yurloc", "createdAt": "2020-02-17T11:58:22Z", "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjExMjY1MA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382112650", "bodyText": "This splitting is because right now I have this development in a completely separate structure and with the aim of adding into the kie-server-parent structure the \"less as possible\". This was good for keeping this development isolated as much as possible. And there are a few classes there.\nBUT, the final destination of all this development is kie-server-parent module, so when this PR is approved next step is to move all this classes to the correspnding kie-server-api.\nSo consider this module as \"temporal\".", "author": "wmedvede", "createdAt": "2020-02-20T16:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MDk3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java b/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java\nindex cfd2ae983..b9b90a68e 100644\n--- a/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java\n+++ b/jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java\n\n@@ -25,7 +25,4 @@ public class QueryParamName {\n     public static final String PAGE = \"page\";\n     public static final String PAGE_SIZE = \"pageSize\";\n     public static final String TASK_INPUT_VARIABLES_MODE = \"inputVariablesMode\";\n-\n-    private QueryParamName() {\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzU2Ng==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380143566", "bodyText": "Typo: expeted.", "author": "yurloc", "createdAt": "2020-02-17T12:04:33Z", "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionBuilderTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.kie.api.task.model.Status;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import static org.kie.api.task.model.Status.InProgress;\n+import static org.kie.api.task.model.Status.Ready;\n+import static org.kie.api.task.model.Status.Reserved;\n+import static org.kie.api.task.model.Status.Suspended;\n+import static org.kie.server.api.model.taskassigning.util.StatusConverter.convertToString;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.DUMMY_TASK;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.assertContains;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.assertNotContains;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.mockExternalUser;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n+\n+public class SolutionBuilderTest {\n+\n+    // enabled user\n+    private static final String USER1 = \"USER1\";\n+    // disabled user\n+    private static final String USER2 = \"USER2\";\n+    // enabled user\n+    private static final String USER3 = \"USER3\";\n+    // user not present in the external users\n+    private static final String USER_NOT_PRESENT = \"USER_NOT_PRESENT\";\n+\n+    @Test\n+    public void buildAndCheckUsersWhereAdded() {\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.emptyList())\n+                .withUsers(externalUsers)\n+                .build();\n+\n+        assertContains(USER1, solution.getUserList());\n+        assertNotContains(USER2, solution.getUserList()); //externalUser2 is disabled.\n+        assertContains(USER3, solution.getUserList());\n+        assertContains(PLANNING_USER_ID, solution.getUserList()); //is always added.\n+        assertEquals(3, solution.getUserList().size(), 0);\n+    }\n+\n+    @Test\n+    public void buildAndCheckDummyTaskWasAdded() {\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.emptyList())\n+                .withUsers(Collections.emptyList())\n+                .build();\n+        assertEquals(1, solution.getTaskList().size());\n+        assertEquals(DUMMY_TASK, solution.getTaskList().get(0));\n+    }\n+\n+    @Test\n+    public void buildAndCheckReadyTaskWasProcessedCorrect() {\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskData taskData = mockTaskData(1L, Ready);\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.singletonList(taskData))\n+                .withUsers(externalUsers)\n+                .build();\n+        assertEquals(2, solution.getTaskList().size());\n+        assertContainsNotAssignedTask(taskData, solution);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, InProgress, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Suspended, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckTaskForNotPresentUserWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER_NOT_PRESENT), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAnExample() {\n+        PlanningTask planningTask1 = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData1 = mockTaskData(1L, Reserved, USER1);\n+        taskData1.setPlanningTask(planningTask1);\n+\n+        PlanningTask planningTask2 = PlanningTask.builder()\n+                .taskId(2L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(2)\n+                .build();\n+        TaskData taskData2 = mockTaskData(2L, Suspended, USER1);\n+        taskData2.setPlanningTask(planningTask2);\n+\n+        PlanningTask planningTask3 = PlanningTask.builder()\n+                .taskId(3L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(3)\n+                .build();\n+        TaskData taskData3 = mockTaskData(3L, InProgress, USER1);\n+        taskData3.setPlanningTask(planningTask3);\n+\n+        PlanningTask planningTask4 = PlanningTask.builder()\n+                .taskId(4L)\n+                .assignedUser(USER2)\n+                .published(false)\n+                .index(4)\n+                .build();\n+        TaskData taskData4 = mockTaskData(4L, InProgress, USER1);\n+        taskData4.setPlanningTask(planningTask4);\n+\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Arrays.asList(taskData4, taskData1, taskData3, taskData2))\n+                .withUsers(externalUsers)\n+                .build();\n+\n+        assertEquals(5, solution.getTaskList().size());\n+        User user1 = solution.getUserList().stream()\n+                .filter(user -> user.getEntityId().equals(USER1))\n+                .findFirst().orElse(null);\n+        assertNotNull(user1);\n+        List<Task> user1Tasks = extractTasks(user1, (task) -> true);\n+        assertEquals(4L, user1Tasks.size(), 0);\n+\n+        assertExpetedTaskAtPosition(taskData2.getTaskId(), 0, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData3.getTaskId(), 1, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData4.getTaskId(), 2, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData1.getTaskId(), 3, false, user1Tasks);\n+    }\n+\n+    void assertExpetedTaskAtPosition(long taskId, int position, boolean pinned, List<Task> tasks) {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDMyOA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264328", "bodyText": "good catch\ndone", "author": "wmedvede", "createdAt": "2020-02-20T21:21:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzU2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "chunk": "diff --git a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionBuilderTest.java b/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionBuilderTest.java\ndeleted file mode 100644\nindex 3498e7316..000000000\n--- a/jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionBuilderTest.java\n+++ /dev/null\n\n@@ -1,412 +0,0 @@\n-/*\n- * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.kie.server.services.taskassigning.planning;\n-\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import org.junit.Test;\n-import org.kie.api.task.model.Status;\n-import org.kie.server.api.model.taskassigning.PlanningTask;\n-import org.kie.server.api.model.taskassigning.TaskData;\n-import org.kie.server.services.taskassigning.core.model.Task;\n-import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n-import org.kie.server.services.taskassigning.core.model.User;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertNotNull;\n-import static org.junit.Assert.assertNull;\n-\n-import static org.kie.api.task.model.Status.InProgress;\n-import static org.kie.api.task.model.Status.Ready;\n-import static org.kie.api.task.model.Status.Reserved;\n-import static org.kie.api.task.model.Status.Suspended;\n-import static org.kie.server.api.model.taskassigning.util.StatusConverter.convertToString;\n-import static org.kie.server.services.taskassigning.core.model.ModelConstants.DUMMY_TASK;\n-import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n-import static org.kie.server.services.taskassigning.planning.TestUtil.assertContains;\n-import static org.kie.server.services.taskassigning.planning.TestUtil.assertNotContains;\n-import static org.kie.server.services.taskassigning.planning.TestUtil.mockExternalUser;\n-import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n-\n-public class SolutionBuilderTest {\n-\n-    // enabled user\n-    private static final String USER1 = \"USER1\";\n-    // disabled user\n-    private static final String USER2 = \"USER2\";\n-    // enabled user\n-    private static final String USER3 = \"USER3\";\n-    // user not present in the external users\n-    private static final String USER_NOT_PRESENT = \"USER_NOT_PRESENT\";\n-\n-    @Test\n-    public void buildAndCheckUsersWhereAdded() {\n-        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n-        TaskAssigningSolution solution = SolutionBuilder.create()\n-                .withTasks(Collections.emptyList())\n-                .withUsers(externalUsers)\n-                .build();\n-\n-        assertContains(USER1, solution.getUserList());\n-        assertNotContains(USER2, solution.getUserList()); //externalUser2 is disabled.\n-        assertContains(USER3, solution.getUserList());\n-        assertContains(PLANNING_USER_ID, solution.getUserList()); //is always added.\n-        assertEquals(3, solution.getUserList().size(), 0);\n-    }\n-\n-    @Test\n-    public void buildAndCheckDummyTaskWasAdded() {\n-        TaskAssigningSolution solution = SolutionBuilder.create()\n-                .withTasks(Collections.emptyList())\n-                .withUsers(Collections.emptyList())\n-                .build();\n-        assertEquals(1, solution.getTaskList().size());\n-        assertEquals(DUMMY_TASK, solution.getTaskList().get(0));\n-    }\n-\n-    @Test\n-    public void buildAndCheckReadyTaskWasProcessedCorrect() {\n-        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n-        TaskData taskData = mockTaskData(1L, Ready);\n-        TaskAssigningSolution solution = SolutionBuilder.create()\n-                .withTasks(Collections.singletonList(taskData))\n-                .withUsers(externalUsers)\n-                .build();\n-        assertEquals(2, solution.getTaskList().size());\n-        assertContainsNotAssignedTask(taskData, solution);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedTaskWithNoPlanningTaskWasProcessedCorrect() {\n-        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER1), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckInProgressTaskWithNoPlanningTaskWasProcessedCorrect() {\n-        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, InProgress, USER1), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckSuspendedTaskWithNoPlanningTaskWasProcessedCorrect() {\n-        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Suspended, USER1), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckTaskForNotPresentUserWithNoPlanningTaskWasProcessedCorrect() {\n-        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER_NOT_PRESENT), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), false);\n-    }\n-\n-    @Test\n-    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n-    }\n-\n-    @Test\n-    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n-    }\n-\n-    @Test\n-    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n-    }\n-\n-    @Test\n-    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n-        PlanningTask planningTask = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n-        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n-    }\n-\n-    @Test\n-    public void buildAnExample() {\n-        PlanningTask planningTask1 = PlanningTask.builder()\n-                .taskId(1L)\n-                .assignedUser(USER1)\n-                .published(false)\n-                .index(1)\n-                .build();\n-        TaskData taskData1 = mockTaskData(1L, Reserved, USER1);\n-        taskData1.setPlanningTask(planningTask1);\n-\n-        PlanningTask planningTask2 = PlanningTask.builder()\n-                .taskId(2L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(2)\n-                .build();\n-        TaskData taskData2 = mockTaskData(2L, Suspended, USER1);\n-        taskData2.setPlanningTask(planningTask2);\n-\n-        PlanningTask planningTask3 = PlanningTask.builder()\n-                .taskId(3L)\n-                .assignedUser(USER1)\n-                .published(true)\n-                .index(3)\n-                .build();\n-        TaskData taskData3 = mockTaskData(3L, InProgress, USER1);\n-        taskData3.setPlanningTask(planningTask3);\n-\n-        PlanningTask planningTask4 = PlanningTask.builder()\n-                .taskId(4L)\n-                .assignedUser(USER2)\n-                .published(false)\n-                .index(4)\n-                .build();\n-        TaskData taskData4 = mockTaskData(4L, InProgress, USER1);\n-        taskData4.setPlanningTask(planningTask4);\n-\n-        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n-        TaskAssigningSolution solution = SolutionBuilder.create()\n-                .withTasks(Arrays.asList(taskData4, taskData1, taskData3, taskData2))\n-                .withUsers(externalUsers)\n-                .build();\n-\n-        assertEquals(5, solution.getTaskList().size());\n-        User user1 = solution.getUserList().stream()\n-                .filter(user -> user.getEntityId().equals(USER1))\n-                .findFirst().orElse(null);\n-        assertNotNull(user1);\n-        List<Task> user1Tasks = extractTasks(user1, (task) -> true);\n-        assertEquals(4L, user1Tasks.size(), 0);\n-\n-        assertExpetedTaskAtPosition(taskData2.getTaskId(), 0, true, user1Tasks);\n-        assertExpetedTaskAtPosition(taskData3.getTaskId(), 1, true, user1Tasks);\n-        assertExpetedTaskAtPosition(taskData4.getTaskId(), 2, true, user1Tasks);\n-        assertExpetedTaskAtPosition(taskData1.getTaskId(), 3, false, user1Tasks);\n-    }\n-\n-    void assertExpetedTaskAtPosition(long taskId, int position, boolean pinned, List<Task> tasks) {\n-        assertEquals(\"Task: \" + taskId + \" is expected at position 0\", taskId, tasks.get(position).getId(), 0);\n-        assertEquals(\"Task: \" + taskId + \" with pinned = \" + pinned + \" is expected at position 0\", pinned, tasks.get(position).isPinned());\n-    }\n-\n-    private void buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(TaskData taskData, boolean pinned) {\n-        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n-        TaskAssigningSolution solution = SolutionBuilder.create()\n-                .withTasks(Collections.singletonList(taskData))\n-                .withUsers(externalUsers)\n-                .build();\n-        assertEquals(2, solution.getTaskList().size());\n-        assertContainsAssignedTask(taskData, taskData.getActualOwner(), pinned, solution);\n-    }\n-\n-    private void buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(TaskData taskData, PlanningTask planningTask, String owner, boolean pinned) {\n-        taskData.setPlanningTask(planningTask);\n-        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n-        TaskAssigningSolution solution = SolutionBuilder.create()\n-                .withTasks(Collections.singletonList(taskData))\n-                .withUsers(externalUsers)\n-                .build();\n-        assertEquals(2, solution.getTaskList().size());\n-        assertContainsAssignedTask(taskData, owner, pinned, solution);\n-    }\n-\n-    private List<org.kie.server.services.taskassigning.user.system.api.User> buildExternalUsers() {\n-        org.kie.server.services.taskassigning.user.system.api.User externalUser1 =\n-                mockExternalUser(USER1, true, Collections.emptySet());\n-        org.kie.server.services.taskassigning.user.system.api.User externalUser2 =\n-                mockExternalUser(USER2, false, Collections.emptySet());\n-        org.kie.server.services.taskassigning.user.system.api.User externalUser3 =\n-                mockExternalUser(USER3, true, Collections.emptySet());\n-        return Arrays.asList(externalUser1, externalUser2, externalUser3);\n-    }\n-\n-    private TaskData mockTaskData(Long taskId, Status status) {\n-        return mockTaskData(taskId, status, null);\n-    }\n-\n-    private TaskData mockTaskData(Long taskId, Status status, String actualOwner) {\n-        TaskData taskData = new TaskData();\n-        taskData.setTaskId(taskId);\n-        taskData.setActualOwner(actualOwner);\n-        taskData.setStatus(convertToString(status));\n-        taskData.setPriority(0);\n-        taskData.setProcessInstanceId(1L);\n-        return taskData;\n-    }\n-\n-    private void assertContainsNotAssignedTask(TaskData taskData, TaskAssigningSolution solution) {\n-        Task task = solution.getTaskList().stream()\n-                .filter(t -> taskData.getTaskId().equals(t.getId()))\n-                .findFirst().orElse(null);\n-        assertNotNull(\"Task: \" + taskData.getTaskId() + \" must be present in the solution.\", task);\n-        assertNull(\"Task: \" + taskData.getTaskId() + \" must not be assigned to any user\", task.getUser());\n-    }\n-\n-    private void assertContainsAssignedTask(TaskData taskData, String userId, boolean pinned, TaskAssigningSolution solution) {\n-        Task task = solution.getTaskList().stream()\n-                .filter(t -> taskData.getTaskId().equals(t.getId()))\n-                .findFirst().orElse(null);\n-        User user = solution.getUserList().stream()\n-                .filter(u -> userId.equals(u.getEntityId()))\n-                .findFirst().orElse(null);\n-        assertNotNull(\"Task: \" + taskData.getTaskId() + \" must be present in the solution.\", task);\n-        assertNotNull(\"Task: \" + taskData.getTaskId() + \" must assigned to user: \" + userId + \" but user is not be present in the solution.\", user);\n-        assertNotNull(\"Task: \" + taskData.getTaskId() + \" must be assigned to user: \" + userId + \" but has no assigned user.\", task.getUser());\n-        assertEquals(\"Task: \" + taskData.getTaskId() + \" must be assigned to user: \" + userId, userId, task.getUser().getEntityId());\n-        assertEquals(\"Task: \" + taskData.getTaskId() + \" must have pinned = \" + pinned, pinned, task.isPinned());\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4NjgzMg==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380186832", "bodyText": "Is there any reason for abbreviating the element names? I'd personally avoid abbreviations since the XML should be human readable (think of the documentation with REST call examples).", "author": "yurloc", "createdAt": "2020-02-17T13:39:44Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.util.Objects;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-oe\")", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDQ1NQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264455", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4NjgzMg=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java\nindex e9c042d8c..c8b5945da 100644\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java\n+++ b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java\n\n@@ -24,7 +24,7 @@ import javax.xml.bind.annotation.XmlElement;\n import javax.xml.bind.annotation.XmlRootElement;\n \n @XmlAccessorType(XmlAccessType.FIELD)\n-@XmlRootElement(name = \"tsk-assig-oe\")\n+@XmlRootElement(name = \"task-assigning-organizational-entity\")\n public class OrganizationalEntity {\n \n     @XmlElement(name = \"name\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4Nzg4OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380187888", "bodyText": "Redundant \"-task\".", "author": "yurloc", "createdAt": "2020-02-17T13:41:51Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+import org.kie.server.api.model.ItemList;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-task-planning-item-list\")", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDY2Nw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264667", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4Nzg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java\nindex 308148efd..753297ba9 100644\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java\n+++ b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java\n\n@@ -28,7 +28,7 @@ import javax.xml.bind.annotation.XmlRootElement;\n import org.kie.server.api.model.ItemList;\n \n @XmlAccessorType(XmlAccessType.FIELD)\n-@XmlRootElement(name = \"tsk-assig-task-planning-item-list\")\n+@XmlRootElement(name = \"task-assigning-planning-item-list\")\n public class PlanningItemList implements ItemList<PlanningItem> {\n \n     @XmlElement(name = \"planningItems\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380192678", "bodyText": "Probably s/Execute/Execution/. Is this a result of a planning execution? Then it should be PlanningExecutionResult.", "author": "yurloc", "createdAt": "2020-02-17T13:50:55Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-exec-planning-result\")\n+public class ExecutePlanningResult {", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NTIyMw==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380195223", "bodyText": "Also, by looking at the class fields, it seem this only serves to report an execution error. Should the class name reflect this?", "author": "yurloc", "createdAt": "2020-02-17T13:55:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzMDY1NA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382130654", "bodyText": "I agree with the renaming PlanningExecutionResult is better suited and I think I makes sense keep this name.", "author": "wmedvede", "createdAt": "2020-02-20T16:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NDgwNQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382264805", "bodyText": "done", "author": "wmedvede", "createdAt": "2020-02-20T21:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningExecutionResult.java\nsimilarity index 91%\nrename from kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java\nrename to kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningExecutionResult.java\nindex 529a6c807..acd1c4718 100644\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java\n+++ b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningExecutionResult.java\n\n@@ -22,8 +22,8 @@ import javax.xml.bind.annotation.XmlElement;\n import javax.xml.bind.annotation.XmlRootElement;\n \n @XmlAccessorType(XmlAccessType.FIELD)\n-@XmlRootElement(name = \"tsk-assig-exec-planning-result\")\n-public class ExecutePlanningResult {\n+@XmlRootElement(name = \"task-assigning-planning-execution-result\")\n+public class PlanningExecutionResult {\n \n     public enum ErrorCode {\n         TASK_MODIFIED_SINCE_PLAN_CALCULATION_ERROR,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NjI1OA==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380196258", "bodyText": "Will this work without ExecutePlanningResult and OrganizationalEntity?", "author": "yurloc", "createdAt": "2020-02-17T13:57:35Z", "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java", "diffHunk": "@@ -381,13 +386,20 @@\n                 DMNDecisionInfo.class,\n                 DMNInputDataInfo.class,\n                 DMNItemDefinitionInfo.class,\n-                \n+\n                 // Kie PMML\n                 PMML4Result.class,\n                 IntegerFieldOutput.class,\n                 DoubleFieldOutput.class,\n                 StringFieldOutput.class,\n-                ScoreCard.class\n+                ScoreCard.class,\n+\n+                //TaskAssigning\n+                PlanningItem.class,\n+                PlanningItemList.class,\n+                PlanningTask.class,\n+                TaskDataList.class,\n+                TaskData.class", "originalCommit": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI2NTM3OQ==", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r382265379", "bodyText": "works since the missing classes are right now being sent as fields of declared ones, but good catch. done", "author": "wmedvede", "createdAt": "2020-02-20T21:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NjI1OA=="}], "type": "inlineReview", "revised_code": {"commit": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "chunk": "diff --git a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java\nindex e8a9202b8..82ca80eb7 100644\n--- a/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java\n+++ b/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java\n\n@@ -395,6 +397,8 @@ public class JaxbMarshaller implements Marshaller {\n                 ScoreCard.class,\n \n                 //TaskAssigning\n+                PlanningExecutionResult.class,\n+                OrganizationalEntity.class,\n                 PlanningItem.class,\n                 PlanningItemList.class,\n                 PlanningTask.class,\n"}}, {"oid": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "f797da226fee8a2b8df32bc606b869bb66f33492", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/f797da226fee8a2b8df32bc606b869bb66f33492", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests I", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "6b6465776075428ebfdc3f9018be38703a7571ce", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/6b6465776075428ebfdc3f9018be38703a7571ce", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/db9e03bb968b28a37642f4b825cfe35aec2e8132", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests III", "committedDate": "2020-02-20T20:44:47Z", "type": "commit"}, {"oid": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/db9e03bb968b28a37642f4b825cfe35aec2e8132", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests III", "committedDate": "2020-02-20T20:44:47Z", "type": "forcePushed"}, {"oid": "00c0a6fb5eec3c39538f1e28c7cf478ebc674c0d", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/00c0a6fb5eec3c39538f1e28c7cf478ebc674c0d", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests IV", "committedDate": "2020-02-25T17:21:55Z", "type": "commit"}, {"oid": "aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f", "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests V", "committedDate": "2020-02-26T09:17:25Z", "type": "commit"}]}