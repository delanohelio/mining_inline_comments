{"pr_number": 3668, "pr_title": "TRUNK-5980: BaseContextSensitiveTest to allow protected overrides.", "pr_createdAt": "2020-12-17T10:33:43Z", "pr_url": "https://github.com/openmrs/openmrs-core/pull/3668", "timeline": [{"oid": "4c138687babaff8c67d202f05d2c505b3931037f", "url": "https://github.com/openmrs/openmrs-core/commit/4c138687babaff8c67d202f05d2c505b3931037f", "message": "TRUNK-5980: BaseContextSensitiveTest to allow further protected overrides. (#3664)\n\n* TRUNK-5980:BaseContextSensitiveTest to allow Protected overrides\n\n* Updating the commit\n\n(cherry picked from commit 743de0d4df27a98887919fef5522cbc1afa28149)", "committedDate": "2020-12-17T10:02:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzMjI5Nw==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545032297", "bodyText": "@sherrif10  did you see the conflict here ?", "author": "tendomart", "createdAt": "2020-12-17T11:54:00Z", "path": "api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java", "diffHunk": "@@ -601,12 +601,29 @@ public void setAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator() t\n \t}\n \n \t/**\n+<<<<<<< HEAD", "originalCommit": "4c138687babaff8c67d202f05d2c505b3931037f", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "17b101eda2cbf3c28cd6130af031e277bc516a0a", "chunk": "diff --git a/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java b/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\nindex 29fd53028..bd0cd8416 100644\n--- a/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\n+++ b/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\n\n@@ -601,8 +602,6 @@ public abstract class BaseContextSensitiveTest extends AbstractJUnit4SpringConte\n \t}\n \n \t/**\n-<<<<<<< HEAD\n-=======\n \t * Drops the not null constraint from the the specified column in the specified table\n \t *\n \t * @param columnName the column from which to remove the constraint\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzMzI1OQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545033259", "bodyText": "oops And here as well .", "author": "tendomart", "createdAt": "2020-12-17T11:55:42Z", "path": "api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java", "diffHunk": "@@ -601,12 +601,29 @@ public void setAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator() t\n \t}\n \n \t/**\n+<<<<<<< HEAD\n+=======\n+\t * Drops the not null constraint from the the specified column in the specified table\n+\t *\n+\t * @param columnName the column from which to remove the constraint\n+\t * @param tableName the table that contains the column\n+\t * @throws SQLException\n+\t */\n+\tprotected void dropNotNullConstraint(String tableName, String columnName) throws SQLException {\n+\t\tif (!useInMemoryDatabase()) {\n+\t\t\tthrow new RuntimeException(\"Altering column nullability is not supported for a non in-memory database\");\n+\t\t}\n+\t\tfinal String sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + columnName + \" SET NULL\";\n+\t\tDatabaseUtil.executeSQL(getConnection(), sql, false);\n+\t}\n+\t/**\n+>>>>>>> 743de0d4d... TRUNK-5980: BaseContextSensitiveTest to allow further protected overrides. (#3664)", "originalCommit": "4c138687babaff8c67d202f05d2c505b3931037f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2NjI1NQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545166255", "bodyText": "Thanks @tendomart  Have resolved the conflicts", "author": "sherrif10", "createdAt": "2020-12-17T15:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAzMzI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "17b101eda2cbf3c28cd6130af031e277bc516a0a", "chunk": "diff --git a/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java b/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\nindex 29fd53028..bd0cd8416 100644\n--- a/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\n+++ b/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\n\n@@ -601,8 +602,6 @@ public abstract class BaseContextSensitiveTest extends AbstractJUnit4SpringConte\n \t}\n \n \t/**\n-<<<<<<< HEAD\n-=======\n \t * Drops the not null constraint from the the specified column in the specified table\n \t *\n \t * @param columnName the column from which to remove the constraint\n"}}, {"oid": "17b101eda2cbf3c28cd6130af031e277bc516a0a", "url": "https://github.com/openmrs/openmrs-core/commit/17b101eda2cbf3c28cd6130af031e277bc516a0a", "message": "resolving merge conflicts", "committedDate": "2020-12-17T12:26:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2NTg0Mg==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545165842", "bodyText": "Jupiter support starts from 2.4.x or even 2.5.x. You can remove this file.", "author": "mks-d", "createdAt": "2020-12-17T15:12:49Z", "path": "api/src/test/java/org/openmrs/test/jupiter/BaseContextSensitiveTest.java", "diffHunk": "@@ -0,0 +1,1027 @@\n+/**\n+ * This Source Code Form is subject to the terms of the Mozilla Public License,\n+ * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n+ * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under\n+ * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.\n+ *\n+ * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS\n+ * graphic logo is a trademark of OpenMRS Inc.\n+ */\n+package org.openmrs.test.jupiter;\n+\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static org.springframework.test.context.TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS;\n+\n+import javax.swing.*;\n+import java.awt.*;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.dbunit.DatabaseUnitException;\n+import org.dbunit.DatabaseUnitRuntimeException;\n+import org.dbunit.database.DatabaseConfig;\n+import org.dbunit.database.DatabaseConnection;\n+import org.dbunit.database.IDatabaseConnection;\n+import org.dbunit.dataset.DataSetException;\n+import org.dbunit.dataset.DefaultDataSet;\n+import org.dbunit.dataset.DefaultTable;\n+import org.dbunit.dataset.IDataSet;\n+import org.dbunit.dataset.ReplacementDataSet;\n+import org.dbunit.dataset.stream.StreamingDataSet;\n+import org.dbunit.dataset.xml.FlatXmlDataSet;\n+import org.dbunit.dataset.xml.FlatXmlProducer;\n+import org.dbunit.dataset.xml.XmlDataSet;\n+import org.dbunit.ext.h2.H2DataTypeFactory;\n+import org.dbunit.operation.DatabaseOperation;\n+import org.hibernate.SessionFactory;\n+import org.hibernate.cfg.Environment;\n+import org.hibernate.dialect.H2Dialect;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.openmrs.ConceptName;\n+import org.openmrs.Drug;\n+import org.openmrs.PatientIdentifier;\n+import org.openmrs.PersonAttribute;\n+import org.openmrs.PersonName;\n+import org.openmrs.User;\n+import org.openmrs.annotation.OpenmrsProfileExcludeFilter;\n+import org.openmrs.api.context.Context;\n+import org.openmrs.api.context.ContextAuthenticationException;\n+import org.openmrs.api.context.ContextMockHelper;\n+import org.openmrs.api.context.Credentials;\n+import org.openmrs.api.context.UsernamePasswordCredentials;\n+import org.openmrs.module.ModuleConstants;\n+import org.openmrs.test.SkipBaseSetup;\n+import org.openmrs.test.SkipBaseSetupAnnotationExecutionListener;\n+import org.openmrs.test.TestUtil;\n+import org.openmrs.util.DatabaseUtil;\n+import org.openmrs.util.OpenmrsClassLoader;\n+import org.openmrs.util.OpenmrsConstants;\n+import org.openmrs.util.OpenmrsUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.test.annotation.Rollback;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.TestExecutionListeners;\n+import org.springframework.test.context.junit.jupiter.SpringExtension;\n+import org.springframework.transaction.annotation.Transactional;\n+import org.xml.sax.InputSource;\n+\n+/**\n+ * This is the base for spring/context tests. Tests that NEED to use calls to the Context class and\n+ * use Services and/or the database should extend this class. NOTE: Tests that do not need access to\n+ * spring enabled services do not need this class and extending this will only slow those test cases\n+ * down. (because spring is started before test cases are run). Normal test cases do not need to\n+ * extend anything.\n+ * \n+ * Use this class for Junit 5 tests.\n+ * \n+ * @since 2.4.0\n+ */\n+@ContextConfiguration(locations = { \"classpath:applicationContext-service.xml\", \"classpath*:openmrs-servlet.xml\",\n+        \"classpath*:moduleApplicationContext.xml\", \"classpath*:TestingApplicationContext.xml\" })\n+@TestExecutionListeners(\n+\tlisteners = { SkipBaseSetupAnnotationExecutionListener.class,\n+\t\tStartModuleExecutionListener.class },\n+        mergeMode = MERGE_WITH_DEFAULTS\n+)\n+@Transactional\n+@Rollback\n+@ExtendWith(SpringExtension.class)\n+@ExtendWith(MockitoExtension.class)\n+public abstract class BaseContextSensitiveTest {\n+\t\n+\tprivate static final Logger log = LoggerFactory.getLogger(BaseContextSensitiveTest.class);\n+\t\n+\t/**\n+\t * Only the classpath/package path and filename of the initial dataset\n+\t */\n+\tprotected static final String INITIAL_XML_DATASET_PACKAGE_PATH = \"org/openmrs/include/initialInMemoryTestDataSet.xml\";\n+\t\n+\tprotected static final String EXAMPLE_XML_DATASET_PACKAGE_PATH = \"org/openmrs/include/standardTestDataset.xml\";\n+\t\n+\t/**\n+\t * cached runtime properties\n+\t */\n+\tprotected static Properties runtimeProperties;\n+\t\n+\t/**\n+\t * Used for username/password dialog\n+\t */\n+\tprivate static final Font font = new Font(\"Arial\", Font.BOLD, 16);\n+\t\n+\t/**\n+\t * Our username field is outside of the getUsernameAndPassword() method so we can do our\n+\t * force-focus-on-the-username-field trick -- i.e., refer to the field within an anonymous\n+\t * TimerTask method.\n+\t */\n+\tprivate static JTextField usernameField;\n+\t\n+\t/**\n+\t * This frame contains the password dialog box. In order to bring the frame to the front in the\n+\t * TimerTask method, we make it a private field\n+\t */\n+\tprivate static Frame frame;\n+\t\n+\t/**\n+\t * Static variable to keep track of the number of times this class has been loaded (aka, number\n+\t * of tests already run)\n+\t */\n+\tprivate static Integer loadCount = 0;\n+\t\n+\t/**\n+\t * Allows to determine if the DB is initialized with standard data\n+\t */\n+\tprivate static boolean isBaseSetup;\n+\t\n+\t/**\n+\t * Stores a user authenticated for running tests which allows to discover a situation when some\n+\t * test authenticates as a different user and we need to revert to the original one\n+\t */\n+\tprivate User authenticatedUser;\n+\t\n+\t@Autowired\n+\tprotected ApplicationContext applicationContext;\n+\t/**\n+\t * Allows mocking services returned by Context. See {@link ContextMockHelper}\n+\t * \n+\t * @since 1.11, 1.10, 1.9.9\n+\t */\n+\t@InjectMocks\n+\tprotected ContextMockHelper contextMockHelper;\n+\t\n+\tprivate static volatile BaseContextSensitiveTest instance;\n+\t\n+\t/**\n+\t * Basic constructor for the super class to all openmrs api unit tests. This constructor sets up\n+\t * the classloader and the properties file so that by the type spring gets around to finally\n+\t * starting, the openmrs runtime properties are already in place A static load count is kept to\n+\t * count the number of times this class has been loaded.\n+\t * \n+\t * @see #getLoadCount()\n+\t */\n+\tpublic BaseContextSensitiveTest() {\n+\t\t\n+\t\tThread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());\n+\t\t\n+\t\tProperties props = getRuntimeProperties();\n+\t\t\n+\t\tif (log.isDebugEnabled())\n+\t\t\tlog.debug(\"props: \" + props);\n+\t\t\n+\t\tContext.setRuntimeProperties(props);\n+\t\t\n+\t\tloadCount++;\n+\t\t\n+\t\tinstance = this;\n+\t}\n+\t\n+\t/**\n+\t * @since 1.11, 1.10, 1.9.9\n+\t */\n+\t@AfterEach\n+\tpublic void revertContextMocks() {\n+\t\tcontextMockHelper.revertMocks();\n+\t}\n+\t\n+\t/**\n+\t * Modules should extend {@link BaseModuleContextSensitiveTest}, not this class. If they extend\n+\t * this class, then they won't work right when run in batches.\n+\t * \n+\t * @throws Exception\n+\t */\n+\t@BeforeEach\n+\tpublic void checkNotModule() throws Exception {\n+\t\tif (this.getClass().getPackage().toString().contains(\"org.openmrs.module.\") && !(this instanceof BaseContextSensitiveTest)) {\n+\t\t\tthrow new RuntimeException(\"Module unit test classes should extend BaseModuleContextSensitiveTest, not just BaseContextSensitiveTest\");\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Allows to ignore the test if the environment does not match the given parameters.\n+\t * \n+\t * @param openmrsPlatformVersion\n+\t * @param modules\n+\t * @since 1.11.3, 1.10.2, 1.9.9\n+\t */\n+\tpublic void assumeOpenmrsProfile(String openmrsPlatformVersion, String... modules) {\n+\t\tOpenmrsProfileExcludeFilter filter = new OpenmrsProfileExcludeFilter();\n+\t\tMap<String, Object> profile = new HashMap<>();\n+\t\tprofile.put(\"openmrsPlatformVersion\", openmrsPlatformVersion);\n+\t\tif (modules != null) {\n+\t\t\tprofile.put(\"modules\", modules);\n+\t\t} else {\n+\t\t\tprofile.put(\"modules\", new String[0]);\n+\t\t}\n+\t\tString errorMessage = \"Ignored. Expected profile: {openmrsPlatformVersion=\" + openmrsPlatformVersion + \", modules=[\"\n+\t\t        + StringUtils.join((String[]) profile.get(\"modules\"), \", \") + \"]}\";\n+\t\tassumeTrue(filter.matchOpenmrsProfileAttributes(profile), errorMessage);\n+\t}\n+\t\n+\t/**\n+\t * Allows to ignore the test if the given modules are not running.\n+\t * \n+\t * @param module in the format moduleId:version\n+\t * @param modules additional list of modules in the format moduleId:version\n+\t * @since 1.11.3, 1.10.2, 1.9.9\n+\t */\n+\tpublic void assumeOpenmrsModules(String module, String... modules) {\n+\t\tString[] allModules = ArrayUtils.addAll(modules, module);\n+\t\tassumeOpenmrsProfile(null, allModules);\n+\t}\n+\t\n+\t/**\n+\t * Allows to ignore the test if the environment does not match the given OpenMRS version.\n+\t * \n+\t * @param openmrsPlatformVersion\n+\t * @since 1.11.3, 1.10.2, 1.9.9\n+\t */\n+\tpublic void assumeOpenmrsPlatformVersion(String openmrsPlatformVersion) {\n+\t\tassumeOpenmrsProfile(openmrsPlatformVersion);\n+\t}\n+\t\n+\t/**\n+\t * Get the number of times this class has been loaded. This is a rough approx of how many tests\n+\t * have been run so far. This can be used to determine if the test is being run in a standalone\n+\t * context or if other tests have been run before.\n+\t * \n+\t * @return number of times this class has been loaded\n+\t */\n+\tpublic Integer getLoadCount() {\n+\t\treturn loadCount;\n+\t}\n+\t\n+\t/**\n+\t * Used for runtime properties. The default is \"openmrs\" because most people will use that as\n+\t * the default. If your webapp and runtime properties are under a different name, override this\n+\t * method in your tests\n+\t * \n+\t * @return String webapp name to assume when looking up the runtime properties\n+\t */\n+\tpublic String getWebappName() {\n+\t\treturn \"openmrs\";\n+\t}\n+\t\n+\t/**\n+\t * Mimics org.openmrs.web.Listener.getRuntimeProperties() Overrides the database connection\n+\t * properties if the user wants an in-memory database\n+\t * \n+\t * @return Properties runtime\n+\t */\n+\tpublic Properties getRuntimeProperties() {\n+\t\t\n+\t\t// cache the properties for subsequent calls\n+\t\tif (runtimeProperties == null)\n+\t\t\truntimeProperties = TestUtil.getRuntimeProperties(getWebappName());\n+\t\t\n+\t\t// if we're using the in-memory hypersonic database, add those\n+\t\t// connection properties here to override what is in the runtime\n+\t\t// properties\n+\t\tif (useInMemoryDatabase()) {\n+\t\t\truntimeProperties.setProperty(Environment.DIALECT, H2Dialect.class.getName());\n+\t\t\tString url = \"jdbc:h2:mem:openmrs;DB_CLOSE_DELAY=30;LOCK_TIMEOUT=10000\";\n+\t\t\truntimeProperties.setProperty(Environment.URL, url);\n+\t\t\truntimeProperties.setProperty(Environment.DRIVER, \"org.h2.Driver\");\n+\t\t\truntimeProperties.setProperty(Environment.USER, \"sa\");\n+\t\t\truntimeProperties.setProperty(Environment.PASS, \"\");\n+\t\t\t\n+\t\t\t// these properties need to be set in case the user has this exact\n+\t\t\t// phrasing in their runtime file.\n+\t\t\truntimeProperties.setProperty(\"connection.username\", \"sa\");\n+\t\t\truntimeProperties.setProperty(\"connection.password\", \"\");\n+\t\t\truntimeProperties.setProperty(\"connection.url\", url);\n+\t\t\t\n+\t\t\t// automatically create the tables defined in the hbm files\n+\t\t\truntimeProperties.setProperty(Environment.HBM2DDL_AUTO, \"create-drop\");\n+\t\t}\n+\t\telse {\n+\t\t\tString url = System.getProperty(\"databaseUrl\");\n+\t\t\tString username = System.getProperty(\"databaseUsername\");\n+\t\t\tString password = System.getProperty(\"databasePassword\");\n+\t\t\t\n+\t\t\truntimeProperties.setProperty(Environment.URL, url);\n+\t\t\truntimeProperties.setProperty(Environment.DRIVER, System.getProperty(\"databaseDriver\"));\n+\t\t\truntimeProperties.setProperty(Environment.USER, username);\n+\t\t\truntimeProperties.setProperty(Environment.PASS, password);\n+\t\t\truntimeProperties.setProperty(Environment.DIALECT, System.getProperty(\"databaseDialect\"));\n+\t\t\t\n+\t\t\t// these properties need to be set in case the user has this exact\n+\t\t\t// phrasing in their runtime file.\n+\t\t\truntimeProperties.setProperty(\"connection.username\", username);\n+\t\t\truntimeProperties.setProperty(\"connection.password\", password);\n+\t\t\truntimeProperties.setProperty(\"connection.url\", url);\n+\t\t\t\n+\t\t\t//for the first time, automatically create the tables defined in the hbm files\n+\t\t\t//after that, just update, if there are any changes. This is for performance reasons.\n+\t\t\truntimeProperties.setProperty(Environment.HBM2DDL_AUTO, \"update\");\n+\t\t}\n+\t\t\n+\t\t// we don't want to try to load core modules in tests\n+\t\truntimeProperties.setProperty(ModuleConstants.IGNORE_CORE_MODULES_PROPERTY, \"true\");\n+\t\t\n+\t\ttry {\n+\t\t\tFile tempappdir = File.createTempFile(\"appdir-for-unit-tests-\", \"\");\n+\t\t\ttempappdir.delete(); // so we can make it into a directory\n+\t\t\ttempappdir.mkdir(); // turn it into a directory\n+\t\t\ttempappdir.deleteOnExit(); // clean up when we're done with tests\n+\t\t\t\n+\t\t\truntimeProperties.setProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, tempappdir\n+\t\t\t        .getAbsolutePath());\n+\t\t\tOpenmrsUtil.setApplicationDataDirectory(tempappdir.getAbsolutePath());\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tlog.error(\"Unable to create temp dir\", e);\n+\t\t}\n+\t\t\n+\t\treturn runtimeProperties;\n+\t}\n+\t\n+\t/**\n+\t * This method provides the credentials to authenticate the user that is authenticated through the base setup.\n+\t * This method can be overridden when setting up test application contexts that are *not* using the default authentication scheme.\n+\t * \n+\t * @return The credentials to use for base setup authentication.\n+\t * @since 2.3.0\n+\t */\n+\tprotected Credentials getCredentials() {\n+\t\treturn new UsernamePasswordCredentials(\"admin\", \"test\");\n+\t}\n+\t\n+\t/**\n+\t * Authenticate to the Context. A popup box will appear asking the current user to enter\n+\t * credentials unless there is a junit.username and junit.password defined in the runtime\n+\t * properties\n+\t * \n+\t * @throws Exception\n+\t */\n+\tpublic void authenticate() {\n+\t\tif (Context.isAuthenticated() && Context.getAuthenticatedUser().equals(authenticatedUser)) {\n+\t\t\treturn;\n+\t\t}\n+\t\t\n+\t\ttry {\n+\t\t\tContext.authenticate(getCredentials());\n+\t\t\tauthenticatedUser = Context.getAuthenticatedUser();\n+\t\t\treturn;\n+\t\t}\n+\t\tcatch (ContextAuthenticationException wrongCredentialsError) {\n+\t\t\tif (useInMemoryDatabase()) {\n+\t\t\t\t// if we get here the user is using some database other than the standard\n+\t\t\t\t// in-memory database, prompt the user for input\n+\t\t\t\tlog.error(\"For some reason we couldn't auth as admin:test ?!\", wrongCredentialsError);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tInteger attempts = 0;\n+\t\t\n+\t\t// TODO: how to make this a locale specific message for the user to see?\n+\t\tString message = null;\n+\t\t\n+\t\t// only need to authenticate once per session\n+\t\twhile (!Context.isAuthenticated() && attempts < 3) {\n+\t\t\t\n+\t\t\t// look in the runtime properties for a defined username and\n+\t\t\t// password first\n+\t\t\tString junitusername = null;\n+\t\t\tString junitpassword = null;\n+\t\t\t\n+\t\t\ttry {\n+\t\t\t\tProperties props = this.getRuntimeProperties();\n+\t\t\t\tjunitusername = props.getProperty(\"junit.username\");\n+\t\t\t\tjunitpassword = props.getProperty(\"junit.password\");\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\t// if anything happens just default to asking the user\n+\t\t\t}\n+\t\t\t\n+\t\t\tString[] credentials = null;\n+\t\t\t\n+\t\t\t// ask the user for creds if no junit username/pass defined\n+\t\t\t// in the runtime properties or if that username/pass failed already\n+\t\t\tif (junitusername == null || junitpassword == null || attempts > 0) {\n+\t\t\t\tcredentials = askForUsernameAndPassword(message);\n+\t\t\t\t// credentials are null if the user clicked \"cancel\" in popup\n+\t\t\t\tif (credentials == null)\n+\t\t\t\t\treturn;\n+\t\t\t} else\n+\t\t\t\tcredentials = new String[] { junitusername, junitpassword };\n+\t\t\t\n+\t\t\t// try to authenticate to the Context with either the runtime\n+\t\t\t// defined credentials or the user supplied credentials from the\n+\t\t\t// popup\n+\t\t\ttry {\n+\t\t\t\tContext.authenticate(credentials[0], credentials[1]);\n+\t\t\t\tauthenticatedUser = Context.getAuthenticatedUser();\n+\t\t\t}\n+\t\t\tcatch (ContextAuthenticationException e) {\n+\t\t\t\tmessage = \"Invalid username/password.  Try again.\";\n+\t\t\t}\n+\t\t\t\n+\t\t\tattempts++;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Utility method for obtaining username and password through Swing interface for tests. Any\n+\t * tests extending the org.openmrs.BaseTest class may simply invoke this method by name.\n+\t * Username and password are returned in a two-member String array. If the user aborts, null is\n+\t * returned. <b> <em>Do not call for non-interactive tests, since this method will try to\n+\t * render an interactive dialog box for authentication!</em></b>\n+\t * \n+\t * @param message string to display above username field\n+\t * @return Two-member String array containing username and password, respectively, or\n+\t *         <code>null</code> if user aborts dialog\n+\t */\n+\tpublic static synchronized String[] askForUsernameAndPassword(String message) {\n+\t\t\n+\t\ttry {\n+\t\t\tUIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n+\t\t}\n+\t\tcatch (Exception e) {\n+\n+\t\t}\n+\t\t\n+\t\tif (message == null || \"\".equals(message))\n+\t\t\tmessage = \"Enter username/password to authenticate to OpenMRS...\";\n+\t\t\n+\t\tJPanel panel = new JPanel(new GridBagLayout());\n+\t\tJLabel usernameLabel = new JLabel(\"Username\");\n+\t\tusernameLabel.setFont(font);\n+\t\tusernameField = new JTextField(20);\n+\t\tusernameField.setFont(font);\n+\t\tJLabel passwordLabel = new JLabel(\"Password\");\n+\t\tpasswordLabel.setFont(font);\n+\t\tJPasswordField passwordField = new JPasswordField(20);\n+\t\tpasswordField.setFont(font);\n+\t\tpanel.add(usernameLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.EAST,\n+\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 5, 0));\n+\t\tpanel.add(usernameField, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.WEST,\n+\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\n+\t\tpanel.add(passwordLabel, new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.EAST,\n+\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 5, 0));\n+\t\tpanel.add(passwordField, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.WEST,\n+\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\n+\t\t\n+\t\tframe = new JFrame();\n+\t\tWindow window = new Window(frame);\n+\t\tframe.setVisible(true);\n+\t\tframe.setTitle(\"JUnit Test Credentials\");\n+\t\t\n+\t\t// We use a TimerTask to force focus on username, but still use\n+\t\t// JOptionPane for model dialog\n+\t\tTimerTask later = new TimerTask() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tif (frame != null) {\n+\t\t\t\t\t// bring the dialog's window to the front\n+\t\t\t\t\tframe.toFront();\n+\t\t\t\t\tusernameField.grabFocus();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\t// try setting focus half a second from now\n+\t\tnew Timer().schedule(later, 500);\n+\t\t\n+\t\t// attention grabber for those people that aren't as observant\n+\t\tTimerTask laterStill = new TimerTask() {\n+\t\t\t\n+\t\t\t@Override\n+\t\t\tpublic void run() {\n+\t\t\t\tif (frame != null) {\n+\t\t\t\t\tframe.toFront(); // bring the dialog's window to the\n+\t\t\t\t\t// front\n+\t\t\t\t\tusernameField.grabFocus();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t};\n+\t\t// if the user hasn't done anything in 10 seconds, tell them the window\n+\t\t// is there\n+\t\tnew Timer().schedule(laterStill, 10000);\n+\t\t\n+\t\t// show the dialog box\n+\t\tint response = JOptionPane.showConfirmDialog(window, panel, message, JOptionPane.OK_CANCEL_OPTION);\n+\t\t\n+\t\t// clear out the window so the timer doesn't screw up\n+\t\tlaterStill.cancel();\n+\t\tframe.setVisible(false);\n+\t\twindow.setVisible(false);\n+\t\tframe = null;\n+\t\t\n+\t\t// response of 2 is the cancel button, response of -1 is the little red\n+\t\t// X in the top right\n+\t\treturn (response == 2 || response == -1 ? null : new String[] { usernameField.getText(),\n+\t\t        String.valueOf(passwordField.getPassword()) });\n+\t}\n+\t\n+\t/**\n+\t * Override this method to turn on/off the in-memory database. The default is to use the\n+\t * in-memory database. When this method returns false, the database defined by the runtime\n+\t * properties is used instead\n+\t * \n+\t * @return true/false whether or not to use an in memory database\n+\t */\n+\tpublic Boolean useInMemoryDatabase() {\n+\t\treturn !\"false\".equals(System.getProperty(\"useInMemoryDatabase\"));\n+\t}\n+\t\n+\t/**\n+\t * Get the database connection currently in use by the testing framework.\n+\t * <p>\n+\t * Note that if you commit a transaction, any changes done by a test will not be rolled back and\n+\t * you will need to clean up yourself by calling for example {@link #deleteAllData()}.\n+\t * \n+\t * @return Connection jdbc connection to the database\n+\t */\n+\tpublic Connection getConnection() {\n+\t\tSessionFactory sessionFactory = (SessionFactory) applicationContext.getBean(\"sessionFactory\");\n+\t\t\n+\t\treturn sessionFactory.getCurrentSession().doReturningWork(connection -> connection);\n+\t}\n+\t\n+\t/**\n+\t * This initializes the empty in-memory database with some rows in order to actually run some\n+\t * tests\n+\t *\n+\t * @throws SQLException\n+\t * @throws Exception\n+\t */\n+\tpublic void initializeInMemoryDatabase() throws SQLException {\n+\t\t//Don't allow the user to overwrite data\n+\t\tif (!useInMemoryDatabase())\n+\t\t\tthrow new RuntimeException(\n+\t\t\t        \"You shouldn't be initializing a NON in-memory database. Consider unoverriding useInMemoryDatabase\");\n+\n+\t\t//Because creator property in the superclass is mapped with optional set to false, the autoddl tool marks the \n+\t\t//column as not nullable but for person it is actually nullable, we need to first drop the constraint from \n+\t\t//person.creator column, historically this was to allow inserting the very first row. Ideally, this should not \n+\t\t//be necessary outside of tests because tables are created using liquibase and not autoddl\n+\t\tdropNotNullConstraint(\"person\", \"creator\");\n+\t\tsetAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator();\n+\t\texecuteDataSet(INITIAL_XML_DATASET_PACKAGE_PATH);\n+\t}\n+\n+\tpublic void setAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator() throws SQLException {\n+\t\t/*\n+\t\t * Hbm2ddl used in tests creates primary key columns, which are not auto incremented if\n+\t\t * NativeIfNotAssignedIdentityGenerator is used. We need to alter those columns in tests.\n+\t\t */\n+\t\tList<String> tables = Collections.singletonList(\"concept\");\n+\t\tfor (String table : tables) {\n+\t\t\tgetConnection().prepareStatement(\"ALTER TABLE \" + table + \" ALTER COLUMN \" + table + \"_id INT AUTO_INCREMENT\")\n+\t\t\t\t\t.execute();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Drops the not null constraint from the the specified column in the specified table\n+\t *\n+\t * @param columnName the column from which to remove the constraint\n+\t * @param tableName the table that contains the column\n+\t * @throws SQLException\n+\t */\n+\tprotected void dropNotNullConstraint(String tableName, String columnName) throws SQLException {\n+\t\tif (!useInMemoryDatabase()) {\n+\t\t\tthrow new RuntimeException(\"Altering column nullability is not supported for a non in-memory database\");\n+\t\t}\n+\t\tfinal String sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + columnName + \" SET NULL\";\n+\t\tDatabaseUtil.executeSQL(getConnection(), sql, false);\n+\t}\n+\n+\t/**\n+\t * Note that with the H2 DB this operation always commits an open transaction.\n+\t * \n+\t * @param connection\n+\t * @throws SQLException\n+\t */\n+\tprotected void turnOnDBConstraints(Connection connection) throws SQLException {\n+\t\tString constraintsOnSql;\n+\t\tif (useInMemoryDatabase()) {\n+\t\t\tconstraintsOnSql = \"SET REFERENTIAL_INTEGRITY TRUE\";\n+\t\t} else {\n+\t\t\tconstraintsOnSql = \"SET FOREIGN_KEY_CHECKS=1;\";\n+\t\t}\n+\t\tPreparedStatement ps = connection.prepareStatement(constraintsOnSql);\n+\t\tps.execute();\n+\t\tps.close();\n+\t}\n+\t\n+\tprotected void turnOffDBConstraints(Connection connection) throws SQLException {\n+\t\tString constraintsOffSql;\n+\t\tif (useInMemoryDatabase()) {\n+\t\t\tconstraintsOffSql = \"SET REFERENTIAL_INTEGRITY FALSE\";\n+\t\t} else {\n+\t\t\tconstraintsOffSql = \"SET FOREIGN_KEY_CHECKS=0;\";\n+\t\t}\n+\t\tPreparedStatement ps = connection.prepareStatement(constraintsOffSql);\n+\t\tps.execute();\n+\t\tps.close();\n+\t}\n+\t\n+\t/**\n+\t * Used by {@link #executeDataSet(String)} to cache the parsed xml files. This speeds up\n+\t * subsequent runs of the dataset\n+\t */\n+\tprivate static Map<String, IDataSet> cachedDatasets = new HashMap<>();\n+\t\n+\t/**\n+\t * Runs the flat xml data file at the classpath location specified by\n+\t * <code>datasetFilename</code> This is a convenience method. It simply creates an\n+\t * {@link IDataSet} and calls {@link #executeDataSet(IDataSet)}\n+\t * \n+\t * @param datasetFilename String path/filename on the classpath of the xml data set to clean\n+\t *            insert into the current database\n+\t * @see #getConnection()\n+\t * @see #executeDataSet(IDataSet)\n+\t */\n+\tpublic void executeDataSet(String datasetFilename) {\n+\t\t\n+\t\t// try to get the given filename from the cache\n+\t\tIDataSet xmlDataSetToRun = cachedDatasets.get(datasetFilename);\n+\t\t\n+\t\t// if we didn't find it in the cache, load it\n+\t\tif (xmlDataSetToRun == null) {\n+\t\t\tFile file = new File(datasetFilename);\n+\t\t\t\n+\t\t\tInputStream fileInInputStreamFormat = null;\n+\t\t\tReader reader = null;\n+\t\t\ttry {\n+\t\t\t\ttry {\n+\t\t\t\t\t// try to load the file if its a straight up path to the file or\n+\t\t\t\t\t// if its a classpath path to the file\n+\t\t\t\t\tif (file.exists()) {\n+\t\t\t\t\t\tfileInInputStreamFormat = new FileInputStream(datasetFilename);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tfileInInputStreamFormat = getClass().getClassLoader().getResourceAsStream(datasetFilename);\n+\t\t\t\t\t\tif (fileInInputStreamFormat == null)\n+\t\t\t\t\t\t\tthrow new FileNotFoundException(\"Unable to find '\" + datasetFilename + \"' in the classpath\");\n+\t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\treader = new InputStreamReader(fileInInputStreamFormat, StandardCharsets.UTF_8);\n+\t\t\t\t\tReplacementDataSet replacementDataSet = new ReplacementDataSet(\n+\t\t\t\t\t        new FlatXmlDataSet(reader, false, true, false));\n+\t\t\t\t\treplacementDataSet.addReplacementObject(\"[NULL]\", null);\n+\t\t\t\t\txmlDataSetToRun = replacementDataSet;\n+\t\t\t\t\t\n+\t\t\t\t\treader.close();\n+\t\t\t\t}\n+\t\t\t\tcatch (DataSetException | IOException e) {\n+\t\t\t\t\tthrow new DatabaseUnitRuntimeException(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tIOUtils.closeQuietly(fileInInputStreamFormat);\n+\t\t\t\tIOUtils.closeQuietly(reader);\n+\t\t\t}\n+\t\t\t\n+\t\t\t// cache the xmldataset for future runs of this file\n+\t\t\tcachedDatasets.put(datasetFilename, xmlDataSetToRun);\n+\t\t}\n+\t\t\n+\t\texecuteDataSet(xmlDataSetToRun);\n+\t}\n+\t\n+\t/**\n+\t * Runs the large flat xml dataset. It does not cache the file as opposed to\n+\t * {@link #executeDataSet(String)}.\n+\t * \n+\t * @param datasetFilename\n+\t * @throws Exception\n+\t * @since 1.10\n+\t */\n+\tpublic void executeLargeDataSet(String datasetFilename) throws Exception {\n+\t\tInputStream inputStream = null;\n+\t\ttry {\n+\t\t\tfinal File file = new File(datasetFilename);\n+\t\t\tif (file.exists()) {\n+\t\t\t\tinputStream = new FileInputStream(datasetFilename);\n+\t\t\t} else {\n+\t\t\t\tinputStream = getClass().getClassLoader().getResourceAsStream(datasetFilename);\n+\t\t\t\tif (inputStream == null)\n+\t\t\t\t\tthrow new FileNotFoundException(\"Unable to find '\" + datasetFilename + \"' in the classpath\");\n+\t\t\t}\n+\t\t\t\n+\t\t\tfinal FlatXmlProducer flatXmlProducer = new FlatXmlProducer(new InputSource(inputStream));\n+\t\t\tfinal StreamingDataSet streamingDataSet = new StreamingDataSet(flatXmlProducer);\n+\t\t\t\n+\t\t\tfinal ReplacementDataSet replacementDataSet = new ReplacementDataSet(streamingDataSet);\n+\t\t\treplacementDataSet.addReplacementObject(\"[NULL]\", null);\n+\t\t\t\n+\t\t\texecuteDataSet(replacementDataSet);\n+\t\t\t\n+\t\t\tinputStream.close();\n+\t\t}\n+\t\tfinally {\n+\t\t\tIOUtils.closeQuietly(inputStream);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Runs the xml data file at the classpath location specified by <code>datasetFilename</code>\n+\t * using XmlDataSet. It simply creates an {@link IDataSet} and calls\n+\t * {@link #executeDataSet(IDataSet)}. <br>\n+\t * <br>\n+\t * This method is different than {@link #executeDataSet(String)} in that this one does not\n+\t * expect a flat file xml but instead a true XmlDataSet. <br>\n+\t * <br>\n+\t * In addition, there is no replacing of [NULL] values in strings.\n+\t * \n+\t * @param datasetFilename String path/filename on the classpath of the xml data set to clean\n+\t *            insert into the current database\n+\t * @see #getConnection()\n+\t * @see #executeDataSet(IDataSet)\n+\t */\n+\tpublic void executeXmlDataSet(String datasetFilename) throws Exception {\n+\t\t\n+\t\t// try to get the given filename from the cache\n+\t\tIDataSet xmlDataSetToRun = cachedDatasets.get(datasetFilename);\n+\t\t\n+\t\t// if we didn't find it in the cache, load it\n+\t\tif (xmlDataSetToRun == null) {\n+\t\t\tFile file = new File(datasetFilename);\n+\t\t\t\n+\t\t\tInputStream fileInInputStreamFormat = null;\n+\t\t\t\n+\t\t\ttry {\n+\t\t\t\t// try to load the file if its a straight up path to the file or\n+\t\t\t\t// if its a classpath path to the file\n+\t\t\t\tif (file.exists())\n+\t\t\t\t\tfileInInputStreamFormat = new FileInputStream(datasetFilename);\n+\t\t\t\telse {\n+\t\t\t\t\tfileInInputStreamFormat = getClass().getClassLoader().getResourceAsStream(datasetFilename);\n+\t\t\t\t\tif (fileInInputStreamFormat == null)\n+\t\t\t\t\t\tthrow new FileNotFoundException(\"Unable to find '\" + datasetFilename + \"' in the classpath\");\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\tXmlDataSet xmlDataSet = null;\n+\t\t\t\txmlDataSet = new XmlDataSet(fileInInputStreamFormat);\n+\t\t\t\txmlDataSetToRun = xmlDataSet;\n+\t\t\t\t\n+\t\t\t\tfileInInputStreamFormat.close();\n+\t\t\t}\n+\t\t\tfinally {\n+\t\t\t\tIOUtils.closeQuietly(fileInInputStreamFormat);\n+\t\t\t}\n+\t\t\t\n+\t\t\t// cache the xmldataset for future runs of this file\n+\t\t\tcachedDatasets.put(datasetFilename, xmlDataSetToRun);\n+\t\t}\n+\t\t\n+\t\texecuteDataSet(xmlDataSetToRun);\n+\t}\n+\t\n+\t/**\n+\t * Run the given dataset specified by the <code>dataset</code> argument\n+\t * \n+\t * @param dataset IDataSet to run on the current database used by Spring\n+\t * @see #getConnection()\n+\t */\n+\tpublic void executeDataSet(IDataSet dataset) {\n+\t\ttry {\n+\t\t\tConnection connection = getConnection();\n+\t\t\t\n+\t\t\tIDatabaseConnection dbUnitConn = setupDatabaseConnection(connection);\n+\t\t\t\n+\t\t\t//Do the actual update/insert:\n+\t\t\t//insert new rows, update existing rows, and leave others alone\n+\t\t\tDatabaseOperation.REFRESH.execute(dbUnitConn, dataset);\n+\t\t}\n+\t\tcatch (DatabaseUnitException | SQLException e) {\n+\t\t\tthrow new DatabaseUnitRuntimeException(e);\n+\t\t}\n+\t}\n+\t\n+\tprotected IDatabaseConnection setupDatabaseConnection(Connection connection) throws DatabaseUnitException {\n+\t\tIDatabaseConnection dbUnitConn = new DatabaseConnection(connection);\n+\t\t\n+\t\tif (useInMemoryDatabase()) {\n+\t\t\t//Setup the db connection to use H2 config.\n+\t\t\tDatabaseConfig config = dbUnitConn.getConfig();\n+\t\t\tconfig.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());\n+\t\t}\n+\t\t\n+\t\treturn dbUnitConn;\n+\t}\n+\t\n+\t/**\n+\t * This is a convenience method to clear out all rows in all tables in the current connection.\n+\t * <p>\n+\t * This operation always results in a commit.\n+\t * \n+\t * @throws Exception\n+\t */\n+\tpublic void deleteAllData() {\n+\t\ttry {\n+\t\t\tContext.clearSession();\n+\t\t\t\n+\t\t\tConnection connection = getConnection();\n+\t\t\t\n+\t\t\tturnOffDBConstraints(connection);\n+\t\t\t\n+\t\t\tIDatabaseConnection dbUnitConn = setupDatabaseConnection(connection);\n+\t\t\t\n+\t\t\t// find all the tables for this connection\n+\t\t\tResultSet resultSet = connection.getMetaData().getTables(null, \"PUBLIC\", \"%\", null);\n+\t\t\tDefaultDataSet dataset = new DefaultDataSet();\n+\t\t\twhile (resultSet.next()) {\n+\t\t\t\tString tableName = resultSet.getString(3);\n+\t\t\t\tdataset.addTable(new DefaultTable(tableName));\n+\t\t\t}\n+\t\t\t\n+\t\t\t// do the actual deleting/truncating\n+\t\t\tDatabaseOperation.DELETE_ALL.execute(dbUnitConn, dataset);\n+\t\t\t\n+\t\t\tturnOnDBConstraints(connection);\n+\t\t\t\n+\t\t\tconnection.commit();\n+\t\t\t\n+\t\t\tupdateSearchIndex();\n+\t\t\t\n+\t\t\tisBaseSetup = false;\n+\t\t}\n+\t\tcatch (SQLException | DatabaseUnitException e) {\n+\t\t\tthrow new DatabaseUnitRuntimeException(e);\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Method to clear the hibernate cache\n+\t */\n+\t@BeforeEach\n+\tpublic void clearHibernateCache() {\n+\t\tSessionFactory sf = (SessionFactory) applicationContext.getBean(\"sessionFactory\");\n+\t\tsf.getCache().evictCollectionRegions();\n+\t\tsf.getCache().evictEntityRegions();\n+\t}\n+\t\n+\t/**\n+\t * This method is run before all test methods that extend this {@link BaseContextSensitiveTest}\n+\t * unless you annotate your method with the \"@SkipBaseSetup\" annotation After running this\n+\t * method an in-memory database will be available that has the content of the rows from\n+\t * {@link #INITIAL_XML_DATASET_PACKAGE_PATH} and {@link #EXAMPLE_XML_DATASET_PACKAGE_PATH} xml\n+\t * files. This method will also ask to be authenticated against the current Context and\n+\t * database. The {@link #initializeInMemoryDatabase()} method has a user of admin:test.\n+\t * <p>\n+\t * If you annotate a test with \"@SkipBaseSetup\", this method will call {@link #deleteAllData()},\n+\t * but only if you use the in memory DB.\n+\t * \n+\t * @throws SQLException\n+\t * @see SkipBaseSetup\n+\t * @see SkipBaseSetupAnnotationExecutionListener\n+\t * @see #initializeInMemoryDatabase()\n+\t * @see #authenticate()\n+\t */\n+\t@BeforeEach\n+\tpublic void baseSetupWithStandardDataAndAuthentication() throws SQLException {\n+\t\t// Open a session if needed\n+\t\tif (!Context.isSessionOpen()) {\n+\t\t\tContext.openSession();\n+\t\t}\n+\t\t\n+\t\t// The skipBaseSetup flag is controlled by the @SkipBaseSetup annotation. \t\tif (useInMemoryDatabase()) {\n+\t\tif (!skipBaseSetup) {\n+\t\t\tif (!isBaseSetup) {\n+\t\t\t\t\n+\t\t\t\tdeleteAllData();\n+\t\t\t\t\n+\t\t\t\tif (useInMemoryDatabase()) {\n+\t\t\t\t\tinitializeInMemoryDatabase();\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\texecuteDataSet(INITIAL_XML_DATASET_PACKAGE_PATH);\n+\t\t\t\t}\n+\t\t\t\t\n+\t\t\t\texecuteDataSet(EXAMPLE_XML_DATASET_PACKAGE_PATH);\n+\t\t\t\t\n+\t\t\t\t//Commit so that it is not rolled back after a test.\n+\t\t\t\tgetConnection().commit();\n+\n+\t\t\t\tupdateSearchIndex();\n+\t\t\t\t\n+\t\t\t\tisBaseSetup = true;\n+\t\t\t}\n+\t\t\t\n+\t\t\tauthenticate();\n+\t\t} else {\n+\t\t\tif (isBaseSetup) {\n+\t\t\t\tdeleteAllData();\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\tContext.clearSession();\n+\t}\n+\t\n+\tpublic Class<?>[] getIndexedTypes() {\n+\t\treturn new Class<?>[] { ConceptName.class, Drug.class, PersonName.class, PersonAttribute.class,\n+\t\t\t\tPatientIdentifier.class};\n+\t}\n+\t\n+\t/**\n+\t * It needs to be call if you want to do a concept search after you modify a concept in a test.\n+\t * It is because index is automatically updated only after transaction is committed, which\n+\t * happens only at the end of a test in our transactional tests.\n+\t */\n+\tpublic void updateSearchIndex() {\n+\t\tfor (Class<?> indexType : getIndexedTypes()) {\n+\t\t\tContext.updateSearchIndexForType(indexType);\n+\t\t}\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void clearSessionAfterEachTest() {\n+\t\t// clear the session to make sure nothing is cached, etc\n+\t\tContext.clearSession();\n+\t\t\n+\t\t// needed because the authenticatedUser is the only object that sticks\n+\t\t// around after tests and the clearSession call\n+\t\tif (Context.isSessionOpen())\n+\t\t\tContext.logout();\n+\t}\n+\t\n+\t/**\n+\t * Called after each test class. This is called once per test class that extends\n+\t * {@link BaseContextSensitiveTest}. Needed so that \"unit of work\" that is the test class is\n+\t * surrounded by a pair of open/close session calls.\n+\t * \n+\t * @throws Exception\n+\t */\n+\t@AfterAll\n+\tpublic static void closeSessionAfterEachClass() throws Exception {\n+\t\t//Some tests add data via executeDataset()\n+\t\t//We need to delete it in order not to interfere with others\n+\t\tif (instance != null) {\n+\t\t\ttry {\n+\t\t\t\tinstance.deleteAllData();\n+\t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\t//No need to worry about this\n+\t\t\t}\n+\t\t\tinstance = null;\n+\t\t}\n+\t\t\n+\t\t// clean up the session so we don't leak memory\n+\t\tif (Context.isSessionOpen()) {\n+\t\t\tContext.closeSession();\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Instance variable used by the {@link #baseSetupWithStandardDataAndAuthentication()} method to\n+\t * know whether the current \"@Test\" method has asked to be _not_ do the initialize/standard\n+\t * data/authenticate\n+\t * \n+\t * @see SkipBaseSetup\n+\t * @see SkipBaseSetupAnnotationExecutionListener\n+\t * @see #baseSetupWithStandardDataAndAuthentication()\n+\t */\n+\tprivate boolean skipBaseSetup = false;\n+\t\n+\t/**\n+\t * Don't run the {@link #setupDatabaseWithStandardData()} method. This means that the associated\n+\t * \"@Test\" must call one of these:\n+\t * \n+\t * <pre>\n+\t *  * initializeInMemoryDatabase() ;\n+\t *  * executeDataSet(EXAMPLE_DATA_SET);\n+\t *  * Authenticate\n+\t * </pre>\n+\t * \n+\t * on its own if any of those results are needed. This method is called before all \"@Test\"\n+\t * methods that have been annotated with the \"@SkipBaseSetup\" annotation.\n+\t * \n+\t * @throws Exception\n+\t * @see SkipBaseSetup\n+\t * @see SkipBaseSetupAnnotationExecutionListener\n+\t * @see #baseSetupWithStandardDataAndAuthentication()\n+\t */\n+\tpublic void skipBaseSetup() throws Exception {\n+\t\tskipBaseSetup = true;\n+\t}\n+\t\n+}", "originalCommit": "17b101eda2cbf3c28cd6130af031e277bc516a0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2NzI0MA==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545167240", "bodyText": "ok thanks let me collect it", "author": "sherrif10", "createdAt": "2020-12-17T15:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2NTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE3NDQwOA==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545174408", "bodyText": "Finished thanks", "author": "sherrif10", "createdAt": "2020-12-17T15:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2NTg0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyNjk3Nw==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545226977", "bodyText": "I think now its LGTM   for 2.4.x its was already captured cc @mks-d  @dkayiwa", "author": "sherrif10", "createdAt": "2020-12-17T16:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE2NTg0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "9fe1baadb803ef2f1dd9092502bb2470ca738f57", "chunk": "diff --git a/api/src/test/java/org/openmrs/test/jupiter/BaseContextSensitiveTest.java b/api/src/test/java/org/openmrs/test/jupiter/BaseContextSensitiveTest.java\nindex affbe6423..e69de29bb 100644\n--- a/api/src/test/java/org/openmrs/test/jupiter/BaseContextSensitiveTest.java\n+++ b/api/src/test/java/org/openmrs/test/jupiter/BaseContextSensitiveTest.java\n\n@@ -1,1027 +0,0 @@\n-/**\n- * This Source Code Form is subject to the terms of the Mozilla Public License,\n- * v. 2.0. If a copy of the MPL was not distributed with this file, You can\n- * obtain one at http://mozilla.org/MPL/2.0/. OpenMRS is also distributed under\n- * the terms of the Healthcare Disclaimer located at http://openmrs.org/license.\n- *\n- * Copyright (C) OpenMRS Inc. OpenMRS is a registered trademark and the OpenMRS\n- * graphic logo is a trademark of OpenMRS Inc.\n- */\n-package org.openmrs.test.jupiter;\n-\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-import static org.springframework.test.context.TestExecutionListeners.MergeMode.MERGE_WITH_DEFAULTS;\n-\n-import javax.swing.*;\n-import java.awt.*;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-import java.nio.charset.StandardCharsets;\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.Timer;\n-import java.util.TimerTask;\n-\n-import org.apache.commons.io.IOUtils;\n-import org.apache.commons.lang3.ArrayUtils;\n-import org.apache.commons.lang3.StringUtils;\n-import org.dbunit.DatabaseUnitException;\n-import org.dbunit.DatabaseUnitRuntimeException;\n-import org.dbunit.database.DatabaseConfig;\n-import org.dbunit.database.DatabaseConnection;\n-import org.dbunit.database.IDatabaseConnection;\n-import org.dbunit.dataset.DataSetException;\n-import org.dbunit.dataset.DefaultDataSet;\n-import org.dbunit.dataset.DefaultTable;\n-import org.dbunit.dataset.IDataSet;\n-import org.dbunit.dataset.ReplacementDataSet;\n-import org.dbunit.dataset.stream.StreamingDataSet;\n-import org.dbunit.dataset.xml.FlatXmlDataSet;\n-import org.dbunit.dataset.xml.FlatXmlProducer;\n-import org.dbunit.dataset.xml.XmlDataSet;\n-import org.dbunit.ext.h2.H2DataTypeFactory;\n-import org.dbunit.operation.DatabaseOperation;\n-import org.hibernate.SessionFactory;\n-import org.hibernate.cfg.Environment;\n-import org.hibernate.dialect.H2Dialect;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.AfterEach;\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.extension.ExtendWith;\n-import org.mockito.InjectMocks;\n-import org.mockito.junit.jupiter.MockitoExtension;\n-import org.openmrs.ConceptName;\n-import org.openmrs.Drug;\n-import org.openmrs.PatientIdentifier;\n-import org.openmrs.PersonAttribute;\n-import org.openmrs.PersonName;\n-import org.openmrs.User;\n-import org.openmrs.annotation.OpenmrsProfileExcludeFilter;\n-import org.openmrs.api.context.Context;\n-import org.openmrs.api.context.ContextAuthenticationException;\n-import org.openmrs.api.context.ContextMockHelper;\n-import org.openmrs.api.context.Credentials;\n-import org.openmrs.api.context.UsernamePasswordCredentials;\n-import org.openmrs.module.ModuleConstants;\n-import org.openmrs.test.SkipBaseSetup;\n-import org.openmrs.test.SkipBaseSetupAnnotationExecutionListener;\n-import org.openmrs.test.TestUtil;\n-import org.openmrs.util.DatabaseUtil;\n-import org.openmrs.util.OpenmrsClassLoader;\n-import org.openmrs.util.OpenmrsConstants;\n-import org.openmrs.util.OpenmrsUtil;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.context.ApplicationContext;\n-import org.springframework.test.annotation.Rollback;\n-import org.springframework.test.context.ContextConfiguration;\n-import org.springframework.test.context.TestExecutionListeners;\n-import org.springframework.test.context.junit.jupiter.SpringExtension;\n-import org.springframework.transaction.annotation.Transactional;\n-import org.xml.sax.InputSource;\n-\n-/**\n- * This is the base for spring/context tests. Tests that NEED to use calls to the Context class and\n- * use Services and/or the database should extend this class. NOTE: Tests that do not need access to\n- * spring enabled services do not need this class and extending this will only slow those test cases\n- * down. (because spring is started before test cases are run). Normal test cases do not need to\n- * extend anything.\n- * \n- * Use this class for Junit 5 tests.\n- * \n- * @since 2.4.0\n- */\n-@ContextConfiguration(locations = { \"classpath:applicationContext-service.xml\", \"classpath*:openmrs-servlet.xml\",\n-        \"classpath*:moduleApplicationContext.xml\", \"classpath*:TestingApplicationContext.xml\" })\n-@TestExecutionListeners(\n-\tlisteners = { SkipBaseSetupAnnotationExecutionListener.class,\n-\t\tStartModuleExecutionListener.class },\n-        mergeMode = MERGE_WITH_DEFAULTS\n-)\n-@Transactional\n-@Rollback\n-@ExtendWith(SpringExtension.class)\n-@ExtendWith(MockitoExtension.class)\n-public abstract class BaseContextSensitiveTest {\n-\t\n-\tprivate static final Logger log = LoggerFactory.getLogger(BaseContextSensitiveTest.class);\n-\t\n-\t/**\n-\t * Only the classpath/package path and filename of the initial dataset\n-\t */\n-\tprotected static final String INITIAL_XML_DATASET_PACKAGE_PATH = \"org/openmrs/include/initialInMemoryTestDataSet.xml\";\n-\t\n-\tprotected static final String EXAMPLE_XML_DATASET_PACKAGE_PATH = \"org/openmrs/include/standardTestDataset.xml\";\n-\t\n-\t/**\n-\t * cached runtime properties\n-\t */\n-\tprotected static Properties runtimeProperties;\n-\t\n-\t/**\n-\t * Used for username/password dialog\n-\t */\n-\tprivate static final Font font = new Font(\"Arial\", Font.BOLD, 16);\n-\t\n-\t/**\n-\t * Our username field is outside of the getUsernameAndPassword() method so we can do our\n-\t * force-focus-on-the-username-field trick -- i.e., refer to the field within an anonymous\n-\t * TimerTask method.\n-\t */\n-\tprivate static JTextField usernameField;\n-\t\n-\t/**\n-\t * This frame contains the password dialog box. In order to bring the frame to the front in the\n-\t * TimerTask method, we make it a private field\n-\t */\n-\tprivate static Frame frame;\n-\t\n-\t/**\n-\t * Static variable to keep track of the number of times this class has been loaded (aka, number\n-\t * of tests already run)\n-\t */\n-\tprivate static Integer loadCount = 0;\n-\t\n-\t/**\n-\t * Allows to determine if the DB is initialized with standard data\n-\t */\n-\tprivate static boolean isBaseSetup;\n-\t\n-\t/**\n-\t * Stores a user authenticated for running tests which allows to discover a situation when some\n-\t * test authenticates as a different user and we need to revert to the original one\n-\t */\n-\tprivate User authenticatedUser;\n-\t\n-\t@Autowired\n-\tprotected ApplicationContext applicationContext;\n-\t/**\n-\t * Allows mocking services returned by Context. See {@link ContextMockHelper}\n-\t * \n-\t * @since 1.11, 1.10, 1.9.9\n-\t */\n-\t@InjectMocks\n-\tprotected ContextMockHelper contextMockHelper;\n-\t\n-\tprivate static volatile BaseContextSensitiveTest instance;\n-\t\n-\t/**\n-\t * Basic constructor for the super class to all openmrs api unit tests. This constructor sets up\n-\t * the classloader and the properties file so that by the type spring gets around to finally\n-\t * starting, the openmrs runtime properties are already in place A static load count is kept to\n-\t * count the number of times this class has been loaded.\n-\t * \n-\t * @see #getLoadCount()\n-\t */\n-\tpublic BaseContextSensitiveTest() {\n-\t\t\n-\t\tThread.currentThread().setContextClassLoader(OpenmrsClassLoader.getInstance());\n-\t\t\n-\t\tProperties props = getRuntimeProperties();\n-\t\t\n-\t\tif (log.isDebugEnabled())\n-\t\t\tlog.debug(\"props: \" + props);\n-\t\t\n-\t\tContext.setRuntimeProperties(props);\n-\t\t\n-\t\tloadCount++;\n-\t\t\n-\t\tinstance = this;\n-\t}\n-\t\n-\t/**\n-\t * @since 1.11, 1.10, 1.9.9\n-\t */\n-\t@AfterEach\n-\tpublic void revertContextMocks() {\n-\t\tcontextMockHelper.revertMocks();\n-\t}\n-\t\n-\t/**\n-\t * Modules should extend {@link BaseModuleContextSensitiveTest}, not this class. If they extend\n-\t * this class, then they won't work right when run in batches.\n-\t * \n-\t * @throws Exception\n-\t */\n-\t@BeforeEach\n-\tpublic void checkNotModule() throws Exception {\n-\t\tif (this.getClass().getPackage().toString().contains(\"org.openmrs.module.\") && !(this instanceof BaseContextSensitiveTest)) {\n-\t\t\tthrow new RuntimeException(\"Module unit test classes should extend BaseModuleContextSensitiveTest, not just BaseContextSensitiveTest\");\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Allows to ignore the test if the environment does not match the given parameters.\n-\t * \n-\t * @param openmrsPlatformVersion\n-\t * @param modules\n-\t * @since 1.11.3, 1.10.2, 1.9.9\n-\t */\n-\tpublic void assumeOpenmrsProfile(String openmrsPlatformVersion, String... modules) {\n-\t\tOpenmrsProfileExcludeFilter filter = new OpenmrsProfileExcludeFilter();\n-\t\tMap<String, Object> profile = new HashMap<>();\n-\t\tprofile.put(\"openmrsPlatformVersion\", openmrsPlatformVersion);\n-\t\tif (modules != null) {\n-\t\t\tprofile.put(\"modules\", modules);\n-\t\t} else {\n-\t\t\tprofile.put(\"modules\", new String[0]);\n-\t\t}\n-\t\tString errorMessage = \"Ignored. Expected profile: {openmrsPlatformVersion=\" + openmrsPlatformVersion + \", modules=[\"\n-\t\t        + StringUtils.join((String[]) profile.get(\"modules\"), \", \") + \"]}\";\n-\t\tassumeTrue(filter.matchOpenmrsProfileAttributes(profile), errorMessage);\n-\t}\n-\t\n-\t/**\n-\t * Allows to ignore the test if the given modules are not running.\n-\t * \n-\t * @param module in the format moduleId:version\n-\t * @param modules additional list of modules in the format moduleId:version\n-\t * @since 1.11.3, 1.10.2, 1.9.9\n-\t */\n-\tpublic void assumeOpenmrsModules(String module, String... modules) {\n-\t\tString[] allModules = ArrayUtils.addAll(modules, module);\n-\t\tassumeOpenmrsProfile(null, allModules);\n-\t}\n-\t\n-\t/**\n-\t * Allows to ignore the test if the environment does not match the given OpenMRS version.\n-\t * \n-\t * @param openmrsPlatformVersion\n-\t * @since 1.11.3, 1.10.2, 1.9.9\n-\t */\n-\tpublic void assumeOpenmrsPlatformVersion(String openmrsPlatformVersion) {\n-\t\tassumeOpenmrsProfile(openmrsPlatformVersion);\n-\t}\n-\t\n-\t/**\n-\t * Get the number of times this class has been loaded. This is a rough approx of how many tests\n-\t * have been run so far. This can be used to determine if the test is being run in a standalone\n-\t * context or if other tests have been run before.\n-\t * \n-\t * @return number of times this class has been loaded\n-\t */\n-\tpublic Integer getLoadCount() {\n-\t\treturn loadCount;\n-\t}\n-\t\n-\t/**\n-\t * Used for runtime properties. The default is \"openmrs\" because most people will use that as\n-\t * the default. If your webapp and runtime properties are under a different name, override this\n-\t * method in your tests\n-\t * \n-\t * @return String webapp name to assume when looking up the runtime properties\n-\t */\n-\tpublic String getWebappName() {\n-\t\treturn \"openmrs\";\n-\t}\n-\t\n-\t/**\n-\t * Mimics org.openmrs.web.Listener.getRuntimeProperties() Overrides the database connection\n-\t * properties if the user wants an in-memory database\n-\t * \n-\t * @return Properties runtime\n-\t */\n-\tpublic Properties getRuntimeProperties() {\n-\t\t\n-\t\t// cache the properties for subsequent calls\n-\t\tif (runtimeProperties == null)\n-\t\t\truntimeProperties = TestUtil.getRuntimeProperties(getWebappName());\n-\t\t\n-\t\t// if we're using the in-memory hypersonic database, add those\n-\t\t// connection properties here to override what is in the runtime\n-\t\t// properties\n-\t\tif (useInMemoryDatabase()) {\n-\t\t\truntimeProperties.setProperty(Environment.DIALECT, H2Dialect.class.getName());\n-\t\t\tString url = \"jdbc:h2:mem:openmrs;DB_CLOSE_DELAY=30;LOCK_TIMEOUT=10000\";\n-\t\t\truntimeProperties.setProperty(Environment.URL, url);\n-\t\t\truntimeProperties.setProperty(Environment.DRIVER, \"org.h2.Driver\");\n-\t\t\truntimeProperties.setProperty(Environment.USER, \"sa\");\n-\t\t\truntimeProperties.setProperty(Environment.PASS, \"\");\n-\t\t\t\n-\t\t\t// these properties need to be set in case the user has this exact\n-\t\t\t// phrasing in their runtime file.\n-\t\t\truntimeProperties.setProperty(\"connection.username\", \"sa\");\n-\t\t\truntimeProperties.setProperty(\"connection.password\", \"\");\n-\t\t\truntimeProperties.setProperty(\"connection.url\", url);\n-\t\t\t\n-\t\t\t// automatically create the tables defined in the hbm files\n-\t\t\truntimeProperties.setProperty(Environment.HBM2DDL_AUTO, \"create-drop\");\n-\t\t}\n-\t\telse {\n-\t\t\tString url = System.getProperty(\"databaseUrl\");\n-\t\t\tString username = System.getProperty(\"databaseUsername\");\n-\t\t\tString password = System.getProperty(\"databasePassword\");\n-\t\t\t\n-\t\t\truntimeProperties.setProperty(Environment.URL, url);\n-\t\t\truntimeProperties.setProperty(Environment.DRIVER, System.getProperty(\"databaseDriver\"));\n-\t\t\truntimeProperties.setProperty(Environment.USER, username);\n-\t\t\truntimeProperties.setProperty(Environment.PASS, password);\n-\t\t\truntimeProperties.setProperty(Environment.DIALECT, System.getProperty(\"databaseDialect\"));\n-\t\t\t\n-\t\t\t// these properties need to be set in case the user has this exact\n-\t\t\t// phrasing in their runtime file.\n-\t\t\truntimeProperties.setProperty(\"connection.username\", username);\n-\t\t\truntimeProperties.setProperty(\"connection.password\", password);\n-\t\t\truntimeProperties.setProperty(\"connection.url\", url);\n-\t\t\t\n-\t\t\t//for the first time, automatically create the tables defined in the hbm files\n-\t\t\t//after that, just update, if there are any changes. This is for performance reasons.\n-\t\t\truntimeProperties.setProperty(Environment.HBM2DDL_AUTO, \"update\");\n-\t\t}\n-\t\t\n-\t\t// we don't want to try to load core modules in tests\n-\t\truntimeProperties.setProperty(ModuleConstants.IGNORE_CORE_MODULES_PROPERTY, \"true\");\n-\t\t\n-\t\ttry {\n-\t\t\tFile tempappdir = File.createTempFile(\"appdir-for-unit-tests-\", \"\");\n-\t\t\ttempappdir.delete(); // so we can make it into a directory\n-\t\t\ttempappdir.mkdir(); // turn it into a directory\n-\t\t\ttempappdir.deleteOnExit(); // clean up when we're done with tests\n-\t\t\t\n-\t\t\truntimeProperties.setProperty(OpenmrsConstants.APPLICATION_DATA_DIRECTORY_RUNTIME_PROPERTY, tempappdir\n-\t\t\t        .getAbsolutePath());\n-\t\t\tOpenmrsUtil.setApplicationDataDirectory(tempappdir.getAbsolutePath());\n-\t\t}\n-\t\tcatch (IOException e) {\n-\t\t\tlog.error(\"Unable to create temp dir\", e);\n-\t\t}\n-\t\t\n-\t\treturn runtimeProperties;\n-\t}\n-\t\n-\t/**\n-\t * This method provides the credentials to authenticate the user that is authenticated through the base setup.\n-\t * This method can be overridden when setting up test application contexts that are *not* using the default authentication scheme.\n-\t * \n-\t * @return The credentials to use for base setup authentication.\n-\t * @since 2.3.0\n-\t */\n-\tprotected Credentials getCredentials() {\n-\t\treturn new UsernamePasswordCredentials(\"admin\", \"test\");\n-\t}\n-\t\n-\t/**\n-\t * Authenticate to the Context. A popup box will appear asking the current user to enter\n-\t * credentials unless there is a junit.username and junit.password defined in the runtime\n-\t * properties\n-\t * \n-\t * @throws Exception\n-\t */\n-\tpublic void authenticate() {\n-\t\tif (Context.isAuthenticated() && Context.getAuthenticatedUser().equals(authenticatedUser)) {\n-\t\t\treturn;\n-\t\t}\n-\t\t\n-\t\ttry {\n-\t\t\tContext.authenticate(getCredentials());\n-\t\t\tauthenticatedUser = Context.getAuthenticatedUser();\n-\t\t\treturn;\n-\t\t}\n-\t\tcatch (ContextAuthenticationException wrongCredentialsError) {\n-\t\t\tif (useInMemoryDatabase()) {\n-\t\t\t\t// if we get here the user is using some database other than the standard\n-\t\t\t\t// in-memory database, prompt the user for input\n-\t\t\t\tlog.error(\"For some reason we couldn't auth as admin:test ?!\", wrongCredentialsError);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tInteger attempts = 0;\n-\t\t\n-\t\t// TODO: how to make this a locale specific message for the user to see?\n-\t\tString message = null;\n-\t\t\n-\t\t// only need to authenticate once per session\n-\t\twhile (!Context.isAuthenticated() && attempts < 3) {\n-\t\t\t\n-\t\t\t// look in the runtime properties for a defined username and\n-\t\t\t// password first\n-\t\t\tString junitusername = null;\n-\t\t\tString junitpassword = null;\n-\t\t\t\n-\t\t\ttry {\n-\t\t\t\tProperties props = this.getRuntimeProperties();\n-\t\t\t\tjunitusername = props.getProperty(\"junit.username\");\n-\t\t\t\tjunitpassword = props.getProperty(\"junit.password\");\n-\t\t\t}\n-\t\t\tcatch (Exception e) {\n-\t\t\t\t// if anything happens just default to asking the user\n-\t\t\t}\n-\t\t\t\n-\t\t\tString[] credentials = null;\n-\t\t\t\n-\t\t\t// ask the user for creds if no junit username/pass defined\n-\t\t\t// in the runtime properties or if that username/pass failed already\n-\t\t\tif (junitusername == null || junitpassword == null || attempts > 0) {\n-\t\t\t\tcredentials = askForUsernameAndPassword(message);\n-\t\t\t\t// credentials are null if the user clicked \"cancel\" in popup\n-\t\t\t\tif (credentials == null)\n-\t\t\t\t\treturn;\n-\t\t\t} else\n-\t\t\t\tcredentials = new String[] { junitusername, junitpassword };\n-\t\t\t\n-\t\t\t// try to authenticate to the Context with either the runtime\n-\t\t\t// defined credentials or the user supplied credentials from the\n-\t\t\t// popup\n-\t\t\ttry {\n-\t\t\t\tContext.authenticate(credentials[0], credentials[1]);\n-\t\t\t\tauthenticatedUser = Context.getAuthenticatedUser();\n-\t\t\t}\n-\t\t\tcatch (ContextAuthenticationException e) {\n-\t\t\t\tmessage = \"Invalid username/password.  Try again.\";\n-\t\t\t}\n-\t\t\t\n-\t\t\tattempts++;\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Utility method for obtaining username and password through Swing interface for tests. Any\n-\t * tests extending the org.openmrs.BaseTest class may simply invoke this method by name.\n-\t * Username and password are returned in a two-member String array. If the user aborts, null is\n-\t * returned. <b> <em>Do not call for non-interactive tests, since this method will try to\n-\t * render an interactive dialog box for authentication!</em></b>\n-\t * \n-\t * @param message string to display above username field\n-\t * @return Two-member String array containing username and password, respectively, or\n-\t *         <code>null</code> if user aborts dialog\n-\t */\n-\tpublic static synchronized String[] askForUsernameAndPassword(String message) {\n-\t\t\n-\t\ttry {\n-\t\t\tUIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n-\t\t}\n-\t\tcatch (Exception e) {\n-\n-\t\t}\n-\t\t\n-\t\tif (message == null || \"\".equals(message))\n-\t\t\tmessage = \"Enter username/password to authenticate to OpenMRS...\";\n-\t\t\n-\t\tJPanel panel = new JPanel(new GridBagLayout());\n-\t\tJLabel usernameLabel = new JLabel(\"Username\");\n-\t\tusernameLabel.setFont(font);\n-\t\tusernameField = new JTextField(20);\n-\t\tusernameField.setFont(font);\n-\t\tJLabel passwordLabel = new JLabel(\"Password\");\n-\t\tpasswordLabel.setFont(font);\n-\t\tJPasswordField passwordField = new JPasswordField(20);\n-\t\tpasswordField.setFont(font);\n-\t\tpanel.add(usernameLabel, new GridBagConstraints(0, 0, 1, 1, 0, 0, GridBagConstraints.EAST,\n-\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 5, 0));\n-\t\tpanel.add(usernameField, new GridBagConstraints(1, 0, 1, 1, 0, 0, GridBagConstraints.WEST,\n-\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\n-\t\tpanel.add(passwordLabel, new GridBagConstraints(0, 1, 1, 1, 0, 0, GridBagConstraints.EAST,\n-\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 5, 0));\n-\t\tpanel.add(passwordField, new GridBagConstraints(1, 1, 1, 1, 0, 0, GridBagConstraints.WEST,\n-\t\t        GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\n-\t\t\n-\t\tframe = new JFrame();\n-\t\tWindow window = new Window(frame);\n-\t\tframe.setVisible(true);\n-\t\tframe.setTitle(\"JUnit Test Credentials\");\n-\t\t\n-\t\t// We use a TimerTask to force focus on username, but still use\n-\t\t// JOptionPane for model dialog\n-\t\tTimerTask later = new TimerTask() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tif (frame != null) {\n-\t\t\t\t\t// bring the dialog's window to the front\n-\t\t\t\t\tframe.toFront();\n-\t\t\t\t\tusernameField.grabFocus();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t\t// try setting focus half a second from now\n-\t\tnew Timer().schedule(later, 500);\n-\t\t\n-\t\t// attention grabber for those people that aren't as observant\n-\t\tTimerTask laterStill = new TimerTask() {\n-\t\t\t\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tif (frame != null) {\n-\t\t\t\t\tframe.toFront(); // bring the dialog's window to the\n-\t\t\t\t\t// front\n-\t\t\t\t\tusernameField.grabFocus();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t};\n-\t\t// if the user hasn't done anything in 10 seconds, tell them the window\n-\t\t// is there\n-\t\tnew Timer().schedule(laterStill, 10000);\n-\t\t\n-\t\t// show the dialog box\n-\t\tint response = JOptionPane.showConfirmDialog(window, panel, message, JOptionPane.OK_CANCEL_OPTION);\n-\t\t\n-\t\t// clear out the window so the timer doesn't screw up\n-\t\tlaterStill.cancel();\n-\t\tframe.setVisible(false);\n-\t\twindow.setVisible(false);\n-\t\tframe = null;\n-\t\t\n-\t\t// response of 2 is the cancel button, response of -1 is the little red\n-\t\t// X in the top right\n-\t\treturn (response == 2 || response == -1 ? null : new String[] { usernameField.getText(),\n-\t\t        String.valueOf(passwordField.getPassword()) });\n-\t}\n-\t\n-\t/**\n-\t * Override this method to turn on/off the in-memory database. The default is to use the\n-\t * in-memory database. When this method returns false, the database defined by the runtime\n-\t * properties is used instead\n-\t * \n-\t * @return true/false whether or not to use an in memory database\n-\t */\n-\tpublic Boolean useInMemoryDatabase() {\n-\t\treturn !\"false\".equals(System.getProperty(\"useInMemoryDatabase\"));\n-\t}\n-\t\n-\t/**\n-\t * Get the database connection currently in use by the testing framework.\n-\t * <p>\n-\t * Note that if you commit a transaction, any changes done by a test will not be rolled back and\n-\t * you will need to clean up yourself by calling for example {@link #deleteAllData()}.\n-\t * \n-\t * @return Connection jdbc connection to the database\n-\t */\n-\tpublic Connection getConnection() {\n-\t\tSessionFactory sessionFactory = (SessionFactory) applicationContext.getBean(\"sessionFactory\");\n-\t\t\n-\t\treturn sessionFactory.getCurrentSession().doReturningWork(connection -> connection);\n-\t}\n-\t\n-\t/**\n-\t * This initializes the empty in-memory database with some rows in order to actually run some\n-\t * tests\n-\t *\n-\t * @throws SQLException\n-\t * @throws Exception\n-\t */\n-\tpublic void initializeInMemoryDatabase() throws SQLException {\n-\t\t//Don't allow the user to overwrite data\n-\t\tif (!useInMemoryDatabase())\n-\t\t\tthrow new RuntimeException(\n-\t\t\t        \"You shouldn't be initializing a NON in-memory database. Consider unoverriding useInMemoryDatabase\");\n-\n-\t\t//Because creator property in the superclass is mapped with optional set to false, the autoddl tool marks the \n-\t\t//column as not nullable but for person it is actually nullable, we need to first drop the constraint from \n-\t\t//person.creator column, historically this was to allow inserting the very first row. Ideally, this should not \n-\t\t//be necessary outside of tests because tables are created using liquibase and not autoddl\n-\t\tdropNotNullConstraint(\"person\", \"creator\");\n-\t\tsetAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator();\n-\t\texecuteDataSet(INITIAL_XML_DATASET_PACKAGE_PATH);\n-\t}\n-\n-\tpublic void setAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator() throws SQLException {\n-\t\t/*\n-\t\t * Hbm2ddl used in tests creates primary key columns, which are not auto incremented if\n-\t\t * NativeIfNotAssignedIdentityGenerator is used. We need to alter those columns in tests.\n-\t\t */\n-\t\tList<String> tables = Collections.singletonList(\"concept\");\n-\t\tfor (String table : tables) {\n-\t\t\tgetConnection().prepareStatement(\"ALTER TABLE \" + table + \" ALTER COLUMN \" + table + \"_id INT AUTO_INCREMENT\")\n-\t\t\t\t\t.execute();\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Drops the not null constraint from the the specified column in the specified table\n-\t *\n-\t * @param columnName the column from which to remove the constraint\n-\t * @param tableName the table that contains the column\n-\t * @throws SQLException\n-\t */\n-\tprotected void dropNotNullConstraint(String tableName, String columnName) throws SQLException {\n-\t\tif (!useInMemoryDatabase()) {\n-\t\t\tthrow new RuntimeException(\"Altering column nullability is not supported for a non in-memory database\");\n-\t\t}\n-\t\tfinal String sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + columnName + \" SET NULL\";\n-\t\tDatabaseUtil.executeSQL(getConnection(), sql, false);\n-\t}\n-\n-\t/**\n-\t * Note that with the H2 DB this operation always commits an open transaction.\n-\t * \n-\t * @param connection\n-\t * @throws SQLException\n-\t */\n-\tprotected void turnOnDBConstraints(Connection connection) throws SQLException {\n-\t\tString constraintsOnSql;\n-\t\tif (useInMemoryDatabase()) {\n-\t\t\tconstraintsOnSql = \"SET REFERENTIAL_INTEGRITY TRUE\";\n-\t\t} else {\n-\t\t\tconstraintsOnSql = \"SET FOREIGN_KEY_CHECKS=1;\";\n-\t\t}\n-\t\tPreparedStatement ps = connection.prepareStatement(constraintsOnSql);\n-\t\tps.execute();\n-\t\tps.close();\n-\t}\n-\t\n-\tprotected void turnOffDBConstraints(Connection connection) throws SQLException {\n-\t\tString constraintsOffSql;\n-\t\tif (useInMemoryDatabase()) {\n-\t\t\tconstraintsOffSql = \"SET REFERENTIAL_INTEGRITY FALSE\";\n-\t\t} else {\n-\t\t\tconstraintsOffSql = \"SET FOREIGN_KEY_CHECKS=0;\";\n-\t\t}\n-\t\tPreparedStatement ps = connection.prepareStatement(constraintsOffSql);\n-\t\tps.execute();\n-\t\tps.close();\n-\t}\n-\t\n-\t/**\n-\t * Used by {@link #executeDataSet(String)} to cache the parsed xml files. This speeds up\n-\t * subsequent runs of the dataset\n-\t */\n-\tprivate static Map<String, IDataSet> cachedDatasets = new HashMap<>();\n-\t\n-\t/**\n-\t * Runs the flat xml data file at the classpath location specified by\n-\t * <code>datasetFilename</code> This is a convenience method. It simply creates an\n-\t * {@link IDataSet} and calls {@link #executeDataSet(IDataSet)}\n-\t * \n-\t * @param datasetFilename String path/filename on the classpath of the xml data set to clean\n-\t *            insert into the current database\n-\t * @see #getConnection()\n-\t * @see #executeDataSet(IDataSet)\n-\t */\n-\tpublic void executeDataSet(String datasetFilename) {\n-\t\t\n-\t\t// try to get the given filename from the cache\n-\t\tIDataSet xmlDataSetToRun = cachedDatasets.get(datasetFilename);\n-\t\t\n-\t\t// if we didn't find it in the cache, load it\n-\t\tif (xmlDataSetToRun == null) {\n-\t\t\tFile file = new File(datasetFilename);\n-\t\t\t\n-\t\t\tInputStream fileInInputStreamFormat = null;\n-\t\t\tReader reader = null;\n-\t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\t// try to load the file if its a straight up path to the file or\n-\t\t\t\t\t// if its a classpath path to the file\n-\t\t\t\t\tif (file.exists()) {\n-\t\t\t\t\t\tfileInInputStreamFormat = new FileInputStream(datasetFilename);\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tfileInInputStreamFormat = getClass().getClassLoader().getResourceAsStream(datasetFilename);\n-\t\t\t\t\t\tif (fileInInputStreamFormat == null)\n-\t\t\t\t\t\t\tthrow new FileNotFoundException(\"Unable to find '\" + datasetFilename + \"' in the classpath\");\n-\t\t\t\t\t}\n-\t\t\t\t\t\n-\t\t\t\t\treader = new InputStreamReader(fileInInputStreamFormat, StandardCharsets.UTF_8);\n-\t\t\t\t\tReplacementDataSet replacementDataSet = new ReplacementDataSet(\n-\t\t\t\t\t        new FlatXmlDataSet(reader, false, true, false));\n-\t\t\t\t\treplacementDataSet.addReplacementObject(\"[NULL]\", null);\n-\t\t\t\t\txmlDataSetToRun = replacementDataSet;\n-\t\t\t\t\t\n-\t\t\t\t\treader.close();\n-\t\t\t\t}\n-\t\t\t\tcatch (DataSetException | IOException e) {\n-\t\t\t\t\tthrow new DatabaseUnitRuntimeException(e);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tIOUtils.closeQuietly(fileInInputStreamFormat);\n-\t\t\t\tIOUtils.closeQuietly(reader);\n-\t\t\t}\n-\t\t\t\n-\t\t\t// cache the xmldataset for future runs of this file\n-\t\t\tcachedDatasets.put(datasetFilename, xmlDataSetToRun);\n-\t\t}\n-\t\t\n-\t\texecuteDataSet(xmlDataSetToRun);\n-\t}\n-\t\n-\t/**\n-\t * Runs the large flat xml dataset. It does not cache the file as opposed to\n-\t * {@link #executeDataSet(String)}.\n-\t * \n-\t * @param datasetFilename\n-\t * @throws Exception\n-\t * @since 1.10\n-\t */\n-\tpublic void executeLargeDataSet(String datasetFilename) throws Exception {\n-\t\tInputStream inputStream = null;\n-\t\ttry {\n-\t\t\tfinal File file = new File(datasetFilename);\n-\t\t\tif (file.exists()) {\n-\t\t\t\tinputStream = new FileInputStream(datasetFilename);\n-\t\t\t} else {\n-\t\t\t\tinputStream = getClass().getClassLoader().getResourceAsStream(datasetFilename);\n-\t\t\t\tif (inputStream == null)\n-\t\t\t\t\tthrow new FileNotFoundException(\"Unable to find '\" + datasetFilename + \"' in the classpath\");\n-\t\t\t}\n-\t\t\t\n-\t\t\tfinal FlatXmlProducer flatXmlProducer = new FlatXmlProducer(new InputSource(inputStream));\n-\t\t\tfinal StreamingDataSet streamingDataSet = new StreamingDataSet(flatXmlProducer);\n-\t\t\t\n-\t\t\tfinal ReplacementDataSet replacementDataSet = new ReplacementDataSet(streamingDataSet);\n-\t\t\treplacementDataSet.addReplacementObject(\"[NULL]\", null);\n-\t\t\t\n-\t\t\texecuteDataSet(replacementDataSet);\n-\t\t\t\n-\t\t\tinputStream.close();\n-\t\t}\n-\t\tfinally {\n-\t\t\tIOUtils.closeQuietly(inputStream);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Runs the xml data file at the classpath location specified by <code>datasetFilename</code>\n-\t * using XmlDataSet. It simply creates an {@link IDataSet} and calls\n-\t * {@link #executeDataSet(IDataSet)}. <br>\n-\t * <br>\n-\t * This method is different than {@link #executeDataSet(String)} in that this one does not\n-\t * expect a flat file xml but instead a true XmlDataSet. <br>\n-\t * <br>\n-\t * In addition, there is no replacing of [NULL] values in strings.\n-\t * \n-\t * @param datasetFilename String path/filename on the classpath of the xml data set to clean\n-\t *            insert into the current database\n-\t * @see #getConnection()\n-\t * @see #executeDataSet(IDataSet)\n-\t */\n-\tpublic void executeXmlDataSet(String datasetFilename) throws Exception {\n-\t\t\n-\t\t// try to get the given filename from the cache\n-\t\tIDataSet xmlDataSetToRun = cachedDatasets.get(datasetFilename);\n-\t\t\n-\t\t// if we didn't find it in the cache, load it\n-\t\tif (xmlDataSetToRun == null) {\n-\t\t\tFile file = new File(datasetFilename);\n-\t\t\t\n-\t\t\tInputStream fileInInputStreamFormat = null;\n-\t\t\t\n-\t\t\ttry {\n-\t\t\t\t// try to load the file if its a straight up path to the file or\n-\t\t\t\t// if its a classpath path to the file\n-\t\t\t\tif (file.exists())\n-\t\t\t\t\tfileInInputStreamFormat = new FileInputStream(datasetFilename);\n-\t\t\t\telse {\n-\t\t\t\t\tfileInInputStreamFormat = getClass().getClassLoader().getResourceAsStream(datasetFilename);\n-\t\t\t\t\tif (fileInInputStreamFormat == null)\n-\t\t\t\t\t\tthrow new FileNotFoundException(\"Unable to find '\" + datasetFilename + \"' in the classpath\");\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tXmlDataSet xmlDataSet = null;\n-\t\t\t\txmlDataSet = new XmlDataSet(fileInInputStreamFormat);\n-\t\t\t\txmlDataSetToRun = xmlDataSet;\n-\t\t\t\t\n-\t\t\t\tfileInInputStreamFormat.close();\n-\t\t\t}\n-\t\t\tfinally {\n-\t\t\t\tIOUtils.closeQuietly(fileInInputStreamFormat);\n-\t\t\t}\n-\t\t\t\n-\t\t\t// cache the xmldataset for future runs of this file\n-\t\t\tcachedDatasets.put(datasetFilename, xmlDataSetToRun);\n-\t\t}\n-\t\t\n-\t\texecuteDataSet(xmlDataSetToRun);\n-\t}\n-\t\n-\t/**\n-\t * Run the given dataset specified by the <code>dataset</code> argument\n-\t * \n-\t * @param dataset IDataSet to run on the current database used by Spring\n-\t * @see #getConnection()\n-\t */\n-\tpublic void executeDataSet(IDataSet dataset) {\n-\t\ttry {\n-\t\t\tConnection connection = getConnection();\n-\t\t\t\n-\t\t\tIDatabaseConnection dbUnitConn = setupDatabaseConnection(connection);\n-\t\t\t\n-\t\t\t//Do the actual update/insert:\n-\t\t\t//insert new rows, update existing rows, and leave others alone\n-\t\t\tDatabaseOperation.REFRESH.execute(dbUnitConn, dataset);\n-\t\t}\n-\t\tcatch (DatabaseUnitException | SQLException e) {\n-\t\t\tthrow new DatabaseUnitRuntimeException(e);\n-\t\t}\n-\t}\n-\t\n-\tprotected IDatabaseConnection setupDatabaseConnection(Connection connection) throws DatabaseUnitException {\n-\t\tIDatabaseConnection dbUnitConn = new DatabaseConnection(connection);\n-\t\t\n-\t\tif (useInMemoryDatabase()) {\n-\t\t\t//Setup the db connection to use H2 config.\n-\t\t\tDatabaseConfig config = dbUnitConn.getConfig();\n-\t\t\tconfig.setProperty(DatabaseConfig.PROPERTY_DATATYPE_FACTORY, new H2DataTypeFactory());\n-\t\t}\n-\t\t\n-\t\treturn dbUnitConn;\n-\t}\n-\t\n-\t/**\n-\t * This is a convenience method to clear out all rows in all tables in the current connection.\n-\t * <p>\n-\t * This operation always results in a commit.\n-\t * \n-\t * @throws Exception\n-\t */\n-\tpublic void deleteAllData() {\n-\t\ttry {\n-\t\t\tContext.clearSession();\n-\t\t\t\n-\t\t\tConnection connection = getConnection();\n-\t\t\t\n-\t\t\tturnOffDBConstraints(connection);\n-\t\t\t\n-\t\t\tIDatabaseConnection dbUnitConn = setupDatabaseConnection(connection);\n-\t\t\t\n-\t\t\t// find all the tables for this connection\n-\t\t\tResultSet resultSet = connection.getMetaData().getTables(null, \"PUBLIC\", \"%\", null);\n-\t\t\tDefaultDataSet dataset = new DefaultDataSet();\n-\t\t\twhile (resultSet.next()) {\n-\t\t\t\tString tableName = resultSet.getString(3);\n-\t\t\t\tdataset.addTable(new DefaultTable(tableName));\n-\t\t\t}\n-\t\t\t\n-\t\t\t// do the actual deleting/truncating\n-\t\t\tDatabaseOperation.DELETE_ALL.execute(dbUnitConn, dataset);\n-\t\t\t\n-\t\t\tturnOnDBConstraints(connection);\n-\t\t\t\n-\t\t\tconnection.commit();\n-\t\t\t\n-\t\t\tupdateSearchIndex();\n-\t\t\t\n-\t\t\tisBaseSetup = false;\n-\t\t}\n-\t\tcatch (SQLException | DatabaseUnitException e) {\n-\t\t\tthrow new DatabaseUnitRuntimeException(e);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Method to clear the hibernate cache\n-\t */\n-\t@BeforeEach\n-\tpublic void clearHibernateCache() {\n-\t\tSessionFactory sf = (SessionFactory) applicationContext.getBean(\"sessionFactory\");\n-\t\tsf.getCache().evictCollectionRegions();\n-\t\tsf.getCache().evictEntityRegions();\n-\t}\n-\t\n-\t/**\n-\t * This method is run before all test methods that extend this {@link BaseContextSensitiveTest}\n-\t * unless you annotate your method with the \"@SkipBaseSetup\" annotation After running this\n-\t * method an in-memory database will be available that has the content of the rows from\n-\t * {@link #INITIAL_XML_DATASET_PACKAGE_PATH} and {@link #EXAMPLE_XML_DATASET_PACKAGE_PATH} xml\n-\t * files. This method will also ask to be authenticated against the current Context and\n-\t * database. The {@link #initializeInMemoryDatabase()} method has a user of admin:test.\n-\t * <p>\n-\t * If you annotate a test with \"@SkipBaseSetup\", this method will call {@link #deleteAllData()},\n-\t * but only if you use the in memory DB.\n-\t * \n-\t * @throws SQLException\n-\t * @see SkipBaseSetup\n-\t * @see SkipBaseSetupAnnotationExecutionListener\n-\t * @see #initializeInMemoryDatabase()\n-\t * @see #authenticate()\n-\t */\n-\t@BeforeEach\n-\tpublic void baseSetupWithStandardDataAndAuthentication() throws SQLException {\n-\t\t// Open a session if needed\n-\t\tif (!Context.isSessionOpen()) {\n-\t\t\tContext.openSession();\n-\t\t}\n-\t\t\n-\t\t// The skipBaseSetup flag is controlled by the @SkipBaseSetup annotation. \t\tif (useInMemoryDatabase()) {\n-\t\tif (!skipBaseSetup) {\n-\t\t\tif (!isBaseSetup) {\n-\t\t\t\t\n-\t\t\t\tdeleteAllData();\n-\t\t\t\t\n-\t\t\t\tif (useInMemoryDatabase()) {\n-\t\t\t\t\tinitializeInMemoryDatabase();\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\texecuteDataSet(INITIAL_XML_DATASET_PACKAGE_PATH);\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\texecuteDataSet(EXAMPLE_XML_DATASET_PACKAGE_PATH);\n-\t\t\t\t\n-\t\t\t\t//Commit so that it is not rolled back after a test.\n-\t\t\t\tgetConnection().commit();\n-\n-\t\t\t\tupdateSearchIndex();\n-\t\t\t\t\n-\t\t\t\tisBaseSetup = true;\n-\t\t\t}\n-\t\t\t\n-\t\t\tauthenticate();\n-\t\t} else {\n-\t\t\tif (isBaseSetup) {\n-\t\t\t\tdeleteAllData();\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tContext.clearSession();\n-\t}\n-\t\n-\tpublic Class<?>[] getIndexedTypes() {\n-\t\treturn new Class<?>[] { ConceptName.class, Drug.class, PersonName.class, PersonAttribute.class,\n-\t\t\t\tPatientIdentifier.class};\n-\t}\n-\t\n-\t/**\n-\t * It needs to be call if you want to do a concept search after you modify a concept in a test.\n-\t * It is because index is automatically updated only after transaction is committed, which\n-\t * happens only at the end of a test in our transactional tests.\n-\t */\n-\tpublic void updateSearchIndex() {\n-\t\tfor (Class<?> indexType : getIndexedTypes()) {\n-\t\t\tContext.updateSearchIndexForType(indexType);\n-\t\t}\n-\t}\n-\t\n-\t@AfterEach\n-\tpublic void clearSessionAfterEachTest() {\n-\t\t// clear the session to make sure nothing is cached, etc\n-\t\tContext.clearSession();\n-\t\t\n-\t\t// needed because the authenticatedUser is the only object that sticks\n-\t\t// around after tests and the clearSession call\n-\t\tif (Context.isSessionOpen())\n-\t\t\tContext.logout();\n-\t}\n-\t\n-\t/**\n-\t * Called after each test class. This is called once per test class that extends\n-\t * {@link BaseContextSensitiveTest}. Needed so that \"unit of work\" that is the test class is\n-\t * surrounded by a pair of open/close session calls.\n-\t * \n-\t * @throws Exception\n-\t */\n-\t@AfterAll\n-\tpublic static void closeSessionAfterEachClass() throws Exception {\n-\t\t//Some tests add data via executeDataset()\n-\t\t//We need to delete it in order not to interfere with others\n-\t\tif (instance != null) {\n-\t\t\ttry {\n-\t\t\t\tinstance.deleteAllData();\n-\t\t\t}\n-\t\t\tcatch (Exception ex) {\n-\t\t\t\t//No need to worry about this\n-\t\t\t}\n-\t\t\tinstance = null;\n-\t\t}\n-\t\t\n-\t\t// clean up the session so we don't leak memory\n-\t\tif (Context.isSessionOpen()) {\n-\t\t\tContext.closeSession();\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Instance variable used by the {@link #baseSetupWithStandardDataAndAuthentication()} method to\n-\t * know whether the current \"@Test\" method has asked to be _not_ do the initialize/standard\n-\t * data/authenticate\n-\t * \n-\t * @see SkipBaseSetup\n-\t * @see SkipBaseSetupAnnotationExecutionListener\n-\t * @see #baseSetupWithStandardDataAndAuthentication()\n-\t */\n-\tprivate boolean skipBaseSetup = false;\n-\t\n-\t/**\n-\t * Don't run the {@link #setupDatabaseWithStandardData()} method. This means that the associated\n-\t * \"@Test\" must call one of these:\n-\t * \n-\t * <pre>\n-\t *  * initializeInMemoryDatabase() ;\n-\t *  * executeDataSet(EXAMPLE_DATA_SET);\n-\t *  * Authenticate\n-\t * </pre>\n-\t * \n-\t * on its own if any of those results are needed. This method is called before all \"@Test\"\n-\t * methods that have been annotated with the \"@SkipBaseSetup\" annotation.\n-\t * \n-\t * @throws Exception\n-\t * @see SkipBaseSetup\n-\t * @see SkipBaseSetupAnnotationExecutionListener\n-\t * @see #baseSetupWithStandardDataAndAuthentication()\n-\t */\n-\tpublic void skipBaseSetup() throws Exception {\n-\t\tskipBaseSetup = true;\n-\t}\n-\t\n-}\n"}}, {"oid": "9fe1baadb803ef2f1dd9092502bb2470ca738f57", "url": "https://github.com/openmrs/openmrs-core/commit/9fe1baadb803ef2f1dd9092502bb2470ca738f57", "message": "Reverting Jupiter from 2.3.x", "committedDate": "2020-12-17T15:19:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MDE3Nw==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545250177", "bodyText": "What's this?", "author": "mks-d", "createdAt": "2020-12-17T17:01:57Z", "path": "api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java", "diffHunk": "@@ -601,12 +602,27 @@ public void setAutoIncrementOnTablesWithNativeIfNotAssignedIdentityGenerator() t\n \t}\n \n \t/**\n+\t * Drops the not null constraint from the the specified column in the specified table\n+\t *\n+\t * @param columnName the column from which to remove the constraint\n+\t * @param tableName the table that contains the column\n+\t * @throws SQLException\n+\t */\n+\tprotected void dropNotNullConstraint(String tableName, String columnName) throws SQLException {\n+\t\tif (!useInMemoryDatabase()) {\n+\t\t\tthrow new RuntimeException(\"Altering column nullability is not supported for a non in-memory database\");\n+\t\t}\n+\t\tfinal String sql = \"ALTER TABLE \" + tableName + \" ALTER COLUMN \" + columnName + \" SET NULL\";\n+\t\tDatabaseUtil.executeSQL(getConnection(), sql, false);\n+\t}\n+\t/**\n+\n \t * Note that with the H2 DB this operation always commits an open transaction.", "originalCommit": "9fe1baadb803ef2f1dd9092502bb2470ca738f57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI2NzIwOQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545267209", "bodyText": "Have resolved it thanks", "author": "sherrif10", "createdAt": "2020-12-17T17:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MDE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc0NzQwMw==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545747403", "bodyText": "@sherrif10 what is this newly added dropNotNullConstraint(String, String)?\nThe change that is expected is just to turn two private methods into protected.", "author": "mks-d", "createdAt": "2020-12-18T10:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MDE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc3MDgzOQ==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545770839", "bodyText": "This was due to cherry-picked commit. i thought we can also inherit this commit to since this was not committed in 2.3.x as you see here on branch 2.3.x.however not sure if we can handle that in this commit", "author": "sherrif10", "createdAt": "2020-12-18T11:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MDE3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTc4NDM3Ng==", "url": "https://github.com/openmrs/openmrs-core/pull/3668#discussion_r545784376", "bodyText": "Resolved thanks", "author": "sherrif10", "createdAt": "2020-12-18T11:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI1MDE3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "24df0b442846a0cdf068e2a61101d7601aa399ca", "chunk": "diff --git a/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java b/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\nindex bd0cd8416..cafeadd73 100644\n--- a/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\n+++ b/api/src/test/java/org/openmrs/test/BaseContextSensitiveTest.java\n\n@@ -616,7 +616,6 @@ public abstract class BaseContextSensitiveTest extends AbstractJUnit4SpringConte\n \t\tDatabaseUtil.executeSQL(getConnection(), sql, false);\n \t}\n \t/**\n-\n \t * Note that with the H2 DB this operation always commits an open transaction.\n \t * \n \t * @param connection\n"}}, {"oid": "24df0b442846a0cdf068e2a61101d7601aa399ca", "url": "https://github.com/openmrs/openmrs-core/commit/24df0b442846a0cdf068e2a61101d7601aa399ca", "message": "Getting rid of jupitar package in 2.3.x", "committedDate": "2020-12-17T17:22:21Z", "type": "commit"}, {"oid": "db291d1b42ea1e710c551edeebdf5fe8691edaa8", "url": "https://github.com/openmrs/openmrs-core/commit/db291d1b42ea1e710c551edeebdf5fe8691edaa8", "message": "Removing unwanted commit", "committedDate": "2020-12-18T11:50:43Z", "type": "commit"}]}