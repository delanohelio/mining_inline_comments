{"pr_number": 9388, "pr_title": "Added support for @InjectSpy", "pr_createdAt": "2020-05-17T19:17:34Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9388", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426371984", "bodyText": "I'm afraid that this could get us into trouble.\nWhat this does is basically set a private field on the CDI proxy. For mock that works great because the mock is just some object. But in this case you would be setting the that private field to the CDI proxy itself.\nI really think we need to find a more safe way of providing this facility.", "author": "geoand", "createdAt": "2020-05-18T05:07:15Z", "path": "test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.quarkus.test.junit.mockito.internal;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.inject.Qualifier;\n+\n+import org.mockito.Mockito;\n+\n+import io.quarkus.arc.Arc;\n+import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n+import io.quarkus.test.junit.mockito.InjectSpy;\n+\n+public class CreateMockitoSpiesCallback implements QuarkusTestBeforeAllCallback {\n+\n+    @Override\n+    public void beforeAll(Object testInstance) {\n+        Class<?> current = testInstance.getClass();\n+        while (current.getSuperclass() != null) {\n+            for (Field field : current.getDeclaredFields()) {\n+                InjectSpy injectSpyAnnotation = field.getAnnotation(InjectSpy.class);\n+                if (injectSpyAnnotation != null) {\n+                    Object beanInstance = getBeanInstance(testInstance, field);\n+                    Object spy = createSpyAndSetTestField(testInstance, field, beanInstance);\n+                    MockitoMocksTracker.track(testInstance, spy, beanInstance);", "originalCommit": "677fa036c0975056826ffbf66aab395bb7b90fd5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1NjA5Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426556096", "bodyText": "I am not sure I am following the concern.\nIn both the mock and spy use cases we are wrapping an Object into the Mockito Framework.\nIn the case of a Mock that is that Object is instantiated with null for all internal variables, and the Mockito Framework is set to doReturn(null) for any method that returns anything, or doNothing() for methods that return void.\nIn the case of the Spy that Object is a fully instantiated Object with all of the variables set how they are expected. Then the Mockito Framework will by default call doCallRealMethod() on all method calls into that Object.\nIn both cases, we are putting into the CDI proxy a Mockito wrapped Object.", "author": "aaron-rogers82", "createdAt": "2020-05-18T11:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1ODU4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426558585", "bodyText": "The problem is that with the Spy, what you are putting in, actually contains a reference to the object itself, no?", "author": "geoand", "createdAt": "2020-05-18T11:31:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2MjUzMA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426562530", "bodyText": "Yes, you are just using a wrapper pattern to provide additional functionality to the Object.\nAt the end, the CDI proxy isn't pointing to the first Object it originally created, it is pointing to the Mockito Framework wrapped Object. If the CDI interacts with that Bean, it will be doing so to the wrapped Object, not to the original Bean itself.", "author": "aaron-rogers82", "createdAt": "2020-05-18T11:39:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU2NjU4NA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426566584", "bodyText": "So I think I haven't been clear.\nWhen  MockSupport.installMock() gets called (down the line) what happens is that whatever you pass as the objects gets stuffed into a special field called mock of  the CDI proxy.\nIn this case, you are passing an object which essentially wraps the proxy itself (unless I have misunderstood).\nSo this mock field of the CDI proxy would (once the intermediate is removed) essentially contains a reference to itself. That is what has me worried.", "author": "geoand", "createdAt": "2020-05-18T11:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxMDc2Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426610763", "bodyText": "Okay, I ran some additional tests and compared the memory addresses for the different objects.\nIn the test I had one Object annotated with @InjectMock and another Object annotated with @InjectSpy. I then ran two @test method and compared the actual Bean, ClientProxy, and mock/spy objects.\nIn both @test cases, the actual CDI Bean instance stayed the same (mock = @34d3bfca and spy = @1d57b8f1), and the ClentProxy instance stayed the same (mock = @16660 and spy = @16705). However, the Mockito wrapped instance change between each test (mock = test1 = @16662, test2 = @17364, and the spy = test1 = @16707, test2 = @17370).\nDoes this help address your concern?", "author": "aaron-rogers82", "createdAt": "2020-05-18T13:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjYxMTU0OA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426611548", "bodyText": "Thanks for the info, I'll take a look at it and get back to you", "author": "geoand", "createdAt": "2020-05-18T13:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzQ3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426693470", "bodyText": "There is a copy of the CDI proxy deep inside the mock field. See\n\nIt might be completely safe, but I would like to hear from @mkouba or @manovotn first :)", "author": "geoand", "createdAt": "2020-05-18T15:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4MDEyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426780129", "bodyText": "@geoand aren't we doing the same thing in CreateMockitoMocksCallback#beforeAll()? When you retrieve the CDI bean there, it also looks to be a proxy, right?", "author": "manovotn", "createdAt": "2020-05-18T17:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjc4MTA2NA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426781064", "bodyText": "I mean you also base the mock on the proxy and then store that into  MockitoMocksTracker. I don't know the internals but I would assume there isn't much difference in spy versus mock in this regard.", "author": "manovotn", "createdAt": "2020-05-18T17:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg0ODgxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426848811", "bodyText": "I think that it shoudln't be a problem although it's a bit \"tangled\".\nThere is a difference though because for @InjectMock a mock object is created and injected into the test class instance AND this mock is set to the mock field of the relevant client proxy object so that any client proxy method invocation is redirected to the mock.\nFor @InjectSpy a copy (according to the javadoc) of the client proxy object is created AND then this copy is set to the mock field of the relevant client proxy object. And it seems to work because the spy copy is created before the mock field is set and so if the client proxy is invoked (i.e. from another bean) the spy copy that has mock=null is used and so non-stubbed methods delegate to the underlying bean instance.", "author": "mkouba", "createdAt": "2020-05-18T19:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg3NTg3NA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426875874", "bodyText": "Oh my bad, Mockito.mock() is based off a Class, not actual instance...\nIn that case, it might be \"cleaner\" to unwrap the proxies before creating the spy, WDYT?", "author": "manovotn", "createdAt": "2020-05-18T20:28:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjkwNzU4OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r426907589", "bodyText": "In that case, it might be \"cleaner\" to unwrap the proxies before creating the spy, WDYT?\n\nJust to be clear, you are suggesting we do something like:\nClientProxyUnwrapper unwrapProxy = new ClientProxyUnwrapper();\nObject spy = Mockito.spy(unwrapProxy.apply(beanInstance));\nI tested this locally, and the \"WithSpiesTest\" tests all work with that. This appears to be a good solution, as we are not adding a circular reference to the Proxy.", "author": "aaron-rogers82", "createdAt": "2020-05-18T21:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAzNzM5NA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427037394", "bodyText": "I like @manovotn's idea, WDYT @mkouba ?", "author": "geoand", "createdAt": "2020-05-19T05:24:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NDAwMA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427044000", "bodyText": "I'm not sure it's a good idea because if Mockito.spy() copies the state and does not delegate to the original instance we may end up with unexpected behavior. Let's say we have @ApplicationScoped Foo then @InjectSpy Foo -> this creates a copy of Foo instance. Now if you call an unstubbed method on the spy instance the state of the original bean instance does not change. Ideally, test methods should not be connected in any way but since the @ApplicationScoped beans are shared...", "author": "mkouba", "createdAt": "2020-05-19T05:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0ODE2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427048165", "bodyText": "So @mkouba do you propose we just leave the PR as is?", "author": "geoand", "createdAt": "2020-05-19T06:00:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA5MDc0MA==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427090740", "bodyText": "Frankly, I never used the spy functionality before but looking at the docs, this seems to be what you would expect - that the real instance is in fact not invoked, it's state unchanged.", "author": "manovotn", "createdAt": "2020-05-19T07:36:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI0Mzc3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427243775", "bodyText": "FWIW, @mkouba fixed the issue he mentioned above", "author": "geoand", "createdAt": "2020-05-19T11:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI5MDMxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427290319", "bodyText": "Ideally, test methods should not be connected in any way but since the @ApplicationScoped beans are shared...\n\nI still think we should unwrap the ClientProxy. I did a quick test with the \"quarkus-integration-test-injectmock\" project and if we just create the Spy on the ClientProxy then the internal state of the actual bean will persist between test. I agree with @mkouba above, that test state should not be shared. If we do share the state, then Testers will see unexpected results.\nI updated MessageServiceImpl to:\nprivate int count = 0;\n@Override\npublic String getMessage() {\n    System.out.println(\"Test Instance: \"+this);\n    System.out.println(\"Count: \"+count++);\n    return \"hello\";\n}\n\nBetween all of the test in the integration project, the MessageServiceImpl is called three times.\nSpy on ClientProxy:\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@62ce03cc Count: 0\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@62ce03cc Count: 1\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@62ce03cc Count: 2\nSpy on Unwrapped ClientProxy:\nTest Instance: org.mockito.codegen.MessageServiceImpl$MockitoMock$718960814@9131950 Count: 0\nTest Instance: org.mockito.codegen.MessageServiceImpl$MockitoMock$718960814@38d42ab7 Count: 0\nTest Instance: io.quarkus.it.mockbean.MessageServiceImpl@2553ddc4 Count: 0\nI will defer and leave the Spy at the ClientProxy if y'all really think that the Test should alter the internal state of ApplicationScoped beans.\nPlease advise how y'all would like to proceed.", "author": "aaron-rogers82", "createdAt": "2020-05-19T13:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMyMjQ2OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427322469", "bodyText": "I don't have a strong opinion. Both approaches probably have pros and cons. To me it sounds more natural to delegate the calls to the real instance but the contract of mockito spy is probably more important.", "author": "mkouba", "createdAt": "2020-05-19T13:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU4ODk2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427588967", "bodyText": "I think we should stick to what mockito spy contract is since we are trying to mimick that.\nBut truth be told, I am not sure I see the use case where you would actually need a spy versus standard mock...", "author": "manovotn", "createdAt": "2020-05-19T20:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTk0Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9388#discussion_r427601943", "bodyText": "I provided a few reasons in the documentation.\nAn example, in my current project I am working on, we have three possible methods that will all return the same object, but will go about looking up the data for the object different ways. We determine which method to call based on the JSON object passed into the project. When testing, we don't really want to alter how the code operates, we just want to be able to verify that the logic called the correct method.\nTo do that with a Mock it would have to create the mock and then in setup (@beforeeach) call doCallRealMethod().when(logic).method() for each public/protected/package private method on the class. Just creating a Spy eliminates that setup and simplifies maintenance as new methods are added.\nFor the majority of time, a Mock is just fine and will accomplish the majority of testing. Having the ability to use a Spy just provides more options to use when they are beneficial.", "author": "aaron-rogers82", "createdAt": "2020-05-19T21:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "462087109fa70fd0e264340adaaea7411dcb3ad3", "chunk": "diff --git a/test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java b/test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java\nindex 7c1cd1d28a..5f70e614ca 100644\n--- a/test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java\n+++ b/test-framework/junit5-mockito/src/main/java/io/quarkus/test/junit/mockito/internal/CreateMockitoSpiesCallback.java\n\n@@ -1,16 +1,10 @@\n package io.quarkus.test.junit.mockito.internal;\n \n-import java.lang.annotation.Annotation;\n import java.lang.reflect.Field;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import javax.inject.Qualifier;\n \n import org.mockito.Mockito;\n \n-import io.quarkus.arc.Arc;\n-import io.quarkus.arc.InstanceHandle;\n+import io.quarkus.arc.runtime.ClientProxyUnwrapper;\n import io.quarkus.test.junit.callback.QuarkusTestBeforeAllCallback;\n import io.quarkus.test.junit.mockito.InjectSpy;\n \n"}}, {"oid": "462087109fa70fd0e264340adaaea7411dcb3ad3", "url": "https://github.com/quarkusio/quarkus/commit/462087109fa70fd0e264340adaaea7411dcb3ad3", "message": "Added support for @InjectSpy", "committedDate": "2020-05-21T16:18:24Z", "type": "commit"}]}