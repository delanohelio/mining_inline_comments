{"pr_number": 9474, "pr_title": "Make access logging work in native mode", "pr_createdAt": "2020-05-20T01:51:51Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9474", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODA5OA==", "url": "https://github.com/quarkusio/quarkus/pull/9474#discussion_r427698098", "bodyText": "An issue with this approach is that if there are additional service implementations on the deployment class path that are not on the runtime class path this will cause failures. Not sure how likely this in practice.", "author": "stuartwdouglas", "createdAt": "2020-05-20T01:55:34Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/builditem/nativeimage/ServiceProviderBuildItem.java", "diffHunk": "@@ -18,6 +27,50 @@\n     private final String serviceInterface;\n     private final List<String> providers;\n \n+    /**\n+     * Creates and returns a {@link ServiceProviderBuildItem} for the {@code serviceInterfaceClassName} by including\n+     * all the providers that are listed in the service interface descriptor file. The passed classloader is used to\n+     * find the service interface descriptor file and if no such file is found, this method returns an\n+     * {@link Optional#empty() empty value}.\n+     *\n+     * @param serviceInterfaceClassName the interface whose service interface descriptor file we want to embed\n+     * @param cl the classloader to use to find the service interface descriptor file. Can be null, in which case,\n+     *        this method uses the {@link Thread#getContextClassLoader() thread context classloader}\n+     * @return\n+     * @throws IOException\n+     */\n+    public static Optional<ServiceProviderBuildItem> allProviders(final String serviceInterfaceClassName, final ClassLoader cl)\n+            throws IOException {\n+        if (serviceInterfaceClassName == null || serviceInterfaceClassName.trim().isEmpty()) {\n+            throw new IllegalArgumentException(\"service interface name cannot be null or blank\");\n+        }\n+        final ClassLoader classLoaderToUse = cl == null ? Thread.currentThread().getContextClassLoader() : cl;", "originalCommit": "ecd06c23aab7ba3a386c2769ba6b9c794f7e8a03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjE3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9474#discussion_r427702177", "bodyText": "You are right. I hadn't thought of this scenario. I think I might have a slightly different way to achieve this same functionality without having to run into the issue that you note here. I'll try it out and update the PR shortly.", "author": "jaikiran", "createdAt": "2020-05-20T02:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODA5OA=="}], "type": "inlineReview", "revised_code": {"commit": "d1b704131369240e42160e3c34196694ee1cd30d", "chunk": "diff --git a/core/deployment/src/main/java/io/quarkus/deployment/builditem/nativeimage/ServiceProviderBuildItem.java b/core/deployment/src/main/java/io/quarkus/deployment/builditem/nativeimage/ServiceProviderBuildItem.java\nindex f15c7a0fc0..ae16002b04 100644\n--- a/core/deployment/src/main/java/io/quarkus/deployment/builditem/nativeimage/ServiceProviderBuildItem.java\n+++ b/core/deployment/src/main/java/io/quarkus/deployment/builditem/nativeimage/ServiceProviderBuildItem.java\n\n@@ -29,46 +27,37 @@ public final class ServiceProviderBuildItem extends MultiBuildItem {\n \n     /**\n      * Creates and returns a {@link ServiceProviderBuildItem} for the {@code serviceInterfaceClassName} by including\n-     * all the providers that are listed in the service interface descriptor file. The passed classloader is used to\n-     * find the service interface descriptor file and if no such file is found, this method returns an\n-     * {@link Optional#empty() empty value}.\n+     * all the providers that are listed in the service interface descriptor file.\n      *\n      * @param serviceInterfaceClassName the interface whose service interface descriptor file we want to embed\n-     * @param cl the classloader to use to find the service interface descriptor file. Can be null, in which case,\n-     *        this method uses the {@link Thread#getContextClassLoader() thread context classloader}\n+     * @param serviceInterfaceDescriptorFile the path to the service interface descriptor file\n      * @return\n      * @throws IOException\n      */\n-    public static Optional<ServiceProviderBuildItem> allProviders(final String serviceInterfaceClassName, final ClassLoader cl)\n+    public static ServiceProviderBuildItem allProviders(final String serviceInterfaceClassName,\n+            final Path serviceInterfaceDescriptorFile)\n             throws IOException {\n         if (serviceInterfaceClassName == null || serviceInterfaceClassName.trim().isEmpty()) {\n             throw new IllegalArgumentException(\"service interface name cannot be null or blank\");\n         }\n-        final ClassLoader classLoaderToUse = cl == null ? Thread.currentThread().getContextClassLoader() : cl;\n-        final URL serviceDescriptorFile = classLoaderToUse.getResource(SPI_ROOT + serviceInterfaceClassName);\n-        if (serviceDescriptorFile == null) {\n-            return Optional.empty();\n+        if (serviceInterfaceDescriptorFile == null) {\n+            throw new IllegalArgumentException(\"service interface descriptor file path cannot be null\");\n         }\n         final Set<String> classNames = new LinkedHashSet<>();\n-        // parse the services file and add each listed provider\n-        try (final BufferedReader reader = new BufferedReader(\n-                new InputStreamReader(serviceDescriptorFile.openStream(), StandardCharsets.UTF_8))) {\n-            String line = reader.readLine();\n-            while (line != null) {\n-                final int commentIndex = line.indexOf('#');\n-                if (commentIndex >= 0) {\n-                    // strip off anything after the # (including the #)\n-                    line = line.substring(0, commentIndex);\n-                }\n-                line = line.trim();\n-                if (line.length() != 0) {\n-                    classNames.add(line);\n-                }\n-                // move to next line\n-                line = reader.readLine();\n+        final List<String> lines = Files.readAllLines(serviceInterfaceDescriptorFile, StandardCharsets.UTF_8);\n+        // parse each line and add each listed provider\n+        for (String line : lines) {\n+            final int commentIndex = line.indexOf('#');\n+            if (commentIndex >= 0) {\n+                // strip off anything after the # (including the #)\n+                line = line.substring(0, commentIndex);\n+            }\n+            line = line.trim();\n+            if (line.length() != 0) {\n+                classNames.add(line);\n             }\n         }\n-        return Optional.of(new ServiceProviderBuildItem(serviceInterfaceClassName, new ArrayList<>(classNames)));\n+        return new ServiceProviderBuildItem(serviceInterfaceClassName, new ArrayList<>(classNames));\n     }\n \n     /**\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODU1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/9474#discussion_r427698559", "bodyText": "This should actually happen automatically, as ServiceProviderBuildItem should only be consumed in a native build so it will only run if doing a native build.", "author": "stuartwdouglas", "createdAt": "2020-05-20T01:57:20Z", "path": "extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/VertxHttpProcessor.java", "diffHunk": "@@ -185,4 +188,25 @@ void openSocket(ApplicationStartBuildItem start,\n     RuntimeInitializedClassBuildItem configureNativeCompilation() {\n         return new RuntimeInitializedClassBuildItem(\"io.vertx.ext.web.handler.sockjs.impl.XhrTransport\");\n     }\n+\n+    /**\n+     * Register the {@link ExchangeAttributeBuilder} services for native image consumption\n+     * \n+     * @param exchangeAttributeBuilderService\n+     * @throws BuildException\n+     */\n+    @BuildStep(onlyIf = NativeBuild.class)", "originalCommit": "ecd06c23aab7ba3a386c2769ba6b9c794f7e8a03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjM1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/9474#discussion_r427702356", "bodyText": "That makes sense. I'll take care of this while updating this PR.", "author": "jaikiran", "createdAt": "2020-05-20T02:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODU1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyMzk5MQ==", "url": "https://github.com/quarkusio/quarkus/pull/9474#discussion_r427723991", "bodyText": "Updated", "author": "jaikiran", "createdAt": "2020-05-20T03:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODU1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "d1b704131369240e42160e3c34196694ee1cd30d", "chunk": "diff --git a/extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/VertxHttpProcessor.java b/extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/VertxHttpProcessor.java\nindex 98f2369356..31180ae91b 100644\n--- a/extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/VertxHttpProcessor.java\n+++ b/extensions/vertx-http/deployment/src/main/java/io/quarkus/vertx/http/deployment/VertxHttpProcessor.java\n\n@@ -195,18 +203,33 @@ class VertxHttpProcessor {\n      * @param exchangeAttributeBuilderService\n      * @throws BuildException\n      */\n-    @BuildStep(onlyIf = NativeBuild.class)\n+    @BuildStep\n     void registerExchangeAttributeBuilders(final BuildProducer<ServiceProviderBuildItem> exchangeAttributeBuilderService)\n             throws BuildException {\n-        try {\n+        // get hold of the META-INF/services/io.quarkus.vertx.http.runtime.attribute.ExchangeAttributeBuilder\n+        // from within the jar containing the ExchangeAttributeBuilder class\n+        final CodeSource codeSource = ExchangeAttributeBuilder.class.getProtectionDomain().getCodeSource();\n+        if (codeSource == null) {\n+            logger.debug(\"Skipping registration of service providers for \" + ExchangeAttributeBuilder.class);\n+            return;\n+        }\n+        try (final FileSystem jarFileSystem = ZipUtils.newFileSystem(codeSource.getLocation().toURI(),\n+                Collections.emptyMap())) {\n+            final Path serviceDescriptorFilePath = jarFileSystem.getPath(\"META-INF\", \"services\",\n+                    \"io.quarkus.vertx.http.runtime.attribute.ExchangeAttributeBuilder\");\n+            if (!Files.exists(serviceDescriptorFilePath)) {\n+                logger.debug(\"Skipping registration of service providers for \" + ExchangeAttributeBuilder.class\n+                        + \" since no service descriptor file found\");\n+                return;\n+            }\n             // we register all the listed providers since the access log configuration is a runtime construct\n             // and we won't know at build time which attributes the user application will choose\n-            final Optional<ServiceProviderBuildItem> serviceProviderBuildItem = ServiceProviderBuildItem\n-                    .allProviders(ExchangeAttributeBuilder.class.getName(), null);\n-            serviceProviderBuildItem.ifPresent(s -> exchangeAttributeBuilderService.produce(s));\n-        } catch (IOException e) {\n+            final ServiceProviderBuildItem serviceProviderBuildItem;\n+            serviceProviderBuildItem = ServiceProviderBuildItem.allProviders(ExchangeAttributeBuilder.class.getName(),\n+                    serviceDescriptorFilePath);\n+            exchangeAttributeBuilderService.produce(serviceProviderBuildItem);\n+        } catch (IOException | URISyntaxException e) {\n             throw new BuildException(e, Collections.emptyList());\n         }\n-\n     }\n }\n"}}, {"oid": "d1b704131369240e42160e3c34196694ee1cd30d", "url": "https://github.com/quarkusio/quarkus/commit/d1b704131369240e42160e3c34196694ee1cd30d", "message": "issue#9047 Register io.quarkus.vertx.http.runtime.attribute.ExchangeAttributeBuilder service providers for access logging to work in native image", "committedDate": "2020-05-20T03:37:12Z", "type": "commit"}, {"oid": "d1b704131369240e42160e3c34196694ee1cd30d", "url": "https://github.com/quarkusio/quarkus/commit/d1b704131369240e42160e3c34196694ee1cd30d", "message": "issue#9047 Register io.quarkus.vertx.http.runtime.attribute.ExchangeAttributeBuilder service providers for access logging to work in native image", "committedDate": "2020-05-20T03:37:12Z", "type": "forcePushed"}]}