{"pr_number": 7385, "pr_title": "Fix broken MongoClientBuildItem support", "pr_createdAt": "2020-02-24T13:13:54Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/7385", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMzQzMw==", "url": "https://github.com/quarkusio/quarkus/pull/7385#discussion_r383313433", "bodyText": "Why not using this new methods also in the createMongoClientProducerBeanmethods that do the same but based on Jandex ?", "author": "loicmathieu", "createdAt": "2020-02-24T14:57:41Z", "path": "extensions/mongodb-client/deployment/src/main/java/io/quarkus/mongodb/deployment/MongoClientProcessor.java", "diffHunk": "@@ -365,21 +358,51 @@ BeanContainerListenerBuildItem build(\n \n     @Record(RUNTIME_INIT)\n     @BuildStep\n-    void build(MongoClientRecorder recorder, BuildProducer<MongoClientBuildItem> mongoClients, MongodbConfig config) {\n-        if (config.mongoClientConfigs != null && !config.mongoClientConfigs.isEmpty()) {\n-            for (Map.Entry<String, MongoClientConfig> namedDataSourceEntry : config.mongoClientConfigs.entrySet()) {\n-                String name = namedDataSourceEntry.getKey();\n-                mongoClients\n-                        .produce(new MongoClientBuildItem(recorder.getClient(name), recorder.getReactiveClient(name), name));\n+    void configureRuntimePropertiesAndBuildClients(MongoClientRecorder recorder,\n+            CodecProviderBuildItem codecProvider,\n+            BsonDiscriminatorBuildItem bsonDiscriminator,\n+            MongodbConfig mongodbConfig, ConfigurationBuildItem config,\n+            BuildProducer<MongoClientBuildItem> mongoClients) {\n+        recorder.configureRuntimeProperties(codecProvider.getCodecProviderClassNames(),\n+                bsonDiscriminator.getBsonDiscriminatorClassNames(), mongodbConfig);\n+\n+        for (String connectionName : resolveAllConnectionNamesFromConfig(config)) {\n+            mongoClients.produce(new MongoClientBuildItem(recorder.getClient(connectionName),\n+                    recorder.getReactiveClient(connectionName), connectionName));\n+        }\n+    }\n+\n+    private Set<String> resolveAllConnectionNamesFromConfig(ConfigurationBuildItem config) {", "originalCommit": "ad376e42465a03925f579b1f63ea55f28385e235", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMjQ0OQ==", "url": "https://github.com/quarkusio/quarkus/pull/7385#discussion_r383322449", "bodyText": "That is an interesting idea! I went the way I did because that solution feels closer to the problem at hand.\nThat said, I'll sleep on this idea and once the Camel folks respond with whether or not the whole idea works then I'll have settled :)", "author": "geoand", "createdAt": "2020-02-24T15:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMzQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2OTMyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/7385#discussion_r383569325", "bodyText": "Implemented", "author": "geoand", "createdAt": "2020-02-24T23:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMxMzQzMw=="}], "type": "inlineReview", "revised_code": {"commit": "15e2f328234c7e7afe550e90f1936f076269020e", "chunk": "diff --git a/extensions/mongodb-client/deployment/src/main/java/io/quarkus/mongodb/deployment/MongoClientProcessor.java b/extensions/mongodb-client/deployment/src/main/java/io/quarkus/mongodb/deployment/MongoClientProcessor.java\nindex 450bf9aebb..24fcbf3db9 100644\n--- a/extensions/mongodb-client/deployment/src/main/java/io/quarkus/mongodb/deployment/MongoClientProcessor.java\n+++ b/extensions/mongodb-client/deployment/src/main/java/io/quarkus/mongodb/deployment/MongoClientProcessor.java\n\n@@ -359,50 +383,53 @@ public class MongoClientProcessor {\n     @Record(RUNTIME_INIT)\n     @BuildStep\n     void configureRuntimePropertiesAndBuildClients(MongoClientRecorder recorder,\n-            CodecProviderBuildItem codecProvider,\n-            BsonDiscriminatorBuildItem bsonDiscriminator,\n+            CodecProviderBuildItem codecProvider, BsonDiscriminatorBuildItem bsonDiscriminator,\n+            List<MongoConnectionPoolListenerBuildItem> connectionPoolListenerProvider,\n+            List<MongoClientNameBuildItem> mongoClientNames,\n             MongodbConfig mongodbConfig, ConfigurationBuildItem config,\n-            BuildProducer<MongoClientBuildItem> mongoClients) {\n+            BuildProducer<MongoConnectionNameBuildItem> mongoConnections) {\n+\n+        List<ConnectionPoolListener> poolListenerList = connectionPoolListenerProvider.stream()\n+                .map(MongoConnectionPoolListenerBuildItem::getConnectionPoolListener)\n+                .collect(Collectors.toList());\n+\n         recorder.configureRuntimeProperties(codecProvider.getCodecProviderClassNames(),\n-                bsonDiscriminator.getBsonDiscriminatorClassNames(), mongodbConfig);\n+                bsonDiscriminator.getBsonDiscriminatorClassNames(),\n+                mongodbConfig,\n+                poolListenerList);\n \n-        for (String connectionName : resolveAllConnectionNamesFromConfig(config)) {\n-            mongoClients.produce(new MongoClientBuildItem(recorder.getClient(connectionName),\n-                    recorder.getReactiveClient(connectionName), connectionName));\n+        mongoConnections.produce(new MongoConnectionNameBuildItem(MongoClientRecorder.DEFAULT_MONGOCLIENT_NAME));\n+        for (MongoClientNameBuildItem bi : mongoClientNames) {\n+            mongoConnections.produce(new MongoConnectionNameBuildItem(bi.getName()));\n         }\n     }\n \n-    private Set<String> resolveAllConnectionNamesFromConfig(ConfigurationBuildItem config) {\n-        Set<String> allMongodbConfigConnectionOptionNames = allMongodbRuntimeConfigOptionNames(config);\n-        Set<String> connectionNames = new HashSet<>(1);\n-\n-        Iterable<String> propertyNames = ConfigProvider.getConfig().getPropertyNames();\n-        for (String propertyName : propertyNames) {\n-            if (!propertyName.startsWith(CONFIG_PREFIX)) {\n-                continue;\n-            }\n-            String propertyWithoutPrefix = propertyName.replace(CONFIG_PREFIX, \"\");\n-            int dotIndex = propertyWithoutPrefix.indexOf('.');\n-\n-            String topLevelPropertyName = dotIndex == -1 ? propertyWithoutPrefix\n-                    : propertyWithoutPrefix.substring(0, dotIndex).trim();\n-            if (allMongodbConfigConnectionOptionNames.contains(topLevelPropertyName)) {\n-                connectionNames.add(MongoClientRecorder.DEFAULT_MONGOCLIENT_NAME);\n-            } else {\n-                connectionNames.add(topLevelPropertyName);\n-            }\n+    /**\n+     * We only create the bytecode that returns Mongo clients when MongoClientBuildItem is used\n+     * This is an optimization in order to avoid having to make all mongo client beans unremovable\n+     * by default.\n+     * When the build consumes MongoClientBuildItem, then we need to make the all clients unremovable\n+     * by default, because they are not referenced by CDI injection points\n+     */\n+    @BuildStep\n+    @Record(value = RUNTIME_INIT, optional = true)\n+    List<MongoClientBuildItem> mongoClients(MongoClientRecorder recorder, List<MongoConnectionNameBuildItem> mongoConnections) {\n+        List<MongoClientBuildItem> result = new ArrayList<>(mongoConnections.size());\n+        for (MongoConnectionNameBuildItem mongoConnection : mongoConnections) {\n+            String name = mongoConnection.getName();\n+            result.add(new MongoClientBuildItem(recorder.getClient(name), recorder.getReactiveClient(name), name));\n         }\n-        return connectionNames;\n+        return result;\n     }\n \n-    private Set<String> allMongodbRuntimeConfigOptionNames(ConfigurationBuildItem config) {\n-        Set<String> mongodbConfigConnectionOptionNames = new HashSet<>(20);\n-        Iterable<String> strings = config.getReadResult().getRunTimePatternMap()\n-                .getChild(MongodbConfig.CONFIG_NAME).childNames();\n-        for (String string : strings) {\n-            mongodbConfigConnectionOptionNames.add(string);\n-        }\n-        return mongodbConfigConnectionOptionNames;\n+    /**\n+     * When MongoClientBuildItem is actually consumed by the build, then we need to make all the mongo beans unremovable\n+     * because they can be potentially used by the consumers\n+     */\n+    @BuildStep\n+    @Weak\n+    MongoUnremovableClientsBuildItem unremovable(@SuppressWarnings(\"unused\") BuildProducer<MongoClientBuildItem> producer) {\n+        return new MongoUnremovableClientsBuildItem();\n     }\n \n     private String getMongoClientProducerClassName() {\n"}}, {"oid": "15e2f328234c7e7afe550e90f1936f076269020e", "url": "https://github.com/quarkusio/quarkus/commit/15e2f328234c7e7afe550e90f1936f076269020e", "message": "Fix broken MongoClientBuildItem support\n\nFixes: #7378", "committedDate": "2020-02-24T23:06:17Z", "type": "commit"}, {"oid": "15e2f328234c7e7afe550e90f1936f076269020e", "url": "https://github.com/quarkusio/quarkus/commit/15e2f328234c7e7afe550e90f1936f076269020e", "message": "Fix broken MongoClientBuildItem support\n\nFixes: #7378", "committedDate": "2020-02-24T23:06:17Z", "type": "forcePushed"}]}