{"pr_number": 8432, "pr_title": "Upgrade Hibernate ORM to 5.4.14.Final and generate proxies at build time", "pr_createdAt": "2020-04-06T23:26:24Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8432", "timeline": [{"oid": "f498e23ef246d6d185728cc4555ebf4d1afd0767", "url": "https://github.com/quarkusio/quarkus/commit/f498e23ef246d6d185728cc4555ebf4d1afd0767", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T01:04:11Z", "type": "forcePushed"}, {"oid": "e6fd6cdc676833e1358cc4b5070ad2dfcd2f6cfe", "url": "https://github.com/quarkusio/quarkus/commit/e6fd6cdc676833e1358cc4b5070ad2dfcd2f6cfe", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T02:13:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDYzNDk1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404634956", "bodyText": "Oops, this class should not have made it into the PR, fixing now.", "author": "stuartwdouglas", "createdAt": "2020-04-07T08:36:35Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/DeploymentProxyDefinitions.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package io.quarkus.hibernate.orm.deployment;\n+\n+import static org.objectweb.asm.Opcodes.ACC_FINAL;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.hibernate.boot.Metadata;\n+import org.hibernate.bytecode.internal.bytebuddy.BytecodeProviderImpl;\n+import org.hibernate.internal.util.ReflectHelper;\n+import org.hibernate.internal.util.collections.ArrayHelper;\n+import org.hibernate.mapping.PersistentClass;\n+import org.hibernate.proxy.pojo.ProxyFactoryHelper;\n+import org.hibernate.proxy.pojo.bytebuddy.ByteBuddyProxyHelper;\n+import org.jboss.logging.Logger;\n+\n+import net.bytebuddy.dynamic.DynamicType;\n+\n+/**\n+ * Runtime proxies are used by Hibernate ORM to handle a number of corner cases;\n+ * in particular Enhanced Proxies need special consideration in Quarkus as\n+ * they aren't generated by the enhancers during the build.\n+ * Since we can't generate new class definitions at runtime, this value holder\n+ * class is meant to be created at build time and hold onto those class definitions.\n+ *\n+ * Implementors of a custom {@link org.hibernate.bytecode.spi.ProxyFactoryFactory} are\n+ * then able to lookup such class definitions at runtime to create new instances of the\n+ * required enhanced proxies.\n+ *\n+ * Failure to generate such a proxy is not critical, but it implies that Hibernate ORM\n+ * will not be able to use the enhanced proxy mechanism, possibly having to generate\n+ * an additional round trip to the database in some circumstances.\n+ * Most notably we'll fail to generate such a proxy when the entity has a \"final\" modifier;\n+ * we'll also need a default constructor.\n+ * Default constructors are required beyond proxy generation, so a lack of such a constructor\n+ * will have us abort the bootstrap process with a critical error.\n+ * On the other hand, having the entities marked as \"final\" is handled gracefully, as we\n+ * can simply fallback to not use the enhanced proxy for the specific entity, and because\n+ * it's a common case when writing entities in Kotlin.\n+ */\n+public final class DeploymentProxyDefinitions {", "originalCommit": "e6fd6cdc676833e1358cc4b5070ad2dfcd2f6cfe", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "52431c139164eee0571939f8ab10bd89c13aec85", "chunk": "diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/DeploymentProxyDefinitions.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/DeploymentProxyDefinitions.java\ndeleted file mode 100644\nindex 13c7d0aad7..0000000000\n--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/DeploymentProxyDefinitions.java\n+++ /dev/null\n\n@@ -1,149 +0,0 @@\n-package io.quarkus.hibernate.orm.deployment;\n-\n-import static org.objectweb.asm.Opcodes.ACC_FINAL;\n-\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import org.hibernate.boot.Metadata;\n-import org.hibernate.bytecode.internal.bytebuddy.BytecodeProviderImpl;\n-import org.hibernate.internal.util.ReflectHelper;\n-import org.hibernate.internal.util.collections.ArrayHelper;\n-import org.hibernate.mapping.PersistentClass;\n-import org.hibernate.proxy.pojo.ProxyFactoryHelper;\n-import org.hibernate.proxy.pojo.bytebuddy.ByteBuddyProxyHelper;\n-import org.jboss.logging.Logger;\n-\n-import net.bytebuddy.dynamic.DynamicType;\n-\n-/**\n- * Runtime proxies are used by Hibernate ORM to handle a number of corner cases;\n- * in particular Enhanced Proxies need special consideration in Quarkus as\n- * they aren't generated by the enhancers during the build.\n- * Since we can't generate new class definitions at runtime, this value holder\n- * class is meant to be created at build time and hold onto those class definitions.\n- *\n- * Implementors of a custom {@link org.hibernate.bytecode.spi.ProxyFactoryFactory} are\n- * then able to lookup such class definitions at runtime to create new instances of the\n- * required enhanced proxies.\n- *\n- * Failure to generate such a proxy is not critical, but it implies that Hibernate ORM\n- * will not be able to use the enhanced proxy mechanism, possibly having to generate\n- * an additional round trip to the database in some circumstances.\n- * Most notably we'll fail to generate such a proxy when the entity has a \"final\" modifier;\n- * we'll also need a default constructor.\n- * Default constructors are required beyond proxy generation, so a lack of such a constructor\n- * will have us abort the bootstrap process with a critical error.\n- * On the other hand, having the entities marked as \"final\" is handled gracefully, as we\n- * can simply fallback to not use the enhanced proxy for the specific entity, and because\n- * it's a common case when writing entities in Kotlin.\n- */\n-public final class DeploymentProxyDefinitions {\n-\n-    private final Map<Class<?>, DeploymentProxyClassDetailsHolder> proxyDefinitionMap;\n-    private static final Logger LOGGER = Logger.getLogger(DeploymentProxyDefinitions.class.getName());\n-\n-    private DeploymentProxyDefinitions(Map<Class<?>, DeploymentProxyClassDetailsHolder> proxyDefinitionMap) {\n-        this.proxyDefinitionMap = proxyDefinitionMap;\n-    }\n-\n-    public Map<Class<?>, DeploymentProxyClassDetailsHolder> getProxyDefinitionMap() {\n-        return proxyDefinitionMap;\n-    }\n-\n-    public static DeploymentProxyDefinitions createFromMetadata(Metadata storeableMetadata) {\n-        //Check upfront for any need across all metadata: would be nice to avoid initializing the Bytecode provider.\n-        if (needAnyProxyDefinitions(storeableMetadata)) {\n-            final HashMap<Class<?>, DeploymentProxyClassDetailsHolder> proxyDefinitionMap = new HashMap<>();\n-            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n-            try {\n-                final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n-                for (PersistentClass persistentClass : storeableMetadata.getEntityBindings()) {\n-                    if (needsProxyGeneration(persistentClass)) {\n-                        final Class mappedClass = persistentClass.getMappedClass();\n-                        final DynamicType.Unloaded<?> proxyClassDefinition = generateProxyClass(persistentClass,\n-                                byteBuddyProxyHelper);\n-                        if (proxyClassDefinition == null) {\n-                            continue;\n-                        }\n-                        final boolean overridesEquals = ReflectHelper.overridesEquals(mappedClass);\n-                        proxyDefinitionMap.put(mappedClass,\n-                                new DeploymentProxyClassDetailsHolder(overridesEquals,\n-                                        proxyClassDefinition.getTypeDescription().getName(), proxyClassDefinition));\n-                    }\n-                }\n-            } finally {\n-                bytecodeProvider.resetCaches();\n-            }\n-            return new DeploymentProxyDefinitions(proxyDefinitionMap);\n-        } else {\n-            return new DeploymentProxyDefinitions(Collections.emptyMap());\n-        }\n-    }\n-\n-    private static boolean needAnyProxyDefinitions(Metadata storeableMetadata) {\n-        for (PersistentClass persistentClass : storeableMetadata.getEntityBindings()) {\n-            if (needsProxyGeneration(persistentClass))\n-                return true;\n-        }\n-        return false;\n-    }\n-\n-    private static boolean needsProxyGeneration(PersistentClass persistentClass) {\n-        //Only lazy entities need a proxy, and only class-mapped classed can be proxies (Envers!)\n-        return persistentClass.isLazy() && (persistentClass.getMappedClass() != null);\n-    }\n-\n-    private static DynamicType.Unloaded<?> generateProxyClass(PersistentClass persistentClass,\n-            ByteBuddyProxyHelper byteBuddyProxyHelper) {\n-        final String entityName = persistentClass.getEntityName();\n-        final Class mappedClass = persistentClass.getMappedClass();\n-        if ((mappedClass.getModifiers() & ACC_FINAL) == ACC_FINAL) {\n-            LOGGER.warn(\"Could not generate an enhanced proxy for entity '\" + entityName + \"' (class='\"\n-                    + mappedClass.getCanonicalName()\n-                    + \"') as it's final. Your application might perform better if we're allowed to extend it.\");\n-            return null;\n-        }\n-        final Set<Class> proxyInterfaces = ProxyFactoryHelper.extractProxyInterfaces(persistentClass, entityName);\n-        return byteBuddyProxyHelper.buildUnloadedProxy(mappedClass, toArray(proxyInterfaces));\n-    }\n-\n-    private static Class[] toArray(final Set<Class> interfaces) {\n-        if (interfaces == null) {\n-            return ArrayHelper.EMPTY_CLASS_ARRAY;\n-        }\n-        return interfaces.toArray(new Class[interfaces.size()]);\n-    }\n-\n-    public DeploymentProxyClassDetailsHolder getProxyForClass(Class persistentClass) {\n-        return proxyDefinitionMap.get(persistentClass);\n-    }\n-\n-    public static class DeploymentProxyClassDetailsHolder {\n-\n-        private final boolean overridesEquals;\n-        private final String className;\n-        private final DynamicType.Unloaded<?> classData;\n-\n-        public DeploymentProxyClassDetailsHolder(boolean overridesEquals, String className, DynamicType.Unloaded<?> classData) {\n-            this.overridesEquals = overridesEquals;\n-            this.className = className;\n-            this.classData = classData;\n-        }\n-\n-        public boolean isOverridesEquals() {\n-            return overridesEquals;\n-        }\n-\n-        public String getClassName() {\n-            return className;\n-        }\n-\n-        public DynamicType.Unloaded<?> getClassData() {\n-            return classData;\n-        }\n-    }\n-\n-}\n"}}, {"oid": "52431c139164eee0571939f8ab10bd89c13aec85", "url": "https://github.com/quarkusio/quarkus/commit/52431c139164eee0571939f8ab10bd89c13aec85", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T08:36:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2MTY1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404661651", "bodyText": "Not the most readable block but as I understand it, we bail out of any final or entity with no default constructor.\nIf you can write a comment in that effect that will be a bit more readable.\nMaybe even move that logic in a separate method", "author": "emmanuelbernard", "createdAt": "2020-04-07T09:18:35Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -256,9 +269,89 @@ public void build(RecorderContext recorderContext, HibernateOrmRecorder recorder\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n+        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n+        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n+            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n+        }\n+\n+        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n+                generatedClassBuildItemBuildProducer);\n+\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n+                                proxyDefinitions)));\n+    }\n+\n+    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n+            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n+        //create a map of entity to proxy type\n+        PreGeneratedProxies ret = new PreGeneratedProxies();\n+        Map<String, String> proxyAnnotations = new HashMap<>();\n+        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n+            AnnotationValue proxyClass = i.value(\"proxyClass\");\n+            if (proxyClass == null) {\n+                continue;\n+            }\n+            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n+        }\n+        try {\n+\n+            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n+            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n+\n+            for (String entity : entityClassNames) {\n+                Set<Class<?>> proxyInterfaces = new HashSet<>();\n+                proxyInterfaces.add(HibernateProxy.class); //always added\n+                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n+                String proxy = proxyAnnotations.get(entity);\n+                if (proxy != null) {\n+                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n+                } else {\n+                    //if there is no @Proxy we need to make sure the actual class is proxiable", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODEzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404708139", "bodyText": "it's correct, as it mimicks the current semantics: we won't generate them for final classes or entities lacking a default ctor. Appropriate warnings / failures are generated later.", "author": "Sanne", "createdAt": "2020-04-07T10:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2MTY1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\nindex f0b593b1d5..87d3fab127 100644\n--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n\n@@ -269,89 +256,9 @@ public final class HibernateOrmProcessor {\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n-        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n-        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n-            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n-        }\n-\n-        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n-                generatedClassBuildItemBuildProducer);\n-\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n-                                proxyDefinitions)));\n-    }\n-\n-    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n-            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n-        //create a map of entity to proxy type\n-        PreGeneratedProxies ret = new PreGeneratedProxies();\n-        Map<String, String> proxyAnnotations = new HashMap<>();\n-        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n-            AnnotationValue proxyClass = i.value(\"proxyClass\");\n-            if (proxyClass == null) {\n-                continue;\n-            }\n-            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n-        }\n-        try {\n-\n-            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n-            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n-\n-            for (String entity : entityClassNames) {\n-                Set<Class<?>> proxyInterfaces = new HashSet<>();\n-                proxyInterfaces.add(HibernateProxy.class); //always added\n-                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n-                String proxy = proxyAnnotations.get(entity);\n-                if (proxy != null) {\n-                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                } else {\n-                    //if there is no @Proxy we need to make sure the actual class is proxiable\n-                    if (Modifier.isFinal(mappedClass.getModifiers())) {\n-                        continue;\n-                    }\n-                    try {\n-                        mappedClass.getConstructor();\n-                    } catch (NoSuchMethodException e) {\n-                        continue;\n-                    }\n-                }\n-                for (ClassInfo subclass : combinedIndex.getAllKnownSubclasses(DotName.createSimple(entity))) {\n-                    String subclassName = subclass.name().toString();\n-                    if (!entityClassNames.contains(subclassName)) {\n-                        //not an entity\n-                        continue;\n-                    }\n-                    proxy = proxyAnnotations.get(subclassName);\n-                    if (proxy != null) {\n-                        proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                    }\n-                }\n-                DynamicType.Unloaded<?> proxyDef = byteBuddyProxyHelper.buildUnloadedProxy(mappedClass,\n-                        toArray(proxyInterfaces));\n-\n-                for (Entry<TypeDescription, byte[]> i : proxyDef.getAllTypes().entrySet()) {\n-                    generatedClassBuildItemBuildProducer\n-                            .produce(new GeneratedClassBuildItem(true, i.getKey().getName(), i.getValue()));\n-                }\n-                ret.getProxies().put(entity,\n-                        new PreGeneratedProxies.ProxyClassDetailsHolder(proxyDef.getTypeDescription().getName(),\n-                                proxyInterfaces.stream().map(Class::getName).collect(Collectors.toSet())));\n-            }\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return ret;\n-    }\n-\n-    private static Class[] toArray(final Set<Class<?>> interfaces) {\n-        if (interfaces == null) {\n-            return ArrayHelper.EMPTY_CLASS_ARRAY;\n-        }\n-        return interfaces.toArray(new Class[interfaces.size()]);\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n     }\n \n     @BuildStep\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mzg4OA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404663888", "bodyText": "we only need subclasses to enlist their @Proxy, nothing else?", "author": "emmanuelbernard", "createdAt": "2020-04-07T09:22:16Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -256,9 +269,89 @@ public void build(RecorderContext recorderContext, HibernateOrmRecorder recorder\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n+        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n+        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n+            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n+        }\n+\n+        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n+                generatedClassBuildItemBuildProducer);\n+\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n+                                proxyDefinitions)));\n+    }\n+\n+    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n+            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n+        //create a map of entity to proxy type\n+        PreGeneratedProxies ret = new PreGeneratedProxies();\n+        Map<String, String> proxyAnnotations = new HashMap<>();\n+        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n+            AnnotationValue proxyClass = i.value(\"proxyClass\");\n+            if (proxyClass == null) {\n+                continue;\n+            }\n+            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n+        }\n+        try {\n+\n+            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n+            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n+\n+            for (String entity : entityClassNames) {\n+                Set<Class<?>> proxyInterfaces = new HashSet<>();\n+                proxyInterfaces.add(HibernateProxy.class); //always added\n+                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n+                String proxy = proxyAnnotations.get(entity);\n+                if (proxy != null) {\n+                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n+                } else {\n+                    //if there is no @Proxy we need to make sure the actual class is proxiable\n+                    if (Modifier.isFinal(mappedClass.getModifiers())) {\n+                        continue;\n+                    }\n+                    try {\n+                        mappedClass.getConstructor();\n+                    } catch (NoSuchMethodException e) {\n+                        continue;\n+                    }\n+                }\n+                for (ClassInfo subclass : combinedIndex.getAllKnownSubclasses(DotName.createSimple(entity))) {", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczOTE1OQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404739159", "bodyText": "You can't enlist the subclasses themselves, as you can't inherit from multiple classes. From what I could see in the hibernate code this is all that is registered.", "author": "stuartwdouglas", "createdAt": "2020-04-07T11:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY2Mzg4OA=="}], "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\nindex f0b593b1d5..87d3fab127 100644\n--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n\n@@ -269,89 +256,9 @@ public final class HibernateOrmProcessor {\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n-        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n-        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n-            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n-        }\n-\n-        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n-                generatedClassBuildItemBuildProducer);\n-\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n-                                proxyDefinitions)));\n-    }\n-\n-    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n-            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n-        //create a map of entity to proxy type\n-        PreGeneratedProxies ret = new PreGeneratedProxies();\n-        Map<String, String> proxyAnnotations = new HashMap<>();\n-        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n-            AnnotationValue proxyClass = i.value(\"proxyClass\");\n-            if (proxyClass == null) {\n-                continue;\n-            }\n-            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n-        }\n-        try {\n-\n-            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n-            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n-\n-            for (String entity : entityClassNames) {\n-                Set<Class<?>> proxyInterfaces = new HashSet<>();\n-                proxyInterfaces.add(HibernateProxy.class); //always added\n-                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n-                String proxy = proxyAnnotations.get(entity);\n-                if (proxy != null) {\n-                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                } else {\n-                    //if there is no @Proxy we need to make sure the actual class is proxiable\n-                    if (Modifier.isFinal(mappedClass.getModifiers())) {\n-                        continue;\n-                    }\n-                    try {\n-                        mappedClass.getConstructor();\n-                    } catch (NoSuchMethodException e) {\n-                        continue;\n-                    }\n-                }\n-                for (ClassInfo subclass : combinedIndex.getAllKnownSubclasses(DotName.createSimple(entity))) {\n-                    String subclassName = subclass.name().toString();\n-                    if (!entityClassNames.contains(subclassName)) {\n-                        //not an entity\n-                        continue;\n-                    }\n-                    proxy = proxyAnnotations.get(subclassName);\n-                    if (proxy != null) {\n-                        proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                    }\n-                }\n-                DynamicType.Unloaded<?> proxyDef = byteBuddyProxyHelper.buildUnloadedProxy(mappedClass,\n-                        toArray(proxyInterfaces));\n-\n-                for (Entry<TypeDescription, byte[]> i : proxyDef.getAllTypes().entrySet()) {\n-                    generatedClassBuildItemBuildProducer\n-                            .produce(new GeneratedClassBuildItem(true, i.getKey().getName(), i.getValue()));\n-                }\n-                ret.getProxies().put(entity,\n-                        new PreGeneratedProxies.ProxyClassDetailsHolder(proxyDef.getTypeDescription().getName(),\n-                                proxyInterfaces.stream().map(Class::getName).collect(Collectors.toSet())));\n-            }\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return ret;\n-    }\n-\n-    private static Class[] toArray(final Set<Class<?>> interfaces) {\n-        if (interfaces == null) {\n-            return ArrayHelper.EMPTY_CLASS_ARRAY;\n-        }\n-        return interfaces.toArray(new Class[interfaces.size()]);\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n     }\n \n     @BuildStep\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3NzMzNg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404677336", "bodyText": "s/ret/preGeneratedProxies/g", "author": "emmanuelbernard", "createdAt": "2020-04-07T09:43:35Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -256,9 +269,89 @@ public void build(RecorderContext recorderContext, HibernateOrmRecorder recorder\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n+        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n+        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n+            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n+        }\n+\n+        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n+                generatedClassBuildItemBuildProducer);\n+\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n+                                proxyDefinitions)));\n+    }\n+\n+    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n+            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n+        //create a map of entity to proxy type\n+        PreGeneratedProxies ret = new PreGeneratedProxies();", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\nindex f0b593b1d5..87d3fab127 100644\n--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n\n@@ -269,89 +256,9 @@ public final class HibernateOrmProcessor {\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n-        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n-        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n-            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n-        }\n-\n-        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n-                generatedClassBuildItemBuildProducer);\n-\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n-                                proxyDefinitions)));\n-    }\n-\n-    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n-            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n-        //create a map of entity to proxy type\n-        PreGeneratedProxies ret = new PreGeneratedProxies();\n-        Map<String, String> proxyAnnotations = new HashMap<>();\n-        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n-            AnnotationValue proxyClass = i.value(\"proxyClass\");\n-            if (proxyClass == null) {\n-                continue;\n-            }\n-            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n-        }\n-        try {\n-\n-            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n-            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n-\n-            for (String entity : entityClassNames) {\n-                Set<Class<?>> proxyInterfaces = new HashSet<>();\n-                proxyInterfaces.add(HibernateProxy.class); //always added\n-                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n-                String proxy = proxyAnnotations.get(entity);\n-                if (proxy != null) {\n-                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                } else {\n-                    //if there is no @Proxy we need to make sure the actual class is proxiable\n-                    if (Modifier.isFinal(mappedClass.getModifiers())) {\n-                        continue;\n-                    }\n-                    try {\n-                        mappedClass.getConstructor();\n-                    } catch (NoSuchMethodException e) {\n-                        continue;\n-                    }\n-                }\n-                for (ClassInfo subclass : combinedIndex.getAllKnownSubclasses(DotName.createSimple(entity))) {\n-                    String subclassName = subclass.name().toString();\n-                    if (!entityClassNames.contains(subclassName)) {\n-                        //not an entity\n-                        continue;\n-                    }\n-                    proxy = proxyAnnotations.get(subclassName);\n-                    if (proxy != null) {\n-                        proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                    }\n-                }\n-                DynamicType.Unloaded<?> proxyDef = byteBuddyProxyHelper.buildUnloadedProxy(mappedClass,\n-                        toArray(proxyInterfaces));\n-\n-                for (Entry<TypeDescription, byte[]> i : proxyDef.getAllTypes().entrySet()) {\n-                    generatedClassBuildItemBuildProducer\n-                            .produce(new GeneratedClassBuildItem(true, i.getKey().getName(), i.getValue()));\n-                }\n-                ret.getProxies().put(entity,\n-                        new PreGeneratedProxies.ProxyClassDetailsHolder(proxyDef.getTypeDescription().getName(),\n-                                proxyInterfaces.stream().map(Class::getName).collect(Collectors.toSet())));\n-            }\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return ret;\n-    }\n-\n-    private static Class[] toArray(final Set<Class<?>> interfaces) {\n-        if (interfaces == null) {\n-            return ArrayHelper.EMPTY_CLASS_ARRAY;\n-        }\n-        return interfaces.toArray(new Class[interfaces.size()]);\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n     }\n \n     @BuildStep\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4MzUyMw==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404683523", "bodyText": "@Sanne do you know if we need @MappedSuperclass in the list of classes we want to proxy? I guess no but it's unclear from ProxyFactoryHelper.extractProxyInterfaces for me. I guess getSubclassIterator() does not return mappedSuberclass. only real entities.", "author": "emmanuelbernard", "createdAt": "2020-04-07T09:53:46Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -256,9 +269,89 @@ public void build(RecorderContext recorderContext, HibernateOrmRecorder recorder\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n+        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMTQ4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404711486", "bodyText": "I don't see why we'd need it? The class is hopefully already extending its mappedSuperClass - or it's an user error.", "author": "Sanne", "createdAt": "2020-04-07T10:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4MzUyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczOTUzMQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404739531", "bodyText": "yea, this would have no effect.", "author": "stuartwdouglas", "createdAt": "2020-04-07T11:34:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4MzUyMw=="}], "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\nindex f0b593b1d5..87d3fab127 100644\n--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n\n@@ -269,89 +256,9 @@ public final class HibernateOrmProcessor {\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n-        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n-        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n-            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n-        }\n-\n-        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n-                generatedClassBuildItemBuildProducer);\n-\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n-                                proxyDefinitions)));\n-    }\n-\n-    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n-            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n-        //create a map of entity to proxy type\n-        PreGeneratedProxies ret = new PreGeneratedProxies();\n-        Map<String, String> proxyAnnotations = new HashMap<>();\n-        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n-            AnnotationValue proxyClass = i.value(\"proxyClass\");\n-            if (proxyClass == null) {\n-                continue;\n-            }\n-            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n-        }\n-        try {\n-\n-            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n-            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n-\n-            for (String entity : entityClassNames) {\n-                Set<Class<?>> proxyInterfaces = new HashSet<>();\n-                proxyInterfaces.add(HibernateProxy.class); //always added\n-                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n-                String proxy = proxyAnnotations.get(entity);\n-                if (proxy != null) {\n-                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                } else {\n-                    //if there is no @Proxy we need to make sure the actual class is proxiable\n-                    if (Modifier.isFinal(mappedClass.getModifiers())) {\n-                        continue;\n-                    }\n-                    try {\n-                        mappedClass.getConstructor();\n-                    } catch (NoSuchMethodException e) {\n-                        continue;\n-                    }\n-                }\n-                for (ClassInfo subclass : combinedIndex.getAllKnownSubclasses(DotName.createSimple(entity))) {\n-                    String subclassName = subclass.name().toString();\n-                    if (!entityClassNames.contains(subclassName)) {\n-                        //not an entity\n-                        continue;\n-                    }\n-                    proxy = proxyAnnotations.get(subclassName);\n-                    if (proxy != null) {\n-                        proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                    }\n-                }\n-                DynamicType.Unloaded<?> proxyDef = byteBuddyProxyHelper.buildUnloadedProxy(mappedClass,\n-                        toArray(proxyInterfaces));\n-\n-                for (Entry<TypeDescription, byte[]> i : proxyDef.getAllTypes().entrySet()) {\n-                    generatedClassBuildItemBuildProducer\n-                            .produce(new GeneratedClassBuildItem(true, i.getKey().getName(), i.getValue()));\n-                }\n-                ret.getProxies().put(entity,\n-                        new PreGeneratedProxies.ProxyClassDetailsHolder(proxyDef.getTypeDescription().getName(),\n-                                proxyInterfaces.stream().map(Class::getName).collect(Collectors.toSet())));\n-            }\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return ret;\n-    }\n-\n-    private static Class[] toArray(final Set<Class<?>> interfaces) {\n-        if (interfaces == null) {\n-            return ArrayHelper.EMPTY_CLASS_ARRAY;\n-        }\n-        return interfaces.toArray(new Class[interfaces.size()]);\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n     }\n \n     @BuildStep\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzE4OA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404687188", "bodyText": "Please open an issue to Quarkus with a reproducer.", "author": "emmanuelbernard", "createdAt": "2020-04-07T09:59:51Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java", "diffHunk": "@@ -106,8 +108,45 @@ private static Class generateProxyClass(PersistentClass persistentClass, ByteBud\n             return null;\n         }\n         final Set<Class> proxyInterfaces = ProxyFactoryHelper.extractProxyInterfaces(persistentClass, entityName);\n-        Class proxyDef = byteBuddyProxyHelper.buildProxy(mappedClass, toArray(proxyInterfaces));\n-        return proxyDef;\n+        PreGeneratedProxies.ProxyClassDetailsHolder preProxy = preGeneratedProxies.getProxies()\n+                .get(persistentClass.getClassName());\n+        Class<?> preGeneratedProxy = null;\n+        boolean match = true;\n+        if (preProxy != null) {\n+            match = proxyInterfaces.size() == preProxy.getProxyInterfaces().size();\n+            if (match) {\n+                for (Class i : proxyInterfaces) {\n+                    if (!preProxy.getProxyInterfaces().contains(i.getName())) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (match) {\n+                try {\n+                    preGeneratedProxy = Class.forName(preProxy.getClassName(), false,\n+                            Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException e) {\n+                    //should never happen\n+                    throw new RuntimeException(\"Unable to load proxy class\", e);\n+                }\n+            }\n+        }\n+\n+        if (preGeneratedProxy == null) {\n+            if (match) {\n+                LOGGER.warnf(\"Unable to find a build time generated proxy for entity %s\",", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4OTgwNg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404689806", "bodyText": "meaning add that to the message.", "author": "emmanuelbernard", "createdAt": "2020-04-07T10:04:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxNjAyMg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404716022", "bodyText": "+1\nAlso could we include the details of the mismatch, if any. I think we're assuming that this will never actually happen, but if it does it would be super useful to know the class which was expected, if we had that class at all registered in any PreGeneratedProxies , and if we had it what's the interfaces mismatch.", "author": "Sanne", "createdAt": "2020-04-07T10:50:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc0NjMxNg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404746316", "bodyText": "I thought this could happen with Envars? This particular WARN would only happen if an entity was registered we don't know about.", "author": "stuartwdouglas", "createdAt": "2020-04-07T11:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\nindex 77e81f9346..b4f8cbbf9f 100644\n--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\n+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\n\n@@ -108,45 +106,8 @@ public final class ProxyDefinitions {\n             return null;\n         }\n         final Set<Class> proxyInterfaces = ProxyFactoryHelper.extractProxyInterfaces(persistentClass, entityName);\n-        PreGeneratedProxies.ProxyClassDetailsHolder preProxy = preGeneratedProxies.getProxies()\n-                .get(persistentClass.getClassName());\n-        Class<?> preGeneratedProxy = null;\n-        boolean match = true;\n-        if (preProxy != null) {\n-            match = proxyInterfaces.size() == preProxy.getProxyInterfaces().size();\n-            if (match) {\n-                for (Class i : proxyInterfaces) {\n-                    if (!preProxy.getProxyInterfaces().contains(i.getName())) {\n-                        match = false;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (match) {\n-                try {\n-                    preGeneratedProxy = Class.forName(preProxy.getClassName(), false,\n-                            Thread.currentThread().getContextClassLoader());\n-                } catch (ClassNotFoundException e) {\n-                    //should never happen\n-                    throw new RuntimeException(\"Unable to load proxy class\", e);\n-                }\n-            }\n-        }\n-\n-        if (preGeneratedProxy == null) {\n-            if (match) {\n-                LOGGER.warnf(\"Unable to find a build time generated proxy for entity %s\",\n-                        persistentClass.getClassName());\n-            } else {\n-                LOGGER.errorf(\n-                        \"Unable to use a build time generated proxy for entity %s, as the build time proxy interfaces are different to the runtime ones. This should not happen.\",\n-                        persistentClass.getClassName());\n-            }\n-            Class<?> proxyDef = byteBuddyProxyHelper.buildProxy(mappedClass, toArray(proxyInterfaces));\n-            return proxyDef;\n-        } else {\n-            return preGeneratedProxy;\n-        }\n+        Class proxyDef = byteBuddyProxyHelper.buildProxy(mappedClass, toArray(proxyInterfaces));\n+        return proxyDef;\n     }\n \n     private static Class[] toArray(final Set<Class> interfaces) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzIyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404687226", "bodyText": "Please open an issue to Quarkus with a reproducer.", "author": "emmanuelbernard", "createdAt": "2020-04-07T09:59:55Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java", "diffHunk": "@@ -106,8 +108,45 @@ private static Class generateProxyClass(PersistentClass persistentClass, ByteBud\n             return null;\n         }\n         final Set<Class> proxyInterfaces = ProxyFactoryHelper.extractProxyInterfaces(persistentClass, entityName);\n-        Class proxyDef = byteBuddyProxyHelper.buildProxy(mappedClass, toArray(proxyInterfaces));\n-        return proxyDef;\n+        PreGeneratedProxies.ProxyClassDetailsHolder preProxy = preGeneratedProxies.getProxies()\n+                .get(persistentClass.getClassName());\n+        Class<?> preGeneratedProxy = null;\n+        boolean match = true;\n+        if (preProxy != null) {\n+            match = proxyInterfaces.size() == preProxy.getProxyInterfaces().size();\n+            if (match) {\n+                for (Class i : proxyInterfaces) {\n+                    if (!preProxy.getProxyInterfaces().contains(i.getName())) {\n+                        match = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (match) {\n+                try {\n+                    preGeneratedProxy = Class.forName(preProxy.getClassName(), false,\n+                            Thread.currentThread().getContextClassLoader());\n+                } catch (ClassNotFoundException e) {\n+                    //should never happen\n+                    throw new RuntimeException(\"Unable to load proxy class\", e);\n+                }\n+            }\n+        }\n+\n+        if (preGeneratedProxy == null) {\n+            if (match) {\n+                LOGGER.warnf(\"Unable to find a build time generated proxy for entity %s\",\n+                        persistentClass.getClassName());\n+            } else {\n+                LOGGER.errorf(\n+                        \"Unable to use a build time generated proxy for entity %s, as the build time proxy interfaces are different to the runtime ones. This should not happen.\",", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4OTg0NA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404689844", "bodyText": "meaning add that to the message.", "author": "emmanuelbernard", "createdAt": "2020-04-07T10:04:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxNjQ5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404716493", "bodyText": "(same content as above : we'll need to know the details of the mismatch)", "author": "Sanne", "createdAt": "2020-04-07T10:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4NzIyNg=="}], "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\nindex 77e81f9346..b4f8cbbf9f 100644\n--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\n+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\n\n@@ -108,45 +106,8 @@ public final class ProxyDefinitions {\n             return null;\n         }\n         final Set<Class> proxyInterfaces = ProxyFactoryHelper.extractProxyInterfaces(persistentClass, entityName);\n-        PreGeneratedProxies.ProxyClassDetailsHolder preProxy = preGeneratedProxies.getProxies()\n-                .get(persistentClass.getClassName());\n-        Class<?> preGeneratedProxy = null;\n-        boolean match = true;\n-        if (preProxy != null) {\n-            match = proxyInterfaces.size() == preProxy.getProxyInterfaces().size();\n-            if (match) {\n-                for (Class i : proxyInterfaces) {\n-                    if (!preProxy.getProxyInterfaces().contains(i.getName())) {\n-                        match = false;\n-                        break;\n-                    }\n-                }\n-            }\n-            if (match) {\n-                try {\n-                    preGeneratedProxy = Class.forName(preProxy.getClassName(), false,\n-                            Thread.currentThread().getContextClassLoader());\n-                } catch (ClassNotFoundException e) {\n-                    //should never happen\n-                    throw new RuntimeException(\"Unable to load proxy class\", e);\n-                }\n-            }\n-        }\n-\n-        if (preGeneratedProxy == null) {\n-            if (match) {\n-                LOGGER.warnf(\"Unable to find a build time generated proxy for entity %s\",\n-                        persistentClass.getClassName());\n-            } else {\n-                LOGGER.errorf(\n-                        \"Unable to use a build time generated proxy for entity %s, as the build time proxy interfaces are different to the runtime ones. This should not happen.\",\n-                        persistentClass.getClassName());\n-            }\n-            Class<?> proxyDef = byteBuddyProxyHelper.buildProxy(mappedClass, toArray(proxyInterfaces));\n-            return proxyDef;\n-        } else {\n-            return preGeneratedProxy;\n-        }\n+        Class proxyDef = byteBuddyProxyHelper.buildProxy(mappedClass, toArray(proxyInterfaces));\n+        return proxyDef;\n     }\n \n     private static Class[] toArray(final Set<Class> interfaces) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY4ODMzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404688335", "bodyText": "maybe add a dog specific property (getFavoriteToy())", "author": "emmanuelbernard", "createdAt": "2020-04-07T10:01:42Z", "path": "integration-tests/jpa-h2/src/main/java/io/quarkus/it/jpa/h2/proxy/Dog.java", "diffHunk": "@@ -0,0 +1,21 @@\n+package io.quarkus.it.jpa.h2.proxy;\n+\n+import javax.persistence.DiscriminatorValue;\n+import javax.persistence.Entity;\n+\n+import org.hibernate.annotations.Proxy;\n+\n+@Entity\n+@Proxy(proxyClass = DogProxy.class)\n+@DiscriminatorValue(\"DOG\")\n+public class Dog extends Pet implements DogProxy {\n+    @Override\n+    public String makeNoise() {\n+        return bark();\n+    }", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/integration-tests/jpa-h2/src/main/java/io/quarkus/it/jpa/h2/proxy/Dog.java b/integration-tests/jpa-h2/src/main/java/io/quarkus/it/jpa/h2/proxy/Dog.java\ndeleted file mode 100644\nindex 25bd724031..0000000000\n--- a/integration-tests/jpa-h2/src/main/java/io/quarkus/it/jpa/h2/proxy/Dog.java\n+++ /dev/null\n\n@@ -1,21 +0,0 @@\n-package io.quarkus.it.jpa.h2.proxy;\n-\n-import javax.persistence.DiscriminatorValue;\n-import javax.persistence.Entity;\n-\n-import org.hibernate.annotations.Proxy;\n-\n-@Entity\n-@Proxy(proxyClass = DogProxy.class)\n-@DiscriminatorValue(\"DOG\")\n-public class Dog extends Pet implements DogProxy {\n-    @Override\n-    public String makeNoise() {\n-        return bark();\n-    }\n-\n-    @Override\n-    public String bark() {\n-        return \"Woof\";\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404713510", "bodyText": "I know it's horrible, but given the context I think I'd prefer this method to be surrounded by a catch Runtime exception / log warning ?\nThat's to ensure that any unforeseen issue with those proxy generation will indeed get us the \"falllback the current state\" behaviour we discussed.\n(Especially as the method intentionally throws RuntimeException on any CNFE)", "author": "Sanne", "createdAt": "2020-04-07T10:45:53Z", "path": "extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java", "diffHunk": "@@ -256,9 +269,89 @@ public void build(RecorderContext recorderContext, HibernateOrmRecorder recorder\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n+        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n+        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n+            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n+        }\n+\n+        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxNzM0NA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404717344", "bodyText": "p.s. as a fallback of course register an empty PreGeneratedProxies", "author": "Sanne", "createdAt": "2020-04-07T10:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc0MTQ1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404741455", "bodyText": "Why does this get such special treatment? Any PR that normally included such a try/catch because the author was not sure if would work would get rejected. If there is an NPE or some other problem then IMHO this is no different to any other bug.", "author": "stuartwdouglas", "createdAt": "2020-04-07T11:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc0MjAwNQ==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404742005", "bodyText": "@Sanne maybe we should ask for broader review from the hibernate team if you are worried there are cases I have missed?", "author": "stuartwdouglas", "createdAt": "2020-04-07T11:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1NDkwNA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404754904", "bodyText": "yes I would generally react like you say. but we decided to go very cautious here and promised that any problem this would fallback to the previous, slower behaviour gracefully.\nAs you prefer though, I don't consider it blocking.", "author": "Sanne", "createdAt": "2020-04-07T12:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1NTQwNg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404755406", "bodyText": "@Sanne maybe we should ask for broader review from the hibernate team if you are worried there are cases I have missed?\n\nbecause we either will get a timely answer but not entirely sure, or it will take much longer.", "author": "Sanne", "createdAt": "2020-04-07T12:05:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc2Mzg0Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404763842", "bodyText": "Against my better judgement I have added it.", "author": "stuartwdouglas", "createdAt": "2020-04-07T12:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgxNTUwNA==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404815504", "bodyText": "Created #8447 to remove it in 1.5", "author": "emmanuelbernard", "createdAt": "2020-04-07T13:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMzEyNg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404923126", "bodyText": "thank you both!", "author": "Sanne", "createdAt": "2020-04-07T15:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDkyMzMyMg==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404923322", "bodyText": "Created #8447 to remove it in 1.5\n\nwhy not in 1.4 ?", "author": "Sanne", "createdAt": "2020-04-07T15:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcxMzUxMA=="}], "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\nindex f0b593b1d5..87d3fab127 100644\n--- a/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n+++ b/extensions/hibernate-orm/deployment/src/main/java/io/quarkus/hibernate/orm/deployment/HibernateOrmProcessor.java\n\n@@ -269,89 +256,9 @@ public final class HibernateOrmProcessor {\n                     .add((Class<? extends ServiceContributor>) recorderContext.classProxy(serviceContributorClassName));\n         }\n \n-        Set<String> entitiesToGenerateProxiesFor = new HashSet<>(domainObjects.getEntityClassNames());\n-        for (ParsedPersistenceXmlDescriptor unit : allDescriptors) {\n-            entitiesToGenerateProxiesFor.addAll(unit.getManagedClassNames());\n-        }\n-\n-        PreGeneratedProxies proxyDefinitions = generatedProxies(entitiesToGenerateProxiesFor, compositeIndex,\n-                generatedClassBuildItemBuildProducer);\n-\n         beanContainerListener\n                 .produce(new BeanContainerListenerBuildItem(\n-                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses,\n-                                proxyDefinitions)));\n-    }\n-\n-    private PreGeneratedProxies generatedProxies(Set<String> entityClassNames, IndexView combinedIndex,\n-            BuildProducer<GeneratedClassBuildItem> generatedClassBuildItemBuildProducer) {\n-        //create a map of entity to proxy type\n-        PreGeneratedProxies ret = new PreGeneratedProxies();\n-        Map<String, String> proxyAnnotations = new HashMap<>();\n-        for (AnnotationInstance i : combinedIndex.getAnnotations(DotName.createSimple(Proxy.class.getName()))) {\n-            AnnotationValue proxyClass = i.value(\"proxyClass\");\n-            if (proxyClass == null) {\n-                continue;\n-            }\n-            proxyAnnotations.put(i.target().asClass().name().toString(), proxyClass.asClass().name().toString());\n-        }\n-        try {\n-\n-            final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl();\n-            final ByteBuddyProxyHelper byteBuddyProxyHelper = bytecodeProvider.getByteBuddyProxyHelper();\n-\n-            for (String entity : entityClassNames) {\n-                Set<Class<?>> proxyInterfaces = new HashSet<>();\n-                proxyInterfaces.add(HibernateProxy.class); //always added\n-                Class<?> mappedClass = Class.forName(entity, false, Thread.currentThread().getContextClassLoader());\n-                String proxy = proxyAnnotations.get(entity);\n-                if (proxy != null) {\n-                    proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                } else {\n-                    //if there is no @Proxy we need to make sure the actual class is proxiable\n-                    if (Modifier.isFinal(mappedClass.getModifiers())) {\n-                        continue;\n-                    }\n-                    try {\n-                        mappedClass.getConstructor();\n-                    } catch (NoSuchMethodException e) {\n-                        continue;\n-                    }\n-                }\n-                for (ClassInfo subclass : combinedIndex.getAllKnownSubclasses(DotName.createSimple(entity))) {\n-                    String subclassName = subclass.name().toString();\n-                    if (!entityClassNames.contains(subclassName)) {\n-                        //not an entity\n-                        continue;\n-                    }\n-                    proxy = proxyAnnotations.get(subclassName);\n-                    if (proxy != null) {\n-                        proxyInterfaces.add(Class.forName(proxy, false, Thread.currentThread().getContextClassLoader()));\n-                    }\n-                }\n-                DynamicType.Unloaded<?> proxyDef = byteBuddyProxyHelper.buildUnloadedProxy(mappedClass,\n-                        toArray(proxyInterfaces));\n-\n-                for (Entry<TypeDescription, byte[]> i : proxyDef.getAllTypes().entrySet()) {\n-                    generatedClassBuildItemBuildProducer\n-                            .produce(new GeneratedClassBuildItem(true, i.getKey().getName(), i.getValue()));\n-                }\n-                ret.getProxies().put(entity,\n-                        new PreGeneratedProxies.ProxyClassDetailsHolder(proxyDef.getTypeDescription().getName(),\n-                                proxyInterfaces.stream().map(Class::getName).collect(Collectors.toSet())));\n-            }\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new RuntimeException(e);\n-        }\n-        return ret;\n-    }\n-\n-    private static Class[] toArray(final Set<Class<?>> interfaces) {\n-        if (interfaces == null) {\n-            return ArrayHelper.EMPTY_CLASS_ARRAY;\n-        }\n-        return interfaces.toArray(new Class[interfaces.size()]);\n+                        recorder.initMetadata(allDescriptors, scanner, integratorClasses, serviceContributorClasses)));\n     }\n \n     @BuildStep\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDczNjIwNw==", "url": "https://github.com/quarkusio/quarkus/pull/8432#discussion_r404736207", "bodyText": "There's an important optimisation missing here: even if all proxies are generated upfront, we still initialize the Bytecode Provider!\nThe line final BytecodeProviderImpl bytecodeProvider = new BytecodeProviderImpl(); needs to become lazily evaulated if we aim to skip loading all those classes.", "author": "Sanne", "createdAt": "2020-04-07T11:28:07Z", "path": "extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java", "diffHunk": "@@ -49,7 +49,7 @@ private ProxyDefinitions(Map<Class<?>, ProxyClassDetailsHolder> proxyDefinitionM\n         this.proxyDefinitionMap = proxyDefinitionMap;\n     }\n \n-    public static ProxyDefinitions createFromMetadata(Metadata storeableMetadata) {\n+    public static ProxyDefinitions createFromMetadata(Metadata storeableMetadata, PreGeneratedProxies preGeneratedProxies) {\n         //Check upfront for any need across all metadata: would be nice to avoid initializing the Bytecode provider.", "originalCommit": "52431c139164eee0571939f8ab10bd89c13aec85", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "79e4277f5da451843b714af9797bf8da9c1de0a8", "chunk": "diff --git a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\nindex 77e81f9346..b4f8cbbf9f 100644\n--- a/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\n+++ b/extensions/hibernate-orm/runtime/src/main/java/io/quarkus/hibernate/orm/runtime/proxies/ProxyDefinitions.java\n\n@@ -49,7 +49,7 @@ public final class ProxyDefinitions {\n         this.proxyDefinitionMap = proxyDefinitionMap;\n     }\n \n-    public static ProxyDefinitions createFromMetadata(Metadata storeableMetadata, PreGeneratedProxies preGeneratedProxies) {\n+    public static ProxyDefinitions createFromMetadata(Metadata storeableMetadata) {\n         //Check upfront for any need across all metadata: would be nice to avoid initializing the Bytecode provider.\n         if (needAnyProxyDefinitions(storeableMetadata)) {\n             final HashMap<Class<?>, ProxyClassDetailsHolder> proxyDefinitionMap = new HashMap<>();\n"}}, {"oid": "79e4277f5da451843b714af9797bf8da9c1de0a8", "url": "https://github.com/quarkusio/quarkus/commit/79e4277f5da451843b714af9797bf8da9c1de0a8", "message": "Upgrade to Hibernate ORM 5.4.14.Final", "committedDate": "2020-04-07T11:33:30Z", "type": "commit"}, {"oid": "e4eab2237f6fb2cdb8c48990852de02a3750f86b", "url": "https://github.com/quarkusio/quarkus/commit/e4eab2237f6fb2cdb8c48990852de02a3750f86b", "message": "No longer needing the static reflective registrations from HibernateOrmReflections", "committedDate": "2020-04-07T11:33:30Z", "type": "commit"}, {"oid": "4844fa1c146a13ad80742c0b688ad4982a9c8e91", "url": "https://github.com/quarkusio/quarkus/commit/4844fa1c146a13ad80742c0b688ad4982a9c8e91", "message": "Avoid initializing all classes from the vanilla Hibernate ORM service initiator", "committedDate": "2020-04-07T11:33:30Z", "type": "commit"}, {"oid": "6b5d7f6a78016897bff57228cae2bf2eac13286f", "url": "https://github.com/quarkusio/quarkus/commit/6b5d7f6a78016897bff57228cae2bf2eac13286f", "message": "No longer register long time deprecated ServiceContributingIntegrator in Hibernate ORM", "committedDate": "2020-04-07T11:33:30Z", "type": "commit"}, {"oid": "498af1c764180a67b3453e569fbdd4ce7113d583", "url": "https://github.com/quarkusio/quarkus/commit/498af1c764180a67b3453e569fbdd4ce7113d583", "message": "Remove some more dead code", "committedDate": "2020-04-07T11:35:16Z", "type": "commit"}, {"oid": "0b895872b370546a7100b035a42dbeac8f858e73", "url": "https://github.com/quarkusio/quarkus/commit/0b895872b370546a7100b035a42dbeac8f858e73", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T12:10:59Z", "type": "forcePushed"}, {"oid": "18d404740aaca00b64719f51264eb28e08cd61ef", "url": "https://github.com/quarkusio/quarkus/commit/18d404740aaca00b64719f51264eb28e08cd61ef", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T12:19:01Z", "type": "forcePushed"}, {"oid": "b148e4769c504088e370aa3e82b16a7cdaf0c6f0", "url": "https://github.com/quarkusio/quarkus/commit/b148e4769c504088e370aa3e82b16a7cdaf0c6f0", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T12:23:40Z", "type": "commit"}, {"oid": "b148e4769c504088e370aa3e82b16a7cdaf0c6f0", "url": "https://github.com/quarkusio/quarkus/commit/b148e4769c504088e370aa3e82b16a7cdaf0c6f0", "message": "Generate hibernate proxies at build time", "committedDate": "2020-04-07T12:23:40Z", "type": "forcePushed"}]}