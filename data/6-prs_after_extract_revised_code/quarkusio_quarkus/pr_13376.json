{"pr_number": 13376, "pr_title": "Build time minimum log level", "pr_createdAt": "2020-11-19T11:22:00Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13376", "timeline": [{"oid": "a0f4beb59dc022abdc2a53a6a37b4e80cc10dd7f", "url": "https://github.com/quarkusio/quarkus/commit/a0f4beb59dc022abdc2a53a6a37b4e80cc10dd7f", "message": "Add min-level documentation", "committedDate": "2020-12-04T13:12:32Z", "type": "forcePushed"}, {"oid": "93630da4a6f7c5e522928a4a2e7956f5697dccd6", "url": "https://github.com/quarkusio/quarkus/commit/93630da4a6f7c5e522928a4a2e7956f5697dccd6", "message": "Add min-level settings whenever level is set below INFO", "committedDate": "2020-12-15T09:52:36Z", "type": "forcePushed"}, {"oid": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07", "url": "https://github.com/quarkusio/quarkus/commit/cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07", "message": "Add build-time min-level logging option #12938\n\n* It enables log levels below that to be folded in native.\n* Runtime min-level has been removed (was deprecated already).", "committedDate": "2020-12-15T16:23:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE2OTU5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544169593", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The minimum log level level for this category.\n          \n          \n            \n                 * The minimum log level for this category.", "author": "gsmet", "createdAt": "2020-12-16T10:06:41Z", "path": "core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package io.quarkus.runtime.logging;\n+\n+import io.quarkus.runtime.annotations.ConfigGroup;\n+import io.quarkus.runtime.annotations.ConfigItem;\n+\n+@ConfigGroup\n+public class CategoryBuildTimeConfig {\n+    /**\n+     * The minimum log level level for this category.", "originalCommit": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffe77419b6d3fe436a0a91e8999e2535a426b8c1", "chunk": "diff --git a/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java b/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java\nindex ffcb2aef9e..3ac342ef05 100644\n--- a/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java\n+++ b/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryBuildTimeConfig.java\n\n@@ -6,7 +6,7 @@ import io.quarkus.runtime.annotations.ConfigItem;\n @ConfigGroup\n public class CategoryBuildTimeConfig {\n     /**\n-     * The minimum log level level for this category.\n+     * The minimum log level for this category.\n      * By default all categories are configured with <code>INFO</code> minimum level.\n      *\n      * To get runtime logging below <code>INFO</code>, e.g. <code>DEBUG</code> or <code>TRACE</code>,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MDE1MA==", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544170150", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * The log level level for this category.\n          \n          \n            \n                 * The log level for this category.", "author": "gsmet", "createdAt": "2020-12-16T10:07:26Z", "path": "core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java", "diffHunk": "@@ -10,7 +10,10 @@\n public class CategoryConfig {\n \n     /**\n-     * The log level level for this category\n+     * The log level level for this category.", "originalCommit": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffe77419b6d3fe436a0a91e8999e2535a426b8c1", "chunk": "diff --git a/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java b/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java\nindex 68ea1f388a..cb25fa55b1 100644\n--- a/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java\n+++ b/core/runtime/src/main/java/io/quarkus/runtime/logging/CategoryConfig.java\n\n@@ -10,7 +10,7 @@ import io.quarkus.runtime.annotations.ConfigItem;\n public class CategoryConfig {\n \n     /**\n-     * The log level level for this category.\n+     * The log level for this category.\n      *\n      * Note that to get log levels below <code>INFO</code>,\n      * the minimum level build time configuration option needs to be adjusted as well.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDE3MjAxOQ==", "url": "https://github.com/quarkusio/quarkus/pull/13376#discussion_r544172019", "bodyText": "This requires a comment to explain why it's there?", "author": "gsmet", "createdAt": "2020-12-16T10:10:21Z", "path": "core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java", "diffHunk": "@@ -140,4 +166,177 @@ void registerMetrics(LogMetricsHandlerRecorder recorder, LogBuildTimeConfig log,\n             logHandler.produce(new LogHandlerBuildItem(recorder.getLogHandler()));\n         }\n     }\n+\n+    @BuildStep(onlyIf = NativeBuild.class)\n+    void setUpMinLevelLogging(LogBuildTimeConfig log,\n+            final BuildProducer<GeneratedClassBuildItem> generatedTraceLogger) {\n+        ClassOutput output = new GeneratedClassGizmoAdaptor(generatedTraceLogger, false);\n+        if (log.categories.isEmpty() || allMinLevelInfoOrHigher(log.categories)) {\n+            generateDefaultLoggers(output);\n+        } else {\n+            generateCategoryMinLevelLoggers(log.categories, log.minLevel, output);\n+        }\n+    }\n+\n+    private static boolean allMinLevelInfoOrHigher(Map<String, CategoryBuildTimeConfig> categories) {\n+        return categories.values().stream()\n+                .allMatch(categoryConfig -> categoryConfig.minLevel.getLevel().intValue() >= org.jboss.logmanager.Level.INFO\n+                        .intValue());\n+    }\n+\n+    private static void generateDefaultLoggers(ClassOutput output) {\n+        generateDefaultLoggingLogger(output);\n+        generateDefaultLoggerNode(output);\n+        generateLogManagerLogger(output, LoggingResourceProcessor::generateMinLevelDefault);\n+    }\n+\n+    private static void generateCategoryMinLevelLoggers(Map<String, CategoryBuildTimeConfig> categories, Level minLevel,\n+            ClassOutput output) {\n+        generateMinLevelCompute(categories, minLevel.toString(), output);\n+        generateDefaultLoggerNode(output);\n+        generateLogManagerLogger(output, LoggingResourceProcessor::generateMinLevelCheckCategory);\n+    }\n+\n+    private static BranchResult generateMinLevelCheckCategory(MethodCreator method, FieldDescriptor nameAliasDescriptor) {\n+        final ResultHandle levelIntValue = getParamLevelIntValue(method);\n+        final ResultHandle nameAlias = method.readInstanceField(nameAliasDescriptor, method.getThis());\n+        return method.ifTrue(method.invokeStaticMethod(IS_MIN_LEVEL_ENABLED, levelIntValue, nameAlias));\n+    }\n+\n+    private static void generateMinLevelCompute(Map<String, CategoryBuildTimeConfig> categories, String defaultMinLevelName,\n+            ClassOutput output) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(MIN_LEVEL_COMPUTE_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            try (MethodCreator mc = cc.getMethodCreator(IS_MIN_LEVEL_ENABLED)) {\n+                mc.setModifiers(Opcodes.ACC_STATIC);\n+\n+                final ResultHandle level = mc.getMethodParam(0);\n+                final ResultHandle name = mc.getMethodParam(1);\n+\n+                BytecodeCreator current = mc;\n+                for (Map.Entry<String, CategoryBuildTimeConfig> entry : categories.entrySet()) {\n+                    final String category = entry.getKey();\n+                    final int categoryLevelIntValue = entry.getValue().minLevel.getLevel().intValue();\n+\n+                    ResultHandle equalsResult = current.invokeVirtualMethod(\n+                            MethodDescriptor.ofMethod(Object.class, \"equals\", boolean.class, Object.class),\n+                            name, current.load(category));\n+\n+                    BranchResult equalsBranch = current.ifTrue(equalsResult);\n+                    try (BytecodeCreator false1 = equalsBranch.falseBranch()) {\n+                        ResultHandle startsWithResult = false1.invokeVirtualMethod(\n+                                MethodDescriptor.ofMethod(String.class, \"startsWith\", boolean.class, String.class),\n+                                name, false1.load(category));\n+\n+                        BranchResult startsWithBranch = false1.ifTrue(startsWithResult);\n+\n+                        final BytecodeCreator startsWithTrue = startsWithBranch.trueBranch();\n+                        final BranchResult levelCompareBranch = startsWithTrue.ifIntegerGreaterEqual(level,\n+                                startsWithTrue.load(categoryLevelIntValue));\n+                        levelCompareBranch.trueBranch().returnValue(levelCompareBranch.trueBranch().load(true));\n+                        levelCompareBranch.falseBranch().returnValue(levelCompareBranch.falseBranch().load(false));\n+\n+                        current = startsWithBranch.falseBranch();\n+                    }\n+\n+                    equalsBranch.trueBranch().returnValue(equalsBranch.trueBranch().load(true));\n+                }\n+\n+                final ResultHandle infoLevelIntValue = getLogManagerLevelIntValue(defaultMinLevelName, current);\n+                final BranchResult isInfoOrHigherBranch = current.ifIntegerGreaterEqual(level, infoLevelIntValue);\n+                isInfoOrHigherBranch.trueBranch().returnValue(isInfoOrHigherBranch.trueBranch().load(true));\n+                isInfoOrHigherBranch.falseBranch().returnValue(isInfoOrHigherBranch.falseBranch().load(false));\n+            }\n+        }\n+    }\n+\n+    private static void generateDefaultLoggerNode(ClassOutput output) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(LOGGER_NODE_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n+            targetClass.addValue(\"className\", \"org.jboss.logmanager.LoggerNode\");\n+\n+            final MethodCreator isLoggableLevelMethod = cc.getMethodCreator(\"isLoggableLevel\", boolean.class, int.class);\n+            isLoggableLevelMethod.addAnnotation(\"com.oracle.svm.core.annotate.Alias\");\n+            isLoggableLevelMethod.returnValue(isLoggableLevelMethod.load(false));\n+        }\n+    }\n+\n+    private static void generateLogManagerLogger(ClassOutput output,\n+            BiFunction<MethodCreator, FieldDescriptor, BranchResult> isMinLevelEnabledFunction) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(LOGMANAGER_LOGGER_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n+            targetClass.addValue(\"className\", \"org.jboss.logmanager.Logger\");\n+\n+            FieldCreator nameAlias = cc.getFieldCreator(\"name\", String.class);\n+            nameAlias.addAnnotation(\"com.oracle.svm.core.annotate.Alias\");\n+\n+            FieldCreator loggerNodeAlias = cc.getFieldCreator(\"loggerNode\", LOGGER_NODE_CLASS_NAME);\n+            loggerNodeAlias.addAnnotation(\"com.oracle.svm.core.annotate.Alias\");\n+\n+            final MethodCreator isLoggableMethod = cc.getMethodCreator(\"isLoggable\", boolean.class,\n+                    java.util.logging.Level.class);\n+            isLoggableMethod.addAnnotation(\"com.oracle.svm.core.annotate.Substitute\");\n+\n+            final ResultHandle levelIntValue = getParamLevelIntValue(isLoggableMethod);\n+\n+            final BranchResult levelBranch = isMinLevelEnabledFunction.apply(isLoggableMethod, nameAlias.getFieldDescriptor());\n+\n+            final BytecodeCreator levelTrue = levelBranch.trueBranch();\n+            levelTrue.returnValue(\n+                    levelTrue.invokeVirtualMethod(\n+                            MethodDescriptor.ofMethod(LOGGER_NODE_CLASS_NAME, \"isLoggableLevel\", boolean.class, int.class),\n+                            levelTrue.readInstanceField(loggerNodeAlias.getFieldDescriptor(), levelTrue.getThis()),\n+                            levelIntValue));\n+\n+            final BytecodeCreator levelFalse = levelBranch.falseBranch();\n+            levelFalse.returnValue(levelFalse.load(false));\n+        }\n+    }\n+\n+    private static ResultHandle getParamLevelIntValue(MethodCreator method) {\n+        final ResultHandle level = method.getMethodParam(0);\n+        return method\n+                .invokeVirtualMethod(MethodDescriptor.ofMethod(Level.class, \"intValue\", int.class), level);\n+    }\n+\n+    private static BranchResult generateMinLevelDefault(MethodCreator method, FieldDescriptor nameAliasDescriptor) {\n+        final ResultHandle levelIntValue = getParamLevelIntValue(method);\n+        final ResultHandle infoLevelIntValue = getLogManagerLevelIntValue(\"INFO\", method);\n+        return method.ifIntegerGreaterEqual(levelIntValue, infoLevelIntValue);\n+    }\n+\n+    private static ResultHandle getLogManagerLevelIntValue(String levelName, BytecodeCreator method) {\n+        final ResultHandle infoLevel = method.readStaticField(\n+                FieldDescriptor.of(org.jboss.logmanager.Level.class, levelName, org.jboss.logmanager.Level.class));\n+        return method\n+                .invokeVirtualMethod(MethodDescriptor.ofMethod(Level.class, \"intValue\", int.class), infoLevel);\n+    }\n+\n+    private static void generateDefaultLoggingLogger(ClassOutput output) {\n+        try (ClassCreator cc = ClassCreator.builder().setFinal(true)\n+                .className(LOGGING_LOGGER_CLASS_NAME)\n+                .classOutput(output).build()) {\n+\n+            AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n+            targetClass.addValue(\"className\", \"org.jboss.logging.Logger\");\n+\n+            generateFalseFoldMethod(\"isTraceEnabled\", cc);\n+            generateFalseFoldMethod(\"isDebugEnabled\", cc);\n+        }\n+    }\n+\n+    private static void generateFalseFoldMethod(String name, ClassCreator cc) {", "originalCommit": "cdfc43fcb3cd0ecdbc525ba9eb8efb69f267ed07", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "ffe77419b6d3fe436a0a91e8999e2535a426b8c1", "chunk": "diff --git a/core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java b/core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java\nindex f1895f057b..5e91d51af1 100644\n--- a/core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java\n+++ b/core/deployment/src/main/java/io/quarkus/deployment/logging/LoggingResourceProcessor.java\n\n@@ -328,11 +328,16 @@ public final class LoggingResourceProcessor {\n             AnnotationCreator targetClass = cc.addAnnotation(\"com.oracle.svm.core.annotate.TargetClass\");\n             targetClass.addValue(\"className\", \"org.jboss.logging.Logger\");\n \n+            // Constant fold these methods to return false,\n+            // since the build time log level is above this level.\n             generateFalseFoldMethod(\"isTraceEnabled\", cc);\n             generateFalseFoldMethod(\"isDebugEnabled\", cc);\n         }\n     }\n \n+    /**\n+     * Generates a method that is constant-folded to always return false.\n+     */\n     private static void generateFalseFoldMethod(String name, ClassCreator cc) {\n         MethodCreator method = cc.getMethodCreator(name, boolean.class);\n         method.addAnnotation(\"com.oracle.svm.core.annotate.Substitute\");\n"}}, {"oid": "ffe77419b6d3fe436a0a91e8999e2535a426b8c1", "url": "https://github.com/quarkusio/quarkus/commit/ffe77419b6d3fe436a0a91e8999e2535a426b8c1", "message": "Add build-time min-level logging option #12938\n\n* It enables log levels below that to be folded in native.\n* Runtime min-level has been removed (was deprecated already).", "committedDate": "2020-12-21T09:57:00Z", "type": "forcePushed"}, {"oid": "f5c4cadbc539ac5d5998988a7b639288866e3ce0", "url": "https://github.com/quarkusio/quarkus/commit/f5c4cadbc539ac5d5998988a7b639288866e3ce0", "message": "Add build-time min-level logging option #12938\n\n* It enables log levels below that to be folded in native.\n* Runtime min-level has been removed (was deprecated already).", "committedDate": "2021-01-04T17:28:38Z", "type": "commit"}, {"oid": "f5c4cadbc539ac5d5998988a7b639288866e3ce0", "url": "https://github.com/quarkusio/quarkus/commit/f5c4cadbc539ac5d5998988a7b639288866e3ce0", "message": "Add build-time min-level logging option #12938\n\n* It enables log levels below that to be folded in native.\n* Runtime min-level has been removed (was deprecated already).", "committedDate": "2021-01-04T17:28:38Z", "type": "forcePushed"}]}