{"pr_number": 6691, "pr_title": "spring-data-jpa: support custom return type for @Query annotation", "pr_createdAt": "2020-01-21T15:13:08Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/6691", "timeline": [{"oid": "d9d5b25646c866746d58c3bc1967c5223bc2a9b5", "url": "https://github.com/quarkusio/quarkus/commit/d9d5b25646c866746d58c3bc1967c5223bc2a9b5", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-21T15:13:56Z", "type": "forcePushed"}, {"oid": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "url": "https://github.com/quarkusio/quarkus/commit/8a4b2eacf046d658f5c2e7da8a905316fb792095", "message": "spring-data-jpa: deployment unit tests\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-22T03:52:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5NTkzMg==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369395932", "bodyText": "How about this get changed to Objects.requireNonNull?", "author": "geoand", "createdAt": "2020-01-22T06:59:31Z", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +60,54 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {\n+        List<BookRepository.BookCountByYear> list = bookRepository.findAllByPublicationYear();\n+\n+        // #6205 - Make sure elements in list have been properly cast to the target object type.\n+        // If the type is wrong (Object array), this will throw a ClassNotFoundException\n+        BookRepository.BookCountByYear first = list.get(0);\n+        assert (first != null);", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java b/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java\nindex 3280c21bc9..0331cc7816 100644\n--- a/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java\n+++ b/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java\n\n@@ -70,44 +69,23 @@ public class BookResource {\n         // #6205 - Make sure elements in list have been properly cast to the target object type.\n         // If the type is wrong (Object array), this will throw a ClassNotFoundException\n         BookRepository.BookCountByYear first = list.get(0);\n-        assert (first != null);\n+        Objects.requireNonNull(first);\n \n         return list;\n     }\n \n-    public void util() {\n-        List<Object[]> values = new ArrayList<>(3);\n-        values.add(new Object[] { 1982, 2 });\n-        values.add(new Object[] { 1996, 3 });\n-        values.add(new Object[] { 2018, 1 });\n+    @GET\n+    @Path(\"/count/year2\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear2() {\n+        List<BookRepository.BookCountByYear> list = bookRepository.findAllByPublicationYear2();\n \n-        List<BookRepository.BookCountByYear> list = values.stream()\n-                .map((x) -> TestImpl.convert(x))\n-                .collect(Collectors.toList());\n+        // #6205 - Make sure elements in list have been properly cast to the target object type.\n+        // If the type is wrong (Object array), this will throw a ClassNotFoundException\n+        BookRepository.BookCountByYear first = list.get(0);\n+        Objects.requireNonNull(first);\n \n-        System.out.println(list);\n+        return list;\n     }\n \n-    static class TestImpl implements BookRepository.BookCountByYear {\n-\n-        int publicationYear;\n-        long count;\n-\n-        @Override\n-        public int getPublicationYear() {\n-            return publicationYear;\n-        }\n-\n-        @Override\n-        public Long getCount() {\n-            return count;\n-        }\n-\n-        static TestImpl convert(Object[] params) {\n-            TestImpl impl = new TestImpl();\n-            impl.publicationYear = (int) params[0];\n-            impl.count = (long) params[1];\n-            return impl;\n-        }\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5ODAzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369398039", "bodyText": "How about we move generatedClasses right after generatedBeans instead of next to additionalBeans. It will make things a tad more consistent I believe.", "author": "geoand", "createdAt": "2020-01-22T07:08:33Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java", "diffHunk": "@@ -58,7 +61,8 @@ void build(CombinedIndexBuildItem index,\n                 indexIndex);\n \n         removeNoRepositoryBeanClasses(interfacesExtendingCrudRepository);\n-        implementCrudRepositories(generatedBeans, additionalBeans, interfacesExtendingCrudRepository, indexIndex);\n+        implementCrudRepositories(generatedBeans, additionalBeans, generatedClasses,", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java\nindex 7b09fce52d..25370c6d15 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/SpringDataJPAProcessor.java\n\n@@ -61,7 +61,7 @@ public class SpringDataJPAProcessor {\n                 indexIndex);\n \n         removeNoRepositoryBeanClasses(interfacesExtendingCrudRepository);\n-        implementCrudRepositories(generatedBeans, additionalBeans, generatedClasses,\n+        implementCrudRepositories(generatedBeans, generatedClasses, additionalBeans,\n                 interfacesExtendingCrudRepository, indexIndex);\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5ODc5OQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369398799", "bodyText": "The IDE is telling warning me about Redundant group nesting for (([\\w\\.]+))", "author": "geoand", "createdAt": "2020-01-22T07:11:52Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -2,21 +2,28 @@\n \n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n \n import org.jboss.jandex.ClassInfo;\n import org.jboss.jandex.DotName;\n import org.jboss.jandex.IndexView;\n import org.jboss.jandex.MethodInfo;\n import org.jboss.jandex.Type;\n \n+import io.quarkus.deployment.util.HashUtil;\n import io.quarkus.gizmo.MethodDescriptor;\n import io.quarkus.spring.data.deployment.DotNames;\n \n public final class GenerationUtil {\n \n+    private static final Pattern SELECT_CLAUSE = Pattern.compile(\"select\\\\s+(.+)\\\\s+from\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern FIELD_ALIAS = Pattern.compile(\"\\\\s+[as|AS]+\\\\s+(([\\\\w\\\\.]+))\");", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\nindex b75ccd9d34..cabec776f2 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\n\n@@ -2,12 +2,9 @@ package io.quarkus.spring.data.deployment.generate;\n \n import java.util.ArrayList;\n import java.util.Collection;\n-import java.util.Collections;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n \n import org.jboss.jandex.ClassInfo;\n import org.jboss.jandex.DotName;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTYwMA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369399600", "bodyText": "I think this method is unused", "author": "geoand", "createdAt": "2020-01-22T07:14:56Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\nindex b75ccd9d34..cabec776f2 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\n\n@@ -61,50 +54,4 @@ public final class GenerationUtil {\n                 parameterTypesStr.toArray(new String[0]));\n     }\n \n-    static String getSimpleName(DotName ifaceName) {\n-        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n-    }\n-\n-    static DotName createImplDotName(DotName ifaceName) {\n-        String fullName = ifaceName.toString();\n-\n-        // package name: must be in the same package as the interface\n-        final int index = fullName.lastIndexOf('.');\n-        String packageName = \"\";\n-        if (index > 0 && index < fullName.length() - 1) {\n-            packageName = fullName.substring(0, index) + \".\";\n-        }\n-\n-        return DotName.createSimple(packageName\n-                + (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix()) + \"_\"\n-                + HashUtil.sha1(ifaceName.toString()));\n-    }\n-\n-    static List<String> getFieldNames(String queryString) {\n-        Matcher matcher = SELECT_CLAUSE.matcher(queryString);\n-        if (matcher.find()) {\n-            List<String> fieldNames = new ArrayList<>(3);\n-            Matcher aliases = FIELD_ALIAS.matcher(matcher.group(1).trim());\n-            while (aliases.find()) {\n-                fieldNames.add(aliases.group(1));\n-            }\n-            return fieldNames;\n-        }\n-\n-        return Collections.emptyList();\n-    }\n-\n-    public static DotName getPrimitiveTypeName(DotName returnTypeName) {\n-        if (DotNames.LONG.equals(returnTypeName)) {\n-            return DotNames.PRIMITIVE_LONG;\n-        }\n-        if (DotNames.INTEGER.equals(returnTypeName)) {\n-            return DotNames.PRIMITIVE_INTEGER;\n-        }\n-        if (DotNames.BOOLEAN.equals(returnTypeName)) {\n-            return DotNames.PRIMITIVE_BOOLEAN;\n-        }\n-        return returnTypeName;\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369399718", "bodyText": "Perhaps this and the other newly added methods should be moved to a different utility class that is more aptly named?", "author": "geoand", "createdAt": "2020-01-22T07:15:28Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java", "diffHunk": "@@ -53,4 +60,51 @@ static MethodDescriptor toMethodDescriptor(String generatedClassName, MethodInfo\n         return MethodDescriptor.ofMethod(generatedClassName, methodInfo.name(), methodInfo.returnType().name().toString(),\n                 parameterTypesStr.toArray(new String[0]));\n     }\n+\n+    static String getSimpleName(DotName ifaceName) {\n+        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n+    }\n+\n+    static DotName createImplDotName(DotName ifaceName) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Njg0NQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369476845", "bodyText": "This only seems to be used in one class, so could also stay as a private method there.", "author": "gytis", "createdAt": "2020-01-22T10:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNjYyMw==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369616623", "bodyText": "Moved to private methods re: other feedback from @gytis", "author": "ebullient", "createdAt": "2020-01-22T15:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTM5OTcxOA=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\nindex b75ccd9d34..cabec776f2 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/GenerationUtil.java\n\n@@ -61,50 +54,4 @@ public final class GenerationUtil {\n                 parameterTypesStr.toArray(new String[0]));\n     }\n \n-    static String getSimpleName(DotName ifaceName) {\n-        return (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix());\n-    }\n-\n-    static DotName createImplDotName(DotName ifaceName) {\n-        String fullName = ifaceName.toString();\n-\n-        // package name: must be in the same package as the interface\n-        final int index = fullName.lastIndexOf('.');\n-        String packageName = \"\";\n-        if (index > 0 && index < fullName.length() - 1) {\n-            packageName = fullName.substring(0, index) + \".\";\n-        }\n-\n-        return DotName.createSimple(packageName\n-                + (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix()) + \"_\"\n-                + HashUtil.sha1(ifaceName.toString()));\n-    }\n-\n-    static List<String> getFieldNames(String queryString) {\n-        Matcher matcher = SELECT_CLAUSE.matcher(queryString);\n-        if (matcher.find()) {\n-            List<String> fieldNames = new ArrayList<>(3);\n-            Matcher aliases = FIELD_ALIAS.matcher(matcher.group(1).trim());\n-            while (aliases.find()) {\n-                fieldNames.add(aliases.group(1));\n-            }\n-            return fieldNames;\n-        }\n-\n-        return Collections.emptyList();\n-    }\n-\n-    public static DotName getPrimitiveTypeName(DotName returnTypeName) {\n-        if (DotNames.LONG.equals(returnTypeName)) {\n-            return DotNames.PRIMITIVE_LONG;\n-        }\n-        if (DotNames.INTEGER.equals(returnTypeName)) {\n-            return DotNames.PRIMITIVE_INTEGER;\n-        }\n-        if (DotNames.BOOLEAN.equals(returnTypeName)) {\n-            return DotNames.PRIMITIVE_BOOLEAN;\n-        }\n-        return returnTypeName;\n-    }\n-\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401061", "bodyText": "What happens if it's not an interface?\nIn other places we do have code that can deal with this situation (by instantiating a JavaBean for example), but does Spring Data support that?", "author": "geoand", "createdAt": "2020-01-22T07:20:32Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -218,6 +229,32 @@ public void add(ClassCreator classCreator, FieldDescriptor entityClassFieldDescr\n                         }\n                     }\n \n+                    // Find the type of data used in the result\n+                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    Type resultType = verifyQueryResultType(method.returnType());\n+                    DotName customResultTypeName = resultType.name();\n+\n+                    if (customResultTypeName.equals(entityClassInfo.name())\n+                            || customResultTypeName.equals(DotNames.OBJECT)) {\n+                        // Result is using standard entity or Object result type \n+                        customResultTypeName = null;\n+                    } else {\n+                        // The result is using a custom type.\n+                        List<String> fieldNames = GenerationUtil.getFieldNames(queryString);\n+                        if (fieldNames.isEmpty()) {\n+                            throw new IllegalArgumentException(\n+                                    \"Custom Query annotations must specify field aliases when used with a custom type. \"\n+                                            + \"Offending query string is \\\"\" + queryString + \"\\\" on method \" + methodName\n+                                            + \" of Repository \" + repositoryName);\n+                        }\n+\n+                        // If the custom type is an interface, we may need to generate the implementation\n+                        ClassInfo resultClassInfo = index.getClassByName(customResultTypeName);\n+                        if (Modifier.isInterface(resultClassInfo.flags())) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3Mjc0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369572747", "bodyText": "I don't know that Spring supports it, I can test. I'll also see if the newInstance works, though I imagine we'll also miss the field ordering.", "author": "ebullient", "createdAt": "2020-01-22T13:57:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MjM5MA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371242390", "bodyText": "I throw an exception here. I could check to ensure the fields exist, but the code that attempts to convert from one type to the other depends on a method in the generated impl.", "author": "ebullient", "createdAt": "2020-01-27T13:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0NzAzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371247039", "bodyText": "Looks good", "author": "geoand", "createdAt": "2020-01-27T13:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTA2MQ=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\nindex 5f2adeb043..aad733613c 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n\n@@ -230,7 +240,7 @@ public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n                     }\n \n                     // Find the type of data used in the result\n-                    // e.g. method.returnType() is List, but it can contain custom/non-entity elements\n+                    // e.g. method.returnType() is a List that may contain non-entity elements\n                     Type resultType = verifyQueryResultType(method.returnType());\n                     DotName customResultTypeName = resultType.name();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTM3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401376", "bodyText": "It seems like this is unused", "author": "geoand", "createdAt": "2020-01-22T07:21:34Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -31,13 +36,18 @@\n \n public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n \n+    private static final Logger log = Logger.getLogger(CustomQueryMethodsAdder.class.getName());", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MDIyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369570225", "bodyText": "Woops! Yes. I had plans to use it..", "author": "ebullient", "createdAt": "2020-01-22T13:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTM3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\nindex 5f2adeb043..aad733613c 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n\n@@ -36,14 +39,15 @@ import io.quarkus.spring.data.runtime.TypesConverter;\n \n public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n \n-    private static final Logger log = Logger.getLogger(CustomQueryMethodsAdder.class.getName());\n-\n     private static final String QUERY_VALUE_FIELD = \"value\";\n     private static final String QUERY_COUNT_FIELD = \"countQuery\";\n \n+    private static final Pattern SELECT_CLAUSE = Pattern.compile(\"select\\\\s+(.+)\\\\s+from\", Pattern.CASE_INSENSITIVE);\n+    private static final Pattern FIELD_ALIAS = Pattern.compile(\".*\\\\s+[as|AS]+\\\\s+([\\\\w\\\\.]+)\");\n+    private static final Pattern FIELD_NAME = Pattern.compile(\"(\\\\w+).*\");\n+\n     private final IndexView index;\n     private final ClassOutput nonBeansClassOutput;\n-    private final Map<DotName, DotName> customReturnTypes = new HashMap<>(3);\n \n     public CustomQueryMethodsAdder(IndexView index, ClassOutput classOutput) {\n         this.index = index;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTc3MA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369401770", "bodyText": "for each loop perhaps would be nicer?", "author": "geoand", "createdAt": "2020-01-22T07:23:05Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3MDUzNg==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369570536", "bodyText": "I can go to a foreach loop now, yes. Remember that thing where I was dependent on order? That's from then. ;) I'll fix", "author": "ebullient", "createdAt": "2020-01-22T13:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMTc3MA=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\nindex 5f2adeb043..aad733613c 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n\n@@ -363,80 +385,106 @@ public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n         return t;\n     }\n \n-    // Verify the implementation class exists (generate it if necessary)\n-    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n-        DotName interfaceName = interfaceInfo.name();\n-        DotName customImplName = customReturnTypes.get(interfaceName);\n+    private List<String> getFieldNames(String queryString) {\n+        Matcher matcher = SELECT_CLAUSE.matcher(queryString);\n+        if (matcher.find()) {\n+            String selectClause = matcher.group(1).trim();\n+\n+            String[] fields = selectClause.split(\"\\\\s*,\\\\s+\");\n+            List<String> fieldNames = new ArrayList<>(fields.length);\n+            for (String name : fields) {\n+                Matcher m = FIELD_ALIAS.matcher(name);\n+                if (m.matches()) {\n+                    name = m.group(1);\n+                } else {\n+                    Matcher n = FIELD_NAME.matcher(name); // (\\\\w+).*\n+                    if (n.matches()) {\n+                        name = n.group(1);\n+                    }\n+                }\n+                fieldNames.add(name.toLowerCase());\n+            }\n \n-        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n-        if (customImplName == null) {\n-            customImplName = GenerationUtil.createImplDotName(interfaceName);\n-            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n-                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n-                    .build()) {\n+            return fieldNames;\n+        }\n \n-                List<MethodInfo> methods = interfaceInfo.methods();\n+        return Collections.emptyList();\n+    }\n \n-                // Work with methods in declared order\n-                for (int i = 0; i < methods.size(); i++) {\n-                    MethodInfo method = methods.get(i);\n+    private DotName createImplDotName(DotName ifaceName) {\n+        String fullName = ifaceName.toString();\n \n-                    if (!method.parameters().isEmpty()) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it defined parameters\");\n-                    }\n-                    Type returnType = method.returnType();\n-                    if (returnType.kind() == Type.Kind.VOID) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it returns void\");\n-                    }\n+        // package name: must be in the same package as the interface\n+        final int index = fullName.lastIndexOf('.');\n+        String packageName = \"\";\n+        if (index > 0 && index < fullName.length() - 1) {\n+            packageName = fullName.substring(0, index) + \".\";\n+        }\n+\n+        return DotName.createSimple(packageName\n+                + (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix()) + \"_\"\n+                + HashUtil.sha1(ifaceName.toString()));\n+    }\n \n-                    String getterName = method.name();\n-                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n-                    DotName returnTypeName = method.returnType().name();\n-                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+    private void generateCustomResultTypes(DotName interfaceName, DotName implName, Map<String, List<String>> queryMethods) {\n \n-                    if (!fieldNames.contains(propertyName)) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n-                    }\n+        ClassInfo interfaceInfo = index.getClassByName(interfaceName);\n \n-                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n-                            .getFieldDescriptor();\n-                    fields.put(propertyName, field);\n+        try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                .interfaces(interfaceName.toString()).className(implName.toString())\n+                .build()) {\n \n-                    // create getter (based on the interface)\n-                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n-                        getter.setModifiers(Modifier.PUBLIC);\n-                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n-                    }\n+            Map<String, FieldDescriptor> fields = new HashMap<>(3);\n+\n+            for (MethodInfo method : interfaceInfo.methods()) {\n+                String getterName = method.name();\n+                String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+\n+                Type returnType = method.returnType();\n+                if (returnType.kind() == Type.Kind.VOID) {\n+                    throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                            + \" is not a getter method since it returns void\");\n+                }\n+                DotName fieldTypeName = getPrimitiveTypeName(returnType.name());\n+\n+                FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                        .getFieldDescriptor();\n+\n+                // create getter (based on the interface)\n+                try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                    getter.setModifiers(Modifier.PUBLIC);\n+                    getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n                 }\n \n-                // Generate a static 'convert' method, to convert Object[] to field values\n-                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",\n-                        customImplName.toString(), Object[].class.getName())) {\n+                fields.put(propertyName.toLowerCase(), field);\n+            }\n+\n+            // Add static methods to convert from Object[] to this type\n+            for (Map.Entry<String, List<String>> queryMethod : queryMethods.entrySet()) {\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert_\" + queryMethod.getKey(),\n+                        implName.toString(), Object[].class.getName())) {\n                     convert.setModifiers(Modifier.STATIC);\n-                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(customImplName.toString()));\n \n-                    // Work with parameters in declared order\n-                    ResultHandle array = convert.getMethodParam(0);\n+                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(implName.toString()));\n+\n+                    // Use field names in the query-declared order\n+                    List<String> queryNames = queryMethod.getValue();\n \n-                    for (int i = 0; i < fieldNames.size(); i++) {\n-                        FieldDescriptor f = fields.get(fieldNames.get(i));\n+                    // Object[] is the only paramter: values are in column/declared order\n+                    ResultHandle array = convert.getMethodParam(0);\n \n+                    for (int i = 0; i < queryNames.size(); i++) {\n+                        FieldDescriptor f = fields.get(queryNames.get(i));\n                         convert.writeInstanceField(f, newObject,\n                                 castReturnValue(convert, convert.readArrayValue(array, i), f.getType()));\n                     }\n                     convert.returnValue(newObject);\n                 }\n             }\n-\n-            customReturnTypes.put(interfaceInfo.name(), customImplName);\n         }\n-        return customImplName;\n     }\n \n-    public ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n+    private ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n         switch (type) {\n             case \"I\":\n                 resultHandle = methodCreator.invokeStaticMethod(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369402074", "bodyText": "I think we also need to be checking for default methods and skip over those", "author": "geoand", "createdAt": "2020-01-22T07:24:07Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyNzA3OA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370627078", "bodyText": "I've changed it a bit to only look for getters .. Given the impl has to be generated, it can't do/won't build anything else. I will follow-up and ask what is allowed, now that I know what question to ask. ;)", "author": "ebullient", "createdAt": "2020-01-24T13:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYyODU1Nw==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r370628557", "bodyText": "Sounds good", "author": "geoand", "createdAt": "2020-01-24T13:18:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwMjA3NA=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\nindex 5f2adeb043..aad733613c 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n\n@@ -363,80 +385,106 @@ public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n         return t;\n     }\n \n-    // Verify the implementation class exists (generate it if necessary)\n-    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n-        DotName interfaceName = interfaceInfo.name();\n-        DotName customImplName = customReturnTypes.get(interfaceName);\n+    private List<String> getFieldNames(String queryString) {\n+        Matcher matcher = SELECT_CLAUSE.matcher(queryString);\n+        if (matcher.find()) {\n+            String selectClause = matcher.group(1).trim();\n+\n+            String[] fields = selectClause.split(\"\\\\s*,\\\\s+\");\n+            List<String> fieldNames = new ArrayList<>(fields.length);\n+            for (String name : fields) {\n+                Matcher m = FIELD_ALIAS.matcher(name);\n+                if (m.matches()) {\n+                    name = m.group(1);\n+                } else {\n+                    Matcher n = FIELD_NAME.matcher(name); // (\\\\w+).*\n+                    if (n.matches()) {\n+                        name = n.group(1);\n+                    }\n+                }\n+                fieldNames.add(name.toLowerCase());\n+            }\n \n-        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n-        if (customImplName == null) {\n-            customImplName = GenerationUtil.createImplDotName(interfaceName);\n-            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n-                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n-                    .build()) {\n+            return fieldNames;\n+        }\n \n-                List<MethodInfo> methods = interfaceInfo.methods();\n+        return Collections.emptyList();\n+    }\n \n-                // Work with methods in declared order\n-                for (int i = 0; i < methods.size(); i++) {\n-                    MethodInfo method = methods.get(i);\n+    private DotName createImplDotName(DotName ifaceName) {\n+        String fullName = ifaceName.toString();\n \n-                    if (!method.parameters().isEmpty()) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it defined parameters\");\n-                    }\n-                    Type returnType = method.returnType();\n-                    if (returnType.kind() == Type.Kind.VOID) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it returns void\");\n-                    }\n+        // package name: must be in the same package as the interface\n+        final int index = fullName.lastIndexOf('.');\n+        String packageName = \"\";\n+        if (index > 0 && index < fullName.length() - 1) {\n+            packageName = fullName.substring(0, index) + \".\";\n+        }\n+\n+        return DotName.createSimple(packageName\n+                + (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix()) + \"_\"\n+                + HashUtil.sha1(ifaceName.toString()));\n+    }\n \n-                    String getterName = method.name();\n-                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n-                    DotName returnTypeName = method.returnType().name();\n-                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+    private void generateCustomResultTypes(DotName interfaceName, DotName implName, Map<String, List<String>> queryMethods) {\n \n-                    if (!fieldNames.contains(propertyName)) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n-                    }\n+        ClassInfo interfaceInfo = index.getClassByName(interfaceName);\n \n-                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n-                            .getFieldDescriptor();\n-                    fields.put(propertyName, field);\n+        try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                .interfaces(interfaceName.toString()).className(implName.toString())\n+                .build()) {\n \n-                    // create getter (based on the interface)\n-                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n-                        getter.setModifiers(Modifier.PUBLIC);\n-                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n-                    }\n+            Map<String, FieldDescriptor> fields = new HashMap<>(3);\n+\n+            for (MethodInfo method : interfaceInfo.methods()) {\n+                String getterName = method.name();\n+                String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+\n+                Type returnType = method.returnType();\n+                if (returnType.kind() == Type.Kind.VOID) {\n+                    throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                            + \" is not a getter method since it returns void\");\n+                }\n+                DotName fieldTypeName = getPrimitiveTypeName(returnType.name());\n+\n+                FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                        .getFieldDescriptor();\n+\n+                // create getter (based on the interface)\n+                try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                    getter.setModifiers(Modifier.PUBLIC);\n+                    getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n                 }\n \n-                // Generate a static 'convert' method, to convert Object[] to field values\n-                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",\n-                        customImplName.toString(), Object[].class.getName())) {\n+                fields.put(propertyName.toLowerCase(), field);\n+            }\n+\n+            // Add static methods to convert from Object[] to this type\n+            for (Map.Entry<String, List<String>> queryMethod : queryMethods.entrySet()) {\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert_\" + queryMethod.getKey(),\n+                        implName.toString(), Object[].class.getName())) {\n                     convert.setModifiers(Modifier.STATIC);\n-                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(customImplName.toString()));\n \n-                    // Work with parameters in declared order\n-                    ResultHandle array = convert.getMethodParam(0);\n+                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(implName.toString()));\n+\n+                    // Use field names in the query-declared order\n+                    List<String> queryNames = queryMethod.getValue();\n \n-                    for (int i = 0; i < fieldNames.size(); i++) {\n-                        FieldDescriptor f = fields.get(fieldNames.get(i));\n+                    // Object[] is the only paramter: values are in column/declared order\n+                    ResultHandle array = convert.getMethodParam(0);\n \n+                    for (int i = 0; i < queryNames.size(); i++) {\n+                        FieldDescriptor f = fields.get(queryNames.get(i));\n                         convert.writeInstanceField(f, newObject,\n                                 castReturnValue(convert, convert.readArrayValue(array, i), f.getType()));\n                     }\n                     convert.returnValue(newObject);\n                 }\n             }\n-\n-            customReturnTypes.put(interfaceInfo.name(), customImplName);\n         }\n-        return customImplName;\n     }\n \n-    public ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n+    private ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n         switch (type) {\n             case \"I\":\n                 resultHandle = methodCreator.invokeStaticMethod(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369405666", "bodyText": "Although this does do what it's intended to do, I suspect however that it will be problematic when the same Class is returned from multiple repository methods that don't use the same ordering for fields.\nIn you test you have:\n    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")\n    List<BookCountByYear> findAllByPublicationYear();\n\nWhat happens if I do this:\n    @Query(value = \"SELECT COUNT(*) as count, publicationYear as publicationYear FROM Book GROUP BY publicationYear\")\n    List<BookCountByYear> findAllByPublicationYear2();\n\nI actually did try this and it failed :(", "author": "geoand", "createdAt": "2020-01-22T07:37:10Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {\n+            customImplName = GenerationUtil.createImplDotName(interfaceName);\n+            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n+                    .build()) {\n+\n+                List<MethodInfo> methods = interfaceInfo.methods();\n+\n+                // Work with methods in declared order\n+                for (int i = 0; i < methods.size(); i++) {\n+                    MethodInfo method = methods.get(i);\n+\n+                    if (!method.parameters().isEmpty()) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it defined parameters\");\n+                    }\n+                    Type returnType = method.returnType();\n+                    if (returnType.kind() == Type.Kind.VOID) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method since it returns void\");\n+                    }\n+\n+                    String getterName = method.name();\n+                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+                    DotName returnTypeName = method.returnType().name();\n+                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+\n+                    if (!fieldNames.contains(propertyName)) {\n+                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n+                    }\n+\n+                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                            .getFieldDescriptor();\n+                    fields.put(propertyName, field);\n+\n+                    // create getter (based on the interface)\n+                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                        getter.setModifiers(Modifier.PUBLIC);\n+                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n+                    }\n+                }\n+\n+                // Generate a static 'convert' method, to convert Object[] to field values\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNzA0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369407046", "bodyText": "What I think you'll need to do is take into account the fieldNames in the convert method by adding it as a parameter and then doing some magic to work out the proper order", "author": "geoand", "createdAt": "2020-01-22T07:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NDUxMA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369574510", "bodyText": "I think I'd have to mark the query uniquely, and include that in a separate convert method. The order of the columns is significant, so while those have the same custom return type, it is probably safer to treat as two separate implementations. .. maybe. I will have to see if I still have the field order available when calling convert later.", "author": "ebullient", "createdAt": "2020-01-22T14:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQwNTY2Ng=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\nindex 5f2adeb043..aad733613c 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n\n@@ -363,80 +385,106 @@ public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n         return t;\n     }\n \n-    // Verify the implementation class exists (generate it if necessary)\n-    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n-        DotName interfaceName = interfaceInfo.name();\n-        DotName customImplName = customReturnTypes.get(interfaceName);\n+    private List<String> getFieldNames(String queryString) {\n+        Matcher matcher = SELECT_CLAUSE.matcher(queryString);\n+        if (matcher.find()) {\n+            String selectClause = matcher.group(1).trim();\n+\n+            String[] fields = selectClause.split(\"\\\\s*,\\\\s+\");\n+            List<String> fieldNames = new ArrayList<>(fields.length);\n+            for (String name : fields) {\n+                Matcher m = FIELD_ALIAS.matcher(name);\n+                if (m.matches()) {\n+                    name = m.group(1);\n+                } else {\n+                    Matcher n = FIELD_NAME.matcher(name); // (\\\\w+).*\n+                    if (n.matches()) {\n+                        name = n.group(1);\n+                    }\n+                }\n+                fieldNames.add(name.toLowerCase());\n+            }\n \n-        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n-        if (customImplName == null) {\n-            customImplName = GenerationUtil.createImplDotName(interfaceName);\n-            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n-                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n-                    .build()) {\n+            return fieldNames;\n+        }\n \n-                List<MethodInfo> methods = interfaceInfo.methods();\n+        return Collections.emptyList();\n+    }\n \n-                // Work with methods in declared order\n-                for (int i = 0; i < methods.size(); i++) {\n-                    MethodInfo method = methods.get(i);\n+    private DotName createImplDotName(DotName ifaceName) {\n+        String fullName = ifaceName.toString();\n \n-                    if (!method.parameters().isEmpty()) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it defined parameters\");\n-                    }\n-                    Type returnType = method.returnType();\n-                    if (returnType.kind() == Type.Kind.VOID) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it returns void\");\n-                    }\n+        // package name: must be in the same package as the interface\n+        final int index = fullName.lastIndexOf('.');\n+        String packageName = \"\";\n+        if (index > 0 && index < fullName.length() - 1) {\n+            packageName = fullName.substring(0, index) + \".\";\n+        }\n+\n+        return DotName.createSimple(packageName\n+                + (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix()) + \"_\"\n+                + HashUtil.sha1(ifaceName.toString()));\n+    }\n \n-                    String getterName = method.name();\n-                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n-                    DotName returnTypeName = method.returnType().name();\n-                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+    private void generateCustomResultTypes(DotName interfaceName, DotName implName, Map<String, List<String>> queryMethods) {\n \n-                    if (!fieldNames.contains(propertyName)) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n-                    }\n+        ClassInfo interfaceInfo = index.getClassByName(interfaceName);\n \n-                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n-                            .getFieldDescriptor();\n-                    fields.put(propertyName, field);\n+        try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                .interfaces(interfaceName.toString()).className(implName.toString())\n+                .build()) {\n \n-                    // create getter (based on the interface)\n-                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n-                        getter.setModifiers(Modifier.PUBLIC);\n-                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n-                    }\n+            Map<String, FieldDescriptor> fields = new HashMap<>(3);\n+\n+            for (MethodInfo method : interfaceInfo.methods()) {\n+                String getterName = method.name();\n+                String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+\n+                Type returnType = method.returnType();\n+                if (returnType.kind() == Type.Kind.VOID) {\n+                    throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                            + \" is not a getter method since it returns void\");\n+                }\n+                DotName fieldTypeName = getPrimitiveTypeName(returnType.name());\n+\n+                FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                        .getFieldDescriptor();\n+\n+                // create getter (based on the interface)\n+                try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                    getter.setModifiers(Modifier.PUBLIC);\n+                    getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n                 }\n \n-                // Generate a static 'convert' method, to convert Object[] to field values\n-                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",\n-                        customImplName.toString(), Object[].class.getName())) {\n+                fields.put(propertyName.toLowerCase(), field);\n+            }\n+\n+            // Add static methods to convert from Object[] to this type\n+            for (Map.Entry<String, List<String>> queryMethod : queryMethods.entrySet()) {\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert_\" + queryMethod.getKey(),\n+                        implName.toString(), Object[].class.getName())) {\n                     convert.setModifiers(Modifier.STATIC);\n-                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(customImplName.toString()));\n \n-                    // Work with parameters in declared order\n-                    ResultHandle array = convert.getMethodParam(0);\n+                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(implName.toString()));\n+\n+                    // Use field names in the query-declared order\n+                    List<String> queryNames = queryMethod.getValue();\n \n-                    for (int i = 0; i < fieldNames.size(); i++) {\n-                        FieldDescriptor f = fields.get(fieldNames.get(i));\n+                    // Object[] is the only paramter: values are in column/declared order\n+                    ResultHandle array = convert.getMethodParam(0);\n \n+                    for (int i = 0; i < queryNames.size(); i++) {\n+                        FieldDescriptor f = fields.get(queryNames.get(i));\n                         convert.writeInstanceField(f, newObject,\n                                 castReturnValue(convert, convert.readArrayValue(array, i), f.getType()));\n                     }\n                     convert.returnValue(newObject);\n                 }\n             }\n-\n-            customReturnTypes.put(interfaceInfo.name(), customImplName);\n         }\n-        return customImplName;\n     }\n \n-    public ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n+    private ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n         switch (type) {\n             case \"I\":\n                 resultHandle = methodCreator.invokeStaticMethod(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Mjc5NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369472794", "bodyText": "Content of this block could be a private method e.g. generateInterfaceImplementation(...)", "author": "gytis", "createdAt": "2020-01-22T10:14:41Z", "path": "extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java", "diffHunk": "@@ -298,4 +336,119 @@ private ResultHandle generateSort(Integer sortParameterIndex, MethodCreator meth\n         }\n         return sort;\n     }\n+\n+    // Make sure the return type is referencing a class we have indexed \n+    // somewhere along the way (e.g. non-entity return types in @Query methods)\n+    // Unless it is some kind of collection containing multiple types, \n+    // return the type used in the query result.\n+    private Type verifyQueryResultType(Type t) {\n+        if (t.kind() == Kind.ARRAY) {\n+            return verifyQueryResultType(t.asArrayType().component());\n+        } else if (t.kind() == Kind.PARAMETERIZED_TYPE) {\n+            List<Type> list = t.asParameterizedType().arguments();\n+            if (list.size() == 1) {\n+                return verifyQueryResultType(list.get(0));\n+            } else {\n+                for (Type x : list) {\n+                    verifyQueryResultType(x);\n+                }\n+                return t;\n+            }\n+        } else if (!DotNames.OBJECT.equals(t.name())) {\n+            ClassInfo typeClassInfo = index.getClassByName(t.name());\n+            if (typeClassInfo == null) {\n+                throw new IllegalStateException(t.name() + \" was not part of the Quarkus index\");\n+            }\n+        }\n+        return t;\n+    }\n+\n+    // Verify the implementation class exists (generate it if necessary)\n+    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n+        DotName interfaceName = interfaceInfo.name();\n+        DotName customImplName = customReturnTypes.get(interfaceName);\n+\n+        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n+        if (customImplName == null) {", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3MzcyNA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369473724", "bodyText": "Same for further blocks: generateMethod, generateField, generateConverter etc.. I think it might improve readability.", "author": "gytis", "createdAt": "2020-01-22T10:16:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ3Mjc5NA=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\nindex 5f2adeb043..aad733613c 100644\n--- a/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n+++ b/extensions/spring-data-jpa/deployment/src/main/java/io/quarkus/spring/data/deployment/generate/CustomQueryMethodsAdder.java\n\n@@ -363,80 +385,106 @@ public class CustomQueryMethodsAdder extends AbstractMethodsAdder {\n         return t;\n     }\n \n-    // Verify the implementation class exists (generate it if necessary)\n-    private DotName verifyGeneratedImplementationClass(ClassInfo interfaceInfo, List<String> fieldNames) {\n-        DotName interfaceName = interfaceInfo.name();\n-        DotName customImplName = customReturnTypes.get(interfaceName);\n+    private List<String> getFieldNames(String queryString) {\n+        Matcher matcher = SELECT_CLAUSE.matcher(queryString);\n+        if (matcher.find()) {\n+            String selectClause = matcher.group(1).trim();\n+\n+            String[] fields = selectClause.split(\"\\\\s*,\\\\s+\");\n+            List<String> fieldNames = new ArrayList<>(fields.length);\n+            for (String name : fields) {\n+                Matcher m = FIELD_ALIAS.matcher(name);\n+                if (m.matches()) {\n+                    name = m.group(1);\n+                } else {\n+                    Matcher n = FIELD_NAME.matcher(name); // (\\\\w+).*\n+                    if (n.matches()) {\n+                        name = n.group(1);\n+                    }\n+                }\n+                fieldNames.add(name.toLowerCase());\n+            }\n \n-        Map<String, FieldDescriptor> fields = new HashMap<>(fieldNames.size());\n-        if (customImplName == null) {\n-            customImplName = GenerationUtil.createImplDotName(interfaceName);\n-            try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n-                    .interfaces(interfaceName.toString()).className(customImplName.toString())\n-                    .build()) {\n+            return fieldNames;\n+        }\n \n-                List<MethodInfo> methods = interfaceInfo.methods();\n+        return Collections.emptyList();\n+    }\n \n-                // Work with methods in declared order\n-                for (int i = 0; i < methods.size(); i++) {\n-                    MethodInfo method = methods.get(i);\n+    private DotName createImplDotName(DotName ifaceName) {\n+        String fullName = ifaceName.toString();\n \n-                    if (!method.parameters().isEmpty()) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it defined parameters\");\n-                    }\n-                    Type returnType = method.returnType();\n-                    if (returnType.kind() == Type.Kind.VOID) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method since it returns void\");\n-                    }\n+        // package name: must be in the same package as the interface\n+        final int index = fullName.lastIndexOf('.');\n+        String packageName = \"\";\n+        if (index > 0 && index < fullName.length() - 1) {\n+            packageName = fullName.substring(0, index) + \".\";\n+        }\n+\n+        return DotName.createSimple(packageName\n+                + (ifaceName.isInner() ? ifaceName.local() : ifaceName.withoutPackagePrefix()) + \"_\"\n+                + HashUtil.sha1(ifaceName.toString()));\n+    }\n \n-                    String getterName = method.name();\n-                    String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n-                    DotName returnTypeName = method.returnType().name();\n-                    DotName fieldTypeName = GenerationUtil.getPrimitiveTypeName(returnTypeName);\n+    private void generateCustomResultTypes(DotName interfaceName, DotName implName, Map<String, List<String>> queryMethods) {\n \n-                    if (!fieldNames.contains(propertyName)) {\n-                        throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n-                                + \" is not a getter method for a field defined in the original query \" + fieldNames);\n-                    }\n+        ClassInfo interfaceInfo = index.getClassByName(interfaceName);\n \n-                    FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n-                            .getFieldDescriptor();\n-                    fields.put(propertyName, field);\n+        try (ClassCreator implClassCreator = ClassCreator.builder().classOutput(nonBeansClassOutput)\n+                .interfaces(interfaceName.toString()).className(implName.toString())\n+                .build()) {\n \n-                    // create getter (based on the interface)\n-                    try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n-                        getter.setModifiers(Modifier.PUBLIC);\n-                        getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n-                    }\n+            Map<String, FieldDescriptor> fields = new HashMap<>(3);\n+\n+            for (MethodInfo method : interfaceInfo.methods()) {\n+                String getterName = method.name();\n+                String propertyName = JavaBeanUtil.getPropertyNameFromGetter(getterName);\n+\n+                Type returnType = method.returnType();\n+                if (returnType.kind() == Type.Kind.VOID) {\n+                    throw new IllegalArgumentException(\"Method \" + method.name() + \" of interface \" + interfaceName\n+                            + \" is not a getter method since it returns void\");\n+                }\n+                DotName fieldTypeName = getPrimitiveTypeName(returnType.name());\n+\n+                FieldDescriptor field = implClassCreator.getFieldCreator(propertyName, fieldTypeName.toString())\n+                        .getFieldDescriptor();\n+\n+                // create getter (based on the interface)\n+                try (MethodCreator getter = implClassCreator.getMethodCreator(getterName, returnType.toString())) {\n+                    getter.setModifiers(Modifier.PUBLIC);\n+                    getter.returnValue(getter.readInstanceField(field, getter.getThis()));\n                 }\n \n-                // Generate a static 'convert' method, to convert Object[] to field values\n-                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert\",\n-                        customImplName.toString(), Object[].class.getName())) {\n+                fields.put(propertyName.toLowerCase(), field);\n+            }\n+\n+            // Add static methods to convert from Object[] to this type\n+            for (Map.Entry<String, List<String>> queryMethod : queryMethods.entrySet()) {\n+                try (MethodCreator convert = implClassCreator.getMethodCreator(\"convert_\" + queryMethod.getKey(),\n+                        implName.toString(), Object[].class.getName())) {\n                     convert.setModifiers(Modifier.STATIC);\n-                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(customImplName.toString()));\n \n-                    // Work with parameters in declared order\n-                    ResultHandle array = convert.getMethodParam(0);\n+                    ResultHandle newObject = convert.newInstance(MethodDescriptor.ofConstructor(implName.toString()));\n+\n+                    // Use field names in the query-declared order\n+                    List<String> queryNames = queryMethod.getValue();\n \n-                    for (int i = 0; i < fieldNames.size(); i++) {\n-                        FieldDescriptor f = fields.get(fieldNames.get(i));\n+                    // Object[] is the only paramter: values are in column/declared order\n+                    ResultHandle array = convert.getMethodParam(0);\n \n+                    for (int i = 0; i < queryNames.size(); i++) {\n+                        FieldDescriptor f = fields.get(queryNames.get(i));\n                         convert.writeInstanceField(f, newObject,\n                                 castReturnValue(convert, convert.readArrayValue(array, i), f.getType()));\n                     }\n                     convert.returnValue(newObject);\n                 }\n             }\n-\n-            customReturnTypes.put(interfaceInfo.name(), customImplName);\n         }\n-        return customImplName;\n     }\n \n-    public ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n+    private ResultHandle castReturnValue(MethodCreator methodCreator, ResultHandle resultHandle, String type) {\n         switch (type) {\n             case \"I\":\n                 resultHandle = methodCreator.invokeStaticMethod(\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369480958", "bodyText": "I don't know how it's done in Spring Data, but why can't field name without alias be treated as is? Now publicationYear as publicationYear seems redundant.", "author": "gytis", "createdAt": "2020-01-22T10:30:45Z", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java", "diffHunk": "@@ -22,4 +23,14 @@\n     boolean existsBookByPublicationYearBetween(Integer start, Integer end);\n \n     Optional<Book> findByPublicationYear(Integer year);\n+\n+    // issue 6205\n+    @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")", "originalCommit": "8a4b2eacf046d658f5c2e7da8a905316fb792095", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NTY0NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369575644", "bodyText": "I can try using the original name if it is otherwise missing. Will see where that gets me", "author": "ebullient", "createdAt": "2020-01-22T14:02:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzYzNg==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369577636", "bodyText": "Yeah I agree with @gytis . From an implementation perspective it shouldn't be any harder (except probably for a more complex regex)", "author": "geoand", "createdAt": "2020-01-22T14:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNzM0OA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r369617348", "bodyText": "agree", "author": "ebullient", "createdAt": "2020-01-22T15:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ4MDk1OA=="}], "type": "inlineReview", "revised_code": {"commit": "199754ce688b7e5d604185725d9fa12954da954b", "chunk": "diff --git a/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java b/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java\nindex 513695fc0a..502f019ded 100644\n--- a/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java\n+++ b/integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookRepository.java\n\n@@ -28,6 +28,10 @@ public interface BookRepository extends Repository<Book, Integer> {\n     @Query(value = \"SELECT publicationYear as publicationYear, COUNT(*) as count FROM Book GROUP BY publicationYear\")\n     List<BookCountByYear> findAllByPublicationYear();\n \n+    // issue 6205\n+    @Query(value = \"SELECT COUNT(*), publicationYear FROM Book GROUP BY publicationYear\")\n+    List<BookCountByYear> findAllByPublicationYear2();\n+\n     interface BookCountByYear {\n         int getPublicationYear();\n \n"}}, {"oid": "199754ce688b7e5d604185725d9fa12954da954b", "url": "https://github.com/quarkusio/quarkus/commit/199754ce688b7e5d604185725d9fa12954da954b", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-23T21:59:41Z", "type": "forcePushed"}, {"oid": "34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5", "url": "https://github.com/quarkusio/quarkus/commit/34b49e7911dee65b5f4a6f5c3f784e5c7120cdf5", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-23T23:36:15Z", "type": "forcePushed"}, {"oid": "78c2767d8440f23a01399b9a31bfaff360fb2389", "url": "https://github.com/quarkusio/quarkus/commit/78c2767d8440f23a01399b9a31bfaff360fb2389", "message": "Ensure that generated custom query interface implementations are registered for reflection", "committedDate": "2020-01-26T18:31:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371623574", "bodyText": "I am also thinking that the tests should include another custom type as well, just to be sure nothing weird gets tripped", "author": "geoand", "createdAt": "2020-01-28T06:10:15Z", "path": "integration-tests/spring-data-jpa/src/main/java/io/quarkus/it/spring/data/jpa/BookResource.java", "diffHunk": "@@ -58,4 +59,33 @@ public Response findByPublicationYear(@PathParam(\"year\") Integer year) {\n         Optional<Book> book = bookRepository.findByPublicationYear(year);\n         return book.map(b -> Response.ok(book).build()).orElse(Response.noContent().build());\n     }\n+\n+    @GET\n+    @Path(\"/count/year\")\n+    @Produces(\"application/json\")\n+    public List<BookRepository.BookCountByYear> countAllByPublicationYear() {", "originalCommit": "78c2767d8440f23a01399b9a31bfaff360fb2389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwMTE5NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371801194", "bodyText": "Will add another. Give me a few. Will use at least one different attribute type. I'm afraid my brain fails at anything useful for a Join query.", "author": "ebullient", "createdAt": "2020-01-28T13:29:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTgwNDc0NA==", "url": "https://github.com/quarkusio/quarkus/pull/6691#discussion_r371804744", "bodyText": "\ud83d\udc4d", "author": "geoand", "createdAt": "2020-01-28T13:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYyMzU3NA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "97585564a701a507e3efb6682accca1fb9e72251", "url": "https://github.com/quarkusio/quarkus/commit/97585564a701a507e3efb6682accca1fb9e72251", "message": "additional test, review comments\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-28T13:56:54Z", "type": "forcePushed"}, {"oid": "0088903773d108318aba817f5a075b6f9692ccf5", "url": "https://github.com/quarkusio/quarkus/commit/0088903773d108318aba817f5a075b6f9692ccf5", "message": "additional test, review comments\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-29T01:53:06Z", "type": "forcePushed"}, {"oid": "1b2a212f5727590c7c44189662bbc6de3c27a409", "url": "https://github.com/quarkusio/quarkus/commit/1b2a212f5727590c7c44189662bbc6de3c27a409", "message": "Ensure that generated custom query interface implementations are registered for reflection", "committedDate": "2020-01-29T13:32:39Z", "type": "forcePushed"}, {"oid": "a91295622ce9c99b550f9cf409ffb44904e97703", "url": "https://github.com/quarkusio/quarkus/commit/a91295622ce9c99b550f9cf409ffb44904e97703", "message": "spring-data-jpa: Query with custom return type\n\nresolves #6205\n\nSigned-off-by: Erin Schnabel <schnabel@us.ibm.com>", "committedDate": "2020-01-30T06:20:54Z", "type": "commit"}, {"oid": "d0ea1b0eb80477ccaf23cb2156fb5ad3ac5d82a1", "url": "https://github.com/quarkusio/quarkus/commit/d0ea1b0eb80477ccaf23cb2156fb5ad3ac5d82a1", "message": "Ensure that generated custom query interface implementations are registered for reflection", "committedDate": "2020-01-30T06:20:54Z", "type": "commit"}, {"oid": "524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "url": "https://github.com/quarkusio/quarkus/commit/524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "message": "Explicitly include resources in Spring Data QuarkusUnitTest", "committedDate": "2020-01-30T06:31:02Z", "type": "commit"}, {"oid": "524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "url": "https://github.com/quarkusio/quarkus/commit/524b8f6e0f64441fdf31dcb12b4bbda4d308771b", "message": "Explicitly include resources in Spring Data QuarkusUnitTest", "committedDate": "2020-01-30T06:31:02Z", "type": "forcePushed"}]}