{"pr_number": 13537, "pr_title": "Refactoring Vault components to be CDI beans", "pr_createdAt": "2020-11-28T19:06:42Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/13537", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4NTI3Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r549485272", "bodyText": "@vsevel I think the best way to access Arc is via io.quarkus.arc.deployment.BeanContainerBuildItem - you'd add it as the built step parameter and it will give you BeanContainer which will go to the recorder, try it please.\nI believe the other option is to have this runtime config to be wrapped into a synthetic bean (see for ex OidcRecorder) and then inject that into the beans which need it and access it in the @PostConstruct methods - however - I'm not 100% sure it will work in the case of the vault extension - maybe you can experiment with this approach in a follow up PR", "author": "sberyozkin", "createdAt": "2020-12-28T20:59:44Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultRecorder.java", "diffHunk": "@@ -18,12 +18,10 @@\n \n     private static final Logger log = Logger.getLogger(VaultRecorder.class);\n \n-    public RuntimeValue<ConfigSourceProvider> configureRuntimeProperties(VaultBuildTimeConfig vaultBuildTimeConfig,\n-            VaultRuntimeConfig vaultRuntimeConfig,\n-            TlsConfig tlsConfig) {\n-\n+    public RuntimeValue<ConfigSourceProvider> configureRuntimeProperties(VaultRuntimeConfig vaultRuntimeConfig) {\n         if (vaultRuntimeConfig.url.isPresent()) {\n-            VaultManager.init(vaultBuildTimeConfig, vaultRuntimeConfig, tlsConfig);\n+            Arc.container().instance(VaultAuthManager.class).get().setVaultRuntimeConfig(vaultRuntimeConfig);", "originalCommit": "953924d08340fd915a5c8777d564d8a2ea7c64aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyNDg1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r549824855", "bodyText": "thanks for taking a look. happy christmas and new year as well!\nI tried the BeanContainerBuildItem approach. just passing the BeanContainer instance to the configureRuntimeProperties() method (not actually using it), messes up the initialization. it may be related to the fact that the VaultRuntimeConfig is running  in the bootstrap phase? I do not see any other reason. but it makes one of the test fail because of a missing property that should have been loaded by the vault config source.\nhowever doc says:\nHowever, it is safe to expect that the CDI container is fully initialized and running in a `@Record(RUNTIME_INIT)` build step.\nYou can obtain a reference to the container via `CDI.current()` or Quarkus-specific `Arc.container()`.\n\nso I think the current approach is acceptable.\nI will look anyway at the synthetic bean approach.", "author": "vsevel", "createdAt": "2020-12-29T19:41:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4NTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyNTQ1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r549825455", "bodyText": "here is the code that makes the test fail:\n    public RuntimeValue<ConfigSourceProvider> configureRuntimeProperties(VaultRuntimeConfig vaultRuntimeConfig,\n            BeanContainer beanContainer) {\n        if (vaultRuntimeConfig.url.isPresent()) {\n            Arc.container().instance(VaultAuthManager.class).get().setVaultRuntimeConfig(vaultRuntimeConfig);\n            Arc.container().instance(OkHttpVaultClient.class).get().initWith(vaultRuntimeConfig);\n            return new RuntimeValue<>(new VaultConfigSourceProvider(vaultRuntimeConfig));\n        } else {\n            return emptyRuntimeValue();\n        }\n    }", "author": "vsevel", "createdAt": "2020-12-29T19:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4NTI3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTAyNDEzNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r551024135", "bodyText": "@vsevel sure if the current code works then it is fine. Sorry, it may indeed be the issue of the different phases mix-up.", "author": "sberyozkin", "createdAt": "2021-01-03T16:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ4NTI3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "184564a791660b052444bb37cd61f017d60a6ddc", "chunk": "diff --git a/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultRecorder.java b/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultRecorder.java\nindex 31481d878e..03f0e71030 100644\n--- a/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultRecorder.java\n+++ b/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultRecorder.java\n\n@@ -1,41 +1,41 @@\n package io.quarkus.vault.runtime;\n \n-import java.util.Collections;\n+import static java.util.Collections.emptyList;\n \n import org.eclipse.microprofile.config.spi.ConfigSource;\n import org.eclipse.microprofile.config.spi.ConfigSourceProvider;\n import org.jboss.logging.Logger;\n \n import io.quarkus.arc.Arc;\n+import io.quarkus.arc.ArcContainer;\n import io.quarkus.runtime.RuntimeValue;\n import io.quarkus.runtime.annotations.Recorder;\n import io.quarkus.vault.runtime.client.OkHttpVaultClient;\n+import io.quarkus.vault.runtime.config.VaultBootstrapConfig;\n import io.quarkus.vault.runtime.config.VaultConfigSourceProvider;\n-import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n \n @Recorder\n public class VaultRecorder {\n \n     private static final Logger log = Logger.getLogger(VaultRecorder.class);\n \n-    public RuntimeValue<ConfigSourceProvider> configureRuntimeProperties(VaultRuntimeConfig vaultRuntimeConfig) {\n-        if (vaultRuntimeConfig.url.isPresent()) {\n-            Arc.container().instance(VaultAuthManager.class).get().setVaultRuntimeConfig(vaultRuntimeConfig);\n-            Arc.container().instance(OkHttpVaultClient.class).get().initWith(vaultRuntimeConfig);\n-            return new RuntimeValue<>(new VaultConfigSourceProvider(vaultRuntimeConfig));\n-        } else {\n-            return emptyRuntimeValue();\n-        }\n-    }\n-\n-    private RuntimeValue<ConfigSourceProvider> emptyRuntimeValue() {\n-        return new RuntimeValue<>(new EmptyConfigSourceProvider());\n-    }\n+    private static final EmptyConfigSourceProvider EMPTY = new EmptyConfigSourceProvider();\n \n     private static class EmptyConfigSourceProvider implements ConfigSourceProvider {\n         @Override\n-        public Iterable<ConfigSource> getConfigSources(ClassLoader forClassLoader) {\n-            return Collections.emptyList();\n+        public Iterable<ConfigSource> getConfigSources(ClassLoader classLoader) {\n+            return emptyList();\n+        }\n+    }\n+\n+    public RuntimeValue<ConfigSourceProvider> configure(VaultBootstrapConfig vaultBootstrapConfig) {\n+        ConfigSourceProvider configSourceProvider = EMPTY;\n+        if (vaultBootstrapConfig.url.isPresent()) {\n+            ArcContainer container = Arc.container();\n+            container.instance(VaultConfigHolder.class).get().setVaultBootstrapConfig(vaultBootstrapConfig);\n+            container.instance(OkHttpVaultClient.class).get().init();\n+            configSourceProvider = new VaultConfigSourceProvider(vaultBootstrapConfig);\n         }\n+        return new RuntimeValue<>(configSourceProvider);\n     }\n }\n"}}, {"oid": "95d6b62d96a0c02d90a675b1484fe3764801eaba", "url": "https://github.com/quarkusio/quarkus/commit/95d6b62d96a0c02d90a675b1484fe3764801eaba", "message": "Vault CDI", "committedDate": "2020-12-29T20:28:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4ODIyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r551188225", "bodyText": "Why the @Named qualifier? Is it required for some functionality?", "author": "mkouba", "createdAt": "2021-01-04T09:02:31Z", "path": "extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultCredentialsProvider.java", "diffHunk": "@@ -3,28 +3,29 @@\n import java.util.HashMap;\n import java.util.Map;\n \n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Inject;\n+import javax.inject.Named;\n+\n import io.quarkus.credentials.CredentialsProvider;\n import io.quarkus.vault.VaultException;\n+import io.quarkus.vault.VaultKVSecretEngine;\n import io.quarkus.vault.runtime.config.CredentialsProviderConfig;\n import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n \n+@ApplicationScoped\n+@Named(\"vault-credentials-provider\")", "originalCommit": "95d6b62d96a0c02d90a675b1484fe3764801eaba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTIzNzg5NA==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r551237894", "bodyText": "it is related to https://quarkus.io/guides/credentials-provider#new-credentials-provider-extension\nit is needed if you have more than 1 credentials provider in your app.", "author": "vsevel", "createdAt": "2021-01-04T10:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4ODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTI0NjU2MQ==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r551246561", "bodyText": "Hm, are all credential providers required to be @Named? I'm a bit puzzled because the MyCredentialsProvider in https://quarkus.io/guides/credentials-provider#custom-credentials-provider is not @Named.", "author": "mkouba", "createdAt": "2021-01-04T10:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4ODIyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTMyMTI5Mg==", "url": "https://github.com/quarkusio/quarkus/pull/13537#discussion_r551321292", "bodyText": "are all credential providers required to be @nAmed\n\nno, if you create your own credentials provider, and do not include any other provider (e.g. the vault credentials provider) in your app. but if plan to include several providers in your app (hashicorp vault, plus your own provider or any other provider implemented by an extension - e.g. an azure kms), then you will need to distinguish them by name. in the doc it says in the section about providers implemented by extensions: First, you need to name it to avoid collisions in case multiple credentials providers are available in the project:\nif you create your own provider, then you probably know if there will be multiple providers in your app. but if you create an extension with a provider in it, then you don't know what the extension's users will do with it.\nit is the credentials provider's client (e.g. agroal) responsibility to select the appropriate provider, by calling the common service io.quarkus.credentials.runtime.CredentialsProviderFinder.find(String)\nfor instance in agroal Datasources:\n        // credentials provider\n        if (dataSourceRuntimeConfig.credentialsProvider.isPresent()) {\n            String beanName = dataSourceRuntimeConfig.credentialsProviderName.orElse(null);\n            CredentialsProvider credentialsProvider = CredentialsProviderFinder.find(beanName);\n            String name = dataSourceRuntimeConfig.credentialsProvider.get();\n            connectionFactoryConfiguration\n                    .credential(new AgroalVaultCredentialsProviderPassword(name, credentialsProvider));\n        }", "author": "vsevel", "createdAt": "2021-01-04T13:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTE4ODIyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "184564a791660b052444bb37cd61f017d60a6ddc", "chunk": "diff --git a/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultCredentialsProvider.java b/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultCredentialsProvider.java\nindex c9bfd84830..cf6d6212b7 100644\n--- a/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultCredentialsProvider.java\n+++ b/extensions/vault/runtime/src/main/java/io/quarkus/vault/runtime/VaultCredentialsProvider.java\n\n@@ -11,7 +11,7 @@ import io.quarkus.credentials.CredentialsProvider;\n import io.quarkus.vault.VaultException;\n import io.quarkus.vault.VaultKVSecretEngine;\n import io.quarkus.vault.runtime.config.CredentialsProviderConfig;\n-import io.quarkus.vault.runtime.config.VaultRuntimeConfig;\n+import io.quarkus.vault.runtime.config.VaultBootstrapConfig;\n \n @ApplicationScoped\n @Named(\"vault-credentials-provider\")\n"}}, {"oid": "184564a791660b052444bb37cd61f017d60a6ddc", "url": "https://github.com/quarkusio/quarkus/commit/184564a791660b052444bb37cd61f017d60a6ddc", "message": "Vault CDI", "committedDate": "2021-01-06T17:16:56Z", "type": "forcePushed"}, {"oid": "f8b366d5b0d64dc2a96dd8dfd05e62344357788f", "url": "https://github.com/quarkusio/quarkus/commit/f8b366d5b0d64dc2a96dd8dfd05e62344357788f", "message": "Vault CDI", "committedDate": "2021-01-06T18:04:31Z", "type": "commit"}, {"oid": "f8b366d5b0d64dc2a96dd8dfd05e62344357788f", "url": "https://github.com/quarkusio/quarkus/commit/f8b366d5b0d64dc2a96dd8dfd05e62344357788f", "message": "Vault CDI", "committedDate": "2021-01-06T18:04:31Z", "type": "forcePushed"}]}