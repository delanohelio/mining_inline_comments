{"pr_number": 8581, "pr_title": "fix Jaeger metrics initialization", "pr_createdAt": "2020-04-15T09:48:46Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/8581", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408722527", "bodyText": "I would keep passing the boolean and initialize the class in the recorder. I think it would work the same and be a bit less confusing.\nThe recorder method wouldn't be called so the class wouldn't be accessible either.\n(Just guessing, you would need to try)", "author": "gsmet", "createdAt": "2020-04-15T09:56:13Z", "path": "extensions/jaeger/deployment/src/main/java/io/quarkus/jaeger/deployment/JaegerProcessor.java", "diffHunk": "@@ -29,8 +32,11 @@ void setupTracer(JaegerDeploymentRecorder jdr, JaegerBuildTimeConfig buildTimeCo\n \n         if (buildTimeConfig.enabled) {\n             boolean metricsEnabled = capabilities.isCapabilityPresent(Capabilities.METRICS);\n+            MetricsFactory metricsFactory = metricsEnabled\n+                    ? new QuarkusJaegerMetricsFactory()\n+                    : new NoopMetricsFactory();\n \n-            jdr.registerTracer(jaeger, appConfig, metricsEnabled);\n+            jdr.registerTracer(jaeger, appConfig, metricsFactory);", "originalCommit": "33243e8241106e0f3f42d2cc79cf91a4e290f730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyOTkzOA==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408729938", "bodyText": "But that's exactly how it used to be before, and it was failing :-)\nWhat might work is to have 2 recorder methods, 1 for disabled metrics and 1 for enabled metrics. I guess.", "author": "Ladicek", "createdAt": "2020-04-15T10:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczNDc1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408734753", "bodyText": "I am personally fine with the approach of the PR, IMHO this is what the bytecode recording is all about - being able to easily \"pass\" objects from build time to runtime.", "author": "geoand", "createdAt": "2020-04-15T10:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODczODA4Mg==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408738082", "bodyText": "No, it used to be done in QuarkusJaegerTracer based on a dynamic value and in a method called at runtime.\nI won't fight for it but I prefer when it's clear a runtime object is a runtime object.", "author": "gsmet", "createdAt": "2020-04-15T10:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0MzYzNA==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408743634", "bodyText": "Ah, I think I see what you mean now. I'll try.", "author": "Ladicek", "createdAt": "2020-04-15T10:34:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0NjMxMg==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408746312", "bodyText": "Or perhaps not. I have changed JaegerProcessor to be\nboolean metricsEnabled = capabilities.isCapabilityPresent(Capabilities.METRICS);\n\njdr.registerTracer(jaeger, appConfig, metricsEnabled);\njust like before, and then change the JaegerDeploymentRecorder to have this:\nMetricsFactory metricsFactory = metricsEnabled\n        ? new QuarkusJaegerMetricsFactory()\n        : new NoopMetricsFactory();\n\ninitTracerConfig(jaeger);\nquarkusTracer.setMetricsFactory(metricsFactory);\nquarkusTracer.reset();\nBut no, this leads to the same failure as before.\nI'll try the approach with 2 recorder methods.", "author": "Ladicek", "createdAt": "2020-04-15T10:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc0ODA4NQ==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408748085", "bodyText": "OK, well, let's leave it at that then. It's not worth your time.", "author": "gsmet", "createdAt": "2020-04-15T10:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc2OTA4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408769083", "bodyText": "The approach with 2 recorder method works:\nboolean metricsEnabled = capabilities.isCapabilityPresent(Capabilities.METRICS);\n\nif (metricsEnabled) {\n    jdr.registerTracerWithMetrics(jaeger, appConfig);\n} else {\n    jdr.registerTracer(jaeger, appConfig);\n}\nand\nsynchronized public void registerTracer(JaegerConfig jaeger, ApplicationConfig appConfig) {\n    registerTracer(jaeger, appConfig, new NoopMetricsFactory());\n}\n\nsynchronized public void registerTracerWithMetrics(JaegerConfig jaeger, ApplicationConfig appConfig) {\n    registerTracer(jaeger, appConfig, new QuarkusJaegerMetricsFactory());\n}\n\nprivate void registerTracer(JaegerConfig jaeger, ApplicationConfig appConfig, MetricsFactory metricsFactory) {\n    ...\n}\nAnd I think it's certainly worth my time, as I get to learn a lot!", "author": "Ladicek", "createdAt": "2020-04-15T11:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODc5MDE4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/8581#discussion_r408790187", "bodyText": "I have modified the PR to use the approach with 2 recorder methods and currently waiting for CI to finish in my fork.", "author": "Ladicek", "createdAt": "2020-04-15T12:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyNw=="}], "type": "inlineReview", "revised_code": {"commit": "4bab9db1a03a07e558614a6ca7e969650953404c", "chunk": "diff --git a/extensions/jaeger/deployment/src/main/java/io/quarkus/jaeger/deployment/JaegerProcessor.java b/extensions/jaeger/deployment/src/main/java/io/quarkus/jaeger/deployment/JaegerProcessor.java\nindex 14c9240f13..1c754e3cb1 100644\n--- a/extensions/jaeger/deployment/src/main/java/io/quarkus/jaeger/deployment/JaegerProcessor.java\n+++ b/extensions/jaeger/deployment/src/main/java/io/quarkus/jaeger/deployment/JaegerProcessor.java\n\n@@ -32,11 +29,12 @@ public class JaegerProcessor {\n \n         if (buildTimeConfig.enabled) {\n             boolean metricsEnabled = capabilities.isCapabilityPresent(Capabilities.METRICS);\n-            MetricsFactory metricsFactory = metricsEnabled\n-                    ? new QuarkusJaegerMetricsFactory()\n-                    : new NoopMetricsFactory();\n \n-            jdr.registerTracer(jaeger, appConfig, metricsFactory);\n+            if (metricsEnabled) {\n+                jdr.registerTracerWithMetrics(jaeger, appConfig);\n+            } else {\n+                jdr.registerTracerWithoutMetrics(jaeger, appConfig);\n+            }\n         }\n     }\n \n"}}, {"oid": "4bab9db1a03a07e558614a6ca7e969650953404c", "url": "https://github.com/quarkusio/quarkus/commit/4bab9db1a03a07e558614a6ca7e969650953404c", "message": "fix Jaeger metrics initialization\n\nCreation of the correct `MetricsFactory` is moved from runtime\nto build time, which also means that it's created during native\nimage compilation. Therefore, the MicroProfile Metrics API and\nSmallRye Metrics are not required to be present at runtime.\nWhich, in the end, means that native image compilation no longer\nfails when the `quarkus-smallrye-opentracing` extension is present\nbut `quarkus-smallrye-metrics` is not.", "committedDate": "2020-04-15T11:53:45Z", "type": "commit"}, {"oid": "4bab9db1a03a07e558614a6ca7e969650953404c", "url": "https://github.com/quarkusio/quarkus/commit/4bab9db1a03a07e558614a6ca7e969650953404c", "message": "fix Jaeger metrics initialization\n\nCreation of the correct `MetricsFactory` is moved from runtime\nto build time, which also means that it's created during native\nimage compilation. Therefore, the MicroProfile Metrics API and\nSmallRye Metrics are not required to be present at runtime.\nWhich, in the end, means that native image compilation no longer\nfails when the `quarkus-smallrye-opentracing` extension is present\nbut `quarkus-smallrye-metrics` is not.", "committedDate": "2020-04-15T11:53:45Z", "type": "forcePushed"}]}