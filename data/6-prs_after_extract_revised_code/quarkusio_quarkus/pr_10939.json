{"pr_number": 10939, "pr_title": "Allow reading configuration from Kubernetes secrets", "pr_createdAt": "2020-07-23T15:29:39Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/10939", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDE4Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459864187", "bodyText": "Can we please have some Javadoc on what the purpose of this is? I know we don't have it in all Build Items, but let's at least try to add it for build items we change :)", "author": "geoand", "createdAt": "2020-07-24T05:54:31Z", "path": "extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBindingBuildItem.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package io.quarkus.kubernetes.spi;\n+\n+import io.quarkus.builder.item.MultiBuildItem;\n+\n+public final class KubernetesRoleBindingBuildItem extends MultiBuildItem {", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5OTU4MQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459899581", "bodyText": "Good point, will do.", "author": "Ladicek", "createdAt": "2020-07-24T07:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDE4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "dfc1f6e24129a7fc34017da44ee543ef0b781b5b", "chunk": "diff --git a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBindingBuildItem.java b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBindingBuildItem.java\nindex 04fbf30049..6075a1204d 100644\n--- a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBindingBuildItem.java\n+++ b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBindingBuildItem.java\n\n@@ -2,10 +2,28 @@ package io.quarkus.kubernetes.spi;\n \n import io.quarkus.builder.item.MultiBuildItem;\n \n+/**\n+ * Produce this build item to request the Kubernetes extension to generate\n+ * a Kubernetes {@code RoleBinding} resource. The configuration here is limited;\n+ * in particular, you can't specify subjects of the role binding. The role will always\n+ * be bound to the application's service account.\n+ * <p>\n+ * Note that this can't be used to generate a {@code ClusterRoleBinding}.\n+ */\n public final class KubernetesRoleBindingBuildItem extends MultiBuildItem {\n-    private final String name; // name of the RoleBinding resource; autogenerated if `null`\n-    private final String role; // name of the bound role\n-    private final boolean clusterWide; // if true, the binding refers to a ClusterRole, otherwise to a namespaced Role\n+    /**\n+     * Name of the generated {@code RoleBinding} resource.\n+     * Can be {@code null}, in which case the resource name is autogenerated.\n+     */\n+    private final String name;\n+    /**\n+     * Name of the bound role.\n+     */\n+    private final String role;\n+    /**\n+     * If {@code true}, the binding refers to a {@code ClusterRole}, otherwise to a namespaced {@code Role}.\n+     */\n+    private final boolean clusterWide;\n \n     public KubernetesRoleBindingBuildItem(String role, boolean clusterWide) {\n         this(null, role, clusterWide);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDI3Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459864276", "bodyText": "Again, it would be great if we had some Javadoc here", "author": "geoand", "createdAt": "2020-07-24T05:54:55Z", "path": "extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java", "diffHunk": "@@ -1,16 +1,64 @@\n package io.quarkus.kubernetes.spi;\n \n+import java.util.List;\n+\n import io.quarkus.builder.item.MultiBuildItem;\n \n public final class KubernetesRoleBuildItem extends MultiBuildItem {", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5OTYwMg==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459899602", "bodyText": "Good point, will do.", "author": "Ladicek", "createdAt": "2020-07-24T07:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDI3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "dfc1f6e24129a7fc34017da44ee543ef0b781b5b", "chunk": "diff --git a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java\nindex 78a1a37f8a..52a7501837 100644\n--- a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java\n+++ b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java\n\n@@ -4,8 +4,20 @@ import java.util.List;\n \n import io.quarkus.builder.item.MultiBuildItem;\n \n+/**\n+ * Produce this build item to request the Kubernetes extension to generate\n+ * a Kubernetes {@code Role} resource.\n+ * <p>\n+ * Note that this can't be used to generate a {@code ClusterRole}.\n+ */\n public final class KubernetesRoleBuildItem extends MultiBuildItem {\n-    private final String name; // name of the Role resource\n+    /**\n+     * Name of the generated {@code Role} resource.\n+     */\n+    private final String name;\n+    /**\n+     * The {@code PolicyRule} resources for this {@code Role}.\n+     */\n     private final List<PolicyRule> rules;\n \n     public KubernetesRoleBuildItem(String name, List<PolicyRule> rules) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDY1MA==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459864650", "bodyText": "I don't remember TBH... To me it doesn't seem reasonable (it might have made sense in the past?).\n@iocanel do you remember?", "author": "geoand", "createdAt": "2020-07-24T05:56:14Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -732,11 +736,16 @@ private void applyBuildItems(Session session,\n                 .forEach(p -> session.configurators().add(new AddPort(p)));\n \n         //Handle RBAC\n+        // TODO why this condition?", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0NTc1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r462245755", "bodyText": "The condition seems wrong. The actual condition should be when kubernetes-client is added to the project or something like that.", "author": "iocanel", "createdAt": "2020-07-29T12:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NDY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "4eab152a07579dea6c53cd0de8e668febb327019", "chunk": "diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java\nindex 510161b6ee..93078292de 100644\n--- a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java\n+++ b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java\n\n@@ -736,16 +742,11 @@ class KubernetesProcessor {\n                 .forEach(p -> session.configurators().add(new AddPort(p)));\n \n         //Handle RBAC\n-        // TODO why this condition?\n         if (!kubernetesPorts.isEmpty()) {\n             session.resources().decorate(new ApplyServiceAccountNamedDecorator());\n             session.resources().decorate(new AddServiceAccountResourceDecorator());\n-            kubernetesRoles.forEach(r -> session.resources().decorate(new AddRoleResourceDecorator(r)));\n-            kubernetesRoleBindings.forEach(rb -> session.resources().decorate(\n-                    new AddRoleBindingResourceDecorator(rb.getName(), null, rb.getRole(),\n-                            rb.isClusterWide()\n-                                    ? AddRoleBindingResourceDecorator.RoleKind.ClusterRole\n-                                    : AddRoleBindingResourceDecorator.RoleKind.Role)));\n+            kubernetesRoles\n+                    .forEach(r -> session.resources().decorate(new AddRoleBindingResourceDecorator(r.getRole())));\n         }\n \n         handleServices(session, kubernetesConfig, openshiftConfig, knativeConfig, kubernetesName, openshiftName, knativeName);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTMyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459865325", "bodyText": "What is the rationale for multiple apiGroups? Is it useful for when Kubernetes API graduate?", "author": "geoand", "createdAt": "2020-07-24T05:58:59Z", "path": "extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java", "diffHunk": "@@ -1,16 +1,64 @@\n package io.quarkus.kubernetes.spi;\n \n+import java.util.List;\n+\n import io.quarkus.builder.item.MultiBuildItem;\n \n public final class KubernetesRoleBuildItem extends MultiBuildItem {\n+    private final String name; // name of the Role resource\n+    private final List<PolicyRule> rules;\n+\n+    public KubernetesRoleBuildItem(String name, List<PolicyRule> rules) {\n+        this.name = name;\n+        this.rules = rules;\n+    }\n \n-    private final String role;\n+    public String getName() {\n+        return name;\n+    }\n \n-    public KubernetesRoleBuildItem(String role) {\n-        this.role = role;\n+    public List<PolicyRule> getRules() {\n+        return rules;\n     }\n \n-    public String getRole() {\n-        return this.role;\n+    public static final class PolicyRule {\n+        private final List<String> apiGroups;", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMTQ5OA==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459901498", "bodyText": "I have no idea, this just mirrors the Kubernetes API :-)\nAPI graduation (API group named \"alpha\", \"beta\", and final without designation) is certainly one case where this can be used. Another is older OpenShift resources that were in the \"\" API group and are now moved to their own API group (run oc get clusterrole view -o yaml and see).", "author": "Ladicek", "createdAt": "2020-07-24T07:49:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTMyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMTk2NQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459901965", "bodyText": "Gotcha, thanks", "author": "geoand", "createdAt": "2020-07-24T07:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTMyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "dfc1f6e24129a7fc34017da44ee543ef0b781b5b", "chunk": "diff --git a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java\nindex 78a1a37f8a..52a7501837 100644\n--- a/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java\n+++ b/extensions/kubernetes/spi/src/main/java/io/quarkus/kubernetes/spi/KubernetesRoleBuildItem.java\n\n@@ -4,8 +4,20 @@ import java.util.List;\n \n import io.quarkus.builder.item.MultiBuildItem;\n \n+/**\n+ * Produce this build item to request the Kubernetes extension to generate\n+ * a Kubernetes {@code Role} resource.\n+ * <p>\n+ * Note that this can't be used to generate a {@code ClusterRole}.\n+ */\n public final class KubernetesRoleBuildItem extends MultiBuildItem {\n-    private final String name; // name of the Role resource\n+    /**\n+     * Name of the generated {@code Role} resource.\n+     */\n+    private final String name;\n+    /**\n+     * The {@code PolicyRule} resources for this {@code Role}.\n+     */\n     private final List<PolicyRule> rules;\n \n     public KubernetesRoleBuildItem(String name, List<PolicyRule> rules) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTgyNg==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459865826", "bodyText": "I am wondering if we should have a warning message when this is used without quarkus.kubernetes-config.secrets.enabled being true", "author": "geoand", "createdAt": "2020-07-24T06:00:45Z", "path": "extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigSourceConfig.java", "diffHunk": "@@ -29,8 +29,15 @@\n     public Optional<List<String>> configMaps;\n \n     /**\n-     * Namespace to look for config maps. If this is not specified, then the namespace configured in the kubectl config context\n-     * is used. If the value is specified and the namespace doesn't exist, the application will fail to start.\n+     * Secrets to look for in the namespace that the Kubernetes Client has been configured for.\n+     * If you use this, you probably want to enable {@code quarkus.kubernetes-config.secrets.enabled}.\n+     */\n+    @ConfigItem\n+    public Optional<List<String>> secrets;", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMTk0Nw==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459901947", "bodyText": "I'd be careful about that. As you explained to me, we can't figure out at build time if secrets will be used or not.", "author": "Ladicek", "createdAt": "2020-07-24T07:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMzg0MA==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459903840", "bodyText": "Sure yeah, you can't have a proper build time warning, but we could have a warning in the recorder which would be logged at runtime.\nI think it's better to be explicit so users will now exactly what's going on.\nI can already imagine people asking on Zulip or GitHub why their configured secrets are not taking effect :)", "author": "geoand", "createdAt": "2020-07-24T07:54:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkxNDQyOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459914429", "bodyText": "I see what you mean. I personally think that the Kubernetes stuff already logs a bit too much, but that's during build. I'll add this runtime warning.", "author": "Ladicek", "createdAt": "2020-07-24T08:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyMjIxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459922211", "bodyText": "I did it, but found that in the failing case, the warning is totally lost between all the other logs :-) Will push in a sec.", "author": "Ladicek", "createdAt": "2020-07-24T08:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNDQzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459924439", "bodyText": "Done.", "author": "Ladicek", "createdAt": "2020-07-24T08:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NTgyNg=="}], "type": "inlineReview", "revised_code": {"commit": "4eab152a07579dea6c53cd0de8e668febb327019", "chunk": "diff --git a/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigSourceConfig.java b/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigSourceConfig.java\nindex b5f906a39f..c56d0ae5d7 100644\n--- a/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigSourceConfig.java\n+++ b/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigSourceConfig.java\n\n@@ -29,15 +29,14 @@ public class KubernetesConfigSourceConfig {\n     public Optional<List<String>> configMaps;\n \n     /**\n-     * Secrets to look for in the namespace that the Kubernetes Client has been configured for.\n-     * If you use this, you probably want to enable {@code quarkus.kubernetes-config.secrets.enabled}.\n+     * Secrets to look for in the namespace that the Kubernetes Client has been configured for\n      */\n     @ConfigItem\n     public Optional<List<String>> secrets;\n \n     /**\n-     * Namespace to look for config maps and secrets. If this is not specified, then the namespace configured in the kubectl\n-     * config context is used. If the value is specified and the namespace doesn't exist, the application will fail to start.\n+     * Namespace to look for config maps and secrets. If this is not specified, then the namespace configured in the kubectl config context\n+     * is used. If the value is specified and the namespace doesn't exist, the application will fail to start.\n      */\n     @ConfigItem\n     public Optional<String> namespace;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NjE1OA==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459866158", "bodyText": "This kind of thing is exactly why I LOVE AssertJ :)", "author": "geoand", "createdAt": "2020-07-24T06:02:08Z", "path": "integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesConfigWithSecretsTest.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package io.quarkus.it.kubernetes;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.kubernetes.api.model.rbac.PolicyRule;\n+import io.fabric8.kubernetes.api.model.rbac.Role;\n+import io.fabric8.kubernetes.api.model.rbac.RoleBinding;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.builder.Version;\n+import io.quarkus.test.ProdBuildResults;\n+import io.quarkus.test.ProdModeTestResults;\n+import io.quarkus.test.QuarkusProdModeTest;\n+\n+public class KubernetesConfigWithSecretsTest {\n+\n+    @RegisterExtension\n+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class).addClasses(GreetingResource.class))\n+            .setApplicationName(\"kubernetes-config-with-secrets\")\n+            .setApplicationVersion(\"0.1-SNAPSHOT\")\n+            .withConfigurationResource(\"kubernetes-config-with-secrets.properties\")\n+            .setForcedDependencies(Collections.singletonList(\n+                    new AppArtifact(\"io.quarkus\", \"quarkus-kubernetes-config\", Version.getVersion())));\n+\n+    @ProdBuildResults\n+    private ProdModeTestResults prodModeTestResults;\n+\n+    @Test\n+    public void assertGeneratedResources() throws IOException {\n+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve(\"kubernetes\");\n+        assertThat(kubernetesDir)\n+                .isDirectoryContaining(p -> p.getFileName().endsWith(\"kubernetes.json\"))\n+                .isDirectoryContaining(p -> p.getFileName().endsWith(\"kubernetes.yml\"));\n+        List<HasMetadata> kubernetesList = DeserializationUtil.deserializeAsList(kubernetesDir.resolve(\"kubernetes.yml\"));\n+\n+        assertThat(kubernetesList).filteredOn(h -> \"Role\".equals(h.getKind())).hasSize(1);\n+\n+        assertThat(kubernetesList).anySatisfy(res -> {\n+            assertThat(res).isInstanceOfSatisfying(Role.class, role -> {\n+                assertThat(role.getMetadata()).satisfies(m -> {\n+                    assertThat(m.getName()).isEqualTo(\"view-secrets\");\n+                });\n+\n+                assertThat(role.getRules()).hasOnlyOneElementSatisfying(r -> {\n+                    assertThat(r).isInstanceOfSatisfying(PolicyRule.class, rule -> {\n+                        assertThat(rule.getApiGroups()).containsExactly(\"\");\n+                        assertThat(rule.getResources()).containsExactly(\"secrets\");\n+                        assertThat(rule.getVerbs()).containsExactly(\"get\", \"list\", \"watch\");", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eab152a07579dea6c53cd0de8e668febb327019", "chunk": "diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesConfigWithSecretsTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesConfigWithSecretsTest.java\ndeleted file mode 100644\nindex ecfd7e6a5b..0000000000\n--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/KubernetesConfigWithSecretsTest.java\n+++ /dev/null\n\n@@ -1,100 +0,0 @@\n-package io.quarkus.it.kubernetes;\n-\n-import static org.assertj.core.api.Assertions.assertThat;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Collections;\n-import java.util.List;\n-\n-import org.jboss.shrinkwrap.api.ShrinkWrap;\n-import org.jboss.shrinkwrap.api.spec.JavaArchive;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.extension.RegisterExtension;\n-\n-import io.fabric8.kubernetes.api.model.HasMetadata;\n-import io.fabric8.kubernetes.api.model.rbac.PolicyRule;\n-import io.fabric8.kubernetes.api.model.rbac.Role;\n-import io.fabric8.kubernetes.api.model.rbac.RoleBinding;\n-import io.quarkus.bootstrap.model.AppArtifact;\n-import io.quarkus.builder.Version;\n-import io.quarkus.test.ProdBuildResults;\n-import io.quarkus.test.ProdModeTestResults;\n-import io.quarkus.test.QuarkusProdModeTest;\n-\n-public class KubernetesConfigWithSecretsTest {\n-\n-    @RegisterExtension\n-    static final QuarkusProdModeTest config = new QuarkusProdModeTest()\n-            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class).addClasses(GreetingResource.class))\n-            .setApplicationName(\"kubernetes-config-with-secrets\")\n-            .setApplicationVersion(\"0.1-SNAPSHOT\")\n-            .withConfigurationResource(\"kubernetes-config-with-secrets.properties\")\n-            .setForcedDependencies(Collections.singletonList(\n-                    new AppArtifact(\"io.quarkus\", \"quarkus-kubernetes-config\", Version.getVersion())));\n-\n-    @ProdBuildResults\n-    private ProdModeTestResults prodModeTestResults;\n-\n-    @Test\n-    public void assertGeneratedResources() throws IOException {\n-        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve(\"kubernetes\");\n-        assertThat(kubernetesDir)\n-                .isDirectoryContaining(p -> p.getFileName().endsWith(\"kubernetes.json\"))\n-                .isDirectoryContaining(p -> p.getFileName().endsWith(\"kubernetes.yml\"));\n-        List<HasMetadata> kubernetesList = DeserializationUtil.deserializeAsList(kubernetesDir.resolve(\"kubernetes.yml\"));\n-\n-        assertThat(kubernetesList).filteredOn(h -> \"Role\".equals(h.getKind())).hasSize(1);\n-\n-        assertThat(kubernetesList).anySatisfy(res -> {\n-            assertThat(res).isInstanceOfSatisfying(Role.class, role -> {\n-                assertThat(role.getMetadata()).satisfies(m -> {\n-                    assertThat(m.getName()).isEqualTo(\"view-secrets\");\n-                });\n-\n-                assertThat(role.getRules()).hasOnlyOneElementSatisfying(r -> {\n-                    assertThat(r).isInstanceOfSatisfying(PolicyRule.class, rule -> {\n-                        assertThat(rule.getApiGroups()).containsExactly(\"\");\n-                        assertThat(rule.getResources()).containsExactly(\"secrets\");\n-                        assertThat(rule.getVerbs()).containsExactly(\"get\", \"list\", \"watch\");\n-                    });\n-                });\n-            });\n-        });\n-\n-        assertThat(kubernetesList).filteredOn(h -> \"RoleBinding\".equals(h.getKind())).hasSize(2);\n-\n-        assertThat(kubernetesList).anySatisfy(res -> {\n-            assertThat(res).isInstanceOfSatisfying(RoleBinding.class, roleBinding -> {\n-                assertThat(roleBinding.getMetadata()).satisfies(m -> {\n-                    assertThat(m.getName()).isEqualTo(\"kubernetes-config-with-secrets:view-secrets\");\n-                });\n-\n-                assertThat(roleBinding.getRoleRef().getKind()).isEqualTo(\"Role\");\n-                assertThat(roleBinding.getRoleRef().getName()).isEqualTo(\"view-secrets\");\n-\n-                assertThat(roleBinding.getSubjects()).hasOnlyOneElementSatisfying(subject -> {\n-                    assertThat(subject.getKind()).isEqualTo(\"ServiceAccount\");\n-                    assertThat(subject.getName()).isEqualTo(\"kubernetes-config-with-secrets\");\n-                });\n-            });\n-        });\n-\n-        assertThat(kubernetesList).anySatisfy(res -> {\n-            assertThat(res).isInstanceOfSatisfying(RoleBinding.class, roleBinding -> {\n-                assertThat(roleBinding.getMetadata()).satisfies(m -> {\n-                    assertThat(m.getName()).isEqualTo(\"kubernetes-config-with-secrets:view\");\n-                });\n-\n-                assertThat(roleBinding.getRoleRef().getKind()).isEqualTo(\"ClusterRole\");\n-                assertThat(roleBinding.getRoleRef().getName()).isEqualTo(\"view\");\n-\n-                assertThat(roleBinding.getSubjects()).hasOnlyOneElementSatisfying(subject -> {\n-                    assertThat(subject.getKind()).isEqualTo(\"ServiceAccount\");\n-                    assertThat(subject.getName()).isEqualTo(\"kubernetes-config-with-secrets\");\n-                });\n-            });\n-        });\n-    }\n-\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg2NjU0Ng==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459866546", "bodyText": "LGTM, but this is one that @iocanel will have to give the OK for", "author": "geoand", "createdAt": "2020-07-24T06:03:45Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddRoleResourceDecorator.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package io.quarkus.kubernetes.deployment;\n+\n+import java.util.stream.Collectors;\n+\n+import io.dekorate.deps.kubernetes.api.model.KubernetesListBuilder;\n+import io.dekorate.deps.kubernetes.api.model.ObjectMeta;\n+import io.dekorate.deps.kubernetes.api.model.rbac.PolicyRuleBuilder;\n+import io.dekorate.deps.kubernetes.api.model.rbac.RoleBuilder;\n+import io.dekorate.kubernetes.decorator.ResourceProvidingDecorator;\n+import io.quarkus.kubernetes.spi.KubernetesRoleBuildItem;\n+\n+class AddRoleResourceDecorator extends ResourceProvidingDecorator<KubernetesListBuilder> {", "originalCommit": "9ffc17d63e880f64272916ced572c613920f6ec1", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4eab152a07579dea6c53cd0de8e668febb327019", "chunk": "diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddRoleResourceDecorator.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddRoleResourceDecorator.java\ndeleted file mode 100644\nindex f173102360..0000000000\n--- a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/AddRoleResourceDecorator.java\n+++ /dev/null\n\n@@ -1,43 +0,0 @@\n-package io.quarkus.kubernetes.deployment;\n-\n-import java.util.stream.Collectors;\n-\n-import io.dekorate.deps.kubernetes.api.model.KubernetesListBuilder;\n-import io.dekorate.deps.kubernetes.api.model.ObjectMeta;\n-import io.dekorate.deps.kubernetes.api.model.rbac.PolicyRuleBuilder;\n-import io.dekorate.deps.kubernetes.api.model.rbac.RoleBuilder;\n-import io.dekorate.kubernetes.decorator.ResourceProvidingDecorator;\n-import io.quarkus.kubernetes.spi.KubernetesRoleBuildItem;\n-\n-class AddRoleResourceDecorator extends ResourceProvidingDecorator<KubernetesListBuilder> {\n-    private final KubernetesRoleBuildItem spec;\n-\n-    public AddRoleResourceDecorator(KubernetesRoleBuildItem buildItem) {\n-        this.spec = buildItem;\n-    }\n-\n-    public void visit(KubernetesListBuilder list) {\n-        ObjectMeta meta = getMandatoryDeploymentMetadata(list);\n-\n-        if (contains(list, \"rbac.authorization.k8s.io/v1\", \"Role\", spec.getName())) {\n-            return;\n-        }\n-\n-        list.addToItems(new RoleBuilder()\n-                .withNewMetadata()\n-                .withName(spec.getName())\n-                .withLabels(meta.getLabels())\n-                .endMetadata()\n-                .withRules(\n-                        spec.getRules()\n-                                .stream()\n-                                .map(it -> new PolicyRuleBuilder()\n-                                        .withApiGroups(it.getApiGroups())\n-                                        .withNonResourceURLs(it.getNonResourceURLs())\n-                                        .withResourceNames(it.getResourceNames())\n-                                        .withResources(it.getResources())\n-                                        .withVerbs(it.getVerbs())\n-                                        .build())\n-                                .collect(Collectors.toList())));\n-    }\n-}\n"}}, {"oid": "74eb333af3f9583e45502b6a641ee3e93bf6ce4b", "url": "https://github.com/quarkusio/quarkus/commit/74eb333af3f9583e45502b6a641ee3e93bf6ce4b", "message": "support reading configuration from Kubernetes Secrets\n\nThe `kubernetes` extension automatically generates a RoleBinding\nthat refers to the `view` ClusterRole. This ClusterRole doesn't\nallow access to secrets. This commit therefore adds a configuration\nproperty which, when enabled, makes the `kubernetes` extension\ngenerate a special Role `view-secrets` and a second RoleBinding\nreferring to that role. This configuration property is build-time\nonly and has no other effect.\n\nWith this configuration in place, there's nothing preventing\nthe application from reading Secrets directly from the API server.\n\nFor convenience, a warning is printed at runtime if configuration\nis read from Secrets yet the property is disabled.", "committedDate": "2020-07-24T08:38:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNTUxMA==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459925510", "bodyText": "Is it just me, or does the last sentence seem out of place?", "author": "geoand", "createdAt": "2020-07-24T08:42:23Z", "path": "extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigRecorder.java", "diffHunk": "@@ -26,6 +26,17 @@\n                 KubernetesClientUtils.createClient(clientConfig)));\n     }\n \n+    public void warnAboutSecrets(KubernetesConfigSourceConfig config, KubernetesConfigBuildTimeConfig buildTimeConfig) {\n+        if (config.enabled\n+                && config.secrets.isPresent()\n+                && !config.secrets.get().isEmpty()\n+                && !buildTimeConfig.secretsEnabled) {\n+            log.warn(\"Configuration is read from Secrets \" + config.secrets.get()\n+                    + \", but quarkus.kubernetes-config.secrets.enabled is false.\"\n+                    + \" Check if your application's service account has enough permissions to read secrets.\");", "originalCommit": "74eb333af3f9583e45502b6a641ee3e93bf6ce4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk0MDY2NA==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459940664", "bodyText": "I wanted to say that what the user ultimately needs to do is not setting our config property, but make sure that the app's service account has access to secrets.\nObviously quarkus.kubernetes-config.secrets.enabled is the easiest way, if people use the Kubernetes extension. But that doesn't always have to be the case.", "author": "Ladicek", "createdAt": "2020-07-24T09:13:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNTUxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NTUxMQ==", "url": "https://github.com/quarkusio/quarkus/pull/10939#discussion_r459955511", "bodyText": "Okay", "author": "geoand", "createdAt": "2020-07-24T09:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNTUxMA=="}], "type": "inlineReview", "revised_code": {"commit": "4eab152a07579dea6c53cd0de8e668febb327019", "chunk": "diff --git a/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigRecorder.java b/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigRecorder.java\nindex f311d6a90a..648d5c8416 100644\n--- a/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigRecorder.java\n+++ b/extensions/kubernetes-config/runtime/src/main/java/io/quarkus/kubernetes/client/runtime/KubernetesConfigRecorder.java\n\n@@ -26,17 +26,6 @@ public class KubernetesConfigRecorder {\n                 KubernetesClientUtils.createClient(clientConfig)));\n     }\n \n-    public void warnAboutSecrets(KubernetesConfigSourceConfig config, KubernetesConfigBuildTimeConfig buildTimeConfig) {\n-        if (config.enabled\n-                && config.secrets.isPresent()\n-                && !config.secrets.get().isEmpty()\n-                && !buildTimeConfig.secretsEnabled) {\n-            log.warn(\"Configuration is read from Secrets \" + config.secrets.get()\n-                    + \", but quarkus.kubernetes-config.secrets.enabled is false.\"\n-                    + \" Check if your application's service account has enough permissions to read secrets.\");\n-        }\n-    }\n-\n     private RuntimeValue<ConfigSourceProvider> emptyRuntimeValue() {\n         return new RuntimeValue<>(new EmptyConfigSourceProvider());\n     }\n"}}, {"oid": "dfc1f6e24129a7fc34017da44ee543ef0b781b5b", "url": "https://github.com/quarkusio/quarkus/commit/dfc1f6e24129a7fc34017da44ee543ef0b781b5b", "message": "support reading configuration from Kubernetes Secrets\n\nThe `kubernetes` extension automatically generates a RoleBinding\nthat refers to the `view` ClusterRole. This ClusterRole doesn't\nallow access to secrets. This commit therefore adds a configuration\nproperty which, when enabled, makes the `kubernetes` extension\ngenerate a special Role `view-secrets` and a second RoleBinding\nreferring to that role. This configuration property is build-time\nonly and has no other effect.\n\nWith this configuration in place, there's nothing preventing\nthe application from reading Secrets directly from the API server.\n\nFor convenience, a warning is printed at runtime if configuration\nis read from Secrets yet the property is disabled.", "committedDate": "2020-07-24T09:08:22Z", "type": "forcePushed"}, {"oid": "412d10a478e859a394e4de1e1690022c2c7f53c9", "url": "https://github.com/quarkusio/quarkus/commit/412d10a478e859a394e4de1e1690022c2c7f53c9", "message": "support reading configuration from Kubernetes Secrets\n\nThe `kubernetes` extension automatically generates a RoleBinding\nthat refers to the `view` ClusterRole. This ClusterRole doesn't\nallow access to secrets. This commit therefore adds a configuration\nproperty which, when enabled, makes the `kubernetes` extension\ngenerate a special Role `view-secrets` and a second RoleBinding\nreferring to that role. This configuration property is build-time\nonly and has no other effect.\n\nWith this configuration in place, there's nothing preventing\nthe application from reading Secrets directly from the API server.\n\nFor convenience, a warning is printed at runtime if configuration\nis read from Secrets yet the property is disabled.", "committedDate": "2020-07-24T12:47:53Z", "type": "forcePushed"}, {"oid": "a19aab02d4b92dbc70bab44a11020e84b4ee1188", "url": "https://github.com/quarkusio/quarkus/commit/a19aab02d4b92dbc70bab44a11020e84b4ee1188", "message": "support reading configuration from Kubernetes Secrets\n\nThe `kubernetes` extension automatically generates a RoleBinding\nthat refers to the `view` ClusterRole. This ClusterRole doesn't\nallow access to secrets. This commit therefore adds a configuration\nproperty which, when enabled, makes the `kubernetes` extension\ngenerate a special Role `view-secrets` and a second RoleBinding\nreferring to that role. This configuration property is build-time\nonly and has no other effect.\n\nWith this configuration in place, there's nothing preventing\nthe application from reading Secrets directly from the API server.\n\nFor convenience, a warning is printed at runtime if configuration\nis read from Secrets yet the property is disabled.", "committedDate": "2020-07-29T14:24:27Z", "type": "forcePushed"}, {"oid": "29c6d1124bf70844b81435eaa328b25a7fe09e7e", "url": "https://github.com/quarkusio/quarkus/commit/29c6d1124bf70844b81435eaa328b25a7fe09e7e", "message": "support reading configuration from Kubernetes Secrets\n\nThe `kubernetes` extension automatically generates a RoleBinding\nthat refers to the `view` ClusterRole. This ClusterRole doesn't\nallow access to secrets. This commit therefore adds a configuration\nproperty which, when enabled, makes the `kubernetes` extension\ngenerate a special Role `view-secrets` and a second RoleBinding\nreferring to that role. This configuration property is build-time\nonly and has no other effect.\n\nWith this configuration in place, there's nothing preventing\nthe application from reading Secrets directly from the API server.\n\nFor convenience, a warning is printed at runtime if configuration\nis read from Secrets yet the property is disabled.", "committedDate": "2020-07-29T14:50:13Z", "type": "forcePushed"}, {"oid": "4eab152a07579dea6c53cd0de8e668febb327019", "url": "https://github.com/quarkusio/quarkus/commit/4eab152a07579dea6c53cd0de8e668febb327019", "message": "restore the ConfigSource based on Kubernetes Secrets\n\nThis reverts commit 0c71c47152681cb23b1928a12b202c283e5e27fb\nand adds a couple of cleanups. Most importantly, the issue\nwhich caused this functionality to be removed remains:\nthe application by default runs under a role that doesn't have\naccess to secrets. This is marked with one TODO in the code\nand will be addressed in a subsequent commit.", "committedDate": "2020-07-29T16:12:31Z", "type": "commit"}, {"oid": "e91c1d8668d0b2c1a815dbd5c171ad524cb89ad6", "url": "https://github.com/quarkusio/quarkus/commit/e91c1d8668d0b2c1a815dbd5c171ad524cb89ad6", "message": "support reading configuration from Kubernetes Secrets\n\nThe `kubernetes` extension automatically generates a RoleBinding\nthat refers to the `view` ClusterRole. This ClusterRole doesn't\nallow access to secrets. This commit therefore adds a configuration\nproperty which, when enabled, makes the `kubernetes` extension\ngenerate a special Role `view-secrets` and a second RoleBinding\nreferring to that role. This configuration property is build-time\nonly and has no other effect.\n\nWith this configuration in place, there's nothing preventing\nthe application from reading Secrets directly from the API server.\n\nFor convenience, a warning is printed at runtime if configuration\nis read from Secrets yet the property is disabled.", "committedDate": "2020-07-29T16:12:31Z", "type": "commit"}, {"oid": "571aaef97c885f436bb3ad7ca76ef21eba5e3d31", "url": "https://github.com/quarkusio/quarkus/commit/571aaef97c885f436bb3ad7ca76ef21eba5e3d31", "message": "make sure ConfigMap/Secret content isn't accidentally exposed", "committedDate": "2020-07-29T16:12:31Z", "type": "commit"}, {"oid": "571aaef97c885f436bb3ad7ca76ef21eba5e3d31", "url": "https://github.com/quarkusio/quarkus/commit/571aaef97c885f436bb3ad7ca76ef21eba5e3d31", "message": "make sure ConfigMap/Secret content isn't accidentally exposed", "committedDate": "2020-07-29T16:12:31Z", "type": "forcePushed"}]}