{"pr_number": 12531, "pr_title": "Kafka metrics", "pr_createdAt": "2020-10-05T17:40:11Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/12531", "timeline": [{"oid": "d4598f00a4a2c02e88de354d65d321ced3912fde", "url": "https://github.com/quarkusio/quarkus/commit/d4598f00a4a2c02e88de354d65d321ced3912fde", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-05T19:42:12Z", "type": "forcePushed"}, {"oid": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "url": "https://github.com/quarkusio/quarkus/commit/ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-06T02:30:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025573", "bodyText": "Why is Vert.x mentioned here?", "author": "cescoffier", "createdAt": "2020-10-06T06:07:27Z", "path": "extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java", "diffHunk": "@@ -0,0 +1,36 @@\n+package io.quarkus.micrometer.deployment.binder;\n+\n+import java.util.function.BooleanSupplier;\n+\n+import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n+import io.quarkus.deployment.annotations.BuildStep;\n+import io.quarkus.micrometer.runtime.MicrometerRecorder;\n+import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n+\n+/**\n+ * Add support for Kafka Producer and Consumer instrumentation. Note that\n+ * various bits of support may not be present at deploy time. Avoid referencing\n+ * classes that in turn import optional dependencies.\n+ */\n+public class KafkaBinderProcessor {\n+    static final String KAFKA_CONSUMER_CLASS_NAME = \"org.apache.kafka.clients.consumer.Consumer\";\n+    static final Class<?> KAFKA_CONSUMER_CLASS_CLASS = MicrometerRecorder.getClassForName(KAFKA_CONSUMER_CLASS_NAME);\n+\n+    static final String KAFKA_EVENT_CONSUMER_CLASS_NAME = \"io.quarkus.micrometer.runtime.binder.kafka.KafkaEventObserver\";\n+\n+    static class KafkaSupportEnabled implements BooleanSupplier {\n+        MicrometerConfig mConfig;\n+\n+        public boolean getAsBoolean() {\n+            return KAFKA_CONSUMER_CLASS_CLASS != null && mConfig.checkBinderEnabledWithDefault(mConfig.binder.kafka);\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = KafkaSupportEnabled.class)\n+    AdditionalBeanBuildItem createCDIEventConsumer() {\n+        // Add Vertx meter adapters", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNDA1NQ==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500224055", "bodyText": "copy/paste? =) Will fix.", "author": "ebullient", "createdAt": "2020-10-06T12:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTU3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "chunk": "diff --git a/extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java b/extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java\ndeleted file mode 100644\nindex 1ba37c1648..0000000000\n--- a/extensions/micrometer/deployment/src/main/java/io/quarkus/micrometer/deployment/binder/KafkaBinderProcessor.java\n+++ /dev/null\n\n@@ -1,36 +0,0 @@\n-package io.quarkus.micrometer.deployment.binder;\n-\n-import java.util.function.BooleanSupplier;\n-\n-import io.quarkus.arc.deployment.AdditionalBeanBuildItem;\n-import io.quarkus.deployment.annotations.BuildStep;\n-import io.quarkus.micrometer.runtime.MicrometerRecorder;\n-import io.quarkus.micrometer.runtime.config.MicrometerConfig;\n-\n-/**\n- * Add support for Kafka Producer and Consumer instrumentation. Note that\n- * various bits of support may not be present at deploy time. Avoid referencing\n- * classes that in turn import optional dependencies.\n- */\n-public class KafkaBinderProcessor {\n-    static final String KAFKA_CONSUMER_CLASS_NAME = \"org.apache.kafka.clients.consumer.Consumer\";\n-    static final Class<?> KAFKA_CONSUMER_CLASS_CLASS = MicrometerRecorder.getClassForName(KAFKA_CONSUMER_CLASS_NAME);\n-\n-    static final String KAFKA_EVENT_CONSUMER_CLASS_NAME = \"io.quarkus.micrometer.runtime.binder.kafka.KafkaEventObserver\";\n-\n-    static class KafkaSupportEnabled implements BooleanSupplier {\n-        MicrometerConfig mConfig;\n-\n-        public boolean getAsBoolean() {\n-            return KAFKA_CONSUMER_CLASS_CLASS != null && mConfig.checkBinderEnabledWithDefault(mConfig.binder.kafka);\n-        }\n-    }\n-\n-    @BuildStep(onlyIf = KafkaSupportEnabled.class)\n-    AdditionalBeanBuildItem createCDIEventConsumer() {\n-        // Add Vertx meter adapters\n-        return AdditionalBeanBuildItem.builder()\n-                .addBeanClass(KAFKA_EVENT_CONSUMER_CLASS_NAME)\n-                .setUnremovable().build();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500025851", "bodyText": "Should this be logged instead?", "author": "cescoffier", "createdAt": "2020-10-06T06:08:27Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNDA0NA==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500224044", "bodyText": "yes!", "author": "ebullient", "createdAt": "2020-10-06T12:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNTg1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "chunk": "diff --git a/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java b/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java\ndeleted file mode 100644\nindex 7ae521fb93..0000000000\n--- a/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package io.quarkus.micrometer.runtime.binder.kafka;\n-\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.event.Observes;\n-\n-import org.apache.kafka.clients.consumer.Consumer;\n-import org.apache.kafka.clients.producer.Producer;\n-\n-import io.micrometer.core.instrument.MeterRegistry;\n-import io.micrometer.core.instrument.Metrics;\n-import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n-\n-@ApplicationScoped\n-public class KafkaEventObserver {\n-    MeterRegistry registry = Metrics.globalRegistry;\n-    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n-\n-    /**\n-     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n-     * If the consumer has not been seen before, it will be bound to the\n-     * Micrometer registry and instrumented using a Kafka MeterBinder.\n-     * If the consumer has been seen before, the MeterBinder will be closed.\n-     * \n-     * @param consumer Observed Kafka Consumer\n-     */\n-    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n-        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n-        if (prev == null) {\n-            clientMetrics.computeIfAbsent(consumer, x -> {\n-                try {\n-                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n-                    metrics.bindTo(registry);\n-                    return metrics;\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                    return null;\n-                }\n-            });\n-        } else {\n-            prev.close();\n-        }\n-    }\n-\n-    /**\n-     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n-     * If the producer has not been seen before, it will be bound to the\n-     * Micrometer registry and instrumented using a Kafka MeterBinder.\n-     * If the producer has been seen before, the MeterBinder will be closed.\n-     * \n-     * @param producer Observed Kafka Producer\n-     */\n-    public void producerCreated(@Observes Producer<?, ?> producer) {\n-        KafkaClientMetrics prev = clientMetrics.remove(producer);\n-        if (prev == null) {\n-            clientMetrics.computeIfAbsent(producer, x -> {\n-                try {\n-                    KafkaClientMetrics metrics = new KafkaClientMetrics(producer);\n-                    metrics.bindTo(registry);\n-                    return metrics;\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                    return null;\n-                }\n-            });\n-        } else {\n-            prev.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026377", "bodyText": "Why do you remove it and then computeIfAbsent? Do you expect concurrent access? If I'm not sure it works.", "author": "cescoffier", "createdAt": "2020-10-06T06:10:03Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjUyMw==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026523", "bodyText": "it might be safer to just synchronized the whole method.", "author": "cescoffier", "createdAt": "2020-10-06T06:10:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyNjcxOA==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500226718", "bodyText": "I can change that. I like computeIfAbsent as an atomic operation (personal bias), but I can see that it is confusing.", "author": "ebullient", "createdAt": "2020-10-06T12:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjM3Nw=="}], "type": "inlineReview", "revised_code": {"commit": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "chunk": "diff --git a/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java b/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java\ndeleted file mode 100644\nindex 7ae521fb93..0000000000\n--- a/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package io.quarkus.micrometer.runtime.binder.kafka;\n-\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.event.Observes;\n-\n-import org.apache.kafka.clients.consumer.Consumer;\n-import org.apache.kafka.clients.producer.Producer;\n-\n-import io.micrometer.core.instrument.MeterRegistry;\n-import io.micrometer.core.instrument.Metrics;\n-import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n-\n-@ApplicationScoped\n-public class KafkaEventObserver {\n-    MeterRegistry registry = Metrics.globalRegistry;\n-    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n-\n-    /**\n-     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n-     * If the consumer has not been seen before, it will be bound to the\n-     * Micrometer registry and instrumented using a Kafka MeterBinder.\n-     * If the consumer has been seen before, the MeterBinder will be closed.\n-     * \n-     * @param consumer Observed Kafka Consumer\n-     */\n-    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n-        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n-        if (prev == null) {\n-            clientMetrics.computeIfAbsent(consumer, x -> {\n-                try {\n-                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n-                    metrics.bindTo(registry);\n-                    return metrics;\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                    return null;\n-                }\n-            });\n-        } else {\n-            prev.close();\n-        }\n-    }\n-\n-    /**\n-     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n-     * If the producer has not been seen before, it will be bound to the\n-     * Micrometer registry and instrumented using a Kafka MeterBinder.\n-     * If the producer has been seen before, the MeterBinder will be closed.\n-     * \n-     * @param producer Observed Kafka Producer\n-     */\n-    public void producerCreated(@Observes Producer<?, ?> producer) {\n-        KafkaClientMetrics prev = clientMetrics.remove(producer);\n-        if (prev == null) {\n-            clientMetrics.computeIfAbsent(producer, x -> {\n-                try {\n-                    KafkaClientMetrics metrics = new KafkaClientMetrics(producer);\n-                    metrics.bindTo(registry);\n-                    return metrics;\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                    return null;\n-                }\n-            });\n-        } else {\n-            prev.close();\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDAyNjYyMA==", "url": "https://github.com/quarkusio/quarkus/pull/12531#discussion_r500026620", "bodyText": "Same comment", "author": "cescoffier", "createdAt": "2020-10-06T06:10:45Z", "path": "extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package io.quarkus.micrometer.runtime.binder.kafka;\n+\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.event.Observes;\n+\n+import org.apache.kafka.clients.consumer.Consumer;\n+import org.apache.kafka.clients.producer.Producer;\n+\n+import io.micrometer.core.instrument.MeterRegistry;\n+import io.micrometer.core.instrument.Metrics;\n+import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n+\n+@ApplicationScoped\n+public class KafkaEventObserver {\n+    MeterRegistry registry = Metrics.globalRegistry;\n+    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n+     * If the consumer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the consumer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param consumer Observed Kafka Consumer\n+     */\n+    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(consumer, x -> {\n+                try {\n+                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n+                    metrics.bindTo(registry);\n+                    return metrics;\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    return null;\n+                }\n+            });\n+        } else {\n+            prev.close();\n+        }\n+    }\n+\n+    /**\n+     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n+     * If the producer has not been seen before, it will be bound to the\n+     * Micrometer registry and instrumented using a Kafka MeterBinder.\n+     * If the producer has been seen before, the MeterBinder will be closed.\n+     * \n+     * @param producer Observed Kafka Producer\n+     */\n+    public void producerCreated(@Observes Producer<?, ?> producer) {\n+        KafkaClientMetrics prev = clientMetrics.remove(producer);\n+        if (prev == null) {\n+            clientMetrics.computeIfAbsent(producer, x -> {", "originalCommit": "ab7f77eee84cb5f2d80d13737f9e327409e0e26b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "chunk": "diff --git a/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java b/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java\ndeleted file mode 100644\nindex 7ae521fb93..0000000000\n--- a/extensions/micrometer/runtime/src/main/java/io/quarkus/micrometer/runtime/binder/kafka/KafkaEventObserver.java\n+++ /dev/null\n\n@@ -1,71 +0,0 @@\n-package io.quarkus.micrometer.runtime.binder.kafka;\n-\n-import java.util.concurrent.ConcurrentHashMap;\n-\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.event.Observes;\n-\n-import org.apache.kafka.clients.consumer.Consumer;\n-import org.apache.kafka.clients.producer.Producer;\n-\n-import io.micrometer.core.instrument.MeterRegistry;\n-import io.micrometer.core.instrument.Metrics;\n-import io.micrometer.core.instrument.binder.kafka.KafkaClientMetrics;\n-\n-@ApplicationScoped\n-public class KafkaEventObserver {\n-    MeterRegistry registry = Metrics.globalRegistry;\n-    ConcurrentHashMap<Object, KafkaClientMetrics> clientMetrics = new ConcurrentHashMap<>();\n-\n-    /**\n-     * Manage bind/close of KafkaClientMetrics for the specified Consumer.\n-     * If the consumer has not been seen before, it will be bound to the\n-     * Micrometer registry and instrumented using a Kafka MeterBinder.\n-     * If the consumer has been seen before, the MeterBinder will be closed.\n-     * \n-     * @param consumer Observed Kafka Consumer\n-     */\n-    public void consumerCreated(@Observes Consumer<?, ?> consumer) {\n-        KafkaClientMetrics prev = clientMetrics.remove(consumer);\n-        if (prev == null) {\n-            clientMetrics.computeIfAbsent(consumer, x -> {\n-                try {\n-                    KafkaClientMetrics metrics = new KafkaClientMetrics(consumer);\n-                    metrics.bindTo(registry);\n-                    return metrics;\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                    return null;\n-                }\n-            });\n-        } else {\n-            prev.close();\n-        }\n-    }\n-\n-    /**\n-     * Manage bind/close of KafkaClientMetrics for the specified Producer.\n-     * If the producer has not been seen before, it will be bound to the\n-     * Micrometer registry and instrumented using a Kafka MeterBinder.\n-     * If the producer has been seen before, the MeterBinder will be closed.\n-     * \n-     * @param producer Observed Kafka Producer\n-     */\n-    public void producerCreated(@Observes Producer<?, ?> producer) {\n-        KafkaClientMetrics prev = clientMetrics.remove(producer);\n-        if (prev == null) {\n-            clientMetrics.computeIfAbsent(producer, x -> {\n-                try {\n-                    KafkaClientMetrics metrics = new KafkaClientMetrics(producer);\n-                    metrics.bindTo(registry);\n-                    return metrics;\n-                } catch (Throwable t) {\n-                    t.printStackTrace();\n-                    return null;\n-                }\n-            });\n-        } else {\n-            prev.close();\n-        }\n-    }\n-}\n"}}, {"oid": "70b007ee99452e8a992b9a190a05aa14f80a6e29", "url": "https://github.com/quarkusio/quarkus/commit/70b007ee99452e8a992b9a190a05aa14f80a6e29", "message": "Warning message for deprecated property", "committedDate": "2020-10-06T13:01:20Z", "type": "commit"}, {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "url": "https://github.com/quarkusio/quarkus/commit/41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-06T13:01:20Z", "type": "commit"}, {"oid": "41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "url": "https://github.com/quarkusio/quarkus/commit/41f29547c223eab20bc4b8bce6f91ba1aa02c61a", "message": "Kafka + Micrometer metrics", "committedDate": "2020-10-06T13:01:20Z", "type": "forcePushed"}]}