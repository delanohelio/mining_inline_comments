{"pr_number": 11760, "pr_title": "OpenShift container image extension", "pr_createdAt": "2020-08-31T19:16:53Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/11760", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NjgzMA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480386830", "bodyText": "Super minor nitpick: Best use single().satisfies(h -> {...}) as hasOnlyOneElementSatisfying has been deprecated", "author": "geoand", "createdAt": "2020-08-31T20:40:49Z", "path": "integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/OpenshiftWithDockerBuildStrategyTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package io.quarkus.it.kubernetes;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.assertj.core.api.AbstractObjectAssert;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.spec.JavaArchive;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+\n+import io.fabric8.kubernetes.api.model.HasMetadata;\n+import io.fabric8.openshift.api.model.DockerBuildStrategy;\n+import io.quarkus.bootstrap.model.AppArtifact;\n+import io.quarkus.builder.Version;\n+import io.quarkus.test.ProdBuildResults;\n+import io.quarkus.test.ProdModeTestResults;\n+import io.quarkus.test.QuarkusProdModeTest;\n+\n+public class OpenshiftWithDockerBuildStrategyTest {\n+\n+    @RegisterExtension\n+    static final QuarkusProdModeTest config = new QuarkusProdModeTest()\n+            .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class).addClasses(GreetingResource.class))\n+            .setApplicationName(\"openshift-s2i\").setApplicationVersion(\"0.1-SNAPSHOT\")\n+            .withConfigurationResource(\"openshift-with-docker-build-strategy.properties\")\n+            .setForcedDependencies(Collections\n+                    .singletonList(new AppArtifact(\"io.quarkus\", \"quarkus-openshift\", Version.getVersion())));\n+\n+    @ProdBuildResults\n+    private ProdModeTestResults prodModeTestResults;\n+\n+    @Test\n+    public void assertGeneratedResources() throws IOException {\n+        Path kubernetesDir = prodModeTestResults.getBuildDir().resolve(\"kubernetes\");\n+\n+        assertThat(kubernetesDir).isDirectoryContaining(p -> p.getFileName().endsWith(\"openshift.json\"))\n+                .isDirectoryContaining(p -> p.getFileName().endsWith(\"openshift.yml\"));\n+        List<HasMetadata> openshiftList = DeserializationUtil.deserializeAsList(kubernetesDir.resolve(\"openshift.yml\"));\n+\n+        assertThat(openshiftList).filteredOn(h -> \"BuildConfig\".equals(h.getKind())).hasOnlyOneElementSatisfying(h -> {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71e488fbd7079f8c5894cb65061b401484fef71c", "chunk": "diff --git a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/OpenshiftWithDockerBuildStrategyTest.java b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/OpenshiftWithDockerBuildStrategyTest.java\nindex 9b66478383..567a7273a9 100644\n--- a/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/OpenshiftWithDockerBuildStrategyTest.java\n+++ b/integration-tests/kubernetes/quarkus-standard-way/src/test/java/io/quarkus/it/kubernetes/OpenshiftWithDockerBuildStrategyTest.java\n\n@@ -42,7 +42,7 @@ public class OpenshiftWithDockerBuildStrategyTest {\n                 .isDirectoryContaining(p -> p.getFileName().endsWith(\"openshift.yml\"));\n         List<HasMetadata> openshiftList = DeserializationUtil.deserializeAsList(kubernetesDir.resolve(\"openshift.yml\"));\n \n-        assertThat(openshiftList).filteredOn(h -> \"BuildConfig\".equals(h.getKind())).hasOnlyOneElementSatisfying(h -> {\n+        assertThat(openshiftList).filteredOn(h -> \"BuildConfig\".equals(h.getKind())).singleElement().satisfies(h -> {\n             assertThat(h.getMetadata()).satisfies(m -> {\n                 assertThat(m.getName()).isEqualTo(\"openshift-s2i\");\n                 assertThat(m.getLabels().get(\"app.openshift.io/runtime\")).isEqualTo(\"quarkus\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MjY1OA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480392658", "bodyText": "We should probably move findMainSourcesRoot some utility common to all container-image extensions - It doesn't need to be now of course", "author": "geoand", "createdAt": "2020-08-31T20:53:04Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java", "diffHunk": "@@ -65,12 +83,36 @@ public CapabilityBuildItem capability() {\n         return new CapabilityBuildItem(Capability.CONTAINER_IMAGE_S2I);\n     }\n \n+    @BuildStep(onlyIf = { S2iBuild.class }, onlyIfNot = NativeBuild.class)\n+    public void s2iPrepareJvmDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.jvmDockerfile))));\n+            decorator.produce(new DecoratorBuildItem(new RemoveEnvVarDecorator(null, \"JAVA_APP_JAR\")));\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = { S2iBuild.class, NativeBuild.class })\n+    public void s2iPrepareNativeDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.nativeDockerfile))));", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1OTU5Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r493659593", "bodyText": "This is already in the quarkus container image util module.", "author": "iocanel", "createdAt": "2020-09-23T14:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MjY1OA=="}], "type": "inlineReview", "revised_code": {"commit": "71e488fbd7079f8c5894cb65061b401484fef71c", "chunk": "diff --git a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java\nindex 0e3ba90756..44e45d3a8c 100644\n--- a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java\n+++ b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java\n\n@@ -112,7 +112,6 @@ public class S2iProcessor {\n             OutputTargetBuildItem out,\n             PackageConfig packageConfig,\n             JarBuildItem jarBuildItem,\n-            BuildProducer<DecoratorBuildItem> decorator,\n             BuildProducer<KubernetesEnvBuildItem> envProducer,\n             BuildProducer<BaseImageInfoBuildItem> builderImageProducer,\n             BuildProducer<KubernetesCommandBuildItem> commandProducer) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NDY1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480394656", "bodyText": "This seems to be unused", "author": "geoand", "createdAt": "2020-08-31T20:57:11Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java", "diffHunk": "@@ -65,12 +83,36 @@ public CapabilityBuildItem capability() {\n         return new CapabilityBuildItem(Capability.CONTAINER_IMAGE_S2I);\n     }\n \n+    @BuildStep(onlyIf = { S2iBuild.class }, onlyIfNot = NativeBuild.class)\n+    public void s2iPrepareJvmDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.jvmDockerfile))));\n+            decorator.produce(new DecoratorBuildItem(new RemoveEnvVarDecorator(null, \"JAVA_APP_JAR\")));\n+        }\n+    }\n+\n+    @BuildStep(onlyIf = { S2iBuild.class, NativeBuild.class })\n+    public void s2iPrepareNativeDockerBuild(S2iConfig s2iConfig,\n+            OutputTargetBuildItem out,\n+            BuildProducer<DecoratorBuildItem> decorator) {\n+        if (s2iConfig.buildStrategy == BuildStrategy.docker) {\n+            decorator.produce(new DecoratorBuildItem(new ApplyDockerfileToBuildConfigDecorator(null,\n+                    findMainSourcesRoot(out.getOutputDirectory()).getValue().resolve(s2iConfig.nativeDockerfile))));\n+        }\n+        //Let's remove this for all kinds of native build\n+        decorator.produce(new DecoratorBuildItem(new RemoveEnvVarDecorator(null, \"JAVA_APP_JAR\")));\n+    }\n+\n     @BuildStep(onlyIf = { IsNormal.class, S2iBuild.class }, onlyIfNot = NativeBuild.class)\n     public void s2iRequirementsJvm(S2iConfig s2iConfig,\n             CurateOutcomeBuildItem curateOutcomeBuildItem,\n             OutputTargetBuildItem out,\n             PackageConfig packageConfig,\n             JarBuildItem jarBuildItem,\n+            BuildProducer<DecoratorBuildItem> decorator,", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "71e488fbd7079f8c5894cb65061b401484fef71c", "chunk": "diff --git a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java\nindex 0e3ba90756..44e45d3a8c 100644\n--- a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java\n+++ b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/S2iProcessor.java\n\n@@ -112,7 +112,6 @@ public class S2iProcessor {\n             OutputTargetBuildItem out,\n             PackageConfig packageConfig,\n             JarBuildItem jarBuildItem,\n-            BuildProducer<DecoratorBuildItem> decorator,\n             BuildProducer<KubernetesEnvBuildItem> envProducer,\n             BuildProducer<BaseImageInfoBuildItem> builderImageProducer,\n             BuildProducer<KubernetesCommandBuildItem> commandProducer) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NTQ0OA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480395448", "bodyText": "Can we get some comments in this?\nMentioning it because this looks like where most of the problems could arise - the rest of the changes seem pretty straighforward, but this one is a mouth full :)", "author": "geoand", "createdAt": "2020-08-31T20:58:42Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MjI3NA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r488752274", "bodyText": "This is copied from dekorate and modified so that it can support custom entry prefix paths.\nThis should be fixed upstream. See: dekorateio/dekorate#621", "author": "iocanel", "createdAt": "2020-09-15T15:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NTQ0OA=="}], "type": "inlineReview", "revised_code": {"commit": "4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "chunk": "diff --git a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\ndeleted file mode 100644\nindex 1b6d1b067b..0000000000\n--- a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\n+++ /dev/null\n\n@@ -1,216 +0,0 @@\n-\n-package io.quarkus.container.image.s2i.deployment;\n-\n-import java.io.BufferedOutputStream;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.jsoup.helper.StringUtil;\n-\n-import io.dekorate.DekorateException;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n-\n-public class PackageUtil {\n-\n-    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n-    private static final String DOCKER_IGNORE = \".dockerignore\";\n-\n-    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n-    protected static final String DOCKER_PREFIX = \"docker-\";\n-    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n-\n-    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n-\n-    public static File packageFile(String path) {\n-        return packageFile(path, null);\n-    }\n-\n-    public static File packageFile(String path, String base) {\n-        try {\n-            final Path root = Paths.get(path).getParent();\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!path.equals(absolutePath)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw DekorateException.launderThrowable(e);\n-        }\n-    }\n-\n-    public static File packageFile(Path root, Path... additional) {\n-        return packageFile(root, null, additional);\n-    }\n-\n-    public static File packageFile(Path root, String base, Path... additional) {\n-        try {\n-            final Set<String> includes = Arrays\n-                    .stream(additional)\n-                    .map(p -> p.toAbsolutePath().toString())\n-                    .collect(Collectors.toSet());\n-\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!shouldInclude(absolutePath, includes)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static void putTarEntry(TarArchiveOutputStream tarArchiveOutputStream, TarArchiveEntry tarArchiveEntry,\n-            Path inputPath) throws IOException {\n-        tarArchiveEntry.setSize(Files.size(inputPath));\n-        tarArchiveOutputStream.putArchiveEntry(tarArchiveEntry);\n-        Files.copy(inputPath, tarArchiveOutputStream);\n-        tarArchiveOutputStream.closeArchiveEntry();\n-    }\n-\n-    public static TarArchiveOutputStream buildTarStream(File outputPath) throws IOException {\n-        FileOutputStream fout = new FileOutputStream(outputPath);\n-        BufferedOutputStream bout = new BufferedOutputStream(fout);\n-        //BZip2CompressorOutputStream bzout = new BZip2CompressorOutputStream(bout);\n-        TarArchiveOutputStream stream = new TarArchiveOutputStream(bout);\n-        stream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n-        return stream;\n-    }\n-\n-    public static void tar(Path inputPath, Path outputPath) throws IOException {\n-        if (!Files.exists(inputPath)) {\n-            throw new FileNotFoundException(\"File not found \" + inputPath);\n-        }\n-\n-        try (TarArchiveOutputStream tarArchiveOutputStream = buildTarStream(outputPath.toFile())) {\n-            if (!Files.isDirectory(inputPath)) {\n-                TarArchiveEntry tarEntry = new TarArchiveEntry(inputPath.toFile().getName());\n-                if (inputPath.toFile().canExecute()) {\n-                    tarEntry.setMode(tarEntry.getMode() | 0755);\n-                }\n-                putTarEntry(tarArchiveOutputStream, tarEntry, inputPath);\n-            } else {\n-                Files.walkFileTree(inputPath,\n-                        new TarDirWalker(inputPath, tarArchiveOutputStream));\n-            }\n-            tarArchiveOutputStream.flush();\n-        }\n-    }\n-\n-    private static boolean shouldInclude(String candidate, String path) {\n-        return candidate.equals(path) || candidate.startsWith(path);\n-    }\n-\n-    private static boolean shouldInclude(String candidate, Set<String> paths) {\n-        for (String path : paths) {\n-            if (shouldInclude(candidate, path)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public static class TarDirWalker extends SimpleFileVisitor<Path> {\n-        private Path basePath;\n-        private TarArchiveOutputStream tarArchiveOutputStream;\n-\n-        public TarDirWalker(Path basePath, TarArchiveOutputStream tarArchiveOutputStream) {\n-            this.basePath = basePath;\n-            this.tarArchiveOutputStream = tarArchiveOutputStream;\n-        }\n-\n-        @Override\n-        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-            if (!dir.equals(basePath)) {\n-                tarArchiveOutputStream.putArchiveEntry(new TarArchiveEntry(basePath.relativize(dir).toFile()));\n-                tarArchiveOutputStream.closeArchiveEntry();\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-            TarArchiveEntry tarEntry = new TarArchiveEntry(basePath.relativize(file).toFile());\n-            tarEntry.setSize(attrs.size());\n-            if (file.toFile().canExecute()) {\n-                tarEntry.setMode(tarEntry.getMode() | 0755);\n-            }\n-            putTarEntry(tarArchiveOutputStream, tarEntry, file);\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-            tarArchiveOutputStream.close();\n-            throw exc;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg0OTkzOQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480849939", "bodyText": "This seems to be unused", "author": "geoand", "createdAt": "2020-09-01T05:56:34Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {\n+\n+    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n+    private static final String DOCKER_IGNORE = \".dockerignore\";\n+\n+    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n+    protected static final String DOCKER_PREFIX = \"docker-\";\n+    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n+\n+    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+    public static File packageFile(String path) {\n+        return packageFile(path, null);\n+    }\n+\n+    public static File packageFile(String path, String base) {\n+        try {\n+            final Path root = Paths.get(path).getParent();\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!path.equals(absolutePath)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw DekorateException.launderThrowable(e);\n+        }\n+    }\n+\n+    public static File packageFile(Path root, Path... additional) {\n+        return packageFile(root, null, additional);\n+    }\n+\n+    public static File packageFile(Path root, String base, Path... additional) {\n+        try {\n+            final Set<String> includes = Arrays\n+                    .stream(additional)\n+                    .map(p -> p.toAbsolutePath().toString())\n+                    .collect(Collectors.toSet());\n+\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!shouldInclude(absolutePath, includes)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void putTarEntry(TarArchiveOutputStream tarArchiveOutputStream, TarArchiveEntry tarArchiveEntry,\n+            Path inputPath) throws IOException {\n+        tarArchiveEntry.setSize(Files.size(inputPath));\n+        tarArchiveOutputStream.putArchiveEntry(tarArchiveEntry);\n+        Files.copy(inputPath, tarArchiveOutputStream);\n+        tarArchiveOutputStream.closeArchiveEntry();\n+    }\n+\n+    public static TarArchiveOutputStream buildTarStream(File outputPath) throws IOException {\n+        FileOutputStream fout = new FileOutputStream(outputPath);\n+        BufferedOutputStream bout = new BufferedOutputStream(fout);\n+        //BZip2CompressorOutputStream bzout = new BZip2CompressorOutputStream(bout);\n+        TarArchiveOutputStream stream = new TarArchiveOutputStream(bout);\n+        stream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n+        return stream;\n+    }\n+\n+    public static void tar(Path inputPath, Path outputPath) throws IOException {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MjUzNA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r488752534", "bodyText": "Same as above.", "author": "iocanel", "createdAt": "2020-09-15T15:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg0OTkzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "chunk": "diff --git a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\ndeleted file mode 100644\nindex 1b6d1b067b..0000000000\n--- a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\n+++ /dev/null\n\n@@ -1,216 +0,0 @@\n-\n-package io.quarkus.container.image.s2i.deployment;\n-\n-import java.io.BufferedOutputStream;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.jsoup.helper.StringUtil;\n-\n-import io.dekorate.DekorateException;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n-\n-public class PackageUtil {\n-\n-    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n-    private static final String DOCKER_IGNORE = \".dockerignore\";\n-\n-    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n-    protected static final String DOCKER_PREFIX = \"docker-\";\n-    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n-\n-    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n-\n-    public static File packageFile(String path) {\n-        return packageFile(path, null);\n-    }\n-\n-    public static File packageFile(String path, String base) {\n-        try {\n-            final Path root = Paths.get(path).getParent();\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!path.equals(absolutePath)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw DekorateException.launderThrowable(e);\n-        }\n-    }\n-\n-    public static File packageFile(Path root, Path... additional) {\n-        return packageFile(root, null, additional);\n-    }\n-\n-    public static File packageFile(Path root, String base, Path... additional) {\n-        try {\n-            final Set<String> includes = Arrays\n-                    .stream(additional)\n-                    .map(p -> p.toAbsolutePath().toString())\n-                    .collect(Collectors.toSet());\n-\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!shouldInclude(absolutePath, includes)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static void putTarEntry(TarArchiveOutputStream tarArchiveOutputStream, TarArchiveEntry tarArchiveEntry,\n-            Path inputPath) throws IOException {\n-        tarArchiveEntry.setSize(Files.size(inputPath));\n-        tarArchiveOutputStream.putArchiveEntry(tarArchiveEntry);\n-        Files.copy(inputPath, tarArchiveOutputStream);\n-        tarArchiveOutputStream.closeArchiveEntry();\n-    }\n-\n-    public static TarArchiveOutputStream buildTarStream(File outputPath) throws IOException {\n-        FileOutputStream fout = new FileOutputStream(outputPath);\n-        BufferedOutputStream bout = new BufferedOutputStream(fout);\n-        //BZip2CompressorOutputStream bzout = new BZip2CompressorOutputStream(bout);\n-        TarArchiveOutputStream stream = new TarArchiveOutputStream(bout);\n-        stream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n-        return stream;\n-    }\n-\n-    public static void tar(Path inputPath, Path outputPath) throws IOException {\n-        if (!Files.exists(inputPath)) {\n-            throw new FileNotFoundException(\"File not found \" + inputPath);\n-        }\n-\n-        try (TarArchiveOutputStream tarArchiveOutputStream = buildTarStream(outputPath.toFile())) {\n-            if (!Files.isDirectory(inputPath)) {\n-                TarArchiveEntry tarEntry = new TarArchiveEntry(inputPath.toFile().getName());\n-                if (inputPath.toFile().canExecute()) {\n-                    tarEntry.setMode(tarEntry.getMode() | 0755);\n-                }\n-                putTarEntry(tarArchiveOutputStream, tarEntry, inputPath);\n-            } else {\n-                Files.walkFileTree(inputPath,\n-                        new TarDirWalker(inputPath, tarArchiveOutputStream));\n-            }\n-            tarArchiveOutputStream.flush();\n-        }\n-    }\n-\n-    private static boolean shouldInclude(String candidate, String path) {\n-        return candidate.equals(path) || candidate.startsWith(path);\n-    }\n-\n-    private static boolean shouldInclude(String candidate, Set<String> paths) {\n-        for (String path : paths) {\n-            if (shouldInclude(candidate, path)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public static class TarDirWalker extends SimpleFileVisitor<Path> {\n-        private Path basePath;\n-        private TarArchiveOutputStream tarArchiveOutputStream;\n-\n-        public TarDirWalker(Path basePath, TarArchiveOutputStream tarArchiveOutputStream) {\n-            this.basePath = basePath;\n-            this.tarArchiveOutputStream = tarArchiveOutputStream;\n-        }\n-\n-        @Override\n-        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-            if (!dir.equals(basePath)) {\n-                tarArchiveOutputStream.putArchiveEntry(new TarArchiveEntry(basePath.relativize(dir).toFile()));\n-                tarArchiveOutputStream.closeArchiveEntry();\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-            TarArchiveEntry tarEntry = new TarArchiveEntry(basePath.relativize(file).toFile());\n-            tarEntry.setSize(attrs.size());\n-            if (file.toFile().canExecute()) {\n-                tarEntry.setMode(tarEntry.getMode() | 0755);\n-            }\n-            putTarEntry(tarArchiveOutputStream, tarEntry, file);\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-            tarArchiveOutputStream.close();\n-            throw exc;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MTUwNw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480851507", "bodyText": "Are you sure that using 0755 like this is correct?", "author": "geoand", "createdAt": "2020-09-01T05:58:59Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {\n+\n+    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n+    private static final String DOCKER_IGNORE = \".dockerignore\";\n+\n+    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n+    protected static final String DOCKER_PREFIX = \"docker-\";\n+    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n+\n+    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+    public static File packageFile(String path) {\n+        return packageFile(path, null);\n+    }\n+\n+    public static File packageFile(String path, String base) {\n+        try {\n+            final Path root = Paths.get(path).getParent();\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!path.equals(absolutePath)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw DekorateException.launderThrowable(e);\n+        }\n+    }\n+\n+    public static File packageFile(Path root, Path... additional) {\n+        return packageFile(root, null, additional);\n+    }\n+\n+    public static File packageFile(Path root, String base, Path... additional) {\n+        try {\n+            final Set<String> includes = Arrays\n+                    .stream(additional)\n+                    .map(p -> p.toAbsolutePath().toString())\n+                    .collect(Collectors.toSet());\n+\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!shouldInclude(absolutePath, includes)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MjgwMQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r488752801", "bodyText": "Yeah", "author": "iocanel", "createdAt": "2020-09-15T15:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MTUwNw=="}], "type": "inlineReview", "revised_code": {"commit": "4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "chunk": "diff --git a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\ndeleted file mode 100644\nindex 1b6d1b067b..0000000000\n--- a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\n+++ /dev/null\n\n@@ -1,216 +0,0 @@\n-\n-package io.quarkus.container.image.s2i.deployment;\n-\n-import java.io.BufferedOutputStream;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.jsoup.helper.StringUtil;\n-\n-import io.dekorate.DekorateException;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n-\n-public class PackageUtil {\n-\n-    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n-    private static final String DOCKER_IGNORE = \".dockerignore\";\n-\n-    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n-    protected static final String DOCKER_PREFIX = \"docker-\";\n-    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n-\n-    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n-\n-    public static File packageFile(String path) {\n-        return packageFile(path, null);\n-    }\n-\n-    public static File packageFile(String path, String base) {\n-        try {\n-            final Path root = Paths.get(path).getParent();\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!path.equals(absolutePath)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw DekorateException.launderThrowable(e);\n-        }\n-    }\n-\n-    public static File packageFile(Path root, Path... additional) {\n-        return packageFile(root, null, additional);\n-    }\n-\n-    public static File packageFile(Path root, String base, Path... additional) {\n-        try {\n-            final Set<String> includes = Arrays\n-                    .stream(additional)\n-                    .map(p -> p.toAbsolutePath().toString())\n-                    .collect(Collectors.toSet());\n-\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!shouldInclude(absolutePath, includes)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static void putTarEntry(TarArchiveOutputStream tarArchiveOutputStream, TarArchiveEntry tarArchiveEntry,\n-            Path inputPath) throws IOException {\n-        tarArchiveEntry.setSize(Files.size(inputPath));\n-        tarArchiveOutputStream.putArchiveEntry(tarArchiveEntry);\n-        Files.copy(inputPath, tarArchiveOutputStream);\n-        tarArchiveOutputStream.closeArchiveEntry();\n-    }\n-\n-    public static TarArchiveOutputStream buildTarStream(File outputPath) throws IOException {\n-        FileOutputStream fout = new FileOutputStream(outputPath);\n-        BufferedOutputStream bout = new BufferedOutputStream(fout);\n-        //BZip2CompressorOutputStream bzout = new BZip2CompressorOutputStream(bout);\n-        TarArchiveOutputStream stream = new TarArchiveOutputStream(bout);\n-        stream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n-        return stream;\n-    }\n-\n-    public static void tar(Path inputPath, Path outputPath) throws IOException {\n-        if (!Files.exists(inputPath)) {\n-            throw new FileNotFoundException(\"File not found \" + inputPath);\n-        }\n-\n-        try (TarArchiveOutputStream tarArchiveOutputStream = buildTarStream(outputPath.toFile())) {\n-            if (!Files.isDirectory(inputPath)) {\n-                TarArchiveEntry tarEntry = new TarArchiveEntry(inputPath.toFile().getName());\n-                if (inputPath.toFile().canExecute()) {\n-                    tarEntry.setMode(tarEntry.getMode() | 0755);\n-                }\n-                putTarEntry(tarArchiveOutputStream, tarEntry, inputPath);\n-            } else {\n-                Files.walkFileTree(inputPath,\n-                        new TarDirWalker(inputPath, tarArchiveOutputStream));\n-            }\n-            tarArchiveOutputStream.flush();\n-        }\n-    }\n-\n-    private static boolean shouldInclude(String candidate, String path) {\n-        return candidate.equals(path) || candidate.startsWith(path);\n-    }\n-\n-    private static boolean shouldInclude(String candidate, Set<String> paths) {\n-        for (String path : paths) {\n-            if (shouldInclude(candidate, path)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public static class TarDirWalker extends SimpleFileVisitor<Path> {\n-        private Path basePath;\n-        private TarArchiveOutputStream tarArchiveOutputStream;\n-\n-        public TarDirWalker(Path basePath, TarArchiveOutputStream tarArchiveOutputStream) {\n-            this.basePath = basePath;\n-            this.tarArchiveOutputStream = tarArchiveOutputStream;\n-        }\n-\n-        @Override\n-        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-            if (!dir.equals(basePath)) {\n-                tarArchiveOutputStream.putArchiveEntry(new TarArchiveEntry(basePath.relativize(dir).toFile()));\n-                tarArchiveOutputStream.closeArchiveEntry();\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-            TarArchiveEntry tarEntry = new TarArchiveEntry(basePath.relativize(file).toFile());\n-            tarEntry.setSize(attrs.size());\n-            if (file.toFile().canExecute()) {\n-                tarEntry.setMode(tarEntry.getMode() | 0755);\n-            }\n-            putTarEntry(tarArchiveOutputStream, tarEntry, file);\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-            tarArchiveOutputStream.close();\n-            throw exc;\n-        }\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MjA3MQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r480852071", "bodyText": "This method seems to have plenty of similarities with packageFile. Can the common code be extracted?", "author": "geoand", "createdAt": "2020-09-01T05:59:46Z", "path": "extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java", "diffHunk": "@@ -0,0 +1,216 @@\n+\n+package io.quarkus.container.image.s2i.deployment;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jsoup.helper.StringUtil;\n+\n+import io.dekorate.DekorateException;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n+import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n+\n+public class PackageUtil {\n+\n+    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n+    private static final String DOCKER_IGNORE = \".dockerignore\";\n+\n+    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n+    protected static final String DOCKER_PREFIX = \"docker-\";\n+    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n+\n+    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n+\n+    public static File packageFile(String path) {\n+        return packageFile(path, null);\n+    }\n+\n+    public static File packageFile(String path, String base) {\n+        try {\n+            final Path root = Paths.get(path).getParent();\n+            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n+            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n+                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n+                    @Override\n+                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+\n+                    @Override\n+                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n+                        String absolutePath = file.toAbsolutePath().toString();\n+                        if (!path.equals(absolutePath)) {\n+                            return FileVisitResult.CONTINUE;\n+                        }\n+                        final Path relativePath = root.relativize(file);\n+                        final boolean hasBasePath = !StringUtil.isBlank(base);\n+                        final TarArchiveEntry entry = hasBasePath\n+                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n+                                : new TarArchiveEntry(file.toFile());\n+\n+                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n+                        if (file.toFile().canExecute()) {\n+                            entry.setMode(entry.getMode() | 0755);\n+                        }\n+                        entry.setSize(attrs.size());\n+                        putTarEntry(tout, entry, file);\n+                        return FileVisitResult.CONTINUE;\n+                    }\n+                });\n+                tout.flush();\n+            }\n+            return tempFile;\n+\n+        } catch (IOException e) {\n+            throw DekorateException.launderThrowable(e);\n+        }\n+    }\n+\n+    public static File packageFile(Path root, Path... additional) {\n+        return packageFile(root, null, additional);\n+    }\n+\n+    public static File packageFile(Path root, String base, Path... additional) {", "originalCommit": "ad2012f78968f77be03653d48ac806576aa08a3a", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "chunk": "diff --git a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java b/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\ndeleted file mode 100644\nindex 1b6d1b067b..0000000000\n--- a/extensions/container-image/container-image-s2i/deployment/src/main/java/io/quarkus/container/image/s2i/deployment/PackageUtil.java\n+++ /dev/null\n\n@@ -1,216 +0,0 @@\n-\n-package io.quarkus.container.image.s2i.deployment;\n-\n-import java.io.BufferedOutputStream;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.charset.Charset;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Arrays;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import org.jsoup.helper.StringUtil;\n-\n-import io.dekorate.DekorateException;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveEntry;\n-import io.dekorate.deps.commons.compress.archivers.tar.TarArchiveOutputStream;\n-\n-public class PackageUtil {\n-\n-    private static final String DEFAULT_DOCKERFILE = \"Dockerfile\";\n-    private static final String DOCKER_IGNORE = \".dockerignore\";\n-\n-    protected static final String DEFAULT_TEMP_DIR = System.getProperty(\"java.io.tmpdir\", \"/tmp\");\n-    protected static final String DOCKER_PREFIX = \"docker-\";\n-    protected static final String BZIP2_SUFFIX = \".tar.bzip2\";\n-\n-    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n-\n-    public static File packageFile(String path) {\n-        return packageFile(path, null);\n-    }\n-\n-    public static File packageFile(String path, String base) {\n-        try {\n-            final Path root = Paths.get(path).getParent();\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!path.equals(absolutePath)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw DekorateException.launderThrowable(e);\n-        }\n-    }\n-\n-    public static File packageFile(Path root, Path... additional) {\n-        return packageFile(root, null, additional);\n-    }\n-\n-    public static File packageFile(Path root, String base, Path... additional) {\n-        try {\n-            final Set<String> includes = Arrays\n-                    .stream(additional)\n-                    .map(p -> p.toAbsolutePath().toString())\n-                    .collect(Collectors.toSet());\n-\n-            File tempFile = Files.createTempFile(Paths.get(DEFAULT_TEMP_DIR), DOCKER_PREFIX, BZIP2_SUFFIX).toFile();\n-            try (final TarArchiveOutputStream tout = buildTarStream(tempFile)) {\n-                Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                    @Override\n-                    public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-\n-                    @Override\n-                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-                        String absolutePath = file.toAbsolutePath().toString();\n-                        if (!shouldInclude(absolutePath, includes)) {\n-                            return FileVisitResult.CONTINUE;\n-                        }\n-                        final Path relativePath = root.relativize(file);\n-                        final boolean hasBasePath = !StringUtil.isBlank(base);\n-                        final TarArchiveEntry entry = hasBasePath\n-                                ? new TarArchiveEntry(base + File.separator + file.toFile())\n-                                : new TarArchiveEntry(file.toFile());\n-\n-                        entry.setName(hasBasePath ? base + File.separator + relativePath.toString() : relativePath.toString());\n-                        if (file.toFile().canExecute()) {\n-                            entry.setMode(entry.getMode() | 0755);\n-                        }\n-                        entry.setSize(attrs.size());\n-                        putTarEntry(tout, entry, file);\n-                        return FileVisitResult.CONTINUE;\n-                    }\n-                });\n-                tout.flush();\n-            }\n-            return tempFile;\n-\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    public static void putTarEntry(TarArchiveOutputStream tarArchiveOutputStream, TarArchiveEntry tarArchiveEntry,\n-            Path inputPath) throws IOException {\n-        tarArchiveEntry.setSize(Files.size(inputPath));\n-        tarArchiveOutputStream.putArchiveEntry(tarArchiveEntry);\n-        Files.copy(inputPath, tarArchiveOutputStream);\n-        tarArchiveOutputStream.closeArchiveEntry();\n-    }\n-\n-    public static TarArchiveOutputStream buildTarStream(File outputPath) throws IOException {\n-        FileOutputStream fout = new FileOutputStream(outputPath);\n-        BufferedOutputStream bout = new BufferedOutputStream(fout);\n-        //BZip2CompressorOutputStream bzout = new BZip2CompressorOutputStream(bout);\n-        TarArchiveOutputStream stream = new TarArchiveOutputStream(bout);\n-        stream.setLongFileMode(TarArchiveOutputStream.LONGFILE_POSIX);\n-        return stream;\n-    }\n-\n-    public static void tar(Path inputPath, Path outputPath) throws IOException {\n-        if (!Files.exists(inputPath)) {\n-            throw new FileNotFoundException(\"File not found \" + inputPath);\n-        }\n-\n-        try (TarArchiveOutputStream tarArchiveOutputStream = buildTarStream(outputPath.toFile())) {\n-            if (!Files.isDirectory(inputPath)) {\n-                TarArchiveEntry tarEntry = new TarArchiveEntry(inputPath.toFile().getName());\n-                if (inputPath.toFile().canExecute()) {\n-                    tarEntry.setMode(tarEntry.getMode() | 0755);\n-                }\n-                putTarEntry(tarArchiveOutputStream, tarEntry, inputPath);\n-            } else {\n-                Files.walkFileTree(inputPath,\n-                        new TarDirWalker(inputPath, tarArchiveOutputStream));\n-            }\n-            tarArchiveOutputStream.flush();\n-        }\n-    }\n-\n-    private static boolean shouldInclude(String candidate, String path) {\n-        return candidate.equals(path) || candidate.startsWith(path);\n-    }\n-\n-    private static boolean shouldInclude(String candidate, Set<String> paths) {\n-        for (String path : paths) {\n-            if (shouldInclude(candidate, path)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public static class TarDirWalker extends SimpleFileVisitor<Path> {\n-        private Path basePath;\n-        private TarArchiveOutputStream tarArchiveOutputStream;\n-\n-        public TarDirWalker(Path basePath, TarArchiveOutputStream tarArchiveOutputStream) {\n-            this.basePath = basePath;\n-            this.tarArchiveOutputStream = tarArchiveOutputStream;\n-        }\n-\n-        @Override\n-        public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-            if (!dir.equals(basePath)) {\n-                tarArchiveOutputStream.putArchiveEntry(new TarArchiveEntry(basePath.relativize(dir).toFile()));\n-                tarArchiveOutputStream.closeArchiveEntry();\n-            }\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-            TarArchiveEntry tarEntry = new TarArchiveEntry(basePath.relativize(file).toFile());\n-            tarEntry.setSize(attrs.size());\n-            if (file.toFile().canExecute()) {\n-                tarEntry.setMode(tarEntry.getMode() | 0755);\n-            }\n-            putTarEntry(tarArchiveOutputStream, tarEntry, file);\n-            return FileVisitResult.CONTINUE;\n-        }\n-\n-        @Override\n-        public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {\n-            tarArchiveOutputStream.close();\n-            throw exc;\n-        }\n-    }\n-}\n"}}, {"oid": "a5228a7c88a361ea80f7cc141838a405413b8526", "url": "https://github.com/quarkusio/quarkus/commit/a5228a7c88a361ea80f7cc141838a405413b8526", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-23T14:41:12Z", "type": "forcePushed"}, {"oid": "71e488fbd7079f8c5894cb65061b401484fef71c", "url": "https://github.com/quarkusio/quarkus/commit/71e488fbd7079f8c5894cb65061b401484fef71c", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-24T06:01:40Z", "type": "forcePushed"}, {"oid": "520c69d93862d9d8a1ba00e04936d0227314b15b", "url": "https://github.com/quarkusio/quarkus/commit/520c69d93862d9d8a1ba00e04936d0227314b15b", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-24T07:52:48Z", "type": "forcePushed"}, {"oid": "12d812a47b136a16cfd5b37b322e09f824f68de8", "url": "https://github.com/quarkusio/quarkus/commit/12d812a47b136a16cfd5b37b322e09f824f68de8", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-24T07:53:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzODQwMg==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494938402", "bodyText": "Probably best to have these capitalized?", "author": "geoand", "createdAt": "2020-09-25T11:58:10Z", "path": "extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/BuildStrategy.java", "diffHunk": "@@ -0,0 +1,9 @@\n+\n+package io.quarkus.container.image.openshift.deployment;\n+\n+public enum BuildStrategy {\n+\n+    binary,", "originalCommit": "12d812a47b136a16cfd5b37b322e09f824f68de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1MDUyMA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494950520", "bodyText": "The are lowercase, as they read better when passed to application.properties.", "author": "iocanel", "createdAt": "2020-09-25T12:23:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDkzODQwMg=="}], "type": "inlineReview", "revised_code": {"commit": "8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "chunk": "diff --git a/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/BuildStrategy.java b/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/BuildStrategy.java\nindex d253b6cb18..7fb2cb7786 100644\n--- a/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/BuildStrategy.java\n+++ b/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/BuildStrategy.java\n\n@@ -3,7 +3,7 @@ package io.quarkus.container.image.openshift.deployment;\n \n public enum BuildStrategy {\n \n-    binary,\n-    docker;\n+    BINARY,\n+    DOCKER;\n \n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MDQ0OA==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494940448", "bodyText": "This name is too vague IMHO. I would prefer if it were named mergeConfig", "author": "geoand", "createdAt": "2020-09-25T12:02:38Z", "path": "extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/OpenshiftUtils.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package io.quarkus.container.image.openshift.deployment;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import org.eclipse.microprofile.config.Config;\n+import org.eclipse.microprofile.config.ConfigProvider;\n+\n+import io.dekorate.deps.kubernetes.api.model.HasMetadata;\n+import io.dekorate.deps.kubernetes.api.model.KubernetesListBuilder;\n+import io.dekorate.deps.kubernetes.api.model.ObjectReference;\n+import io.dekorate.deps.openshift.api.model.ImageStreamTag;\n+import io.dekorate.deps.openshift.api.model.SourceBuildStrategyFluent;\n+import io.dekorate.deps.openshift.client.OpenShiftClient;\n+import io.dekorate.kubernetes.decorator.Decorator;\n+\n+/**\n+ * This class is copied from Dekorate, with the difference that the {@code waitForImageStreamTags} method\n+ * take a client as the argument\n+ *\n+ * TODO: Update dekorate to take the client as an argument and then remove this class\n+ */\n+public class OpenshiftUtils {\n+\n+    /**\n+     * Wait for the references ImageStreamTags to become available.\n+     *\n+     * @param client The openshift client used to check the status of the ImageStream\n+     * @param items A list of items, possibly referencing image stream tags.\n+     * @param amount The max amount of time to wait.\n+     * @param timeUnit The time unit of the time to wait.\n+     * @return True if the items became available false otherwise.\n+     */\n+    public static boolean waitForImageStreamTags(OpenShiftClient client, Collection<HasMetadata> items, long amount,\n+            TimeUnit timeUnit) {\n+        if (items == null || items.isEmpty()) {\n+            return true;\n+        }\n+        final List<String> tags = new ArrayList<>();\n+        new KubernetesListBuilder()\n+                .withItems(new ArrayList<>(items))\n+                .accept(new Decorator<SourceBuildStrategyFluent>() {\n+                    @Override\n+                    public void visit(SourceBuildStrategyFluent strategy) {\n+                        ObjectReference from = strategy.buildFrom();\n+                        if (from.getKind().equals(\"ImageStreamTag\")) {\n+                            tags.add(from.getName());\n+                        }\n+                    }\n+                }).build();\n+\n+        boolean tagsMissing = true;\n+        long started = System.currentTimeMillis();\n+        long elapsed = 0;\n+\n+        while (tagsMissing && elapsed < timeUnit.toMillis(amount) && !Thread.interrupted()) {\n+            tagsMissing = false;\n+            for (String tag : tags) {\n+                ImageStreamTag t = client.imageStreamTags().withName(tag).get();\n+                if (t == null) {\n+                    tagsMissing = true;\n+                }\n+            }\n+\n+            if (tagsMissing) {\n+                try {\n+                    Thread.sleep(1000);\n+                    elapsed = System.currentTimeMillis() - started;\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                }\n+            }\n+        }\n+        return !tagsMissing;\n+    }\n+\n+    /**\n+     * Merges {@link OpenshiftConfig} with {@link S2iConfig} prioritizing in the former.\n+     * \n+     * @param openshiftConfig the Openshift config\n+     * @param s2iConfig the s2i config\n+     * @param an instance of {@link OpenshiftConfig} with the merged configuration.\n+     */\n+    public static OpenshiftConfig merge(OpenshiftConfig openshiftConfig, S2iConfig s2iConfig) {", "originalCommit": "12d812a47b136a16cfd5b37b322e09f824f68de8", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "chunk": "diff --git a/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/OpenshiftUtils.java b/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/OpenshiftUtils.java\nindex 772f651444..2af3d75ba7 100644\n--- a/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/OpenshiftUtils.java\n+++ b/extensions/container-image/container-image-openshift/deployment/src/main/java/io/quarkus/container/image/openshift/deployment/OpenshiftUtils.java\n\n@@ -86,7 +86,7 @@ public class OpenshiftUtils {\n      * @param s2iConfig the s2i config\n      * @param an instance of {@link OpenshiftConfig} with the merged configuration.\n      */\n-    public static OpenshiftConfig merge(OpenshiftConfig openshiftConfig, S2iConfig s2iConfig) {\n+    public static OpenshiftConfig mergeConfig(OpenshiftConfig openshiftConfig, S2iConfig s2iConfig) {\n         OpenshiftConfig result = openshiftConfig != null ? openshiftConfig : new OpenshiftConfig();\n         if (s2iConfig == null) {\n             return result;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MjIwNw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494942207", "bodyText": "What's the rationale of this change? I think we at least need a comment about it", "author": "geoand", "createdAt": "2020-09-25T12:06:22Z", "path": "extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java", "diffHunk": "@@ -378,6 +383,16 @@ public void build(ApplicationInfoBuildItem applicationInfo,\n                     kubernetesHealthLivenessPath,\n                     kubernetesHealthReadinessPath);\n \n+            decorators.stream().filter(d -> d.matches(Decorator.class)).forEach(i -> {", "originalCommit": "12d812a47b136a16cfd5b37b322e09f824f68de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1MjkyNQ==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494952925", "bodyText": "As I didn't felt comfortable is exposing Decorate specific classes in the kubernetes spi. Decorators are passed to build items as Objects. So, at some point we need to check if the build item is indeed holding an instance of the Decorator.class.\nDefinitely not the most elegant solution, but I feel it's somehow better than dragging decorate to the kubernetes spi.\nI am open about it though.", "author": "iocanel", "createdAt": "2020-09-25T12:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MjIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1NTU1Mw==", "url": "https://github.com/quarkusio/quarkus/pull/11760#discussion_r494955553", "bodyText": "Understood. I'm fine with it, but let's please add some relevant comments to the source", "author": "geoand", "createdAt": "2020-09-25T12:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk0MjIwNw=="}], "type": "inlineReview", "revised_code": {"commit": "8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "chunk": "diff --git a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java\nindex 3326f8009a..739c7e4618 100644\n--- a/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java\n+++ b/extensions/kubernetes/vanilla/deployment/src/main/java/io/quarkus/kubernetes/deployment/KubernetesProcessor.java\n\n@@ -383,6 +384,9 @@ class KubernetesProcessor {\n                     kubernetesHealthLivenessPath,\n                     kubernetesHealthReadinessPath);\n \n+\n+            //We need to verify to filter out anything that doesn't extend the Decorator class.\n+            //The DecoratorBuildItem is a wrapper to Object.\n             decorators.stream().filter(d -> d.matches(Decorator.class)).forEach(i -> {\n                 String group = i.getGroup();\n                 Decorator decorator = (Decorator) i.getDecorator();\n"}}, {"oid": "8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "url": "https://github.com/quarkusio/quarkus/commit/8e45bf5a5dbf4fa27b2a866880ca24af0e1ab3d3", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-29T08:04:10Z", "type": "forcePushed"}, {"oid": "4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "url": "https://github.com/quarkusio/quarkus/commit/4f9dc06f2ba81f13812f3a6f0ea836540831d8e7", "message": "feat: Allow passing decorators via kubernetes spi", "committedDate": "2020-09-29T08:04:10Z", "type": "commit"}, {"oid": "fc712d823431068bc52d65d7c306964139e76ee4", "url": "https://github.com/quarkusio/quarkus/commit/fc712d823431068bc52d65d7c306964139e76ee4", "message": "feat: Implement docker strategy for Openshift BuildConfig", "committedDate": "2020-09-29T08:04:10Z", "type": "commit"}, {"oid": "f507274a95675539f247aee9b6a16804e9ed14c5", "url": "https://github.com/quarkusio/quarkus/commit/f507274a95675539f247aee9b6a16804e9ed14c5", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-29T10:00:52Z", "type": "forcePushed"}, {"oid": "f507274a95675539f247aee9b6a16804e9ed14c5", "url": "https://github.com/quarkusio/quarkus/commit/f507274a95675539f247aee9b6a16804e9ed14c5", "message": "refactor: move docker stratgey for openshift into separate module.", "committedDate": "2020-09-29T10:00:52Z", "type": "commit"}]}