{"pr_number": 14032, "pr_title": "Refactor CacheResultInterceptor exceptions handling and tests", "pr_createdAt": "2020-12-22T23:20:51Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/14032", "timeline": [{"oid": "220ede94a8bc1367a7188b8758f8680475081732", "url": "https://github.com/quarkusio/quarkus/commit/220ede94a8bc1367a7188b8758f8680475081732", "message": "Refactor CacheResultInterceptor exceptions handling and tests", "committedDate": "2020-12-22T23:11:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NDU4Ng==", "url": "https://github.com/quarkusio/quarkus/pull/14032#discussion_r547554586", "bodyText": "There used to be two code branches and we had to deal with asynchronous cache computations before, but today cache computations are done synchronously on the calling thread so this method has become completely useless.", "author": "gwenneg", "createdAt": "2020-12-22T23:24:21Z", "path": "extensions/cache/deployment/src/test/java/io/quarkus/cache/test/runtime/ThrowExecutionExceptionCauseTest.java", "diffHunk": "@@ -55,74 +48,13 @@ public void testCheckedExceptionThrowDuringCacheComputation() {\n     }\n \n     @Test\n-    public void testRuntimeExceptionThrowDuringCacheComputationWithLockTimeout() {\n-        UnsupportedOperationException e = assertThrows(UnsupportedOperationException.class, () -> {\n-            cachedService.throwRuntimeExceptionDuringCacheComputationWithLockTimeout();\n+    public void testErrorThrowDuringCacheComputation() {\n+        OutOfMemoryError e = assertThrows(OutOfMemoryError.class, () -> {\n+            cachedService.throwErrorDuringCacheComputation();\n         });\n         assertEquals(FORCED_EXCEPTION_MESSAGE, e.getMessage());\n     }\n \n-    @Test\n-    public void testBothLockTimeoutCodeBranches() throws InterruptedException {", "originalCommit": "220ede94a8bc1367a7188b8758f8680475081732", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1NDg1Ng==", "url": "https://github.com/quarkusio/quarkus/pull/14032#discussion_r547554856", "bodyText": "That was actually wrong, interceptors can throw any Throwable \ud83d\ude04", "author": "gwenneg", "createdAt": "2020-12-22T23:25:13Z", "path": "extensions/cache/runtime/src/main/java/io/quarkus/cache/runtime/CacheResultInterceptor.java", "diffHunk": "@@ -65,24 +65,20 @@ public Object apply(Object k) {\n              * thrown during a CompletionStage execution.\n              */\n             if (e.getCause() instanceof CacheException) {\n-                // The ExecutionException was caused by a CacheException (most likely case).\n-                CacheException cacheException = (CacheException) e.getCause();\n-                // Let's see if we can throw the root cause of the exceptions chain.\n-                if (cacheException.getCause() instanceof Exception) {\n-                    // If it is an Exception, the root cause is thrown.\n-                    throw (Exception) cacheException.getCause();\n+                /*\n+                 * The ExecutionException was caused by a CacheException (most likely case).\n+                 * Let's throw the CacheException cause if possible or the CacheException itself otherwise.\n+                 */\n+                if (e.getCause().getCause() != null) {\n+                    throw e.getCause().getCause();\n                 } else {\n-                    // If it is an Error, the CacheException itself is thrown because interceptors have to throw exceptions.", "originalCommit": "220ede94a8bc1367a7188b8758f8680475081732", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}]}