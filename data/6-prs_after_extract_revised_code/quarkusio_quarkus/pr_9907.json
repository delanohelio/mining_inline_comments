{"pr_number": 9907, "pr_title": "Correctly register metrics for inherited default methods", "pr_createdAt": "2020-06-10T10:48:01Z", "pr_url": "https://github.com/quarkusio/quarkus/pull/9907", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NDc4Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438064783", "bodyText": "Is that true? It seems that you call findNonOverriddenDefaultMethods when you traverse the inheritance hierachy, so not all superclasses are processed yet when you call this method. Would it be better to traverse the inheritance hierarchy twice, first to process superclasses, and second to process interfaces?", "author": "Ladicek", "createdAt": "2020-06-10T11:55:01Z", "path": "extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java", "diffHunk": "@@ -396,6 +407,35 @@ void registerMetricsFromAnnotatedMethods(SmallRyeMetricsRecorder metrics,\n         }\n     }\n \n+    private void findNonOverriddenDefaultMethods(ClassInfo interfaceInfo, List<ClassInfo> subClasses,\n+            SmallRyeMetricsRecorder recorder,\n+            BeanArchiveIndexBuildItem beanArchiveIndex, JandexMemberInfoAdapter memberInfoAdapter, BeanInfo beanInfo) {\n+        // Check for default methods which are NOT overridden by the bean that we are registering metrics for\n+        // or any of its superclasses. Register a metric for each of them.\n+        interfaceInfo.methods().forEach(method -> {\n+            if (!Modifier.isAbstract(method.flags())) { // only take default methods\n+                // Here we check that the default method is not overridden by the bean of any of its superclasses,\n+                // because in such case it was already picked up while scanning through superclasses and their methods", "originalCommit": "6660b1185ae60577cd098b17627df8b75d831209", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA3NDM3NQ==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438074375", "bodyText": "Hmm I guess it should then say \"already scanned superclasses\", because some of them are not processed yet... \"Already scanned superclasses  and implemented interfaces\" == the subClasses list, yeah the naming is very fortunate, perhaps a alreadyScanned would be a better name. Would it make more sense to you then?\nI nearly burst my brain writing this algorithm, so it's also possible that there's a mistake. If you can come up with a scenario that breaks it...", "author": "jmartisk", "createdAt": "2020-06-10T12:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE2MzM0OA==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438163348", "bodyText": "I don't know, didn't try, but I was thinking something like:\nclass A extends B implements I {\n}\n\nclass B extends C {\n}\n\nclass C {\n  @Timed\n  public void doSomething() { ... }\n}\n\ninterface I {\n  @Timed\n  default void doSomething() { ... }\n}\nPer Java rules, A.doSomething() runs the C.doSomething method, but the algorithm here, in my understanding, will select I.doSomething. Or am I wrong about that?", "author": "Ladicek", "createdAt": "2020-06-10T14:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU5NDcxMg==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438594712", "bodyText": "It does not actually matter what exact method the algorithm registered the metric from, the only thing that matters is the name, because here we're only registering the metric, not binding the registration to any interceptor or so.\nAlso we're talking about the case when the metric annotation is on the concrete bean (and meaning on the class level, not method level), not in the interface, because we don't support that case yet.\nAnyway if i take your scenario and move the @Timed annotations to the class-level of A, then it indeed breaks, because it attempts to register A.doSomething twice. Guess we'll need to track \"already registered method names\" rather than \"already visited classes\", I'll come up with something...", "author": "jmartisk", "createdAt": "2020-06-11T07:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYwODI2Nw==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438608267", "bodyText": "Changed the tracking of \"already visited classes\" to tracking of \"already registered method names\".\nIt does not matter where exactly the method is taken from (which superclass or interface) if there are multiple options - the metric name is computed from the (concrete) bean name and method name. We just need to see each method at least once.", "author": "jmartisk", "createdAt": "2020-06-11T07:56:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODA2NDc4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "9291c70db048eb268fe5595e7c544a127239ebc7", "chunk": "diff --git a/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java b/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java\nindex 63eee8b931..94d38380a9 100644\n--- a/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java\n+++ b/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java\n\n@@ -407,29 +402,24 @@ public class SmallRyeMetricsProcessor {\n         }\n     }\n \n-    private void findNonOverriddenDefaultMethods(ClassInfo interfaceInfo, List<ClassInfo> subClasses,\n+    private void findNonOverriddenDefaultMethods(ClassInfo interfaceInfo, List<String> alreadyRegisteredNames,\n             SmallRyeMetricsRecorder recorder,\n             BeanArchiveIndexBuildItem beanArchiveIndex, JandexMemberInfoAdapter memberInfoAdapter, BeanInfo beanInfo) {\n         // Check for default methods which are NOT overridden by the bean that we are registering metrics for\n         // or any of its superclasses. Register a metric for each of them.\n-        interfaceInfo.methods().forEach(method -> {\n+        for (MethodInfo method : interfaceInfo.methods()) {\n             if (!Modifier.isAbstract(method.flags())) { // only take default methods\n-                // Here we check that the default method is not overridden by the bean of any of its superclasses,\n-                // because in such case it was already picked up while scanning through superclasses and their methods\n-                if (subClasses.stream().allMatch(\n-                        subClass -> subClass.method(method.name(), method.parameters().toArray(new Type[0])) == null)) {\n+                if (!alreadyRegisteredNames.contains(method.name())) {\n                     recorder.registerMetrics(beanInfo, memberInfoAdapter.convert(method));\n+                    alreadyRegisteredNames.add(method.name());\n                 }\n             }\n-        });\n+        }\n         // recursively repeat the same for interfaces which this interface extends\n         for (Type extendedInterface : interfaceInfo.interfaceTypes()) {\n-            List<ClassInfo> subClasses1 = new ArrayList<>(subClasses);\n-            subClasses1.add(interfaceInfo); // to keep track of all interfaces that we've visited on the way so far\n-            // that's to prevent duplicate registration in case that an intermediary interface overrides the default method\n             ClassInfo extendedInterfaceInfo = beanArchiveIndex.getIndex().getClassByName(extendedInterface.name());\n             if (extendedInterfaceInfo != null) {\n-                findNonOverriddenDefaultMethods(extendedInterfaceInfo, subClasses1, recorder, beanArchiveIndex,\n+                findNonOverriddenDefaultMethods(extendedInterfaceInfo, alreadyRegisteredNames, recorder, beanArchiveIndex,\n                         memberInfoAdapter,\n                         beanInfo);\n             }\n"}}, {"oid": "9291c70db048eb268fe5595e7c544a127239ebc7", "url": "https://github.com/quarkusio/quarkus/commit/9291c70db048eb268fe5595e7c544a127239ebc7", "message": "Correctly register metrics for inherited default methods", "committedDate": "2020-06-11T07:53:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYwOTY3Mw==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438609673", "bodyText": "Should it be a Set?", "author": "Ladicek", "createdAt": "2020-06-11T07:58:44Z", "path": "extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java", "diffHunk": "@@ -370,17 +371,22 @@ void registerMetricsFromAnnotatedMethods(SmallRyeMetricsRecorder metrics,\n         for (ClassInfo clazz : collectedMetricsClasses.values()) {\n             BeanInfo beanInfo = beanInfoAdapter.convert(clazz);\n             ClassInfo superclass = clazz;\n+            List<String> alreadyRegisteredNames = new ArrayList<>();", "originalCommit": "9291c70db048eb268fe5595e7c544a127239ebc7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYxNTA3MA==", "url": "https://github.com/quarkusio/quarkus/pull/9907#discussion_r438615070", "bodyText": "Oh.. yeah. Fixed", "author": "jmartisk", "createdAt": "2020-06-11T08:09:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYwOTY3Mw=="}], "type": "inlineReview", "revised_code": {"commit": "fe5e3122d5d784c6b9ca0df602d2ea2244609a72", "chunk": "diff --git a/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java b/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java\nindex 94d38380a9..a2701061f6 100644\n--- a/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java\n+++ b/extensions/smallrye-metrics/deployment/src/main/java/io/quarkus/smallrye/metrics/deployment/SmallRyeMetricsProcessor.java\n\n@@ -371,7 +370,7 @@ public class SmallRyeMetricsProcessor {\n         for (ClassInfo clazz : collectedMetricsClasses.values()) {\n             BeanInfo beanInfo = beanInfoAdapter.convert(clazz);\n             ClassInfo superclass = clazz;\n-            List<String> alreadyRegisteredNames = new ArrayList<>();\n+            Set<String> alreadyRegisteredNames = new HashSet<>();\n             // register metrics for all inherited methods as well\n             while (superclass != null && superclass.superName() != null) {\n                 for (MethodInfo method : superclass.methods()) {\n"}}, {"oid": "fe5e3122d5d784c6b9ca0df602d2ea2244609a72", "url": "https://github.com/quarkusio/quarkus/commit/fe5e3122d5d784c6b9ca0df602d2ea2244609a72", "message": "Correctly register metrics for inherited default methods", "committedDate": "2020-06-11T08:09:24Z", "type": "forcePushed"}, {"oid": "fe5e3122d5d784c6b9ca0df602d2ea2244609a72", "url": "https://github.com/quarkusio/quarkus/commit/fe5e3122d5d784c6b9ca0df602d2ea2244609a72", "message": "Correctly register metrics for inherited default methods", "committedDate": "2020-06-11T08:09:24Z", "type": "commit"}]}