{"pr_number": 3897, "pr_title": "CAMEL-13934 camel-minio - Component to store/load files from blob store", "pr_createdAt": "2020-06-07T21:45:18Z", "pr_url": "https://github.com/apache/camel/pull/3897", "timeline": [{"oid": "18ec4f679abc44faac6792ddc5a619a880e05e93", "url": "https://github.com/apache/camel/commit/18ec4f679abc44faac6792ddc5a619a880e05e93", "message": "Replaced redundant checks with centralized lambdas", "committedDate": "2020-08-08T16:44:10Z", "type": "forcePushed"}, {"oid": "4e7587acde63bffaa8966d15689af206cb9577d9", "url": "https://github.com/apache/camel/commit/4e7587acde63bffaa8966d15689af206cb9577d9", "message": "Changed the error message in checkAndSetRegistryClient in MinioComponent.java", "committedDate": "2020-08-08T17:17:25Z", "type": "commit"}, {"oid": "9f619c84b46945598c63f1d7ad04cdefa1329d39", "url": "https://github.com/apache/camel/commit/9f619c84b46945598c63f1d7ad04cdefa1329d39", "message": "Fixed article issues in minio-component.adoc and unused parameter", "committedDate": "2020-08-08T17:46:46Z", "type": "commit"}, {"oid": "5ce02877a27e4c44242760f1bd7af412bd220664", "url": "https://github.com/apache/camel/commit/5ce02877a27e4c44242760f1bd7af412bd220664", "message": "Mimicked aws2-s3 component, ran mvn clean install -DskipTests", "committedDate": "2020-08-09T03:36:30Z", "type": "commit"}, {"oid": "ae457d0c7b0907f3ede8722baf1eec49803d60d4", "url": "https://github.com/apache/camel/commit/ae457d0c7b0907f3ede8722baf1eec49803d60d4", "message": "Minor fixes", "committedDate": "2020-08-09T06:27:38Z", "type": "commit"}, {"oid": "7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "url": "https://github.com/apache/camel/commit/7e7c617cce3dc8ee50b2c4eaf46d9730918ce63d", "message": "Resolved a TODO", "committedDate": "2020-08-09T16:10:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470795", "bodyText": "This class can be removed.", "author": "oscerd", "createdAt": "2020-06-08T05:56:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n+ * this component can consume from.\n+ */\n+public class EventBusHelper {", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjQzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437672436", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:38:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDc5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java b/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\ndeleted file mode 100644\nindex 6f82b1d075c..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/EventBusHelper.java\n+++ /dev/null\n\n@@ -1,61 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Consumer;\n-\n-/**\n- * Used for demonstrations purpose to simulate some external system event bus/broker, where messages are sent to, and\n- * this component can consume from.\n- */\n-public class EventBusHelper {\n-\n-    // TODO: Delete me when you implementy your custom component\n-\n-    private static EventBusHelper INSTANCE;\n-\n-    final private Set<Consumer> subscribers = ConcurrentHashMap.newKeySet();\n-\n-    private EventBusHelper() {\n-    }\n-\n-    public static EventBusHelper getInstance(){\n-        if (INSTANCE == null) {\n-            INSTANCE = new EventBusHelper();\n-        }\n-\n-        return INSTANCE;\n-    }\n-\n-    public <T> void subscribe(final Consumer<T> subscriber) {\n-        subscribers.add(subscriber);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public <T> void publish(final T event){\n-        // Notify all subscribers\n-        subscribers.forEach(consumer -> publishSingleEvent(event, consumer));\n-    }\n-\n-    private <T> void publishSingleEvent(final T event, final Consumer<T> subscriber){\n-        subscriber.accept(event);\n-    }\n-\n-}\n\\ No newline at end of file\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MDk1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436470950", "bodyText": "You can use directly Component annotation without the whole package.", "author": "oscerd", "createdAt": "2020-06-08T05:57:13Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import java.util.Map;\n+\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.Endpoint;\n+\n+import org.apache.camel.support.DefaultComponent;\n+\n+@org.apache.camel.spi.annotations.Component(\"MinIO\")", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java b/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\nsimilarity index 62%\nrename from components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java\nrename to components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\nindex 3595bd418ab..ac89094a1ac 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOComponent.java\n+++ b/components/camel-openapi-java/src/main/java/org/apache/camel/openapi/RestDefinitionsResolver.java\n\n@@ -14,22 +14,22 @@\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n+package org.apache.camel.openapi;\n \n-package org.apache.camel;\n-\n-import java.util.Map;\n+import java.util.List;\n \n import org.apache.camel.CamelContext;\n-import org.apache.camel.Endpoint;\n+import org.apache.camel.model.rest.RestDefinition;\n+\n+/**\n+ * Pluggable resolver for resolving rest and camel context either local or globally via JMX for the entire JVM\n+ */\n+public interface RestDefinitionsResolver {\n+\n+    String JMX_REST_DEFINITION_RESOLVER = \"jmx-rest-definition-resolver\";\n+\n+    List<RestDefinition> getRestDefinitions(CamelContext camelContext, String camelId) throws Exception;\n \n-import org.apache.camel.support.DefaultComponent;\n+    List<String> findCamelContexts() throws Exception;\n \n-@org.apache.camel.spi.annotations.Component(\"MinIO\")\n-public class MinIOComponent extends DefaultComponent {\n-    \n-    protected Endpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n-        Endpoint endpoint = new MinIOEndpoint(uri, this);\n-        setProperties(endpoint, parameters);\n-        return endpoint;\n-    }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r436471145", "bodyText": "Remove the eventBusHelper, except it is something really useful to the basic feature of component, but I don't think so.", "author": "oscerd", "createdAt": "2020-06-08T05:58:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Exchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.support.DefaultConsumer;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+public class MinIOConsumer extends DefaultConsumer {\n+    private final MinIOEndpoint endpoint;\n+    private final EventBusHelper eventBusHelper;\n+\n+    private ExecutorService executorService;\n+\n+    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+        this.endpoint = endpoint;\n+        eventBusHelper = EventBusHelper.getInstance();", "originalCommit": "b6cd7fb707f1ee66f5b4fa54ecd69cf70ed0f7a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3Mzg1MQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r437673851", "bodyText": "Hi thank you for the suggestion, and I'll remove this for sure. But I'll keep it for a while for some random hello world kind tests while on the go. :)", "author": "Nayananga", "createdAt": "2020-06-09T19:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTE0NQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\ndeleted file mode 100644\nindex f1c62ddb85a..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOConsumer.java\n+++ /dev/null\n\n@@ -1,77 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Exchange;\n-import org.apache.camel.Processor;\n-import org.apache.camel.RuntimeCamelException;\n-import org.apache.camel.support.DefaultConsumer;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-public class MinIOConsumer extends DefaultConsumer {\n-    private final MinIOEndpoint endpoint;\n-    private final EventBusHelper eventBusHelper;\n-\n-    private ExecutorService executorService;\n-\n-    public MinIOConsumer(MinIOEndpoint endpoint, Processor processor) {\n-        super(endpoint, processor);\n-        this.endpoint = endpoint;\n-        eventBusHelper = EventBusHelper.getInstance();\n-    }\n-\n-    @Override\n-    protected void doStart() throws Exception {\n-        super.doStart();\n-\n-        // start a single threaded pool to monitor events\n-        executorService = endpoint.createExecutor();\n-\n-        // submit task to the thread pool\n-        executorService.submit(() -> {\n-            // subscribe to an event\n-            eventBusHelper.subscribe(this::onEventListener);\n-        });\n-    }\n-\n-    @Override\n-    protected void doStop() throws Exception {\n-        super.doStop();\n-\n-        // shutdown the thread pool gracefully\n-        getEndpoint().getCamelContext().getExecutorServiceManager().shutdownGraceful(executorService);\n-    }\n-\n-    private void onEventListener(final Object event) {\n-        final Exchange exchange = endpoint.createExchange();\n-\n-        exchange.getIn().setBody(\"Hello World! The time is \" + event);\n-\n-        try {\n-            // send message to next processor in the route\n-            getProcessor().process(exchange);\n-        } catch (Exception e) {\n-            exchange.setException(e);\n-        } finally {\n-            if (exchange.getException() != null) {\n-                getExceptionHandler().handleException(\"Error processing exchange\", exchange, exchange.getException());\n-            }\n-        }\n-    }\n-}\n"}}, {"oid": "ece2cb7569d380486b4a0187ac97b3fac0574bbd", "url": "https://github.com/apache/camel/commit/ece2cb7569d380486b4a0187ac97b3fac0574bbd", "message": "Added auto generated files", "committedDate": "2020-06-10T04:13:01Z", "type": "forcePushed"}, {"oid": "2acf3087813b7b772b0efa5415212d4aa26495cd", "url": "https://github.com/apache/camel/commit/2acf3087813b7b772b0efa5415212d4aa26495cd", "message": "Updated minio-component.adoc file", "committedDate": "2020-06-12T13:33:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjMzMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466333", "bodyText": "Maybe firstVersion could be set to 3.5.0 or something like that.", "author": "DenisIstomin", "createdAt": "2020-06-12T14:50:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\ndeleted file mode 100644\nindex b7c90e3bb8d..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ /dev/null\n\n@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n-import org.apache.camel.support.DefaultEndpoint;\n-import org.apache.camel.spi.Metadata;\n-import org.apache.camel.spi.UriEndpoint;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriPath;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * MinIO component which does bla bla.\n- *\n- * TODO: Update one line description above what the component does.\n- */\n-@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",\n-             consumerClass = MinIOConsumer.class, label = \"custom\")\n-public class MinIOEndpoint extends DefaultEndpoint {\n-    @UriPath @Metadata(required = true)\n-    private String name;\n-    @UriParam(defaultValue = \"10\")\n-    private int option = 10;\n-\n-    public MinIOEndpoint() {\n-    }\n-\n-    public MinIOEndpoint(String uri, MinIOComponent component) {\n-        super(uri, component);\n-    }\n-\n-    public Producer createProducer() throws Exception {\n-        return new MinIOProducer(this);\n-    }\n-\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        Consumer consumer = new MinIOConsumer(this, processor);\n-        configureConsumer(consumer);\n-        return consumer;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n-    }\n-\n-    public int getOption() {\n-        return option;\n-    }\n-\n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2NjY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r439466644", "bodyText": "And maybe scheme could be lowercase, like \"minio\"", "author": "DenisIstomin", "createdAt": "2020-06-12T14:51:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.camel;\n+\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.support.DefaultEndpoint;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+\n+import java.util.concurrent.ExecutorService;\n+\n+/**\n+ * MinIO component which does bla bla.\n+ *\n+ * TODO: Update one line description above what the component does.\n+ */\n+@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",", "originalCommit": "2acf3087813b7b772b0efa5415212d4aa26495cd", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\ndeleted file mode 100644\nindex b7c90e3bb8d..00000000000\n--- a/components/camel-minio/src/main/java/org/apache/camel/MinIOEndpoint.java\n+++ /dev/null\n\n@@ -1,87 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package org.apache.camel;\n-\n-import org.apache.camel.Consumer;\n-import org.apache.camel.Processor;\n-import org.apache.camel.Producer;\n-import org.apache.camel.support.DefaultEndpoint;\n-import org.apache.camel.spi.Metadata;\n-import org.apache.camel.spi.UriEndpoint;\n-import org.apache.camel.spi.UriParam;\n-import org.apache.camel.spi.UriPath;\n-\n-import java.util.concurrent.ExecutorService;\n-\n-/**\n- * MinIO component which does bla bla.\n- *\n- * TODO: Update one line description above what the component does.\n- */\n-@UriEndpoint(firstVersion = \"1.0-SNAPSHOT\", scheme = \"MinIO\", title = \"MinIO\", syntax=\"MinIO:name\",\n-             consumerClass = MinIOConsumer.class, label = \"custom\")\n-public class MinIOEndpoint extends DefaultEndpoint {\n-    @UriPath @Metadata(required = true)\n-    private String name;\n-    @UriParam(defaultValue = \"10\")\n-    private int option = 10;\n-\n-    public MinIOEndpoint() {\n-    }\n-\n-    public MinIOEndpoint(String uri, MinIOComponent component) {\n-        super(uri, component);\n-    }\n-\n-    public Producer createProducer() throws Exception {\n-        return new MinIOProducer(this);\n-    }\n-\n-    public Consumer createConsumer(Processor processor) throws Exception {\n-        Consumer consumer = new MinIOConsumer(this, processor);\n-        configureConsumer(consumer);\n-        return consumer;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setName(String name) {\n-        this.name = name;\n-    }\n-\n-    public String getName() {\n-        return name;\n-    }\n-\n-    /**\n-     * Some description of this option, and what it does\n-     */\n-    public void setOption(int option) {\n-        this.option = option;\n-    }\n-\n-    public int getOption() {\n-        return option;\n-    }\n-\n-    public ExecutorService createExecutor() {\n-        // TODO: Delete me when you implementy your custom component\n-        return getCamelContext().getExecutorServiceManager().newSingleThreadExecutor(this, \"MinIOConsumer\");\n-    }\n-}\n"}}, {"oid": "c26cc5d467d572180ba8a6a0d42bf52967b32010", "url": "https://github.com/apache/camel/commit/c26cc5d467d572180ba8a6a0d42bf52967b32010", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-12T20:41:12Z", "type": "forcePushed"}, {"oid": "39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "url": "https://github.com/apache/camel/commit/39e847ad781ca35a4d69735cf9d92c47aeeba0d0", "message": "Code fixed for camel-checkstyle", "committedDate": "2020-06-13T06:41:19Z", "type": "forcePushed"}, {"oid": "1e7d342708e717f9299d7b55ef435ac776e616e9", "url": "https://github.com/apache/camel/commit/1e7d342708e717f9299d7b55ef435ac776e616e9", "message": "Recommended changes done", "committedDate": "2020-06-13T07:28:48Z", "type": "forcePushed"}, {"oid": "a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "url": "https://github.com/apache/camel/commit/a0538d43806eac5d88a4b6cb9ee7fcea97a0ad41", "message": "Recommended changes done", "committedDate": "2020-06-13T08:03:57Z", "type": "forcePushed"}, {"oid": "c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "url": "https://github.com/apache/camel/commit/c1f4c4a57e9b85b40cd531746b0f98b98f9fc66c", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-13T22:09:26Z", "type": "forcePushed"}, {"oid": "d965cdf77194a40ee48877e4551ef97e63c692e7", "url": "https://github.com/apache/camel/commit/d965cdf77194a40ee48877e4551ef97e63c692e7", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-06-14T03:07:03Z", "type": "forcePushed"}, {"oid": "557c54ccc663f5b0b044f80629973afd8ceacb28", "url": "https://github.com/apache/camel/commit/557c54ccc663f5b0b044f80629973afd8ceacb28", "message": "Code reformatted", "committedDate": "2020-06-18T04:28:40Z", "type": "forcePushed"}, {"oid": "c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "url": "https://github.com/apache/camel/commit/c9282c3f360308ad99724fb7ebf3aecf16ffe7b8", "message": "Updated imports", "committedDate": "2020-06-18T21:18:28Z", "type": "forcePushed"}, {"oid": "1fe1eda807af55348e41b0a61fd601003f7e1360", "url": "https://github.com/apache/camel/commit/1fe1eda807af55348e41b0a61fd601003f7e1360", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-06-19T16:16:43Z", "type": "forcePushed"}, {"oid": "f46f2996d879c333635e764484ec74d5deb2b890", "url": "https://github.com/apache/camel/commit/f46f2996d879c333635e764484ec74d5deb2b890", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-24T22:11:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445202915", "bodyText": "@oscerd @DenisIstomin What kind of approach suitable here? AWS2 S3 component have use something like this\nListObjectsRequest.Builder listObjectsRequest = ListObjectsRequest.builder();\n            listObjectsRequest.bucket(bucketName);\n            listObjectsRequest.prefix(getConfiguration().getPrefix());\n            listObjectsRequest.delimiter(getConfiguration().getDelimiter());", "author": "Nayananga", "createdAt": "2020-06-24T22:18:37Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwMjk1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445302954", "bodyText": "you could use https://docs.min.io/docs/java-client-api-reference.html#listObjects @Nayananga", "author": "oscerd", "createdAt": "2020-06-25T04:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjkxNQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,14 +16,28 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n-\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n import io.minio.MinioClient;\n-import io.minio.Result;\n+import io.minio.RemoveObjectArgs;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Item;\n-import org.apache.camel.*;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.util.CastUtils;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445307693", "bodyText": "Hi @oscerd, here if users haven't provided any objectName then my intention is to pull all the objects in the bucket using Iterator named marker, first I would like to know is that ok to do?", "author": "Nayananga", "createdAt": "2020-06-25T05:00:48Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Item;\n+import org.apache.camel.*;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        MinioClient minioClient = getConfiguration().getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        String bucketName = getConfiguration().getBucketName();\n+        Queue<Exchange> exchanges = null;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket [{}] with object name [{}]...\", bucketName, objectName);\n+\n+            try {\n+                InputStream stream = minioClient.getObject(bucketName,\n+                        objectName,\n+                        getConfiguration().getOffset(),\n+                        getConfiguration().getLength(),\n+                        getConfiguration().getServerSideEncryption());\n+\n+                exchanges = createExchanges(stream, objectName);\n+            } catch (Exception e) {\n+                LOG.trace(\"Failed to get object in bucket [{}] with object name [{}], Error message [{}]\", bucketName, objectName, e);\n+            }\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            Iterable<Result<Item>> results = minioClient.listObjects(bucketName,", "originalCommit": "f46f2996d879c333635e764484ec74d5deb2b890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwODYzNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445308634", "bodyText": "Hello @Nayananga , yes it is ok. You can do that and then process the result as a batch, like the S3 AWS2 component does.", "author": "oscerd", "createdAt": "2020-06-25T05:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMDY0NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445310644", "bodyText": "Thank you, is it okay to queue all the bucket objects (may take lot memory I guess) then send to  processBatch(CastUtils.cast(exchanges))? because in minio I had to queue each object in a Queue<Object> until iterator.hasNext() return false", "author": "Nayananga", "createdAt": "2020-06-25T05:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMxMTc5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r445311790", "bodyText": "Not all the objects in one call, you need to define a limit for the batch, like setMaxKeys in AWS2 S3 component https://github.com/apache/camel/blob/master/components/camel-aws2-s3/src/main/java/org/apache/camel/component/aws2/s3/AWS2S3Consumer.java#L88", "author": "oscerd", "createdAt": "2020-06-25T05:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMwNzY5Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 78c7b72a228..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,14 +16,28 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n-\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n import io.minio.MinioClient;\n-import io.minio.Result;\n+import io.minio.RemoveObjectArgs;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Item;\n-import org.apache.camel.*;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.util.CastUtils;\n"}}, {"oid": "7174a3c85fdc5148e794521a6e86ca82d3520f2f", "url": "https://github.com/apache/camel/commit/7174a3c85fdc5148e794521a6e86ca82d3520f2f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-25T21:54:51Z", "type": "forcePushed"}, {"oid": "58e3d1b028374ac69716844c063623003d33c19f", "url": "https://github.com/apache/camel/commit/58e3d1b028374ac69716844c063623003d33c19f", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-27T21:34:59Z", "type": "forcePushed"}, {"oid": "6040d1fa742dea91463f02238c51de4ef432b5e6", "url": "https://github.com/apache/camel/commit/6040d1fa742dea91463f02238c51de4ef432b5e6", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-06-28T09:42:08Z", "type": "forcePushed"}, {"oid": "303b36dc012fe0439b1ef3f9127489227fade0cc", "url": "https://github.com/apache/camel/commit/303b36dc012fe0439b1ef3f9127489227fade0cc", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-07-02T20:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY0OTY3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449649678", "bodyText": "Maybe you should avoid using assert. It is not enabled by default. It would be better to handle that with if condition.", "author": "DenisIstomin", "createdAt": "2020-07-03T16:15:31Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -20,28 +20,36 @@ import java.io.IOException;\n import java.io.InputStream;\n import java.security.InvalidKeyException;\n import java.security.NoSuchAlgorithmException;\n-import java.util.*;\n-\n-import io.minio.DownloadObjectArgs;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n import io.minio.MinioClient;\n-import io.minio.Result;\n-import io.minio.errors.InvalidBucketNameException;\n+import io.minio.RemoveObjectArgs;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.AsyncCallback;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.NoFactoryAvailableException;\n import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isEmpty;\n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * A Consumer of messages from the Minio Storage Service.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDM4Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650386", "bodyText": "Maybe try-with-resources could be used here. It would be nice to reduce nesting.", "author": "DenisIstomin", "createdAt": "2020-07-03T16:18:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.*;\n+\n+import io.minio.DownloadObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.Result;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.AsyncCallback;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.NoFactoryAvailableException;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private Iterator<Result<Item>> marker;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) throws NoFactoryAvailableException {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        assert getConfiguration().getBucketName() != null;\n+        String bucketName = getConfiguration().getBucketName();\n+        MinioClient minioClient = getMinioClient();\n+        String objectName = getConfiguration().getObjectName();\n+        InputStream minioObject = null;\n+        Queue<Exchange> exchanges = null;\n+\n+        if (bucketExists(minioClient, bucketName)) {\n+            LOG.trace(\"Bucket {} exists\", bucketName);\n+        } else {\n+            throw new InvalidBucketNameException(\"Bucket {} does not exists\", bucketName);\n+        }\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            try {\n+                minioObject = getObject(bucketName, minioClient, objectName);\n+                if (minioObject != null) {\n+                    exchanges = createExchanges(minioObject, objectName);\n+                }\n+\n+            } catch (Throwable e) {\n+                LOG.warn(\"Failed to get object in bucket {} with object name {}, Error message {}\", bucketName, objectName, e.getMessage());\n+                throw e;\n+\n+            } finally {\n+                //must be closed after use to release network resources.\n+                try {\n+                    assert minioObject != null;\n+                    minioObject.close();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 60ff9b1e2c1..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -20,28 +20,36 @@ import java.io.IOException;\n import java.io.InputStream;\n import java.security.InvalidKeyException;\n import java.security.NoSuchAlgorithmException;\n-import java.util.*;\n-\n-import io.minio.DownloadObjectArgs;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n import io.minio.MinioClient;\n-import io.minio.Result;\n-import io.minio.errors.InvalidBucketNameException;\n+import io.minio.RemoveObjectArgs;\n import io.minio.errors.MinioException;\n-import io.minio.messages.Bucket;\n-import io.minio.messages.Item;\n-import org.apache.camel.AsyncCallback;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n import org.apache.camel.Exchange;\n import org.apache.camel.ExtendedExchange;\n-import org.apache.camel.NoFactoryAvailableException;\n import org.apache.camel.Processor;\n import org.apache.camel.spi.Synchronization;\n import org.apache.camel.support.ScheduledBatchPollingConsumer;\n import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n import org.apache.camel.util.ObjectHelper;\n import org.apache.camel.util.URISupport;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isEmpty;\n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * A Consumer of messages from the Minio Storage Service.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDk3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449650977", "bodyText": "Typo: retrieve", "author": "DenisIstomin", "createdAt": "2020-07-03T16:20:17Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import io.minio.GetObjectTagsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.errors.InvalidBucketNameException;\n+import io.minio.messages.Tags;\n+import jdk.internal.org.jline.utils.Log;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrie objects from Minio Storage Service using Minio SDK.", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex c827cc9fab1..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n\n@@ -16,17 +16,20 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n-import java.nio.charset.Charset;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.StandardCharsets;\n-import java.util.Map;\n \n-import io.minio.GetObjectTagsArgs;\n+import io.minio.BucketExistsArgs;\n import io.minio.MakeBucketArgs;\n import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n import io.minio.errors.InvalidBucketNameException;\n-import io.minio.messages.Tags;\n-import jdk.internal.org.jline.utils.Log;\n import org.apache.camel.Category;\n import org.apache.camel.Component;\n import org.apache.camel.Consumer;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449651579", "bodyText": "Looks like that test should fail, because there are no messages being sent.", "author": "DenisIstomin", "createdAt": "2020-07-03T16:22:46Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit4.CamelTestSupport;\n+import org.junit.Test;\n+\n+public class MinioComponentTest extends CamelTestSupport {\n+\n+    @Test\n+    public void testMinio() throws Exception {\n+        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n+        mock.expectedMinimumMessageCount(1);\n+\n+        assertMockEndpointsSatisfied();", "originalCommit": "303b36dc012fe0439b1ef3f9127489227fade0cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc2MDE4NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r449760185", "bodyText": "ack, I haven't look into tests yet, I'll work on these asap :)", "author": "Nayananga", "createdAt": "2020-07-04T10:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MTU3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java\ndeleted file mode 100644\nindex ff31e186930..00000000000\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentTest.java\n+++ /dev/null\n\n@@ -1,44 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.camel.component.minio;\n-\n-import org.apache.camel.builder.RouteBuilder;\n-import org.apache.camel.component.mock.MockEndpoint;\n-import org.apache.camel.test.junit4.CamelTestSupport;\n-import org.junit.Test;\n-\n-public class MinioComponentTest extends CamelTestSupport {\n-\n-    @Test\n-    public void testMinio() throws Exception {\n-        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n-        mock.expectedMinimumMessageCount(1);\n-\n-        assertMockEndpointsSatisfied();\n-    }\n-\n-    @Override\n-    protected RouteBuilder createRouteBuilder() throws Exception {\n-        return new RouteBuilder() {\n-            public void configure() {\n-                from(\"minio://foo\")\n-                        .to(\"minio://bar\")\n-                        .to(\"mock:result\");\n-            }\n-        };\n-    }\n-}\n"}}, {"oid": "eb8a5eab91055dbefb8eb2a664bc6efc02068922", "url": "https://github.com/apache/camel/commit/eb8a5eab91055dbefb8eb2a664bc6efc02068922", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-07-07T20:00:00Z", "type": "forcePushed"}, {"oid": "9a61617593bd21370a09598b54c766d167a9484c", "url": "https://github.com/apache/camel/commit/9a61617593bd21370a09598b54c766d167a9484c", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-07-09T14:43:55Z", "type": "forcePushed"}, {"oid": "c03064959bc92443b06333578b1c3a212adb8012", "url": "https://github.com/apache/camel/commit/c03064959bc92443b06333578b1c3a212adb8012", "message": "Updated to Minio 7.1.0", "committedDate": "2020-07-09T23:42:26Z", "type": "forcePushed"}, {"oid": "6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "url": "https://github.com/apache/camel/commit/6aa5e647d00ee7dae2c321f22f01b45b03f2cbd4", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-07-10T18:45:31Z", "type": "forcePushed"}, {"oid": "6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "url": "https://github.com/apache/camel/commit/6321e33f3fd832d2af57dc8c5e2d8b966cc7f97e", "message": "Include integration Tests", "committedDate": "2020-07-13T22:08:02Z", "type": "forcePushed"}, {"oid": "311972bb833e08423b081d8268f686355cdcc161", "url": "https://github.com/apache/camel/commit/311972bb833e08423b081d8268f686355cdcc161", "message": "Code Reformatted", "committedDate": "2020-07-15T23:25:21Z", "type": "forcePushed"}, {"oid": "3878b763e4e472b798d59f32e77fe5d52b7d4446", "url": "https://github.com/apache/camel/commit/3878b763e4e472b798d59f32e77fe5d52b7d4446", "message": "Ran Integration tests", "committedDate": "2020-07-16T22:20:43Z", "type": "forcePushed"}, {"oid": "aa7ba42bf24225df0036f6164360b5067781d18b", "url": "https://github.com/apache/camel/commit/aa7ba42bf24225df0036f6164360b5067781d18b", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-07-19T04:14:27Z", "type": "forcePushed"}, {"oid": "0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "url": "https://github.com/apache/camel/commit/0faf24a60a7eaffb51af24f8ac2f15b83b3f8219", "message": "Added documentation", "committedDate": "2020-07-19T18:43:50Z", "type": "forcePushed"}, {"oid": "e6028a86cd2018454b7d0d65938785171b6d02ab", "url": "https://github.com/apache/camel/commit/e6028a86cd2018454b7d0d65938785171b6d02ab", "message": "Minor changes to the tests", "committedDate": "2020-07-24T15:58:23Z", "type": "forcePushed"}, {"oid": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "url": "https://github.com/apache/camel/commit/ca963a048e1beb422fdf86ed84790523e9fd4b76", "message": "Fixed typo", "committedDate": "2020-07-25T18:22:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyODIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460728216", "bodyText": "labels are missing here, for example producer, consumer, common ..etc", "author": "omarsmak", "createdAt": "2020-07-27T08:29:11Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..93afa8e2874 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n\n@@ -29,36 +29,35 @@ import org.apache.camel.spi.UriParams;\n @UriParams\n public class MinioConfiguration implements Cloneable {\n \n-    @UriParam\n+    @UriParam(label = \"common\")\n     private String endpoint;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private Integer proxyPort;\n+    @UriParam(label = \"common\")\n+    private boolean secure;\n+    @UriParam(label = \"common\")\n+    private String region;\n+    @UriParam(label = \"common\")\n+    private OkHttpClient customHttpClient;\n \n     @UriParam(label = \"security\", secret = true)\n     private String accessKey;\n     @UriParam(label = \"security\", secret = true)\n     private String secretKey;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean secure;\n-\n-    @UriParam\n-    private String region;\n-\n-    @UriParam\n-    private OkHttpClient customHttpClient;\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n \n     private String bucketName;\n-    @UriParam(defaultValue = \"true\")\n+    @UriParam(label = \"common\", defaultValue = \"true\")\n     private boolean autoCreateBucket = true;\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n     private boolean objectLock;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n+    private String policy;\n+    @UriParam(label = \"common\")\n     private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private ServerSideEncryption serverSideEncryption;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n     @UriParam(label = \"consumer\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDcyOTQyOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460729429", "bodyText": "Please avoid wildcard import", "author": "omarsmak", "createdAt": "2020-07-27T08:31:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,8 +16,15 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n \n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731257", "bodyText": "Should we handle this exception as well?", "author": "omarsmak", "createdAt": "2020-07-27T08:34:15Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODI0Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088247", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().removeObject(removeObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2OTIxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464269216", "bodyText": "What I mean here, does it make sense to handle it through  getExceptionHandler().handleException", "author": "omarsmak", "createdAt": "2020-08-03T08:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYxNDAyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464614021", "bodyText": "Hi, @omarsmak I was mimicking this line. should I keep this or change it to maybe LOG.warn?", "author": "Nayananga", "createdAt": "2020-08-03T19:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDg4NjIxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464886215", "bodyText": "@Nayananga my question is about catching Exception e, do you need your consumer to ignore all exceptions (as the case now) or you need your consumer to throw  and halt camel process in case minio client throw any exceptions other than MinioException? My gut feeling, you may just need to remove catch (Exception e) block and only handle MinioException as you are currently doing, by that camel will halt its process in any unexpected process.", "author": "omarsmak", "createdAt": "2020-08-04T08:27:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNTU3OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466215578", "bodyText": "Hi @omarsmak, thank you for your suggestion. I did some changes :)", "author": "Nayananga", "createdAt": "2020-08-06T07:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTI1Nw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,8 +16,15 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n \n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460731754", "bodyText": "Same here, should handle this exception as well?", "author": "omarsmak", "createdAt": "2020-07-27T08:35:06Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {\n+            getObjectRequest.matchETag(getConfiguration().getMatchETag());\n+        }\n+        if (getConfiguration().getNotMatchETag() != null) {\n+            getObjectRequest.notMatchETag(getConfiguration().getNotMatchETag());\n+        }\n+        if (getConfiguration().getModifiedSince() != null) {\n+            getObjectRequest.modifiedSince(getConfiguration().getModifiedSince());\n+        }\n+        if (getConfiguration().getUnModifiedSince() != null) {\n+            getObjectRequest.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+        }\n+\n+        return minioClient.getObject(getObjectRequest.build());\n+    }\n+\n+    @Override\n+    public int processBatch(Queue<Object> exchanges) {\n+        int total = exchanges.size();\n+\n+        for (int index = 0; index < total && isBatchAllowed(); index++) {\n+            // only loop if we are started (allowed to run)\n+            final Exchange exchange = ObjectHelper.cast(Exchange.class, exchanges.poll());\n+            // add current index and total as properties\n+            exchange.setProperty(Exchange.BATCH_INDEX, index);\n+            exchange.setProperty(Exchange.BATCH_SIZE, total);\n+            exchange.setProperty(Exchange.BATCH_COMPLETE, index == total - 1);\n+\n+            // update pending number of exchanges\n+            pendingExchanges = total - index - 1;\n+\n+            // add on completion to handle after work when the exchange is done\n+            exchange.adapt(ExtendedExchange.class).addOnCompletion(new Synchronization() {\n+                public void onComplete(Exchange exchange) {\n+                    processCommit(exchange);\n+                }\n+\n+                public void onFailure(Exchange exchange) {\n+                    processRollback(exchange);\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return \"MinioConsumerOnCompletion\";\n+                }\n+            });\n+\n+            LOG.trace(\"Processing exchange ...\");\n+            getAsyncProcessor().process(exchange, doneSync -> LOG.trace(\"Processing exchange done.\"));\n+        }\n+\n+        return total;\n+    }\n+\n+    /**\n+     * Strategy to delete the message after being processed.\n+     *\n+     * @param exchange the exchange\n+     */\n+    protected void processCommit(Exchange exchange) {\n+        try {\n+            String srcBucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+            String srcObjectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+\n+            if (getConfiguration().isDeleteAfterRead() || getConfiguration().isMoveAfterRead()) {\n+                if (getConfiguration().isMoveAfterRead()) {\n+                    copyObject(srcBucketName, srcObjectName);\n+                    LOG.trace(\"Copied object from bucket {} with objectName {} to bucket {}...\",\n+                            srcBucketName, srcObjectName, getConfiguration().getDestinationBucketName());\n+                }\n+\n+                LOG.trace(\"Deleting object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+\n+                RemoveObjectArgs.Builder removeObjectRequest = RemoveObjectArgs.builder()\n+                        .bucket(srcBucketName)\n+                        .object(srcObjectName)\n+                        .bypassGovernanceMode(getConfiguration().isBypassGovernanceMode());\n+\n+                if (getConfiguration().getVersionId() != null) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                if (getConfiguration().isBypassGovernanceMode()) {\n+                    removeObjectRequest.versionId(getConfiguration().getVersionId());\n+                }\n+                getMinioClient().removeObject(removeObjectRequest.build());\n+\n+                LOG.trace(\"Deleted object from bucket {} with objectName {}...\", srcBucketName, srcObjectName);\n+            }\n+        } catch (MinioException e) {\n+            getExceptionHandler().handleException(\"Error occurred during moving or deleting object. This exception is ignored.\",\n+                    exchange, e);\n+        } catch (Exception e) {\n+            LOG.trace(\"Error process commit...\");\n+        }\n+    }\n+\n+    private void copyObject(String srcBucketName, String srcObjectName) {\n+        String destinationBucketName = getConfiguration().getDestinationBucketName();\n+        if (destinationBucketName == null) {\n+            throw new IllegalArgumentException(\"Destination Bucket name must be specified to copy operation\");\n+        }\n+\n+        try {\n+            // set destination object name as source object name, if not specified\n+            String destinationObjectName = (getConfiguration().getDestinationObjectName() != null)\n+                    ? getConfiguration().getDestinationObjectName()\n+                    : srcObjectName;\n+\n+\n+            LOG.trace(\"Copying object from bucket {} with objectName {} to bucket {}...\",\n+                    srcBucketName, srcObjectName, destinationBucketName);\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder().bucket(srcBucketName).object(srcObjectName);\n+            if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+                copySourceBuilder.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+            }\n+            if (getConfiguration().getOffset() != 0) {\n+                copySourceBuilder.offset(getConfiguration().getOffset());\n+            }\n+            if (getConfiguration().getLength() != 0) {\n+                copySourceBuilder.length(getConfiguration().getLength());\n+            }\n+            if (getConfiguration().getVersionId() != null) {\n+                copySourceBuilder.versionId(getConfiguration().getVersionId());\n+            }\n+            if (getConfiguration().getMatchETag() != null) {\n+                copySourceBuilder.matchETag(getConfiguration().getMatchETag());\n+            }\n+            if (getConfiguration().getNotMatchETag() != null) {\n+                copySourceBuilder.notMatchETag(getConfiguration().getNotMatchETag());\n+            }\n+            if (getConfiguration().getModifiedSince() != null) {\n+                copySourceBuilder.modifiedSince(getConfiguration().getModifiedSince());\n+            }\n+            if (getConfiguration().getUnModifiedSince() != null) {\n+                copySourceBuilder.unmodifiedSince(getConfiguration().getUnModifiedSince());\n+            }\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .source(copySourceBuilder.build())\n+                    .bucket(getConfiguration().getDestinationBucketName())\n+                    .object(destinationObjectName);\n+\n+            if (getConfiguration().getServerSideEncryption() != null) {\n+                copyObjectRequest.sse(getConfiguration().getServerSideEncryption());\n+            }\n+\n+            getMinioClient().copyObject(copyObjectRequest.build());\n+\n+        } catch (Exception e) {\n+            LOG.warn(\"Error copy object from bucket {} with objectName {} to bucket {}...\",", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA4ODM1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464088357", "bodyText": "Hi @omarsmak this has to handle since getMinioClient().copyObject(copyObjectRequest.build()); throws an error", "author": "Nayananga", "createdAt": "2020-08-02T15:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMDUyMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464620523", "bodyText": "I'll remove this error handle since this is redundant", "author": "Nayananga", "createdAt": "2020-08-03T19:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDczMTc1NA=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,8 +16,15 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n \n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0MDMyMQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460740321", "bodyText": "I am bit not comfortable of having check with not equal 0, odd cases like minus could slip. I'd recommend changing this to > 0 instead. Same for the other checks", "author": "omarsmak", "createdAt": "2020-07-27T08:49:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,8 +16,15 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n \n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc0Nzk0OA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460747948", "bodyText": "Perhaps we can use isNotEmpty from org.apache.camel.util.ObjectHelper to check for nulls or emptyness", "author": "omarsmak", "createdAt": "2020-07-27T09:01:43Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.InputStream;\n+import java.util.*;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.errors.MinioException;\n+import io.minio.messages.Contents;\n+import io.minio.messages.ListBucketResultV2;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Processor;\n+import org.apache.camel.spi.Synchronization;\n+import org.apache.camel.support.ScheduledBatchPollingConsumer;\n+import org.apache.camel.util.CastUtils;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Consumer of messages from the Minio Storage Service.\n+ */\n+public class MinioConsumer extends ScheduledBatchPollingConsumer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioConsumer.class);\n+\n+    private String continuationToken;\n+    private transient String minioConsumerToString;\n+\n+    public MinioConsumer(MinioEndpoint endpoint, Processor processor) {\n+        super(endpoint, processor);\n+    }\n+\n+    @Override\n+    protected int poll() throws Exception {\n+        // must reset for each poll\n+        shutdownRunningTask = null;\n+        pendingExchanges = 0;\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        String objectName = getConfiguration().getObjectName();\n+        MinioClient minioClient = getMinioClient();\n+        Queue<Exchange> exchanges;\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Getting object in bucket {} with object name {}...\", bucketName, objectName);\n+\n+            InputStream minioObject = getObject(bucketName, minioClient, objectName);\n+            exchanges = createExchanges(minioObject, objectName);\n+\n+        } else {\n+\n+            LOG.trace(\"Queueing objects in bucket [{}]...\", bucketName);\n+\n+            ListObjectsArgs.Builder listObjectRequest = ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .includeUserMetadata(getConfiguration().isIncludeUserMetadata())\n+                    .includeVersions(getConfiguration().isIncludeVersions())\n+                    .recursive(getConfiguration().isRecursive())\n+                    .useApiVersion1(getConfiguration().isUseVersion1());\n+\n+            if (getConfiguration().getDelimiter() != null) {\n+                listObjectRequest.delimiter(getConfiguration().getDelimiter());\n+            }\n+\n+            if (maxMessagesPerPoll > 0) {\n+                listObjectRequest.maxKeys(maxMessagesPerPoll);\n+            }\n+\n+            if (getConfiguration().getPrefix() != null) {\n+                listObjectRequest.prefix(getConfiguration().getPrefix());\n+            }\n+\n+            if (getConfiguration().getStartAfter() != null) {\n+                listObjectRequest.startAfter(getConfiguration().getStartAfter());\n+            }\n+\n+            // if there was a marker from previous poll then use that to\n+            // continue from where we left last time\n+            if (continuationToken != null) {\n+                LOG.trace(\"Resuming from marker: {}\", continuationToken);\n+                listObjectRequest.continuationToken(continuationToken);\n+            }\n+\n+            // TODO: Check for validity of the statement\n+            ListBucketResultV2 listObjects = (ListBucketResultV2) getMinioClient().listObjects(listObjectRequest.build());\n+\n+            if (listObjects.isTruncated()) {\n+                LOG.trace(\"Returned list is truncated, so setting next marker: {}\", continuationToken);\n+                continuationToken = listObjects.nextContinuationToken();\n+\n+            } else {\n+                // no more data so clear marker\n+                continuationToken = null;\n+            }\n+            if (LOG.isTraceEnabled()) {\n+                LOG.trace(\"Found {} objects in bucket [{}]...\", listObjects.contents().size(), bucketName);\n+            }\n+\n+            exchanges = createExchanges(listObjects.contents());\n+        }\n+        return processBatch(CastUtils.cast(exchanges));\n+    }\n+\n+    protected Queue<Exchange> createExchanges(InputStream objectStream, String objectName) throws Exception {\n+        Queue<Exchange> answer = new LinkedList<>();\n+        Exchange exchange = getEndpoint().createExchange(objectStream, objectName);\n+        answer.add(exchange);\n+        IOHelper.close(objectStream);\n+        return answer;\n+    }\n+\n+    protected Queue<Exchange> createExchanges(List<Contents> minioObjectSummaries) throws Exception {\n+        if (LOG.isTraceEnabled()) {\n+            LOG.trace(\"Received {} messages in this poll\", minioObjectSummaries.size());\n+        }\n+        String bucketName = getConfiguration().getBucketName();\n+        Collection<InputStream> minioObjects = new ArrayList<>();\n+        Queue<Exchange> answer = new LinkedList<>();\n+        try {\n+            if (getConfiguration().isIncludeFolders()) {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                    minioObjects.add(minioObject);\n+                    Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                    answer.add(exchange);\n+                }\n+            } else {\n+                for (Contents minioObjectSummary : minioObjectSummaries) {\n+                    // ignore if directory\n+                    if (!minioObjectSummary.isDir()) {\n+                        InputStream minioObject = getObject(bucketName, getMinioClient(), minioObjectSummary.objectName());\n+                        minioObjects.add(minioObject);\n+                        Exchange exchange = getEndpoint().createExchange(minioObject, minioObjectSummary.objectName());\n+                        answer.add(exchange);\n+                    }\n+                }\n+            }\n+\n+        } catch (Throwable e) {\n+            LOG.warn(\"Error getting MinioObject due: {}\", e.getMessage());\n+            throw e;\n+\n+        } finally {\n+            // ensure all previous gathered minio objects are closed\n+            // if there was an exception creating the exchanges in this batch\n+            minioObjects.forEach(IOHelper::close);\n+        }\n+\n+        return answer;\n+    }\n+\n+    private InputStream getObject(String bucketName, MinioClient minioClient, String objectName) throws Exception {\n+        GetObjectArgs.Builder getObjectRequest = GetObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            getObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {\n+            getObjectRequest.offset(getConfiguration().getOffset());\n+        }\n+        if (getConfiguration().getLength() != 0) {\n+            getObjectRequest.length(getConfiguration().getLength());\n+        }\n+        if (getConfiguration().getVersionId() != null) {\n+            getObjectRequest.versionId(getConfiguration().getVersionId());\n+        }\n+        if (getConfiguration().getMatchETag() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\nindex 7536f78ba70..686af10f67f 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConsumer.java\n\n@@ -16,8 +16,15 @@\n  */\n package org.apache.camel.component.minio;\n \n+import java.io.IOException;\n import java.io.InputStream;\n-import java.util.*;\n+import java.security.InvalidKeyException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Queue;\n \n import io.minio.CopyObjectArgs;\n import io.minio.CopySource;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MDQxMw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460750413", "bodyText": "I don't see any reason to null the client here, isn't?", "author": "omarsmak", "createdAt": "2020-07-27T09:06:05Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n\n@@ -16,8 +16,11 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n-import java.nio.charset.Charset;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.StandardCharsets;\n \n import io.minio.BucketExistsArgs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1MTMxNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460751316", "bodyText": "please don't print the stack trace here, instead handle the exception.", "author": "omarsmak", "createdAt": "2020-07-27T09:07:49Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n\n@@ -16,8 +16,11 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n-import java.nio.charset.Charset;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.StandardCharsets;\n \n import io.minio.BucketExistsArgs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NDgyNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460754824", "bodyText": "versionId is not used here", "author": "omarsmak", "createdAt": "2020-07-27T09:14:04Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n\n@@ -16,7 +16,12 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1NjczMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460756730", "bodyText": "isNotEmpty as I mentioned earlier would make more sense here", "author": "omarsmak", "createdAt": "2020-07-27T09:17:20Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n\n@@ -16,7 +16,12 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1Nzg3Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460757877", "bodyText": "this check here is not needed. ObjectHelper.isEmpty(bucketName) will check if string is empty or null", "author": "omarsmak", "createdAt": "2020-07-27T09:19:21Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n\n@@ -16,7 +16,12 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460759163", "bodyText": "why is it 1024 bits here? Can you please move this into constant and with some comment why you opted for 1024bits?", "author": "omarsmak", "createdAt": "2020-07-27T09:21:29Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java", "diffHunk": "@@ -0,0 +1,494 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.ListObjectsArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectWriteResponse;\n+import io.minio.PutObjectArgs;\n+import io.minio.RemoveBucketArgs;\n+import io.minio.RemoveObjectArgs;\n+import io.minio.RemoveObjectsArgs;\n+import io.minio.Result;\n+import io.minio.messages.Bucket;\n+import io.minio.messages.Item;\n+import org.apache.camel.Endpoint;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.InvalidPayloadException;\n+import org.apache.camel.Message;\n+import org.apache.camel.WrappedFile;\n+import org.apache.camel.support.DefaultProducer;\n+import org.apache.camel.util.FileUtil;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.apache.camel.util.URISupport;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A Producer which sends messages to the Minio Simple Storage\n+ */\n+public class MinioProducer extends DefaultProducer {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioProducer.class);\n+\n+    private transient String minioProducerToString;\n+\n+    public MinioProducer(final Endpoint endpoint) {\n+        super(endpoint);\n+    }\n+\n+    public static Message getMessageForResponse(final Exchange exchange) {\n+        return exchange.getMessage();\n+    }\n+\n+    @Override\n+    public void process(final Exchange exchange) throws Exception {\n+        MinioOperations operation = determineOperation(exchange);\n+        MinioClient minioClient = getEndpoint().getMinioClient();\n+        if (ObjectHelper.isEmpty(operation)) {\n+            putObject(minioClient, exchange);\n+        } else {\n+            switch (operation) {\n+                case copyObject:\n+                    copyObject(minioClient, exchange);\n+                    break;\n+                case deleteObject:\n+                    deleteObject(minioClient, exchange);\n+                    break;\n+                case deleteObjects:\n+                    deleteObjects(minioClient, exchange);\n+                    break;\n+                case listBuckets:\n+                    listBuckets(minioClient, exchange);\n+                    break;\n+                case deleteBucket:\n+                    deleteBucket(minioClient, exchange);\n+                    break;\n+                case listObjects:\n+                    listObjects(minioClient, exchange);\n+                    break;\n+                case getObject:\n+                    getObject(minioClient, exchange);\n+                    break;\n+                case getPartialObject:\n+                    getPartialObject(minioClient, exchange);\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported operation\");\n+            }\n+        }\n+    }\n+\n+    public void putObject(MinioClient minioClient, final Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            PutObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(PutObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse putObjectResult = minioClient.putObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+                if (putObjectResult.versionId() != null) {\n+                    message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+                }\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String objectName = determineObjectName(exchange);\n+            Map<String, String> objectMetadata = determineMetadata(exchange);\n+            Map<String, String> extraHeaders = determineExtraHeaders(exchange);\n+\n+            File filePayload = null;\n+            InputStream inputStream;\n+            ByteArrayOutputStream baos;\n+            Object object = exchange.getIn().getMandatoryBody();\n+\n+            // Need to check if the message body is WrappedFile\n+            if (object instanceof WrappedFile) {\n+                object = ((WrappedFile<?>) object).getFile();\n+            }\n+            if (object instanceof File) {\n+                filePayload = (File) object;\n+                inputStream = new FileInputStream(filePayload);\n+            } else {\n+                inputStream = exchange.getIn().getMandatoryBody(InputStream.class);\n+                if (objectMetadata.containsKey(Exchange.CONTENT_LENGTH)) {\n+                    if (objectMetadata.get(\"Content-Length\").equals(\"0\") && ObjectHelper.isEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                        LOG.debug(\"The content length is not defined. It needs to be determined by reading the data into memory\");\n+                        baos = determineLengthInputStream(inputStream);\n+                        objectMetadata.put(\"Content-Length\", String.valueOf(baos.size()));\n+                        inputStream = new ByteArrayInputStream(baos.toByteArray());\n+                    } else {\n+                        if (ObjectHelper.isNotEmpty(exchange.getProperty(Exchange.CONTENT_LENGTH))) {\n+                            objectMetadata.put(\"Content-Length\", exchange.getProperty(Exchange.CONTENT_LENGTH, String.class));\n+                        }\n+                    }\n+                }\n+            }\n+            PutObjectArgs.Builder putObjectRequest = PutObjectArgs.builder()\n+                    .stream(inputStream, inputStream.available(), -1)\n+                    .bucket(bucketName)\n+                    .object(objectName)\n+                    .userMetadata(objectMetadata);\n+\n+            if (!extraHeaders.isEmpty()) {\n+                putObjectRequest.extraHeaders(extraHeaders);\n+            }\n+\n+            LOG.trace(\"Put object from exchange...\");\n+\n+            ObjectWriteResponse putObjectResult = getEndpoint().getMinioClient().putObject(putObjectRequest.build());\n+\n+            LOG.trace(\"Received result...\");\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setHeader(MinioConstants.E_TAG, putObjectResult.etag());\n+            if (putObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, putObjectResult.versionId());\n+            }\n+\n+            IOHelper.close(inputStream);\n+\n+            if (getConfiguration().isDeleteAfterWrite() && filePayload != null) {\n+                FileUtil.deleteFile(filePayload);\n+            }\n+        }\n+    }\n+\n+    private Map<String, String> determineExtraHeaders(Exchange exchange) {\n+        Map<String, String> extraHeaders = new HashMap<>();\n+        String storageClass = determineStorageClass(exchange);\n+        if (storageClass != null) {\n+            extraHeaders.put(\"X-Amz-Storage-Class\", storageClass);\n+        }\n+\n+        String cannedAcl = exchange.getIn().getHeader(MinioConstants.CANNED_ACL, String.class);\n+        if (cannedAcl != null) {\n+            extraHeaders.put(\"x-amz-acl\", cannedAcl);\n+        }\n+\n+        return extraHeaders;\n+    }\n+\n+    private void copyObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            CopyObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(CopyObjectArgs.Builder.class);\n+            if (payload != null) {\n+                ObjectWriteResponse result = minioClient.copyObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(result);\n+            }\n+        } else {\n+\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String destinationKey = exchange.getIn().getHeader(MinioConstants.DESTINATION_OBJECT_NAME, String.class);\n+            final String destinationBucketName = exchange.getIn().getHeader(MinioConstants.DESTINATION_BUCKET_NAME, String.class);\n+\n+            if (ObjectHelper.isEmpty(destinationBucketName)) {\n+                throw new IllegalArgumentException(\"Bucket Name Destination must be specified for copyObject Operation\");\n+            }\n+            if (ObjectHelper.isEmpty(destinationKey)) {\n+                throw new IllegalArgumentException(\"Destination Key must be specified for copyObject Operation\");\n+            }\n+\n+            CopySource.Builder copySourceBuilder = CopySource.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey);\n+\n+            CopyObjectArgs.Builder copyObjectRequest = CopyObjectArgs.builder()\n+                    .bucket(destinationBucketName)\n+                    .object(destinationKey)\n+                    .source(copySourceBuilder.build());\n+\n+            ObjectWriteResponse copyObjectResult = minioClient.copyObject(copyObjectRequest.build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            if (copyObjectResult.versionId() != null) {\n+                message.setHeader(MinioConstants.VERSION_ID, copyObjectResult.versionId());\n+            }\n+        }\n+    }\n+\n+    private void deleteObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+        final String sourceKey = determineObjectName(exchange);\n+        final String versionId = determineVersionId(exchange);\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+\n+            minioClient.removeObject(RemoveObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey).build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(true);\n+        }\n+    }\n+\n+    private void deleteObjects(MinioClient minioClient, Exchange exchange) throws Exception {\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(true);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot delete multiple objects without a POJO request\");\n+        }\n+    }\n+\n+    private void listBuckets(MinioClient minioClient, Exchange exchange) throws Exception {\n+        List<Bucket> bucketsList = minioClient.listBuckets();\n+        Message message = getMessageForResponse(exchange);\n+        //returns iterator of bucketList\n+        message.setBody(bucketsList.iterator());\n+    }\n+\n+    private void deleteBucket(MinioClient minioClient, Exchange exchange) throws Exception {\n+        final String bucketName = determineBucketName(exchange);\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            RemoveBucketArgs.Builder payload = exchange.getIn().getMandatoryBody(RemoveBucketArgs.Builder.class);\n+            if (payload != null) {\n+                minioClient.removeBucket(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(\"ok\");\n+            }\n+        } else {\n+\n+            minioClient.removeBucket(RemoveBucketArgs.builder().bucket(bucketName).build());\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(\"ok\");\n+        }\n+    }\n+\n+    private void getObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void getPartialObject(MinioClient minioClient, Exchange exchange) throws Exception {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            GetObjectArgs.Builder payload = exchange.getIn().getMandatoryBody(GetObjectArgs.Builder.class);\n+            if (payload != null) {\n+                InputStream respond = minioClient.getObject(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(respond);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+            final String sourceKey = determineObjectName(exchange);\n+            final String offset = exchange.getIn().getHeader(MinioConstants.OFFSET, String.class);\n+            final String length = exchange.getIn().getHeader(MinioConstants.LENGTH, String.class);\n+\n+            if (ObjectHelper.isEmpty(offset) || ObjectHelper.isEmpty(length)) {\n+                throw new IllegalArgumentException(\"A Offset and length header must be configured to perform a partial get operation.\");\n+            }\n+\n+            InputStream respond = minioClient.getObject(GetObjectArgs.builder()\n+                    .bucket(bucketName)\n+                    .object(sourceKey)\n+                    .offset(Long.parseLong(offset))\n+                    .length(Long.parseLong(length))\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(respond);\n+        }\n+    }\n+\n+    private void listObjects(MinioClient minioClient, Exchange exchange) throws InvalidPayloadException {\n+\n+        if (getConfiguration().isPojoRequest()) {\n+            ListObjectsArgs.Builder payload = exchange.getIn().getMandatoryBody(ListObjectsArgs.Builder.class);\n+            if (payload != null) {\n+                Iterable<Result<Item>> objectList = minioClient.listObjects(payload.build());\n+                Message message = getMessageForResponse(exchange);\n+                message.setBody(objectList);\n+            }\n+        } else {\n+            final String bucketName = determineBucketName(exchange);\n+\n+            Iterable<Result<Item>> objectList = minioClient.listObjects(ListObjectsArgs.builder()\n+                    .bucket(bucketName)\n+                    .recursive(getConfiguration().isRecursive())\n+                    .build());\n+\n+            Message message = getMessageForResponse(exchange);\n+            message.setBody(objectList);\n+        }\n+    }\n+\n+    private MinioOperations determineOperation(Exchange exchange) {\n+        MinioOperations operation = exchange.getIn().getHeader(MinioConstants.MINIO_OPERATION, MinioOperations.class);\n+        if (operation == null) {\n+            operation = getConfiguration().getOperation();\n+        }\n+        return operation;\n+    }\n+\n+    private Map<String, String> determineMetadata(final Exchange exchange) {\n+        Map<String, String> objectMetadata = new HashMap<>();\n+\n+        Long contentLength = exchange.getIn().getHeader(MinioConstants.CONTENT_LENGTH, Long.class);\n+        if (contentLength != null) {\n+            objectMetadata.put(\"Content-Length\", String.valueOf(contentLength));\n+        }\n+\n+        String contentType = exchange.getIn().getHeader(MinioConstants.CONTENT_TYPE, String.class);\n+        if (contentType != null) {\n+            objectMetadata.put(\"Content-Type\", contentType);\n+        }\n+\n+        String cacheControl = exchange.getIn().getHeader(MinioConstants.CACHE_CONTROL, String.class);\n+        if (cacheControl != null) {\n+            objectMetadata.put(\"Cache-Control\", cacheControl);\n+        }\n+\n+        String contentDisposition = exchange.getIn().getHeader(MinioConstants.CONTENT_DISPOSITION, String.class);\n+        if (contentDisposition != null) {\n+            objectMetadata.put(\"Content-Disposition\", contentDisposition);\n+        }\n+\n+        String contentEncoding = exchange.getIn().getHeader(MinioConstants.CONTENT_ENCODING, String.class);\n+        if (contentEncoding != null) {\n+            objectMetadata.put(\"Content-Encoding\", contentEncoding);\n+        }\n+\n+        String contentMD5 = exchange.getIn().getHeader(MinioConstants.CONTENT_MD5, String.class);\n+        if (contentMD5 != null) {\n+            objectMetadata.put(\"Content-Md5\", contentMD5);\n+        }\n+\n+        return objectMetadata;\n+    }\n+\n+    /**\n+     * Reads the bucket name from the header of the given exchange. If not\n+     * provided, it's read from the endpoint configuration.\n+     *\n+     * @param exchange The exchange to read the header from.\n+     * @return The bucket name.\n+     * @throws IllegalArgumentException if the header could not be determined.\n+     */\n+    private String determineBucketName(final Exchange exchange) {\n+        String bucketName = exchange.getIn().getHeader(MinioConstants.BUCKET_NAME, String.class);\n+\n+        if (ObjectHelper.isEmpty(bucketName)) {\n+            bucketName = getConfiguration().getBucketName();\n+            LOG.trace(\"Minio Bucket name header is missing, using default one [{}]\", bucketName);\n+        }\n+\n+        if (bucketName == null) {\n+            throw new IllegalArgumentException(\"Minio Bucket name header is missing or not configured.\");\n+        }\n+\n+        return bucketName;\n+    }\n+\n+    private String determineObjectName(final Exchange exchange) {\n+        String objectName = exchange.getIn().getHeader(MinioConstants.OBJECT_NAME, String.class);\n+        if (ObjectHelper.isEmpty(objectName)) {\n+            objectName = getConfiguration().getKeyName();\n+        }\n+        if (objectName == null) {\n+            throw new IllegalArgumentException(\"Minio Key header is missing.\");\n+        }\n+        return objectName;\n+    }\n+\n+    private String determineStorageClass(final Exchange exchange) {\n+        String storageClass = exchange.getIn().getHeader(MinioConstants.STORAGE_CLASS, String.class);\n+        if (storageClass == null) {\n+            storageClass = getConfiguration().getStorageClass();\n+        }\n+\n+        return storageClass;\n+    }\n+\n+    private String determineVersionId(final Exchange exchange) {\n+        String versionId = exchange.getIn().getHeader(MinioConstants.VERSION_ID, String.class);\n+        if (versionId == null) {\n+            versionId = getConfiguration().getVersionId();\n+        }\n+\n+        return versionId;\n+    }\n+\n+    private ByteArrayOutputStream determineLengthInputStream(InputStream inputStream) throws IOException {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        byte[] bytes = new byte[1024];", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113257", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMzI5NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464113295", "bodyText": "Hi @omarsmak, I was actually mimicking this line. I will put this as a constant in MinioConstants.java", "author": "Nayananga", "createdAt": "2020-08-02T19:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc1OTE2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\nindex 79c80ab4cae..6be64b509d8 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioProducer.java\n\n@@ -16,7 +16,12 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NTMwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460765307", "bodyText": "This class name is weird for the client impl. If this the remote client from the factory, something like MinioRemoteClientImpl would make more sense", "author": "omarsmak", "createdAt": "2020-07-27T09:32:02Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nsimilarity index 78%\nrename from components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nindex 6cb96368b45..387b4409420 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\n\n@@ -21,18 +21,20 @@ import org.apache.camel.component.minio.MinioConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * Creates MinIO client object according to the\n  * given endpoint, port, access key, secret key, region and secure option.\n  */\n-public class GetMinioClient implements MinioCamelInternalClient {\n-    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+public class MinioRemoteClientImpl implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioRemoteClientImpl.class);\n     private final MinioConfiguration configuration;\n \n     /**\n      * Constructor that uses the config file.\n      */\n-    public GetMinioClient(MinioConfiguration configuration) {\n+    public MinioRemoteClientImpl(MinioConfiguration configuration) {\n         LOG.trace(\"Creating an Minio client.\");\n         this.configuration = configuration;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766063", "bodyText": "I wonder accessKeys, same as region are not required?", "author": "omarsmak", "createdAt": "2020-07-27T09:33:28Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.client;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.component.minio.MinioConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Creates MinIO client object according to the\n+ * given endpoint, port, access key, secret key, region and secure option.\n+ */\n+public class GetMinioClient implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+    private final MinioConfiguration configuration;\n+\n+    /**\n+     * Constructor that uses the config file.\n+     */\n+    public GetMinioClient(MinioConfiguration configuration) {\n+        LOG.trace(\"Creating an Minio client.\");\n+        this.configuration = configuration;\n+    }\n+\n+    /**\n+     * Getting the minio client.\n+     *\n+     * @return Minio Client.\n+     */\n+    @Override\n+    public MinioClient getMinioClient() {\n+        if (configuration.getEndpoint() != null) {\n+            MinioClient.Builder minioClientRequest = MinioClient.builder();\n+\n+            if (configuration.getProxyPort() != null) {\n+                minioClientRequest.endpoint(configuration.getEndpoint(), configuration.getProxyPort(), configuration.isSecure());\n+            } else {\n+                minioClientRequest.endpoint(configuration.getEndpoint());\n+            }\n+            if (configuration.getAccessKey() != null && configuration.getSecretKey() != null) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEwMDMyMA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464100320", "bodyText": "Hi @omarsmak sorry, I didn't get this question?", "author": "Nayananga", "createdAt": "2020-08-02T17:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MDYwNw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464270607", "bodyText": "What I mean here, are the accessKey, secretKey and region are required in order to initiate the client? What happens if one of these is null or not set?", "author": "omarsmak", "createdAt": "2020-08-03T08:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDYyMzg2NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464623864", "bodyText": "@omarsmak, As per Java Client API Reference you can create MinioClient with or without accessKey, secretKey (namely anonymous access) or region.", "author": "Nayananga", "createdAt": "2020-08-03T19:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIxNjIwNA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466216204", "bodyText": "@omarsmak is it okay to mark this as resolved?", "author": "Nayananga", "createdAt": "2020-08-06T07:56:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjA2Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nsimilarity index 78%\nrename from components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\nrename to components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\nindex 6cb96368b45..387b4409420 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/GetMinioClient.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/client/MinioRemoteClientImpl.java\n\n@@ -21,18 +21,20 @@ import org.apache.camel.component.minio.MinioConfiguration;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * Creates MinIO client object according to the\n  * given endpoint, port, access key, secret key, region and secure option.\n  */\n-public class GetMinioClient implements MinioCamelInternalClient {\n-    private static final Logger LOG = LoggerFactory.getLogger(GetMinioClient.class);\n+public class MinioRemoteClientImpl implements MinioCamelInternalClient {\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioRemoteClientImpl.class);\n     private final MinioConfiguration configuration;\n \n     /**\n      * Constructor that uses the config file.\n      */\n-    public GetMinioClient(MinioConfiguration configuration) {\n+    public MinioRemoteClientImpl(MinioConfiguration configuration) {\n         LOG.trace(\"Creating an Minio client.\");\n         this.configuration = configuration;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc2NjU1Nw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460766557", "bodyText": "Please add more cases for region, secretKey .. etc", "author": "omarsmak", "createdAt": "2020-07-27T09:34:22Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class MinioComponentConfigurationTest extends CamelTestSupport {\n+\n+    @Test\n+    public void createEndpointWithMinimalConfiguration() throws Exception {\n+        MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n+        MinioEndpoint endpoint = (MinioEndpoint) component\n+                .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\nindex a30b0f5a702..056b1403c9c 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/MinioComponentConfigurationTest.java\n\n@@ -28,6 +28,10 @@ public class MinioComponentConfigurationTest extends CamelTestSupport {\n         MinioComponent component = context.getComponent(\"minio\", MinioComponent.class);\n         MinioEndpoint endpoint = (MinioEndpoint) component\n                 .createEndpoint(\"minio://TestDomain?accessKey=xxx&secretKey=yyy&region=us-west-1&endpoint=http://localhost:4572\");\n+        assertEquals(endpoint.getConfiguration().getBucketName(), \"TestDomain\");\n+        assertEquals(endpoint.getConfiguration().getAccessKey(), \"xxx\");\n+        assertEquals(endpoint.getConfiguration().getSecretKey(), \"yyy\");\n+        assertEquals(endpoint.getConfiguration().getRegion(), \"us-west-1\");\n         assertEquals(endpoint.getConfiguration().getEndpoint(), \"http://localhost:4572\");\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc3NTgzMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r460775832", "bodyText": "These checks are pretty redundant. Perhaps what we can do here, wrap these into centralized lambdas somewhere and just pass the function reference. Example:\nprivate void checkMatchTagConfig(final MinioConfiguration configuration, final java.util.function.Consumer<String> fn) {\n        if ( ObjectHelper.isNotEmpty(configuration.getMatchETag()) ) {\n            fn.accept(configuration.getMatchETag());\n        }\n    }\n\nAnd then somewhere in the code:\ncheckMatchTagConfig(getConfiguration(), statObjectRequest::matchETag);", "author": "omarsmak", "createdAt": "2020-07-27T09:50:46Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+            int c;\n+            while ((c = reader.read()) != -1) {\n+                textBuilder.append((char) c);\n+            }\n+        }\n+        return textBuilder.toString();\n+    }\n+\n+    private boolean bucketExists(String bucketName) throws Exception {\n+        return minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());\n+    }\n+\n+    private void makeBucket(String bucketName) throws Exception {\n+        MakeBucketArgs.Builder makeBucketRequest = MakeBucketArgs.builder().bucket(bucketName).objectLock(getConfiguration().isObjectLock());\n+        if (getConfiguration().getRegion() != null) {\n+            makeBucketRequest.region(getConfiguration().getRegion());\n+        }\n+        minioClient.makeBucket(makeBucketRequest.build());\n+    }\n+\n+    private void setBucketPolicy(String bucketName) throws Exception {\n+        LOG.trace(\"Updating bucket {} with policy...\", bucketName);\n+        minioClient.setBucketPolicy(\n+                SetBucketPolicyArgs.builder().bucket(bucketName).config(getConfiguration().getPolicy()).build());\n+        LOG.trace(\"Bucket policy updated\");\n+    }\n+\n+    private void getObjectStat(String objectName, Message message) throws Exception {\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        StatObjectArgs.Builder statObjectRequest = StatObjectArgs.builder().bucket(bucketName).object(objectName);\n+\n+        if (getConfiguration().getServerSideEncryptionCustomerKey() != null) {\n+            statObjectRequest.ssec(getConfiguration().getServerSideEncryptionCustomerKey());\n+        }\n+        if (getConfiguration().getOffset() != 0) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n\n@@ -16,8 +16,11 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n-import java.nio.charset.Charset;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.StandardCharsets;\n \n import io.minio.BucketExistsArgs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463681735", "bodyText": "Not sure about this, might lead to NullPointerExceptions", "author": "zregvart", "createdAt": "2020-07-31T15:34:12Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4NDMzNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463684336", "bodyText": "No, this is fine, we are using similar approach for component with Extension for validation like this https://github.com/apache/camel/blob/master/components/camel-aws-s3/src/main/java/org/apache/camel/component/aws/s3/S3Component.java#L35", "author": "oscerd", "createdAt": "2020-07-31T15:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY4MTczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..16eec326a9d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n\n@@ -24,10 +24,12 @@ import org.apache.camel.CamelContext;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.annotations.Component;\n import org.apache.camel.support.DefaultComponent;\n-import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isEmpty;\n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * Represents the component that manages {@link MinioEndpoint}.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692222", "bodyText": "I would suggest to reformat it like this:\n    @Override\n    protected Result verifyParameters(Map<String, Object> parameters) {\n        ResultBuilder builder = ResultBuilder.withStatusAndScope(Result.Status.OK, Scope.PARAMETERS)\n                                             .error(ResultErrorHelper.requiresOption(\"accessKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"secretKey\", parameters))\n                                             .error(ResultErrorHelper.requiresOption(\"region\", parameters));\n\n        // Validate using the catalog\n        super.verifyParametersAgainstCatalog(builder, parameters);\n\n        return builder.build();\n    }", "author": "DenisIstomin", "createdAt": "2020-07-31T15:53:27Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+\n+import io.minio.MinioClient;\n+import io.minio.errors.MinioException;\n+import org.apache.camel.component.extension.verifier.DefaultComponentVerifierExtension;\n+import org.apache.camel.component.extension.verifier.ResultBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n+import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n+\n+public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n+\n+    public MinioComponentVerifierExtension() {\n+        this(\"minio\");\n+    }\n+\n+    public MinioComponentVerifierExtension(String scheme) {\n+        super(scheme);\n+    }\n+\n+    // *********************************\n+    // Parameters validation\n+    // *********************************\n+\n+    @Override", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5Mjg0NQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463692845", "bodyText": "And the same below", "author": "DenisIstomin", "createdAt": "2020-07-31T15:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5MjIyMg=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\nindex f4bf952a507..cc97d5ecf25 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponentVerifierExtension.java\n\n@@ -25,6 +25,9 @@ import org.apache.camel.component.extension.verifier.ResultBuilder;\n import org.apache.camel.component.extension.verifier.ResultErrorBuilder;\n import org.apache.camel.component.extension.verifier.ResultErrorHelper;\n \n+import static org.apache.camel.util.ObjectHelper.isEmpty;\n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n public class MinioComponentVerifierExtension extends DefaultComponentVerifierExtension {\n \n     public MinioComponentVerifierExtension() {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NDMwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463694308", "bodyText": "This is TODO comment?", "author": "DenisIstomin", "createdAt": "2020-07-31T15:57:10Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n\n@@ -16,8 +16,11 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n-import java.nio.charset.Charset;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.StandardCharsets;\n \n import io.minio.BucketExistsArgs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5NTYwOQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463695609", "bodyText": "Looks like it could be simplified:\nReader reader = new BufferedReader(new InputStreamReader(minioObject, StandardCharsets.UTF_8));", "author": "DenisIstomin", "createdAt": "2020-07-31T15:59:40Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+import io.minio.BucketExistsArgs;\n+import io.minio.MakeBucketArgs;\n+import io.minio.MinioClient;\n+import io.minio.ObjectStat;\n+import io.minio.SetBucketPolicyArgs;\n+import io.minio.StatObjectArgs;\n+import io.minio.errors.InvalidBucketNameException;\n+import org.apache.camel.Category;\n+import org.apache.camel.Component;\n+import org.apache.camel.Consumer;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.ExtendedExchange;\n+import org.apache.camel.Message;\n+import org.apache.camel.Processor;\n+import org.apache.camel.Producer;\n+import org.apache.camel.component.minio.client.MinioClientFactory;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.UriEndpoint;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriPath;\n+import org.apache.camel.support.ScheduledPollEndpoint;\n+import org.apache.camel.support.SynchronizationAdapter;\n+import org.apache.camel.util.IOHelper;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Store and retrieve objects from Minio Storage Service using Minio SDK.\n+ */\n+@UriEndpoint(firstVersion = \"3.5.0\", scheme = \"minio\", title = \"Minio Storage Service\", syntax = \"minio://bucketName\",\n+        category = {Category.CLOUD, Category.FILE})\n+\n+public class MinioEndpoint extends ScheduledPollEndpoint {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioEndpoint.class);\n+\n+    private MinioClient minioClient;\n+\n+    @UriPath(description = \"Bucket name\")\n+    @Metadata(required = true)\n+    private String bucketName; // to support component docs\n+    @UriParam\n+    private MinioConfiguration configuration;\n+    @UriParam(label = \"consumer\", defaultValue = \"10\")\n+    private int maxMessagesPerPoll = 10;\n+    @UriParam(label = \"consumer\", defaultValue = \"60\")\n+    private int maxConnections = 50 + maxMessagesPerPoll;\n+\n+    public MinioEndpoint(String uri, Component component, MinioConfiguration configuration) {\n+        super(uri, component);\n+        this.configuration = configuration;\n+    }\n+\n+    @Override\n+    public Consumer createConsumer(Processor processor) throws Exception {\n+        MinioConsumer minioConsumer = new MinioConsumer(this, processor);\n+        configureConsumer(minioConsumer);\n+        minioConsumer.setMaxMessagesPerPoll(maxMessagesPerPoll);\n+        return minioConsumer;\n+    }\n+\n+    @Override\n+    public Producer createProducer() {\n+        return new MinioProducer(this);\n+    }\n+\n+    @Override\n+    public void doStart() throws Exception {\n+        super.doStart();\n+\n+        minioClient = getConfiguration().getMinioClient() != null\n+                ? getConfiguration().getMinioClient()\n+                : MinioClientFactory.getClient(getConfiguration()).getMinioClient();\n+\n+        String objectName = getConfiguration().getObjectName();\n+\n+        if (objectName != null) {\n+            LOG.trace(\"Object name {} requested, so skipping bucket check...\", objectName);\n+            return;\n+        }\n+\n+        String bucketName = getConfiguration().getBucketName();\n+        LOG.trace(\"Querying whether bucket {} already exists...\", bucketName);\n+\n+        if (bucketExists(bucketName)) {\n+            LOG.trace(\"Bucket {} already exists\", bucketName);\n+        } else {\n+            if (!getConfiguration().isAutoCreateBucket()) {\n+                throw new InvalidBucketNameException(\"Bucket {} does not exists, set autoCreateBucket option for bucket auto creation\", bucketName);\n+            } else {\n+                LOG.trace(\"AutoCreateBucket set to true, Creating bucket {}...\", bucketName);\n+                makeBucket(bucketName);\n+                LOG.trace(\"Bucket created\");\n+            }\n+        }\n+\n+        if (getConfiguration().getPolicy() != null) {\n+            setBucketPolicy(bucketName);\n+        }\n+    }\n+\n+    @Override\n+    public void doStop() throws Exception {\n+        if (ObjectHelper.isEmpty(getConfiguration().getMinioClient())) {\n+            if (minioClient != null) {\n+                minioClient = null;\n+            }\n+        }\n+        super.doStop();\n+    }\n+\n+    public Exchange createExchange(InputStream minioObject, String objectName) throws Exception {\n+        return createExchange(getExchangePattern(), minioObject, objectName);\n+    }\n+\n+    public Exchange createExchange(ExchangePattern pattern,\n+                                   InputStream minioObject, String objectName) throws Exception {\n+        LOG.trace(\"Getting object with objectName {} from bucket {}...\", objectName, getConfiguration().getBucketName());\n+\n+        Exchange exchange = super.createExchange(pattern);\n+        Message message = exchange.getIn();\n+        LOG.trace(\"Got object!\");\n+\n+        getObjectStat(objectName, message);\n+\n+        if (getConfiguration().isIncludeBody()) {\n+            try {\n+                message.setBody(readInputStream(minioObject));\n+                if (getConfiguration().isAutocloseBody()) {\n+                    exchange.adapt(ExtendedExchange.class).addOnCompletion(new SynchronizationAdapter() {\n+                        @Override\n+                        public void onDone(Exchange exchange) {\n+                            IOHelper.close(minioObject);\n+                        }\n+                    });\n+                }\n+\n+            } catch (IOException e) {\n+                // TODO Auto-generated catch block\n+                e.printStackTrace();\n+            }\n+        } else {\n+            message.setBody(null);\n+            IOHelper.close(minioObject);\n+        }\n+\n+        return exchange;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    public MinioClient getMinioClient() {\n+        return minioClient;\n+    }\n+\n+    public void setMinioClient(MinioClient minioClient) {\n+        this.minioClient = minioClient;\n+    }\n+\n+    public int getMaxMessagesPerPoll() {\n+        return maxMessagesPerPoll;\n+    }\n+\n+    /**\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * <p/>\n+     * Gets the maximum number of messages as a limit to poll at each polling.\n+     * The default value is 10. Use 0 or a negative number to set it as\n+     * unlimited.\n+     */\n+    public void setMaxMessagesPerPoll(int maxMessagesPerPoll) {\n+        this.maxMessagesPerPoll = maxMessagesPerPoll;\n+    }\n+\n+    public int getMaxConnections() {\n+        return maxConnections;\n+    }\n+\n+    /**\n+     * Set the maxConnections parameter in the minio client configuration\n+     */\n+    public void setMaxConnections(int maxConnections) {\n+        this.maxConnections = maxConnections;\n+    }\n+\n+    private String readInputStream(InputStream minioObject) throws IOException {\n+        StringBuilder textBuilder = new StringBuilder();\n+        try (Reader reader = new BufferedReader(new InputStreamReader(minioObject, Charset.forName(StandardCharsets.UTF_8.name())))) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\nindex 9ad67ad3573..0f75734b972 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioEndpoint.java\n\n@@ -16,8 +16,11 @@\n  */\n package org.apache.camel.component.minio;\n \n-import java.io.*;\n-import java.nio.charset.Charset;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.StandardCharsets;\n \n import io.minio.BucketExistsArgs;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzY5OTg5Ng==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463699896", "bodyText": "Please avoid star import usage.", "author": "DenisIstomin", "createdAt": "2020-07-31T16:08:36Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ExchangePattern;\n+import org.apache.camel.Message;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\nindex d449212a70a..3191fd6c874 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioComponentIntegrationTest.java\n\n@@ -28,7 +28,10 @@ import org.apache.camel.test.junit5.CamelTestSupport;\n import org.junit.jupiter.api.Disabled;\n import org.junit.jupiter.api.Test;\n \n-import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n \n @Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n public class MinioComponentIntegrationTest extends CamelTestSupport {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700750", "bodyText": "It would be nice to extract all credentials into .properties file", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:19Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDExMjAxNQ==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464112015", "bodyText": "Hi @DenisIstomin, How can I do that?", "author": "Nayananga", "createdAt": "2020-08-02T19:03:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3MjE5NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464272194", "bodyText": "An example here", "author": "omarsmak", "createdAt": "2020-08-03T08:38:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjgzNzgyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466837828", "bodyText": "@omarsmak, @DenisIstomin I have put minio_key.properties file in test/resources file along with the log4j2.properties file,\nendpoint=https://play.min.io\naccessKey=Q3AM3UQ867SPQQA43P2F\nsecretKey=zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\nregion=us-west-1\n\nbut then it throws this error java.lang.Exception: Make sure to supply minio endpoint and credentials as throws in this line. Any suggestions?", "author": "Nayananga", "createdAt": "2020-08-07T06:01:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MDE4Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r466840183", "bodyText": "Hi this problem solved", "author": "Nayananga", "createdAt": "2020-08-07T06:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDc1MA=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..4884ebd3455 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.component.minio.integration;\n \n+import java.util.Properties;\n+\n import io.minio.MinioClient;\n import org.apache.camel.BindToRegistry;\n import org.apache.camel.EndpointInject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcwMDk4Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463700982", "bodyText": "Please resolve this TODO", "author": "DenisIstomin", "createdAt": "2020-07-31T16:10:47Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")\n+public class MinioConsumerIntegrationTest extends CamelTestSupport {\n+\n+    @BindToRegistry(\"minioClient\")\n+    MinioClient client = MinioClient.builder()\n+            .endpoint(\"https://play.min.io\")\n+            .credentials(\"Q3AM3UQ867SPQQA43P2F\", \"zuf+tfteSlswRu7BJ86wekitnifILbZam1KYY3TG\")\n+            .region(\"us-west-1\")\n+            .build();\n+\n+    @EndpointInject\n+    private ProducerTemplate template;\n+\n+    @EndpointInject(\"mock:result\")\n+    private MockEndpoint result;\n+\n+    @Test\n+    public void sendIn() throws Exception {\n+        result.expectedMessageCount(3);\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test1.txt\");\n+            exchange.getIn().setBody(\"Test1\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test2.txt\");\n+            exchange.getIn().setBody(\"Test2\");\n+        });\n+\n+        template.send(\"direct:putObject\", exchange -> {\n+            exchange.getIn().setHeader(MinioConstants.OBJECT_NAME, \"test3.txt\");\n+            exchange.getIn().setBody(\"Test3\");\n+        });\n+\n+        assertMockEndpointsSatisfied();\n+    }\n+\n+    @Override\n+    protected RouteBuilder createRouteBuilder() {\n+        return new RouteBuilder() {\n+            @Override\n+            public void configure() {\n+                String minioEndpoint = \"minio://mycamel?autoCreateBucket=false\";\n+\n+                from(\"direct:putObject\").startupOrder(1).to(minioEndpoint).to(\"mock:result\");\n+\n+                // TODO: Check why this is not working", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\nindex 3f653b6a10a..4884ebd3455 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioConsumerIntegrationTest.java\n\n@@ -16,6 +16,8 @@\n  */\n package org.apache.camel.component.minio.integration;\n \n+import java.util.Properties;\n+\n import io.minio.MinioClient;\n import org.apache.camel.BindToRegistry;\n import org.apache.camel.EndpointInject;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk3ODgwOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463978808", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean autocloseBody = true;\n          \n          \n            \n                private boolean autoCloseBody = true;", "author": "dmvolod", "createdAt": "2020-08-01T16:41:18Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java", "diffHunk": "@@ -0,0 +1,641 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.time.ZonedDateTime;\n+\n+import io.minio.MinioClient;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import okhttp3.OkHttpClient;\n+import org.apache.camel.RuntimeCamelException;\n+import org.apache.camel.spi.UriParam;\n+import org.apache.camel.spi.UriParams;\n+\n+@UriParams\n+public class MinioConfiguration implements Cloneable {\n+\n+    @UriParam\n+    private String endpoint;\n+    @UriParam\n+    private Integer proxyPort;\n+\n+    @UriParam(label = \"security\", secret = true)\n+    private String accessKey;\n+    @UriParam(label = \"security\", secret = true)\n+    private String secretKey;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean secure;\n+\n+    @UriParam\n+    private String region;\n+\n+    @UriParam\n+    private OkHttpClient customHttpClient;\n+\n+    private String bucketName;\n+    @UriParam(defaultValue = \"true\")\n+    private boolean autoCreateBucket = true;\n+    @UriParam(defaultValue = \"false\")\n+    private boolean objectLock;\n+\n+    @UriParam\n+    private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n+    @UriParam\n+    private ServerSideEncryption serverSideEncryption;\n+\n+    @UriParam\n+    private MinioClient minioClient;\n+\n+    @UriParam(label = \"consumer\")\n+    private String objectName;\n+    @UriParam(label = \"consumer\")\n+    private String delimiter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeUserMetadata;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeVersions;\n+    @UriParam(label = \"consumer\")\n+    private String prefix;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean recursive;\n+    @UriParam(label = \"consumer\")\n+    private String startAfter;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean useVersion1;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean includeFolders;\n+    @UriParam(label = \"consumer\")\n+    private long offset;\n+    @UriParam(label = \"consumer\")\n+    private long length;\n+    @UriParam(label = \"consumer\")\n+    private String matchETag;\n+    @UriParam(label = \"consumer\")\n+    private String notMatchETag;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime modifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private ZonedDateTime unModifiedSince;\n+    @UriParam(label = \"consumer\")\n+    private String destinationBucketName;\n+    @UriParam(label = \"consumer\")\n+    private String destinationObjectName;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean deleteAfterRead = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"false\")\n+    private boolean moveAfterRead;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean includeBody = true;\n+    @UriParam(label = \"consumer\", defaultValue = \"true\")\n+    private boolean autocloseBody = true;", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\nindex 22e8441987e..93afa8e2874 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConfiguration.java\n\n@@ -29,36 +29,35 @@ import org.apache.camel.spi.UriParams;\n @UriParams\n public class MinioConfiguration implements Cloneable {\n \n-    @UriParam\n+    @UriParam(label = \"common\")\n     private String endpoint;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private Integer proxyPort;\n+    @UriParam(label = \"common\")\n+    private boolean secure;\n+    @UriParam(label = \"common\")\n+    private String region;\n+    @UriParam(label = \"common\")\n+    private OkHttpClient customHttpClient;\n \n     @UriParam(label = \"security\", secret = true)\n     private String accessKey;\n     @UriParam(label = \"security\", secret = true)\n     private String secretKey;\n-    @UriParam(defaultValue = \"false\")\n-    private boolean secure;\n-\n-    @UriParam\n-    private String region;\n-\n-    @UriParam\n-    private OkHttpClient customHttpClient;\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n \n     private String bucketName;\n-    @UriParam(defaultValue = \"true\")\n+    @UriParam(label = \"common\", defaultValue = \"true\")\n     private boolean autoCreateBucket = true;\n-    @UriParam(defaultValue = \"false\")\n+    @UriParam(label = \"common\", defaultValue = \"false\")\n     private boolean objectLock;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n+    private String policy;\n+    @UriParam(label = \"common\")\n     private ServerSideEncryptionCustomerKey serverSideEncryptionCustomerKey;\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private ServerSideEncryption serverSideEncryption;\n-\n-    @UriParam\n+    @UriParam(label = \"common\")\n     private MinioClient minioClient;\n \n     @UriParam(label = \"consumer\")\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980253", "bodyText": "I saw this implementation in large number of components, developed by @omarsmak, @oscerd and other members, but a little bit confusing about error message as getCamelContext().getRegistry().findByType can return more than one record if user suddenly put more than one MinioClient.class in the registry even if it doesn't make sense.\nThe error will be \"No MinioClient instance in the registry\" but can be wrong enough.", "author": "dmvolod", "createdAt": "2020-08-01T16:58:38Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import io.minio.MinioClient;\n+import org.apache.camel.CamelContext;\n+import org.apache.camel.spi.Metadata;\n+import org.apache.camel.spi.annotations.Component;\n+import org.apache.camel.support.DefaultComponent;\n+import org.apache.camel.util.ObjectHelper;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Represents the component that manages {@link MinioEndpoint}.\n+ */\n+@Component(\"minio\")\n+public class MinioComponent extends DefaultComponent {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MinioComponent.class);\n+\n+    @Metadata\n+    private MinioConfiguration configuration = new MinioConfiguration();\n+\n+    public MinioComponent() {\n+        this(null);\n+    }\n+\n+    public MinioComponent(CamelContext context) {\n+        super(context);\n+        registerExtension(new MinioComponentVerifierExtension());\n+\n+    }\n+\n+    @Override\n+    protected MinioEndpoint createEndpoint(String uri, String remaining, Map<String, Object> parameters) throws Exception {\n+        if (remaining == null || remaining.trim().length() == 0) {\n+            throw new IllegalArgumentException(\"Bucket name must be specified.\");\n+        }\n+\n+        final MinioConfiguration configuration = this.configuration != null ? this.configuration.copy() : new MinioConfiguration();\n+        configuration.setBucketName(remaining);\n+        MinioEndpoint endpoint = new MinioEndpoint(uri, this, configuration);\n+        setProperties(endpoint, parameters);\n+        checkAndSetRegistryClient(configuration, endpoint);\n+\n+        return endpoint;\n+    }\n+\n+    public MinioConfiguration getConfiguration() {\n+        return configuration;\n+    }\n+\n+    /**\n+     * The component configuration\n+     */\n+    public void setConfiguration(MinioConfiguration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    private void checkAndSetRegistryClient(MinioConfiguration configuration, MinioEndpoint endpoint) {\n+        if (ObjectHelper.isEmpty(endpoint.getConfiguration().getMinioClient())) {\n+            LOG.debug(\"Looking for an MinioClient instance in the registry\");\n+            Set<MinioClient> clients = getCamelContext().getRegistry().findByType(MinioClient.class);\n+            if (clients.size() == 1) {", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MTMyNg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463981326", "bodyText": "I introduced the autoDisvoverCliebt for this situation in 3.5.0. in case it is false, that method won't be called", "author": "oscerd", "createdAt": "2020-08-01T17:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI4MDc2Mg==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464280762", "bodyText": "@dmvolod yes, I agree, this error message could be misleading, I think error message could be changed if there are two cases, one for more than one MinioClient instance and other one for in case there is no instance of MinioClient.", "author": "omarsmak", "createdAt": "2020-08-03T08:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQ4NDY1NA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r467484654", "bodyText": "Hi all,\nif (clients.size() > 1) {\n                LOG.debug(\"Found more than one MinioClient instance in the registry, getting the first one...\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else if (clients.size() == 1) {\n                LOG.debug(\"Found exactly one MinioClient instance in the registry\");\n                configuration.setMinioClient(clients.stream().findFirst().get());\n            } else {\n                LOG.debug(\"No MinioClient instance in the registry\");\n            }\n\nis this approach okay?", "author": "Nayananga", "createdAt": "2020-08-08T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDI1Mw=="}], "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\nindex 8a826098549..16eec326a9d 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioComponent.java\n\n@@ -24,10 +24,12 @@ import org.apache.camel.CamelContext;\n import org.apache.camel.spi.Metadata;\n import org.apache.camel.spi.annotations.Component;\n import org.apache.camel.support.DefaultComponent;\n-import org.apache.camel.util.ObjectHelper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import static org.apache.camel.util.ObjectHelper.isEmpty;\n+import static org.apache.camel.util.ObjectHelper.isNotEmpty;\n+\n /**\n  * Represents the component that manages {@link MinioEndpoint}.\n  */\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzk4MDUyOA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r463980528", "bodyText": "@Nayananga a little bit confusing about key name and key value. The same as for LENGTH", "author": "dmvolod", "createdAt": "2020-08-01T17:01:42Z", "path": "components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio;\n+\n+/**\n+ * Constants used in Camel Minio module\n+ */\n+public interface MinioConstants {\n+\n+    String BUCKET_NAME = \"CamelMinioBucketName\";\n+    String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n+    String CACHE_CONTROL = \"CamelMinioContentControl\";\n+    String CONTENT_DISPOSITION = \"CamelMinioContentDisposition\";\n+    String CONTENT_ENCODING = \"CamelMinioContentEncoding\";\n+    String CONTENT_LENGTH = \"CamelMinioContentLength\";\n+    String CONTENT_MD5 = \"CamelMinioContentMD5\";\n+    String CONTENT_TYPE = \"CamelMinioContentType\";\n+    String E_TAG = \"CamelMinioETag\";\n+    String OBJECT_NAME = \"CamelMinioObjectName\";\n+    String DESTINATION_OBJECT_NAME = \"CamelMinioDestinationObjectName\";\n+    String LAST_MODIFIED = \"CamelMinioLastModified\";\n+    String STORAGE_CLASS = \"CamelMinioStorageClass\";\n+    String VERSION_ID = \"CamelMinioVersionId\";\n+    String CANNED_ACL = \"CamelMinioCannedAcl\";\n+    String MINIO_OPERATION = \"CamelMinioOperation\";\n+    String SERVER_SIDE_ENCRYPTION = \"CamelMinioServerSideEncryption\";\n+    String EXPIRATION_TIME = \"CamelMinioExpirationTime\";\n+    String REPLICATION_STATUS = \"CamelMinioReplicationStatus\";\n+    String OFFSET = \"CamelMinioRangeStart\";", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\nindex ddc90808d2d..a9e16731984 100644\n--- a/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n+++ b/components/camel-minio/src/main/java/org/apache/camel/component/minio/MinioConstants.java\n\n@@ -21,6 +21,7 @@ package org.apache.camel.component.minio;\n  */\n public interface MinioConstants {\n \n+    int BYTE_ARRAY_LENGTH = 1024;\n     String BUCKET_NAME = \"CamelMinioBucketName\";\n     String DESTINATION_BUCKET_NAME = \"CamelMinioDestinationBucketName\";\n     String CACHE_CONTROL = \"CamelMinioContentControl\";\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI3NTY5MA==", "url": "https://github.com/apache/camel/pull/3897#discussion_r464275690", "bodyText": "@Nayananga a tip: I think it will be easier for these Integration Tests classes to run through maven command line instead of having to remove the @Disabled. An example, take a look at this component IT tests. You will need to add a maven profile that will run IT tests that end with IT here. And then, you can add a Util class to load the credentials from the maven command line. Therefore after you have done all of the mentioned steps, you will just run your IT like this:\nmvn clean test -PfullTests", "author": "omarsmak", "createdAt": "2020-08-03T08:45:16Z", "path": "components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.component.minio.integration;\n+\n+import java.io.*;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.security.SecureRandom;\n+import java.util.UUID;\n+\n+import javax.crypto.KeyGenerator;\n+\n+import io.minio.CopyObjectArgs;\n+import io.minio.CopySource;\n+import io.minio.GetObjectArgs;\n+import io.minio.MinioClient;\n+import io.minio.PutObjectArgs;\n+import io.minio.ServerSideEncryption;\n+import io.minio.ServerSideEncryptionCustomerKey;\n+import org.apache.camel.BindToRegistry;\n+import org.apache.camel.EndpointInject;\n+import org.apache.camel.Exchange;\n+import org.apache.camel.ProducerTemplate;\n+import org.apache.camel.builder.RouteBuilder;\n+import org.apache.camel.component.minio.MinioConstants;\n+import org.apache.camel.component.minio.MinioOperations;\n+import org.apache.camel.component.mock.MockEndpoint;\n+import org.apache.camel.test.junit5.CamelTestSupport;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+@Disabled(\"Must be manually tested. Provide your own accessKey and secretKey!\")", "originalCommit": "ca963a048e1beb422fdf86ed84790523e9fd4b76", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "18ec4f679abc44faac6792ddc5a619a880e05e93", "chunk": "diff --git a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\nindex 9593d44cb13..7fec2fc9332 100644\n--- a/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n+++ b/components/camel-minio/src/test/java/org/apache/camel/component/minio/integration/MinioCopyObjectCustomerKeyOperationIntegrationTest.java\n\n@@ -16,10 +16,16 @@\n  */\n package org.apache.camel.component.minio.integration;\n \n-import java.io.*;\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n import java.nio.charset.Charset;\n import java.nio.charset.StandardCharsets;\n import java.security.SecureRandom;\n+import java.util.Properties;\n import java.util.UUID;\n \n import javax.crypto.KeyGenerator;\n"}}, {"oid": "fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "url": "https://github.com/apache/camel/commit/fe862d1d6d77d13ff95b8e1c7e0340527f9699d6", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-03T18:42:35Z", "type": "forcePushed"}, {"oid": "c0038995d0dd7129eade273ff2039a79e00d49f6", "url": "https://github.com/apache/camel/commit/c0038995d0dd7129eade273ff2039a79e00d49f6", "message": "Code simplified", "committedDate": "2020-08-06T07:48:09Z", "type": "forcePushed"}, {"oid": "d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "url": "https://github.com/apache/camel/commit/d99a0cfad3d9437b0b7bf15dd9526b67007b0458", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-06T18:25:17Z", "type": "forcePushed"}, {"oid": "0e860b49082c2ce8ae735e48cfb746850711f22e", "url": "https://github.com/apache/camel/commit/0e860b49082c2ce8ae735e48cfb746850711f22e", "message": "Removed redundant check", "committedDate": "2020-08-07T05:02:20Z", "type": "forcePushed"}, {"oid": "1535a16a62132c3be469a43230d0507eba76063c", "url": "https://github.com/apache/camel/commit/1535a16a62132c3be469a43230d0507eba76063c", "message": "Added component basic sketch", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "228df3f1623107af49b9755bf053b063e3375dda", "url": "https://github.com/apache/camel/commit/228df3f1623107af49b9755bf053b063e3375dda", "message": "Ran mvn clean install -Pfastinstall", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "0fd206c77f5d3fa320bad1cd34683710c229b2cf", "url": "https://github.com/apache/camel/commit/0fd206c77f5d3fa320bad1cd34683710c229b2cf", "message": "Updated to align with camel-checkstyle", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "url": "https://github.com/apache/camel/commit/90bce55a7e8b2800e08abaac9e633d36e23ae4fe", "message": "Added existing implementation and fixed build failures", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1e66a510a172e04b1bbeece7e1a5d330944daf14", "url": "https://github.com/apache/camel/commit/1e66a510a172e04b1bbeece7e1a5d330944daf14", "message": "Code reformatted", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "c6a9b5ac3b4d5a128c045495008174d905492576", "url": "https://github.com/apache/camel/commit/c6a9b5ac3b4d5a128c045495008174d905492576", "message": "Updated imports", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "cfce4fb8f46ec8057652ad366b47bbc93da82849", "url": "https://github.com/apache/camel/commit/cfce4fb8f46ec8057652ad366b47bbc93da82849", "message": "Updated camel version in camel-mino/pom.xml", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "1328d8106703a3d90d671d8d32c5eaa7419fa147", "url": "https://github.com/apache/camel/commit/1328d8106703a3d90d671d8d32c5eaa7419fa147", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "843335696c2da037e026ad7cc0318cf36494b183", "url": "https://github.com/apache/camel/commit/843335696c2da037e026ad7cc0318cf36494b183", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "2de2427460630152d5be00c6c33bad22c015f2cd", "url": "https://github.com/apache/camel/commit/2de2427460630152d5be00c6c33bad22c015f2cd", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:06Z", "type": "commit"}, {"oid": "bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "url": "https://github.com/apache/camel/commit/bcf25f83ff57e5e99db01aba34cbf6ce051dba00", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "152fd8b381686621d3de6a6300323fe89f42720b", "url": "https://github.com/apache/camel/commit/152fd8b381686621d3de6a6300323fe89f42720b", "message": "Added features according to the aws2 s3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "cce1852e6ad88c7c3a35134e8b0771f3a216e754", "url": "https://github.com/apache/camel/commit/cce1852e6ad88c7c3a35134e8b0771f3a216e754", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "0acedfcedaaf81796626b5f205f187b1262137ec", "url": "https://github.com/apache/camel/commit/0acedfcedaaf81796626b5f205f187b1262137ec", "message": "Added message headers in MinioEndpoint", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "url": "https://github.com/apache/camel/commit/acaa69fc2cf7a1f7127fc945e0bc5724c0af8aaa", "message": "Added new implementations for MinioProducer", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "45beb5ddeaad938003b700bcf4f34b1da4105be3", "url": "https://github.com/apache/camel/commit/45beb5ddeaad938003b700bcf4f34b1da4105be3", "message": "Completed porting AWS2 S3 component", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "url": "https://github.com/apache/camel/commit/c31ba2f8a3f6292297ff18111c199ffd8e4bb2b8", "message": "Updated to Minio 7.1.0", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "6972439ee57658ed13ff58c89df749dfafbfa18b", "url": "https://github.com/apache/camel/commit/6972439ee57658ed13ff58c89df749dfafbfa18b", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "f4aea6f0902b2108a296a183973813785969618b", "url": "https://github.com/apache/camel/commit/f4aea6f0902b2108a296a183973813785969618b", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "9dd0f1297a490222db92d0e8aee5919403fdcda7", "url": "https://github.com/apache/camel/commit/9dd0f1297a490222db92d0e8aee5919403fdcda7", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "3e2463ac08dfe95e015a7c22394bba783110e159", "url": "https://github.com/apache/camel/commit/3e2463ac08dfe95e015a7c22394bba783110e159", "message": "Include integration Tests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "217cea4fdb007779cfeaa3f709c8b5111de0ec22", "url": "https://github.com/apache/camel/commit/217cea4fdb007779cfeaa3f709c8b5111de0ec22", "message": "ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:07Z", "type": "commit"}, {"oid": "a118ffe604943fd210497c88aaf14265888eceb8", "url": "https://github.com/apache/camel/commit/a118ffe604943fd210497c88aaf14265888eceb8", "message": "ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "f2e79fda016b69999310571208bcda56d08251a4", "url": "https://github.com/apache/camel/commit/f2e79fda016b69999310571208bcda56d08251a4", "message": "Code Reformatted", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "08f2029caf83805ec099e160924b48da294350d8", "url": "https://github.com/apache/camel/commit/08f2029caf83805ec099e160924b48da294350d8", "message": "Integration test fixed", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "dbe1b9d6a59d2d844b774b48c576d31519b8239e", "url": "https://github.com/apache/camel/commit/dbe1b9d6a59d2d844b774b48c576d31519b8239e", "message": "Updated code to mimic the AWS2 s3 component", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "5e215f54a6df69b8da845a48ab9966c6f5afdef8", "url": "https://github.com/apache/camel/commit/5e215f54a6df69b8da845a48ab9966c6f5afdef8", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "0c39393a1c2b10699825ca6286d2d5f3c0062dab", "url": "https://github.com/apache/camel/commit/0c39393a1c2b10699825ca6286d2d5f3c0062dab", "message": "Ran Integration tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "url": "https://github.com/apache/camel/commit/bbe7f6fbe7e11a8d4c0ddf6316f11d1848b225f5", "message": "Fixed code issues", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "url": "https://github.com/apache/camel/commit/c35a7cb2bc1e76ec8968eb7e7b7b92b9c267ed0f", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "url": "https://github.com/apache/camel/commit/6d02c2928ffc2cb751e6fae3d2353aa29fda95f0", "message": "Added documentation", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "url": "https://github.com/apache/camel/commit/166adad9f8d0ae86f322dc34e5480a3d2e0a7b73", "message": "Minor changes to the tests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "429db9080e37920a959ef6837141e7ed94357f9d", "url": "https://github.com/apache/camel/commit/429db9080e37920a959ef6837141e7ed94357f9d", "message": "Fixed typo", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "585e4deebddd6999431c35a3b5a8f3ce72f1f974", "url": "https://github.com/apache/camel/commit/585e4deebddd6999431c35a3b5a8f3ce72f1f974", "message": "Added missing labels", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "d09d6135cbb90dde34b080b393621fa69c16777d", "url": "https://github.com/apache/camel/commit/d09d6135cbb90dde34b080b393621fa69c16777d", "message": "Ran  mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "c627c28ed07400606c1f31ef1a6a6e0ce975da10", "url": "https://github.com/apache/camel/commit/c627c28ed07400606c1f31ef1a6a6e0ce975da10", "message": "Removed wildcard imports", "committedDate": "2020-08-08T16:44:08Z", "type": "commit"}, {"oid": "e01c571ced63b6f85456cb419085ad2a5db9df3d", "url": "https://github.com/apache/camel/commit/e01c571ced63b6f85456cb419085ad2a5db9df3d", "message": "Removed redundant error handling and extracted removeObject method in MinioConsumer.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "652ceb5290bc403dfa12cc3dfc27447163f07e20", "url": "https://github.com/apache/camel/commit/652ceb5290bc403dfa12cc3dfc27447163f07e20", "message": "Renamed GetMinioClient.java to MinioRemoteClientImpl.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5a8af2544004b9d92e26d5db558932c2bb446f4f", "url": "https://github.com/apache/camel/commit/5a8af2544004b9d92e26d5db558932c2bb446f4f", "message": "Renamed Offset and Length in MinioConstants.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "170ea27658ce31d585e0df8cddc599d6e2e63d74", "url": "https://github.com/apache/camel/commit/170ea27658ce31d585e0df8cddc599d6e2e63d74", "message": "Added more cases in MinioComponentConfigurationTest.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "5c97f24959e7766acbc0e8159512233954d0ecbb", "url": "https://github.com/apache/camel/commit/5c97f24959e7766acbc0e8159512233954d0ecbb", "message": "Added new MinioConstant", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "1f08aa281662d69aecfdbad038df3b1d8add228b", "url": "https://github.com/apache/camel/commit/1f08aa281662d69aecfdbad038df3b1d8add228b", "message": "Replaced != 0 with > 0", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "fa241fb3e2068636d81e3e918a63414639c06eec", "url": "https://github.com/apache/camel/commit/fa241fb3e2068636d81e3e918a63414639c06eec", "message": "Handled processCommit exception", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "url": "https://github.com/apache/camel/commit/27adf752f62677ae3e8488ed7350fb3bd5e2eefa", "message": "Handled createExchange exceptions", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "url": "https://github.com/apache/camel/commit/73e3b6bd522d7123fee5dbe1045b5a0890ffe326", "message": "Reformatted code", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "7136941423266b6a21f290a250e1e0017e439219", "url": "https://github.com/apache/camel/commit/7136941423266b6a21f290a250e1e0017e439219", "message": "Code simplified", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "url": "https://github.com/apache/camel/commit/2b27c7c868f05fbad30816b0a540fc4aa4c0965d", "message": "Ran mvn clean install -DskipTests", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "url": "https://github.com/apache/camel/commit/56eddb9a3966a9f0dfa00c44ea030b09db3492c3", "message": "Renamed autocloseBody to autoCloseBody in MinioConfiguration.java", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "409614e6426f1393c9c465c7dae4ff670902b2d2", "url": "https://github.com/apache/camel/commit/409614e6426f1393c9c465c7dae4ff670902b2d2", "message": "Minor fix", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c308169b9ee19d93399a599b1a4df08e7816b5fd", "url": "https://github.com/apache/camel/commit/c308169b9ee19d93399a599b1a4df08e7816b5fd", "message": "Replaced == null / != null with isEmpty / isNotEmpty", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "url": "https://github.com/apache/camel/commit/c1bebb8cb5eea864f23e7347cc793c84ea5036cf", "message": "Removed redundant check", "committedDate": "2020-08-08T16:44:09Z", "type": "commit"}, {"oid": "b08f49d96a2ce88cc46a80decd169986249b5779", "url": "https://github.com/apache/camel/commit/b08f49d96a2ce88cc46a80decd169986249b5779", "message": "Extracted all credentials into minio_key.properties file", "committedDate": "2020-08-08T16:44:10Z", "type": "commit"}]}