{"pr_number": 1614, "pr_title": "Add failing compatibility reason in rest response ", "pr_createdAt": "2020-09-02T16:56:51Z", "pr_url": "https://github.com/confluentinc/schema-registry/pull/1614", "timeline": [{"oid": "4edfceaed3e7c6d0dc843491ee09d1870e2e37c2", "url": "https://github.com/confluentinc/schema-registry/commit/4edfceaed3e7c6d0dc843491ee09d1870e2e37c2", "message": "Revert style change; Use Collections.emptyList() to indicate is-compatible", "committedDate": "2020-09-03T21:52:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExMTc4NQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485111785", "bodyText": "nit: other wise -> otherwise", "author": "rayokota", "createdAt": "2020-09-08T18:21:00Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java", "diffHunk": "@@ -34,6 +36,7 @@\n    *\n    * @param toValidate The schema to validate\n    * @param existing The schema to validate against\n+   * @return List of error message, other wise empty list", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java\nindex 0f9605465..b1f8cbd61 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java\n\n@@ -36,7 +36,7 @@ public interface SchemaValidationStrategy {\n    *\n    * @param toValidate The schema to validate\n    * @param existing The schema to validate against\n-   * @return List of error message, other wise empty list\n+   * @return List of error message, otherwise empty list\n    */\n   List<String> validate(ParsedSchema toValidate, ParsedSchema existing);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExMzY1Nw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485113657", "bodyText": "Change to\nList<String> result = new ArrayList<>();\nresult.addAll(existing.isBackwardCompatible(toValidate);\nresult.addAll(toValidate.isBackwardCompatible(existing);\nreturn result;", "author": "rayokota", "createdAt": "2020-09-08T18:24:33Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java", "diffHunk": "@@ -53,8 +55,21 @@ public SchemaValidatorBuilder canBeReadStrategy() {\n    * and vice-versa, according to the JSON default schema resolution.\n    */\n   public SchemaValidatorBuilder mutualReadStrategy() {\n-    this.strategy = (toValidate, existing) -> existing.isBackwardCompatible(toValidate)\n-        && toValidate.isBackwardCompatible(existing);\n+\n+    this.strategy = (toValidate, existing) -> {\n+      List<String> backward = existing.isBackwardCompatible(toValidate);", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java\nindex b5978c1e1..65d992fd4 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java\n\n@@ -57,18 +58,10 @@ public final class SchemaValidatorBuilder {\n   public SchemaValidatorBuilder mutualReadStrategy() {\n \n     this.strategy = (toValidate, existing) -> {\n-      List<String> backward = existing.isBackwardCompatible(toValidate);\n-      List<String> forward = toValidate.isBackwardCompatible(existing);\n-      if (!backward.isEmpty() && !forward.isEmpty()) {\n-        backward.addAll(forward);\n-        return backward;\n-      } else if (!backward.isEmpty()) {\n-        return backward;\n-      } else if (!forward.isEmpty())  {\n-        return forward;\n-      } else {\n-        return Collections.emptyList();\n-      }\n+      List<String> result = new ArrayList<>();\n+      result.addAll(existing.isBackwardCompatible(toValidate));\n+      result.addAll(toValidate.isBackwardCompatible(existing));\n+      return result;\n     };\n     return this;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDY0Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485114646", "bodyText": "Replace with Collections.singletonList(...)", "author": "rayokota", "createdAt": "2020-09-08T18:26:22Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDY5Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485114692", "bodyText": "Replace with Collections.singletonList(...)", "author": "rayokota", "createdAt": "2020-09-08T18:26:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNDgwMw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485114803", "bodyText": "Replace with Collections.singletonList(...)", "author": "rayokota", "createdAt": "2020-09-08T18:26:44Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return false;\n+      return new LinkedList<>(Arrays.asList(", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExNjg2MQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485116861", "bodyText": "This is not the correct usage of String.format, you can replace with\n\"Unexpected exception during compatibility check: \" + e.getMessage()", "author": "rayokota", "createdAt": "2020-09-08T18:30:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\n+              String.format(\"Unexpected exception during compatibility check\", e)));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExODAwMA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485118000", "bodyText": "Change public -> default and have the implementation throw new UnsupportedOperationException()", "author": "rayokota", "createdAt": "2020-09-08T18:32:43Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/SchemaRegistryClient.java", "diffHunk": "@@ -121,6 +121,9 @@ default boolean testCompatibility(String subject, org.apache.avro.Schema schema)\n   public boolean testCompatibility(String subject, ParsedSchema schema)\n       throws IOException, RestClientException;\n \n+  public List<String> testCompatibilityVerbose(String subject, ParsedSchema schema)", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/SchemaRegistryClient.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/SchemaRegistryClient.java\nindex 81b414dc3..c87a8d0b6 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/SchemaRegistryClient.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/SchemaRegistryClient.java\n\n@@ -121,8 +121,10 @@ public interface SchemaRegistryClient extends SchemaVersionFetcher {\n   public boolean testCompatibility(String subject, ParsedSchema schema)\n       throws IOException, RestClientException;\n \n-  public List<String> testCompatibilityVerbose(String subject, ParsedSchema schema)\n-          throws IOException, RestClientException;\n+  default List<String> testCompatibilityVerbose(String subject, ParsedSchema schema)\n+          throws IOException, RestClientException {\n+    throw new UnsupportedOperationException();\n+  }\n \n   public String updateCompatibility(String subject, String compatibility)\n       throws IOException, RestClientException;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExOTQ3MA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485119470", "bodyText": "Let's call this property \"messages\" and getMessages, this will allow us to put other messages in the future.", "author": "rayokota", "createdAt": "2020-09-08T18:35:22Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java", "diffHunk": "@@ -45,6 +50,16 @@ public String toJson() throws IOException {\n     return JacksonMapper.INSTANCE.writeValueAsString(this);\n   }\n \n+  @JsonProperty(\"error_messages\")", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\nindex a495662c9..30ce9afb1 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\n\n@@ -50,14 +50,14 @@ public class CompatibilityCheckResponse {\n     return JacksonMapper.INSTANCE.writeValueAsString(this);\n   }\n \n-  @JsonProperty(\"error_messages\")\n-  public List<String> getErrorMessages() {\n-    return errorMessages;\n+  @JsonProperty(\"messages\")\n+  public List<String> getMessages() {\n+    return messages;\n   }\n \n-  @JsonProperty(\"error_messages\")\n-  public void setErrorMessages(List<String> errorMessages) {\n-    this.errorMessages = errorMessages;\n+  @JsonProperty(\"messages\")\n+  public void setMessages(List<String> messages) {\n+    this.messages = messages;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTExOTY0Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485119642", "bodyText": "Let's call this property \"messages\" and getMessages, this will allow us to put other messages in the future.", "author": "rayokota", "createdAt": "2020-09-08T18:35:43Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java", "diffHunk": "@@ -45,6 +50,16 @@ public String toJson() throws IOException {\n     return JacksonMapper.INSTANCE.writeValueAsString(this);\n   }\n \n+  @JsonProperty(\"error_messages\")\n+  public List<String> getErrorMessages() {\n+    return errorMessages;\n+  }\n+\n+  @JsonProperty(\"error_messages\")", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\nindex a495662c9..30ce9afb1 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\n\n@@ -50,14 +50,14 @@ public class CompatibilityCheckResponse {\n     return JacksonMapper.INSTANCE.writeValueAsString(this);\n   }\n \n-  @JsonProperty(\"error_messages\")\n-  public List<String> getErrorMessages() {\n-    return errorMessages;\n+  @JsonProperty(\"messages\")\n+  public List<String> getMessages() {\n+    return messages;\n   }\n \n-  @JsonProperty(\"error_messages\")\n-  public void setErrorMessages(List<String> errorMessages) {\n-    this.errorMessages = errorMessages;\n+  @JsonProperty(\"messages\")\n+  public void setMessages(List<String> messages) {\n+    this.messages = messages;\n   }\n \n   @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyMzQxNg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485123416", "bodyText": "Let's call this property messages, this will allow us to put other messages in the future.", "author": "rayokota", "createdAt": "2020-09-08T18:43:03Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java", "diffHunk": "@@ -16,16 +16,21 @@\n \n package io.confluent.kafka.schemaregistry.client.rest.entities.requests;\n \n+import com.fasterxml.jackson.annotation.JsonInclude;\n import com.fasterxml.jackson.annotation.JsonProperty;\n \n import java.io.IOException;\n \n import io.confluent.kafka.schemaregistry.utils.JacksonMapper;\n+\n+import java.util.List;\n import java.util.Objects;\n \n+@JsonInclude(JsonInclude.Include.NON_NULL)\n public class CompatibilityCheckResponse {\n \n   private boolean isCompatible;\n+  private List<String> errorMessages = null;", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\nindex a495662c9..30ce9afb1 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/entities/requests/CompatibilityCheckResponse.java\n\n@@ -30,7 +30,7 @@ import java.util.Objects;\n public class CompatibilityCheckResponse {\n \n   private boolean isCompatible;\n-  private List<String> errorMessages = null;\n+  private List<String> messages = null;\n \n   public static CompatibilityCheckResponse fromJson(String json) throws IOException {\n     return JacksonMapper.INSTANCE.readValue(json, CompatibilityCheckResponse.class);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTA4NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125084", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:04Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1281,7 +1282,7 @@ public CompatibilityLevel getCompatibilityLevelInScope(String subject)\n   }\n \n   @Override\n-  public boolean isCompatible(String subject,\n+  public List<String> isCompatible(String subject,\n                               Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\nindex 08cbf88e1..1d3c01367 100644\n--- a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\n+++ b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\n\n@@ -1283,8 +1283,8 @@ public class KafkaSchemaRegistry implements SchemaRegistry, LeaderAwareSchemaReg\n \n   @Override\n   public List<String> isCompatible(String subject,\n-                              Schema newSchema,\n-                              Schema latestSchema)\n+                                   Schema newSchema,\n+                                   Schema latestSchema)\n       throws SchemaRegistryException {\n     if (latestSchema == null) {\n       log.error(\"Lastest schema not provided\");\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTE0OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125148", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:10Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1296,7 +1297,7 @@ public boolean isCompatible(String subject,\n    * @param previousSchemas Full schema history in chronological order\n    */\n   @Override\n-  public boolean isCompatible(String subject,\n+  public List<String> isCompatible(String subject,\n                               Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\nindex 08cbf88e1..1d3c01367 100644\n--- a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\n+++ b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\n\n@@ -1298,8 +1298,8 @@ public class KafkaSchemaRegistry implements SchemaRegistry, LeaderAwareSchemaReg\n    */\n   @Override\n   public List<String> isCompatible(String subject,\n-                              Schema newSchema,\n-                              List<Schema> previousSchemas)\n+                                   Schema newSchema,\n+                                   List<Schema> previousSchemas)\n       throws SchemaRegistryException {\n \n     if (previousSchemas == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTIyNA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125224", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:17Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java", "diffHunk": "@@ -1316,7 +1317,7 @@ public boolean isCompatible(String subject,\n     return isCompatibleWithPrevious(subject, parsedSchema, prevParsedSchemas);\n   }\n \n-  private boolean isCompatibleWithPrevious(String subject,\n+  private List<String> isCompatibleWithPrevious(String subject,\n                                            ParsedSchema parsedSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\nindex 08cbf88e1..1d3c01367 100644\n--- a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\n+++ b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/KafkaSchemaRegistry.java\n\n@@ -1318,8 +1318,8 @@ public class KafkaSchemaRegistry implements SchemaRegistry, LeaderAwareSchemaReg\n   }\n \n   private List<String> isCompatibleWithPrevious(String subject,\n-                                           ParsedSchema parsedSchema,\n-                                           List<ParsedSchema> previousSchemas)\n+                                                ParsedSchema parsedSchema,\n+                                                List<ParsedSchema> previousSchemas)\n       throws SchemaRegistryException {\n \n     CompatibilityLevel compatibility = getCompatibilityLevelInScope(subject);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTI5Mw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125293", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:26Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java", "diffHunk": "@@ -71,11 +71,11 @@ Schema get(String subject, int version, boolean returnDeletedSchema)\n   Schema lookUpSchemaUnderSubject(String subject, Schema schema, boolean lookupDeletedSchema)\n       throws SchemaRegistryException;\n \n-  boolean isCompatible(String subject,\n+  List<String> isCompatible(String subject,\n                        Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java\nindex 347331a48..2120ab8cb 100644\n--- a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java\n+++ b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java\n\n@@ -72,12 +72,12 @@ public interface SchemaRegistry extends SchemaVersionFetcher {\n       throws SchemaRegistryException;\n \n   List<String> isCompatible(String subject,\n-                       Schema newSchema,\n-                       Schema targetSchema) throws SchemaRegistryException;\n+                            Schema newSchema,\n+                            Schema targetSchema) throws SchemaRegistryException;\n \n   List<String> isCompatible(String subject,\n-                       Schema newSchema,\n-                       List<Schema> previousSchemas) throws SchemaRegistryException;\n+                            Schema newSchema,\n+                            List<Schema> previousSchemas) throws SchemaRegistryException;\n \n   void close();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTQ4OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125488", "bodyText": "nit: fix indentation", "author": "rayokota", "createdAt": "2020-09-08T18:46:47Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java", "diffHunk": "@@ -71,11 +71,11 @@ Schema get(String subject, int version, boolean returnDeletedSchema)\n   Schema lookUpSchemaUnderSubject(String subject, Schema schema, boolean lookupDeletedSchema)\n       throws SchemaRegistryException;\n \n-  boolean isCompatible(String subject,\n+  List<String> isCompatible(String subject,\n                        Schema newSchema,\n                        Schema targetSchema) throws SchemaRegistryException;\n \n-  boolean isCompatible(String subject,\n+  List<String> isCompatible(String subject,\n                        Schema newSchema,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java\nindex 347331a48..2120ab8cb 100644\n--- a/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java\n+++ b/core/src/main/java/io/confluent/kafka/schemaregistry/storage/SchemaRegistry.java\n\n@@ -72,12 +72,12 @@ public interface SchemaRegistry extends SchemaVersionFetcher {\n       throws SchemaRegistryException;\n \n   List<String> isCompatible(String subject,\n-                       Schema newSchema,\n-                       Schema targetSchema) throws SchemaRegistryException;\n+                            Schema newSchema,\n+                            Schema targetSchema) throws SchemaRegistryException;\n \n   List<String> isCompatible(String subject,\n-                       Schema newSchema,\n-                       List<Schema> previousSchemas) throws SchemaRegistryException;\n+                            Schema newSchema,\n+                            List<Schema> previousSchemas) throws SchemaRegistryException;\n \n   void close();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNTk5NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485125994", "bodyText": "Use Collections.singletonList", "author": "rayokota", "createdAt": "2020-09-08T18:47:44Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -300,9 +302,9 @@ private static boolean isPrimitive(Object value) {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java b/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\nindex 4a4d95b4c..d9db8231e 100644\n--- a/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\n+++ b/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\n\n@@ -304,7 +303,7 @@ public class JsonSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     final List<Difference> differences = SchemaDiff.compare(\n         ((JsonSchema) previousSchema).rawSchema(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNjU3Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485126576", "bodyText": "Use ArrayList instead of LinkedList", "author": "rayokota", "createdAt": "2020-09-08T18:48:48Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -314,17 +316,22 @@ public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n+      List<String> errorMessages = new LinkedList<>();", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java b/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\nindex 4a4d95b4c..d9db8231e 100644\n--- a/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\n+++ b/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\n\n@@ -316,7 +315,7 @@ public class JsonSchema implements ParsedSchema {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n-      List<String> errorMessages = new LinkedList<>();\n+      List<String> errorMessages = new ArrayList<>();\n       for (Difference incompatibleDiff : incompatibleDiffs) {\n         if (first) {\n           // Log first incompatible change as warning\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNzQ4Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485127482", "bodyText": "Use Collections.singletonList", "author": "rayokota", "createdAt": "2020-09-08T18:50:18Z", "path": "protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java", "diffHunk": "@@ -785,9 +787,9 @@ public void validate() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java b/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\nindex 27c7e70d0..74d1859f8 100644\n--- a/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\n+++ b/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\n\n@@ -789,7 +787,7 @@ public class ProtobufSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     final List<Difference> differences = SchemaDiff.compare(\n         (ProtobufSchema) previousSchema, this\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyNzU2OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485127568", "bodyText": "Use ArrayList", "author": "rayokota", "createdAt": "2020-09-08T18:50:28Z", "path": "protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java", "diffHunk": "@@ -798,17 +800,22 @@ public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n+      List<String> errorMessages = new LinkedList<>();", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java b/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\nindex 27c7e70d0..74d1859f8 100644\n--- a/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\n+++ b/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\n\n@@ -800,7 +798,7 @@ public class ProtobufSchema implements ParsedSchema {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n-      List<String> errorMessages = new LinkedList<>();\n+      List<String> errorMessages = new ArrayList<>();\n       for (Difference incompatibleDiff : incompatibleDiffs) {\n         if (first) {\n           // Log first incompatible change as warning\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEyODg0Mw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485128843", "bodyText": "Actually RestService is more like an internal class (SchemaRegistryClient wraps it), so we can change this interface by adding a boolean verbose flag to the existing testCompatibility method", "author": "rayokota", "createdAt": "2020-09-08T18:52:56Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java", "diffHunk": "@@ -549,6 +549,47 @@ public boolean testCompatibility(Map<String, String> requestProperties,\n     return response.getIsCompatible();\n   }\n \n+  public List<String> testCompatibilityVerbose(String schemaString,", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java\nindex 6048a8458..a6c3ba62e 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java\n\n@@ -505,89 +505,57 @@ public class RestService implements Configurable {\n   }\n \n   // Visible for testing\n-  public boolean testCompatibility(String schemaString, String subject, String version)\n+  public List<String> testCompatibility(String schemaString, String subject, String version)\n       throws IOException, RestClientException {\n     RegisterSchemaRequest request = new RegisterSchemaRequest();\n     request.setSchema(schemaString);\n-    return testCompatibility(request, subject, version);\n+    return testCompatibility(request, subject, version, false);\n   }\n \n-  public boolean testCompatibility(String schemaString,\n-                                   String schemaType,\n-                                   List<SchemaReference> references,\n-                                   String subject,\n-                                   String version)\n+  public List<String> testCompatibility(String schemaString,\n+                                        String schemaType,\n+                                        List<SchemaReference> references,\n+                                        String subject,\n+                                        String version,\n+                                        boolean verbose)\n       throws IOException, RestClientException {\n     RegisterSchemaRequest request = new RegisterSchemaRequest();\n     request.setSchema(schemaString);\n     request.setSchemaType(schemaType);\n     request.setReferences(references);\n-    return testCompatibility(request, subject, version);\n+    return testCompatibility(request, subject, version, verbose);\n   }\n \n-  public boolean testCompatibility(RegisterSchemaRequest registerSchemaRequest,\n-                                   String subject,\n-                                   String version)\n+  public List<String> testCompatibility(RegisterSchemaRequest registerSchemaRequest,\n+                                        String subject,\n+                                        String version,\n+                                        boolean verbose)\n       throws IOException, RestClientException {\n     return testCompatibility(DEFAULT_REQUEST_PROPERTIES, registerSchemaRequest,\n-                             subject, version);\n+                             subject, version, verbose);\n   }\n \n-  public boolean testCompatibility(Map<String, String> requestProperties,\n-                                   RegisterSchemaRequest registerSchemaRequest,\n-                                   String subject,\n-                                   String version)\n+  public List<String> testCompatibility(Map<String, String> requestProperties,\n+                                        RegisterSchemaRequest registerSchemaRequest,\n+                                        String subject,\n+                                        String version,\n+                                        boolean verbose)\n       throws IOException, RestClientException {\n     UriBuilder builder = UriBuilder.fromPath(\n         \"/compatibility/subjects/{subject}/versions/{version}\");\n+    builder.queryParam(\"verbose\", verbose);\n     String path = builder.build(subject, version).toString();\n \n     CompatibilityCheckResponse response =\n         httpRequest(path, \"POST\",\n                     registerSchemaRequest.toJson().getBytes(StandardCharsets.UTF_8),\n                     requestProperties, COMPATIBILITY_CHECK_RESPONSE_TYPE_REFERENCE);\n-    return response.getIsCompatible();\n-  }\n-\n-  public List<String> testCompatibilityVerbose(String schemaString,\n-                                               String schemaType,\n-                                               List<SchemaReference> references,\n-                                               String subject,\n-                                               String version)\n-      throws IOException, RestClientException {\n-    RegisterSchemaRequest request = new RegisterSchemaRequest();\n-    request.setSchema(schemaString);\n-    request.setSchemaType(schemaType);\n-    request.setReferences(references);\n-    return testCompatibilityVerbose(request, subject, version);\n-  }\n-\n-  public List<String> testCompatibilityVerbose(RegisterSchemaRequest registerSchemaRequest,\n-                                               String subject,\n-                                               String version)\n-      throws IOException, RestClientException {\n-    return testCompatibilityVerbose(\n-        DEFAULT_REQUEST_PROPERTIES, registerSchemaRequest, subject, version);\n-  }\n-\n-  public List<String> testCompatibilityVerbose(Map<String, String> requestProperties,\n-                                               RegisterSchemaRequest registerSchemaRequest,\n-                                               String subject,\n-                                               String version)\n-      throws IOException, RestClientException {\n-    UriBuilder builder =\n-        UriBuilder.fromPath(\"/compatibility/subjects/{subject}/versions/{version}\");\n-    builder.queryParam(\"verbose\", true);\n-    String path = builder.build(subject, version).toString();\n-\n-    CompatibilityCheckResponse response =\n-        httpRequest(\n-            path,\n-            \"POST\",\n-            registerSchemaRequest.toJson().getBytes(StandardCharsets.UTF_8),\n-            requestProperties,\n-            COMPATIBILITY_CHECK_RESPONSE_TYPE_REFERENCE);\n-    return response.getErrorMessages();\n+    if (verbose) {\n+      return response.getMessages();\n+    } else {\n+      return response.getIsCompatible()\n+              ? Collections.emptyList() : Collections.singletonList(\"Schemas are incompatible\");\n+    }\n   }\n \n   public ConfigUpdateRequest updateCompatibility(String compatibility, String subject)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEzNDM3OQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485134379", "bodyText": "A few lines above this line, we catch InvalidSchemaException.  If verbose is true, instead of throwing an exception, let's put the error message from InvalidSchemaException in a CompatibilityCheckResponse and return that.", "author": "rayokota", "createdAt": "2020-09-08T19:02:57Z", "path": "core/src/main/java/io/confluent/kafka/schemaregistry/rest/resources/CompatibilityResource.java", "diffHunk": "@@ -137,11 +141,22 @@ public void testCompatibilityBySubjectName(\n       throw Errors.schemaRegistryException(", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/core/src/main/java/io/confluent/kafka/schemaregistry/rest/resources/CompatibilityResource.java b/core/src/main/java/io/confluent/kafka/schemaregistry/rest/resources/CompatibilityResource.java\nindex 53d9c4acb..f9a0d9aac 100644\n--- a/core/src/main/java/io/confluent/kafka/schemaregistry/rest/resources/CompatibilityResource.java\n+++ b/core/src/main/java/io/confluent/kafka/schemaregistry/rest/resources/CompatibilityResource.java\n\n@@ -133,7 +133,11 @@ public class CompatibilityResource {\n               : Collections.emptyList()\n       );\n     } catch (InvalidSchemaException e) {\n-      throw Errors.invalidSchemaException(e);\n+      if (verbose) {\n+        errorMessages = Collections.singletonList(e.getMessage());\n+      } else {\n+        throw Errors.invalidSchemaException(e);\n+      }\n     } catch (SchemaRegistryStoreException e) {\n       throw Errors.storeException(\n           \"Error while getting compatibility level for subject \" + subject, e);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MTE4Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485051186", "bodyText": "I guess the whole \"if else\" block can be replaced by a single if given the other collection is empty in the else if we change a bit the condition.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!backward.isEmpty() && !forward.isEmpty()) {\n          \n          \n            \n                    backward.addAll(forward);\n          \n          \n            \n                    return backward;\n          \n          \n            \n                  } else if (!backward.isEmpty()) {\n          \n          \n            \n                    return backward;\n          \n          \n            \n                  } else if (!forward.isEmpty())  {\n          \n          \n            \n                    return forward;\n          \n          \n            \n                  } else {\n          \n          \n            \n                    return Collections.emptyList();\n          \n          \n            \n                  }\n          \n          \n            \n                  if (!backward.isEmpty() || !forward.isEmpty()) {\n          \n          \n            \n                    backward.addAll(forward);\n          \n          \n            \n                    return backward;\n          \n          \n            \n                  } else {\n          \n          \n            \n                    return Collections.emptyList();\n          \n          \n            \n                  }", "author": "ImFlog", "createdAt": "2020-09-08T16:31:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java", "diffHunk": "@@ -53,8 +55,21 @@ public SchemaValidatorBuilder canBeReadStrategy() {\n    * and vice-versa, according to the JSON default schema resolution.\n    */\n   public SchemaValidatorBuilder mutualReadStrategy() {\n-    this.strategy = (toValidate, existing) -> existing.isBackwardCompatible(toValidate)\n-        && toValidate.isBackwardCompatible(existing);\n+\n+    this.strategy = (toValidate, existing) -> {\n+      List<String> backward = existing.isBackwardCompatible(toValidate);\n+      List<String> forward = toValidate.isBackwardCompatible(existing);\n+      if (!backward.isEmpty() && !forward.isEmpty()) {\n+        backward.addAll(forward);\n+        return backward;\n+      } else if (!backward.isEmpty()) {\n+        return backward;\n+      } else if (!forward.isEmpty())  {\n+        return forward;\n+      } else {\n+        return Collections.emptyList();\n+      }", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java\nindex b5978c1e1..65d992fd4 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidatorBuilder.java\n\n@@ -57,18 +58,10 @@ public final class SchemaValidatorBuilder {\n   public SchemaValidatorBuilder mutualReadStrategy() {\n \n     this.strategy = (toValidate, existing) -> {\n-      List<String> backward = existing.isBackwardCompatible(toValidate);\n-      List<String> forward = toValidate.isBackwardCompatible(existing);\n-      if (!backward.isEmpty() && !forward.isEmpty()) {\n-        backward.addAll(forward);\n-        return backward;\n-      } else if (!backward.isEmpty()) {\n-        return backward;\n-      } else if (!forward.isEmpty())  {\n-        return forward;\n-      } else {\n-        return Collections.emptyList();\n-      }\n+      List<String> result = new ArrayList<>();\n+      result.addAll(existing.isBackwardCompatible(toValidate));\n+      result.addAll(toValidate.isBackwardCompatible(existing));\n+      return result;\n     };\n     return this;\n   }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1Mjk0NQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485052945", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return List of error message, other wise empty list\n          \n          \n            \n               * @return List of error message, otherwise empty list", "author": "ImFlog", "createdAt": "2020-09-08T16:34:29Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java", "diffHunk": "@@ -34,6 +36,7 @@\n    *\n    * @param toValidate The schema to validate\n    * @param existing The schema to validate against\n+   * @return List of error message, other wise empty list", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java\nindex 0f9605465..b1f8cbd61 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidationStrategy.java\n\n@@ -36,7 +36,7 @@ public interface SchemaValidationStrategy {\n    *\n    * @param toValidate The schema to validate\n    * @param existing The schema to validate against\n-   * @return List of error message, other wise empty list\n+   * @return List of error message, otherwise empty list\n    */\n   List<String> validate(ParsedSchema toValidate, ParsedSchema existing);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1MzEyOA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485053128", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @return empty list if the schema is compatible with the provided schema, other wise the list\n          \n          \n            \n               * @return List of error message, otherwise empty list", "author": "ImFlog", "createdAt": "2020-09-08T16:34:50Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidator.java", "diffHunk": "@@ -42,6 +44,8 @@\n    * @param toValidate The schema to validate\n    * @param existing The schemas to validate against, in order from most recent to latest if\n    *     applicable\n+   * @return empty list if the schema is compatible with the provided schema, other wise the list", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidator.java b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidator.java\nindex 86ea4428c..9a3462d59 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidator.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/SchemaValidator.java\n\n@@ -44,8 +44,7 @@ public interface SchemaValidator {\n    * @param toValidate The schema to validate\n    * @param existing The schemas to validate against, in order from most recent to latest if\n    *     applicable\n-   * @return empty list if the schema is compatible with the provided schema, other wise the list\n-   *        of error messages\n+   * @return List of error message, otherwise empty list\n    */\n   List<String> validate(ParsedSchema toValidate, Iterable<? extends ParsedSchema> existing);\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NjY4Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485056682", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));\n          \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Compatibility level not specified.\"));", "author": "ImFlog", "createdAt": "2020-09-08T16:40:56Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -364,6 +365,29 @@ public boolean testCompatibility(String subject, ParsedSchema newSchema) throws\n           schemaMetadata.getId()));\n     }\n \n+    return newSchema.isCompatible(compatibilityLevel, schemaHistory).isEmpty();\n+  }\n+\n+  @Override\n+  public List<String> testCompatibilityVerbose(String subject, ParsedSchema newSchema)\n+          throws IOException, RestClientException {\n+    String compatibility = compatibilityCache.get(subject);\n+    if (compatibility == null) {\n+      compatibility = defaultCompatibility;\n+    }\n+\n+    CompatibilityLevel compatibilityLevel = CompatibilityLevel.forName(compatibility);\n+    if (compatibilityLevel == null) {\n+      return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java\nindex 7a66ed1b0..13aa97fac 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java\n\n@@ -378,7 +378,7 @@ public class MockSchemaRegistryClient implements SchemaRegistryClient {\n \n     CompatibilityLevel compatibilityLevel = CompatibilityLevel.forName(compatibility);\n     if (compatibilityLevel == null) {\n-      return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));\n+      return new LinkedList<>(Arrays.asList(\"Compatibility level not specified.\"));\n     }\n \n     List<ParsedSchema> schemaHistory = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3OTU2OQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485079569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                  return Arrays.asList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T17:21:25Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3OTcyOA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485079728", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(e.toString()));\n          \n          \n            \n                  return Arrays.asList(e.toString());", "author": "ImFlog", "createdAt": "2020-09-08T17:21:42Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA3OTk3MQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485079971", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\n          \n          \n            \n                          String.format(\"Unexpected exception during compatibility check\", e)));\n          \n          \n            \n                  return Arrays.asList(\n          \n          \n            \n                          String.format(\"Unexpected exception during compatibility check\", e));", "author": "ImFlog", "createdAt": "2020-09-08T17:22:09Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\n+              String.format(\"Unexpected exception during compatibility check\", e)));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4MDQwOA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485080408", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));\n          \n          \n            \n                  return Arrays.asList(\"Compatibility level not specified.\");", "author": "ImFlog", "createdAt": "2020-09-08T17:22:51Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java", "diffHunk": "@@ -364,6 +365,29 @@ public boolean testCompatibility(String subject, ParsedSchema newSchema) throws\n           schemaMetadata.getId()));\n     }\n \n+    return newSchema.isCompatible(compatibilityLevel, schemaHistory).isEmpty();\n+  }\n+\n+  @Override\n+  public List<String> testCompatibilityVerbose(String subject, ParsedSchema newSchema)\n+          throws IOException, RestClientException {\n+    String compatibility = compatibilityCache.get(subject);\n+    if (compatibility == null) {\n+      compatibility = defaultCompatibility;\n+    }\n+\n+    CompatibilityLevel compatibilityLevel = CompatibilityLevel.forName(compatibility);\n+    if (compatibilityLevel == null) {\n+      return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java\nindex 7a66ed1b0..13aa97fac 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/MockSchemaRegistryClient.java\n\n@@ -378,7 +378,7 @@ public class MockSchemaRegistryClient implements SchemaRegistryClient {\n \n     CompatibilityLevel compatibilityLevel = CompatibilityLevel.forName(compatibility);\n     if (compatibilityLevel == null) {\n-      return new LinkedList<>(Arrays.asList(\"Compatibility level not specify.\"));\n+      return new LinkedList<>(Arrays.asList(\"Compatibility level not specified.\"));\n     }\n \n     List<ParsedSchema> schemaHistory = new ArrayList<>();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Mzc3Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485083772", "bodyText": "I guess this could be put in common with the existing compatibility check rest call from the testCompatibility method.\nAlso adding a new field to the response should not break compatibility so maybe we could remove the queryParam. WDYT ?\nCC @rayokota", "author": "ImFlog", "createdAt": "2020-09-08T17:28:47Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java", "diffHunk": "@@ -549,6 +549,47 @@ public boolean testCompatibility(Map<String, String> requestProperties,\n     return response.getIsCompatible();\n   }\n \n+  public List<String> testCompatibilityVerbose(String schemaString,\n+                                               String schemaType,\n+                                               List<SchemaReference> references,\n+                                               String subject,\n+                                               String version)\n+      throws IOException, RestClientException {\n+    RegisterSchemaRequest request = new RegisterSchemaRequest();\n+    request.setSchema(schemaString);\n+    request.setSchemaType(schemaType);\n+    request.setReferences(references);\n+    return testCompatibilityVerbose(request, subject, version);\n+  }\n+\n+  public List<String> testCompatibilityVerbose(RegisterSchemaRequest registerSchemaRequest,\n+                                               String subject,\n+                                               String version)\n+      throws IOException, RestClientException {\n+    return testCompatibilityVerbose(\n+        DEFAULT_REQUEST_PROPERTIES, registerSchemaRequest, subject, version);\n+  }\n+\n+  public List<String> testCompatibilityVerbose(Map<String, String> requestProperties,\n+                                               RegisterSchemaRequest registerSchemaRequest,\n+                                               String subject,\n+                                               String version)\n+      throws IOException, RestClientException {\n+    UriBuilder builder =\n+        UriBuilder.fromPath(\"/compatibility/subjects/{subject}/versions/{version}\");\n+    builder.queryParam(\"verbose\", true);\n+    String path = builder.build(subject, version).toString();\n+\n+    CompatibilityCheckResponse response =\n+        httpRequest(\n+            path,\n+            \"POST\",\n+            registerSchemaRequest.toJson().getBytes(StandardCharsets.UTF_8),\n+            requestProperties,\n+            COMPATIBILITY_CHECK_RESPONSE_TYPE_REFERENCE);", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIxMjU2Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485212562", "bodyText": "Unfortunately the CompatibilityCheckResponse was not declared with @JsonIgnoreProperties(ignoreUnknown = true) so older clients will break if we add a new field to the response.", "author": "rayokota", "createdAt": "2020-09-08T21:42:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Mzc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ2NDYwOQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485464609", "bodyText": "Oh yes, good catch.\nWe could add this annotation in the PR to avoid issues like this in the future ?", "author": "ImFlog", "createdAt": "2020-09-09T09:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4Mzc3Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java\nindex 6048a8458..a6c3ba62e 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/client/rest/RestService.java\n\n@@ -505,89 +505,57 @@ public class RestService implements Configurable {\n   }\n \n   // Visible for testing\n-  public boolean testCompatibility(String schemaString, String subject, String version)\n+  public List<String> testCompatibility(String schemaString, String subject, String version)\n       throws IOException, RestClientException {\n     RegisterSchemaRequest request = new RegisterSchemaRequest();\n     request.setSchema(schemaString);\n-    return testCompatibility(request, subject, version);\n+    return testCompatibility(request, subject, version, false);\n   }\n \n-  public boolean testCompatibility(String schemaString,\n-                                   String schemaType,\n-                                   List<SchemaReference> references,\n-                                   String subject,\n-                                   String version)\n+  public List<String> testCompatibility(String schemaString,\n+                                        String schemaType,\n+                                        List<SchemaReference> references,\n+                                        String subject,\n+                                        String version,\n+                                        boolean verbose)\n       throws IOException, RestClientException {\n     RegisterSchemaRequest request = new RegisterSchemaRequest();\n     request.setSchema(schemaString);\n     request.setSchemaType(schemaType);\n     request.setReferences(references);\n-    return testCompatibility(request, subject, version);\n+    return testCompatibility(request, subject, version, verbose);\n   }\n \n-  public boolean testCompatibility(RegisterSchemaRequest registerSchemaRequest,\n-                                   String subject,\n-                                   String version)\n+  public List<String> testCompatibility(RegisterSchemaRequest registerSchemaRequest,\n+                                        String subject,\n+                                        String version,\n+                                        boolean verbose)\n       throws IOException, RestClientException {\n     return testCompatibility(DEFAULT_REQUEST_PROPERTIES, registerSchemaRequest,\n-                             subject, version);\n+                             subject, version, verbose);\n   }\n \n-  public boolean testCompatibility(Map<String, String> requestProperties,\n-                                   RegisterSchemaRequest registerSchemaRequest,\n-                                   String subject,\n-                                   String version)\n+  public List<String> testCompatibility(Map<String, String> requestProperties,\n+                                        RegisterSchemaRequest registerSchemaRequest,\n+                                        String subject,\n+                                        String version,\n+                                        boolean verbose)\n       throws IOException, RestClientException {\n     UriBuilder builder = UriBuilder.fromPath(\n         \"/compatibility/subjects/{subject}/versions/{version}\");\n+    builder.queryParam(\"verbose\", verbose);\n     String path = builder.build(subject, version).toString();\n \n     CompatibilityCheckResponse response =\n         httpRequest(path, \"POST\",\n                     registerSchemaRequest.toJson().getBytes(StandardCharsets.UTF_8),\n                     requestProperties, COMPATIBILITY_CHECK_RESPONSE_TYPE_REFERENCE);\n-    return response.getIsCompatible();\n-  }\n-\n-  public List<String> testCompatibilityVerbose(String schemaString,\n-                                               String schemaType,\n-                                               List<SchemaReference> references,\n-                                               String subject,\n-                                               String version)\n-      throws IOException, RestClientException {\n-    RegisterSchemaRequest request = new RegisterSchemaRequest();\n-    request.setSchema(schemaString);\n-    request.setSchemaType(schemaType);\n-    request.setReferences(references);\n-    return testCompatibilityVerbose(request, subject, version);\n-  }\n-\n-  public List<String> testCompatibilityVerbose(RegisterSchemaRequest registerSchemaRequest,\n-                                               String subject,\n-                                               String version)\n-      throws IOException, RestClientException {\n-    return testCompatibilityVerbose(\n-        DEFAULT_REQUEST_PROPERTIES, registerSchemaRequest, subject, version);\n-  }\n-\n-  public List<String> testCompatibilityVerbose(Map<String, String> requestProperties,\n-                                               RegisterSchemaRequest registerSchemaRequest,\n-                                               String subject,\n-                                               String version)\n-      throws IOException, RestClientException {\n-    UriBuilder builder =\n-        UriBuilder.fromPath(\"/compatibility/subjects/{subject}/versions/{version}\");\n-    builder.queryParam(\"verbose\", true);\n-    String path = builder.build(subject, version).toString();\n-\n-    CompatibilityCheckResponse response =\n-        httpRequest(\n-            path,\n-            \"POST\",\n-            registerSchemaRequest.toJson().getBytes(StandardCharsets.UTF_8),\n-            requestProperties,\n-            COMPATIBILITY_CHECK_RESPONSE_TYPE_REFERENCE);\n-    return response.getErrorMessages();\n+    if (verbose) {\n+      return response.getMessages();\n+    } else {\n+      return response.getIsCompatible()\n+              ? Collections.emptyList() : Collections.singletonList(\"Schemas are incompatible\");\n+    }\n   }\n \n   public ConfigUpdateRequest updateCompatibility(String compatibility, String subject)\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA4OTcxMA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485089710", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                  return Arrays.asList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T17:39:45Z", "path": "json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java", "diffHunk": "@@ -300,9 +302,9 @@ private static boolean isPrimitive(Object value) {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java b/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\nindex 4a4d95b4c..d9db8231e 100644\n--- a/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\n+++ b/json-schema-provider/src/main/java/io/confluent/kafka/schemaregistry/json/JsonSchema.java\n\n@@ -304,7 +303,7 @@ public class JsonSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     final List<Difference> differences = SchemaDiff.compare(\n         ((JsonSchema) previousSchema).rawSchema(),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MDU2Mg==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485090562", "bodyText": "You can move the two errorMessages.add(..) after the if / else block to remove the duplicated lines.", "author": "ImFlog", "createdAt": "2020-09-08T17:41:16Z", "path": "protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java", "diffHunk": "@@ -798,17 +800,22 @@ public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n+      List<String> errorMessages = new LinkedList<>();\n       for (Difference incompatibleDiff : incompatibleDiffs) {\n         if (first) {\n           // Log first incompatible change as warning\n           log.warn(\"Found incompatible change: {}\", incompatibleDiff);\n+          errorMessages.add(String.format(\"Found incompatible change: {}\", incompatibleDiff));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNDQ2NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485834464", "bodyText": "Good suggestion", "author": "rayokota", "createdAt": "2020-09-09T18:41:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA5MDU2Mg=="}], "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java b/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\nindex 27c7e70d0..74d1859f8 100644\n--- a/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\n+++ b/protobuf-provider/src/main/java/io/confluent/kafka/schemaregistry/protobuf/ProtobufSchema.java\n\n@@ -800,7 +798,7 @@ public class ProtobufSchema implements ParsedSchema {\n     boolean isCompatible = incompatibleDiffs.isEmpty();\n     if (!isCompatible) {\n       boolean first = true;\n-      List<String> errorMessages = new LinkedList<>();\n+      List<String> errorMessages = new ArrayList<>();\n       for (Difference incompatibleDiff : incompatibleDiffs) {\n         if (first) {\n           // Log first incompatible change as warning\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MTI4NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485141284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                    return Collections.singletonList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T19:16:38Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java", "diffHunk": "@@ -95,13 +97,14 @@ default void validate() {\n    *\n    * @param level the compatibility level\n    * @param previousSchemas full schema history in chronological order\n-   * @return whether this schema is compatible with the previous schemas\n+   * @return an empty list if this schema is backward compatible with the previous schema, otherwise\n+   *         the list of error messages\n    */\n-  default boolean isCompatible(CompatibilityLevel level,\n-                               List<? extends ParsedSchema> previousSchemas) {\n+  default List<String> isCompatible(\n+      CompatibilityLevel level, List<? extends ParsedSchema> previousSchemas) {\n     for (ParsedSchema previousSchema : previousSchemas) {\n       if (!schemaType().equals(previousSchema.schemaType())) {\n-        return false;\n+        return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bbff6869be4edc038c057c2cfbe9ec21ab724657", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java\nindex 696061623..69942a9bb 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java\n\n@@ -104,7 +103,7 @@ public interface ParsedSchema {\n       CompatibilityLevel level, List<? extends ParsedSchema> previousSchemas) {\n     for (ParsedSchema previousSchema : previousSchemas) {\n       if (!schemaType().equals(previousSchema.schemaType())) {\n-        return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+        return Collections.singletonList(\"Incompatible because of different schema type\");\n       }\n     }\n     return CompatibilityChecker.checker(level).isCompatible(this, previousSchemas);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE0MjAzNA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485142034", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n          \n          \n            \n                  return Collections.singletonList(\"Incompatible because of different schema type\");", "author": "ImFlog", "createdAt": "2020-09-08T19:18:14Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +159,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "88416cfcecd87c2c5c5bff5c28f449b1c2540bd3", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex ad6d8e861..8b054d0c0 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -161,18 +159,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return new LinkedList<>(Arrays.asList(e.toString()));\n+      return Collections.singletonList(e.toString());\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return new LinkedList<>(Arrays.asList(\n-              String.format(\"Unexpected exception during compatibility check\", e)));\n+      return Collections.singletonList(\n+              \"Unexpected exception during compatibility check: \" + e.getMessage());\n     }\n   }\n \n"}}, {"oid": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "url": "https://github.com/confluentinc/schema-registry/commit/1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "message": "typo fix, style fix, add boolean verbose flag to RestService.testCompatibility() and tests update", "committedDate": "2020-09-08T22:06:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgyOTk2OA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485829968", "bodyText": "Use Collections.singletonList", "author": "rayokota", "createdAt": "2020-09-09T18:32:42Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java", "diffHunk": "@@ -95,13 +97,14 @@ default void validate() {\n    *\n    * @param level the compatibility level\n    * @param previousSchemas full schema history in chronological order\n-   * @return whether this schema is compatible with the previous schemas\n+   * @return an empty list if this schema is backward compatible with the previous schema, otherwise\n+   *         the list of error messages\n    */\n-  default boolean isCompatible(CompatibilityLevel level,\n-                               List<? extends ParsedSchema> previousSchemas) {\n+  default List<String> isCompatible(\n+      CompatibilityLevel level, List<? extends ParsedSchema> previousSchemas) {\n     for (ParsedSchema previousSchema : previousSchemas) {\n       if (!schemaType().equals(previousSchema.schemaType())) {\n-        return false;\n+        return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));", "originalCommit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "bbff6869be4edc038c057c2cfbe9ec21ab724657", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java\nindex 696061623..69942a9bb 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/ParsedSchema.java\n\n@@ -104,7 +103,7 @@ public interface ParsedSchema {\n       CompatibilityLevel level, List<? extends ParsedSchema> previousSchemas) {\n     for (ParsedSchema previousSchema : previousSchemas) {\n       if (!schemaType().equals(previousSchema.schemaType())) {\n-        return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n+        return Collections.singletonList(\"Incompatible because of different schema type\");\n       }\n     }\n     return CompatibilityChecker.checker(level).isCompatible(this, previousSchemas);\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzMDQyMw==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485830423", "bodyText": "e.toString -> e.getMessage", "author": "rayokota", "createdAt": "2020-09-09T18:33:34Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java", "diffHunk": "@@ -156,19 +157,20 @@ public Integer version() {\n   }\n \n   @Override\n-  public boolean isBackwardCompatible(ParsedSchema previousSchema) {\n+  public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return false;\n+      return Collections.singletonList(\"Incompatible because of different schema type\");\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n-      return true;\n+      return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return false;\n+      return Collections.singletonList(e.toString());", "originalCommit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be8b8e6981eb9d4161ea3dd7c65bb2e8df6e8415", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\nindex 8b054d0c0..ad6d8e861 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/avro/AvroSchema.java\n\n@@ -159,18 +161,18 @@ public class AvroSchema implements ParsedSchema {\n   @Override\n   public List<String> isBackwardCompatible(ParsedSchema previousSchema) {\n     if (!schemaType().equals(previousSchema.schemaType())) {\n-      return Collections.singletonList(\"Incompatible because of different schema type\");\n+      return new LinkedList<>(Arrays.asList(\"Incompatible because of different schema type\"));\n     }\n     try {\n       BACKWARD_VALIDATOR.validate(this.schemaObj,\n           Collections.singleton(((AvroSchema) previousSchema).schemaObj));\n       return Collections.emptyList();\n     } catch (SchemaValidationException e) {\n-      return Collections.singletonList(e.toString());\n+      return new LinkedList<>(Arrays.asList(e.toString()));\n     } catch (Exception e) {\n       log.error(\"Unexpected exception during compatibility check\", e);\n-      return Collections.singletonList(\n-              \"Unexpected exception during compatibility check: \" + e.getMessage());\n+      return new LinkedList<>(Arrays.asList(\n+              String.format(\"Unexpected exception during compatibility check\", e)));\n     }\n   }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgzNjM3NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1614#discussion_r485836374", "bodyText": "Checkstyle is complaining that this has the wrong indentation", "author": "rayokota", "createdAt": "2020-09-09T18:44:45Z", "path": "client/src/main/java/io/confluent/kafka/schemaregistry/CompatibilityChecker.java", "diffHunk": "@@ -63,7 +63,9 @@\n   public static final CompatibilityChecker FULL_TRANSITIVE_CHECKER = new CompatibilityChecker(\n       FULL_TRANSITIVE_VALIDATOR);\n \n-  private static final SchemaValidator NO_OP_VALIDATOR = (schema, schemas) -> true;\n+  private static final SchemaValidator NO_OP_VALIDATOR =\n+          (schema, schemas) -> Collections.emptyList();", "originalCommit": "1aba4bf7fd5d5b3448d192e11787196cc03b5c5d", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "be8b8e6981eb9d4161ea3dd7c65bb2e8df6e8415", "chunk": "diff --git a/client/src/main/java/io/confluent/kafka/schemaregistry/CompatibilityChecker.java b/client/src/main/java/io/confluent/kafka/schemaregistry/CompatibilityChecker.java\nindex 139eb4b9f..8bf6fca9a 100644\n--- a/client/src/main/java/io/confluent/kafka/schemaregistry/CompatibilityChecker.java\n+++ b/client/src/main/java/io/confluent/kafka/schemaregistry/CompatibilityChecker.java\n\n@@ -65,7 +65,6 @@ public class CompatibilityChecker {\n \n   private static final SchemaValidator NO_OP_VALIDATOR =\n           (schema, schemas) -> Collections.emptyList();\n-\n   public static final CompatibilityChecker NO_OP_CHECKER =\n       new CompatibilityChecker(NO_OP_VALIDATOR);\n \n"}}, {"oid": "be8b8e6981eb9d4161ea3dd7c65bb2e8df6e8415", "url": "https://github.com/confluentinc/schema-registry/commit/be8b8e6981eb9d4161ea3dd7c65bb2e8df6e8415", "message": "Revert style change; Use Collections.emptyList() to indicate is-compatible", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "edf5ec6f2a3ffed8a5e339b97bd904e2b637628b", "url": "https://github.com/confluentinc/schema-registry/commit/edf5ec6f2a3ffed8a5e339b97bd904e2b637628b", "message": "bugs fix", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "df0e2046c1acdf5109fd7b704098f75221bb9769", "url": "https://github.com/confluentinc/schema-registry/commit/df0e2046c1acdf5109fd7b704098f75221bb9769", "message": "add ?verbose queryparam to CompatibilityResource.testCompatibilityBySubjectName()", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "0d127c093800206fd6623ad71a71223b0c4b1a0e", "url": "https://github.com/confluentinc/schema-registry/commit/0d127c093800206fd6623ad71a71223b0c4b1a0e", "message": "bug fix", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "a6cb68a6c2a3ba1f9689ebb361137f9ab2c90e6a", "url": "https://github.com/confluentinc/schema-registry/commit/a6cb68a6c2a3ba1f9689ebb361137f9ab2c90e6a", "message": "Revert style change; Use Collections.emptyList() to indicate is-compatible", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "785778a438c7589cd3d9e5c1ec7083f7bcc55bae", "url": "https://github.com/confluentinc/schema-registry/commit/785778a438c7589cd3d9e5c1ec7083f7bcc55bae", "message": "add ?verbose queryparam to CompatibilityResource.testCompatibilityBySubjectName()", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "8fd3cebb4c92955a982d8fb6c3358fe9c8ea553b", "url": "https://github.com/confluentinc/schema-registry/commit/8fd3cebb4c92955a982d8fb6c3358fe9c8ea553b", "message": "typo fix, style fix, add boolean verbose flag to RestService.testCompatibility() and tests update", "committedDate": "2020-09-09T20:02:40Z", "type": "commit"}, {"oid": "bbff6869be4edc038c057c2cfbe9ec21ab724657", "url": "https://github.com/confluentinc/schema-registry/commit/bbff6869be4edc038c057c2cfbe9ec21ab724657", "message": "fix indentation, bug fix", "committedDate": "2020-09-09T20:09:08Z", "type": "commit"}, {"oid": "bbff6869be4edc038c057c2cfbe9ec21ab724657", "url": "https://github.com/confluentinc/schema-registry/commit/bbff6869be4edc038c057c2cfbe9ec21ab724657", "message": "fix indentation, bug fix", "committedDate": "2020-09-09T20:09:08Z", "type": "forcePushed"}]}