{"pr_number": 1471, "pr_title": "Wrappers for AWS lambda tracing", "pr_createdAt": "2020-10-23T21:18:27Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471", "timeline": [{"oid": "4ad01d9afd9f03ea674576215014a9c6b7df74a3", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/4ad01d9afd9f03ea674576215014a9c6b7df74a3", "message": "wrappers for AWS lambda instrumentation", "committedDate": "2020-10-23T21:15:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDE0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511730149", "bodyText": "Thanks for handling the stream handlers :)", "author": "anuraaga", "createdAt": "2020-10-26T05:46:35Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {", "originalCommit": "4ad01d9afd9f03ea674576215014a9c6b7df74a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzODYyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511838621", "bodyText": ":)", "author": "kubawach", "createdAt": "2020-10-26T09:56:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDE0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "a4fe1be2462210361979ca6abb693a3dfb84e6d2", "chunk": "diff --git a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\nindex 361df94c11..3995cb3652 100644\n--- a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\n+++ b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\n\n@@ -53,22 +53,53 @@ public abstract class TracingRequestStreamHandler implements RequestStreamHandle\n   public final void handleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException {\n     Span span = tracer.startSpan(context, Kind.SERVER);\n-    Throwable error = null;\n     try (Scope ignored = tracer.startScope(span)) {\n-      doHandleRequest(input, output, context);\n+      doHandleRequest(input, new OutputStreamWrapper(output, span), context);\n     } catch (Throwable t) {\n-      error = t;\n-      throw t;\n-    } finally {\n-      if (error != null) {\n-        tracer.endExceptionally(span, error);\n-      } else {\n-        tracer.end(span);\n-      }\n+      tracer.endExceptionally(span, t);\n       OpenTelemetrySdk.getTracerManagement().forceFlush().join(1, TimeUnit.SECONDS);\n+      throw t;\n     }\n   }\n \n   protected abstract void doHandleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException;\n+\n+  private class OutputStreamWrapper extends OutputStream {\n+\n+    private final OutputStream delegate;\n+    private final Span span;\n+\n+    OutputStreamWrapper(OutputStream delegate, Span span) {\n+      this.delegate = delegate;\n+      this.span = span;\n+    }\n+\n+    @Override\n+    public void write(byte[] b) throws IOException {\n+      delegate.write(b);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+      delegate.write(b, off, len);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+      delegate.flush();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+      delegate.close();\n+      tracer.end(span);\n+      OpenTelemetrySdk.getTracerManagement().forceFlush().join(1, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+      delegate.write(b);\n+    }\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511730302", "bodyText": "I think we need to wrap OutputStream so the span is closed on OutputStream.close which could be asynchronous?", "author": "anuraaga", "createdAt": "2020-10-26T05:47:25Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import io.opentelemetry.context.Scope;\n+import io.opentelemetry.sdk.OpenTelemetrySdk;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.Span.Kind;\n+import io.opentelemetry.trace.Tracer;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * A base class similar to {@link RequestStreamHandler} but will automatically trace invocations of\n+ * {@link #doHandleRequest(InputStream input, OutputStream output, Context)}.\n+ */\n+public abstract class TracingRequestStreamHandler implements RequestStreamHandler {\n+\n+  private final AwsLambdaTracer tracer;\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the default {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler() {\n+    this.tracer = new AwsLambdaTracer();\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * Tracer}.\n+   */\n+  protected TracingRequestStreamHandler(Tracer tracer) {\n+    this.tracer = new AwsLambdaTracer(tracer);\n+  }\n+\n+  /**\n+   * Creates a new {@link TracingRequestStreamHandler} which traces using the specified {@link\n+   * AwsLambdaTracer}.\n+   */\n+  protected TracingRequestStreamHandler(AwsLambdaTracer tracer) {\n+    this.tracer = tracer;\n+  }\n+\n+  @Override\n+  public final void handleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+    Span span = tracer.startSpan(context, Kind.SERVER);\n+    Throwable error = null;\n+    try (Scope ignored = tracer.startScope(span)) {\n+      doHandleRequest(input, output, context);", "originalCommit": "4ad01d9afd9f03ea674576215014a9c6b7df74a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgzODUxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511838519", "bodyText": "It's an option I considered. However now, with span issued on lambda exit, stream handler behaves exactly as \"no stream\" counterpart. In particular, the span gets send even if underlying output stream flush fails - I understand that in the case of RequestHandler implementations serialization / writing happens after the lambda exits. So with this implementation we have similar behaviour in both cases. What do you think?", "author": "kubawach", "createdAt": "2020-10-26T09:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTg0OTAwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511849004", "bodyText": "I don't know the details of lambda well but does it not allow something like\nCompletableFuture<Foo> response = backend.getFoo();\n\nresponse.thenAccept(writeToOutputStream);\n\nIf this is allowed than I think we need to make sure the span survives until the output is closed since that's the length of the request and how we generally model async requests.", "author": "anuraaga", "createdAt": "2020-10-26T10:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkwMTM0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511901341", "bodyText": "With this in mind, the idea totally makes sense. Will wrap OOS then :)", "author": "kubawach", "createdAt": "2020-10-26T11:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDMwMg=="}], "type": "inlineReview", "revised_code": {"commit": "a4fe1be2462210361979ca6abb693a3dfb84e6d2", "chunk": "diff --git a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\nindex 361df94c11..3995cb3652 100644\n--- a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\n+++ b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\n\n@@ -53,22 +53,53 @@ public abstract class TracingRequestStreamHandler implements RequestStreamHandle\n   public final void handleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException {\n     Span span = tracer.startSpan(context, Kind.SERVER);\n-    Throwable error = null;\n     try (Scope ignored = tracer.startScope(span)) {\n-      doHandleRequest(input, output, context);\n+      doHandleRequest(input, new OutputStreamWrapper(output, span), context);\n     } catch (Throwable t) {\n-      error = t;\n-      throw t;\n-    } finally {\n-      if (error != null) {\n-        tracer.endExceptionally(span, error);\n-      } else {\n-        tracer.end(span);\n-      }\n+      tracer.endExceptionally(span, t);\n       OpenTelemetrySdk.getTracerManagement().forceFlush().join(1, TimeUnit.SECONDS);\n+      throw t;\n     }\n   }\n \n   protected abstract void doHandleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException;\n+\n+  private class OutputStreamWrapper extends OutputStream {\n+\n+    private final OutputStream delegate;\n+    private final Span span;\n+\n+    OutputStreamWrapper(OutputStream delegate, Span span) {\n+      this.delegate = delegate;\n+      this.span = span;\n+    }\n+\n+    @Override\n+    public void write(byte[] b) throws IOException {\n+      delegate.write(b);\n+    }\n+\n+    @Override\n+    public void write(byte[] b, int off, int len) throws IOException {\n+      delegate.write(b, off, len);\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+      delegate.flush();\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+      delegate.close();\n+      tracer.end(span);\n+      OpenTelemetrySdk.getTracerManagement().forceFlush().join(1, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void write(int b) throws IOException {\n+      delegate.write(b);\n+    }\n+  }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDU5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511730599", "bodyText": "I wonder if we should just make this static since the configuration is?", "author": "anuraaga", "createdAt": "2020-10-26T05:48:36Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.services.lambda.runtime.Context;\n+import com.amazonaws.services.lambda.runtime.RequestStreamHandler;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * Wrapper for {@link TracingRequestStreamHandler}. Allows for wrapping a regular lambda, enabling\n+ * single span tracing. Main lambda class should be configured as env property OTEL_LAMBDA_HANDLER\n+ * in package.ClassName::methodName format. Lambda class must implement {@link\n+ * RequestStreamHandler}.\n+ */\n+public class TracingRequestStreamWrapper extends TracingRequestStreamHandler {\n+\n+  private WrappedLambda wrappedLambda;\n+\n+  @Override\n+  protected void doHandleRequest(InputStream input, OutputStream output, Context context)\n+      throws IOException {\n+\n+    if (wrappedLambda == null) {", "originalCommit": "4ad01d9afd9f03ea674576215014a9c6b7df74a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTgyNDY2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1471#discussion_r511824666", "bodyText": "Good idea, changed.", "author": "kubawach", "createdAt": "2020-10-26T09:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTczMDU5OQ=="}], "type": "inlineReview", "revised_code": {"commit": "9083eb25e4af459552a4b3af303a35528ec53dee", "chunk": "diff --git a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java\nindex 76c8cedb76..513bc00cf4 100644\n--- a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java\n+++ b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamWrapper.java\n\n@@ -19,20 +19,16 @@ import java.io.OutputStream;\n  */\n public class TracingRequestStreamWrapper extends TracingRequestStreamHandler {\n \n-  private WrappedLambda wrappedLambda;\n+  private static final WrappedLambda WRAPPED_LAMBDA = WrappedLambda.fromConfiguration();\n \n   @Override\n   protected void doHandleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException {\n \n-    if (wrappedLambda == null) {\n-      wrappedLambda = WrappedLambda.fromConfiguration();\n-    }\n-\n-    if (!(wrappedLambda.getTargetObject() instanceof RequestStreamHandler)) {\n+    if (!(WRAPPED_LAMBDA.getTargetObject() instanceof RequestStreamHandler)) {\n       throw new RuntimeException(\n-          wrappedLambda.getTargetClass().getName() + \" is not an instance of RequestStreamHandler\");\n+          WRAPPED_LAMBDA.getTargetClass().getName() + \" is not an instance of RequestStreamHandler\");\n     }\n-    ((RequestStreamHandler) wrappedLambda.getTargetObject()).handleRequest(input, output, context);\n+    ((RequestStreamHandler) WRAPPED_LAMBDA.getTargetObject()).handleRequest(input, output, context);\n   }\n }\n"}}, {"oid": "9083eb25e4af459552a4b3af303a35528ec53dee", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9083eb25e4af459552a4b3af303a35528ec53dee", "message": "code review changes", "committedDate": "2020-10-26T10:01:53Z", "type": "commit"}, {"oid": "a4fe1be2462210361979ca6abb693a3dfb84e6d2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a4fe1be2462210361979ca6abb693a3dfb84e6d2", "message": "code review changes", "committedDate": "2020-10-26T12:13:54Z", "type": "commit"}]}