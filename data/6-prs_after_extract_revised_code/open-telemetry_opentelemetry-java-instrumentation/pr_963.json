{"pr_number": 963, "pr_title": "add some JMS attributes", "pr_createdAt": "2020-08-13T15:36:20Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963", "timeline": [{"oid": "0391a06e0d9f6a24f5ed5fb8404f3f4715ca309c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0391a06e0d9f6a24f5ed5fb8404f3f4715ca309c", "message": "add some JMS attributes\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-08-13T15:35:57Z", "type": "commit"}, {"oid": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/11d3e435bf71d8e0c2006019b71a26b11f6a169b", "message": "remove semicolon\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-08-13T15:48:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODIzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470208239", "bodyText": "i think good to narrow down the try/catch, and log exception at debug level\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  try {\n          \n          \n            \n                    String messageID = message.getJMSMessageID();\n          \n          \n            \n                    if (messageID != null) {\n          \n          \n            \n                      SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n          \n          \n            \n                    }\n          \n          \n            \n                  } catch (JMSException e) {\n          \n          \n            \n                  }\n          \n          \n            \n                  String messageID = null;\n          \n          \n            \n                  try {\n          \n          \n            \n                    messageID = message.getJMSMessageID();\n          \n          \n            \n                  } catch (JMSException e) {\n          \n          \n            \n                    log.debug(e.getMessage(), e);\n          \n          \n            \n                  }\n          \n          \n            \n                  if (messageID != null) {\n          \n          \n            \n                    SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n          \n          \n            \n                  }", "author": "trask", "createdAt": "2020-08-13T19:51:01Z", "path": "instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java", "diffHunk": "@@ -80,4 +83,35 @@ public static String toSpanName(Destination destination) {\n     }\n     return \"destination\";\n   }\n+\n+  public void afterStart(Span span, String spanName, Message message) {\n+    if (spanName.startsWith(\"queue/\")) {\n+      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"queue\");\n+      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"queue/\", \"\"));\n+    } else if (spanName.startsWith(\"topic/\")) {\n+      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"topic\");\n+      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"topic/\", \"\"));\n+    }\n+    if (spanName.equals(\"queue/<temporary>\") || spanName.equals(\"topic/<temporary>\")) {\n+      SemanticAttributes.MESSAGING_TEMP_DESTINATION.set(span, true);\n+    }\n+\n+    if (message != null) {\n+      try {\n+        String messageID = message.getJMSMessageID();\n+        if (messageID != null) {\n+          SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n+        }\n+      } catch (JMSException e) {\n+      }", "originalCommit": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUzMjI0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470532249", "bodyText": "done", "author": "malafeev", "createdAt": "2020-08-14T10:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODIzOQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "chunk": "diff --git a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java b/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java\ndeleted file mode 100644\nindex b1c332a564..0000000000\n--- a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-/*\n- * Copyright The OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.auto.instrumentation.jms;\n-\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.instrumentation.api.decorator.ClientDecorator;\n-import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Tracer;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.Queue;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.Topic;\n-\n-public class JMSDecorator extends ClientDecorator {\n-  public static final JMSDecorator DECORATE = new JMSDecorator();\n-\n-  public static final Tracer TRACER =\n-      OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto.jms-1.1\");\n-\n-  public String spanNameForReceive(final Message message) {\n-    return toSpanName(message, null);\n-  }\n-\n-  public String spanNameForConsumer(final Message message) {\n-    return toSpanName(message, null);\n-  }\n-\n-  public String spanNameForProducer(final Message message, final Destination destination) {\n-    return toSpanName(message, destination);\n-  }\n-\n-  private static final String TIBCO_TMP_PREFIX = \"$TMP$\";\n-\n-  public static String toSpanName(final Message message, final Destination destination) {\n-    Destination jmsDestination = null;\n-    try {\n-      jmsDestination = message.getJMSDestination();\n-    } catch (final Exception e) {\n-    }\n-    if (jmsDestination == null) {\n-      jmsDestination = destination;\n-    }\n-    return toSpanName(jmsDestination);\n-  }\n-\n-  public static String toSpanName(Destination destination) {\n-    try {\n-      if (destination instanceof Queue) {\n-        String queueName = ((Queue) destination).getQueueName();\n-        if (destination instanceof TemporaryQueue || queueName.startsWith(TIBCO_TMP_PREFIX)) {\n-          return \"queue/<temporary>\";\n-        } else {\n-          return \"queue/\" + queueName;\n-        }\n-      }\n-      if (destination instanceof Topic) {\n-        String topicName = ((Topic) destination).getTopicName();\n-        if (destination instanceof TemporaryTopic || topicName.startsWith(TIBCO_TMP_PREFIX)) {\n-          return \"topic/<temporary>\";\n-        } else {\n-          return \"topic/\" + topicName;\n-        }\n-      }\n-    } catch (final Exception e) {\n-    }\n-    return \"destination\";\n-  }\n-\n-  public void afterStart(Span span, String spanName, Message message) {\n-    if (spanName.startsWith(\"queue/\")) {\n-      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"queue\");\n-      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"queue/\", \"\"));\n-    } else if (spanName.startsWith(\"topic/\")) {\n-      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"topic\");\n-      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"topic/\", \"\"));\n-    }\n-    if (spanName.equals(\"queue/<temporary>\") || spanName.equals(\"topic/<temporary>\")) {\n-      SemanticAttributes.MESSAGING_TEMP_DESTINATION.set(span, true);\n-    }\n-\n-    if (message != null) {\n-      try {\n-        String messageID = message.getJMSMessageID();\n-        if (messageID != null) {\n-          SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n-        }\n-      } catch (JMSException e) {\n-      }\n-\n-      try {\n-        String correlationID = message.getJMSCorrelationID();\n-        if (correlationID != null) {\n-          SemanticAttributes.MESSAGING_CONVERSATION_ID.set(span, correlationID);\n-        }\n-      } catch (JMSException e) {\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODM1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470208357", "bodyText": "same here", "author": "trask", "createdAt": "2020-08-13T19:51:14Z", "path": "instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java", "diffHunk": "@@ -80,4 +83,35 @@ public static String toSpanName(Destination destination) {\n     }\n     return \"destination\";\n   }\n+\n+  public void afterStart(Span span, String spanName, Message message) {\n+    if (spanName.startsWith(\"queue/\")) {\n+      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"queue\");\n+      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"queue/\", \"\"));\n+    } else if (spanName.startsWith(\"topic/\")) {\n+      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"topic\");\n+      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"topic/\", \"\"));\n+    }\n+    if (spanName.equals(\"queue/<temporary>\") || spanName.equals(\"topic/<temporary>\")) {\n+      SemanticAttributes.MESSAGING_TEMP_DESTINATION.set(span, true);\n+    }\n+\n+    if (message != null) {\n+      try {\n+        String messageID = message.getJMSMessageID();\n+        if (messageID != null) {\n+          SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n+        }\n+      } catch (JMSException e) {\n+      }\n+\n+      try {\n+        String correlationID = message.getJMSCorrelationID();\n+        if (correlationID != null) {\n+          SemanticAttributes.MESSAGING_CONVERSATION_ID.set(span, correlationID);\n+        }\n+      } catch (JMSException e) {\n+      }", "originalCommit": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "chunk": "diff --git a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java b/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java\ndeleted file mode 100644\nindex b1c332a564..0000000000\n--- a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-/*\n- * Copyright The OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.auto.instrumentation.jms;\n-\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.instrumentation.api.decorator.ClientDecorator;\n-import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Tracer;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.Queue;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.Topic;\n-\n-public class JMSDecorator extends ClientDecorator {\n-  public static final JMSDecorator DECORATE = new JMSDecorator();\n-\n-  public static final Tracer TRACER =\n-      OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto.jms-1.1\");\n-\n-  public String spanNameForReceive(final Message message) {\n-    return toSpanName(message, null);\n-  }\n-\n-  public String spanNameForConsumer(final Message message) {\n-    return toSpanName(message, null);\n-  }\n-\n-  public String spanNameForProducer(final Message message, final Destination destination) {\n-    return toSpanName(message, destination);\n-  }\n-\n-  private static final String TIBCO_TMP_PREFIX = \"$TMP$\";\n-\n-  public static String toSpanName(final Message message, final Destination destination) {\n-    Destination jmsDestination = null;\n-    try {\n-      jmsDestination = message.getJMSDestination();\n-    } catch (final Exception e) {\n-    }\n-    if (jmsDestination == null) {\n-      jmsDestination = destination;\n-    }\n-    return toSpanName(jmsDestination);\n-  }\n-\n-  public static String toSpanName(Destination destination) {\n-    try {\n-      if (destination instanceof Queue) {\n-        String queueName = ((Queue) destination).getQueueName();\n-        if (destination instanceof TemporaryQueue || queueName.startsWith(TIBCO_TMP_PREFIX)) {\n-          return \"queue/<temporary>\";\n-        } else {\n-          return \"queue/\" + queueName;\n-        }\n-      }\n-      if (destination instanceof Topic) {\n-        String topicName = ((Topic) destination).getTopicName();\n-        if (destination instanceof TemporaryTopic || topicName.startsWith(TIBCO_TMP_PREFIX)) {\n-          return \"topic/<temporary>\";\n-        } else {\n-          return \"topic/\" + topicName;\n-        }\n-      }\n-    } catch (final Exception e) {\n-    }\n-    return \"destination\";\n-  }\n-\n-  public void afterStart(Span span, String spanName, Message message) {\n-    if (spanName.startsWith(\"queue/\")) {\n-      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"queue\");\n-      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"queue/\", \"\"));\n-    } else if (spanName.startsWith(\"topic/\")) {\n-      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"topic\");\n-      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"topic/\", \"\"));\n-    }\n-    if (spanName.equals(\"queue/<temporary>\") || spanName.equals(\"topic/<temporary>\")) {\n-      SemanticAttributes.MESSAGING_TEMP_DESTINATION.set(span, true);\n-    }\n-\n-    if (message != null) {\n-      try {\n-        String messageID = message.getJMSMessageID();\n-        if (messageID != null) {\n-          SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n-        }\n-      } catch (JMSException e) {\n-      }\n-\n-      try {\n-        String correlationID = message.getJMSCorrelationID();\n-        if (correlationID != null) {\n-          SemanticAttributes.MESSAGING_CONVERSATION_ID.set(span, correlationID);\n-        }\n-      } catch (JMSException e) {\n-      }\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODkyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470208928", "bodyText": "and call super.afterStart(span) from inside afterStart(Span, String, Message)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  DECORATE.afterStart(span);\n          \n          \n            \n                  DECORATE.afterStart(span, spanName, message);\n          \n          \n            \n                  DECORATE.afterStart(span, spanName, message);", "author": "trask", "createdAt": "2020-08-13T19:52:29Z", "path": "instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageListenerInstrumentation.java", "diffHunk": "@@ -79,12 +79,13 @@ public JMSMessageListenerInstrumentation() {\n     @Advice.OnMethodEnter(suppress = Throwable.class)\n     public static SpanWithScope onEnter(@Advice.Argument(0) final Message message) {\n \n-      Span.Builder spanBuilder =\n-          TRACER.spanBuilder(DECORATE.spanNameForConsumer(message)).setSpanKind(CONSUMER);\n+      final String spanName = DECORATE.spanNameForConsumer(message);\n+      Span.Builder spanBuilder = TRACER.spanBuilder(spanName).setSpanKind(CONSUMER);\n       spanBuilder.setParent(extract(message, GETTER));\n \n       Span span = spanBuilder.startSpan();\n       DECORATE.afterStart(span);\n+      DECORATE.afterStart(span, spanName, message);", "originalCommit": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUzMjMxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470532311", "bodyText": "done", "author": "malafeev", "createdAt": "2020-08-14T10:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODkyOA=="}], "type": "inlineReview", "revised_code": {"commit": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "chunk": "diff --git a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageListenerInstrumentation.java b/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageListenerInstrumentation.java\ndeleted file mode 100644\nindex a60ff08214..0000000000\n--- a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageListenerInstrumentation.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-/*\n- * Copyright The OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.auto.instrumentation.jms;\n-\n-import static io.opentelemetry.auto.instrumentation.jms.JMSDecorator.DECORATE;\n-import static io.opentelemetry.auto.instrumentation.jms.JMSDecorator.TRACER;\n-import static io.opentelemetry.auto.instrumentation.jms.MessageExtractAdapter.GETTER;\n-import static io.opentelemetry.auto.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.auto.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static io.opentelemetry.instrumentation.api.decorator.BaseDecorator.extract;\n-import static io.opentelemetry.trace.Span.Kind.CONSUMER;\n-import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n-import static java.util.Collections.singletonMap;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.named;\n-import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n-\n-import com.google.auto.service.AutoService;\n-import io.opentelemetry.auto.tooling.Instrumenter;\n-import io.opentelemetry.instrumentation.auto.api.SpanWithScope;\n-import io.opentelemetry.trace.Span;\n-import java.util.Map;\n-import javax.jms.Message;\n-import net.bytebuddy.asm.Advice;\n-import net.bytebuddy.description.method.MethodDescription;\n-import net.bytebuddy.description.type.TypeDescription;\n-import net.bytebuddy.matcher.ElementMatcher;\n-\n-@AutoService(Instrumenter.class)\n-public final class JMSMessageListenerInstrumentation extends Instrumenter.Default {\n-\n-  public JMSMessageListenerInstrumentation() {\n-    super(\"jms\", \"jms-1\", \"jms-2\");\n-  }\n-\n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return hasClassesNamed(\"javax.jms.MessageListener\");\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return implementsInterface(named(\"javax.jms.MessageListener\"));\n-  }\n-\n-  @Override\n-  public String[] helperClassNames() {\n-    return new String[] {\n-      packageName + \".JMSDecorator\",\n-      packageName + \".MessageExtractAdapter\",\n-      packageName + \".MessageInjectAdapter\"\n-    };\n-  }\n-\n-  @Override\n-  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return singletonMap(\n-        named(\"onMessage\").and(takesArgument(0, named(\"javax.jms.Message\"))).and(isPublic()),\n-        JMSMessageListenerInstrumentation.class.getName() + \"$MessageListenerAdvice\");\n-  }\n-\n-  public static class MessageListenerAdvice {\n-\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope onEnter(@Advice.Argument(0) final Message message) {\n-\n-      final String spanName = DECORATE.spanNameForConsumer(message);\n-      Span.Builder spanBuilder = TRACER.spanBuilder(spanName).setSpanKind(CONSUMER);\n-      spanBuilder.setParent(extract(message, GETTER));\n-\n-      Span span = spanBuilder.startSpan();\n-      DECORATE.afterStart(span);\n-      DECORATE.afterStart(span, spanName, message);\n-\n-      return new SpanWithScope(span, currentContextWith(span));\n-    }\n-\n-    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n-    public static void stopSpan(\n-        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n-      if (spanWithScope == null) {\n-        return;\n-      }\n-      Span span = spanWithScope.getSpan();\n-      DECORATE.onError(span, throwable);\n-      DECORATE.beforeFinish(span);\n-      span.end();\n-      spanWithScope.closeScope();\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwOTA2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470209068", "bodyText": "same", "author": "trask", "createdAt": "2020-08-13T19:52:43Z", "path": "instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java", "diffHunk": "@@ -105,12 +105,10 @@ public static SpanWithScope onEnter(\n         defaultDestination = null;\n       }\n \n-      Span span =\n-          TRACER\n-              .spanBuilder(DECORATE.spanNameForProducer(message, defaultDestination))\n-              .setSpanKind(PRODUCER)\n-              .startSpan();\n+      final String spanName = DECORATE.spanNameForProducer(message, defaultDestination);\n+      Span span = TRACER.spanBuilder(spanName).setSpanKind(PRODUCER).startSpan();\n       DECORATE.afterStart(span);\n+      DECORATE.afterStart(span, spanName, message);", "originalCommit": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUzMjM3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470532370", "bodyText": "done", "author": "malafeev", "createdAt": "2020-08-14T10:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwOTA2OA=="}], "type": "inlineReview", "revised_code": {"commit": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "chunk": "diff --git a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java b/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java\ndeleted file mode 100644\nindex 144648243a..0000000000\n--- a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java\n+++ /dev/null\n\n@@ -1,174 +0,0 @@\n-/*\n- * Copyright The OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.auto.instrumentation.jms;\n-\n-import static io.opentelemetry.auto.instrumentation.jms.JMSDecorator.DECORATE;\n-import static io.opentelemetry.auto.instrumentation.jms.JMSDecorator.TRACER;\n-import static io.opentelemetry.auto.instrumentation.jms.MessageInjectAdapter.SETTER;\n-import static io.opentelemetry.auto.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.auto.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n-import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n-import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.named;\n-import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n-\n-import com.google.auto.service.AutoService;\n-import io.grpc.Context;\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.auto.tooling.Instrumenter;\n-import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap;\n-import io.opentelemetry.instrumentation.auto.api.SpanWithScope;\n-import io.opentelemetry.trace.Span;\n-import java.util.HashMap;\n-import java.util.Map;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageProducer;\n-import net.bytebuddy.asm.Advice;\n-import net.bytebuddy.description.method.MethodDescription;\n-import net.bytebuddy.description.type.TypeDescription;\n-import net.bytebuddy.matcher.ElementMatcher;\n-\n-@AutoService(Instrumenter.class)\n-public final class JMSMessageProducerInstrumentation extends Instrumenter.Default {\n-\n-  public JMSMessageProducerInstrumentation() {\n-    super(\"jms\", \"jms-1\", \"jms-2\");\n-  }\n-\n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return hasClassesNamed(\"javax.jms.MessageProducer\");\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return implementsInterface(named(\"javax.jms.MessageProducer\"));\n-  }\n-\n-  @Override\n-  public String[] helperClassNames() {\n-    return new String[] {\n-      packageName + \".JMSDecorator\",\n-      packageName + \".MessageExtractAdapter\",\n-      packageName + \".MessageInjectAdapter\"\n-    };\n-  }\n-\n-  @Override\n-  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n-    transformers.put(\n-        named(\"send\").and(takesArgument(0, named(\"javax.jms.Message\"))).and(isPublic()),\n-        JMSMessageProducerInstrumentation.class.getName() + \"$ProducerAdvice\");\n-    transformers.put(\n-        named(\"send\")\n-            .and(takesArgument(0, named(\"javax.jms.Destination\")))\n-            .and(takesArgument(1, named(\"javax.jms.Message\")))\n-            .and(isPublic()),\n-        JMSMessageProducerInstrumentation.class.getName() + \"$ProducerWithDestinationAdvice\");\n-    return transformers;\n-  }\n-\n-  public static class ProducerAdvice {\n-\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope onEnter(\n-        @Advice.Argument(0) final Message message, @Advice.This final MessageProducer producer) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(MessageProducer.class);\n-      if (callDepth > 0) {\n-        return null;\n-      }\n-\n-      Destination defaultDestination;\n-      try {\n-        defaultDestination = producer.getDestination();\n-      } catch (final JMSException e) {\n-        defaultDestination = null;\n-      }\n-\n-      final String spanName = DECORATE.spanNameForProducer(message, defaultDestination);\n-      Span span = TRACER.spanBuilder(spanName).setSpanKind(PRODUCER).startSpan();\n-      DECORATE.afterStart(span);\n-      DECORATE.afterStart(span, spanName, message);\n-\n-      Context context = withSpan(span, Context.current());\n-      OpenTelemetry.getPropagators().getHttpTextFormat().inject(context, message, SETTER);\n-\n-      return new SpanWithScope(span, currentContextWith(span));\n-    }\n-\n-    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n-    public static void stopSpan(\n-        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n-      if (spanWithScope == null) {\n-        return;\n-      }\n-      CallDepthThreadLocalMap.reset(MessageProducer.class);\n-\n-      Span span = spanWithScope.getSpan();\n-      DECORATE.onError(span, throwable);\n-      DECORATE.beforeFinish(span);\n-\n-      span.end();\n-      spanWithScope.closeScope();\n-    }\n-  }\n-\n-  public static class ProducerWithDestinationAdvice {\n-\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope onEnter(\n-        @Advice.Argument(0) final Destination destination,\n-        @Advice.Argument(1) final Message message) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(MessageProducer.class);\n-      if (callDepth > 0) {\n-        return null;\n-      }\n-\n-      final String spanName = DECORATE.spanNameForProducer(message, destination);\n-\n-      Span span = TRACER.spanBuilder(spanName).setSpanKind(PRODUCER).startSpan();\n-      DECORATE.afterStart(span);\n-      DECORATE.afterStart(span, spanName, message);\n-\n-      Context context = withSpan(span, Context.current());\n-      OpenTelemetry.getPropagators().getHttpTextFormat().inject(context, message, SETTER);\n-\n-      return new SpanWithScope(span, currentContextWith(span));\n-    }\n-\n-    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n-    public static void stopSpan(\n-        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n-      if (spanWithScope == null) {\n-        return;\n-      }\n-      CallDepthThreadLocalMap.reset(MessageProducer.class);\n-\n-      Span span = spanWithScope.getSpan();\n-      DECORATE.onError(span, throwable);\n-      DECORATE.beforeFinish(span);\n-      span.end();\n-      spanWithScope.closeScope();\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwOTE3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470209171", "bodyText": "same", "author": "trask", "createdAt": "2020-08-13T19:52:51Z", "path": "instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java", "diffHunk": "@@ -146,12 +144,11 @@ public static SpanWithScope onEnter(\n         return null;\n       }\n \n-      Span span =\n-          TRACER\n-              .spanBuilder(DECORATE.spanNameForProducer(message, destination))\n-              .setSpanKind(PRODUCER)\n-              .startSpan();\n+      final String spanName = DECORATE.spanNameForProducer(message, destination);\n+\n+      Span span = TRACER.spanBuilder(spanName).setSpanKind(PRODUCER).startSpan();\n       DECORATE.afterStart(span);\n+      DECORATE.afterStart(span, spanName, message);", "originalCommit": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUzMjQ3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470532470", "bodyText": "done", "author": "malafeev", "createdAt": "2020-08-14T10:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwOTE3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "chunk": "diff --git a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java b/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java\ndeleted file mode 100644\nindex 144648243a..0000000000\n--- a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSMessageProducerInstrumentation.java\n+++ /dev/null\n\n@@ -1,174 +0,0 @@\n-/*\n- * Copyright The OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.auto.instrumentation.jms;\n-\n-import static io.opentelemetry.auto.instrumentation.jms.JMSDecorator.DECORATE;\n-import static io.opentelemetry.auto.instrumentation.jms.JMSDecorator.TRACER;\n-import static io.opentelemetry.auto.instrumentation.jms.MessageInjectAdapter.SETTER;\n-import static io.opentelemetry.auto.tooling.ClassLoaderMatcher.hasClassesNamed;\n-import static io.opentelemetry.auto.tooling.bytebuddy.matcher.AgentElementMatchers.implementsInterface;\n-import static io.opentelemetry.trace.Span.Kind.PRODUCER;\n-import static io.opentelemetry.trace.TracingContextUtils.currentContextWith;\n-import static io.opentelemetry.trace.TracingContextUtils.withSpan;\n-import static net.bytebuddy.matcher.ElementMatchers.isPublic;\n-import static net.bytebuddy.matcher.ElementMatchers.named;\n-import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n-\n-import com.google.auto.service.AutoService;\n-import io.grpc.Context;\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.auto.tooling.Instrumenter;\n-import io.opentelemetry.instrumentation.auto.api.CallDepthThreadLocalMap;\n-import io.opentelemetry.instrumentation.auto.api.SpanWithScope;\n-import io.opentelemetry.trace.Span;\n-import java.util.HashMap;\n-import java.util.Map;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.MessageProducer;\n-import net.bytebuddy.asm.Advice;\n-import net.bytebuddy.description.method.MethodDescription;\n-import net.bytebuddy.description.type.TypeDescription;\n-import net.bytebuddy.matcher.ElementMatcher;\n-\n-@AutoService(Instrumenter.class)\n-public final class JMSMessageProducerInstrumentation extends Instrumenter.Default {\n-\n-  public JMSMessageProducerInstrumentation() {\n-    super(\"jms\", \"jms-1\", \"jms-2\");\n-  }\n-\n-  @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n-    // Optimization for expensive typeMatcher.\n-    return hasClassesNamed(\"javax.jms.MessageProducer\");\n-  }\n-\n-  @Override\n-  public ElementMatcher<TypeDescription> typeMatcher() {\n-    return implementsInterface(named(\"javax.jms.MessageProducer\"));\n-  }\n-\n-  @Override\n-  public String[] helperClassNames() {\n-    return new String[] {\n-      packageName + \".JMSDecorator\",\n-      packageName + \".MessageExtractAdapter\",\n-      packageName + \".MessageInjectAdapter\"\n-    };\n-  }\n-\n-  @Override\n-  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    Map<ElementMatcher<? super MethodDescription>, String> transformers = new HashMap<>();\n-    transformers.put(\n-        named(\"send\").and(takesArgument(0, named(\"javax.jms.Message\"))).and(isPublic()),\n-        JMSMessageProducerInstrumentation.class.getName() + \"$ProducerAdvice\");\n-    transformers.put(\n-        named(\"send\")\n-            .and(takesArgument(0, named(\"javax.jms.Destination\")))\n-            .and(takesArgument(1, named(\"javax.jms.Message\")))\n-            .and(isPublic()),\n-        JMSMessageProducerInstrumentation.class.getName() + \"$ProducerWithDestinationAdvice\");\n-    return transformers;\n-  }\n-\n-  public static class ProducerAdvice {\n-\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope onEnter(\n-        @Advice.Argument(0) final Message message, @Advice.This final MessageProducer producer) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(MessageProducer.class);\n-      if (callDepth > 0) {\n-        return null;\n-      }\n-\n-      Destination defaultDestination;\n-      try {\n-        defaultDestination = producer.getDestination();\n-      } catch (final JMSException e) {\n-        defaultDestination = null;\n-      }\n-\n-      final String spanName = DECORATE.spanNameForProducer(message, defaultDestination);\n-      Span span = TRACER.spanBuilder(spanName).setSpanKind(PRODUCER).startSpan();\n-      DECORATE.afterStart(span);\n-      DECORATE.afterStart(span, spanName, message);\n-\n-      Context context = withSpan(span, Context.current());\n-      OpenTelemetry.getPropagators().getHttpTextFormat().inject(context, message, SETTER);\n-\n-      return new SpanWithScope(span, currentContextWith(span));\n-    }\n-\n-    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n-    public static void stopSpan(\n-        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n-      if (spanWithScope == null) {\n-        return;\n-      }\n-      CallDepthThreadLocalMap.reset(MessageProducer.class);\n-\n-      Span span = spanWithScope.getSpan();\n-      DECORATE.onError(span, throwable);\n-      DECORATE.beforeFinish(span);\n-\n-      span.end();\n-      spanWithScope.closeScope();\n-    }\n-  }\n-\n-  public static class ProducerWithDestinationAdvice {\n-\n-    @Advice.OnMethodEnter(suppress = Throwable.class)\n-    public static SpanWithScope onEnter(\n-        @Advice.Argument(0) final Destination destination,\n-        @Advice.Argument(1) final Message message) {\n-      int callDepth = CallDepthThreadLocalMap.incrementCallDepth(MessageProducer.class);\n-      if (callDepth > 0) {\n-        return null;\n-      }\n-\n-      final String spanName = DECORATE.spanNameForProducer(message, destination);\n-\n-      Span span = TRACER.spanBuilder(spanName).setSpanKind(PRODUCER).startSpan();\n-      DECORATE.afterStart(span);\n-      DECORATE.afterStart(span, spanName, message);\n-\n-      Context context = withSpan(span, Context.current());\n-      OpenTelemetry.getPropagators().getHttpTextFormat().inject(context, message, SETTER);\n-\n-      return new SpanWithScope(span, currentContextWith(span));\n-    }\n-\n-    @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class)\n-    public static void stopSpan(\n-        @Advice.Enter final SpanWithScope spanWithScope, @Advice.Thrown final Throwable throwable) {\n-      if (spanWithScope == null) {\n-        return;\n-      }\n-      CallDepthThreadLocalMap.reset(MessageProducer.class);\n-\n-      Span span = spanWithScope.getSpan();\n-      DECORATE.onError(span, throwable);\n-      DECORATE.beforeFinish(span);\n-      span.end();\n-      spanWithScope.closeScope();\n-    }\n-  }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470237165", "bodyText": "when we move to the new Tracer design, and do both JMSDecorator.toSpanName() and afterStart() inside of startSpan, we can consolidate the conditionals between these two methods (and remove the startsWith logic)", "author": "trask", "createdAt": "2020-08-13T20:44:35Z", "path": "instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java", "diffHunk": "@@ -80,4 +83,35 @@ public static String toSpanName(Destination destination) {\n     }\n     return \"destination\";\n   }\n+\n+  public void afterStart(Span span, String spanName, Message message) {\n+    if (spanName.startsWith(\"queue/\")) {\n+      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"queue\");\n+      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"queue/\", \"\"));\n+    } else if (spanName.startsWith(\"topic/\")) {\n+      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"topic\");\n+      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"topic/\", \"\"));\n+    }\n+    if (spanName.equals(\"queue/<temporary>\") || spanName.equals(\"topic/<temporary>\")) {\n+      SemanticAttributes.MESSAGING_TEMP_DESTINATION.set(span, true);\n+    }", "originalCommit": "11d3e435bf71d8e0c2006019b71a26b11f6a169b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDUzMjgzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/963#discussion_r470532833", "bodyText": "yeah", "author": "malafeev", "createdAt": "2020-08-14T10:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "chunk": "diff --git a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java b/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java\ndeleted file mode 100644\nindex b1c332a564..0000000000\n--- a/instrumentation/jms-1.1/src/main/java/io/opentelemetry/auto/instrumentation/jms/JMSDecorator.java\n+++ /dev/null\n\n@@ -1,117 +0,0 @@\n-/*\n- * Copyright The OpenTelemetry Authors\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-\n-package io.opentelemetry.auto.instrumentation.jms;\n-\n-import io.opentelemetry.OpenTelemetry;\n-import io.opentelemetry.instrumentation.api.decorator.ClientDecorator;\n-import io.opentelemetry.trace.Span;\n-import io.opentelemetry.trace.Tracer;\n-import io.opentelemetry.trace.attributes.SemanticAttributes;\n-import javax.jms.Destination;\n-import javax.jms.JMSException;\n-import javax.jms.Message;\n-import javax.jms.Queue;\n-import javax.jms.TemporaryQueue;\n-import javax.jms.TemporaryTopic;\n-import javax.jms.Topic;\n-\n-public class JMSDecorator extends ClientDecorator {\n-  public static final JMSDecorator DECORATE = new JMSDecorator();\n-\n-  public static final Tracer TRACER =\n-      OpenTelemetry.getTracerProvider().get(\"io.opentelemetry.auto.jms-1.1\");\n-\n-  public String spanNameForReceive(final Message message) {\n-    return toSpanName(message, null);\n-  }\n-\n-  public String spanNameForConsumer(final Message message) {\n-    return toSpanName(message, null);\n-  }\n-\n-  public String spanNameForProducer(final Message message, final Destination destination) {\n-    return toSpanName(message, destination);\n-  }\n-\n-  private static final String TIBCO_TMP_PREFIX = \"$TMP$\";\n-\n-  public static String toSpanName(final Message message, final Destination destination) {\n-    Destination jmsDestination = null;\n-    try {\n-      jmsDestination = message.getJMSDestination();\n-    } catch (final Exception e) {\n-    }\n-    if (jmsDestination == null) {\n-      jmsDestination = destination;\n-    }\n-    return toSpanName(jmsDestination);\n-  }\n-\n-  public static String toSpanName(Destination destination) {\n-    try {\n-      if (destination instanceof Queue) {\n-        String queueName = ((Queue) destination).getQueueName();\n-        if (destination instanceof TemporaryQueue || queueName.startsWith(TIBCO_TMP_PREFIX)) {\n-          return \"queue/<temporary>\";\n-        } else {\n-          return \"queue/\" + queueName;\n-        }\n-      }\n-      if (destination instanceof Topic) {\n-        String topicName = ((Topic) destination).getTopicName();\n-        if (destination instanceof TemporaryTopic || topicName.startsWith(TIBCO_TMP_PREFIX)) {\n-          return \"topic/<temporary>\";\n-        } else {\n-          return \"topic/\" + topicName;\n-        }\n-      }\n-    } catch (final Exception e) {\n-    }\n-    return \"destination\";\n-  }\n-\n-  public void afterStart(Span span, String spanName, Message message) {\n-    if (spanName.startsWith(\"queue/\")) {\n-      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"queue\");\n-      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"queue/\", \"\"));\n-    } else if (spanName.startsWith(\"topic/\")) {\n-      SemanticAttributes.MESSAGING_DESTINATION_KIND.set(span, \"topic\");\n-      SemanticAttributes.MESSAGING_DESTINATION.set(span, spanName.replaceFirst(\"topic/\", \"\"));\n-    }\n-    if (spanName.equals(\"queue/<temporary>\") || spanName.equals(\"topic/<temporary>\")) {\n-      SemanticAttributes.MESSAGING_TEMP_DESTINATION.set(span, true);\n-    }\n-\n-    if (message != null) {\n-      try {\n-        String messageID = message.getJMSMessageID();\n-        if (messageID != null) {\n-          SemanticAttributes.MESSAGING_MESSAGE_ID.set(span, messageID);\n-        }\n-      } catch (JMSException e) {\n-      }\n-\n-      try {\n-        String correlationID = message.getJMSCorrelationID();\n-        if (correlationID != null) {\n-          SemanticAttributes.MESSAGING_CONVERSATION_ID.set(span, correlationID);\n-        }\n-      } catch (JMSException e) {\n-      }\n-    }\n-  }\n-}\n"}}, {"oid": "7c3814dc88381ac7bc5dffdbac4f1c444459791c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7c3814dc88381ac7bc5dffdbac4f1c444459791c", "message": "Merge remote-tracking branch 'upstream/master' into malafeev-merge", "committedDate": "2020-08-14T06:26:27Z", "type": "commit"}, {"oid": "0e1b4048007603408ae5e97eb11c229648384865", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0e1b4048007603408ae5e97eb11c229648384865", "message": "fix review comments\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-08-14T10:02:06Z", "type": "commit"}, {"oid": "9171eb07f7747a32001a79f8f69ff03ce8c3b9a2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/9171eb07f7747a32001a79f8f69ff03ce8c3b9a2", "message": "get rid of unused imports\n\nSigned-off-by: Sergei Malafeev <sergei@malafeev.org>", "committedDate": "2020-08-14T10:17:42Z", "type": "commit"}]}