{"pr_number": 1536, "pr_title": "AWS lambda instrumentation - HTTP context propagation", "pr_createdAt": "2020-10-30T20:36:48Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MDk0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r515740942", "bodyText": "This is unfortunate but seems to be the only way to support streams, oh well.\nFor non-streams, will we use the event types?\nhttps://github.com/aws/aws-lambda-java-libs/blob/master/aws-lambda-java-events/src/main/java/com/amazonaws/services/lambda/runtime/events/APIGatewayProxyRequestEvent.java", "author": "anuraaga", "createdAt": "2020-11-02T05:00:42Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.serverless.proxy.model.Headers;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n+import java.io.InputStream;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+class ApiGatewayProxyRequest {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ApiGatewayProxyRequest.class);\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  static {\n+    OBJECT_MAPPER.registerModule(new AfterburnerModule());\n+  }\n+\n+  private final Headers headers;\n+\n+  private ApiGatewayProxyRequest(Headers headers) {", "originalCommit": "90009c342b4472dc510792b43c75b7c3c1f150a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MjI1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r515742259", "bodyText": "Though I wonder if supporting stream is actually important. Looking at this, it seems like the body is encoded into JSON anyways so there is no benefit in the stream handler - so maybe it's a reasonable and practical limitation for us to just detect that event type?", "author": "anuraaga", "createdAt": "2020-11-02T05:07:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MDk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzAwMjUzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r517002534", "bodyText": "Yes, events for non-streams should be doable, at least at the wrapper level. Handler gets argument type from a child class so in this case afair it's not possible to get the headers if arg is not the event type (correct me if I'm wrong).\nWith regards to streams, now we have safeguards (only if propagators configured) and current implementation of the AWS proxy uses ButeArrayInputStream which is markable, so I'd say it's safe to leave it (as a drop-in method for customers already suing streams handler).\nIf you agree, we can merge this PR and I'll file another one for non-streams wrapper.", "author": "kubawach", "createdAt": "2020-11-03T22:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MDk0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "7df0bc081b4007b273876c67aec692b777efe345", "chunk": "diff --git a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java\nindex 086ebf0f2f..b3e78b34b6 100644\n--- a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java\n+++ b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java\n\n@@ -10,49 +10,111 @@ import com.fasterxml.jackson.core.JsonFactory;\n import com.fasterxml.jackson.core.JsonParser;\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n+import io.opentelemetry.api.OpenTelemetry;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n import java.io.InputStream;\n+import org.apache.commons.io.IOUtils;\n import org.checkerframework.checker.nullness.qual.Nullable;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-class ApiGatewayProxyRequest {\n+abstract class ApiGatewayProxyRequest {\n \n   private static final Logger log = LoggerFactory.getLogger(ApiGatewayProxyRequest.class);\n+\n   private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n \n   static {\n     OBJECT_MAPPER.registerModule(new AfterburnerModule());\n   }\n \n-  private final Headers headers;\n-\n-  private ApiGatewayProxyRequest(Headers headers) {\n-    this.headers = headers;\n+  private static boolean noHttpPropagationNeeded() {\n+    return OpenTelemetry.getGlobalPropagators().getTextMapPropagator().fields().isEmpty();\n   }\n \n-  static ApiGatewayProxyRequest ofInputStream(InputStream is) {\n+  static ApiGatewayProxyRequest forStream(final InputStream source) throws IOException {\n+\n+    if (noHttpPropagationNeeded()) {\n+      return new NoopRequest(source);\n+    }\n+\n+    if (source.markSupported()) {\n+      return new MarkableApiGatewayProxyRequest(source);\n+    }\n+    // fallback\n+    return new CopiedApiGatewayProxyRequest(source);\n+  }\n \n-    try (JsonParser jParser = new JsonFactory().createParser(is)) {\n+  @Nullable\n+  Headers getHeaders() {\n+    try (JsonParser jParser = new JsonFactory().createParser(freshStream())) {\n \n       Headers headers = null;\n       while (jParser.nextToken() != null && headers == null) {\n         String name = jParser.getCurrentName();\n         if (\"multiValueHeaders\".equalsIgnoreCase(name)) {\n           jParser.nextToken();\n-          headers = OBJECT_MAPPER.readValue(jParser, Headers.class);\n+          return OBJECT_MAPPER.readValue(jParser, Headers.class);\n         }\n       }\n \n-      return new ApiGatewayProxyRequest(headers);\n     } catch (Exception e) {\n       log.debug(\"Could not get headers from request, \", e);\n     }\n+    return null;\n+  }\n+\n+  abstract InputStream freshStream() throws IOException;\n+\n+  private static class NoopRequest extends ApiGatewayProxyRequest {\n+\n+    private final InputStream stream;\n+\n+    private NoopRequest(InputStream stream) {\n+      this.stream = stream;\n+    }\n+\n+    @Override\n+    InputStream freshStream() {\n+      return stream;\n+    }\n \n-    return new ApiGatewayProxyRequest(null);\n+    @Override\n+    Headers getHeaders() {\n+      return null;\n+    }\n   }\n \n-  @Nullable\n-  public Headers getHeaders() {\n-    return headers;\n+  private static class MarkableApiGatewayProxyRequest extends ApiGatewayProxyRequest {\n+\n+    private final InputStream inputStream;\n+\n+    private MarkableApiGatewayProxyRequest(InputStream inputStream) {\n+      this.inputStream = inputStream;\n+      inputStream.mark(Integer.MAX_VALUE);\n+    }\n+\n+    @Override\n+    InputStream freshStream() throws IOException {\n+\n+      inputStream.reset();\n+      inputStream.mark(Integer.MAX_VALUE);\n+      return inputStream;\n+    }\n+  }\n+\n+  private static class CopiedApiGatewayProxyRequest extends ApiGatewayProxyRequest {\n+\n+    private final byte[] data;\n+\n+    private CopiedApiGatewayProxyRequest(InputStream inputStream) throws IOException {\n+      data = IOUtils.toByteArray(inputStream);\n+    }\n+\n+    @Override\n+    InputStream freshStream() {\n+      return new ByteArrayInputStream(data);\n+    }\n   }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MTI0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r515741249", "bodyText": "Do you think it's possible to do this only if the propagator is configured?", "author": "anuraaga", "createdAt": "2020-11-02T05:02:07Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java", "diffHunk": "@@ -50,11 +51,16 @@ protected TracingRequestStreamHandler(AwsLambdaTracer tracer) {\n   }\n \n   @Override\n-  public final void handleRequest(InputStream input, OutputStream output, Context context)\n+  public void handleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException {\n-    Span span = tracer.startSpan(context, Kind.SERVER);\n+\n+    InputStreamFactory streamFactory = InputStreamFactory.forStream(input);", "originalCommit": "90009c342b4472dc510792b43c75b7c3c1f150a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExMjE1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r516112156", "bodyText": "Great idea, will implement a switch,", "author": "kubawach", "createdAt": "2020-11-02T16:52:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc0MTI0OQ=="}], "type": "inlineReview", "revised_code": {"commit": "7df0bc081b4007b273876c67aec692b777efe345", "chunk": "diff --git a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\nindex a91a9ef91a..1dbb6f03d2 100644\n--- a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\n+++ b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/TracingRequestStreamHandler.java\n\n@@ -54,13 +53,11 @@ public abstract class TracingRequestStreamHandler implements RequestStreamHandle\n   public void handleRequest(InputStream input, OutputStream output, Context context)\n       throws IOException {\n \n-    InputStreamFactory streamFactory = InputStreamFactory.forStream(input);\n-    Headers headers =\n-        ApiGatewayProxyRequest.ofInputStream(streamFactory.freshStream()).getHeaders();\n-    Span span = tracer.startSpan(context, Kind.SERVER, headers);\n+    ApiGatewayProxyRequest proxyRequest = ApiGatewayProxyRequest.forStream(input);\n+    Span span = tracer.startSpan(context, Kind.SERVER, proxyRequest.getHeaders());\n \n     try (Scope ignored = tracer.startScope(span)) {\n-      doHandleRequest(streamFactory.freshStream(), new OutputStreamWrapper(output, span), context);\n+      doHandleRequest(proxyRequest.freshStream(), new OutputStreamWrapper(output, span), context);\n     } catch (Throwable t) {\n       tracer.endExceptionally(span, t);\n       OpenTelemetrySdk.getGlobalTracerManagement().forceFlush().join(1, TimeUnit.SECONDS);\n"}}, {"oid": "83df9538fc605a7c7d0546d774dd0c02f22cca69", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/83df9538fc605a7c7d0546d774dd0c02f22cca69", "message": "AWS lambda instrumentation - HTTP context propagation", "committedDate": "2020-11-02T16:11:27Z", "type": "forcePushed"}, {"oid": "7df0bc081b4007b273876c67aec692b777efe345", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/7df0bc081b4007b273876c67aec692b777efe345", "message": "code review, added tests for stream wrapper", "committedDate": "2020-11-03T22:12:56Z", "type": "forcePushed"}, {"oid": "26001403facaef6cef2861d6ae40fad5a8456e27", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/26001403facaef6cef2861d6ae40fad5a8456e27", "message": "code review, added tests for stream wrapper", "committedDate": "2020-11-03T22:20:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA5MTEyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r517091120", "bodyText": "IIUC, if the x-ray propagator is configured, fields wouldn't be empty but in that case we want to read the env var. Should we compare to its fields?", "author": "anuraaga", "createdAt": "2020-11-04T04:28:09Z", "path": "instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.instrumentation.awslambda.v1_0;\n+\n+import com.amazonaws.serverless.proxy.model.Headers;\n+import com.fasterxml.jackson.core.JsonFactory;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n+import io.opentelemetry.api.OpenTelemetry;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.commons.io.IOUtils;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+abstract class ApiGatewayProxyRequest {\n+\n+  private static final Logger log = LoggerFactory.getLogger(ApiGatewayProxyRequest.class);\n+\n+  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n+\n+  static {\n+    OBJECT_MAPPER.registerModule(new AfterburnerModule());\n+  }\n+\n+  private static boolean noHttpPropagationNeeded() {\n+    return OpenTelemetry.getGlobalPropagators().getTextMapPropagator().fields().isEmpty();", "originalCommit": "26001403facaef6cef2861d6ae40fad5a8456e27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTYxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1536#discussion_r517189610", "bodyText": "Hmmm yes, sound idea. I forgot about non-http propagator :)", "author": "kubawach", "createdAt": "2020-11-04T09:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzA5MTEyMA=="}], "type": "inlineReview", "revised_code": {"commit": "ad12340a831fb02d910a90fab9176d301ac679e5", "chunk": "diff --git a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java\nindex b3e78b34b6..94c60e9424 100644\n--- a/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java\n+++ b/instrumentation/aws-lambda-1.0/library/src/main/java/io/opentelemetry/instrumentation/awslambda/v1_0/ApiGatewayProxyRequest.java\n\n@@ -5,32 +5,28 @@\n \n package io.opentelemetry.instrumentation.awslambda.v1_0;\n \n+import static io.opentelemetry.instrumentation.awslambda.v1_0.HeadersFactory.ofStream;\n+\n import com.amazonaws.serverless.proxy.model.Headers;\n-import com.fasterxml.jackson.core.JsonFactory;\n-import com.fasterxml.jackson.core.JsonParser;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-import com.fasterxml.jackson.module.afterburner.AfterburnerModule;\n import io.opentelemetry.api.OpenTelemetry;\n import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.util.List;\n import org.apache.commons.io.IOUtils;\n import org.checkerframework.checker.nullness.qual.Nullable;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n \n abstract class ApiGatewayProxyRequest {\n \n-  private static final Logger log = LoggerFactory.getLogger(ApiGatewayProxyRequest.class);\n-\n-  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n-\n-  static {\n-    OBJECT_MAPPER.registerModule(new AfterburnerModule());\n+  private static boolean noHttpPropagationNeeded() {\n+    List<String> fields = OpenTelemetry.getGlobalPropagators().getTextMapPropagator().fields();\n+    return (fields.isEmpty() || xRayPropagationFieldsOnly(fields));\n   }\n \n-  private static boolean noHttpPropagationNeeded() {\n-    return OpenTelemetry.getGlobalPropagators().getTextMapPropagator().fields().isEmpty();\n+  private static boolean xRayPropagationFieldsOnly(List<String> fields) {\n+    // ugly but faster than typical convert-to-set-and-check-contains-only\n+    return (fields.size() == 1)\n+        && (ParentContextExtractor.AWS_TRACE_HEADER_PROPAGATOR_KEY.equals(fields.get(0)));\n   }\n \n   static ApiGatewayProxyRequest forStream(final InputStream source) throws IOException {\n"}}, {"oid": "ad12340a831fb02d910a90fab9176d301ac679e5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ad12340a831fb02d910a90fab9176d301ac679e5", "message": "code review - recpects XRay propagation, tests added", "committedDate": "2020-11-04T12:50:37Z", "type": "forcePushed"}, {"oid": "629a32288bcb3f54cb581c59b5d47e7c4d52e576", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/629a32288bcb3f54cb581c59b5d47e7c4d52e576", "message": "AWS lambda instrumentation - HTTP context propagation", "committedDate": "2020-11-06T17:18:41Z", "type": "commit"}, {"oid": "b2a36b620547bf545c1758a963dd9f84506465e5", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b2a36b620547bf545c1758a963dd9f84506465e5", "message": "code review, added tests for stream wrapper", "committedDate": "2020-11-06T17:18:44Z", "type": "commit"}, {"oid": "cf71391358f26f5ba21eeb23481c8876a343209d", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/cf71391358f26f5ba21eeb23481c8876a343209d", "message": "code review - recpects XRay propagation, tests added", "committedDate": "2020-11-06T17:18:44Z", "type": "commit"}, {"oid": "f308de1dbe74f1da7ae5b4c72f710a563eeade5a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f308de1dbe74f1da7ae5b4c72f710a563eeade5a", "message": "rebase to master", "committedDate": "2020-11-06T19:12:57Z", "type": "commit"}, {"oid": "f308de1dbe74f1da7ae5b4c72f710a563eeade5a", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/f308de1dbe74f1da7ae5b4c72f710a563eeade5a", "message": "rebase to master", "committedDate": "2020-11-06T19:12:57Z", "type": "forcePushed"}]}