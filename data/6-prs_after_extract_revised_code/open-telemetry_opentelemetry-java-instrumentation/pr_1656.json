{"pr_number": 1656, "pr_title": "Enable checkstyle overload method ordering rule for Google Java Style", "pr_createdAt": "2020-11-17T04:07:24Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1656", "timeline": [{"oid": "51f5a0a99839abf1d0dfa9dab66eeb1d3ff1d26e", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/51f5a0a99839abf1d0dfa9dab66eeb1d3ff1d26e", "message": "Enable checkstyle overload rule for Google Style", "committedDate": "2020-11-17T03:59:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NDMxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1656#discussion_r525054311", "bodyText": "I think that the previous ordering made slightly more sense: methods were ordered by their usage, top to bottom. How about renaming the checkMatch(Reference, TypeDescription) method to checkThirdPartyTypeMatch (or something similar) without reordering them?", "author": "mateuszrzeszutek", "createdAt": "2020-11-17T10:40:58Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/matcher/ReferenceMatcher.java", "diffHunk": "@@ -143,50 +143,6 @@ private boolean doesMatch(ClassLoader loader) {\n     }\n   }\n \n-  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n-  // implemented\n-  private List<Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {", "originalCommit": "51f5a0a99839abf1d0dfa9dab66eeb1d3ff1d26e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTUxOTgyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1656#discussion_r525519821", "bodyText": "\ud83d\udc4d that's better", "author": "trask", "createdAt": "2020-11-17T20:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA1NDMxMQ=="}], "type": "inlineReview", "revised_code": {"commit": "10d4e1781da48e2866e9aa9dee99bebf5665bf15", "chunk": "diff --git a/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/matcher/ReferenceMatcher.java b/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/matcher/ReferenceMatcher.java\nindex 734303e032..c8a944cf6f 100644\n--- a/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/matcher/ReferenceMatcher.java\n+++ b/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/muzzle/matcher/ReferenceMatcher.java\n\n@@ -143,7 +143,52 @@ public final class ReferenceMatcher {\n     }\n   }\n \n-  private static List<Mismatch> checkMatch(Reference reference, TypeDescription typeOnClasspath) {\n+  // for helper classes we make sure that all abstract methods from super classes and interfaces are\n+  // implemented\n+  private List<Mismatch> checkHelperClassMatch(Reference helperClass, TypePool typePool) {\n+    List<Mismatch> mismatches = Collections.emptyList();\n+\n+    HelperReferenceWrapper helperWrapper = new Factory(typePool, references).create(helperClass);\n+\n+    if (!helperWrapper.hasSuperTypes() || helperWrapper.isAbstract()) {\n+      return mismatches;\n+    }\n+\n+    // treat the helper type as a bag of methods: collect all methods defined in the helper class,\n+    // all superclasses and interfaces and check if all abstract methods are implemented somewhere\n+    Set<HelperReferenceWrapper.Method> abstractMethods = new HashSet<>();\n+    Set<HelperReferenceWrapper.Method> plainMethods = new HashSet<>();\n+    collectMethodsFromTypeHierarchy(helperWrapper, abstractMethods, plainMethods);\n+\n+    Set<HelperReferenceWrapper.Method> unimplementedMethods =\n+        Sets.difference(abstractMethods, plainMethods);\n+    for (HelperReferenceWrapper.Method unimplementedMethod : unimplementedMethods) {\n+      mismatches =\n+          lazyAdd(\n+              mismatches,\n+              new Mismatch.MissingMethod(\n+                  helperClass.getSources().toArray(new Reference.Source[0]),\n+                  unimplementedMethod.getDeclaringClass(),\n+                  unimplementedMethod.getName(),\n+                  unimplementedMethod.getDescriptor()));\n+    }\n+\n+    return mismatches;\n+  }\n+\n+  private static void collectMethodsFromTypeHierarchy(\n+      HelperReferenceWrapper type, Set<Method> abstractMethods, Set<Method> plainMethods) {\n+\n+    type.getMethods()\n+        .forEach(method -> (method.isAbstract() ? abstractMethods : plainMethods).add(method));\n+\n+    type.getSuperTypes()\n+        .forEach(\n+            superType -> collectMethodsFromTypeHierarchy(superType, abstractMethods, plainMethods));\n+  }\n+\n+  private static List<Mismatch> checkThirdPartyTypeMatch(\n+      Reference reference, TypeDescription typeOnClasspath) {\n     List<Mismatch> mismatches = Collections.emptyList();\n \n     for (Reference.Flag flag : reference.getFlags()) {\n"}}, {"oid": "10d4e1781da48e2866e9aa9dee99bebf5665bf15", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/10d4e1781da48e2866e9aa9dee99bebf5665bf15", "message": "Better ordering", "committedDate": "2020-11-17T20:57:10Z", "type": "commit"}]}