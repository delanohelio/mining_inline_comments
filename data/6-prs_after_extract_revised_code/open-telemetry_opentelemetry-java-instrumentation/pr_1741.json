{"pr_number": 1741, "pr_title": "Rename TypeInstrumentation#classLoaderMatcher() to classLoaderOptimization()", "pr_createdAt": "2020-11-23T14:02:52Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1741", "timeline": [{"oid": "b203235de053a88c22d2ed747ddf4d0c001b22da", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/b203235de053a88c22d2ed747ddf4d0c001b22da", "message": "Rename TypeInstrumentation#classLoaderMatcher() to classLoaderOptimization()", "committedDate": "2020-11-23T14:01:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc1NTI3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1741#discussion_r528755279", "bodyText": "Probably all these comments can be replaced by more verbose javadoc of the base method?", "author": "iNikem", "createdAt": "2020-11-23T14:47:35Z", "path": "instrumentation/hibernate/hibernate-4.0/src/main/java/io/opentelemetry/javaagent/instrumentation/hibernate/v4_0/TransactionInstrumentation.java", "diffHunk": "@@ -28,7 +28,7 @@\n final class TransactionInstrumentation implements TypeInstrumentation {\n \n   @Override\n-  public ElementMatcher<ClassLoader> classLoaderMatcher() {\n+  public ElementMatcher<ClassLoader> classLoaderOptimization() {\n     // Optimization for expensive typeMatcher.", "originalCommit": "b203235de053a88c22d2ed747ddf4d0c001b22da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc2MDAyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1741#discussion_r528760021", "bodyText": "Honestly I completely forgot about these comments. I'll remove them.", "author": "mateuszrzeszutek", "createdAt": "2020-11-23T14:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODc1NTI3OQ=="}], "type": "inlineReview", "revised_code": {"commit": "ff3a6322dbf84c63e77567717bb8bee7e557d57f", "chunk": "diff --git a/instrumentation/hibernate/hibernate-4.0/src/main/java/io/opentelemetry/javaagent/instrumentation/hibernate/v4_0/TransactionInstrumentation.java b/instrumentation/hibernate/hibernate-4.0/src/main/java/io/opentelemetry/javaagent/instrumentation/hibernate/v4_0/TransactionInstrumentation.java\nindex 93c4180aed..588ef22491 100644\n--- a/instrumentation/hibernate/hibernate-4.0/src/main/java/io/opentelemetry/javaagent/instrumentation/hibernate/v4_0/TransactionInstrumentation.java\n+++ b/instrumentation/hibernate/hibernate-4.0/src/main/java/io/opentelemetry/javaagent/instrumentation/hibernate/v4_0/TransactionInstrumentation.java\n\n@@ -29,7 +29,6 @@ final class TransactionInstrumentation implements TypeInstrumentation {\n \n   @Override\n   public ElementMatcher<ClassLoader> classLoaderOptimization() {\n-    // Optimization for expensive typeMatcher.\n     return hasClassesNamed(\"org.hibernate.Transaction\");\n   }\n \n"}}, {"oid": "ff3a6322dbf84c63e77567717bb8bee7e557d57f", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/ff3a6322dbf84c63e77567717bb8bee7e557d57f", "message": "Removed no longer needed comments & improved JavaDoc", "committedDate": "2020-11-23T15:31:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODQ1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1741#discussion_r529068451", "bodyText": "github is not letting me make this as a \"suggestion\":\n   * An optimization to short circuit matching in the case where the instrumented library is not\n   * even present on the class path.\n   *\n   * <p>Most applications have only a small subset of libraries on their class path, so this ends up\n   * being a very useful optimization.\n   *\n   * <p>Some background on type matcher performance:\n   *\n   * <p>Type matchers that only match against the type name are fast, e.g. {@link\n   * ElementMatchers#named(String)}.\n   *\n   * <p>All other type matchers require some level of bytecode inspection, e.g. {@link\n   * ElementMatchers#isAnnotatedWith(ElementMatcher)}.\n   *\n   * <p>Type matchers that need to inspect the super class hierarchy are even more expensive, e.g.\n   * {@link AgentElementMatchers#implementsInterface(ElementMatcher)}. This is because they require\n   * inspecting multiple super classes/interfaces as well (which may not even be loaded yet in which\n   * case their bytecode has to be read and inspected).", "author": "trask", "createdAt": "2020-11-23T23:43:29Z", "path": "javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/TypeInstrumentation.java", "diffHunk": "@@ -19,13 +19,18 @@\n public interface TypeInstrumentation {\n   /**\n    * A type instrumentation can implement this method to optimize an expensive {@link\n-   * #typeMatcher()} - usually {@link AgentElementMatchers#implementsInterface(ElementMatcher)} or\n-   * {@link AgentElementMatchers#extendsClass(ElementMatcher)}. In that case it's useful to check\n-   * that the classloader contains the class/interface that is being extended.\n+   * #typeMatcher()} - usually one that uses {@link AgentElementMatchers}, e.g. {@link\n+   * AgentElementMatchers#implementsInterface(ElementMatcher)} or {@link\n+   * AgentElementMatchers#extendsClass(ElementMatcher)}. Type matchers that check annotation\n+   * presence or class inheritance are particularly expensive for classloaders that do not contain\n+   * the base class/interface/annotation. To make this check significantly less expensive this\n+   * method can be used to verify that the classloader contains the class/interface that is being\n+   * extended.", "originalCommit": "ff3a6322dbf84c63e77567717bb8bee7e557d57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQxMjY0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1741#discussion_r529412646", "bodyText": "This is great, thanks!", "author": "mateuszrzeszutek", "createdAt": "2020-11-24T10:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTA2ODQ1MQ=="}], "type": "inlineReview", "revised_code": {"commit": "a1afb9f05689275b16ea004314f648a73087b39c", "chunk": "diff --git a/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/TypeInstrumentation.java b/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/TypeInstrumentation.java\nindex 7ab7d9ce29..76f762f656 100644\n--- a/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/TypeInstrumentation.java\n+++ b/javaagent-tooling/src/main/java/io/opentelemetry/javaagent/tooling/TypeInstrumentation.java\n\n@@ -12,20 +12,31 @@ import java.util.Map;\n import net.bytebuddy.description.method.MethodDescription;\n import net.bytebuddy.description.type.TypeDescription;\n import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n \n /**\n  * Interface representing a single type instrumentation. Part of an {@link InstrumentationModule}.\n  */\n public interface TypeInstrumentation {\n   /**\n-   * A type instrumentation can implement this method to optimize an expensive {@link\n-   * #typeMatcher()} - usually one that uses {@link AgentElementMatchers}, e.g. {@link\n-   * AgentElementMatchers#implementsInterface(ElementMatcher)} or {@link\n-   * AgentElementMatchers#extendsClass(ElementMatcher)}. Type matchers that check annotation\n-   * presence or class inheritance are particularly expensive for classloaders that do not contain\n-   * the base class/interface/annotation. To make this check significantly less expensive this\n-   * method can be used to verify that the classloader contains the class/interface that is being\n-   * extended.\n+   * An optimization to short circuit matching in the case where the instrumented library is not\n+   * even present on the class path.\n+   *\n+   * <p>Most applications have only a small subset of libraries on their class path, so this ends up\n+   * being a very useful optimization.\n+   *\n+   * <p>Some background on type matcher performance:\n+   *\n+   * <p>Type matchers that only match against the type name are fast, e.g. {@link\n+   * ElementMatchers#named(String)}.\n+   *\n+   * <p>All other type matchers require some level of bytecode inspection, e.g. {@link\n+   * ElementMatchers#isAnnotatedWith(ElementMatcher)}.\n+   *\n+   * <p>Type matchers that need to inspect the super class hierarchy are even more expensive, e.g.\n+   * {@link AgentElementMatchers#implementsInterface(ElementMatcher)}. This is because they require\n+   * inspecting multiple super classes/interfaces as well (which may not even be loaded yet in which\n+   * case their bytecode has to be read and inspected).\n    *\n    * @return A type matcher that rejects classloaders that do not contain desired interfaces or base\n    *     classes.\n"}}, {"oid": "a1afb9f05689275b16ea004314f648a73087b39c", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/a1afb9f05689275b16ea004314f648a73087b39c", "message": "Improve TypeInstrumentation Javadoc", "committedDate": "2020-11-24T10:24:18Z", "type": "commit"}]}