{"pr_number": 1837, "pr_title": "Make sure AWS SDK spans suppress client spans all the time.", "pr_createdAt": "2020-12-06T06:48:04Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1837", "timeline": [{"oid": "61a5f3ac75ff87bfa202df758fe8469d983cba59", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/61a5f3ac75ff87bfa202df758fe8469d983cba59", "message": "Make sure AWS SDK spans suppress client spans all the time.", "committedDate": "2020-12-06T06:38:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk3MjMxMg==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1837#discussion_r536972312", "bodyText": "I think after #1643 I may try to remove this class, instead just service loading the shaded library instrumentation.", "author": "anuraaga", "createdAt": "2020-12-06T06:52:42Z", "path": "instrumentation/aws-sdk/aws-sdk-2.2/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -41,10 +39,6 @@\n  */\n public class TracingExecutionInterceptor implements ExecutionInterceptor {\n \n-  public static class ScopeHolder {\n-    public static final ThreadLocal<Scope> CURRENT = new ThreadLocal<>();\n-  }\n-\n   private final ExecutionInterceptor delegate;\n \n   public TracingExecutionInterceptor() {", "originalCommit": "1c618e4b730d565aac3572d9080b84d852a393e6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": null}, {"oid": "61a5f3ac75ff87bfa202df758fe8469d983cba59", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/61a5f3ac75ff87bfa202df758fe8469d983cba59", "message": "Make sure AWS SDK spans suppress client spans all the time.", "committedDate": "2020-12-06T06:38:36Z", "type": "forcePushed"}, {"oid": "27e2c328b46d1c355e489db990e982964befd431", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/27e2c328b46d1c355e489db990e982964befd431", "message": "Make more consistent with other instrumentation", "committedDate": "2020-12-07T02:31:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI1NDc3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1837#discussion_r537254770", "bodyText": "I think including a note here about the signature problem would be good too, since that's the biggest worry\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // instrumentation, which executs on event loops. If it's possible, it may require instrumenting\n          \n          \n            \n                // instrumentation, which executes on event loops. If it's possible, it may require instrumenting", "author": "trask", "createdAt": "2020-12-07T06:12:17Z", "path": "instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java", "diffHunk": "@@ -65,6 +66,21 @@ protected String responseHeader(HttpResponse httpResponse, String name) {\n     return SETTER;\n   }\n \n+  public boolean shouldStartSpan(Context parentContext, HttpRequest request) {\n+    if (!super.shouldStartSpan(parentContext)) {\n+      return false;\n+    }\n+    // The AWS SDK uses Netty for asynchronous clients. We have not found how to propagate Context\n+    // from the SDK instrumentation, which executes on an application thread, to Netty\n+    // instrumentation, which executs on event loops. If it's possible, it may require instrumenting", "originalCommit": "27e2c328b46d1c355e489db990e982964befd431", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "0681694bd71a3a409a7b0602140cdaf6d967f3f2", "chunk": "diff --git a/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java b/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\nindex 818aff820d..109e162bb2 100644\n--- a/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\n+++ b/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\n\n@@ -72,7 +72,7 @@ public class NettyHttpClientTracer\n     }\n     // The AWS SDK uses Netty for asynchronous clients. We have not found how to propagate Context\n     // from the SDK instrumentation, which executes on an application thread, to Netty\n-    // instrumentation, which executs on event loops. If it's possible, it may require instrumenting\n+    // instrumentation, which executes on event loops. If it's possible, it may require instrumenting\n     // internal classes. Using a header which is more or less guaranteed to always exist is arguably\n     // more stable.\n     if (request.headers().contains(\"amz-sdk-invocation-id\")) {\n"}}, {"oid": "0681694bd71a3a409a7b0602140cdaf6d967f3f2", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/0681694bd71a3a409a7b0602140cdaf6d967f3f2", "message": "Update instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\n\nCo-authored-by: Trask Stalnaker <trask.stalnaker@gmail.com>", "committedDate": "2020-12-07T06:38:24Z", "type": "commit"}, {"oid": "6551c0dc2e58a92b645247f436ff1828a80e2028", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/6551c0dc2e58a92b645247f436ff1828a80e2028", "message": "more dragons", "committedDate": "2020-12-07T06:41:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI2NTY1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1837#discussion_r537265657", "bodyText": "\ud83d\udc4d", "author": "trask", "createdAt": "2020-12-07T06:43:19Z", "path": "instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java", "diffHunk": "@@ -70,11 +70,14 @@ public boolean shouldStartSpan(Context parentContext, HttpRequest request) {\n     if (!super.shouldStartSpan(parentContext)) {\n       return false;\n     }\n-    // The AWS SDK uses Netty for asynchronous clients. We have not found how to propagate Context\n-    // from the SDK instrumentation, which executes on an application thread, to Netty\n-    // instrumentation, which executes on event loops. If it's possible, it may require instrumenting\n-    // internal classes. Using a header which is more or less guaranteed to always exist is arguably\n-    // more stable.\n+    // The AWS SDK uses Netty for asynchronous clients but constructs a request signature before\n+    // beginning transport. This means we MUST suppress Netty spans we would normally create or\n+    // they will inject their own trace header, which does not match what was present when the\n+    // signature was computed, breaking the SDK request completely We have not found how to\n+    // cleanly propagate context from the SDK instrumentation, which executes on an application\n+    // thread, to Netty instrumentation, which executes on event loops. If it's possible, it may\n+    // require instrumenting internal classes. Using a header which is more or less guaranteed to\n+    // always exist is arguably more stable.", "originalCommit": "6551c0dc2e58a92b645247f436ff1828a80e2028", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "dcfc600e11129a2d568ed88f81650105f19bb573", "chunk": "diff --git a/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java b/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\nindex 5e7196343c..9ff1e5d95e 100644\n--- a/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\n+++ b/instrumentation/netty/netty-4.1/javaagent/src/main/java/io/opentelemetry/javaagent/instrumentation/netty/v4_1/client/NettyHttpClientTracer.java\n\n@@ -73,7 +73,7 @@ public class NettyHttpClientTracer\n     // The AWS SDK uses Netty for asynchronous clients but constructs a request signature before\n     // beginning transport. This means we MUST suppress Netty spans we would normally create or\n     // they will inject their own trace header, which does not match what was present when the\n-    // signature was computed, breaking the SDK request completely We have not found how to\n+    // signature was computed, breaking the SDK request completely. We have not found how to\n     // cleanly propagate context from the SDK instrumentation, which executes on an application\n     // thread, to Netty instrumentation, which executes on event loops. If it's possible, it may\n     // require instrumenting internal classes. Using a header which is more or less guaranteed to\n"}}, {"oid": "dcfc600e11129a2d568ed88f81650105f19bb573", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/dcfc600e11129a2d568ed88f81650105f19bb573", "message": "Grammar", "committedDate": "2020-12-07T06:43:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3NDQyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1837#discussion_r537274420", "bodyText": "Even if you are sure that AWS SDK calls are always terminal and that nobody uses some alternative implementations of AWS services (like local S3 server?), we at least have to document this behaviour very clearly.", "author": "iNikem", "createdAt": "2020-12-07T07:06:36Z", "path": "instrumentation/aws-sdk/aws-sdk-2.2/library/src/main/java/io/opentelemetry/instrumentation/awssdk/v2_2/TracingExecutionInterceptor.java", "diffHunk": "@@ -79,46 +80,55 @@ private RequestType getTypeFromAttributes(ExecutionAttributes executionAttribute\n   @Override\n   public void beforeExecution(\n       Context.BeforeExecution context, ExecutionAttributes executionAttributes) {\n-    Span span = tracer().getOrCreateSpan(spanName(executionAttributes), AwsSdk.tracer(), kind);\n-    executionAttributes.putAttribute(\n-        CONTEXT_ATTRIBUTE, io.opentelemetry.context.Context.current().with(span));\n+    io.opentelemetry.context.Context parentContext = io.opentelemetry.context.Context.current();\n+    if (!tracer().shouldStartSpan(parentContext)) {\n+      return;\n+    }\n+    io.opentelemetry.context.Context otelContext =\n+        tracer().startSpan(parentContext, spanName(executionAttributes), AwsSdk.tracer(), kind);\n+    executionAttributes.putAttribute(CONTEXT_ATTRIBUTE, otelContext);\n     RequestType type = ofSdkRequest(context.request());\n     if (type != null) {\n       executionAttributes.putAttribute(REQUEST_TYPE_ATTRIBUTE, type);\n     }\n+    if (executionAttributes\n+        .getAttribute(SdkExecutionAttribute.CLIENT_TYPE)\n+        .equals(ClientType.SYNC)) {\n+      // We can only activate context for synchronous clients, which allows downstream\n+      // instrumentation like Apache to know about the SDK span.\n+      executionAttributes.putAttribute(SCOPE_ATTRIBUTE, otelContext.makeCurrent());\n+    }\n   }\n \n   @Override\n   public SdkHttpRequest modifyHttpRequest(\n       Context.ModifyHttpRequest context, ExecutionAttributes executionAttributes) {\n-    io.opentelemetry.context.Context otelContext =\n-        executionAttributes.getAttribute(CONTEXT_ATTRIBUTE);\n-    // Never null in practice unless another interceptor cleared out the attribute, which\n-    // is theoretically possible.\n+    io.opentelemetry.context.Context otelContext = getContextFromAttributes(executionAttributes);\n     if (otelContext == null) {\n       return context.httpRequest();\n     }\n+\n     SdkHttpRequest.Builder builder = context.httpRequest().toBuilder();\n-    OpenTelemetry.getGlobalPropagators()\n-        .getTextMapPropagator()\n-        .inject(otelContext, builder, AwsSdkInjectAdapter.INSTANCE);\n+    AwsXRayPropagator.getInstance().inject(otelContext, builder, AwsSdkInjectAdapter.INSTANCE);", "originalCommit": "dcfc600e11129a2d568ed88f81650105f19bb573", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3ODI1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/pull/1837#discussion_r537278255", "bodyText": "Got a bit of extra README out of it too :)", "author": "anuraaga", "createdAt": "2020-12-07T07:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI3NDQyMA=="}], "type": "inlineReview", "revised_code": null}, {"oid": "fcd409a4500fb5cde498aa8ab844a9fac5d611b9", "url": "https://github.com/open-telemetry/opentelemetry-java-instrumentation/commit/fcd409a4500fb5cde498aa8ab844a9fac5d611b9", "message": "README", "committedDate": "2020-12-07T07:15:50Z", "type": "commit"}]}