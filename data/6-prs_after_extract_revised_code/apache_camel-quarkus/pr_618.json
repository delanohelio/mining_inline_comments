{"pr_number": 618, "pr_title": "Fix #617 Registerable and discoverable Camel services", "pr_createdAt": "2020-01-14T10:44:57Z", "pr_url": "https://github.com/apache/camel-quarkus/pull/618", "timeline": [{"oid": "38439849e9cc41ae230af7aafda455556c010098", "url": "https://github.com/apache/camel-quarkus/commit/38439849e9cc41ae230af7aafda455556c010098", "message": "Registerable and discoverable Camel services", "committedDate": "2020-01-16T17:05:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367547095", "bodyText": "we need to fine tune language and data-format as we can store into the registry only singleton services (this requires also some changes to the FastCamelContext as it assumes languages and dataformats are stored in the registry)", "author": "lburgazzoli", "createdAt": "2020-01-16T17:17:23Z", "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")", "originalCommit": "38439849e9cc41ae230af7aafda455556c010098", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1MzcwMg==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367553702", "bodyText": "Yes we do have this problem as today but this is a good change to fix it", "author": "lburgazzoli", "createdAt": "2020-01-16T17:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzYzODcxMg==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367638712", "bodyText": "we need to fine tune language and data-format\n\nNot sure how should we tune?\n\nas we can store into the registry only singleton services\n\nYou seem to imply language and data-format are not singleton services, but could you plz. define \"singleton services\"?", "author": "ppalaga", "createdAt": "2020-01-16T20:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4NjEwMQ==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367686101", "bodyText": "The \"tuning\" here is about to carefully select which language/dataformat can be bound to the registry.\nAs example camel creates components only once so every time you use a schema, then you'll end up using the same component instance.\nFor languages and dataformat that's not always true and this is because you can use the same dataformat multiple time in the same route with a different configuration.", "author": "lburgazzoli", "createdAt": "2020-01-16T22:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU0NzA5NQ=="}], "type": "inlineReview", "revised_code": {"commit": "d82e823d5bcafc7424c32bca9a954b2042010cdf", "chunk": "diff --git a/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java b/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java\nindex 211162d65..63c6e8df0 100644\n--- a/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java\n+++ b/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java\n\n@@ -130,40 +128,65 @@ class BuildProcessor {\n         }\n \n         @BuildStep\n-        void coreServices(\n-                ApplicationArchivesBuildItem archives,\n-                BuildProducer<CamelServiceBuildItem> services) {\n-\n-            /* Registered only */\n-            CamelSupport.propertyFiles(\n-                    archives,\n-                    \"META-INF/services/org/apache/camel/component\",\n-                    \"META-INF/services/org/apache/camel/language\",\n-                    \"META-INF/services/org/apache/camel/dataformat\")\n-                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n-                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n-                    .forEach(services::produce);\n-\n-            /* Configurers need some name transformation */\n-            CamelSupport.propertyFiles(\n-                    archives,\n-                    \"META-INF/services/org/apache/camel/configurer\")\n-                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n-                    .map(entry -> CamelServiceBuildItem.registeredOnly(\n-                            entry.getKey(),\n-                            entry.getKey().getFileName().toString() + \"-configurer\",\n-                            entry.getValue().getProperty(\"class\")))\n-                    .forEach(services::produce);\n-\n-            /* Discoverable only */\n-            CamelSupport.propertyFiles(\n-                    archives,\n-                    \"META-INF/services/org/apache/camel\",\n-                    \"META-INF/services/org/apache/camel/management\",\n-                    \"META-INF/services/org/apache/camel/model\")\n-                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n-                    .map(entry -> CamelServiceBuildItem.discoverableOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n-                    .forEach(services::produce);\n+        void coreServicePatterns(BuildProducer<CamelServicePatternBuildItem> services) {\n+\n+            services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.REGISTRY,\n+                    true,\n+                    \"META-INF/services/org/apache/camel/component/*\",\n+                    \"META-INF/services/org/apache/camel/language/*\",\n+                    \"META-INF/services/org/apache/camel/dataformat/*\"));\n+\n+            services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.DISCOVERY,\n+                    true,\n+                    \"META-INF/services/org/apache/camel/*\",\n+                    \"META-INF/services/org/apache/camel/management/*\",\n+                    \"META-INF/services/org/apache/camel/model/*\",\n+                    \"META-INF/services/org/apache/camel/configurer/*\"));\n+        }\n+\n+        @BuildStep\n+        void userServicePatterns(\n+                CamelConfig camelConfig,\n+                BuildProducer<CamelServicePatternBuildItem> services) {\n+\n+            camelConfig.service.discovery.includePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.DISCOVERY,\n+                    true,\n+                    list)));\n+\n+            camelConfig.service.discovery.excludePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.DISCOVERY,\n+                    false,\n+                    list)));\n+\n+            camelConfig.service.registry.includePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.REGISTRY,\n+                    true,\n+                    list)));\n+\n+            camelConfig.service.registry.excludePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.REGISTRY,\n+                    false,\n+                    list)));\n+        }\n+\n+        @BuildStep\n+        void camelServices(\n+                ApplicationArchivesBuildItem applicationArchives,\n+                List<CamelServicePatternBuildItem> servicePatterns,\n+                BuildProducer<CamelServiceBuildItem> camelServices) {\n+\n+            final PathFilter pathFilter = servicePatterns.stream()\n+                    .filter(patterns -> patterns.getDestination() == CamelServiceDestination.DISCOVERY)\n+                    .collect(\n+                            PathFilter.Builder::new,\n+                            (bldr, patterns) -> bldr.patterns(patterns.isInclude(), patterns.getPatterns()),\n+                            PathFilter.Builder::combine)\n+                    .build();\n+            CamelSupport.services(applicationArchives, pathFilter)\n+                    .forEach(camelServices::produce);\n         }\n \n         /*\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367554684", "bodyText": "As future evolution, may be better not to expose such instances to the user through the registry, maybe better to try to bind them to the components at build time", "author": "lburgazzoli", "createdAt": "2020-01-16T17:33:23Z", "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java", "diffHunk": "@@ -128,9 +130,40 @@ void coreServiceFilter(BuildProducer<CamelServiceFilterBuildItem> filterBuildIte\n         }\n \n         @BuildStep\n-        void serviceInfoTransformers(BuildProducer<CamelServiceInfoTransformerBuildItem> mapperBuildItems) {\n-            mapperBuildItems.produce(\n-                    new CamelServiceInfoTransformerBuildItem(CamelServiceInfoTransformers::configurer));\n+        void coreServices(\n+                ApplicationArchivesBuildItem archives,\n+                BuildProducer<CamelServiceBuildItem> services) {\n+\n+            /* Registered only */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/component\",\n+                    \"META-INF/services/org/apache/camel/language\",\n+                    \"META-INF/services/org/apache/camel/dataformat\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n+                    .forEach(services::produce);\n+\n+            /* Configurers need some name transformation */\n+            CamelSupport.propertyFiles(\n+                    archives,\n+                    \"META-INF/services/org/apache/camel/configurer\")\n+                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n+                    .map(entry -> CamelServiceBuildItem.registeredOnly(", "originalCommit": "38439849e9cc41ae230af7aafda455556c010098", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0NDM1Nw==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367644357", "bodyText": "I wonder how can we cover the case you mentioned on the chat - manually bind a second instance of a component under a different name?", "author": "ppalaga", "createdAt": "2020-01-16T20:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY4OTcyNg==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367689726", "bodyText": "I mean that we should not even bind them to the registry but scan the registry for components and bind related configurers through a recorder during STATIC_INIT", "author": "lburgazzoli", "createdAt": "2020-01-16T22:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMTY1Mw==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367831653", "bodyText": "the registry for components and bind related configurers through a recorder during STATIC_INIT\n\nYes, that would be easy to do. But when a user adds a second instance of a component under a different name at runtime, our configurer setting code would not catch it.", "author": "ppalaga", "createdAt": "2020-01-17T09:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMjc4MQ==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r367832781", "bodyText": "yep but as the second instance is probably configured at runtime, the component will fallback to the \"factory finder\" way which is reasonable", "author": "lburgazzoli", "createdAt": "2020-01-17T09:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NDY4NA=="}], "type": "inlineReview", "revised_code": {"commit": "d82e823d5bcafc7424c32bca9a954b2042010cdf", "chunk": "diff --git a/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java b/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java\nindex 211162d65..63c6e8df0 100644\n--- a/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java\n+++ b/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/BuildProcessor.java\n\n@@ -130,40 +128,65 @@ class BuildProcessor {\n         }\n \n         @BuildStep\n-        void coreServices(\n-                ApplicationArchivesBuildItem archives,\n-                BuildProducer<CamelServiceBuildItem> services) {\n-\n-            /* Registered only */\n-            CamelSupport.propertyFiles(\n-                    archives,\n-                    \"META-INF/services/org/apache/camel/component\",\n-                    \"META-INF/services/org/apache/camel/language\",\n-                    \"META-INF/services/org/apache/camel/dataformat\")\n-                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n-                    .map(entry -> CamelServiceBuildItem.registeredOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n-                    .forEach(services::produce);\n-\n-            /* Configurers need some name transformation */\n-            CamelSupport.propertyFiles(\n-                    archives,\n-                    \"META-INF/services/org/apache/camel/configurer\")\n-                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n-                    .map(entry -> CamelServiceBuildItem.registeredOnly(\n-                            entry.getKey(),\n-                            entry.getKey().getFileName().toString() + \"-configurer\",\n-                            entry.getValue().getProperty(\"class\")))\n-                    .forEach(services::produce);\n-\n-            /* Discoverable only */\n-            CamelSupport.propertyFiles(\n-                    archives,\n-                    \"META-INF/services/org/apache/camel\",\n-                    \"META-INF/services/org/apache/camel/management\",\n-                    \"META-INF/services/org/apache/camel/model\")\n-                    .filter(entry -> entry.getValue().getProperty(\"class\") != null)\n-                    .map(entry -> CamelServiceBuildItem.discoverableOnly(entry.getKey(), entry.getValue().getProperty(\"class\")))\n-                    .forEach(services::produce);\n+        void coreServicePatterns(BuildProducer<CamelServicePatternBuildItem> services) {\n+\n+            services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.REGISTRY,\n+                    true,\n+                    \"META-INF/services/org/apache/camel/component/*\",\n+                    \"META-INF/services/org/apache/camel/language/*\",\n+                    \"META-INF/services/org/apache/camel/dataformat/*\"));\n+\n+            services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.DISCOVERY,\n+                    true,\n+                    \"META-INF/services/org/apache/camel/*\",\n+                    \"META-INF/services/org/apache/camel/management/*\",\n+                    \"META-INF/services/org/apache/camel/model/*\",\n+                    \"META-INF/services/org/apache/camel/configurer/*\"));\n+        }\n+\n+        @BuildStep\n+        void userServicePatterns(\n+                CamelConfig camelConfig,\n+                BuildProducer<CamelServicePatternBuildItem> services) {\n+\n+            camelConfig.service.discovery.includePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.DISCOVERY,\n+                    true,\n+                    list)));\n+\n+            camelConfig.service.discovery.excludePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.DISCOVERY,\n+                    false,\n+                    list)));\n+\n+            camelConfig.service.registry.includePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.REGISTRY,\n+                    true,\n+                    list)));\n+\n+            camelConfig.service.registry.excludePatterns.ifPresent(list -> services.produce(new CamelServicePatternBuildItem(\n+                    CamelServiceDestination.REGISTRY,\n+                    false,\n+                    list)));\n+        }\n+\n+        @BuildStep\n+        void camelServices(\n+                ApplicationArchivesBuildItem applicationArchives,\n+                List<CamelServicePatternBuildItem> servicePatterns,\n+                BuildProducer<CamelServiceBuildItem> camelServices) {\n+\n+            final PathFilter pathFilter = servicePatterns.stream()\n+                    .filter(patterns -> patterns.getDestination() == CamelServiceDestination.DISCOVERY)\n+                    .collect(\n+                            PathFilter.Builder::new,\n+                            (bldr, patterns) -> bldr.patterns(patterns.isInclude(), patterns.getPatterns()),\n+                            PathFilter.Builder::combine)\n+                    .build();\n+            CamelSupport.services(applicationArchives, pathFilter)\n+                    .forEach(camelServices::produce);\n         }\n \n         /*\n"}}, {"oid": "d82e823d5bcafc7424c32bca9a954b2042010cdf", "url": "https://github.com/apache/camel-quarkus/commit/d82e823d5bcafc7424c32bca9a954b2042010cdf", "message": "Fix #617 Registerable and discoverable Camel services", "committedDate": "2020-01-17T15:15:15Z", "type": "forcePushed"}, {"oid": "4720897b436fe540f7ac6b55e5209d35f5a6ff49", "url": "https://github.com/apache/camel-quarkus/commit/4720897b436fe540f7ac6b55e5209d35f5a6ff49", "message": "Fix #617 Registerable and discoverable Camel services", "committedDate": "2020-01-17T15:26:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368011742", "bodyText": "not a huge issue in our case but my understanding is that invoking build() multiple time on the same builder should produce the same result", "author": "lburgazzoli", "createdAt": "2020-01-17T16:03:22Z", "path": "extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.camel.quarkus.core.deployment.util;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import org.apache.camel.util.AntPathMatcher;\n+import org.apache.camel.util.ObjectHelper;\n+import org.jboss.jandex.DotName;\n+\n+/**\n+ * A utility able to filter resource paths using Ant-like includes and excludes.\n+ */\n+public class PathFilter {\n+    private final AntPathMatcher matcher = new AntPathMatcher();\n+    private final List<String> includePatterns;\n+    private final List<String> excludePatterns;\n+    private final Predicate<String> stringPredicate;\n+\n+    PathFilter(List<String> includePatterns, List<String> excludePatterns) {\n+        this.includePatterns = includePatterns;\n+        this.excludePatterns = excludePatterns;\n+\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            this.stringPredicate = path -> true;\n+        } else {\n+            this.stringPredicate = path -> {\n+                path = sanitize(path);\n+                // same logic as  org.apache.camel.main.DefaultRoutesCollector so exclude\n+                // take precedence over include\n+                for (String part : excludePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return false;\n+                    }\n+                }\n+                for (String part : includePatterns) {\n+                    if (matcher.match(part, path)) {\n+                        return true;\n+                    }\n+                }\n+                return ObjectHelper.isEmpty(includePatterns);\n+            };\n+        }\n+        ;\n+    }\n+\n+    public Predicate<String> asStringPredicate() {\n+        return stringPredicate;\n+    }\n+\n+    public Predicate<DotName> asDotNamePredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return dotName -> true;\n+        } else {\n+            return dotName -> stringPredicate.test(dotName.toString().replace('.', '/'));\n+        }\n+    }\n+\n+    public Predicate<Path> asPathPredicate() {\n+        if (ObjectHelper.isEmpty(excludePatterns) && ObjectHelper.isEmpty(includePatterns)) {\n+            return path -> true;\n+        } else {\n+            return path -> stringPredicate.test(sanitize(path.toString()));\n+        }\n+    }\n+\n+    static String sanitize(String path) {\n+        path = path.trim();\n+        return (!path.isEmpty() && path.charAt(0) == '/')\n+                ? path.substring(1)\n+                : path;\n+    }\n+\n+    public static class Builder {\n+        private List<String> includePatterns = new ArrayList<String>();\n+        private List<String> excludePatterns = new ArrayList<String>();\n+\n+        public Builder patterns(boolean isInclude, Collection<String> patterns) {\n+            if (isInclude) {\n+                include(patterns);\n+            } else {\n+                exclude(patterns);\n+            }\n+            return this;\n+        }\n+\n+        public Builder include(String pattern) {\n+            includePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder include(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(includePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder include(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> include(ps));\n+            return this;\n+        }\n+\n+        public Builder exclude(String pattern) {\n+            excludePatterns.add(sanitize(pattern));\n+            return this;\n+        }\n+\n+        public Builder exclude(Collection<String> patterns) {\n+            patterns.stream().map(PathFilter::sanitize).forEach(excludePatterns::add);\n+            return this;\n+        }\n+\n+        public Builder exclude(Optional<? extends Collection<String>> patterns) {\n+            patterns.ifPresent(ps -> exclude(ps));\n+            return this;\n+        }\n+\n+        public Builder combine(Builder other) {\n+            includePatterns.addAll(other.includePatterns);\n+            excludePatterns.addAll(other.excludePatterns);\n+            return this;\n+        }\n+\n+        public PathFilter build() {\n+            final List<String> incl = includePatterns;\n+            includePatterns = null; // avoid leaking the collection trough reuse of the builder", "originalCommit": "4720897b436fe540f7ac6b55e5209d35f5a6ff49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzMTIyOQ==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368031229", "bodyText": "invoking build() multiple time on the same builder should produce the same result\n\nIf the collection is not set to null here the following sequence would be possible:\nPathFilter.Builder b = new PathFilter.Builder();\nb.include(\"foo/bar\");\nPathFilter pf1 = b.build();\nb.include(\"bar/baz\");\nPathFilter pf2 = b.build();\n\nwhere pf1 and pf2 would have set the same list instance in their includePatterns fields. That would be really unwanted. That's a true reference leak that harms the immutability of PathFilter.\nI hold re-using builders for rather unusual and so I find breaking the re-use better than copying the list in the PathFilter constructor as a way to ensure immutability.", "author": "ppalaga", "createdAt": "2020-01-17T16:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAzNjU1Ng==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368036556", "bodyText": "At least document it as I think no-one expect the builder to be re-set once you invoke build()", "author": "lburgazzoli", "createdAt": "2020-01-17T16:54:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA0NDUwNQ==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368044505", "bodyText": "Done at https://github.com/apache/camel-quarkus/pull/618/files#diff-7d0dfbc8ca22f0eb14e77322fcda0902R143", "author": "ppalaga", "createdAt": "2020-01-17T17:11:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA1NzQzMg==", "url": "https://github.com/apache/camel-quarkus/pull/618#discussion_r368057432", "bodyText": "Well another, in my opinion, cleaner option is to copy the collection in each object built making it immutable. A variation of this is used in most of the framework that generates builders, like Lombok and similars one.\nMy 2c.", "author": "valdar", "createdAt": "2020-01-17T17:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODAxMTc0Mg=="}], "type": "inlineReview", "revised_code": {"commit": "671803a6dd20fe79f1ead3bf4f3f0d145b0e0f0b", "chunk": "diff --git a/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java b/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java\nindex 9502525aa..4c6772d1a 100644\n--- a/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java\n+++ b/extensions/core/deployment/src/main/java/org/apache/camel/quarkus/core/deployment/util/PathFilter.java\n\n@@ -139,6 +139,10 @@ public class PathFilter {\n             return this;\n         }\n \n+        /**\n+         * @throws NullPointerException if this method is called more than once for the same {@link Builder} instance.\n+         * @return                      a new {@link PathFilter}\n+         */\n         public PathFilter build() {\n             final List<String> incl = includePatterns;\n             includePatterns = null; // avoid leaking the collection trough reuse of the builder\n"}}, {"oid": "671803a6dd20fe79f1ead3bf4f3f0d145b0e0f0b", "url": "https://github.com/apache/camel-quarkus/commit/671803a6dd20fe79f1ead3bf4f3f0d145b0e0f0b", "message": "Do not register languages and dataformats so that they can be used in parallel with conflicting configs", "committedDate": "2020-01-17T17:10:46Z", "type": "forcePushed"}, {"oid": "7e11340ec7196c16aafcaed313f6090568fabe4e", "url": "https://github.com/apache/camel-quarkus/commit/7e11340ec7196c16aafcaed313f6090568fabe4e", "message": "Do not register languages and dataformats so that they can be used in parallel with conflicting configs", "committedDate": "2020-01-18T11:03:27Z", "type": "forcePushed"}, {"oid": "2597d800d6ce69fc1ec671ded53511c7ad3989c2", "url": "https://github.com/apache/camel-quarkus/commit/2597d800d6ce69fc1ec671ded53511c7ad3989c2", "message": "Revert \"Fix #620 Introduce CamelServiceInfo transformers\"\n\nThis reverts commit e6920d014fec0ea4ec52ab527fdd0d1ac05ad7ee.\n\nWe decided to adopt another approach", "committedDate": "2020-01-20T14:56:57Z", "type": "commit"}, {"oid": "c6315286e379845e8c33f733b52b68847a26c6e9", "url": "https://github.com/apache/camel-quarkus/commit/c6315286e379845e8c33f733b52b68847a26c6e9", "message": "Avoid using field injection in the core NativeImageProcessor", "committedDate": "2020-01-20T14:56:57Z", "type": "commit"}, {"oid": "1645a33ec868e4aa8f3e657e060e1c1d05fb6818", "url": "https://github.com/apache/camel-quarkus/commit/1645a33ec868e4aa8f3e657e060e1c1d05fb6818", "message": "Fix #617 Registerable and discoverable Camel services", "committedDate": "2020-01-20T16:24:48Z", "type": "commit"}, {"oid": "869af4136b086cde0ac914c54d162d1dbff1ce1c", "url": "https://github.com/apache/camel-quarkus/commit/869af4136b086cde0ac914c54d162d1dbff1ce1c", "message": "Do not register languages and dataformats so that they can be used in parallel with conflicting configs", "committedDate": "2020-01-20T16:24:48Z", "type": "commit"}, {"oid": "869af4136b086cde0ac914c54d162d1dbff1ce1c", "url": "https://github.com/apache/camel-quarkus/commit/869af4136b086cde0ac914c54d162d1dbff1ce1c", "message": "Do not register languages and dataformats so that they can be used in parallel with conflicting configs", "committedDate": "2020-01-20T16:24:48Z", "type": "forcePushed"}]}