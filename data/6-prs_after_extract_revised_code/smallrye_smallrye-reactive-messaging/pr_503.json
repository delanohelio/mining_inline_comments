{"pr_number": 503, "pr_title": "add lower-level worker pool registration method", "pr_createdAt": "2020-04-14T13:29:01Z", "pr_url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503", "timeline": [{"oid": "ae207f698f5ce298ec734bf48eaf90741ec07c6b", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/ae207f698f5ce298ec734bf48eaf90741ec07c6b", "message": "add lower-level worker pool registration method", "committedDate": "2020-04-14T13:27:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MjM2Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408172363", "bodyText": "What's the reason for not injecting the Config and using the Provider?\nI thought that was a source of issues?", "author": "kenfinnigan", "createdAt": "2020-04-14T14:17:35Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -38,9 +37,6 @@\n     @Inject\n     private ExecutionHolder executionHolder;\n \n-    @Inject", "originalCommit": "ae207f698f5ce298ec734bf48eaf90741ec07c6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM1NTI5NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408355294", "bodyText": "When I had this code in Quarkus, it caused problems, I will try to roll back to Instance", "author": "michalszynkiewicz", "createdAt": "2020-04-14T18:42:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3MjM2Mw=="}], "type": "inlineReview", "revised_code": null}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3Mjg1MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408172850", "bodyText": "Should this validation be in the other method so it doesn't need to be repeated in a runtime?\nNot sure what that means for parameters though", "author": "kenfinnigan", "createdAt": "2020-04-14T14:18:16Z", "path": "smallrye-reactive-messaging-provider/src/main/java/io/smallrye/reactive/messaging/connectors/WorkerPoolRegistry.java", "diffHunk": "@@ -105,39 +101,45 @@ private WorkerExecutor getWorker(String workerName) {\n                 .forEach(m -> defineWorker(m.getJavaMember()));\n     }\n \n-    private void defineWorker(Method method) {\n+    public void defineWorker(String className, String method, String poolName) {\n+        Objects.requireNonNull(className, \"className was empty\");\n         Objects.requireNonNull(method, \"Method was empty\");\n \n-        Blocking blocking = method.getAnnotation(Blocking.class);\n-\n-        // Validate @Blocking is used in conjunction with @Incoming, or @Outgoing\n-        if (!(method.isAnnotationPresent(Incoming.class) || method.isAnnotationPresent(Outgoing.class))) {\n-            throw getBlockingError(method, \"no @Incoming or @Outgoing present\");\n-        }\n-\n-        if (!blocking.value().equals(Blocking.DEFAULT_WORKER_POOL)) {\n+        if (!poolName.equals(Blocking.DEFAULT_WORKER_POOL)) {\n             // Validate @Blocking value is not empty, if set\n-            if (Validation.isBlank(blocking.value())) {\n-                throw getBlockingError(method, \"value is blank or null\");\n+            if (Validation.isBlank(poolName)) {\n+                throw getBlockingError(className, method, \"value is blank or null\");\n             }\n \n             // Validate @Blocking worker pool has configuration to define concurrency\n-            String workerConfigKey = WORKER_CONFIG_PREFIX + \".\" + blocking.value() + \".\" + WORKER_CONCURRENCY;\n-            Optional<Integer> concurrency = configInstance.get().getOptionalValue(workerConfigKey, Integer.class);\n+            String workerConfigKey = WORKER_CONFIG_PREFIX + \".\" + poolName + \".\" + WORKER_CONCURRENCY;\n+            Optional<Integer> concurrency = ConfigProvider.getConfig().getOptionalValue(workerConfigKey, Integer.class);\n             if (!concurrency.isPresent()) {\n-                throw getBlockingError(method, workerConfigKey + \" was not defined\");\n+                throw getBlockingError(className, method, workerConfigKey + \" was not defined\");\n             }\n \n-            workerConcurrency.put(blocking.value(), concurrency.get());\n+            workerConcurrency.put(poolName, concurrency.get());\n         }\n     }\n \n-    private IllegalArgumentException getBlockingError(Method method, String message) {\n-        return new IllegalArgumentException(\n-                \"Invalid method annotated with @Blocking: \" + methodAsString(method) + \" - \" + message);\n+    private void defineWorker(Method method) {\n+        Objects.requireNonNull(method, \"Method was empty\");\n+\n+        Blocking blocking = method.getAnnotation(Blocking.class);\n+\n+        String methodName = method.getName();\n+        String className = method.getDeclaringClass().getName();\n+\n+        // Validate @Blocking is used in conjunction with @Incoming, or @Outgoing", "originalCommit": "ae207f698f5ce298ec734bf48eaf90741ec07c6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3NjQ3NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408176474", "bodyText": "I don't know. This check was done this way before my changes too.", "author": "michalszynkiewicz", "createdAt": "2020-04-14T14:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3Mjg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3NjQ4Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408176482", "bodyText": "Maybe pass an array of annotations on the method?", "author": "kenfinnigan", "createdAt": "2020-04-14T14:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3Mjg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3OTM1Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408179353", "bodyText": "Not sure what you mean. Quarkus doesn't do this check?\nMy presumption was that Quarkus is calling the defineWorker version that doesn't have the check. If it's calling the one with the check, that's fine", "author": "kenfinnigan", "createdAt": "2020-04-14T14:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3Mjg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE4OTQ4OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408189488", "bodyText": "oh, sorry, I misunderstood your question :)\nIt seems I missed it and Quarkus does not have this validation. I created an issue for it, will fix it tomorrow: quarkusio/quarkus#8567\nFor Quarkus we don't have info on the present annotations here, it's taken from Jandex so has to be done before calling defineWorker", "author": "michalszynkiewicz", "createdAt": "2020-04-14T14:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3Mjg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM2Njk4OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/503#discussion_r408366988", "bodyText": "@kenfinnigan I checked Quarkus once again and there @Blocking on methods that don't have @Incoming or @Outgoing will be ignored. That's because the logic for blocking is applied only to methods from MediatorBuildItems.\nAnyway, such validation makes sense and I will add it to Quarkus.", "author": "michalszynkiewicz", "createdAt": "2020-04-14T19:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODE3Mjg1MA=="}], "type": "inlineReview", "revised_code": null}]}