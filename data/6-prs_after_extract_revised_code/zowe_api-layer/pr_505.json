{"pr_number": 505, "pr_title": "enabler custom metadata support", "pr_createdAt": "2020-02-13T08:36:58Z", "pr_url": "https://github.com/zowe/api-layer/pull/505", "timeline": [{"oid": "72b27c76296de167fa53d66b0b57ea29d9ab088e", "url": "https://github.com/zowe/api-layer/commit/72b27c76296de167fa53d66b0b57ea29d9ab088e", "message": "fix after rebase\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-14T14:49:06Z", "type": "forcePushed"}, {"oid": "2546c473895345cc567cb35d77138b07e2fad705", "url": "https://github.com/zowe/api-layer/commit/2546c473895345cc567cb35d77138b07e2fad705", "message": "fix after rebase\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-14T14:57:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTcyMg==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r379529722", "bodyText": "No need to assign variable that is not used, just mapUtils.flattenMap(null, testMap); will throw the exception. Same in tests below.", "author": "cZikos", "createdAt": "2020-02-14T16:37:33Z", "path": "common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.hasEntry;\n+import static org.junit.Assert.assertThat;\n+\n+public class MapUtilsTest {\n+\n+    private MapUtils mapUtils = new MapUtils();\n+\n+    @Test\n+    public void givenMap_whenFlattenedWithRootKey_shouldReturnMapKeysWithRootKey() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key\", null);\n+        Map<String, String> resultMap = mapUtils.flattenMap(\"apiml\", testMap);\n+        assertThat(resultMap, hasEntry(\"apiml.key\", \"\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithNullValue_whenFlattened_shouldReturnValueEmptyString() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key\", null);\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"key\", \"\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithPrimitiveValues_whenFlattened_shouldReturnCorrectValues() {\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"key1\", true);\n+        testMap.put(\"key2\", 23);\n+        testMap.put(\"key3\", 23.0d);\n+        testMap.put(\"key4\", 23.0f);\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"key1\", \"true\"));\n+        assertThat(resultMap, hasEntry(\"key2\", \"23\"));\n+        assertThat(resultMap, hasEntry(\"key3\", \"23.0\"));\n+        assertThat(resultMap, hasEntry(\"key4\", \"23.0\"));\n+    }\n+\n+    @Test\n+    public void givenMapWithNestedMap_whenFlattened_shouldReturnFlattened() {\n+        Map<String, Object> nestedLvl2 = new HashMap<>();\n+        nestedLvl2.put(\"keyzzz\", \"valuezzz\");\n+\n+        Map<String, Object> nested = new HashMap<>();\n+        nested.put(\"key1\", \"value1\");\n+        nested.put(\"key2\", \"value2\");\n+        nested.put(\"key3\", nestedLvl2);\n+\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"masterKey\", nested);\n+\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n+        assertThat(resultMap, hasEntry(\"masterKey.key1\", \"value1\"));\n+        assertThat(resultMap, hasEntry(\"masterKey.key2\", \"value2\"));\n+        assertThat(resultMap, hasEntry(\"masterKey.key3.keyzzz\", \"valuezzz\"));\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void givenMapWithNestedList_whenFlattened_shouldReturnException() {\n+        List<Object> nested = new ArrayList<>();\n+        nested.add(\"value1\");\n+        nested.add(\"value2\");\n+\n+        Map<String, Object> testMap = new HashMap<>();\n+        testMap.put(\"masterKey\", nested);\n+\n+        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);", "originalCommit": "5e1a4f3ea0a22a6fafd5f96224093939d9fe3fc5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE2ODU5Mw==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380168593", "bodyText": "Thank you!", "author": "jandadav", "createdAt": "2020-02-17T13:01:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUyOTcyMg=="}], "type": "inlineReview", "revised_code": {"commit": "38ab5a76b01eded1a6cb0880dc278ee8f1bfcd42", "chunk": "diff --git a/common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java b/common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java\ndeleted file mode 100644\nindex 34259772..00000000\n--- a/common-service-core/src/test/java/org/zowe/apiml/util/MapUtilsTest.java\n+++ /dev/null\n\n@@ -1,106 +0,0 @@\n-/*\n- * This program and the accompanying materials are made available under the terms of the\n- * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n- * https://www.eclipse.org/legal/epl-v20.html\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- *\n- * Copyright Contributors to the Zowe Project.\n- */\n-\n-package org.zowe.apiml.util;\n-\n-import org.junit.Test;\n-\n-import java.math.BigDecimal;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import static org.hamcrest.Matchers.hasEntry;\n-import static org.junit.Assert.assertThat;\n-\n-public class MapUtilsTest {\n-\n-    private MapUtils mapUtils = new MapUtils();\n-\n-    @Test\n-    public void givenMap_whenFlattenedWithRootKey_shouldReturnMapKeysWithRootKey() {\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"key\", null);\n-        Map<String, String> resultMap = mapUtils.flattenMap(\"apiml\", testMap);\n-        assertThat(resultMap, hasEntry(\"apiml.key\", \"\"));\n-    }\n-\n-    @Test\n-    public void givenMapWithNullValue_whenFlattened_shouldReturnValueEmptyString() {\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"key\", null);\n-        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n-        assertThat(resultMap, hasEntry(\"key\", \"\"));\n-    }\n-\n-    @Test\n-    public void givenMapWithPrimitiveValues_whenFlattened_shouldReturnCorrectValues() {\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"key1\", true);\n-        testMap.put(\"key2\", 23);\n-        testMap.put(\"key3\", 23.0d);\n-        testMap.put(\"key4\", 23.0f);\n-        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n-        assertThat(resultMap, hasEntry(\"key1\", \"true\"));\n-        assertThat(resultMap, hasEntry(\"key2\", \"23\"));\n-        assertThat(resultMap, hasEntry(\"key3\", \"23.0\"));\n-        assertThat(resultMap, hasEntry(\"key4\", \"23.0\"));\n-    }\n-\n-    @Test\n-    public void givenMapWithNestedMap_whenFlattened_shouldReturnFlattened() {\n-        Map<String, Object> nestedLvl2 = new HashMap<>();\n-        nestedLvl2.put(\"keyzzz\", \"valuezzz\");\n-\n-        Map<String, Object> nested = new HashMap<>();\n-        nested.put(\"key1\", \"value1\");\n-        nested.put(\"key2\", \"value2\");\n-        nested.put(\"key3\", nestedLvl2);\n-\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"masterKey\", nested);\n-\n-        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n-        assertThat(resultMap, hasEntry(\"masterKey.key1\", \"value1\"));\n-        assertThat(resultMap, hasEntry(\"masterKey.key2\", \"value2\"));\n-        assertThat(resultMap, hasEntry(\"masterKey.key3.keyzzz\", \"valuezzz\"));\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void givenMapWithNestedList_whenFlattened_shouldReturnException() {\n-        List<Object> nested = new ArrayList<>();\n-        nested.add(\"value1\");\n-        nested.add(\"value2\");\n-\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"masterKey\", nested);\n-\n-        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void givenMapWithNestedArray_whenFlattened_shouldReturnException() {\n-        String[] nested = {\"value1\", \"value2\"};\n-\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"masterKey\", nested);\n-\n-        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n-    }\n-\n-    @Test(expected = IllegalArgumentException.class)\n-    public void givenMapWithAnythingElseThanExpected_whenFlattened_shouldReturnException() {\n-        Map<String, Object> testMap = new HashMap<>();\n-        testMap.put(\"key1\", new BigDecimal(0));\n-        Map<String, String> resultMap = mapUtils.flattenMap(null, testMap);\n-    }\n-\n-}\n"}}, {"oid": "38ab5a76b01eded1a6cb0880dc278ee8f1bfcd42", "url": "https://github.com/zowe/api-layer/commit/38ab5a76b01eded1a6cb0880dc278ee8f1bfcd42", "message": "refactor configuration of discoverable client\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:09Z", "type": "commit"}, {"oid": "d677e2c0b5f2b211d86099224a2c72d0781d3ef2", "url": "https://github.com/zowe/api-layer/commit/d677e2c0b5f2b211d86099224a2c72d0781d3ef2", "message": "loading of metadata from yaml\nrefactorings\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "7a1f8c599bf7e8e904e01084d5bb56d83f566df1", "url": "https://github.com/zowe/api-layer/commit/7a1f8c599bf7e8e904e01084d5bb56d83f566df1", "message": "refactor of local config\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "6327db74c6a6774f419805bf7d81b66606b79df9", "url": "https://github.com/zowe/api-layer/commit/6327db74c6a6774f419805bf7d81b66606b79df9", "message": "incorporate changes after rebase\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "1d70f17a268f8b47a5b10da7048864c42e61366b", "url": "https://github.com/zowe/api-layer/commit/1d70f17a268f8b47a5b10da7048864c42e61366b", "message": "tests for config merging\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "38a5d1c01b6f03de9707e21d0a5e104daab548c6", "url": "https://github.com/zowe/api-layer/commit/38a5d1c01b6f03de9707e21d0a5e104daab548c6", "message": "enableUrlEncodedCharacters for DC\nadded tests for primitive deserialization\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "2a8da78a57d129d59ac615792172010435017a8e", "url": "https://github.com/zowe/api-layer/commit/2a8da78a57d129d59ac615792172010435017a8e", "message": "fix string format\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "44890423b2b0e6a867299b3f2d542f3e3041f1bc", "url": "https://github.com/zowe/api-layer/commit/44890423b2b0e6a867299b3f2d542f3e3041f1bc", "message": "move classes\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "3329b16aa68ef322773887ffef6f5074801aab05", "url": "https://github.com/zowe/api-layer/commit/3329b16aa68ef322773887ffef6f5074801aab05", "message": "refactor sonar issue\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "795d83ea6054d88a93c98dec303c9c7ad66021c4", "url": "https://github.com/zowe/api-layer/commit/795d83ea6054d88a93c98dec303c9c7ad66021c4", "message": "fix after rebase\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "2381de42217ea7ee5fe0285f6614cbad0573c3d2", "url": "https://github.com/zowe/api-layer/commit/2381de42217ea7ee5fe0285f6614cbad0573c3d2", "message": "remove irrelevant doc\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:10Z", "type": "commit"}, {"oid": "e911ae94d803551af714911279ab5b2e0982df26", "url": "https://github.com/zowe/api-layer/commit/e911ae94d803551af714911279ab5b2e0982df26", "message": "custom metadata for static definitions\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:11Z", "type": "commit"}, {"oid": "3729756e07767ff522cec67e1e2ff4533520da0e", "url": "https://github.com/zowe/api-layer/commit/3729756e07767ff522cec67e1e2ff4533520da0e", "message": "Tests are good\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:11Z", "type": "commit"}, {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb", "url": "https://github.com/zowe/api-layer/commit/6e2edacac2cac529ad948018b4dd323530e2feeb", "message": "Review refactor\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:11Z", "type": "commit"}, {"oid": "6e2edacac2cac529ad948018b4dd323530e2feeb", "url": "https://github.com/zowe/api-layer/commit/6e2edacac2cac529ad948018b4dd323530e2feeb", "message": "Review refactor\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T07:06:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MTI1OQ==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380571259", "bodyText": "What about make this mapping in static part. For rootKey of course use BiFunction. In this case the map is constructed all times.", "author": "pj892031", "createdAt": "2020-02-18T10:03:52Z", "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {\n+\n+    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+        if (collection == null || collection.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<String, String> result = new HashMap<>();\n+\n+        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();", "originalCommit": "6e2edacac2cac529ad948018b4dd323530e2feeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjQzNg==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106436", "bodyText": "check out the latest impl, I've modified the code to do this", "author": "jandadav", "createdAt": "2020-02-19T06:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MTI1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "6551e1fb846234e11451f8557bc32a4f809dc5b3", "chunk": "diff --git a/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java b/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\nindex dd0792f5..5a98df8a 100644\n--- a/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\n+++ b/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\n\n@@ -10,49 +10,71 @@\n \n package org.zowe.apiml.util;\n \n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+\n import java.util.*;\n import java.util.function.Consumer;\n \n+@UtilityClass\n public class MapUtils {\n \n-    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+    @Getter\n+    @RequiredArgsConstructor\n+    private static final class Argument {\n+        @NonNull\n+        private final Map.Entry<String, Object> entry;\n+        @NonNull\n+        private final Map<String, String> result;\n+        private final String rootKey;\n+    }\n+\n+    private static final Consumer<Argument> MAP_CONSUMER = argument -> argument.getResult().putAll(flattenMap(mergeKey(argument.getRootKey(), argument.getEntry().getKey()), (Map<String, Object>) argument.getEntry().getValue()));\n+    private static final Consumer<Argument> PRIMITIVE_CONSUMER = argument -> argument.getResult().put(mergeKey(argument.getRootKey(), argument.getEntry().getKey()), argument.getEntry().getValue().toString());\n+    private static final Map<Class, Consumer<Argument>> ACTION_MAP = new LinkedHashMap<>();\n+\n+    static {\n+        ACTION_MAP.put(Map.class, MAP_CONSUMER);\n+        ACTION_MAP.put(String.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Boolean.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Integer.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Double.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Float.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(List.class, argument -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n+        ACTION_MAP.put(Object[].class, argument -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n+        ACTION_MAP.put(Object.class, argument -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", argument.getEntry().getKey(), argument.getEntry().getValue().toString())); } );\n+    }\n+\n+    public static Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n         if (collection == null || collection.isEmpty()) {\n             return Collections.emptyMap();\n         }\n \n         Map<String, String> result = new HashMap<>();\n \n-        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\n-        actionMap.put(Map.class, entry -> result.putAll(flattenMap(mergeKey(rootKey, entry.getKey()), (Map<String, Object>)entry.getValue())));\n-        actionMap.put(String.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Boolean.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Integer.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Double.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Float.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(List.class, entry -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n-        actionMap.put(Object[].class, entry -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n-        actionMap.put(Object.class, entry -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", entry.getKey(), entry.getValue().toString())); } );\n-\n         for (Map.Entry<String, Object> entry : collection.entrySet()) {\n             if (entry.getValue() == null) {\n                 result.put( mergeKey(rootKey, entry.getKey()), \"\");\n                 continue;\n             }\n-            executeAction(entry,actionMap);\n+            executeAction(new Argument(entry, result, rootKey));\n         }\n         return result;\n     }\n \n-    private void executeAction(Map.Entry<String, Object> switchSubject, Map<Class, Consumer<Map.Entry<String, Object>>> actionMap) {\n-        for (Map.Entry<Class, Consumer<Map.Entry<String, Object>>> action : actionMap.entrySet()) {\n-            if (action.getKey().isInstance(switchSubject.getValue())) {\n-                action.getValue().accept(switchSubject);\n+    private static void executeAction(Argument argument) {\n+\n+        for (Map.Entry<Class, Consumer<Argument>> action : ACTION_MAP.entrySet()) {\n+            if (action.getKey().isInstance(argument.getEntry().getValue())) {\n+                action.getValue().accept(argument);\n                 break;\n             }\n         }\n     }\n \n-    private String mergeKey(String rootKey, String newKey) {\n+    private static String mergeKey(String rootKey, String newKey) {\n         return rootKey != null ? rootKey + \".\" + newKey : newKey;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MjczMg==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380572732", "bodyText": "There is possible to test in first step with current class. If it is not found, then make this iteration and then store new type in the class. It could be helpfull (like cache), but I am not sure how often it is run.\nMap<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\nMap<Class, Consumer<Map.Entry<String, Object>>> cache = new HashMap<>();\nstatic {\ninit(actionMap);\ncache.putAll(actionMap)\n}\n....\nConsumer c = cache.get(...);\nif (c != null) return c....;\nfor (Entry e : actionMap) {\nif (instanceof...) {\ncache.put(class, e.getValue);\nreturn e.getValue....\n}", "author": "pj892031", "createdAt": "2020-02-18T10:06:28Z", "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {\n+\n+    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+        if (collection == null || collection.isEmpty()) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<String, String> result = new HashMap<>();\n+\n+        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\n+        actionMap.put(Map.class, entry -> result.putAll(flattenMap(mergeKey(rootKey, entry.getKey()), (Map<String, Object>)entry.getValue())));\n+        actionMap.put(String.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Boolean.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Integer.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Double.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(Float.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n+        actionMap.put(List.class, entry -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n+        actionMap.put(Object[].class, entry -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n+        actionMap.put(Object.class, entry -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", entry.getKey(), entry.getValue().toString())); } );\n+\n+        for (Map.Entry<String, Object> entry : collection.entrySet()) {\n+            if (entry.getValue() == null) {\n+                result.put( mergeKey(rootKey, entry.getKey()), \"\");\n+                continue;\n+            }\n+            executeAction(entry,actionMap);\n+        }\n+        return result;\n+    }\n+\n+    private void executeAction(Map.Entry<String, Object> switchSubject, Map<Class, Consumer<Map.Entry<String, Object>>> actionMap) {\n+        for (Map.Entry<Class, Consumer<Map.Entry<String, Object>>> action : actionMap.entrySet()) {", "originalCommit": "6e2edacac2cac529ad948018b4dd323530e2feeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjU0NQ==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106545", "bodyText": "check out the latest impl", "author": "jandadav", "createdAt": "2020-02-19T06:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3MjczMg=="}], "type": "inlineReview", "revised_code": {"commit": "6551e1fb846234e11451f8557bc32a4f809dc5b3", "chunk": "diff --git a/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java b/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\nindex dd0792f5..5a98df8a 100644\n--- a/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\n+++ b/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\n\n@@ -10,49 +10,71 @@\n \n package org.zowe.apiml.util;\n \n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+\n import java.util.*;\n import java.util.function.Consumer;\n \n+@UtilityClass\n public class MapUtils {\n \n-    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+    @Getter\n+    @RequiredArgsConstructor\n+    private static final class Argument {\n+        @NonNull\n+        private final Map.Entry<String, Object> entry;\n+        @NonNull\n+        private final Map<String, String> result;\n+        private final String rootKey;\n+    }\n+\n+    private static final Consumer<Argument> MAP_CONSUMER = argument -> argument.getResult().putAll(flattenMap(mergeKey(argument.getRootKey(), argument.getEntry().getKey()), (Map<String, Object>) argument.getEntry().getValue()));\n+    private static final Consumer<Argument> PRIMITIVE_CONSUMER = argument -> argument.getResult().put(mergeKey(argument.getRootKey(), argument.getEntry().getKey()), argument.getEntry().getValue().toString());\n+    private static final Map<Class, Consumer<Argument>> ACTION_MAP = new LinkedHashMap<>();\n+\n+    static {\n+        ACTION_MAP.put(Map.class, MAP_CONSUMER);\n+        ACTION_MAP.put(String.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Boolean.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Integer.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Double.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Float.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(List.class, argument -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n+        ACTION_MAP.put(Object[].class, argument -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n+        ACTION_MAP.put(Object.class, argument -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", argument.getEntry().getKey(), argument.getEntry().getValue().toString())); } );\n+    }\n+\n+    public static Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n         if (collection == null || collection.isEmpty()) {\n             return Collections.emptyMap();\n         }\n \n         Map<String, String> result = new HashMap<>();\n \n-        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\n-        actionMap.put(Map.class, entry -> result.putAll(flattenMap(mergeKey(rootKey, entry.getKey()), (Map<String, Object>)entry.getValue())));\n-        actionMap.put(String.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Boolean.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Integer.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Double.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Float.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(List.class, entry -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n-        actionMap.put(Object[].class, entry -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n-        actionMap.put(Object.class, entry -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", entry.getKey(), entry.getValue().toString())); } );\n-\n         for (Map.Entry<String, Object> entry : collection.entrySet()) {\n             if (entry.getValue() == null) {\n                 result.put( mergeKey(rootKey, entry.getKey()), \"\");\n                 continue;\n             }\n-            executeAction(entry,actionMap);\n+            executeAction(new Argument(entry, result, rootKey));\n         }\n         return result;\n     }\n \n-    private void executeAction(Map.Entry<String, Object> switchSubject, Map<Class, Consumer<Map.Entry<String, Object>>> actionMap) {\n-        for (Map.Entry<Class, Consumer<Map.Entry<String, Object>>> action : actionMap.entrySet()) {\n-            if (action.getKey().isInstance(switchSubject.getValue())) {\n-                action.getValue().accept(switchSubject);\n+    private static void executeAction(Argument argument) {\n+\n+        for (Map.Entry<Class, Consumer<Argument>> action : ACTION_MAP.entrySet()) {\n+            if (action.getKey().isInstance(argument.getEntry().getValue())) {\n+                action.getValue().accept(argument);\n                 break;\n             }\n         }\n     }\n \n-    private String mergeKey(String rootKey, String newKey) {\n+    private static String mergeKey(String rootKey, String newKey) {\n         return rootKey != null ? rootKey + \".\" + newKey : newKey;\n     }\n }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzczOA==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380577738", "bodyText": "empty (null) values should not be set", "author": "pj892031", "createdAt": "2020-02-18T10:15:25Z", "path": "onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.eurekaservice.client.util;\n+\n+import com.netflix.appinfo.EurekaInstanceConfig;\n+import org.zowe.apiml.config.ApiInfo;\n+import org.zowe.apiml.eurekaservice.client.config.*;\n+import org.zowe.apiml.exception.MetadataValidationException;\n+import org.zowe.apiml.exception.ServiceDefinitionException;\n+import org.zowe.apiml.util.MapUtils;\n+import org.zowe.apiml.util.UrlUtils;\n+\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.zowe.apiml.constants.EurekaMetadataDefinition.*;\n+\n+public class EurekaInstanceConfigCreator {\n+\n+    private final MapUtils mapUtils;\n+\n+    public EurekaInstanceConfigCreator(MapUtils mapUtils) {\n+        this.mapUtils = mapUtils;\n+    }\n+\n+    public EurekaInstanceConfig createEurekaInstanceConfig(ApiMediationServiceConfig config) throws ServiceDefinitionException {\n+        ApimlEurekaInstanceConfig result = new ApimlEurekaInstanceConfig();\n+\n+        String hostname;\n+        int port;\n+        URL baseUrl;\n+\n+        try {\n+            baseUrl = new URL(config.getBaseUrl());\n+            hostname = baseUrl.getHost();\n+            port = baseUrl.getPort();\n+        } catch (MalformedURLException e) {\n+            String message = String.format(\"baseUrl: [%s] is not valid URL\", config.getBaseUrl());\n+            throw new ServiceDefinitionException(message, e);\n+        }\n+\n+        result.setInstanceId(String.format(\"%s:%s:%s\", hostname, config.getServiceId(), port));\n+        result.setAppname(config.getServiceId());\n+        result.setAppGroupName(config.getServiceId());\n+        result.setHostName(hostname);\n+        result.setIpAddress(config.getServiceIpAddress());\n+        result.setInstanceEnabledOnit(true);\n+        result.setSecureVirtualHostName(config.getServiceId());\n+        result.setVirtualHostName(config.getServiceId());\n+        result.setStatusPageUrl(config.getBaseUrl() + config.getStatusPageRelativeUrl());\n+\n+        if ((config.getHomePageRelativeUrl() != null) && !config.getHomePageRelativeUrl().isEmpty()) {\n+            result.setHomePageUrl(config.getBaseUrl() + config.getHomePageRelativeUrl());\n+        }\n+\n+        String protocol = baseUrl.getProtocol();\n+        result.setNonSecurePort(port);\n+        result.setSecurePort(port);\n+\n+        switch (protocol) {\n+            case \"http\":\n+                result.setNonSecurePortEnabled(true);\n+                result.setHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            case \"https\":\n+                result.setSecurePortEnabled(true);\n+                result.setSecureHealthCheckUrl(config.getBaseUrl() + config.getHealthCheckRelativeUrl());\n+                break;\n+            default:\n+                throw new ServiceDefinitionException(String.format(\"'%s' is not valid protocol for baseUrl property\", protocol));\n+        }\n+\n+        try {\n+            result.setMetadataMap(createMetadata(config));\n+        } catch (MetadataValidationException | IllegalArgumentException e) {\n+            throw new ServiceDefinitionException(\"Service configuration failed to create service metadata: \", e);\n+        }\n+\n+        return result;\n+    }\n+\n+    private Map<String, String> createMetadata(ApiMediationServiceConfig config) {\n+        Map<String, String> metadata = new HashMap<>();\n+\n+        // fill authentication metadata\n+        Authentication authentication = config.getAuthentication();\n+        if (authentication != null) {\n+            metadata.put(AUTHENTICATION_SCHEME, authentication.getScheme());", "originalCommit": "6e2edacac2cac529ad948018b4dd323530e2feeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NzYwNw==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380597607", "bodyText": "It's just moved code from your PR", "author": "jandadav", "createdAt": "2020-02-18T10:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjcxNQ==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106715", "bodyText": "as we debated yesterday, i'll leave this part be as is", "author": "jandadav", "createdAt": "2020-02-19T06:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3NzczOA=="}], "type": "inlineReview", "revised_code": {"commit": "6551e1fb846234e11451f8557bc32a4f809dc5b3", "chunk": "diff --git a/onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java b/onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java\nindex b3d4d060..710c0c5e 100644\n--- a/onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java\n+++ b/onboarding-enabler-java/src/main/java/org/zowe/apiml/eurekaservice/client/util/EurekaInstanceConfigCreator.java\n\n@@ -27,12 +27,6 @@ import static org.zowe.apiml.constants.EurekaMetadataDefinition.*;\n \n public class EurekaInstanceConfigCreator {\n \n-    private final MapUtils mapUtils;\n-\n-    public EurekaInstanceConfigCreator(MapUtils mapUtils) {\n-        this.mapUtils = mapUtils;\n-    }\n-\n     public EurekaInstanceConfig createEurekaInstanceConfig(ApiMediationServiceConfig config) throws ServiceDefinitionException {\n         ApimlEurekaInstanceConfig result = new ApimlEurekaInstanceConfig();\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3ODgwNg==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380578806", "bodyText": "What about write it like class library (not as \"helper\")?\npublic final class MapUtils {\nprivate MapUtils() {}\npublic static final Map<String, String> flattenMap....\n}", "author": "pj892031", "createdAt": "2020-02-18T10:17:31Z", "path": "common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * This program and the accompanying materials are made available under the terms of the\n+ * Eclipse Public License v2.0 which accompanies this distribution, and is available at\n+ * https://www.eclipse.org/legal/epl-v20.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Copyright Contributors to the Zowe Project.\n+ */\n+\n+package org.zowe.apiml.util;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+public class MapUtils {", "originalCommit": "6e2edacac2cac529ad948018b4dd323530e2feeb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NjI3NA==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r380596274", "bodyText": "I intended to preserve the class so it can be mocked and it's methods can be mocked or spied on to help with testing.", "author": "jandadav", "createdAt": "2020-02-18T10:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3ODgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTEwNjc1OQ==", "url": "https://github.com/zowe/api-layer/pull/505#discussion_r381106759", "bodyText": "check out the latest impl, I've modified the code to do this", "author": "jandadav", "createdAt": "2020-02-19T06:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU3ODgwNg=="}], "type": "inlineReview", "revised_code": {"commit": "6551e1fb846234e11451f8557bc32a4f809dc5b3", "chunk": "diff --git a/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java b/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\nindex dd0792f5..5a98df8a 100644\n--- a/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\n+++ b/common-service-core/src/main/java/org/zowe/apiml/util/MapUtils.java\n\n@@ -10,49 +10,71 @@\n \n package org.zowe.apiml.util;\n \n+import lombok.Getter;\n+import lombok.NonNull;\n+import lombok.RequiredArgsConstructor;\n+import lombok.experimental.UtilityClass;\n+\n import java.util.*;\n import java.util.function.Consumer;\n \n+@UtilityClass\n public class MapUtils {\n \n-    public Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n+    @Getter\n+    @RequiredArgsConstructor\n+    private static final class Argument {\n+        @NonNull\n+        private final Map.Entry<String, Object> entry;\n+        @NonNull\n+        private final Map<String, String> result;\n+        private final String rootKey;\n+    }\n+\n+    private static final Consumer<Argument> MAP_CONSUMER = argument -> argument.getResult().putAll(flattenMap(mergeKey(argument.getRootKey(), argument.getEntry().getKey()), (Map<String, Object>) argument.getEntry().getValue()));\n+    private static final Consumer<Argument> PRIMITIVE_CONSUMER = argument -> argument.getResult().put(mergeKey(argument.getRootKey(), argument.getEntry().getKey()), argument.getEntry().getValue().toString());\n+    private static final Map<Class, Consumer<Argument>> ACTION_MAP = new LinkedHashMap<>();\n+\n+    static {\n+        ACTION_MAP.put(Map.class, MAP_CONSUMER);\n+        ACTION_MAP.put(String.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Boolean.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Integer.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Double.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(Float.class, PRIMITIVE_CONSUMER);\n+        ACTION_MAP.put(List.class, argument -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n+        ACTION_MAP.put(Object[].class, argument -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n+        ACTION_MAP.put(Object.class, argument -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", argument.getEntry().getKey(), argument.getEntry().getValue().toString())); } );\n+    }\n+\n+    public static Map<String, String> flattenMap(String rootKey, Map<String, Object> collection) {\n         if (collection == null || collection.isEmpty()) {\n             return Collections.emptyMap();\n         }\n \n         Map<String, String> result = new HashMap<>();\n \n-        Map<Class, Consumer<Map.Entry<String, Object>>> actionMap = new LinkedHashMap<>();\n-        actionMap.put(Map.class, entry -> result.putAll(flattenMap(mergeKey(rootKey, entry.getKey()), (Map<String, Object>)entry.getValue())));\n-        actionMap.put(String.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Boolean.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Integer.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Double.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(Float.class, entry -> result.put(mergeKey(rootKey, entry.getKey()), entry.getValue().toString()));\n-        actionMap.put(List.class, entry -> { throw new IllegalArgumentException(\"List parsing is not supported\"); } );\n-        actionMap.put(Object[].class, entry -> { throw new IllegalArgumentException(\"Array parsing is not supported\"); } );\n-        actionMap.put(Object.class, entry -> { throw new IllegalArgumentException(String.format(\"Cannot parse key: %s with value %s\", entry.getKey(), entry.getValue().toString())); } );\n-\n         for (Map.Entry<String, Object> entry : collection.entrySet()) {\n             if (entry.getValue() == null) {\n                 result.put( mergeKey(rootKey, entry.getKey()), \"\");\n                 continue;\n             }\n-            executeAction(entry,actionMap);\n+            executeAction(new Argument(entry, result, rootKey));\n         }\n         return result;\n     }\n \n-    private void executeAction(Map.Entry<String, Object> switchSubject, Map<Class, Consumer<Map.Entry<String, Object>>> actionMap) {\n-        for (Map.Entry<Class, Consumer<Map.Entry<String, Object>>> action : actionMap.entrySet()) {\n-            if (action.getKey().isInstance(switchSubject.getValue())) {\n-                action.getValue().accept(switchSubject);\n+    private static void executeAction(Argument argument) {\n+\n+        for (Map.Entry<Class, Consumer<Argument>> action : ACTION_MAP.entrySet()) {\n+            if (action.getKey().isInstance(argument.getEntry().getValue())) {\n+                action.getValue().accept(argument);\n                 break;\n             }\n         }\n     }\n \n-    private String mergeKey(String rootKey, String newKey) {\n+    private static String mergeKey(String rootKey, String newKey) {\n         return rootKey != null ? rootKey + \".\" + newKey : newKey;\n     }\n }\n"}}, {"oid": "6551e1fb846234e11451f8557bc32a4f809dc5b3", "url": "https://github.com/zowe/api-layer/commit/6551e1fb846234e11451f8557bc32a4f809dc5b3", "message": "MapUtils Review refactor\n\nSigned-off-by: jandadav <janda.david@gmail.com>", "committedDate": "2020-02-18T16:04:14Z", "type": "commit"}]}