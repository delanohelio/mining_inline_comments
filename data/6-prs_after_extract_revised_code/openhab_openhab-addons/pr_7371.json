{"pr_number": 7371, "pr_title": "[monopriceaudio] Monoprice Whole House Amplifier Binding - initial contribution", "pr_createdAt": "2020-04-14T15:26:48Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/7371", "timeline": [{"oid": "29400b516a30c2ef2c2cfab386cd5863b935cda0", "url": "https://github.com/openhab/openhab-addons/commit/29400b516a30c2ef2c2cfab386cd5863b935cda0", "message": "Merge pull request #1 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-13T19:56:53Z", "type": "commit"}, {"oid": "bcb0a5701d08151c606b3a6bca2bd68741183040", "url": "https://github.com/openhab/openhab-addons/commit/bcb0a5701d08151c606b3a6bca2bd68741183040", "message": "MonopriceAudio Binding - initial contribution\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-14T02:29:25Z", "type": "commit"}, {"oid": "2254bbe8e988dd6b130b00aef8225e3b79c7a94c", "url": "https://github.com/openhab/openhab-addons/commit/2254bbe8e988dd6b130b00aef8225e3b79c7a94c", "message": "fix documentation issues\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-14T15:10:55Z", "type": "commit"}, {"oid": "b13b1f303241948a7647014b7adc5a14ee35dc48", "url": "https://github.com/openhab/openhab-addons/commit/b13b1f303241948a7647014b7adc5a14ee35dc48", "message": "Add logic set offline status if the controller is not responding\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T18:37:15Z", "type": "commit"}, {"oid": "37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "url": "https://github.com/openhab/openhab-addons/commit/37d791e6a6a787b77a5c60383d1f6a88adc6c9cd", "message": "Merge pull request #2 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-04-19T18:41:08Z", "type": "commit"}, {"oid": "7cc33e62f6c1dab46457526dda876750ff613a1d", "url": "https://github.com/openhab/openhab-addons/commit/7cc33e62f6c1dab46457526dda876750ff613a1d", "message": "fix merge conflict in pom.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T18:44:19Z", "type": "commit"}, {"oid": "3f077b3e504cbe95b4b0b0676ed034b87476f25c", "url": "https://github.com/openhab/openhab-addons/commit/3f077b3e504cbe95b4b0b0676ed034b87476f25c", "message": "update pom version to 2.5.5\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-04-19T20:08:28Z", "type": "commit"}, {"oid": "546783b7ac100c45270e008dd7b55e0d5c781e37", "url": "https://github.com/openhab/openhab-addons/commit/546783b7ac100c45270e008dd7b55e0d5c781e37", "message": "Removed advanced from treble, bass and balance in channels.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-01T22:24:37Z", "type": "commit"}, {"oid": "8485fa9668467a03627b328488f892594e0ca8d3", "url": "https://github.com/openhab/openhab-addons/commit/8485fa9668467a03627b328488f892594e0ca8d3", "message": "Cleanup before review\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-22T16:09:05Z", "type": "commit"}, {"oid": "99430f8919968fda476e81cb27e1bd44b1a19752", "url": "https://github.com/openhab/openhab-addons/commit/99430f8919968fda476e81cb27e1bd44b1a19752", "message": "update pom version to 2.5.6\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-23T04:53:31Z", "type": "commit"}, {"oid": "399741ecdd8a650362929167b0227e70a9885b4c", "url": "https://github.com/openhab/openhab-addons/commit/399741ecdd8a650362929167b0227e70a9885b4c", "message": "refactored to minimize unnecessary channel updates\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-25T22:05:28Z", "type": "commit"}, {"oid": "82462cd7c0499460c54237c70b956459bd53d8b3", "url": "https://github.com/openhab/openhab-addons/commit/82462cd7c0499460c54237c70b956459bd53d8b3", "message": "Merge pull request #3 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-05-27T03:57:29Z", "type": "commit"}, {"oid": "7643886a75fe02b8479e92b71bc7f63a799739ae", "url": "https://github.com/openhab/openhab-addons/commit/7643886a75fe02b8479e92b71bc7f63a799739ae", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-05-27T04:27:37Z", "type": "commit"}, {"oid": "70cd561d206e45925692019f6199bcaa2a5d8515", "url": "https://github.com/openhab/openhab-addons/commit/70cd561d206e45925692019f6199bcaa2a5d8515", "message": "more cleanup\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-05-27T05:03:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzI4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827287", "bodyText": "Is there a reason for Nullable?", "author": "fwolter", "createdAt": "2020-05-30T09:43:16Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+\n+    QUERY(\"?\"),\n+    BEGIN_CMD(\"<\"),\n+    END_CMD(\"\\r\"),\n+\n+    POWER_ON(\"PR01\"),\n+    POWER_OFF(\"PR00\"),\n+    SOURCE(\"CH\"),\n+    VOLUME(\"VO\"),\n+    MUTE_ON(\"MU01\"),\n+    MUTE_OFF(\"MU00\"),\n+    TREBLE(\"TR\"),\n+    BASS(\"BS\"),\n+    BALANCE(\"BL\"),\n+    DND_ON(\"DT01\"),\n+    DND_OFF(\"DT00\");\n+\n+    private @Nullable String value;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNzU5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433007590", "bodyText": "NM, fixed.", "author": "mlobstein", "createdAt": "2020-06-01T01:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzI4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "a9d29a8ea5ab145757680c602e69f784d66e52e3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\nindex b528b11d10..921dcb02c4 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\n\n@@ -39,7 +39,7 @@ public enum MonopriceAudioCommand {\n     DND_ON(\"DT01\"),\n     DND_OFF(\"DT00\");\n \n-    private @Nullable String value;\n+    private String value;\n \n     MonopriceAudioCommand(String value) {\n         this.value = value;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827513", "bodyText": "What is expected to throw a InterruptedIOException?", "author": "fwolter", "createdAt": "2020-05-30T09:47:02Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwNzk3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433007978", "bodyText": "Not sure, it was there in rotel.", "author": "mlobstein", "createdAt": "2020-06-01T01:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQwNTgxNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433405814", "bodyText": "Since it is a checked exception, you can remove the declaration without any risk.", "author": "fwolter", "createdAt": "2020-06-01T18:17:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NDIwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433454204", "bodyText": "removed", "author": "mlobstein", "createdAt": "2020-06-01T19:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzUxMw=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzU4Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827582", "bodyText": "This exception is logged here and in MonopriceAudioReaderThread.", "author": "fwolter", "createdAt": "2020-05-30T09:48:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAwOTA3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433009072", "bodyText": "removed.", "author": "mlobstein", "createdAt": "2020-06-01T01:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzU4Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzc4NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    byte[] message = new byte[0];\n          \n          \n            \n                    byte[] message;", "author": "fwolter", "createdAt": "2020-05-30T09:51:36Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzk3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432827974", "bodyText": "Is this message necessary? The content is logged again below.", "author": "fwolter", "createdAt": "2020-05-30T09:54:38Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxMDA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433010093", "bodyText": "I removed one.", "author": "mlobstein", "createdAt": "2020-06-01T01:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyNzk3NA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODE2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828167", "bodyText": "If you log exceptions where they are eventually catched, you don't have to take care if the same error is logged multiple times. This exception is logged here and at least at MonopriceAudioHandler:400.", "author": "fwolter", "createdAt": "2020-05-30T09:57:22Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAzNjExOA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433036118", "bodyText": "yeah I see now rotel was very verbose in this regard.", "author": "mlobstein", "createdAt": "2020-06-01T04:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODE2Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODI4MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828280", "bodyText": "Better specify the encoding you expect.", "author": "fwolter", "createdAt": "2020-05-30T09:59:23Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODU3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828578", "bodyText": "It's bad practice to catch unchecked exceptions. Can you evaluate the return value of find()?", "author": "fwolter", "createdAt": "2020-05-30T10:03:18Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (READ_ERROR.equals(message)) {\n+            dispatchKeyValue(KEY_ERROR, MSG_VALUE_ON);\n+            return;\n+        }\n+\n+        // Amp controller sends status string: #>1200010000130809100601\n+        Pattern p = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+        try {\n+            Matcher matcher = p.matcher(message);\n+            matcher.find();\n+            // pull out just the digits and send them as an event\n+            dispatchKeyValue(KEY_ZONE_UPDATE, matcher.group(1));\n+        } catch (IllegalStateException e) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxMjY0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433012640", "bodyText": "I will fix all of these!", "author": "mlobstein", "createdAt": "2020-06-01T01:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODU3OA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyODY5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432828694", "bodyText": "Syntactical sugar:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (int i = 0; i < listeners.size(); i++) {\n          \n          \n            \n                        listeners.get(i).onNewMessageEvent(event);\n          \n          \n            \n                    }\n          \n          \n            \n                    listeners.forEach(l -> l.onNewMessageEvent(event));", "author": "fwolter", "createdAt": "2020-05-30T10:05:23Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message = new byte[0];\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+        }\n+        messageStr += MonopriceAudioCommand.END_CMD.getValue();\n+\n+        message = messageStr.getBytes(StandardCharsets.US_ASCII);\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(message);\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            logger.debug(\"Send command \\\"{}\\\" failed: {}\", messageStr, e.getMessage());\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n+        }\n+        logger.debug(\"Send command \\\"{}\\\" succeeded\", messageStr);\n+    }\n+\n+    /**\n+     * Add a listener to the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void addEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.add(listener);\n+    }\n+\n+    /**\n+     * Remove a listener from the list of listeners to be notified with events\n+     *\n+     * @param listener the listener\n+     */\n+    public void removeEventListener(MonopriceAudioMessageEventListener listener) {\n+        listeners.remove(listener);\n+    }\n+\n+    /**\n+     * Analyze an incoming message and dispatch corresponding (key, value) to the event listeners\n+     *\n+     * @param incomingMessage the received message\n+     */\n+    public void handleIncomingMessage(byte[] incomingMessage) {\n+        String message = new String(incomingMessage).trim();\n+\n+        logger.debug(\"handleIncomingMessage: {}\", message);\n+\n+        if (READ_ERROR.equals(message)) {\n+            dispatchKeyValue(KEY_ERROR, MSG_VALUE_ON);\n+            return;\n+        }\n+\n+        // Amp controller sends status string: #>1200010000130809100601\n+        Pattern p = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+        try {\n+            Matcher matcher = p.matcher(message);\n+            matcher.find();\n+            // pull out just the digits and send them as an event\n+            dispatchKeyValue(KEY_ZONE_UPDATE, matcher.group(1));\n+        } catch (IllegalStateException e) {\n+            logger.debug(\"no match on message: {}\", message);\n+        }\n+    }\n+\n+    /**\n+     * Dispatch an event (key, value) to the event listeners\n+     *\n+     * @param key the key\n+     * @param value the value\n+     */\n+    private void dispatchKeyValue(String key, String value) {\n+        MonopriceAudioMessageEvent event = new MonopriceAudioMessageEvent(this, key, value);\n+        for (int i = 0; i < listeners.size(); i++) {\n+            listeners.get(i).onNewMessageEvent(event);\n+        }", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex d038662bc4..f54d620110 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -36,9 +36,6 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public abstract class MonopriceAudioConnector {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n-\n     public static final String READ_ERROR = \"Command Error.\";\n \n     // Message types\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTA4Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829087", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T10:11:41Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(String address, Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.clientSocket = clientSocket;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"IP connection opened\");\n+        } catch (IOException | SecurityException | IllegalArgumentException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening IP connection failed: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NTY4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433455688", "bodyText": "should be good now", "author": "mlobstein", "createdAt": "2020-06-01T19:56:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTA4Nw=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\nindex 3252703078..f526ce936f 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\n\n@@ -37,8 +37,8 @@ public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n \n-    private String address;\n-    private int port;\n+    private @Nullable String address;\n+    private @Nullable Integer port;\n \n     private @Nullable Socket clientSocket;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTI1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829259", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T10:14:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private String address;\n+    private int port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(String address, Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);\n+            clientSocket.setSoTimeout(100);\n+\n+            dataOut = new DataOutputStream(clientSocket.getOutputStream());\n+            dataIn = new DataInputStream(clientSocket.getInputStream());\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.clientSocket = clientSocket;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"IP connection opened\");\n+        } catch (IOException | SecurityException | IllegalArgumentException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening IP connection failed: {}\", e.getMessage());\n+            throw new MonopriceAudioException(\"Opening IP connection failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void close() {\n+        logger.debug(\"Closing IP connection\");\n+        super.cleanup();\n+        Socket clientSocket = this.clientSocket;\n+        if (clientSocket != null) {\n+            try {\n+                clientSocket.close();\n+            } catch (IOException e) {\n+            }\n+            this.clientSocket = null;\n+        }\n+        setConnected(false);\n+        logger.debug(\"IP connection closed\");\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     * In case of socket timeout, the returned value is 0.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     * @throws InterruptedIOException - if the thread was interrupted during the reading of the input stream\n+     */\n+    @Override\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException, InterruptedIOException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (SocketTimeoutException e) {\n+            return 0;\n+        } catch (IOException e) {\n+            logger.debug(\"readInput failed: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\nindex 3252703078..f526ce936f 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\n\n@@ -37,8 +37,8 @@ public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n \n-    private String address;\n-    private int port;\n+    private @Nullable String address;\n+    private @Nullable Integer port;\n \n     private @Nullable Socket clientSocket;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgyOTkzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432829937", "bodyText": "This could be made a static field.", "author": "fwolter", "createdAt": "2020-05-30T10:24:41Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.InterruptedIOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Data listener started\");\n+\n+        final int size = 64;\n+        byte[] readDataBuffer = new byte[READ_BUFFER_SIZE];\n+        byte[] dataBuffer = new byte[size];\n+        int index = 0;\n+        final char terminatingChar = '\\r';", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\nindex af73a089fa..8f050fd5c2 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n\n@@ -28,10 +28,10 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public class MonopriceAudioReaderThread extends Thread {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n-\n     private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n \n     private MonopriceAudioConnector connector;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDAyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830027", "bodyText": "This could be made a static field.", "author": "fwolter", "createdAt": "2020-05-30T10:25:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.InterruptedIOException;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private static final int READ_BUFFER_SIZE = 16;\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;\n+    }\n+\n+    @Override\n+    public void run() {\n+        logger.debug(\"Data listener started\");\n+\n+        final int size = 64;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\nindex af73a089fa..8f050fd5c2 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n\n@@ -28,10 +28,10 @@ import org.slf4j.LoggerFactory;\n  */\n @NonNullByDefault\n public class MonopriceAudioReaderThread extends Thread {\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n-\n     private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n \n     private MonopriceAudioConnector connector;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830296", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T10:30:18Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjA5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433456091", "bodyText": "fixed.", "author": "mlobstein", "createdAt": "2020-06-01T19:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDI5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\nindex 0717363511..526aa64a8b 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n\n@@ -62,7 +62,6 @@ public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n             SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n             if (portIdentifier == null) {\n                 setConnected(false);\n-                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);\n                 throw new MonopriceAudioException(\"Opening serial connection failed: No Such Port\");\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDM5NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830394", "bodyText": "See above (each catch)", "author": "fwolter", "createdAt": "2020-05-30T10:31:34Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        try {\n+            SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n+            if (portIdentifier == null) {\n+                setConnected(false);\n+                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);\n+                throw new MonopriceAudioException(\"Opening serial connection failed: No Such Port\");\n+            }\n+\n+            SerialPort commPort = portIdentifier.open(this.getClass().getName(), 2000);\n+\n+            commPort.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+            commPort.enableReceiveThreshold(1);\n+            commPort.enableReceiveTimeout(100);\n+            commPort.setFlowControlMode(SerialPort.FLOWCONTROL_NONE);\n+\n+            InputStream dataIn = commPort.getInputStream();\n+            OutputStream dataOut = commPort.getOutputStream();\n+\n+            if (dataOut != null) {\n+                dataOut.flush();\n+            }\n+            if (dataIn != null && dataIn.markSupported()) {\n+                try {\n+                    dataIn.reset();\n+                } catch (IOException e) {\n+                }\n+            }\n+\n+            Thread thread = new MonopriceAudioReaderThread(this);\n+            setReaderThread(thread);\n+            thread.start();\n+\n+            this.serialPort = commPort;\n+            this.dataIn = dataIn;\n+            this.dataOut = dataOut;\n+\n+            setConnected(true);\n+\n+            logger.debug(\"Serial connection opened\");\n+        } catch (PortInUseException e) {\n+            setConnected(false);\n+            logger.warn(\"Opening serial connection failed: Port in Use Exception: {}\", e.getMessage(), e);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ1NjIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433456236", "bodyText": "yep done.", "author": "mlobstein", "createdAt": "2020-06-01T19:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDM5NA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\nindex 0717363511..526aa64a8b 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n\n@@ -62,7 +62,6 @@ public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n             SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n             if (portIdentifier == null) {\n                 setConnected(false);\n-                logger.warn(\"Opening serial connection failed: No Such Port: {}\", serialPortName);\n                 throw new MonopriceAudioException(\"Opening serial connection failed: No Such Port\");\n             }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDk4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432830984", "bodyText": "You could use valueOf() to get rid of the Maps in the MonopriceAudioZone Enum.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n          \n          \n            \n                                                        connector.sendCommand(MonopriceAudioZone.valueOf(\"ZONE\" + zoneId),", "author": "fwolter", "createdAt": "2020-05-30T10:40:46Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNTMyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433015324", "bodyText": "That is a great idea. ZONE_MAP removed!", "author": "mlobstein", "createdAt": "2020-06-01T02:13:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMDk4NA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjAyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832025", "bodyText": "Can you make these Nullable? You could combine the config validation in the handler with the != null checks to not blowing up your code.", "author": "fwolter", "createdAt": "2020-05-30T10:58:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+\n+    public @NonNullByDefault({}) Integer numZones;\n+    public @NonNullByDefault({}) Integer pollingInterval;\n+    public @NonNullByDefault({}) String serialPort;\n+    public @NonNullByDefault({}) String host;\n+    public @NonNullByDefault({}) Integer port;\n+    public @NonNullByDefault({}) String ignoreZones;\n+    public @NonNullByDefault({}) Integer initialAllVolume;\n+    public @NonNullByDefault({}) String inputLabel1;\n+    public @NonNullByDefault({}) String inputLabel2;\n+    public @NonNullByDefault({}) String inputLabel3;\n+    public @NonNullByDefault({}) String inputLabel4;\n+    public @NonNullByDefault({}) String inputLabel5;\n+    public @NonNullByDefault({}) String inputLabel6;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java\nindex 563d132e96..587243c505 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java\n\n@@ -13,6 +13,7 @@\n package org.openhab.binding.monopriceaudio.internal.configuration;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n \n /**\n  * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjEwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832104", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<String>();\n          \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<>();", "author": "fwolter", "createdAt": "2020-05-30T10:59:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjE4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832186", "bodyText": "Better use primitive types where possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Long lastPollingUpdate = System.currentTimeMillis();\n          \n          \n            \n                private long lastPollingUpdate = System.currentTimeMillis();", "author": "fwolter", "createdAt": "2020-05-30T11:00:56Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjIzMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832231", "bodyText": "Can this message be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T11:02:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNjc1Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433016753", "bodyText": "removed", "author": "mlobstein", "createdAt": "2020-06-01T02:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjIzMQ=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjYzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832630", "bodyText": "You could have had some fun with streams here. Next time...", "author": "fwolter", "createdAt": "2020-05-30T11:09:29Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMjkxMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432832911", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n          \n          \n            \n                                    ZONE + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);", "author": "fwolter", "createdAt": "2020-05-30T11:13:57Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzA5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833093", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n          \n          \n            \n                                if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone)))) {", "author": "fwolter", "createdAt": "2020-05-30T11:16:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833188", "bodyText": "Can these log messages be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T11:18:07Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzg0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433017845", "bodyText": "ok", "author": "mlobstein", "createdAt": "2020-06-01T02:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzE4OA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzIzOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833239", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:19:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833504", "bodyText": "There are lots of NonNull warnings for connector. You can reference connector with a local variable and check it for nullness. Then, these warnings will disappear.", "author": "fwolter", "createdAt": "2020-05-30T11:22:35Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyOTM0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r434129340", "bodyText": "Why not just null check connector directly in a few strategic places?\nIn the code above it would look like this:\nif (connector !=null && !connector.isConnected()) {....", "author": "mlobstein", "createdAt": "2020-06-02T19:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDE5MjAyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r434192022", "bodyText": "This code won't be thread-safe. connector could be set to null between the null check and invocation of isConnected(). The compiler would still complain.", "author": "fwolter", "createdAt": "2020-06-02T21:42:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg3ODM5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r434878399", "bodyText": "In the rotel binding (which this is based off of), they leave the connector variable as non-nullable and then new up the connector with a 'simulated' Impl class when the handler class is instantiated (thus is has a default value and is never null). Then they re-assign it to the desired real Impl (Serial, IP, etc.) during initialize(). Would that be acceptable here?", "author": "mlobstein", "createdAt": "2020-06-03T21:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQzOTc3OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435439779", "bodyText": "I like this approach with simple classes like ScheduledFutures. Be careful when using it with more complex ones when it comes to returning processing results of 'simulated' implementations when actually no processing has have happened.", "author": "fwolter", "createdAt": "2020-06-04T17:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTQ2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435569465", "bodyText": "@fwolter... The PR is ready for another look. I cleared up almost all of the warnings. There are a few pesky ones with the config that remain even though config is a local variable that can't be null and the fields are null checked explicitly :(", "author": "mlobstein", "createdAt": "2020-06-04T21:42:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzUwNA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzU4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833588", "bodyText": "Better use primitives int.", "author": "fwolter", "createdAt": "2020-05-30T11:24:02Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzY5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833699", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:25:27Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzcyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833721", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:25:42Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzc2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833763", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:26:14Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzMzk1MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432833951", "bodyText": "30ms are not enough to guarentee that the JVM will execute the following code in a different time slice, hence the sleep could be ignored. You should be safe with 100ms.", "author": "fwolter", "createdAt": "2020-05-30T11:29:57Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDEyMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834122", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T11:32:30Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE1NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834154", "bodyText": "See above. Please check the other occurrences down below.", "author": "fwolter", "createdAt": "2020-05-30T11:32:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxOTAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433019026", "bodyText": "got it", "author": "mlobstein", "createdAt": "2020-06-01T02:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE1NA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDE3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834170", "bodyText": "See above. Please check the other occurrences down below.", "author": "fwolter", "createdAt": "2020-05-30T11:33:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDQxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834419", "bodyText": "Can this be replaced by using the debugger?", "author": "fwolter", "createdAt": "2020-05-30T11:37:54Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDQ5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834490", "bodyText": "Should this be warn or can be completly removed?", "author": "fwolter", "createdAt": "2020-05-30T11:39:12Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834501", "bodyText": "Should this be warn?", "author": "fwolter", "createdAt": "2020-05-30T11:39:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834525", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:39:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDE5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433020195", "bodyText": "NM", "author": "mlobstein", "createdAt": "2020-06-01T02:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDUyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDY1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834650", "bodyText": "You can use == when using primitive types. Would < or > be more adequate here?", "author": "fwolter", "createdAt": "2020-05-30T11:41:42Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDI4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433020286", "bodyText": "I suppose so", "author": "mlobstein", "createdAt": "2020-06-01T02:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDY1MA=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834748", "bodyText": "No harm in cancelling an already canceled job.", "author": "fwolter", "createdAt": "2020-05-30T11:43:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834790", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:43:44Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDc5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834793", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:43:49Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNDgxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432834817", "bodyText": "See above", "author": "fwolter", "createdAt": "2020-05-30T11:44:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTE0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835148", "bodyText": "You could make that a static field to save resources.", "author": "fwolter", "createdAt": "2020-05-30T11:48:58Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneData zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = new DecimalType(zoneData.isPageActive() ? 1 : 0);\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = new DecimalType(zoneData.isKeypadActive() ? 1 : 0);\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneData zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601\n+            Pattern p = Pattern.compile(\n+                    \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTE3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835173", "bodyText": "Better evaluate the return value of find(), instead of catching the unchecked exception.", "author": "fwolter", "createdAt": "2020-05-30T11:49:26Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE + zoneNum.toString() + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    if (channels.removeIf(c -> (c.getUID().getId().contains(\"zone\" + zone.toString())))) {\n+                        logger.debug(\"Removed channels for zone: {}\", zone);\n+                    } else {\n+                        logger.debug(\"Could NOT remove channels for zone: {}\", zone);\n+                    }\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Disposing handler for thing {}\", getThing().getUID());\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        if (!connector.isConnected()) {\n+            logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.debug(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.debug(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            Integer value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.debug(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            Integer value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.ZONE_MAP.get(zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.debug(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector != null && connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+        logger.debug(\"onNewMessageEvent: key {} = {}\", evt.getKey(), evt.getValue());\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.ZONE_MAP.get(zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.debug(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            Long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (prevUpdateTime.equals(lastPollingUpdate)) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    }\n+                } else {\n+                    error = \"Reconnection failed\";\n+                }\n+                if (error != null) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                } else {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    lastPollingUpdate = System.currentTimeMillis();\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null && !reconnectJob.isCancelled()) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (connector.isConnected()) {\n+                logger.debug(\"Polling the controller for updated status...\");\n+\n+                synchronized (sequenceLock) {\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneId) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.ZONE_MAP.get(zoneId));\n+                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                        } catch (MonopriceAudioException | InterruptedException e) {\n+                            logger.debug(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneData zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = new DecimalType(zoneData.isPageActive() ? 1 : 0);\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = new DecimalType(zoneData.isKeypadActive() ? 1 : 0);\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneData zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601\n+            Pattern p = Pattern.compile(\n+                    \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+            try {\n+                Matcher matcher = p.matcher(newZoneData);\n+                matcher.find();", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTYyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r432835625", "bodyText": "You should handle the case, the user enters an invalid zone number. E.g. check for get() returning null or make the generic type of ignoreZones Nullable.", "author": "fwolter", "createdAt": "2020-05-30T11:56:19Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,754 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private long pollingInterval = TimeUnit.SECONDS.toSeconds(15);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(30);\n+\n+    private static final String ZONE = \"zone\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final Integer ONE = 1;\n+    private static final Integer MAX_ZONES = 18;\n+    private static final Integer MAX_SRC = 6;\n+    private static final Integer MIN_VOLUME = 0;\n+    private static final Integer MAX_VOLUME = 38;\n+    private static final Integer MIN_TONE = -7;\n+    private static final Integer MAX_TONE = 7;\n+    private static final Integer MIN_BALANCE = -10;\n+    private static final Integer MAX_BALANCE = 10;\n+    private static final Integer BALANCE_OFFSET = 10;\n+    private static final Integer TONE_OFFSET = 7;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable MonopriceAudioConnector connector;\n+\n+    private Integer numZones = 1;\n+    private ArrayList<String> ignoreZones = new ArrayList<String>();\n+    private Integer allVolume = 1;\n+    private Integer initialAllVolume = 1;\n+\n+    private static Map<String, MonopriceAudioZoneData> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneData());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneData());\n+    }\n+\n+    private Long lastPollingUpdate = System.currentTimeMillis();\n+\n+    private Object sequenceLock = new Object();\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing handler for thing {}\", getThing().getUID());\n+\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    ignoreZones.add(MonopriceAudioZone.BINDING_ZONE_MAP.get(zone));", "originalCommit": "70cd561d206e45925692019f6199bcaa2a5d8515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDMyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r433024320", "bodyText": "got catch, can't trust the user here!", "author": "mlobstein", "createdAt": "2020-06-01T03:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzNTYyNQ=="}], "type": "inlineReview", "revised_code": {"commit": "2f59993883de521456437c5b3471a0bb4844169e", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex f6d17af86d..7a972b0ef0 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -54,8 +54,8 @@ import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioM\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZoneData;\n import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n"}}, {"oid": "2f59993883de521456437c5b3471a0bb4844169e", "url": "https://github.com/openhab/openhab-addons/commit/2f59993883de521456437c5b3471a0bb4844169e", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T04:31:32Z", "type": "commit"}, {"oid": "646c6f39247be8ce22cf96ae97b863f3a1f72bc8", "url": "https://github.com/openhab/openhab-addons/commit/646c6f39247be8ce22cf96ae97b863f3a1f72bc8", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T05:20:31Z", "type": "commit"}, {"oid": "a9d29a8ea5ab145757680c602e69f784d66e52e3", "url": "https://github.com/openhab/openhab-addons/commit/a9d29a8ea5ab145757680c602e69f784d66e52e3", "message": "code review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T05:28:52Z", "type": "commit"}, {"oid": "16a523a0de2ce99db1a460a000bfdb0b1af2259c", "url": "https://github.com/openhab/openhab-addons/commit/16a523a0de2ce99db1a460a000bfdb0b1af2259c", "message": "implement code review changes from other PR\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T18:05:10Z", "type": "commit"}, {"oid": "d7c5ee5eb1e4a3bf8f23533fc5b372268697b8bf", "url": "https://github.com/openhab/openhab-addons/commit/d7c5ee5eb1e4a3bf8f23533fc5b372268697b8bf", "message": "Removed InterruptedIOException\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T20:00:47Z", "type": "commit"}, {"oid": "db01c93a26ef33d48f2827a7f313f87c35d55017", "url": "https://github.com/openhab/openhab-addons/commit/db01c93a26ef33d48f2827a7f313f87c35d55017", "message": "Use Contact instead of Number\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-01T21:31:09Z", "type": "commit"}, {"oid": "5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "url": "https://github.com/openhab/openhab-addons/commit/5d548ccb1f0c2dc140c006242aa61ed0b07b3d87", "message": "Merge pull request #4 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-04T21:19:29Z", "type": "commit"}, {"oid": "c677c0596be4b15330ed2f20c98e1a98a90a906a", "url": "https://github.com/openhab/openhab-addons/commit/c677c0596be4b15330ed2f20c98e1a98a90a906a", "message": "changes to fix null pointer warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-04T21:20:39Z", "type": "commit"}, {"oid": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "url": "https://github.com/openhab/openhab-addons/commit/a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "message": "fix CODEOWNERS conflicts\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-04T21:23:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTk5ODgwNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r435998805", "bodyText": "Use named threads.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;", "author": "fwolter", "createdAt": "2020-06-05T15:31:09Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        this.connector = connector;", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\nindex 8d78590d1f..2262d2f590 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n\n@@ -15,6 +15,7 @@ package org.openhab.binding.monopriceaudio.internal.communication;\n import java.util.Arrays;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMzIyMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436003223", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final ArrayList<String> VALID_ZONES = new ArrayList<String>(\n          \n          \n            \n                        Arrays.asList(ZONE1.getZoneId(), ZONE2.getZoneId(), ZONE3.getZoneId(), ZONE4.getZoneId(), ZONE5.getZoneId(),\n          \n          \n            \n                                ZONE6.getZoneId(), ZONE7.getZoneId(), ZONE8.getZoneId(), ZONE9.getZoneId(), ZONE10.getZoneId(),\n          \n          \n            \n                                ZONE11.getZoneId(), ZONE12.getZoneId(), ZONE13.getZoneId(), ZONE14.getZoneId(), ZONE15.getZoneId(),\n          \n          \n            \n                                ZONE16.getZoneId(), ZONE17.getZoneId(), ZONE18.getZoneId()));\n          \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.getZoneId())\n          \n          \n            \n                        .collect(Collectors.toList());", "author": "fwolter", "createdAt": "2020-06-05T15:37:34Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone ids\n+    public static final ArrayList<String> VALID_ZONES = new ArrayList<String>(\n+            Arrays.asList(ZONE1.getZoneId(), ZONE2.getZoneId(), ZONE3.getZoneId(), ZONE4.getZoneId(), ZONE5.getZoneId(),\n+                    ZONE6.getZoneId(), ZONE7.getZoneId(), ZONE8.getZoneId(), ZONE9.getZoneId(), ZONE10.getZoneId(),\n+                    ZONE11.getZoneId(), ZONE12.getZoneId(), ZONE13.getZoneId(), ZONE14.getZoneId(), ZONE15.getZoneId(),\n+                    ZONE16.getZoneId(), ZONE17.getZoneId(), ZONE18.getZoneId()));", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2MTg5MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436161891", "bodyText": "nice!", "author": "mlobstein", "createdAt": "2020-06-05T20:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwMzIyMw=="}], "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\nindex 03a7841d19..02d67b6c60 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n\n@@ -12,8 +12,9 @@\n  */\n package org.openhab.binding.monopriceaudio.internal.communication;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436006183", "bodyText": "Why is the null annotation disabled?", "author": "fwolter", "createdAt": "2020-06-05T15:42:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.configuration;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link MonopriceAudioThingConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioThingConfiguration {\n+    public Integer numZones = 1;\n+    public Integer pollingInterval = 15;\n+    public @NonNullByDefault({}) String serialPort;", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1ODM0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436158346", "bodyText": "Because SerialPortManager.getIdentifier(String name) takes a NonNullByDefault argument.", "author": "mlobstein", "createdAt": "2020-06-05T20:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzMwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857301", "bodyText": "You already do all null checks to be able to make this Nullable. Why not go for it?", "author": "fwolter", "createdAt": "2020-06-14T18:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjE4Mw=="}], "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java\nindex fba95aeb01..4428b562ff 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/configuration/MonopriceAudioThingConfiguration.java\n\n@@ -24,7 +24,7 @@ import org.eclipse.jdt.annotation.Nullable;\n public class MonopriceAudioThingConfiguration {\n     public Integer numZones = 1;\n     public Integer pollingInterval = 15;\n-    public @NonNullByDefault({}) String serialPort;\n+    public @Nullable String serialPort;\n     public @Nullable String host;\n     public @Nullable Integer port;\n     public @Nullable String ignoreZones;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNjU0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436006543", "bodyText": "Can be removed", "author": "fwolter", "createdAt": "2020-06-05T15:43:17Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.dto;\n+\n+/**\n+ * Represents the data elements of a single zone of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+public class MonopriceAudioZoneDTO {\n+\n+    private String zone;\n+    private String page;\n+    private String power;\n+    private String mute;\n+    private String dnd;\n+    private String volume;\n+    private String treble;\n+    private String bass;\n+    private String balance;\n+    private String source;\n+    private String keypad;\n+\n+    public MonopriceAudioZoneDTO() {\n+    }", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java\nindex 78d66f46ce..a058169edd 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/dto/MonopriceAudioZoneDTO.java\n\n@@ -31,9 +31,6 @@ public class MonopriceAudioZoneDTO {\n     private String source;\n     private String keypad;\n \n-    public MonopriceAudioZoneDTO() {\n-    }\n-\n     public void setZone(String zone) {\n         this.zone = zone;\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNzY4NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436007684", "bodyText": "You could replace this by a stream operation, too. See above.", "author": "fwolter", "createdAt": "2020-06-05T15:45:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2MjE4OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436162188", "bodyText": "done.", "author": "mlobstein", "createdAt": "2020-06-05T21:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwNzY4NA=="}], "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwODk1Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436008952", "bodyText": "Since there shouldn't be any concurrency issues with the configuration, you could annotate this method with @SuppressWarnings(\"null\"), to prevent the compiler warnings.", "author": "fwolter", "createdAt": "2020-06-05T15:47:36Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzg5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857890", "bodyText": "When I read this again, I think other reviewers won't be happy about this. You could initialize the config parameters with default values in your configuration class, to be able to remove the Nullables from the fields. Then, this suppression isn't necessary at all.", "author": "fwolter", "createdAt": "2020-06-14T18:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwODk1Mg=="}], "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAwOTUwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436009502", "bodyText": "These comments have no benefit and can be removed.", "author": "fwolter", "createdAt": "2020-06-05T15:48:30Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMTgzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436011830", "bodyText": "You might want to log a warning or throw an exception if the zone is out of range.", "author": "fwolter", "createdAt": "2020-06-05T15:52:37Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2Mzg4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436163883", "bodyText": "A warning will be enough I think.", "author": "mlobstein", "createdAt": "2020-06-05T21:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMTgzMA=="}], "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxMzEwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436013101", "bodyText": "The method of the base class has no implementation, therefore this could be remoeved.", "author": "fwolter", "createdAt": "2020-06-05T15:54:48Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk5MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436018990", "bodyText": "A timeout of 150ms seem a bit short. Are you sure is is enough under all circumstances?", "author": "fwolter", "createdAt": "2020-06-05T16:05:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.valueOf(ZONE + zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+                            Thread.sleep(150);", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2ODc2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436168764", "bodyText": "Yes 150 should be more than enough here. Actually I will change it to use the constant.", "author": "mlobstein", "createdAt": "2020-06-05T21:18:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk5MA=="}], "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDQyOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436024429", "bodyText": "Are you sure this synchronization is sufficent? If I see correctly scheduleReconnectJob() can be called from different threads. openConnection() itself is synchronized but what if multiple threads call it one after another at this location? Should the sequenceLock monitor start at the beginning of this scheduler job? Same for the polling job.", "author": "fwolter", "createdAt": "2020-06-05T16:15:04Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,749 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern.compile(\n+            \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    private static Map<String, MonopriceAudioZoneDTO> zoneDataMap = new HashMap<>();\n+    static {\n+        zoneDataMap.put(MonopriceAudioZone.ZONE1.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE2.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE3.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE4.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE5.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE6.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE7.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE8.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE9.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE10.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE11.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE12.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE13.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE14.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE15.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE16.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE17.getZoneId(), new MonopriceAudioZoneDTO());\n+        zoneDataMap.put(MonopriceAudioZone.ZONE18.getZoneId(), new MonopriceAudioZoneDTO());\n+    }\n+\n+    /**\n+     * Constructor\n+     */\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= 1 && zoneInt <=18) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            zoneDataMap.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                zoneDataMap.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            zoneDataMap.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                } catch (MonopriceAudioException | InterruptedException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                                Thread.sleep(SLEEP_BETWEEN_CMD);\n+                            } catch (MonopriceAudioException | InterruptedException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                    if (!ignoreZones.contains(zoneId)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                            Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                        } catch (MonopriceAudioException | InterruptedException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneId) -> {\n+                                if (!ignoreZones.contains(zoneId)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId), cmd);\n+                                        Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    } catch (MonopriceAudioException | InterruptedException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONES.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.valueOf(ZONE + zoneId);\n+                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Trying to reconnect...\");\n+                closeConnection();\n+                String error = null;\n+                if (openConnection()) {\n+                    synchronized (sequenceLock) {", "originalCommit": "a348e32260ac995ba5da1ceb33ec2e11f34b71f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDE5OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436170199", "bodyText": "I will change both to be sure.", "author": "mlobstein", "createdAt": "2020-06-05T21:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyNDQyOQ=="}], "type": "inlineReview", "revised_code": {"commit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 6805ddda02..76faf9204e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -18,7 +18,6 @@ import java.math.BigDecimal;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.EventObject;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"oid": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "url": "https://github.com/openhab/openhab-addons/commit/2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-05T21:38:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MzczNQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r436253735", "bodyText": "One compiler warning left.", "author": "fwolter", "createdAt": "2020-06-06T09:23:44Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial over IP connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n+\n+    private @Nullable String address;\n+    private @Nullable Integer port;\n+\n+    private @Nullable Socket clientSocket;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param address the IP address of the serial over IP device\n+     * @param port the TCP port to be used\n+     */\n+    public MonopriceAudioIpConnector(@Nullable String address, @Nullable Integer port) {\n+        this.address = address;\n+        this.port = port;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening IP connection on IP {} port {}\", this.address, this.port);\n+        try {\n+            Socket clientSocket = new Socket(this.address, this.port);", "originalCommit": "2737cb5e717d8e7d696d6e8793cad6f41548b1aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwODc2OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r437108768", "bodyText": "fixed.", "author": "mlobstein", "createdAt": "2020-06-09T02:52:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI1MzczNQ=="}], "type": "inlineReview", "revised_code": {"commit": "62e417b47937cdba6807f3e58194132edc4b3a92", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\nindex 06fce28f0c..d89c54b65f 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioIpConnector.java\n\n@@ -37,7 +37,7 @@ public class MonopriceAudioIpConnector extends MonopriceAudioConnector {\n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioIpConnector.class);\n \n     private @Nullable String address;\n-    private @Nullable Integer port;\n+    private int port;\n \n     private @Nullable Socket clientSocket;\n \n"}}, {"oid": "62e417b47937cdba6807f3e58194132edc4b3a92", "url": "https://github.com/openhab/openhab-addons/commit/62e417b47937cdba6807f3e58194132edc4b3a92", "message": "fix compilier warning\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-09T02:50:52Z", "type": "commit"}, {"oid": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "url": "https://github.com/openhab/openhab-addons/commit/f763e8586c14bb653986e8468b816a61a3f3a1a6", "message": "fix sychronized placement around openConnection()\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-10T20:46:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTg0Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439855846", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n          \n          \n            \n                        .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));\n          \n          \n            \n                private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);", "author": "fwolter", "createdAt": "2020-06-14T18:28:10Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\nindex c9e59b1fce..76aa00f6a4 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\n\n@@ -16,8 +16,6 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.util.Collections;\n import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NjA5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439856095", "bodyText": "You could put the SerialPortManager as an argument here, too. Then, you can remove the @NonNullByDefault({}) from both fields.", "author": "fwolter", "createdAt": "2020-06-14T18:31:17Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .unmodifiableSet(Stream.of(THING_TYPE_AMP).collect(Collectors.toSet()));\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    @Activate\n+    public MonopriceAudioHandlerFactory(final @Reference MonopriceAudioStateDescriptionOptionProvider provider) {", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\nindex c9e59b1fce..76aa00f6a4 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\n\n@@ -16,8 +16,6 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.util.Collections;\n import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NjQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439856450", "bodyText": "Isn't 00 appended if valueis 0?", "author": "fwolter", "createdAt": "2020-06-14T18:35:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataIn = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command that takes no arguments (ie power on, power off, etc.)\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd) throws MonopriceAudioException {\n+        sendCommand(zone, cmd, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = MonopriceAudioCommand.BEGIN_CMD.getValue() + zone.getZoneId() + cmd.getValue();\n+        byte[] message;\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case - redo messageStr (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            switch (cmd) {\n+                case SOURCE:\n+                case VOLUME:\n+                case TREBLE:\n+                case BASS:\n+                case BALANCE:\n+                    if (value == 0) {\n+                        messageStr += \"00\";\n+                    } else {\n+                        messageStr += String.format(\"%02d\", value);\n+                    }", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex 842ea80ace..081a1aa31d 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -203,11 +203,7 @@ public abstract class MonopriceAudioConnector {\n                 case TREBLE:\n                 case BASS:\n                 case BALANCE:\n-                    if (value == 0) {\n-                        messageStr += \"00\";\n-                    } else {\n-                        messageStr += String.format(\"%02d\", value);\n-                    }\n+                    messageStr += String.format(\"%02d\", value);\n                     break;\n                 default:\n                     break;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NzYyNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857627", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n          \n          \n            \n                            ignore.forEach(zone -> {\n          \n          \n            \n                            Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {", "author": "fwolter", "createdAt": "2020-06-14T18:51:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex dde50ddc4c..ab20d7cf15 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -147,7 +147,8 @@ public class MonopriceAudioHandler extends BaseThingHandler implements Monoprice\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n         } else {\n             if (config.serialPort != null) {\n-                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n             } else {\n                 connector = new MonopriceAudioIpConnector(config.host, config.port);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1Nzk0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439857940", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n          \n          \n            \n                        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());", "author": "fwolter", "createdAt": "2020-06-14T18:55:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex dde50ddc4c..ab20d7cf15 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -147,7 +147,8 @@ public class MonopriceAudioHandler extends BaseThingHandler implements Monoprice\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n         } else {\n             if (config.serialPort != null) {\n-                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n             } else {\n                 connector = new MonopriceAudioIpConnector(config.host, config.port);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439858565", "bodyText": "Are you aware that multiple handleCommand()s can be invoked at the same time from different threads? This rate limit might not work, then.", "author": "fwolter", "createdAt": "2020-06-14T19:03:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,730 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final long SLEEP_BETWEEN_CMD = TimeUnit.MILLISECONDS.toMillis(100);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zone (1-18)\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONES.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                ArrayList<String> ignore = new ArrayList<String>(Arrays.asList(config.ignoreZones.split(\",\")));\n+                ignore.forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range((1), (numZones + 1)).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range((numZones + 1), (MAX_ZONES + 1)).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneId) -> {\n+                            if (!ignoreZones.contains(zoneId)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(ZONE + zoneId),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                    Thread.sleep(SLEEP_BETWEEN_CMD);", "originalCommit": "f763e8586c14bb653986e8468b816a61a3f3a1a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzOTQzNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r439939434", "bodyText": "Yes but hopefully the All* commands will be used sparingly by the user. The idea is to give some advanced functionality to the user so they can affect all zones with one command and avoid having to write rules that loop over all zones. For example, the 'All Off' command can be triggered by a rule that runs when arming the security system to away mode to turn off the music when leaving. And the 'All Volume' & 'All Source' provide party mode functionality that is native to more advanced WHA systems. So ideally two different users would never be adjusting the All Volume at the same time.", "author": "mlobstein", "createdAt": "2020-06-15T05:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM2NDg2MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r440364860", "bodyText": "Ok, but then you can remove the second Thread.sleep() in every case, because they have no effect.", "author": "fwolter", "createdAt": "2020-06-15T18:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwMjI5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441202296", "bodyText": "I removed all the sleeps and the device controller seems to be coping with this ok.", "author": "mlobstein", "createdAt": "2020-06-16T23:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODU2NQ=="}], "type": "inlineReview", "revised_code": {"commit": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex dde50ddc4c..ab20d7cf15 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -147,7 +147,8 @@ public class MonopriceAudioHandler extends BaseThingHandler implements Monoprice\n             updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n         } else {\n             if (config.serialPort != null) {\n-                connector = new MonopriceAudioSerialConnector(serialPortManager, config.serialPort);\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n             } else {\n                 connector = new MonopriceAudioIpConnector(config.host, config.port);\n             }\n"}}, {"oid": "e09ceb96d7b73cffdaf3a77707711cd741719f88", "url": "https://github.com/openhab/openhab-addons/commit/e09ceb96d7b73cffdaf3a77707711cd741719f88", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-15T05:40:02Z", "type": "commit"}, {"oid": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "url": "https://github.com/openhab/openhab-addons/commit/0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "message": "remove sleep and fix a few bugs\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-16T23:44:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDExNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441680116", "bodyText": "The code begs for streams :) If you like, try findAny().orElseThrow(...", "author": "fwolter", "createdAt": "2020-06-17T16:39:25Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -48,10 +49,23 @@\n \n     private String zoneId;\n \n-    // make a list of all valid zone ids\n-    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.getZoneId())\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n             .collect(Collectors.toList());\n \n+    // make a list of all valid zone ids\n+    public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(z -> z.getZoneId()).collect(Collectors.toList());\n+\n+    public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n+        for (MonopriceAudioZone z : MonopriceAudioZone.values()) {\n+            if (z.zoneId.equalsIgnoreCase(zoneId)) {\n+                return z;\n+            }\n+        }\n+        throw new MonopriceAudioException(\"Invalid zoneId specified: \" + zoneId);", "originalCommit": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NjIyMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441796220", "bodyText": "got it!", "author": "mlobstein", "createdAt": "2020-06-17T19:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDExNg=="}], "type": "inlineReview", "revised_code": {"commit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\nindex f43223345e..5ce0f45b64 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n\n@@ -58,12 +58,8 @@ public enum MonopriceAudioZone {\n             .map(z -> z.getZoneId()).collect(Collectors.toList());\n \n     public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n-        for (MonopriceAudioZone z : MonopriceAudioZone.values()) {\n-            if (z.zoneId.equalsIgnoreCase(zoneId)) {\n-                return z;\n-            }\n-        }\n-        throw new MonopriceAudioException(\"Invalid zoneId specified: \" + zoneId);\n+        return Arrays.stream(values()).filter(z -> z.zoneId.equalsIgnoreCase(zoneId)).findFirst()\n+                .orElseThrow(() -> new MonopriceAudioException(\"Invalid zoneId specified: \" + zoneId));\n     }\n \n     MonopriceAudioZone(String zoneId) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDg3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441680870", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        ignoreZones.add(ZONE + String.valueOf(zoneInt));\n          \n          \n            \n                                        ignoreZones.add(ZONE + zoneInt);", "author": "fwolter", "createdAt": "2020-06-17T16:40:31Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -164,7 +163,7 @@ public void initialize() {\n                     try {\n                         int zoneInt = Integer.parseInt(zone);\n                         if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n-                            ignoreZones.add(MonopriceAudioZone.valueOf(ZONE + zoneInt).getZoneId());\n+                            ignoreZones.add(ZONE + String.valueOf(zoneInt));", "originalCommit": "0ad1dcdd09580fbb310e9066a649143a42fe4f0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc5NTk1OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441795958", "bodyText": "fixed", "author": "mlobstein", "createdAt": "2020-06-17T19:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY4MDg3MA=="}], "type": "inlineReview", "revised_code": {"commit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex ea4f25b3fb..7645082893 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -163,7 +163,7 @@ public class MonopriceAudioHandler extends BaseThingHandler implements Monoprice\n                     try {\n                         int zoneInt = Integer.parseInt(zone);\n                         if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n-                            ignoreZones.add(ZONE + String.valueOf(zoneInt));\n+                            ignoreZones.add(ZONE + zoneInt);\n                         } else {\n                             logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n                                     MAX_ZONES);\n"}}, {"oid": "e0e166958454b6492345b317ee9ec96ef70a7a40", "url": "https://github.com/openhab/openhab-addons/commit/e0e166958454b6492345b317ee9ec96ef70a7a40", "message": "review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-17T19:51:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg2OTU2NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441869565", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n            \n          \n          \n            \n                private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n          \n          \n            \n                private final SerialPortManager serialPortManager;\n          \n          \n            \n            \n          \n          \n            \n                private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;", "author": "cpmeister", "createdAt": "2020-06-17T22:31:33Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.handler.MonopriceAudioHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MonopriceAudioHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.monopriceaudio\", service = ThingHandlerFactory.class)\n+public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\nindex 76aa00f6a4..6345991225 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioHandlerFactory.java\n\n@@ -42,9 +42,9 @@ public class MonopriceAudioHandlerFactory extends BaseThingHandlerFactory {\n \n     private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_AMP);\n \n-    private @NonNullByDefault({}) SerialPortManager serialPortManager;\n+    private final SerialPortManager serialPortManager;\n \n-    private @NonNullByDefault({}) MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n \n     @Activate\n     public MonopriceAudioHandlerFactory(final @Reference MonopriceAudioStateDescriptionOptionProvider provider,\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3MTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441871310", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.info(\"Opening serial connection on port {}\", serialPortName);\n          \n          \n            \n                    logger.debug(\"Opening serial connection on port {}\", serialPortName);", "author": "cpmeister", "createdAt": "2020-06-17T22:36:37Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param serialPortManager the serial port manager\n+     * @param serialPortName the serial port name to be used\n+     */\n+    public MonopriceAudioSerialConnector(SerialPortManager serialPortManager, String serialPortName) {\n+        this.serialPortManager = serialPortManager;\n+        this.serialPortName = serialPortName;\n+    }\n+\n+    @Override\n+    public synchronized void open() throws MonopriceAudioException {\n+        logger.info(\"Opening serial connection on port {}\", serialPortName);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\nindex 526aa64a8b..1e99298282 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n\n@@ -57,7 +57,7 @@ public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n \n     @Override\n     public synchronized void open() throws MonopriceAudioException {\n-        logger.info(\"Opening serial connection on port {}\", serialPortName);\n+        logger.debug(\"Opening serial connection on port {}\", serialPortName);\n         try {\n             SerialPortIdentifier portIdentifier = serialPortManager.getIdentifier(serialPortName);\n             if (portIdentifier == null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441874713", "bodyText": "What if the user has multiple amplifiers?\nThis map shouldn't be static. Please make the name lowercase accordingly as well.", "author": "cpmeister", "createdAt": "2020-06-17T22:47:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNTg4MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441915881", "bodyText": "Up to three can be connected together as one unit and accordingly up to 18 zones can be specified in the configuration. If they have more than 18 zones, they can always add another thing instance.", "author": "mlobstein", "createdAt": "2020-06-18T01:19:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU5NTUzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442595538", "bodyText": "If they add another thing instance then its handler would still be using this same static map. It should be a single map per handler right?", "author": "cpmeister", "createdAt": "2020-06-19T02:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNDQxNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442604417", "bodyText": "If they add another thing instance then its handler would still be using this same static map. It should be a single map per handler right?\n\nYeah, each instance of the handler should have its own map so I will remove static, but it can still be final.", "author": "mlobstein", "createdAt": "2020-06-19T02:55:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NDcxMw=="}], "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NTc5NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441875795", "bodyText": "Just return early here so you can get rid of the \"else\" statement and indentations.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n          \n          \n            \n                    } else {\n          \n          \n            \n                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n          \n          \n            \n                        return;\n          \n          \n            \n                    }", "author": "cpmeister", "createdAt": "2020-06-17T22:51:14Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3NjAyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441876026", "bodyText": "Please remove this.", "author": "cpmeister", "createdAt": "2020-06-17T22:51:59Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg3ODQzOA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441878438", "bodyText": "The main benefit of streams and lambdas is how concise they can make code. But sometimes they aren't as concise as a regular loop...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n          \n          \n            \n                            for (String zone : config.ignoreZones.split(\",\")) {", "author": "cpmeister", "createdAt": "2020-06-17T22:59:35Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4MDc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441880770", "bodyText": "Might as well save later code from having to call it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n          \n          \n            \n                        Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);", "author": "cpmeister", "createdAt": "2020-06-17T23:07:18Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NDU5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441884596", "bodyText": "I feel like all these on/off command handlers could be simplified to a single function.\nprivate void handleOnOff(Command command, MonopriceAudioZone zone, MonopriceAudioCommand onCommand, MonopriceAudioCommand offCommand, BiConsumer<MonopriceAudioZoneDTO, String> adjuster){\n    if( command == OnOffType.ON){\n        connector.sendCommand(zone, onCommand);\n        adjuster.accept(ZONE_DATA_MAP.get(zone.getZoneId()), ON);\n    } else if (command == OnOffType.OFF){\n        connector.sendCommand(zone, offCommand);\n        adjuster.accept(ZONE_DATA_MAP.get(zone.getZoneId()), OFF);\n    }\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (command instanceof OnOffType && command == OnOffType.ON) {\n          \n          \n            \n                                        connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n          \n          \n            \n                                        ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n          \n          \n            \n                                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n          \n          \n            \n                                        connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n          \n          \n            \n                                        ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n          \n          \n            \n                                    }\n          \n          \n            \n                                    handleOnOff(command, zone, MonopriceAudioCommand.MUTE_ON, MonopriceAudioCommand.MUTE_OFF, MonopriceAudioZone::setMute);", "author": "cpmeister", "createdAt": "2020-06-17T23:19:48Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MzIwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445263206", "bodyText": "I condensed them all with a ternary.", "author": "mlobstein", "createdAt": "2020-06-25T01:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NDU5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441887496", "bodyText": "might as well break early instead of having to perform another null check.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        cmd = null;\n          \n          \n            \n                                    }\n          \n          \n            \n            \n          \n          \n            \n                                    if (cmd != null) {\n          \n          \n            \n                                        break;\n          \n          \n            \n                                    }", "author": "cpmeister", "createdAt": "2020-06-17T23:29:10Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzU3NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441887574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (command instanceof OnOffType && command == OnOffType.ON) {\n          \n          \n            \n                                        cmd = MonopriceAudioCommand.MUTE_ON;\n          \n          \n            \n                                    } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n          \n          \n            \n                                    if (command == OnOffType.ON) {\n          \n          \n            \n                                        cmd = MonopriceAudioCommand.MUTE_ON;\n          \n          \n            \n                                    } else if (command == OnOffType.OFF) {", "author": "cpmeister", "createdAt": "2020-06-17T23:29:28Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTk1ODM0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441958348", "bodyText": "I made some changes. Please take another look.", "author": "mlobstein", "createdAt": "2020-06-18T04:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg4NzU3NA=="}], "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MDAxMw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441890013", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onNewMessageEvent(EventObject event);\n          \n          \n            \n                public void onNewMessageEvent(MonopriceAudioMessageEvent event);", "author": "cpmeister", "createdAt": "2020-06-17T23:37:34Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.EventListener;\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * MonopriceAudio Event Listener interface. Handles incoming MonopriceAudio message events\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public interface MonopriceAudioMessageEventListener extends EventListener {\n+\n+    /**\n+     * Event handler method for incoming MonopriceAudio message events\n+     *\n+     * @param event the event object\n+     */\n+    public void onNewMessageEvent(EventObject event);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java\nindex bdf314643a..17b7739253 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEventListener.java\n\n@@ -13,7 +13,6 @@\n package org.openhab.binding.monopriceaudio.internal.communication;\n \n import java.util.EventListener;\n-import java.util.EventObject;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MTExMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441891112", "bodyText": "This is more of an external issue rather than one that a user can address, so just make this log debug instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Invalid zone update message: {}\", newZoneData);\n          \n          \n            \n                            logger.debug(\"Invalid zone update message: {}\", newZoneData);", "author": "cpmeister", "createdAt": "2020-06-17T23:41:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n+                        } catch (MonopriceAudioException e) {\n+                            logger.warn(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BASS:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBass()) - TONE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_BALANCE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getBalance()) - BALANCE_OFFSET));\n+                break;\n+            case CHANNEL_TYPE_DND:\n+                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_PAGE:\n+                state = zoneData.isPageActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                break;\n+            case CHANNEL_TYPE_KEYPAD:\n+                state = zoneData.isKeypadActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n+                break;\n+            default:\n+                break;\n+        }\n+        updateState(channel, state);\n+    }\n+\n+    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneDTO zoneData, String newZoneData) {\n+        // only process the update if something actually changed in this zone since the last time through\n+        if (!newZoneData.equals(zoneData.toString())) {\n+            // example status string: 1200010000130809100601, matcher pattern from above:\n+            // \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\"\n+            Matcher matcher = PATTERN.matcher(newZoneData);\n+            if (matcher.find()) {\n+                zoneData.setZone(matcher.group(1));\n+\n+                if (!matcher.group(2).equals(zoneData.getPage())) {\n+                    zoneData.setPage(matcher.group(2));\n+                    updateChannelState(zone, CHANNEL_TYPE_PAGE, zoneData);\n+                }\n+\n+                if (!matcher.group(3).equals(zoneData.getPower())) {\n+                    zoneData.setPower(matcher.group(3));\n+                    updateChannelState(zone, CHANNEL_TYPE_POWER, zoneData);\n+                }\n+\n+                if (!matcher.group(4).equals(zoneData.getMute())) {\n+                    zoneData.setMute(matcher.group(4));\n+                    updateChannelState(zone, CHANNEL_TYPE_MUTE, zoneData);\n+                }\n+\n+                if (!matcher.group(5).equals(zoneData.getDnd())) {\n+                    zoneData.setDnd(matcher.group(5));\n+                    updateChannelState(zone, CHANNEL_TYPE_DND, zoneData);\n+                }\n+\n+                if (!matcher.group(6).equals(zoneData.getVolume())) {\n+                    zoneData.setVolume(matcher.group(6));\n+                    updateChannelState(zone, CHANNEL_TYPE_VOLUME, zoneData);\n+                }\n+\n+                if (!matcher.group(7).equals(zoneData.getTreble())) {\n+                    zoneData.setTreble(matcher.group(7));\n+                    updateChannelState(zone, CHANNEL_TYPE_TREBLE, zoneData);\n+                }\n+\n+                if (!matcher.group(8).equals(zoneData.getBass())) {\n+                    zoneData.setBass(matcher.group(8));\n+                    updateChannelState(zone, CHANNEL_TYPE_BASS, zoneData);\n+                }\n+\n+                if (!matcher.group(9).equals(zoneData.getBalance())) {\n+                    zoneData.setBalance(matcher.group(9));\n+                    updateChannelState(zone, CHANNEL_TYPE_BALANCE, zoneData);\n+                }\n+\n+                if (!matcher.group(10).equals(zoneData.getSource())) {\n+                    zoneData.setSource(matcher.group(10));\n+                    updateChannelState(zone, CHANNEL_TYPE_SOURCE, zoneData);\n+                }\n+\n+                if (!matcher.group(11).equals(zoneData.getKeypad())) {\n+                    zoneData.setKeypad(matcher.group(11));\n+                    updateChannelState(zone, CHANNEL_TYPE_KEYPAD, zoneData);\n+                }\n+            } else {\n+                logger.warn(\"Invalid zone update message: {}\", newZoneData);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MTk2Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441891967", "bodyText": "The TimeUnit.SECONDS.toSeconds doesn't do anything here so you can omit it. If you are trying to make your assignment more declarative then I suggest you add a _SEC suffix to your constant name instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n          \n          \n            \n                private static final long RECON_POLLING_INTERVAL_SEC = 60;", "author": "cpmeister", "createdAt": "2020-06-17T23:44:15Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjAwMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892000", "bodyText": "same here", "author": "cpmeister", "createdAt": "2020-06-17T23:44:22Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjIwMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892201", "bodyText": "Since order doesn't matter and you are only performing lookups on it, use a Set instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private ArrayList<String> ignoreZones = new ArrayList<>();\n          \n          \n            \n                private final Set<String> ignoreZones = new HasSet<>();", "author": "cpmeister", "createdAt": "2020-06-17T23:45:08Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjI0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892245", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "author": "cpmeister", "createdAt": "2020-06-17T23:45:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5Mjk1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441892957", "bodyText": "You should also clear your ignoreZones here.", "author": "cpmeister", "createdAt": "2020-06-17T23:47:50Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MzA0MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441893040", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n          \n          \n            \n                        pollingInterval = config.pollingInterval;", "author": "cpmeister", "createdAt": "2020-06-17T23:48:07Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5Mzc3Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441893773", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n          \n          \n            \n            \n          \n          \n            \n                                // poll each zone up to the number of zones specified in the configuration\n          \n          \n            \n                                zoneStream.limit(numZones).forEach((zoneName) -> {\n          \n          \n            \n                                // poll each zone up to the number of zones specified in the configuration\n          \n          \n            \n                                MonopriceAudioZone.VALID_ZONES.stream().limit(numZones).forEach((zoneName) -> {", "author": "cpmeister", "createdAt": "2020-06-17T23:50:57Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441894896", "bodyText": "Is there any change that zoneData.getTreble() wouldn't return a parsable number? If so then you should catch the exception, if not then I suggest changing the datatype from a String to an int.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));\n          \n          \n            \n                            state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));", "author": "cpmeister", "createdAt": "2020-06-17T23:54:54Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,723 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EventObject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL = TimeUnit.SECONDS.toSeconds(60);\n+    private static final long INITIAL_POLLING_DELAY = TimeUnit.SECONDS.toSeconds(5);\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON = \"01\";\n+    private static final String OFF = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private SerialPortManager serialPortManager;\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private ArrayList<String> ignoreZones = new ArrayList<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private static final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+        } else {\n+            if (config.serialPort != null) {\n+                String serialPort = config.serialPort;\n+                connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+            } else {\n+                connector = new MonopriceAudioIpConnector(config.host, config.port);\n+            }\n+\n+            pollingInterval = TimeUnit.SECONDS.toSeconds(config.pollingInterval);\n+            numZones = config.numZones;\n+            initialAllVolume = config.initialAllVolume;\n+\n+            // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+            // zone ids to get the controller's internal zone ids and save those to a list\n+            if (config.ignoreZones != null) {\n+                Arrays.stream(config.ignoreZones.split(\",\")).forEach(zone -> {\n+                    try {\n+                        int zoneInt = Integer.parseInt(zone);\n+                        if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                            ignoreZones.add(ZONE + zoneInt);\n+                        } else {\n+                            logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                    MAX_ZONES);\n+                        }\n+                    } catch (NumberFormatException nfe) {\n+                        logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                    }\n+                });\n+            }\n+\n+            // Build a state option list for the source labels\n+            List<StateOption> sourcesLabels = new ArrayList<>();\n+            sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+            sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+            sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+            sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+            sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+            sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+            // Put the source labels on all active zones\n+            List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+            stateDescriptionProvider.setStateOptions(\n+                    new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+            activeZones.forEach(zoneNum -> {\n+                stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                        ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+            });\n+\n+            // remove the channels for the zones we are not using\n+            if (numZones < MAX_ZONES) {\n+                List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+                List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                        .collect(Collectors.toList());\n+\n+                zonesToRemove.forEach(zone -> {\n+                    channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+                });\n+                updateThing(editThing().withChannels(channels).build());\n+            }\n+\n+            // initialize the all volume state\n+            allVolume = initialAllVolume;\n+            long allVolumePct = Math\n+                    .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+            updateStatus(ThingStatus.UNKNOWN);\n+\n+            scheduleReconnectJob();\n+            schedulePollingJob();\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_ON);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(ON);\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND_OFF);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(OFF);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            if (!ignoreZones.contains(zoneName)) {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER_ON);\n+                                    // reset the volume of each zone to allVolume\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.VOLUME, allVolume);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                }\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        // set allVolume back to initial volume\n+                        allVolume = initialAllVolume;\n+                        long allVolumePct = Math\n+                                .round((double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                        zoneStream.limit(numZones).forEach((zoneName) -> {\n+                            try {\n+                                connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                        MonopriceAudioCommand.POWER_OFF);\n+                            } catch (MonopriceAudioException e) {\n+                                logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                            }\n+\n+                        });\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        MonopriceAudioCommand cmd;\n+                        if (command instanceof OnOffType && command == OnOffType.ON) {\n+                            cmd = MonopriceAudioCommand.MUTE_ON;\n+                        } else if (command instanceof OnOffType && command == OnOffType.OFF) {\n+                            cmd = MonopriceAudioCommand.MUTE_OFF;\n+                        } else {\n+                            cmd = null;\n+                        }\n+\n+                        if (cmd != null) {\n+                            zoneStream.limit(numZones).forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName), cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n+                }\n+            } catch (MonopriceAudioException e) {\n+                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n+                closeConnection();\n+                scheduleReconnectJob();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @return true if the connection is opened successfully or false if not\n+     */\n+    private synchronized boolean openConnection() {\n+        connector.addEventListener(this);\n+        try {\n+            connector.open();\n+        } catch (MonopriceAudioException e) {\n+            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n+        }\n+        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n+        return connector.isConnected();\n+    }\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    private synchronized void closeConnection() {\n+        if (connector.isConnected()) {\n+            connector.close();\n+            connector.removeEventListener(this);\n+            logger.debug(\"closeConnection(): disconnected\");\n+        }\n+    }\n+\n+    @Override\n+    public void onNewMessageEvent(EventObject event) {\n+        MonopriceAudioMessageEvent evt = (MonopriceAudioMessageEvent) event;\n+\n+        String key = evt.getKey();\n+        String updateData = evt.getValue().trim();\n+        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        try {\n+            switch (key) {\n+                case MonopriceAudioConnector.KEY_ERROR:\n+                    logger.debug(\"Reading feedback message failed\");\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n+                    closeConnection();\n+                    break;\n+\n+                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n+                    String zoneId = updateData.substring(0, 2);\n+\n+                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n+                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n+                        processZoneUpdate(targetZone, ZONE_DATA_MAP.get(zoneId), updateData);\n+                    } else {\n+                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n+                    }\n+                    break;\n+                default:\n+                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n+                    break;\n+            }\n+        } catch (NumberFormatException e) {\n+            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n+        } catch (MonopriceAudioException e) {\n+            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Schedule the reconnection job\n+     */\n+    private void scheduleReconnectJob() {\n+        logger.debug(\"Schedule reconnect job\");\n+        cancelReconnectJob();\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (!connector.isConnected()) {\n+                    logger.debug(\"Trying to reconnect...\");\n+                    closeConnection();\n+                    String error = null;\n+\n+                    if (openConnection()) {\n+                        try {\n+                            long prevUpdateTime = lastPollingUpdate;\n+                            connector.queryZone(MonopriceAudioZone.ZONE1);\n+\n+                            // prevUpdateTime should have changed if a zone update was received\n+                            if (lastPollingUpdate == prevUpdateTime) {\n+                                error = \"Controller not responding to status requests\";\n+                            }\n+\n+                        } catch (MonopriceAudioException e) {\n+                            error = \"First command after connection failed\";\n+                            logger.warn(\"{}: {}\", error, e.getMessage());\n+                            closeConnection();\n+                        }\n+                    } else {\n+                        error = \"Reconnection failed\";\n+                    }\n+                    if (error != null) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                    } else {\n+                        updateStatus(ThingStatus.ONLINE);\n+                        lastPollingUpdate = System.currentTimeMillis();\n+                    }\n+                }\n+            }\n+        }, 1, RECON_POLLING_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the reconnection job\n+     */\n+    private void cancelReconnectJob() {\n+        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n+        if (reconnectJob != null) {\n+            reconnectJob.cancel(true);\n+            this.reconnectJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Schedule the polling job\n+     */\n+    private void schedulePollingJob() {\n+        logger.debug(\"Schedule polling job\");\n+        cancelPollingJob();\n+\n+        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+            synchronized (sequenceLock) {\n+                if (connector.isConnected()) {\n+                    logger.debug(\"Polling the controller for updated status...\");\n+\n+                    Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream();\n+\n+                    // poll each zone up to the number of zones specified in the configuration\n+                    zoneStream.limit(numZones).forEach((zoneName) -> {\n+                        try {\n+                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n+                        } catch (MonopriceAudioException e) {\n+                            logger.warn(\"Polling error: {}\", e.getMessage());\n+                        }\n+                    });\n+\n+                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n+                    // is either switched off or not responding even though the connection is still good\n+                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n+                        logger.warn(\"Controller not responding to status requests\");\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Controller not responding to status requests\");\n+                        closeConnection();\n+                        scheduleReconnectJob();\n+                    }\n+                }\n+            }\n+        }, INITIAL_POLLING_DELAY, pollingInterval, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Cancel the polling job\n+     */\n+    private void cancelPollingJob() {\n+        ScheduledFuture<?> pollingJob = this.pollingJob;\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            this.pollingJob = null;\n+        }\n+    }\n+\n+    /**\n+     * Update the state of a channel\n+     *\n+     * @param channel the channel\n+     */\n+    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n+        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n+\n+        if (!isLinked(channel)) {\n+            return;\n+        }\n+\n+        State state = UnDefType.UNDEF;\n+        switch (channelType) {\n+            case CHANNEL_TYPE_POWER:\n+                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_SOURCE:\n+                state = new DecimalType(zoneData.getSource());\n+                break;\n+            case CHANNEL_TYPE_VOLUME:\n+                long volumePct = Math.round((double) (Integer.parseInt(zoneData.getVolume()) - MIN_VOLUME)\n+                        / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                state = new PercentType(BigDecimal.valueOf(volumePct));\n+                break;\n+            case CHANNEL_TYPE_MUTE:\n+                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n+                break;\n+            case CHANNEL_TYPE_TREBLE:\n+                state = new DecimalType(BigDecimal.valueOf(Integer.parseInt(zoneData.getTreble()) - TONE_OFFSET));", "originalCommit": "e0e166958454b6492345b317ee9ec96ef70a7a40", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkyNTc3Mg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r441925772", "bodyText": "The regex ensures that only digits will make it into the dto. It just a question of whether to parse the string when going into the dto or coming out of the dto. I could overload the getters in the dto to parse/return an integer but that is just moving the ugliness somewhere else IMO.", "author": "mlobstein", "createdAt": "2020-06-18T01:58:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MjY3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442442675", "bodyText": "Well it would be a better practice to make the DTO reflect the actual datatypes involved.", "author": "cpmeister", "createdAt": "2020-06-18T19:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NDg5Ng=="}], "type": "inlineReview", "revised_code": {"commit": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex 7645082893..6fa6eddc70 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -16,8 +16,7 @@ import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingC\n \n import java.math.BigDecimal;\n import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EventObject;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.ScheduledFuture;\n"}}, {"oid": "9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "url": "https://github.com/openhab/openhab-addons/commit/9c3dfc701e2115c540134b6314c0e0d9630fe6f3", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-18T04:12:41Z", "type": "commit"}, {"oid": "0d3e3569c0dd490c3db64e018e702235b09969c7", "url": "https://github.com/openhab/openhab-addons/commit/0d3e3569c0dd490c3db64e018e702235b09969c7", "message": "make ZONE_DATA_MAP not static\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-19T02:59:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MjMzMA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442982330", "bodyText": "Why are BEGIN_CMD AND END_CMD in this list of enums? They are never used as discrete commands and are just used as part of command construction. I don't think they belong here.", "author": "cpmeister", "createdAt": "2020-06-19T18:14:04Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+    QUERY(\"?\"),\n+    BEGIN_CMD(\"<\"),\n+    END_CMD(\"\\r\"),", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\nindex 1919c773cf..08f3ea43c8 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\n\n@@ -22,9 +22,6 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n @NonNullByDefault\n public enum MonopriceAudioCommand {\n     QUERY(\"?\"),\n-    BEGIN_CMD(\"<\"),\n-    END_CMD(\"\\r\"),\n-\n     POWER(\"PR\"),\n     SOURCE(\"CH\"),\n     VOLUME(\"VO\"),\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4MzEyNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442983126", "bodyText": "Make sure that any created threads are daemon.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                }\n          \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID);\n          \n          \n            \n                    this.connector = connector;\n          \n          \n            \n                    setDaemon(true);\n          \n          \n            \n                }", "author": "cpmeister", "createdAt": "2020-06-19T18:15:56Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID);\n+        this.connector = connector;\n+    }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\nindex 2262d2f590..da2d134ce8 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n\n@@ -39,10 +39,12 @@ public class MonopriceAudioReaderThread extends Thread {\n      * Constructor\n      *\n      * @param connector the object that should handle the received message\n+     * @param uid unique identifier from the connector\n      */\n-    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n-        super(MonopriceAudioBindingConstants.BINDING_ID);\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector, String uid) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n         this.connector = connector;\n+        setDaemon(true);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NDY5Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442984693", "bodyText": "Since more than one of these threads can exist, you want to make sure they don't have the same name. Add additional information to the name such as either the thingUID or the address this thread is reading from.", "author": "cpmeister", "createdAt": "2020-06-19T18:19:55Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID);", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\nindex 2262d2f590..da2d134ce8 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n\n@@ -39,10 +39,12 @@ public class MonopriceAudioReaderThread extends Thread {\n      * Constructor\n      *\n      * @param connector the object that should handle the received message\n+     * @param uid unique identifier from the connector\n      */\n-    public MonopriceAudioReaderThread(MonopriceAudioConnector connector) {\n-        super(MonopriceAudioBindingConstants.BINDING_ID);\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector, String uid) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n         this.connector = connector;\n+        setDaemon(true);\n     }\n \n     @Override\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjE3NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442986175", "bodyText": "If the thread is in the middle of blocking for IO it may not respond to interrupt requests. To make sure that it is kicked awake you should make sure to close the input and output streams before you try joining the thread.", "author": "cpmeister", "createdAt": "2020-06-19T18:23:21Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5MjE2MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r443092161", "bodyText": "I will move it.", "author": "mlobstein", "createdAt": "2020-06-20T02:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NjE3NQ=="}], "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex da9d54cc9f..44df6d8832 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -44,6 +44,8 @@ public abstract class MonopriceAudioConnector {\n     public static final String MSG_VALUE_ON = \"on\";\n \n     private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzA4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987086", "bodyText": "you should still log this exception", "author": "cpmeister", "createdAt": "2020-06-19T18:25:44Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex da9d54cc9f..44df6d8832 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -44,6 +44,8 @@ public abstract class MonopriceAudioConnector {\n     public static final String MSG_VALUE_ON = \"on\";\n \n     private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzE0NQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987145", "bodyText": "this one too", "author": "cpmeister", "createdAt": "2020-06-19T18:25:53Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();\n+            } catch (InterruptedException e) {\n+            }\n+            this.readerThread = null;\n+        }\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+            }", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex da9d54cc9f..44df6d8832 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -44,6 +44,8 @@ public abstract class MonopriceAudioConnector {\n     public static final String MSG_VALUE_ON = \"on\";\n \n     private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4NzQ5Ng==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442987496", "bodyText": "It is dangerous to wait indefinitely for the join, so add a reasonable timeout and log a warning if that timeout is exceeded.", "author": "cpmeister", "createdAt": "2020-06-19T18:26:48Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join();", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex da9d54cc9f..44df6d8832 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -44,6 +44,8 @@ public abstract class MonopriceAudioConnector {\n     public static final String MSG_VALUE_ON = \"on\";\n \n     private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODY3OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442988678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n          \n          \n            \n                private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n          \n      \n    \n    \n  \n\nAlso move this field above the non-final fields.", "author": "cpmeister", "createdAt": "2020-06-19T18:29:49Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MzQ5OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445263498", "bodyText": "done", "author": "mlobstein", "createdAt": "2020-06-25T01:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODY3OA=="}], "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex aad6dcb563..97fa395d7e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -19,6 +19,7 @@ import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.regex.Matcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODkyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442988921", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashSet<String> ignoreZones = new HashSet<>();\n          \n          \n            \n                private Set<String> ignoreZones = new HashSet<>();", "author": "cpmeister", "createdAt": "2020-06-19T18:30:25Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex aad6dcb563..97fa395d7e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -19,6 +19,7 @@ import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.regex.Matcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442989671", "bodyText": "You should try to handle the RefreshType command for all of these channels.", "author": "cpmeister", "createdAt": "2020-06-19T18:32:19Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new MonopriceAudioIpConnector(config.host, config.port);\n+        }\n+\n+        pollingInterval = config.pollingInterval;\n+        numZones = config.numZones;\n+        initialAllVolume = config.initialAllVolume;\n+\n+        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+        // zone ids to get the controller's internal zone ids and save those to a list\n+        if (config.ignoreZones != null) {\n+            for (String zone : config.ignoreZones.split(\",\")) {\n+                try {\n+                    int zoneInt = Integer.parseInt(zone);\n+                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                        ignoreZones.add(ZONE + zoneInt);\n+                    } else {\n+                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                MAX_ZONES);\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                }\n+            }\n+        }\n+\n+        // Build a state option list for the source labels\n+        List<StateOption> sourcesLabels = new ArrayList<>();\n+        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+        // Put the source labels on all active zones\n+        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+        stateDescriptionProvider.setStateOptions(\n+                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+        activeZones.forEach(zoneNum -> {\n+            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+        });\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        // initialize the all volume state\n+        allVolume = initialAllVolume;\n+        long allVolumePct = Math\n+                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        ignoreZones.clear();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MTY4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442991683", "bodyText": "If you can't query the channel data, then you should at least used cached values.", "author": "cpmeister", "createdAt": "2020-06-19T18:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA5NDEwMg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r443094102", "bodyText": "Done and pushed.", "author": "mlobstein", "createdAt": "2020-06-20T02:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4OTY3MQ=="}], "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex aad6dcb563..97fa395d7e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -19,6 +19,7 @@ import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.regex.Matcher;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MDEwOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r442990109", "bodyText": "Success is expected, so I think you can change the logging level to trace.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.debug(\"Command {} from channel {} succeeded\", command, channel);\n          \n          \n            \n                                logger.trace(\"Command {} from channel {} succeeded\", command, channel);", "author": "cpmeister", "createdAt": "2020-06-19T18:33:27Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,706 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private HashSet<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> ZONE_DATA_MAP = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((config.serialPort == null || config.serialPort.isEmpty())\n+                && (config.host == null || config.host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (config.host == null || config.host.isEmpty()) {\n+            if (config.serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n+                configError = \"use host and port configuration settings for a serial over IP connection\";\n+            }\n+        } else {\n+            if (config.port == null) {\n+                configError = \"undefined port configuration setting\";\n+            } else if (config.port <= 0) {\n+                configError = \"invalid port configuration setting\";\n+            }\n+        }\n+\n+        if (configError != null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n+            return;\n+        }\n+\n+        if (config.serialPort != null) {\n+            String serialPort = config.serialPort;\n+            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n+        } else {\n+            connector = new MonopriceAudioIpConnector(config.host, config.port);\n+        }\n+\n+        pollingInterval = config.pollingInterval;\n+        numZones = config.numZones;\n+        initialAllVolume = config.initialAllVolume;\n+\n+        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n+        // zone ids to get the controller's internal zone ids and save those to a list\n+        if (config.ignoreZones != null) {\n+            for (String zone : config.ignoreZones.split(\",\")) {\n+                try {\n+                    int zoneInt = Integer.parseInt(zone);\n+                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n+                        ignoreZones.add(ZONE + zoneInt);\n+                    } else {\n+                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n+                                MAX_ZONES);\n+                    }\n+                } catch (NumberFormatException nfe) {\n+                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n+                }\n+            }\n+        }\n+\n+        // Build a state option list for the source labels\n+        List<StateOption> sourcesLabels = new ArrayList<>();\n+        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n+        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n+        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n+        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n+        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n+        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n+\n+        // Put the source labels on all active zones\n+        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n+\n+        stateDescriptionProvider.setStateOptions(\n+                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n+        activeZones.forEach(zoneNum -> {\n+            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n+                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n+        });\n+\n+        // remove the channels for the zones we are not using\n+        if (numZones < MAX_ZONES) {\n+            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n+\n+            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n+                    .collect(Collectors.toList());\n+\n+            zonesToRemove.forEach(zone -> {\n+                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n+            });\n+            updateThing(editThing().withChannels(channels).build());\n+        }\n+\n+        // initialize the all volume state\n+        allVolume = initialAllVolume;\n+        long allVolumePct = Math\n+                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleReconnectJob();\n+        schedulePollingJob();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        cancelReconnectJob();\n+        cancelPollingJob();\n+        closeConnection();\n+        ignoreZones.clear();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String channel = channelUID.getId();\n+        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n+        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n+        String channelType = channelSplit[1];\n+\n+        if (getThing().getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n+            return;\n+        }\n+\n+        boolean success = true;\n+        synchronized (sequenceLock) {\n+            if (!connector.isConnected()) {\n+                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n+                return;\n+            }\n+\n+            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n+            try {\n+                switch (channelType) {\n+                    case CHANNEL_TYPE_POWER:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_SOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                logger.debug(\"Got source command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_VOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n+                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setVolume(String.format(\"%02d\", value));\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_MUTE:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setMute(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_TREBLE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setTreble(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BASS:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_TONE && value <= MAX_TONE) {\n+                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId()).setBass(String.format(\"%02d\", value + TONE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_BALANCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n+                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n+                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n+                                ZONE_DATA_MAP.get(zone.getZoneId())\n+                                        .setBalance(String.format(\"%02d\", value + BALANCE_OFFSET));\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_DND:\n+                        if (command instanceof OnOffType) {\n+                            connector.sendCommand(zone, MonopriceAudioCommand.DND, command == OnOffType.ON ? 1 : 0);\n+                            ZONE_DATA_MAP.get(zone.getZoneId()).setDnd(command == OnOffType.ON ? ON_STR : OFF_STR);\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLON:\n+                        if (command instanceof OnOffType) {\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.POWER, 1);\n+                                        // reset the volume of each zone to allVolume\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, allVolume);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n+                                    }\n+                                }\n+\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLOFF:\n+                        if (command instanceof OnOffType) {\n+                            // set allVolume back to initial volume\n+                            allVolume = initialAllVolume;\n+                            long allVolumePct = Math.round(\n+                                    (double) (allVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n+                            updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME,\n+                                    new PercentType(BigDecimal.valueOf(allVolumePct)));\n+\n+                            zoneStream.forEach((zoneName) -> {\n+                                try {\n+                                    connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                            MonopriceAudioCommand.POWER, 0);\n+                                } catch (MonopriceAudioException e) {\n+                                    logger.warn(\"Error Turning All Zones Off: {}\", e.getMessage());\n+                                }\n+\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLSOURCE:\n+                        if (command instanceof DecimalType) {\n+                            int value = ((DecimalType) command).intValue();\n+                            if (value >= ONE && value <= MAX_SRC) {\n+                                zoneStream.forEach((zoneName) -> {\n+                                    if (!ignoreZones.contains(zoneName)) {\n+                                        try {\n+                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                    MonopriceAudioCommand.SOURCE, value);\n+                                        } catch (MonopriceAudioException e) {\n+                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n+                                        }\n+                                    }\n+                                });\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLVOLUME:\n+                        if (command instanceof PercentType) {\n+                            int value = (int) Math\n+                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n+                                    + MIN_VOLUME;\n+                            allVolume = value;\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.VOLUME, value);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    case CHANNEL_TYPE_ALLMUTE:\n+                        if (command instanceof OnOffType) {\n+                            int cmd = command == OnOffType.ON ? 1 : 0;\n+                            zoneStream.forEach((zoneName) -> {\n+                                if (!ignoreZones.contains(zoneName)) {\n+                                    try {\n+                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n+                                                MonopriceAudioCommand.MUTE, cmd);\n+                                    } catch (MonopriceAudioException e) {\n+                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n+                                    }\n+                                }\n+                            });\n+                        }\n+                        break;\n+                    default:\n+                        success = false;\n+                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n+                        break;\n+                }\n+\n+                if (success) {\n+                    logger.debug(\"Command {} from channel {} succeeded\", command, channel);", "originalCommit": "0d3e3569c0dd490c3db64e018e702235b09969c7", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\nindex aad6dcb563..97fa395d7e 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n\n@@ -19,6 +19,7 @@ import java.util.ArrayList;\n import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ScheduledFuture;\n import java.util.concurrent.TimeUnit;\n import java.util.regex.Matcher;\n"}}, {"oid": "592e16adf7d9cb184385738bae937c6ad6ecdaf0", "url": "https://github.com/openhab/openhab-addons/commit/592e16adf7d9cb184385738bae937c6ad6ecdaf0", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-20T02:36:29Z", "type": "commit"}, {"oid": "41709ef3f47b576df3eca355a6a0cc138bf36fd5", "url": "https://github.com/openhab/openhab-addons/commit/41709ef3f47b576df3eca355a6a0cc138bf36fd5", "message": "Merge pull request #5 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-06-24T13:47:17Z", "type": "commit"}, {"oid": "3aa4b61b3250c1c64d6f3eac110c3e1ccbe8fb2d", "url": "https://github.com/openhab/openhab-addons/commit/3aa4b61b3250c1c64d6f3eac110c3e1ccbe8fb2d", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-06-24T14:12:08Z", "type": "commit"}, {"oid": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "url": "https://github.com/openhab/openhab-addons/commit/fd64d16a198b55e5c4792b8c88394ded00eeb042", "message": "Update pom version and format README\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-24T14:23:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODAyNA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188024", "bodyText": "You should include the cause exception in your MonopriceAudioException.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n          \n          \n            \n                        throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-06-24T21:41:43Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());", "originalCommit": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI2MzgxOQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445263819", "bodyText": "done for all", "author": "mlobstein", "createdAt": "2020-06-25T01:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODAyNA=="}], "type": "inlineReview", "revised_code": {"commit": "5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex 44df6d8832..d84bcdef62 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -156,7 +156,7 @@ public abstract class MonopriceAudioConnector {\n         try {\n             return dataIn.read(dataBuffer);\n         } catch (IOException e) {\n-            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage(), e);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODE2NA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188164", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());\n          \n          \n            \n                        throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage(), e);", "author": "cpmeister", "createdAt": "2020-06-24T21:42:00Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+\n+    /**\n+     * Get whether the connection is established or not\n+     *\n+     * @return true if the connection is established\n+     */\n+    public boolean isConnected() {\n+        return connected;\n+    }\n+\n+    /**\n+     * Set whether the connection is established or not\n+     *\n+     * @param connected true if the connection is established\n+     */\n+    protected void setConnected(boolean connected) {\n+        this.connected = connected;\n+    }\n+\n+    /**\n+     * Set the thread that handles the feedback messages\n+     *\n+     * @param readerThread the thread\n+     */\n+    protected void setReaderThread(Thread readerThread) {\n+        this.readerThread = readerThread;\n+    }\n+\n+    /**\n+     * Open the connection with the MonopriceAudio device\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public abstract void open() throws MonopriceAudioException;\n+\n+    /**\n+     * Close the connection with the MonopriceAudio device\n+     */\n+    public abstract void close();\n+\n+    /**\n+     * Stop the thread that handles the feedback messages and close the opened input and output streams\n+     */\n+    protected void cleanup() {\n+        Thread readerThread = this.readerThread;\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut != null) {\n+            try {\n+                dataOut.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataOut: {}\", e.getMessage());\n+            }\n+            this.dataOut = null;\n+        }\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn != null) {\n+            try {\n+                dataIn.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing dataIn: {}\", e.getMessage());\n+            }\n+            this.dataIn = null;\n+        }\n+        if (readerThread != null) {\n+            readerThread.interrupt();\n+            try {\n+                readerThread.join(3000);\n+            } catch (InterruptedException e) {\n+                logger.warn(\"Error joining readerThread: {}\", e.getMessage());\n+            }\n+            this.readerThread = null;\n+        }\n+    }\n+\n+    /**\n+     * Reads some number of bytes from the input stream and stores them into the buffer array b. The number of bytes\n+     * actually read is returned as an integer.\n+     *\n+     * @param dataBuffer the buffer into which the data is read.\n+     *\n+     * @return the total number of bytes read into the buffer, or -1 if there is no more data because the end of the\n+     *         stream has been reached.\n+     *\n+     * @throws MonopriceAudioException - If the input stream is null, if the first byte cannot be read for any reason\n+     *             other than the end of the file, if the input stream has been closed, or if some other I/O error\n+     *             occurs.\n+     */\n+    protected int readInput(byte[] dataBuffer) throws MonopriceAudioException {\n+        InputStream dataIn = this.dataIn;\n+        if (dataIn == null) {\n+            throw new MonopriceAudioException(\"readInput failed: input stream is null\");\n+        }\n+        try {\n+            return dataIn.read(dataBuffer);\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Get the status of a zone\n+     *\n+     * @param zone the zone to query for current status\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void queryZone(MonopriceAudioZone zone) throws MonopriceAudioException {\n+        sendCommand(zone, MonopriceAudioCommand.QUERY, null);\n+    }\n+\n+    /**\n+     * Request the MonopriceAudio controller to execute a command\n+     *\n+     * @param zone the zone for which the command is to be run\n+     * @param cmd the command to execute\n+     * @param value the integer value to consider for volume, bass, treble, etc. adjustment\n+     *\n+     * @throws MonopriceAudioException - In case of any problem\n+     */\n+    public void sendCommand(MonopriceAudioZone zone, MonopriceAudioCommand cmd, @Nullable Integer value)\n+            throws MonopriceAudioException {\n+        String messageStr = \"\";\n+\n+        if (cmd == MonopriceAudioCommand.QUERY) {\n+            // query special case (ie: ? + zoneId)\n+            messageStr = cmd.getValue() + zone.getZoneId();\n+        } else if (value != null) {\n+            // if the command passed a value, append it to the messageStr\n+            messageStr = BEGIN_CMD + zone.getZoneId() + cmd.getValue() + String.format(\"%02d\", value);\n+        } else {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: passed in value is null\");\n+        }\n+        messageStr += END_CMD;\n+        logger.debug(\"Send command {}\", messageStr);\n+\n+        OutputStream dataOut = this.dataOut;\n+        if (dataOut == null) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + messageStr + \"\\\" failed: output stream is null\");\n+        }\n+        try {\n+            dataOut.write(messageStr.getBytes(StandardCharsets.US_ASCII));\n+            dataOut.flush();\n+        } catch (IOException e) {\n+            throw new MonopriceAudioException(\"Send command \\\"\" + cmd.getValue() + \"\\\" failed: \" + e.getMessage());", "originalCommit": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex 44df6d8832..d84bcdef62 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -156,7 +156,7 @@ public abstract class MonopriceAudioConnector {\n         try {\n             return dataIn.read(dataBuffer);\n         } catch (IOException e) {\n-            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage());\n+            throw new MonopriceAudioException(\"readInput failed: \" + e.getMessage(), e);\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODQzNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r445188437", "bodyText": "You should make another constructor that takes a String and a Throwable as an argument. To allow the passing of cause exceptions.", "author": "cpmeister", "createdAt": "2020-06-24T21:42:31Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link MonopriceAudioException} class is used for any exception thrown by the binding\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioException extends Exception {", "originalCommit": "fd64d16a198b55e5c4792b8c88394ded00eeb042", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java\nindex ec29529135..bdcebadd22 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/MonopriceAudioException.java\n\n@@ -26,6 +26,10 @@ public class MonopriceAudioException extends Exception {\n     public MonopriceAudioException() {\n     }\n \n+    public MonopriceAudioException(String message, Throwable t) {\n+        super(message, t);\n+    }\n+\n     public MonopriceAudioException(String message) {\n         super(message);\n     }\n"}}, {"oid": "5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "url": "https://github.com/openhab/openhab-addons/commit/5a2e047186c155d8b5db1cc7d1bf34ad9538f5bc", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-25T02:26:43Z", "type": "commit"}, {"oid": "c34c6d62ac3b72976a0dd5bca563325e8208adb7", "url": "https://github.com/openhab/openhab-addons/commit/c34c6d62ac3b72976a0dd5bca563325e8208adb7", "message": "commit change that was missed\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-06-25T03:56:52Z", "type": "commit"}, {"oid": "f4fd3ae79696e47991c8543f02061493c80e2a32", "url": "https://github.com/openhab/openhab-addons/commit/f4fd3ae79696e47991c8543f02061493c80e2a32", "message": "fix variable name for pmd report\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-06T02:33:08Z", "type": "commit"}, {"oid": "d2c03db0cb30ac223ec1a99a5958701afbd36ddd", "url": "https://github.com/openhab/openhab-addons/commit/d2c03db0cb30ac223ec1a99a5958701afbd36ddd", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-08T22:22:45Z", "type": "commit"}, {"oid": "5cbdb3ad598334b0c5d111a3091f064a8add1601", "url": "https://github.com/openhab/openhab-addons/commit/5cbdb3ad598334b0c5d111a3091f064a8add1601", "message": "minor formatting changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-08T22:24:51Z", "type": "commit"}, {"oid": "cac938edc2d3677c63ba1d34cf36b0f5844e5353", "url": "https://github.com/openhab/openhab-addons/commit/cac938edc2d3677c63ba1d34cf36b0f5844e5353", "message": "fix order of updateStatus() call\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-09T01:13:36Z", "type": "commit"}, {"oid": "b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "url": "https://github.com/openhab/openhab-addons/commit/b3285d67faf4f4c6261dd86e7bc1b3ce855a07b0", "message": "Merge pull request #6 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-16T21:38:23Z", "type": "commit"}, {"oid": "9b579193ad576302dc462c6574b4890746be2025", "url": "https://github.com/openhab/openhab-addons/commit/9b579193ad576302dc462c6574b4890746be2025", "message": "Merge pull request #7 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-25T03:38:33Z", "type": "commit"}, {"oid": "78f69778930aba426a203feec98c17aee188a536", "url": "https://github.com/openhab/openhab-addons/commit/78f69778930aba426a203feec98c17aee188a536", "message": "Merge pull request #8 from openhab/2.5.x\n\nupdate fork", "committedDate": "2020-07-28T15:24:48Z", "type": "commit"}, {"oid": "d0cd7f937d1a5508ec45839ed56eae456a63791d", "url": "https://github.com/openhab/openhab-addons/commit/d0cd7f937d1a5508ec45839ed56eae456a63791d", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-07-28T15:26:15Z", "type": "commit"}, {"oid": "b244b79e0d2a08ac3072306017f3c5576824f6c7", "url": "https://github.com/openhab/openhab-addons/commit/b244b79e0d2a08ac3072306017f3c5576824f6c7", "message": "update version and fix remaining warnings\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-07-28T15:55:47Z", "type": "commit"}, {"oid": "7f0a56bf418fed52b7ad2773f493a849942f4857", "url": "https://github.com/openhab/openhab-addons/commit/7f0a56bf418fed52b7ad2773f493a849942f4857", "message": "documentation fixes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-14T18:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NTExNw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474675117", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String value;\n          \n          \n            \n                private final String value;", "author": "Hilbrand", "createdAt": "2020-08-21T12:48:47Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Represents the different kinds of commands\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioCommand {\n+    QUERY(\"?\"),\n+    POWER(\"PR\"),\n+    SOURCE(\"CH\"),\n+    VOLUME(\"VO\"),\n+    MUTE(\"MU\"),\n+    TREBLE(\"TR\"),\n+    BASS(\"BS\"),\n+    BALANCE(\"BL\"),\n+    DND(\"DT\");\n+\n+    private String value;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\nindex 08f3ea43c8..c0001abb58 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioCommand.java\n\n@@ -31,7 +31,7 @@ public enum MonopriceAudioCommand {\n     BALANCE(\"BL\"),\n     DND(\"DT\");\n \n-    private String value;\n+    private final String value;\n \n     MonopriceAudioCommand(String value) {\n         this.value = value;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NTQ2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474675463", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n          \n          \n            \n                private final List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();", "author": "Hilbrand", "createdAt": "2020-08-21T12:49:24Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Abstract class for communicating with the MonopriceAudio device\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public abstract class MonopriceAudioConnector {\n+    public static final String READ_ERROR = \"Command Error.\";\n+\n+    // Message types\n+    public static final String KEY_ZONE_UPDATE = \"zone_update\";\n+    // Special keys used by the binding\n+    public static final String KEY_ERROR = \"error\";\n+    public static final String MSG_VALUE_ON = \"on\";\n+\n+    private static final Pattern PATTERN = Pattern.compile(\"^.*#>(\\\\d{22})$\", Pattern.DOTALL);\n+    private static final String BEGIN_CMD = \"<\";\n+    private static final String END_CMD = \"\\r\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioConnector.class);\n+\n+    /** The output stream */\n+    protected @Nullable OutputStream dataOut;\n+\n+    /** The input stream */\n+    protected @Nullable InputStream dataIn;\n+\n+    /** true if the connection is established, false if not */\n+    private boolean connected;\n+\n+    private @Nullable Thread readerThread;\n+\n+    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\nindex c36acbac99..d09e6bb879 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioConnector.java\n\n@@ -60,7 +60,7 @@ public abstract class MonopriceAudioConnector {\n \n     private @Nullable Thread readerThread;\n \n-    private List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n+    private final List<MonopriceAudioMessageEventListener> listeners = new ArrayList<>();\n \n     /**\n      * Get whether the connection is established or not\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NjEyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676121", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n          \n          \n            \n                    super(\"OH-binding-\" + MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);", "author": "Hilbrand", "createdAt": "2020-08-21T12:50:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A class that reads messages from the MonopriceAudio device in a dedicated thread\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioReaderThread extends Thread {\n+    private static final int READ_BUFFER_SIZE = 16;\n+    private static final int SIZE = 64;\n+    private static final char TERM_CHAR = '\\r';\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioReaderThread.class);\n+\n+    private MonopriceAudioConnector connector;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param connector the object that should handle the received message\n+     * @param uid unique identifier from the connector\n+     */\n+    public MonopriceAudioReaderThread(MonopriceAudioConnector connector, String uid) {\n+        super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\nindex da2d134ce8..5daf185a3c 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioReaderThread.java\n\n@@ -42,7 +42,7 @@ public class MonopriceAudioReaderThread extends Thread {\n      * @param uid unique identifier from the connector\n      */\n     public MonopriceAudioReaderThread(MonopriceAudioConnector connector, String uid) {\n-        super(MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n+        super(\"OH-binding-\" + MonopriceAudioBindingConstants.BINDING_ID + \"-\" + uid);\n         this.connector = connector;\n         setDaemon(true);\n     }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NjQ1MA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676450", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String serialPortName;\n          \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final String serialPortName;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "author": "Hilbrand", "createdAt": "2020-08-21T12:51:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for communicating with the MonopriceAudio device through a serial connection\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ * @author Michael Lobstein - Adapted for the MonopriceAudio binding\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n+\n+    private String serialPortName;\n+    private SerialPortManager serialPortManager;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\nindex b4e9df328c..28ef29fb03 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioSerialConnector.java\n\n@@ -39,8 +39,8 @@ public class MonopriceAudioSerialConnector extends MonopriceAudioConnector {\n \n     private final Logger logger = LoggerFactory.getLogger(MonopriceAudioSerialConnector.class);\n \n-    private String serialPortName;\n-    private SerialPortManager serialPortManager;\n+    private final String serialPortName;\n+    private final SerialPortManager serialPortManager;\n \n     private @Nullable SerialPort serialPort;\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3Njk0Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474676943", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n          \n          \n            \n                public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(MonopriceAudioZone::name)", "author": "Hilbrand", "createdAt": "2020-08-21T12:52:20Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\nindex 5ce0f45b64..7a74687e85 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n\n@@ -47,15 +47,15 @@ public enum MonopriceAudioZone {\n     ZONE17(\"35\"),\n     ZONE18(\"36\");\n \n-    private String zoneId;\n+    private final String zoneId;\n \n     // make a list of all valid zone names\n-    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n-            .collect(Collectors.toList());\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(MonopriceAudioZone::name).collect(Collectors.toList());\n \n     // make a list of all valid zone ids\n     public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n-            .map(z -> z.getZoneId()).collect(Collectors.toList());\n+            .map(MonopriceAudioZone::getZoneId).collect(Collectors.toList());\n \n     public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n         return Arrays.stream(values()).filter(z -> z.zoneId.equalsIgnoreCase(zoneId)).findFirst()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3NzA2Mw==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474677063", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .map(z -> z.getZoneId()).collect(Collectors.toList());\n          \n          \n            \n                        .map(MonopriceAudioZone::getZoneId).collect(Collectors.toList());", "author": "Hilbrand", "createdAt": "2020-08-21T12:52:39Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;\n+\n+    // make a list of all valid zone names\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n+            .collect(Collectors.toList());\n+\n+    // make a list of all valid zone ids\n+    public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(z -> z.getZoneId()).collect(Collectors.toList());", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\nindex 5ce0f45b64..7a74687e85 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n\n@@ -47,15 +47,15 @@ public enum MonopriceAudioZone {\n     ZONE17(\"35\"),\n     ZONE18(\"36\");\n \n-    private String zoneId;\n+    private final String zoneId;\n \n     // make a list of all valid zone names\n-    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n-            .collect(Collectors.toList());\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(MonopriceAudioZone::name).collect(Collectors.toList());\n \n     // make a list of all valid zone ids\n     public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n-            .map(z -> z.getZoneId()).collect(Collectors.toList());\n+            .map(MonopriceAudioZone::getZoneId).collect(Collectors.toList());\n \n     public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n         return Arrays.stream(values()).filter(z -> z.zoneId.equalsIgnoreCase(zoneId)).findFirst()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY3ODU4OQ==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474678589", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String zoneId;\n          \n          \n            \n                private final String zoneId;", "author": "Hilbrand", "createdAt": "2020-08-21T12:55:41Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+\n+/**\n+ * Represents the different internal zone IDs of the Monoprice Whole House Amplifier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public enum MonopriceAudioZone {\n+\n+    ALL(\"all\"),\n+    ZONE1(\"11\"),\n+    ZONE2(\"12\"),\n+    ZONE3(\"13\"),\n+    ZONE4(\"14\"),\n+    ZONE5(\"15\"),\n+    ZONE6(\"16\"),\n+    ZONE7(\"21\"),\n+    ZONE8(\"22\"),\n+    ZONE9(\"23\"),\n+    ZONE10(\"24\"),\n+    ZONE11(\"25\"),\n+    ZONE12(\"26\"),\n+    ZONE13(\"31\"),\n+    ZONE14(\"32\"),\n+    ZONE15(\"33\"),\n+    ZONE16(\"34\"),\n+    ZONE17(\"35\"),\n+    ZONE18(\"36\");\n+\n+    private String zoneId;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\nindex 5ce0f45b64..7a74687e85 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioZone.java\n\n@@ -47,15 +47,15 @@ public enum MonopriceAudioZone {\n     ZONE17(\"35\"),\n     ZONE18(\"36\");\n \n-    private String zoneId;\n+    private final String zoneId;\n \n     // make a list of all valid zone names\n-    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL).map(z -> z.name())\n-            .collect(Collectors.toList());\n+    public static final List<String> VALID_ZONES = Arrays.stream(values()).filter(z -> z != ALL)\n+            .map(MonopriceAudioZone::name).collect(Collectors.toList());\n \n     // make a list of all valid zone ids\n     public static final List<String> VALID_ZONE_IDS = Arrays.stream(values()).filter(z -> z != ALL)\n-            .map(z -> z.getZoneId()).collect(Collectors.toList());\n+            .map(MonopriceAudioZone::getZoneId).collect(Collectors.toList());\n \n     public static MonopriceAudioZone fromZoneId(String zoneId) throws MonopriceAudioException {\n         return Arrays.stream(values()).filter(z -> z.zoneId.equalsIgnoreCase(zoneId)).findFirst()\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDUxNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474704516", "bodyText": "The openHAB serial port handler supports rfc2217? Is there a reason not to use it and instead of having implemented a separate ip connector and configuration options?", "author": "Hilbrand", "createdAt": "2020-08-21T13:40:40Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java", "diffHunk": "@@ -0,0 +1,703 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.handler;\n+\n+import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.OpenClosedType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n+import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n+import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n+import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n+import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * Based on the Rotel binding by Laurent Garnier\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n+    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n+    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n+    private static final Pattern PATTERN = Pattern\n+            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n+\n+    private static final String ZONE = \"ZONE\";\n+    private static final String ALL = \"all\";\n+    private static final String CHANNEL_DELIMIT = \"#\";\n+    private static final String ON_STR = \"01\";\n+    private static final String OFF_STR = \"00\";\n+\n+    private static final int ONE = 1;\n+    private static final int MAX_ZONES = 18;\n+    private static final int MAX_SRC = 6;\n+    private static final int MIN_VOLUME = 0;\n+    private static final int MAX_VOLUME = 38;\n+    private static final int MIN_TONE = -7;\n+    private static final int MAX_TONE = 7;\n+    private static final int MIN_BALANCE = -10;\n+    private static final int MAX_BALANCE = 10;\n+    private static final int BALANCE_OFFSET = 10;\n+    private static final int TONE_OFFSET = 7;\n+\n+    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n+    private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n+            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n+\n+    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n+    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable ScheduledFuture<?> reconnectJob;\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+\n+    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n+\n+    private Set<String> ignoreZones = new HashSet<>();\n+    private long lastPollingUpdate = System.currentTimeMillis();\n+    private long pollingInterval = 0;\n+    private int numZones = 0;\n+    private int allVolume = 1;\n+    private int initialAllVolume = 0;\n+    private Object sequenceLock = new Object();\n+\n+    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n+            SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.stateDescriptionProvider = stateDescriptionProvider;\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n+        String serialPort = config.serialPort;\n+        String host = config.host;\n+        Integer port = config.port;\n+        String ignoreZonesConfig = config.ignoreZones;\n+\n+        // Check configuration settings\n+        String configError = null;\n+        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n+            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n+        } else if (serialPort != null && (host == null || host.isEmpty())) {\n+            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAyNzcwNg==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r475027706", "bodyText": "same comment as on pr #7651", "author": "mlobstein", "createdAt": "2020-08-22T01:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDUxNg=="}], "type": "inlineReview", "revised_code": {"commit": "f49106bbf897956459a88243323fc5d64a4b3223", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\ndeleted file mode 100644\nindex bf4b813f16..0000000000\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/handler/MonopriceAudioHandler.java\n+++ /dev/null\n\n@@ -1,703 +0,0 @@\n-/**\n- * Copyright (c) 2010-2020 Contributors to the openHAB project\n- *\n- * See the NOTICE file(s) distributed with this work for additional\n- * information.\n- *\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- */\n-package org.openhab.binding.monopriceaudio.internal.handler;\n-\n-import static org.openhab.binding.monopriceaudio.internal.MonopriceAudioBindingConstants.*;\n-\n-import java.math.BigDecimal;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ScheduledFuture;\n-import java.util.concurrent.TimeUnit;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import org.eclipse.jdt.annotation.NonNullByDefault;\n-import org.eclipse.jdt.annotation.Nullable;\n-import org.eclipse.smarthome.core.library.types.DecimalType;\n-import org.eclipse.smarthome.core.library.types.OnOffType;\n-import org.eclipse.smarthome.core.library.types.OpenClosedType;\n-import org.eclipse.smarthome.core.library.types.PercentType;\n-import org.eclipse.smarthome.core.thing.Channel;\n-import org.eclipse.smarthome.core.thing.ChannelUID;\n-import org.eclipse.smarthome.core.thing.Thing;\n-import org.eclipse.smarthome.core.thing.ThingStatus;\n-import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n-import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n-import org.eclipse.smarthome.core.types.Command;\n-import org.eclipse.smarthome.core.types.RefreshType;\n-import org.eclipse.smarthome.core.types.State;\n-import org.eclipse.smarthome.core.types.StateOption;\n-import org.eclipse.smarthome.core.types.UnDefType;\n-import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n-import org.openhab.binding.monopriceaudio.internal.MonopriceAudioException;\n-import org.openhab.binding.monopriceaudio.internal.MonopriceAudioStateDescriptionOptionProvider;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioCommand;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioConnector;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioDefaultConnector;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioIpConnector;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEvent;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioMessageEventListener;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioSerialConnector;\n-import org.openhab.binding.monopriceaudio.internal.communication.MonopriceAudioZone;\n-import org.openhab.binding.monopriceaudio.internal.configuration.MonopriceAudioThingConfiguration;\n-import org.openhab.binding.monopriceaudio.internal.dto.MonopriceAudioZoneDTO;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-/**\n- * The {@link MonopriceAudioHandler} is responsible for handling commands, which are sent to one of the channels.\n- *\n- * Based on the Rotel binding by Laurent Garnier\n- *\n- * @author Michael Lobstein - Initial contribution\n- */\n-@NonNullByDefault\n-public class MonopriceAudioHandler extends BaseThingHandler implements MonopriceAudioMessageEventListener {\n-    private static final long RECON_POLLING_INTERVAL_SEC = 60;\n-    private static final long INITIAL_POLLING_DELAY_SEC = 5;\n-    private static final Pattern PATTERN = Pattern\n-            .compile(\"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\");\n-\n-    private static final String ZONE = \"ZONE\";\n-    private static final String ALL = \"all\";\n-    private static final String CHANNEL_DELIMIT = \"#\";\n-    private static final String ON_STR = \"01\";\n-    private static final String OFF_STR = \"00\";\n-\n-    private static final int ONE = 1;\n-    private static final int MAX_ZONES = 18;\n-    private static final int MAX_SRC = 6;\n-    private static final int MIN_VOLUME = 0;\n-    private static final int MAX_VOLUME = 38;\n-    private static final int MIN_TONE = -7;\n-    private static final int MAX_TONE = 7;\n-    private static final int MIN_BALANCE = -10;\n-    private static final int MAX_BALANCE = 10;\n-    private static final int BALANCE_OFFSET = 10;\n-    private static final int TONE_OFFSET = 7;\n-\n-    // build a Map with a MonopriceAudioZoneDTO for each zoneId\n-    private final Map<String, MonopriceAudioZoneDTO> zoneDataMap = MonopriceAudioZone.VALID_ZONE_IDS.stream()\n-            .collect(Collectors.toMap(s -> s, s -> new MonopriceAudioZoneDTO()));\n-\n-    private final Logger logger = LoggerFactory.getLogger(MonopriceAudioHandler.class);\n-    private final MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider;\n-    private final SerialPortManager serialPortManager;\n-\n-    private @Nullable ScheduledFuture<?> reconnectJob;\n-    private @Nullable ScheduledFuture<?> pollingJob;\n-\n-    private MonopriceAudioConnector connector = new MonopriceAudioDefaultConnector();\n-\n-    private Set<String> ignoreZones = new HashSet<>();\n-    private long lastPollingUpdate = System.currentTimeMillis();\n-    private long pollingInterval = 0;\n-    private int numZones = 0;\n-    private int allVolume = 1;\n-    private int initialAllVolume = 0;\n-    private Object sequenceLock = new Object();\n-\n-    public MonopriceAudioHandler(Thing thing, MonopriceAudioStateDescriptionOptionProvider stateDescriptionProvider,\n-            SerialPortManager serialPortManager) {\n-        super(thing);\n-        this.stateDescriptionProvider = stateDescriptionProvider;\n-        this.serialPortManager = serialPortManager;\n-    }\n-\n-    @Override\n-    public void initialize() {\n-        MonopriceAudioThingConfiguration config = getConfigAs(MonopriceAudioThingConfiguration.class);\n-        String serialPort = config.serialPort;\n-        String host = config.host;\n-        Integer port = config.port;\n-        String ignoreZonesConfig = config.ignoreZones;\n-\n-        // Check configuration settings\n-        String configError = null;\n-        if ((serialPort == null || serialPort.isEmpty()) && (host == null || host.isEmpty())) {\n-            configError = \"undefined serialPort and host configuration settings; please set one of them\";\n-        } else if (serialPort != null && (host == null || host.isEmpty())) {\n-            if (serialPort.toLowerCase().startsWith(\"rfc2217\")) {\n-                configError = \"use host and port configuration settings for a serial over IP connection\";\n-            }\n-        } else {\n-            if (port == null) {\n-                configError = \"undefined port configuration setting\";\n-            } else if (port <= 0) {\n-                configError = \"invalid port configuration setting\";\n-            }\n-        }\n-\n-        if (configError != null) {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, configError);\n-            return;\n-        }\n-\n-        if (serialPort != null) {\n-            connector = new MonopriceAudioSerialConnector(serialPortManager, serialPort);\n-        } else if (port != null) {\n-            connector = new MonopriceAudioIpConnector(host, port);\n-        } else {\n-            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n-                    \"Either Serial port or Host & Port must be specifed\");\n-            return;\n-        }\n-\n-        pollingInterval = config.pollingInterval;\n-        numZones = config.numZones;\n-        initialAllVolume = config.initialAllVolume;\n-\n-        // If zones were specified to be ignored by the 'all*' commands, use the specified binding\n-        // zone ids to get the controller's internal zone ids and save those to a list\n-        if (ignoreZonesConfig != null) {\n-            for (String zone : ignoreZonesConfig.split(\",\")) {\n-                try {\n-                    int zoneInt = Integer.parseInt(zone);\n-                    if (zoneInt >= ONE && zoneInt <= MAX_ZONES) {\n-                        ignoreZones.add(ZONE + zoneInt);\n-                    } else {\n-                        logger.warn(\"Invalid ignore zone value: {}, value must be between {} and {}\", zone, ONE,\n-                                MAX_ZONES);\n-                    }\n-                } catch (NumberFormatException nfe) {\n-                    logger.warn(\"Invalid ignore zone value: {}\", zone);\n-                }\n-            }\n-        }\n-\n-        // Build a state option list for the source labels\n-        List<StateOption> sourcesLabels = new ArrayList<>();\n-        sourcesLabels.add(new StateOption(\"1\", config.inputLabel1));\n-        sourcesLabels.add(new StateOption(\"2\", config.inputLabel2));\n-        sourcesLabels.add(new StateOption(\"3\", config.inputLabel3));\n-        sourcesLabels.add(new StateOption(\"4\", config.inputLabel4));\n-        sourcesLabels.add(new StateOption(\"5\", config.inputLabel5));\n-        sourcesLabels.add(new StateOption(\"6\", config.inputLabel6));\n-\n-        // Put the source labels on all active zones\n-        List<Integer> activeZones = IntStream.range(1, numZones + 1).boxed().collect(Collectors.toList());\n-\n-        stateDescriptionProvider.setStateOptions(\n-                new ChannelUID(getThing().getUID(), ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLSOURCE), sourcesLabels);\n-        activeZones.forEach(zoneNum -> {\n-            stateDescriptionProvider.setStateOptions(new ChannelUID(getThing().getUID(),\n-                    ZONE.toLowerCase() + zoneNum + CHANNEL_DELIMIT + CHANNEL_TYPE_SOURCE), sourcesLabels);\n-        });\n-\n-        // remove the channels for the zones we are not using\n-        if (numZones < MAX_ZONES) {\n-            List<Channel> channels = new ArrayList<>(this.getThing().getChannels());\n-\n-            List<Integer> zonesToRemove = IntStream.range(numZones + 1, MAX_ZONES + 1).boxed()\n-                    .collect(Collectors.toList());\n-\n-            zonesToRemove.forEach(zone -> {\n-                channels.removeIf(c -> (c.getUID().getId().contains(ZONE.toLowerCase() + zone)));\n-            });\n-            updateThing(editThing().withChannels(channels).build());\n-        }\n-\n-        // initialize the all volume state\n-        allVolume = initialAllVolume;\n-        long allVolumePct = Math\n-                .round((double) (initialAllVolume - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n-        updateState(ALL + CHANNEL_DELIMIT + CHANNEL_TYPE_ALLVOLUME, new PercentType(BigDecimal.valueOf(allVolumePct)));\n-\n-        scheduleReconnectJob();\n-        schedulePollingJob();\n-\n-        updateStatus(ThingStatus.UNKNOWN);\n-    }\n-\n-    @Override\n-    public void dispose() {\n-        cancelReconnectJob();\n-        cancelPollingJob();\n-        closeConnection();\n-        ignoreZones.clear();\n-    }\n-\n-    @Override\n-    public void handleCommand(ChannelUID channelUID, Command command) {\n-        String channel = channelUID.getId();\n-        String[] channelSplit = channel.split(CHANNEL_DELIMIT);\n-        MonopriceAudioZone zone = MonopriceAudioZone.valueOf(channelSplit[0].toUpperCase());\n-        String channelType = channelSplit[1];\n-\n-        if (getThing().getStatus() != ThingStatus.ONLINE) {\n-            logger.debug(\"Thing is not ONLINE; command {} from channel {} is ignored\", command, channel);\n-            return;\n-        }\n-\n-        boolean success = true;\n-        synchronized (sequenceLock) {\n-            if (!connector.isConnected()) {\n-                logger.debug(\"Command {} from channel {} is ignored: connection not established\", command, channel);\n-                return;\n-            }\n-\n-            if (command instanceof RefreshType) {\n-                updateChannelState(zone, channelType, zoneDataMap.get(zone.getZoneId()));\n-                return;\n-            }\n-\n-            Stream<String> zoneStream = MonopriceAudioZone.VALID_ZONES.stream().limit(numZones);\n-            try {\n-                switch (channelType) {\n-                    case CHANNEL_TYPE_POWER:\n-                        if (command instanceof OnOffType) {\n-                            connector.sendCommand(zone, MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n-                            zoneDataMap.get(zone.getZoneId()).setPower(command == OnOffType.ON ? ON_STR : OFF_STR);\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_SOURCE:\n-                        if (command instanceof DecimalType) {\n-                            int value = ((DecimalType) command).intValue();\n-                            if (value >= ONE && value <= MAX_SRC) {\n-                                logger.debug(\"Got source command {} zone {}\", value, zone);\n-                                connector.sendCommand(zone, MonopriceAudioCommand.SOURCE, value);\n-                                zoneDataMap.get(zone.getZoneId()).setSource(String.format(\"%02d\", value));\n-                            }\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_VOLUME:\n-                        if (command instanceof PercentType) {\n-                            int value = (int) Math\n-                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n-                                    + MIN_VOLUME;\n-                            logger.debug(\"Got volume command {} zone {}\", value, zone);\n-                            connector.sendCommand(zone, MonopriceAudioCommand.VOLUME, value);\n-                            zoneDataMap.get(zone.getZoneId()).setVolume(value);\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_MUTE:\n-                        if (command instanceof OnOffType) {\n-                            connector.sendCommand(zone, MonopriceAudioCommand.MUTE, command == OnOffType.ON ? 1 : 0);\n-                            zoneDataMap.get(zone.getZoneId()).setMute(command == OnOffType.ON ? ON_STR : OFF_STR);\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_TREBLE:\n-                        if (command instanceof DecimalType) {\n-                            int value = ((DecimalType) command).intValue();\n-                            if (value >= MIN_TONE && value <= MAX_TONE) {\n-                                logger.debug(\"Got treble command {} zone {}\", value, zone);\n-                                connector.sendCommand(zone, MonopriceAudioCommand.TREBLE, value + TONE_OFFSET);\n-                                zoneDataMap.get(zone.getZoneId()).setTreble(value + TONE_OFFSET);\n-                            }\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_BASS:\n-                        if (command instanceof DecimalType) {\n-                            int value = ((DecimalType) command).intValue();\n-                            if (value >= MIN_TONE && value <= MAX_TONE) {\n-                                logger.debug(\"Got bass command {} zone {}\", value, zone);\n-                                connector.sendCommand(zone, MonopriceAudioCommand.BASS, value + TONE_OFFSET);\n-                                zoneDataMap.get(zone.getZoneId()).setBass(value + TONE_OFFSET);\n-                            }\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_BALANCE:\n-                        if (command instanceof DecimalType) {\n-                            int value = ((DecimalType) command).intValue();\n-                            if (value >= MIN_BALANCE && value <= MAX_BALANCE) {\n-                                logger.debug(\"Got balance command {} zone {}\", value, zone);\n-                                connector.sendCommand(zone, MonopriceAudioCommand.BALANCE, value + BALANCE_OFFSET);\n-                                zoneDataMap.get(zone.getZoneId()).setBalance(value + BALANCE_OFFSET);\n-                            }\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_DND:\n-                        if (command instanceof OnOffType) {\n-                            connector.sendCommand(zone, MonopriceAudioCommand.DND, command == OnOffType.ON ? 1 : 0);\n-                            zoneDataMap.get(zone.getZoneId()).setDnd(command == OnOffType.ON ? ON_STR : OFF_STR);\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_ALLPOWER:\n-                        if (command instanceof OnOffType) {\n-                            zoneStream.forEach((zoneName) -> {\n-                                if (command == OnOffType.OFF || !ignoreZones.contains(zoneName)) {\n-                                    try {\n-                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n-                                                MonopriceAudioCommand.POWER, command == OnOffType.ON ? 1 : 0);\n-                                        if (command == OnOffType.ON) {\n-                                            // reset the volume of each zone to allVolume\n-                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n-                                                    MonopriceAudioCommand.VOLUME, allVolume);\n-                                        }\n-                                    } catch (MonopriceAudioException e) {\n-                                        logger.warn(\"Error Turning All Zones On: {}\", e.getMessage());\n-                                    }\n-                                }\n-\n-                            });\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_ALLSOURCE:\n-                        if (command instanceof DecimalType) {\n-                            int value = ((DecimalType) command).intValue();\n-                            if (value >= ONE && value <= MAX_SRC) {\n-                                zoneStream.forEach((zoneName) -> {\n-                                    if (!ignoreZones.contains(zoneName)) {\n-                                        try {\n-                                            connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n-                                                    MonopriceAudioCommand.SOURCE, value);\n-                                        } catch (MonopriceAudioException e) {\n-                                            logger.warn(\"Error Setting Source for  All Zones: {}\", e.getMessage());\n-                                        }\n-                                    }\n-                                });\n-                            }\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_ALLVOLUME:\n-                        if (command instanceof PercentType) {\n-                            int value = (int) Math\n-                                    .round(((PercentType) command).doubleValue() / 100.0 * (MAX_VOLUME - MIN_VOLUME))\n-                                    + MIN_VOLUME;\n-                            allVolume = value;\n-                            zoneStream.forEach((zoneName) -> {\n-                                if (!ignoreZones.contains(zoneName)) {\n-                                    try {\n-                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n-                                                MonopriceAudioCommand.VOLUME, value);\n-                                    } catch (MonopriceAudioException e) {\n-                                        logger.warn(\"Error Setting Volume for All Zones: {}\", e.getMessage());\n-                                    }\n-                                }\n-                            });\n-                        }\n-                        break;\n-                    case CHANNEL_TYPE_ALLMUTE:\n-                        if (command instanceof OnOffType) {\n-                            int cmd = command == OnOffType.ON ? 1 : 0;\n-                            zoneStream.forEach((zoneName) -> {\n-                                if (!ignoreZones.contains(zoneName)) {\n-                                    try {\n-                                        connector.sendCommand(MonopriceAudioZone.valueOf(zoneName),\n-                                                MonopriceAudioCommand.MUTE, cmd);\n-                                    } catch (MonopriceAudioException e) {\n-                                        logger.warn(\"Error Setting Mute for All Zones: {}\", e.getMessage());\n-                                    }\n-                                }\n-                            });\n-                        }\n-                        break;\n-                    default:\n-                        success = false;\n-                        logger.debug(\"Command {} from channel {} failed: unexpected command\", command, channel);\n-                        break;\n-                }\n-\n-                if (success) {\n-                    logger.trace(\"Command {} from channel {} succeeded\", command, channel);\n-                }\n-            } catch (MonopriceAudioException e) {\n-                logger.warn(\"Command {} from channel {} failed: {}\", command, channel, e.getMessage());\n-                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Sending command failed\");\n-                closeConnection();\n-                scheduleReconnectJob();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Open the connection with the MonopriceAudio device\n-     *\n-     * @return true if the connection is opened successfully or false if not\n-     */\n-    private synchronized boolean openConnection() {\n-        connector.addEventListener(this);\n-        try {\n-            connector.open();\n-        } catch (MonopriceAudioException e) {\n-            logger.debug(\"openConnection() failed: {}\", e.getMessage());\n-        }\n-        logger.debug(\"openConnection(): {}\", connector.isConnected() ? \"connected\" : \"disconnected\");\n-        return connector.isConnected();\n-    }\n-\n-    /**\n-     * Close the connection with the MonopriceAudio device\n-     */\n-    private synchronized void closeConnection() {\n-        if (connector.isConnected()) {\n-            connector.close();\n-            connector.removeEventListener(this);\n-            logger.debug(\"closeConnection(): disconnected\");\n-        }\n-    }\n-\n-    @Override\n-    public void onNewMessageEvent(MonopriceAudioMessageEvent evt) {\n-        String key = evt.getKey();\n-        String updateData = evt.getValue().trim();\n-        if (!MonopriceAudioConnector.KEY_ERROR.equals(key)) {\n-            updateStatus(ThingStatus.ONLINE);\n-        }\n-        try {\n-            switch (key) {\n-                case MonopriceAudioConnector.KEY_ERROR:\n-                    logger.debug(\"Reading feedback message failed\");\n-                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Reading thread ended\");\n-                    closeConnection();\n-                    break;\n-\n-                case MonopriceAudioConnector.KEY_ZONE_UPDATE:\n-                    String zoneId = updateData.substring(0, 2);\n-\n-                    if (MonopriceAudioZone.VALID_ZONE_IDS.contains(zoneId)) {\n-                        MonopriceAudioZone targetZone = MonopriceAudioZone.fromZoneId(zoneId);\n-                        processZoneUpdate(targetZone, zoneDataMap.get(zoneId), updateData);\n-                    } else {\n-                        logger.warn(\"invalid event: {} for key: {}\", evt.getValue(), key);\n-                    }\n-                    break;\n-                default:\n-                    logger.debug(\"onNewMessageEvent: unhandled key {}\", key);\n-                    break;\n-            }\n-        } catch (NumberFormatException e) {\n-            logger.warn(\"Invalid value {} for key {}\", updateData, key);\n-        } catch (MonopriceAudioException e) {\n-            logger.warn(\"Error processing zone update: {}\", e.getMessage());\n-        }\n-    }\n-\n-    /**\n-     * Schedule the reconnection job\n-     */\n-    private void scheduleReconnectJob() {\n-        logger.debug(\"Schedule reconnect job\");\n-        cancelReconnectJob();\n-        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n-            synchronized (sequenceLock) {\n-                if (!connector.isConnected()) {\n-                    logger.debug(\"Trying to reconnect...\");\n-                    closeConnection();\n-                    String error = null;\n-\n-                    if (openConnection()) {\n-                        try {\n-                            long prevUpdateTime = lastPollingUpdate;\n-                            connector.queryZone(MonopriceAudioZone.ZONE1);\n-\n-                            // prevUpdateTime should have changed if a zone update was received\n-                            if (lastPollingUpdate == prevUpdateTime) {\n-                                error = \"Controller not responding to status requests\";\n-                            }\n-\n-                        } catch (MonopriceAudioException e) {\n-                            error = \"First command after connection failed\";\n-                            logger.warn(\"{}: {}\", error, e.getMessage());\n-                            closeConnection();\n-                        }\n-                    } else {\n-                        error = \"Reconnection failed\";\n-                    }\n-                    if (error != null) {\n-                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n-                    } else {\n-                        updateStatus(ThingStatus.ONLINE);\n-                        lastPollingUpdate = System.currentTimeMillis();\n-                    }\n-                }\n-            }\n-        }, 1, RECON_POLLING_INTERVAL_SEC, TimeUnit.SECONDS);\n-    }\n-\n-    /**\n-     * Cancel the reconnection job\n-     */\n-    private void cancelReconnectJob() {\n-        ScheduledFuture<?> reconnectJob = this.reconnectJob;\n-        if (reconnectJob != null) {\n-            reconnectJob.cancel(true);\n-            this.reconnectJob = null;\n-        }\n-    }\n-\n-    /**\n-     * Schedule the polling job\n-     */\n-    private void schedulePollingJob() {\n-        logger.debug(\"Schedule polling job\");\n-        cancelPollingJob();\n-\n-        pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n-            synchronized (sequenceLock) {\n-                if (connector.isConnected()) {\n-                    logger.debug(\"Polling the controller for updated status...\");\n-\n-                    // poll each zone up to the number of zones specified in the configuration\n-                    MonopriceAudioZone.VALID_ZONES.stream().limit(numZones).forEach((zoneName) -> {\n-                        try {\n-                            connector.queryZone(MonopriceAudioZone.valueOf(zoneName));\n-                        } catch (MonopriceAudioException e) {\n-                            logger.warn(\"Polling error: {}\", e.getMessage());\n-                        }\n-                    });\n-\n-                    // if the last successful polling update was more than 2.25 intervals ago, the controller\n-                    // is either switched off or not responding even though the connection is still good\n-                    if ((System.currentTimeMillis() - lastPollingUpdate) > (pollingInterval * 2.25 * 1000)) {\n-                        logger.warn(\"Controller not responding to status requests\");\n-                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n-                                \"Controller not responding to status requests\");\n-                        closeConnection();\n-                        scheduleReconnectJob();\n-                    }\n-                }\n-            }\n-        }, INITIAL_POLLING_DELAY_SEC, pollingInterval, TimeUnit.SECONDS);\n-    }\n-\n-    /**\n-     * Cancel the polling job\n-     */\n-    private void cancelPollingJob() {\n-        ScheduledFuture<?> pollingJob = this.pollingJob;\n-        if (pollingJob != null) {\n-            pollingJob.cancel(true);\n-            this.pollingJob = null;\n-        }\n-    }\n-\n-    /**\n-     * Update the state of a channel\n-     *\n-     * @param channel the channel\n-     */\n-    private void updateChannelState(MonopriceAudioZone zone, String channelType, MonopriceAudioZoneDTO zoneData) {\n-        String channel = zone.name().toLowerCase() + CHANNEL_DELIMIT + channelType;\n-\n-        if (!isLinked(channel)) {\n-            return;\n-        }\n-\n-        State state = UnDefType.UNDEF;\n-        switch (channelType) {\n-            case CHANNEL_TYPE_POWER:\n-                state = zoneData.isPowerOn() ? OnOffType.ON : OnOffType.OFF;\n-                break;\n-            case CHANNEL_TYPE_SOURCE:\n-                state = new DecimalType(zoneData.getSource());\n-                break;\n-            case CHANNEL_TYPE_VOLUME:\n-                long volumePct = Math.round(\n-                        (double) (zoneData.getVolume() - MIN_VOLUME) / (double) (MAX_VOLUME - MIN_VOLUME) * 100.0);\n-                state = new PercentType(BigDecimal.valueOf(volumePct));\n-                break;\n-            case CHANNEL_TYPE_MUTE:\n-                state = zoneData.isMuted() ? OnOffType.ON : OnOffType.OFF;\n-                break;\n-            case CHANNEL_TYPE_TREBLE:\n-                state = new DecimalType(BigDecimal.valueOf(zoneData.getTreble() - TONE_OFFSET));\n-                break;\n-            case CHANNEL_TYPE_BASS:\n-                state = new DecimalType(BigDecimal.valueOf(zoneData.getBass() - TONE_OFFSET));\n-                break;\n-            case CHANNEL_TYPE_BALANCE:\n-                state = new DecimalType(BigDecimal.valueOf(zoneData.getBalance() - BALANCE_OFFSET));\n-                break;\n-            case CHANNEL_TYPE_DND:\n-                state = zoneData.isDndOn() ? OnOffType.ON : OnOffType.OFF;\n-                break;\n-            case CHANNEL_TYPE_PAGE:\n-                state = zoneData.isPageActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n-                break;\n-            case CHANNEL_TYPE_KEYPAD:\n-                state = zoneData.isKeypadActive() ? OpenClosedType.OPEN : OpenClosedType.CLOSED;\n-                break;\n-            default:\n-                break;\n-        }\n-        updateState(channel, state);\n-    }\n-\n-    private void processZoneUpdate(MonopriceAudioZone zone, MonopriceAudioZoneDTO zoneData, String newZoneData) {\n-        // only process the update if something actually changed in this zone since the last time through\n-        if (!newZoneData.equals(zoneData.toString())) {\n-            // example status string: 1200010000130809100601, matcher pattern from above:\n-            // \"^(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})(\\\\d{2})\"\n-            Matcher matcher = PATTERN.matcher(newZoneData);\n-            if (matcher.find()) {\n-                zoneData.setZone(matcher.group(1));\n-\n-                if (!matcher.group(2).equals(zoneData.getPage())) {\n-                    zoneData.setPage(matcher.group(2));\n-                    updateChannelState(zone, CHANNEL_TYPE_PAGE, zoneData);\n-                }\n-\n-                if (!matcher.group(3).equals(zoneData.getPower())) {\n-                    zoneData.setPower(matcher.group(3));\n-                    updateChannelState(zone, CHANNEL_TYPE_POWER, zoneData);\n-                }\n-\n-                if (!matcher.group(4).equals(zoneData.getMute())) {\n-                    zoneData.setMute(matcher.group(4));\n-                    updateChannelState(zone, CHANNEL_TYPE_MUTE, zoneData);\n-                }\n-\n-                if (!matcher.group(5).equals(zoneData.getDnd())) {\n-                    zoneData.setDnd(matcher.group(5));\n-                    updateChannelState(zone, CHANNEL_TYPE_DND, zoneData);\n-                }\n-\n-                int volume = Integer.parseInt(matcher.group(6));\n-                if (volume != zoneData.getVolume()) {\n-                    zoneData.setVolume(volume);\n-                    updateChannelState(zone, CHANNEL_TYPE_VOLUME, zoneData);\n-                }\n-\n-                int treble = Integer.parseInt(matcher.group(7));\n-                if (treble != zoneData.getTreble()) {\n-                    zoneData.setTreble(treble);\n-                    updateChannelState(zone, CHANNEL_TYPE_TREBLE, zoneData);\n-                }\n-\n-                int bass = Integer.parseInt(matcher.group(8));\n-                if (bass != zoneData.getBass()) {\n-                    zoneData.setBass(bass);\n-                    updateChannelState(zone, CHANNEL_TYPE_BASS, zoneData);\n-                }\n-\n-                int balance = Integer.parseInt(matcher.group(9));\n-                if (balance != zoneData.getBalance()) {\n-                    zoneData.setBalance(balance);\n-                    updateChannelState(zone, CHANNEL_TYPE_BALANCE, zoneData);\n-                }\n-\n-                if (!matcher.group(10).equals(zoneData.getSource())) {\n-                    zoneData.setSource(matcher.group(10));\n-                    updateChannelState(zone, CHANNEL_TYPE_SOURCE, zoneData);\n-                }\n-\n-                if (!matcher.group(11).equals(zoneData.getKeypad())) {\n-                    zoneData.setKeypad(matcher.group(11));\n-                    updateChannelState(zone, CHANNEL_TYPE_KEYPAD, zoneData);\n-                }\n-            } else {\n-                logger.debug(\"Invalid zone update message: {}\", newZoneData);\n-            }\n-\n-        }\n-        lastPollingUpdate = System.currentTimeMillis();\n-    }\n-}\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwNDg0OA==", "url": "https://github.com/openhab/openhab-addons/pull/7371#discussion_r474704848", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String key;\n          \n          \n            \n                private String value;\n          \n          \n            \n                private final String key;\n          \n          \n            \n                private final String value;", "author": "Hilbrand", "createdAt": "2020-08-21T13:41:13Z", "path": "bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.monopriceaudio.internal.communication;\n+\n+import java.util.EventObject;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * MonopriceAudio event used to notify changes coming from messages received from the MonopriceAudio device\n+ *\n+ * @author Michael Lobstein - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MonopriceAudioMessageEvent extends EventObject {\n+\n+    private static final long serialVersionUID = 1L;\n+    private String key;\n+    private String value;", "originalCommit": "7f0a56bf418fed52b7ad2773f493a849942f4857", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "chunk": "diff --git a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java\nindex 01d7d3cfbe..2531e80e34 100644\n--- a/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java\n+++ b/bundles/org.openhab.binding.monopriceaudio/src/main/java/org/openhab/binding/monopriceaudio/internal/communication/MonopriceAudioMessageEvent.java\n\n@@ -25,8 +25,8 @@ import org.eclipse.jdt.annotation.NonNullByDefault;\n public class MonopriceAudioMessageEvent extends EventObject {\n \n     private static final long serialVersionUID = 1L;\n-    private String key;\n-    private String value;\n+    private final String key;\n+    private final String value;\n \n     public MonopriceAudioMessageEvent(Object source, String key, String value) {\n         super(source);\n"}}, {"oid": "4c109203efcc0bcb3112baf832ad75ecd2481a0a", "url": "https://github.com/openhab/openhab-addons/commit/4c109203efcc0bcb3112baf832ad75ecd2481a0a", "message": "more review changes\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-22T01:04:44Z", "type": "commit"}, {"oid": "f49106bbf897956459a88243323fc5d64a4b3223", "url": "https://github.com/openhab/openhab-addons/commit/f49106bbf897956459a88243323fc5d64a4b3223", "message": "Merge pull request #9 from openhab/2.5.x\n\nUpdate fork", "committedDate": "2020-08-22T01:32:17Z", "type": "commit"}, {"oid": "746cf624b417b4b9df1e3ca4a8066f931485ef87", "url": "https://github.com/openhab/openhab-addons/commit/746cf624b417b4b9df1e3ca4a8066f931485ef87", "message": "merge pom.xml\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-22T01:35:22Z", "type": "commit"}, {"oid": "1b3468619f66ee3714b476681f761a0c92dff658", "url": "https://github.com/openhab/openhab-addons/commit/1b3468619f66ee3714b476681f761a0c92dff658", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T13:25:14Z", "type": "commit"}, {"oid": "ce6b1b83511266993e7e74b54122b54654265a79", "url": "https://github.com/openhab/openhab-addons/commit/ce6b1b83511266993e7e74b54122b54654265a79", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T15:39:12Z", "type": "commit"}, {"oid": "ca3481541399089a8850bdc845723806ad92a28d", "url": "https://github.com/openhab/openhab-addons/commit/ca3481541399089a8850bdc845723806ad92a28d", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-08-26T16:57:47Z", "type": "commit"}, {"oid": "9d1ac35725796cf41e0cd1cdd497c899ab06930c", "url": "https://github.com/openhab/openhab-addons/commit/9d1ac35725796cf41e0cd1cdd497c899ab06930c", "message": "fix thread naming convention\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-08-26T17:09:42Z", "type": "commit"}, {"oid": "31227c502d4697366429850b34557b7cebf44831", "url": "https://github.com/openhab/openhab-addons/commit/31227c502d4697366429850b34557b7cebf44831", "message": "Merge branch '2.5.x' of https://github.com/openhab/openhab-addons into 2.5.x", "committedDate": "2020-08-26T20:01:12Z", "type": "commit"}, {"oid": "67bb699dd5d433cc3428720005b61e6726193933", "url": "https://github.com/openhab/openhab-addons/commit/67bb699dd5d433cc3428720005b61e6726193933", "message": "Merge branch '2.5.x' into MonopriceAudio", "committedDate": "2020-08-26T20:03:28Z", "type": "commit"}, {"oid": "86a5327cb44c5f0ed3f4640a439df62954d8ab33", "url": "https://github.com/openhab/openhab-addons/commit/86a5327cb44c5f0ed3f4640a439df62954d8ab33", "message": "Merge remote-tracking branch 'upstream/2.5.x' into 2.5.x", "committedDate": "2020-09-03T00:24:02Z", "type": "commit"}, {"oid": "ad2731c230b2c87628de459b77f03082da06b656", "url": "https://github.com/openhab/openhab-addons/commit/ad2731c230b2c87628de459b77f03082da06b656", "message": "fix merge conflicts\n\nSigned-off-by: Michael Lobstein <michael.lobstein@gmail.com>", "committedDate": "2020-09-03T00:36:59Z", "type": "commit"}]}