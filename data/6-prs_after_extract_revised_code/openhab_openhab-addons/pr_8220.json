{"pr_number": 8220, "pr_title": "[avmfritz] added call monitor support", "pr_createdAt": "2020-07-28T20:38:46Z", "pr_url": "https://github.com/openhab/openhab-addons/pull/8220", "timeline": [{"oid": "7b24f8e23dd4b795fcda8080f0f18f8cd3be2029", "url": "https://github.com/openhab/openhab-addons/commit/7b24f8e23dd4b795fcda8080f0f18f8cd3be2029", "message": "added call monitor support\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-07-28T20:37:48Z", "type": "commit"}, {"oid": "cb5804546ae9809dc3f8d2c9228b4fcd47b53c43", "url": "https://github.com/openhab/openhab-addons/commit/cb5804546ae9809dc3f8d2c9228b4fcd47b53c43", "message": "addressed SAT findings\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-07-28T21:35:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NTAxOA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r462065018", "bodyText": "I would change the order to \"RING\".equals(callType) to avoid NPEs later on", "author": "DerOetzi", "createdAt": "2020-07-29T06:23:21Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.avmfritz.internal.callmonitor;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Call Events received from a fritzbox.\n+ *\n+ * 12.07.20 09:11:30;RING;0;0171123456;888888;SIP2;\n+ * 12.07.20 09:13:40;DISCONNECT;0;0;\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CallEvent {\n+\n+    private final String rawEvent;\n+    private final String timestamp;\n+    private final String callType;\n+    private final String id;\n+    private final String externalNo;\n+    private final @Nullable String internalNo;\n+    private final @Nullable String connectionType;\n+    private final @Nullable String line;\n+\n+    public CallEvent(String rawEvent) {\n+        this.rawEvent = rawEvent;\n+\n+        String[] fields = rawEvent.split(\";\");\n+        if (fields.length < 4) {\n+            throw new IllegalArgumentException(\"Cannot parse call event: \" + rawEvent);\n+        }\n+\n+        timestamp = fields[0];\n+        callType = fields[1];\n+        id = fields[2];\n+\n+        if (callType.equals(\"RING\")) {", "originalCommit": "cb5804546ae9809dc3f8d2c9228b4fcd47b53c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyNTM3OA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r464125378", "bodyText": "callType is NonNull, so there is no risk.", "author": "kaikreuzer", "createdAt": "2020-08-02T21:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NTAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwMzkyNQ==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466903925", "bodyText": "True for the moment, until someone will change something in the future ;-) and doesn't look on the lines below line 48. For example format changes on the raw line by AVM or something similiar. From aspects of change-proof code I would prefer if you turn around those statements. But this is still my personal suggestion!", "author": "DerOetzi", "createdAt": "2020-08-07T08:38:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NTAxOA=="}], "type": "inlineReview", "revised_code": {"commit": "355184b1a91e340a557f8eccf2d201208ba1151a", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java\nindex c323f52706..e3973852ec 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java\n\n@@ -30,10 +30,10 @@ public class CallEvent {\n     private final String timestamp;\n     private final String callType;\n     private final String id;\n-    private final String externalNo;\n-    private final @Nullable String internalNo;\n-    private final @Nullable String connectionType;\n-    private final @Nullable String line;\n+    private @Nullable String externalNo;\n+    private @Nullable String internalNo;\n+    private @Nullable String connectionType;\n+    private @Nullable String line;\n \n     public CallEvent(String rawEvent) {\n         this.rawEvent = rawEvent;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NzU4NA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r462067584", "bodyText": "I think 5 seconds is really long reaction time for binding, Maybe this should be a configuration Parameter", "author": "DerOetzi", "createdAt": "2020-07-29T06:29:33Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.avmfritz.internal.callmonitor;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringListType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.avmfritz.internal.AVMFritzBindingConstants;\n+import org.openhab.binding.avmfritz.internal.handler.BoxHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class handles all communication with the call monitor port of the fritzbox.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CallMonitor {\n+\n+    protected final Logger logger = LoggerFactory.getLogger(CallMonitor.class);\n+\n+    // port number to connect to fritzbox\n+    private final int MONITOR_PORT = 1012;\n+\n+    private @Nullable CallMonitorThread monitorThread;\n+    private ScheduledFuture<?> reconnectJob;\n+\n+    private String ip;\n+    private BoxHandler handler;\n+\n+    public CallMonitor(String ip, BoxHandler handler, ScheduledExecutorService scheduler) {\n+        this.ip = ip;\n+        this.handler = handler;\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            stopThread();\n+\n+            // Wait before reconnect\n+            try {\n+                Thread.sleep(5000L);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            // create a new thread for listening to the FritzBox\n+            logger.debug(\"Reconnecting to Fritzbox call monitor port.\");\n+            monitorThread = new CallMonitorThread();\n+            monitorThread.start();\n+        }, 0, 2, TimeUnit.HOURS);\n+    }\n+\n+    /**\n+     * Cancel the reconnect job.\n+     */\n+    public void dispose() {\n+        reconnectJob.cancel(true);\n+    }\n+\n+    public class CallMonitorThread extends Thread {\n+\n+        // Socket to connect\n+        private @Nullable Socket socket;\n+\n+        // Thread control flag\n+        private boolean interrupted = false;\n+\n+        // time to wait before reconnecting\n+        private long reconnectTime = 60000L;\n+\n+        public CallMonitorThread() {\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!interrupted) {\n+                BufferedReader reader = null;\n+                try {\n+                    logger.debug(\"Callmonitor thread [{}] attempting connection to FritzBox on {}:{}.\",\n+                            Thread.currentThread().getId(), ip, MONITOR_PORT);\n+                    socket = new Socket(ip, MONITOR_PORT);\n+                    reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    // reset the retry interval\n+                    reconnectTime = 60000L;\n+                } catch (Exception e) {\n+                    logger.warn(\"Error attempting to connect to FritzBox. Retrying in {} seconds\",\n+                            reconnectTime / 1000L, e);\n+                    try {\n+                        Thread.sleep(reconnectTime);\n+                    } catch (InterruptedException ex) {\n+                        interrupted = true;\n+                    }\n+                    // wait another more minute the next time\n+                    reconnectTime += 60000L;\n+                }\n+                if (reader != null) {\n+                    logger.info(\"Connected to FritzBox call monitor at {}:{}.\", ip, MONITOR_PORT);\n+                    while (!interrupted) {\n+                        try {\n+                            String line = reader.readLine();\n+                            if (line != null) {\n+                                logger.debug(\"Received raw call string from fbox: {}\", line);\n+                                CallEvent ce = new CallEvent(line);\n+                                handleCallEvent(ce);\n+                            }\n+                        } catch (IOException e) {\n+                            if (interrupted) {\n+                                logger.debug(\"Lost connection to Fritzbox because of an interrupt.\");\n+                            } else {\n+                                logger.warn(\"Lost connection to FritzBox: {}\", e.getMessage());\n+                            }\n+                            break;\n+                        } finally {\n+                            try {\n+                                sleep(5000L);", "originalCommit": "cb5804546ae9809dc3f8d2c9228b4fcd47b53c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyNTQzMw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r464125433", "bodyText": "I changed it to 1 second. Don't think there's any need to make it configurable.", "author": "kaikreuzer", "createdAt": "2020-08-02T21:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NzU4NA=="}], "type": "inlineReview", "revised_code": {"commit": "355184b1a91e340a557f8eccf2d201208ba1151a", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java\nindex 750d814007..6111599aa4 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java\n\n@@ -23,6 +23,8 @@ import java.util.concurrent.TimeUnit;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n import org.eclipse.smarthome.core.library.types.StringListType;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n import org.eclipse.smarthome.core.types.UnDefType;\n import org.openhab.binding.avmfritz.internal.AVMFritzBindingConstants;\n import org.openhab.binding.avmfritz.internal.handler.BoxHandler;\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2OTQ4Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r462069486", "bodyText": "If I remind correctly call monitor is not activated by default on the fritz box. So maybe this should be although configurable whether call monitor should be initiated. We could reuse the config parameter above.", "author": "DerOetzi", "createdAt": "2020-07-29T06:34:25Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java", "diffHunk": "@@ -35,4 +42,24 @@ public BoxHandler(Bridge bridge, HttpClient httpClient,\n             AVMFritzDynamicCommandDescriptionProvider commandDescriptionProvider) {\n         super(bridge, httpClient, commandDescriptionProvider);\n     }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+        String ip = getConfigAs(AVMFritzBoxConfiguration.class).ipAddress;\n+        callMonitor = new CallMonitor(ip, this, scheduler);", "originalCommit": "cb5804546ae9809dc3f8d2c9228b4fcd47b53c43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDEyNTQ2Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r464125466", "bodyText": "I now only instantiate the CallMonitor connection, if one of the related channels is linked.", "author": "kaikreuzer", "createdAt": "2020-08-02T21:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2OTQ4Ng=="}], "type": "inlineReview", "revised_code": {"commit": "355184b1a91e340a557f8eccf2d201208ba1151a", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\nindex d449189bea..1b1e3c41e3 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n\n@@ -44,10 +60,31 @@ public class BoxHandler extends AVMFritzBaseBridgeHandler {\n     }\n \n     @Override\n-    public void initialize() {\n-        super.initialize();\n-        String ip = getConfigAs(AVMFritzBoxConfiguration.class).ipAddress;\n-        callMonitor = new CallMonitor(ip, this, scheduler);\n+    protected void initConnections() {\n+        AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n+        if (this.callMonitor == null && (isLinked(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE)\n+                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING)\n+                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING)\n+                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_STATE))) {\n+            this.callMonitor = new CallMonitor(config.ipAddress, this, scheduler);\n+        }\n+        if (this.connection == null) {\n+            if (config.password != null) {\n+                this.connection = new FritzAhaWebInterface(config, this, httpClient);\n+                stopPolling();\n+                startPolling();\n+            } else {\n+                if (!callChannelsLinked()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"The 'password' parameter must be configured to use the AHA features.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean callChannelsLinked() {\n+        return getThing().getChannels().stream()\n+                .filter(c -> isLinked(c.getUID()) && CALL_CHANNELS.contains(c.getUID().getId())).count() > 0;\n     }\n \n     @Override\n"}}, {"oid": "355184b1a91e340a557f8eccf2d201208ba1151a", "url": "https://github.com/openhab/openhab-addons/commit/355184b1a91e340a557f8eccf2d201208ba1151a", "message": "added missing bits and pieces\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-02T21:26:04Z", "type": "commit"}, {"oid": "7a1e861a6011212408363175255117d54ed0fe79", "url": "https://github.com/openhab/openhab-addons/commit/7a1e861a6011212408363175255117d54ed0fe79", "message": "fixed SAT error\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-02T21:31:32Z", "type": "commit"}, {"oid": "1a95b277838c38642d23ed84cb1135825055efb7", "url": "https://github.com/openhab/openhab-addons/commit/1a95b277838c38642d23ed84cb1135825055efb7", "message": "applied thread naming convention\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-02T21:44:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjk1OQ==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r465932959", "bodyText": "Don't we have to UNDEF the other channels all the time? Otherwise their state will remain on old value until the next call / event.", "author": "cweitkamp", "createdAt": "2020-08-05T18:49:47Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.avmfritz.internal.callmonitor;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.Socket;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.StringListType;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.avmfritz.internal.AVMFritzBindingConstants;\n+import org.openhab.binding.avmfritz.internal.handler.BoxHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This class handles all communication with the call monitor port of the fritzbox.\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CallMonitor {\n+\n+    protected final Logger logger = LoggerFactory.getLogger(CallMonitor.class);\n+\n+    // port number to connect to fritzbox\n+    private final int MONITOR_PORT = 1012;\n+\n+    private @Nullable CallMonitorThread monitorThread;\n+    private ScheduledFuture<?> reconnectJob;\n+\n+    private String ip;\n+    private BoxHandler handler;\n+\n+    public CallMonitor(String ip, BoxHandler handler, ScheduledExecutorService scheduler) {\n+        this.ip = ip;\n+        this.handler = handler;\n+        reconnectJob = scheduler.scheduleWithFixedDelay(() -> {\n+            stopThread();\n+\n+            // Wait before reconnect\n+            try {\n+                Thread.sleep(5000L);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            // create a new thread for listening to the FritzBox\n+            CallMonitorThread thread = new CallMonitorThread();\n+            thread.setName(\"OH-binding-\" + handler.getThing().getUID().getAsString());\n+            thread.start();\n+            this.monitorThread = thread;\n+        }, 0, 2, TimeUnit.HOURS);\n+    }\n+\n+    /**\n+     * Cancel the reconnect job.\n+     */\n+    public void dispose() {\n+        reconnectJob.cancel(true);\n+    }\n+\n+    public class CallMonitorThread extends Thread {\n+\n+        // Socket to connect\n+        private @Nullable Socket socket;\n+\n+        // Thread control flag\n+        private boolean interrupted = false;\n+\n+        // time to wait before reconnecting\n+        private long reconnectTime = 60000L;\n+\n+        public CallMonitorThread() {\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!interrupted) {\n+                BufferedReader reader = null;\n+                try {\n+                    logger.debug(\"Callmonitor thread [{}] attempting connection to FritzBox on {}:{}.\",\n+                            Thread.currentThread().getId(), ip, MONITOR_PORT);\n+                    socket = new Socket(ip, MONITOR_PORT);\n+                    reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n+                    // reset the retry interval\n+                    reconnectTime = 60000L;\n+                } catch (Exception e) {\n+                    handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Cannot connect to Fritz!Box call monitor - make sure to enable it!\");\n+                    logger.debug(\"Error attempting to connect to FritzBox. Retrying in {} seconds\",\n+                            reconnectTime / 1000L, e);\n+                    try {\n+                        Thread.sleep(reconnectTime);\n+                    } catch (InterruptedException ex) {\n+                        interrupted = true;\n+                    }\n+                    // wait another more minute the next time\n+                    reconnectTime += 60000L;\n+                }\n+                if (reader != null) {\n+                    logger.debug(\"Connected to FritzBox call monitor at {}:{}.\", ip, MONITOR_PORT);\n+                    handler.setStatusInfo(ThingStatus.ONLINE, ThingStatusDetail.NONE, null);\n+                    while (!interrupted) {\n+                        try {\n+                            String line = reader.readLine();\n+                            if (line != null) {\n+                                logger.debug(\"Received raw call string from fbox: {}\", line);\n+                                CallEvent ce = new CallEvent(line);\n+                                handleCallEvent(ce);\n+                            }\n+                        } catch (IOException e) {\n+                            if (interrupted) {\n+                                logger.debug(\"Lost connection to Fritzbox because of an interrupt.\");\n+                            } else {\n+                                handler.setStatusInfo(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                        \"Lost connection to Fritz!Box: \" + e.getMessage());\n+                            }\n+                            break;\n+                        } finally {\n+                            try {\n+                                sleep(1000L);\n+                            } catch (InterruptedException e) {\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Close socket and stop running thread.\n+         */\n+        @Override\n+        public void interrupt() {\n+            interrupted = true;\n+            if (socket != null) {\n+                try {\n+                    socket.close();\n+                    logger.debug(\"Socket to FritzBox closed.\");\n+                } catch (IOException e) {\n+                    logger.warn(\"Failed to close connection to FritzBox.\", e);\n+                }\n+            } else {\n+                logger.debug(\"Socket to FritzBox not open, therefore not closing it.\");\n+            }\n+        }\n+\n+        /**\n+         * Handle call event and update item as required.\n+         *\n+         * @param ce call event to process\n+         */\n+        private void handleCallEvent(CallEvent ce) {\n+            if (ce.getCallType().equals(\"DISCONNECT\")) {\n+                // reset states of call monitor channels\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING, UnDefType.NULL);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING, UnDefType.NULL);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE, UnDefType.NULL);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_STATE,\n+                        AVMFritzBindingConstants.CALL_STATE_IDLE);\n+            } else if (ce.getCallType().equals(\"RING\")) { // first event when call is incoming\n+                StringListType state = new StringListType(ce.getInternalNo(), ce.getExternalNo());\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING, state);", "originalCommit": "1a95b277838c38642d23ed84cb1135825055efb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwNjIyMw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466006223", "bodyText": "good point.", "author": "kaikreuzer", "createdAt": "2020-08-05T21:10:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMjQ1Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466602456", "bodyText": "Sry to be nit-picking on this. According our guidelines we should set the state to UnDefType.UNDEF.", "author": "cweitkamp", "createdAt": "2020-08-06T18:22:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1OTEwNw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466659107", "bodyText": "Which guideline is that? UNDEF is to be used in case the state cannot be mapped to any sensible value and NULL, if no state exists at all (yes, this might be debatable here, but it seems both values can be found arguments for). But if you prefer UNDEF, I can change it.", "author": "kaikreuzer", "createdAt": "2020-08-06T20:11:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MTgyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r467141821", "bodyText": "Hm, ... I always thought the state should only be NULL after restart of OH and otherwise one always should use UNDEF if there is no valid data available to set.", "author": "cweitkamp", "createdAt": "2020-08-07T16:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjk1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQzNzkzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r467437932", "bodyText": "In most cases that is the case this way. But there are a few exceptional cases, where it is better to say that a channel simply does not have ANY state and then NULL is the better match. E.g. when a device operates in a mode, where the channel does not make any functional sense (yeah, ideally, the channel should then be dynamically completely removed).\nBut yeah, I am thus fine with UNDEF here for the call channels. In 1.x, the CallType had a dedicated EMPTY value, but this does not exist for us anymore.", "author": "kaikreuzer", "createdAt": "2020-08-08T10:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMjk1OQ=="}], "type": "inlineReview", "revised_code": {"commit": "e775103afd10247088338906d661432a199b8834", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java\nindex 57b4d02819..0f8eeae3dd 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallMonitor.java\n\n@@ -179,16 +179,22 @@ public class CallMonitor {\n             } else if (ce.getCallType().equals(\"RING\")) { // first event when call is incoming\n                 StringListType state = new StringListType(ce.getInternalNo(), ce.getExternalNo());\n                 handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING, state);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING, UnDefType.NULL);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE, UnDefType.NULL);\n                 handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_STATE,\n                         AVMFritzBindingConstants.CALL_STATE_RINGING);\n             } else if (ce.getCallType().equals(\"CONNECT\")) { // when call is answered/running\n                 StringListType state = new StringListType(ce.getExternalNo(), \"\");\n                 handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE, state);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING, UnDefType.NULL);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING, UnDefType.NULL);\n                 handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_STATE,\n                         AVMFritzBindingConstants.CALL_STATE_ACTIVE);\n             } else if (ce.getCallType().equals(\"CALL\")) { // outgoing call\n                 StringListType state = new StringListType(ce.getExternalNo(), ce.getInternalNo());\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING, UnDefType.NULL);\n                 handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING, state);\n+                handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE, UnDefType.NULL);\n                 handler.updateState(AVMFritzBindingConstants.CHANNEL_CALL_STATE,\n                         AVMFritzBindingConstants.CALL_STATE_DIALING);\n             }\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMzkwMw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r465933903", "bodyText": "This should have org.eclipse.smarthome.core.thing namespace.", "author": "cweitkamp", "createdAt": "2020-08-05T18:51:32Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java", "diffHunk": "@@ -59,6 +59,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import io.netty.channel.Channel;", "originalCommit": "1a95b277838c38642d23ed84cb1135825055efb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwOTE1Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466009157", "bodyText": "Oops. It can actually be removed as it isn't used at all. No idea why it was there...", "author": "kaikreuzer", "createdAt": "2020-08-05T21:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkzMzkwMw=="}], "type": "inlineReview", "revised_code": {"commit": "e775103afd10247088338906d661432a199b8834", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\nindex 8de87eb183..869c9d32ce 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\n\n@@ -59,8 +59,6 @@ import org.openhab.binding.avmfritz.internal.hardware.callbacks.FritzAhaUpdateTe\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import io.netty.channel.Channel;\n-\n /**\n  * Abstract handler for a FRITZ! bridge. Handles polling of values from AHA devices.\n  *\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MDIyMQ==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r465940221", "bodyText": "Should we dispose the CallMonitor if all call monitor channels are unlinked?", "author": "cweitkamp", "createdAt": "2020-08-05T19:02:53Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java", "diffHunk": "@@ -140,13 +141,26 @@ public void initialize() {\n         }\n \n         if (configValid) {\n-            this.connection = new FritzAhaWebInterface(config, this, httpClient);\n+            updateStatus(ThingStatus.UNKNOWN);\n+            initConnections();\n+        }\n+    }\n \n+    protected synchronized void initConnections() {\n+        AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n+        if (this.connection == null) {\n+            this.connection = new FritzAhaWebInterface(config, this, httpClient);\n             stopPolling();\n             startPolling();\n         }\n     }\n \n+    @Override\n+    public void channelLinked(ChannelUID channelUID) {", "originalCommit": "1a95b277838c38642d23ed84cb1135825055efb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxNTMxMA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466015310", "bodyText": "done.", "author": "kaikreuzer", "createdAt": "2020-08-05T21:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MDIyMQ=="}], "type": "inlineReview", "revised_code": {"commit": "e775103afd10247088338906d661432a199b8834", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\nindex 8de87eb183..869c9d32ce 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\n\n@@ -142,25 +140,37 @@ public abstract class AVMFritzBaseBridgeHandler extends BaseBridgeHandler {\n \n         if (configValid) {\n             updateStatus(ThingStatus.UNKNOWN);\n-            initConnections();\n+            manageConnections();\n         }\n     }\n \n-    protected synchronized void initConnections() {\n+    protected synchronized void manageConnections() {\n         AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n         if (this.connection == null) {\n             this.connection = new FritzAhaWebInterface(config, this, httpClient);\n             stopPolling();\n             startPolling();\n+        } else {\n+            if (!getThing().getChannels().stream().filter(c -> isLinked(c.getUID())).findAny().isPresent()) {\n+                // no channels are linked anymore\n+                stopPolling();\n+                this.connection = null;\n+            }\n         }\n     }\n \n     @Override\n     public void channelLinked(ChannelUID channelUID) {\n-        initConnections();\n+        manageConnections();\n         super.channelLinked(channelUID);\n     }\n \n+    @Override\n+    public void channelUnlinked(ChannelUID channelUID) {\n+        manageConnections();\n+        super.channelUnlinked(channelUID);\n+    }\n+\n     @Override\n     public void dispose() {\n         stopPolling();\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTM3NA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r465941374", "bodyText": "You can reuse the callChannelsLinked() method here. Maybe store its result in local variable and access it later.", "author": "cweitkamp", "createdAt": "2020-08-05T19:05:07Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java", "diffHunk": "@@ -35,4 +58,45 @@ public BoxHandler(Bridge bridge, HttpClient httpClient,\n             AVMFritzDynamicCommandDescriptionProvider commandDescriptionProvider) {\n         super(bridge, httpClient, commandDescriptionProvider);\n     }\n+\n+    @Override\n+    protected void initConnections() {\n+        AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n+        if (this.callMonitor == null && (isLinked(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE)", "originalCommit": "1a95b277838c38642d23ed84cb1135825055efb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwODU1NQ==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466008555", "bodyText": "Indeed, I had moved that method from another class and forgot to make use of it here. As there are only 5 channels on this bridge, I don't cache the result as I don't think it has a big impact.", "author": "kaikreuzer", "createdAt": "2020-08-05T21:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MTM3NA=="}], "type": "inlineReview", "revised_code": {"commit": "e775103afd10247088338906d661432a199b8834", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\nindex 1b1e3c41e3..7501205bf3 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n\n@@ -60,13 +60,14 @@ public class BoxHandler extends AVMFritzBaseBridgeHandler {\n     }\n \n     @Override\n-    protected void initConnections() {\n+    protected void manageConnections() {\n         AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n-        if (this.callMonitor == null && (isLinked(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE)\n-                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING)\n-                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING)\n-                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_STATE))) {\n+        if (this.callMonitor == null && callChannelsLinked()) {\n             this.callMonitor = new CallMonitor(config.ipAddress, this, scheduler);\n+        } else if (this.callMonitor != null && !callChannelsLinked()) {\n+            CallMonitor cm = this.callMonitor;\n+            cm.dispose();\n+            this.callMonitor = null;\n         }\n         if (this.connection == null) {\n             if (config.password != null) {\n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MjMyOA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r465942328", "bodyText": "I do not understand this? Why do you need to override it and just call the super method?", "author": "cweitkamp", "createdAt": "2020-08-05T19:07:01Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java", "diffHunk": "@@ -35,4 +58,45 @@ public BoxHandler(Bridge bridge, HttpClient httpClient,\n             AVMFritzDynamicCommandDescriptionProvider commandDescriptionProvider) {\n         super(bridge, httpClient, commandDescriptionProvider);\n     }\n+\n+    @Override\n+    protected void initConnections() {\n+        AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n+        if (this.callMonitor == null && (isLinked(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE)\n+                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING)\n+                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING)\n+                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_STATE))) {\n+            this.callMonitor = new CallMonitor(config.ipAddress, this, scheduler);\n+        }\n+        if (this.connection == null) {\n+            if (config.password != null) {\n+                this.connection = new FritzAhaWebInterface(config, this, httpClient);\n+                stopPolling();\n+                startPolling();\n+            } else {\n+                if (!callChannelsLinked()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"The 'password' parameter must be configured to use the AHA features.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private boolean callChannelsLinked() {\n+        return getThing().getChannels().stream()\n+                .filter(c -> isLinked(c.getUID()) && CALL_CHANNELS.contains(c.getUID().getId())).count() > 0;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (callMonitor != null) {\n+            callMonitor.dispose();\n+        }\n+        super.dispose();\n+    }\n+\n+    @Override\n+    public void updateState(String channelID, State state) {", "originalCommit": "1a95b277838c38642d23ed84cb1135825055efb7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAwOTYzMg==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466009632", "bodyText": "Because we make the method public (while being protected in the super class), so that the CallMonitor thread can access it on the handler object.", "author": "kaikreuzer", "createdAt": "2020-08-05T21:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk0MjMyOA=="}], "type": "inlineReview", "revised_code": {"commit": "e775103afd10247088338906d661432a199b8834", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\nindex 1b1e3c41e3..7501205bf3 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n\n@@ -60,13 +60,14 @@ public class BoxHandler extends AVMFritzBaseBridgeHandler {\n     }\n \n     @Override\n-    protected void initConnections() {\n+    protected void manageConnections() {\n         AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n-        if (this.callMonitor == null && (isLinked(AVMFritzBindingConstants.CHANNEL_CALL_ACTIVE)\n-                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_INCOMING)\n-                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_OUTGOING)\n-                || isLinked(AVMFritzBindingConstants.CHANNEL_CALL_STATE))) {\n+        if (this.callMonitor == null && callChannelsLinked()) {\n             this.callMonitor = new CallMonitor(config.ipAddress, this, scheduler);\n+        } else if (this.callMonitor != null && !callChannelsLinked()) {\n+            CallMonitor cm = this.callMonitor;\n+            cm.dispose();\n+            this.callMonitor = null;\n         }\n         if (this.connection == null) {\n             if (config.password != null) {\n"}}, {"oid": "e775103afd10247088338906d661432a199b8834", "url": "https://github.com/openhab/openhab-addons/commit/e775103afd10247088338906d661432a199b8834", "message": "addressed review comments\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-05T21:31:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzQ5Nw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466603497", "bodyText": "This method stops the whole polling job for updating all devices. We should not do that.", "author": "cweitkamp", "createdAt": "2020-08-06T18:24:00Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java", "diffHunk": "@@ -140,13 +139,38 @@ public void initialize() {\n         }\n \n         if (configValid) {\n-            this.connection = new FritzAhaWebInterface(config, this, httpClient);\n+            updateStatus(ThingStatus.UNKNOWN);\n+            manageConnections();\n+        }\n+    }\n \n+    protected synchronized void manageConnections() {\n+        AVMFritzBoxConfiguration config = getConfigAs(AVMFritzBoxConfiguration.class);\n+        if (this.connection == null) {\n+            this.connection = new FritzAhaWebInterface(config, this, httpClient);\n             stopPolling();\n             startPolling();\n+        } else {\n+            if (!getThing().getChannels().stream().filter(c -> isLinked(c.getUID())).findAny().isPresent()) {\n+                // no channels are linked anymore\n+                stopPolling();", "originalCommit": "e775103afd10247088338906d661432a199b8834", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1OTc3MA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466659770", "bodyText": "Oh, you're right, thanks for noticing!", "author": "kaikreuzer", "createdAt": "2020-08-06T20:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwMzQ5Nw=="}], "type": "inlineReview", "revised_code": {"commit": "8c847834491afd912aacf7f3f744af1a7d125ff0", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\nindex 869c9d32ce..7ab5373f98 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/AVMFritzBaseBridgeHandler.java\n\n@@ -150,12 +150,6 @@ public abstract class AVMFritzBaseBridgeHandler extends BaseBridgeHandler {\n             this.connection = new FritzAhaWebInterface(config, this, httpClient);\n             stopPolling();\n             startPolling();\n-        } else {\n-            if (!getThing().getChannels().stream().filter(c -> isLinked(c.getUID())).findAny().isPresent()) {\n-                // no channels are linked anymore\n-                stopPolling();\n-                this.connection = null;\n-            }\n         }\n     }\n \n"}}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYwNDIzNg==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466604236", "bodyText": "see above", "author": "cweitkamp", "createdAt": "2020-08-06T18:25:14Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java", "diffHunk": "@@ -79,6 +80,12 @@ protected void initConnections() {\n                             \"The 'password' parameter must be configured to use the AHA features.\");\n                 }\n             }\n+        } else {\n+            if (!getThing().getChannels().stream().filter(c -> isLinked(c.getUID())).findAny().isPresent()) {\n+                // no channels are linked anymore\n+                stopPolling();", "originalCommit": "e775103afd10247088338906d661432a199b8834", "replyToReviewId": null, "replies": null, "type": "inlineReview", "revised_code": {"commit": "8c847834491afd912aacf7f3f744af1a7d125ff0", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\nindex 7501205bf3..6f6125a2e2 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/handler/BoxHandler.java\n\n@@ -80,12 +80,6 @@ public class BoxHandler extends AVMFritzBaseBridgeHandler {\n                             \"The 'password' parameter must be configured to use the AHA features.\");\n                 }\n             }\n-        } else {\n-            if (!getThing().getChannels().stream().filter(c -> isLinked(c.getUID())).findAny().isPresent()) {\n-                // no channels are linked anymore\n-                stopPolling();\n-                this.connection = null;\n-            }\n         }\n     }\n \n"}}, {"oid": "8c847834491afd912aacf7f3f744af1a7d125ff0", "url": "https://github.com/openhab/openhab-addons/commit/8c847834491afd912aacf7f3f744af1a7d125ff0", "message": "addressed further review comments\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-06T20:16:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNDY3Ng==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r466904676", "bodyText": "Codestyle check: Please add a new line", "author": "DerOetzi", "createdAt": "2020-08-07T08:40:20Z", "path": "bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.avmfritz.internal.callmonitor;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Call Events received from a fritzbox.\n+ *\n+ * 12.07.20 09:11:30;RING;0;0171123456;888888;SIP2;\n+ * 12.07.20 09:13:40;DISCONNECT;0;0;\n+ *\n+ * @author Kai Kreuzer - Initial contribution\n+ */\n+@NonNullByDefault\n+public class CallEvent {\n+\n+    private final String rawEvent;\n+    private final String timestamp;\n+    private final String callType;\n+    private final String id;\n+    private @Nullable String externalNo;\n+    private @Nullable String internalNo;\n+    private @Nullable String connectionType;\n+    private @Nullable String line;\n+\n+    public CallEvent(String rawEvent) {\n+        this.rawEvent = rawEvent;\n+\n+        String[] fields = rawEvent.split(\";\");\n+        if (fields.length < 4) {\n+            throw new IllegalArgumentException(\"Cannot parse call event: \" + rawEvent);\n+        }\n+\n+        timestamp = fields[0];\n+        callType = fields[1];\n+        id = fields[2];\n+\n+        if (callType.equals(\"RING\")) {\n+            externalNo = fields[3];\n+            internalNo = fields[4];\n+            connectionType = fields[5];\n+        } else if (callType.equals(\"CONNECT\")) {\n+            line = fields[3];\n+            if (fields.length > 4) {\n+                externalNo = fields[4];\n+            } else {\n+                externalNo = \"Unknown\";\n+            }\n+        } else if (callType.equals(\"CALL\")) {\n+            line = fields[3];\n+            internalNo = fields[4];\n+            externalNo = fields[5];\n+            connectionType = fields[6];\n+        } else if (callType.equals(\"DISCONNECT\")) {\n+            // no fields to set\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid call type: \" + callType);\n+        }\n+    }\n+\n+    public @Nullable String getLine() {\n+        return line;\n+    }\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public String getCallType() {\n+        return callType;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public @Nullable String getExternalNo() {\n+        return externalNo;\n+    }\n+\n+    public @Nullable String getInternalNo() {\n+        return internalNo;\n+    }\n+\n+    public @Nullable String getConnectionType() {\n+        return connectionType;\n+    }\n+\n+    public String getRaw() {\n+        return rawEvent;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CallEvent [timestamp=\" + timestamp + \", callType=\" + callType + \", id=\" + id + \", externalNo=\"\n+                + externalNo + \", internalNo=\" + internalNo + \", connectionType=\" + connectionType + \", line=\" + line\n+                + \"]\";\n+    }\n+}", "originalCommit": "8c847834491afd912aacf7f3f744af1a7d125ff0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE0MTg2OA==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r467141868", "bodyText": "I'd say just run mvn spotless:apply in the bundles folder. It will do the rest for you.", "author": "cweitkamp", "createdAt": "2020-08-07T16:23:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNDY3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzQzNTc4Mw==", "url": "https://github.com/openhab/openhab-addons/pull/8220#discussion_r467435783", "bodyText": "Done.", "author": "kaikreuzer", "createdAt": "2020-08-08T10:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNDY3Ng=="}], "type": "inlineReview", "revised_code": {"commit": "74e23615b5bbcf79ccbe0a71a6a5b6b393a51349", "chunk": "diff --git a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java\nindex e3973852ec..3c82b67908 100644\n--- a/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java\n+++ b/bundles/org.openhab.binding.avmfritz/src/main/java/org/openhab/binding/avmfritz/internal/callmonitor/CallEvent.java\n\n@@ -108,4 +108,4 @@ public class CallEvent {\n                 + externalNo + \", internalNo=\" + internalNo + \", connectionType=\" + connectionType + \", line=\" + line\n                 + \"]\";\n     }\n-}\n\\ No newline at end of file\n+}\n"}}, {"oid": "74e23615b5bbcf79ccbe0a71a6a5b6b393a51349", "url": "https://github.com/openhab/openhab-addons/commit/74e23615b5bbcf79ccbe0a71a6a5b6b393a51349", "message": "applied spotless formatter\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-08T10:02:16Z", "type": "commit"}, {"oid": "b746abf90085a31de11f7b7667460da1a89b8d1e", "url": "https://github.com/openhab/openhab-addons/commit/b746abf90085a31de11f7b7667460da1a89b8d1e", "message": "added note about deactivation of call monitor\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-08T10:11:18Z", "type": "commit"}, {"oid": "3dfb1bb20495a603eb720cd30620d972b77a35d6", "url": "https://github.com/openhab/openhab-addons/commit/3dfb1bb20495a603eb720cd30620d972b77a35d6", "message": "improved status detail message\n\nSigned-off-by: Kai Kreuzer <kai@openhab.org>", "committedDate": "2020-08-08T10:16:59Z", "type": "commit"}]}